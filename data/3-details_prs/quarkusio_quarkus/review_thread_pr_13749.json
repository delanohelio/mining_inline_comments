{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0MzUyMjQy", "number": 13749, "reviewThreads": {"totalCount": 38, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMDozOTo1MlrOFCQFOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDo1MTozMFrOFC2-3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTA0OTUyOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMDozOTo1MlrOIBS5Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMDo1OTo1OVrOIBTxmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIyOTA4Nw==", "bodyText": "In such case, what's the scope of the bean?", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538229087", "createdAt": "2020-12-08T10:39:52Z", "author": {"login": "Ladicek"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI0MzQ4Mg==", "bodyText": "It should be the same as with AdditionalBeanBuildItem, i.e. @Dependent. I'll add a note...", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538243482", "createdAt": "2020-12-08T10:59:59Z", "author": {"login": "mkouba"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIyOTA4Nw=="}, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTE1MjU0OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMTowMToyM1rOIBT07A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMjowNjoyNlrOIBWxfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI0NDMzMg==", "bodyText": "This build item probably shouldn't be used in some earlier phases? Maybe better to spell it out?", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538244332", "createdAt": "2020-12-08T11:01:23Z", "author": {"login": "Ladicek"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI2MDk0Mg==", "bodyText": "Currently, it's produced during the bean registration phase, after bean discovery but before the synthetic components are registered. In fact, the build items dependency mechanism ensures that a build step that injects this build item is executed after the bean registration phase.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538260942", "createdAt": "2020-12-08T11:28:29Z", "author": {"login": "mkouba"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI0NDMzMg=="}, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI5MjYwNw==", "bodyText": "Gotcha. It felt weird in the flow of the text, because just a few paragraphs above, you're talking about an AnnotationsTransformerBuildItem, and I'm pretty sure you can't have a build step that consumes TransformedAnnotationsBuildItem and, at the same time, produces AnnotationsTransformerBuildItem.\nBut perhaps it's just me and that limitation is obvious :-)", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538292607", "createdAt": "2020-12-08T12:06:26Z", "author": {"login": "Ladicek"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI0NDMzMg=="}, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTE2MTM2OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMTowMzoyMFrOIBT6BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMTowMzoyMFrOIBT6BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI0NTYzNw==", "bodyText": "wheter -> whether", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538245637", "createdAt": "2020-12-08T11:03:20Z", "author": {"login": "Ladicek"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTE2NDI1OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMTowNDowM1rOIBT75w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMTowNDowM1rOIBT75w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI0NjExOQ==", "bodyText": "wheter -> whether", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538246119", "createdAt": "2020-12-08T11:04:03Z", "author": {"login": "Ladicek"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTE4MjYwOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMTowODoyMFrOIBUGvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMTowODoyMFrOIBUGvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI0ODg5Mg==", "bodyText": "ExtendedBeanConfiguratorio -> ExtendedBeanConfigurator", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538248892", "createdAt": "2020-12-08T11:08:20Z", "author": {"login": "Ladicek"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfiguratorio#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 262}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTE5MDM2OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMToxMDowOVrOIBULaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMTo1NzoyNFrOIBWTew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI1MDA5MQ==", "bodyText": "\"invocation of the Foo bean instance\" -- not sure what that means, perhaps you meant \"creation\" of the bean instance?", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538250091", "createdAt": "2020-12-08T11:10:09Z", "author": {"login": "Ladicek"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfiguratorio#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder`>> method and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`:\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation of the `Foo` bean instance.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 310}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI2NTkwMA==", "bodyText": "Well, \"creation\" precedes \"invocation\" ;-). It means that inside the recorder method we do invoke a method upon the Foo instance of the bean registered in the snippet above.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538265900", "createdAt": "2020-12-08T11:36:36Z", "author": {"login": "mkouba"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfiguratorio#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder`>> method and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`:\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation of the `Foo` bean instance.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI1MDA5MQ=="}, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 310}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI4NDkyMw==", "bodyText": "Ah so it should be \"results in an invocation on the Foo bean instance\", I'd say.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538284923", "createdAt": "2020-12-08T11:57:24Z", "author": {"login": "Ladicek"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfiguratorio#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder`>> method and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`:\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation of the `Foo` bean instance.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI1MDA5MQ=="}, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 310}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTE5NDM5OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMToxMTowNlrOIBUNvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMToxMTowNlrOIBUNvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI1MDY4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Similar to <<synthetic_beans,synthetic beans>> the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension.\n          \n          \n            \n            Similar to <<synthetic_beans,synthetic beans>>, the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538250687", "createdAt": "2020-12-08T11:11:06Z", "author": {"login": "Ladicek"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfiguratorio#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder`>> method and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`:\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation of the `Foo` bean instance.\n+====\n+\n+NOTE: It is also possible to use the `BeanRegistrarBuildItem` and `BeanRegistrationPhaseBuildItem` build items to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus.\n+\n+[[synthetic_observers]]\n+== Use Case - Synthetic Observers\n+\n+Similar to <<synthetic_beans,synthetic beans>> the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 318}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTE5NTk2OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMToxMTozMVrOIBUOrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMToxMTozMVrOIBUOrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI1MDkyNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you need to register a synthetic observer that requires no _build time context_ use the `ObserverRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ObserverConfigurator` API to build a synthetic observer method definition.\n          \n          \n            \n            If you need to register a synthetic observer that requires no _build time context_, use the `ObserverRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ObserverConfigurator` API to build a synthetic observer method definition.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538250927", "createdAt": "2020-12-08T11:11:31Z", "author": {"login": "Ladicek"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfiguratorio#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder`>> method and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`:\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation of the `Foo` bean instance.\n+====\n+\n+NOTE: It is also possible to use the `BeanRegistrarBuildItem` and `BeanRegistrationPhaseBuildItem` build items to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus.\n+\n+[[synthetic_observers]]\n+== Use Case - Synthetic Observers\n+\n+Similar to <<synthetic_beans,synthetic beans>> the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension.\n+\n+=== _Solution 1_: `ObserverRegistrarBuildItem`\n+\n+If you need to register a synthetic observer that requires no _build time context_ use the `ObserverRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ObserverConfigurator` API to build a synthetic observer method definition.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 322}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTI5NzczOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMTozNjo1MFrOIBVJnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNToyNTowMFrOIBjHaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI2NjAxNQ==", "bodyText": "Not for this PR, but this started bugging me in the previous chapters and now I just have to ask: what's the difference between those 2 build items (BeanDeploymentValidatorBuildItem and ValidationPhaseBuildItem)? It seems to me that the 2nd is stricly more powerful, easier to use and generally feels like a better approach, while the 1st looks like some legacy thing we might wanna deprecate (and possibly even remove) at some point?", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538266015", "createdAt": "2020-12-08T11:36:50Z", "author": {"login": "Ladicek"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfiguratorio#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder`>> method and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`:\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation of the `Foo` bean instance.\n+====\n+\n+NOTE: It is also possible to use the `BeanRegistrarBuildItem` and `BeanRegistrationPhaseBuildItem` build items to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus.\n+\n+[[synthetic_observers]]\n+== Use Case - Synthetic Observers\n+\n+Similar to <<synthetic_beans,synthetic beans>> the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension.\n+\n+=== _Solution 1_: `ObserverRegistrarBuildItem`\n+\n+If you need to register a synthetic observer that requires no _build time context_ use the `ObserverRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ObserverConfigurator` API to build a synthetic observer method definition.\n+\n+NOTE: The <<cdi-reference.adoc#startup_event,`@Startup` feature>> is implemented as a synthetic observer method.\n+\n+.`ObserverRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ObserverRegistrarBuildItem syntheticObserver() {\n+    return new ObserverRegistrarBuildItem(new ObserverRegistrar() {\n+       @Override\n+       public void register(RegistrationContext context) {\n+          // NOTE: You can't produce a build item from within this callback!\n+          context.configure().observedType(String.class) <1>\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+            }\n+        }));\n+}\n+----\n+<1> The output of a `ObserverConfigurator` is recorded as bytecode. Therefore, there are some limitations in how a synthetic observer is invoked at runtime. Currently, you must generate the bytecode of the method body directly.\n+\n+=== _Solution 2_: `ObserverRegistrationPhaseBuildItem`\n+\n+If a build step *needs to produce other build items during the registration* it should use the `ObserverRegistrationPhaseBuildItem`.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+.`ObserverRegistrationPhaseBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurators) {\n+   observerConfigurators.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext().configure().observedType(String.class)\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+   myBuildItem.produce(new MyBuildItem());\n+}\n+----\n+\n+[[generated_beans]]\n+== Use Case - I Have a Generated Bean Class\n+\n+No problem.\n+You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`.\n+\n+.`GeneratedBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+GeneratedBeanBuildItem generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {\n+    ClassOutput beansClassOutput = new GeneratedBeanGizmoAdaptor(generatedBeans); <1>\n+    ClassCreator beanClassCreator = ClassCreator.builder().classOutput(beansClassOutput)\n+                .className(\"org.acme.MyBean\")\n+                .build();\n+    beanClassCreator.addAnnotation(Singleton.class);\n+    beanClassCreator.close(); <2>\n+}\n+----\n+<1> A convenient `io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` can be used to produce a `GeneratedBeanBuildItem` from Gizmo constructs.\n+<2> The resulting bean class is something like `public class @Singleton MyBean { }`\n+\n+== Use Case - I Need to Validate the Deployment\n+\n+Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong.\n+\n+=== _Solution 1_: register a `BeanDeploymentValidatorBuildItem`\n+\n+If you need to validate the deployment with no _build time context_ use the `BeanDeploymentValidatorBuildItem` and leverage the `io.quarkus.arc.processor.BeanDeploymentValidator`.\n+\n+.`BeanDeploymentValidatorBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDeploymentValidatorBuildItem beanDeploymentValidator() {\n+    return new BeanDeploymentValidatorBuildItem(new BeanDeploymentValidator() {\n+         public void validate(ValidationContext context) {\n+             for (InjectionPointInfo injectionPoint : context.getInjectionPoints()) {\n+                 // NOTE: You can't produce a build item from within this callback!\n+                 System.out.println(\"Injection point: \" + injectionPoint);\n+             }\n+         }\n+    });\n+}\n+----\n+\n+TIP: You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationContext.beans()` method.\n+\n+=== _Solution 2_: `ValidationPhaseBuildItem`\n+\n+If an extension needs to produce other build items during the validation it should use the `ValidationPhaseBuildItem` instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 417}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI3NjQ5Mg==", "bodyText": "Well, you're right that it's a result of API evolution ;-). However, the difference is mentioned in the first sentence of the description of both build items... In the beginning there was the BeanDeploymentValidatorBuildItem which is basically a callback that is used inside ArC during bootstrap. This works just fine but the problem is that you can't produce a build item from within this callback, ie. outside a @BuildStep invocation (well-defined limitation). And so we had to split the bootstrap into multiple phases and introduce the corresponding Phase build items. The downside of this approach is that you need to add the corresponding BuildProducer otherwise it could be ignored or processed at the wrong time.\nIdeally, we should provide something like SyntheticBeanBuildItem for all phases. However, I'm not sure it's worth the effort.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538276492", "createdAt": "2020-12-08T11:48:54Z", "author": {"login": "mkouba"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfiguratorio#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder`>> method and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`:\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation of the `Foo` bean instance.\n+====\n+\n+NOTE: It is also possible to use the `BeanRegistrarBuildItem` and `BeanRegistrationPhaseBuildItem` build items to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus.\n+\n+[[synthetic_observers]]\n+== Use Case - Synthetic Observers\n+\n+Similar to <<synthetic_beans,synthetic beans>> the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension.\n+\n+=== _Solution 1_: `ObserverRegistrarBuildItem`\n+\n+If you need to register a synthetic observer that requires no _build time context_ use the `ObserverRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ObserverConfigurator` API to build a synthetic observer method definition.\n+\n+NOTE: The <<cdi-reference.adoc#startup_event,`@Startup` feature>> is implemented as a synthetic observer method.\n+\n+.`ObserverRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ObserverRegistrarBuildItem syntheticObserver() {\n+    return new ObserverRegistrarBuildItem(new ObserverRegistrar() {\n+       @Override\n+       public void register(RegistrationContext context) {\n+          // NOTE: You can't produce a build item from within this callback!\n+          context.configure().observedType(String.class) <1>\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+            }\n+        }));\n+}\n+----\n+<1> The output of a `ObserverConfigurator` is recorded as bytecode. Therefore, there are some limitations in how a synthetic observer is invoked at runtime. Currently, you must generate the bytecode of the method body directly.\n+\n+=== _Solution 2_: `ObserverRegistrationPhaseBuildItem`\n+\n+If a build step *needs to produce other build items during the registration* it should use the `ObserverRegistrationPhaseBuildItem`.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+.`ObserverRegistrationPhaseBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurators) {\n+   observerConfigurators.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext().configure().observedType(String.class)\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+   myBuildItem.produce(new MyBuildItem());\n+}\n+----\n+\n+[[generated_beans]]\n+== Use Case - I Have a Generated Bean Class\n+\n+No problem.\n+You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`.\n+\n+.`GeneratedBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+GeneratedBeanBuildItem generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {\n+    ClassOutput beansClassOutput = new GeneratedBeanGizmoAdaptor(generatedBeans); <1>\n+    ClassCreator beanClassCreator = ClassCreator.builder().classOutput(beansClassOutput)\n+                .className(\"org.acme.MyBean\")\n+                .build();\n+    beanClassCreator.addAnnotation(Singleton.class);\n+    beanClassCreator.close(); <2>\n+}\n+----\n+<1> A convenient `io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` can be used to produce a `GeneratedBeanBuildItem` from Gizmo constructs.\n+<2> The resulting bean class is something like `public class @Singleton MyBean { }`\n+\n+== Use Case - I Need to Validate the Deployment\n+\n+Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong.\n+\n+=== _Solution 1_: register a `BeanDeploymentValidatorBuildItem`\n+\n+If you need to validate the deployment with no _build time context_ use the `BeanDeploymentValidatorBuildItem` and leverage the `io.quarkus.arc.processor.BeanDeploymentValidator`.\n+\n+.`BeanDeploymentValidatorBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDeploymentValidatorBuildItem beanDeploymentValidator() {\n+    return new BeanDeploymentValidatorBuildItem(new BeanDeploymentValidator() {\n+         public void validate(ValidationContext context) {\n+             for (InjectionPointInfo injectionPoint : context.getInjectionPoints()) {\n+                 // NOTE: You can't produce a build item from within this callback!\n+                 System.out.println(\"Injection point: \" + injectionPoint);\n+             }\n+         }\n+    });\n+}\n+----\n+\n+TIP: You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationContext.beans()` method.\n+\n+=== _Solution 2_: `ValidationPhaseBuildItem`\n+\n+If an extension needs to produce other build items during the validation it should use the `ValidationPhaseBuildItem` instead.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI2NjAxNQ=="}, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 417}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI4Nzc4Mg==", "bodyText": "Yea I read the first sentence, but it didn't quite occur to me that this particular difference warrants 2 mechanisms to exists to achieve the same thing. It just feels strange.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538287782", "createdAt": "2020-12-08T12:00:44Z", "author": {"login": "Ladicek"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfiguratorio#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder`>> method and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`:\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation of the `Foo` bean instance.\n+====\n+\n+NOTE: It is also possible to use the `BeanRegistrarBuildItem` and `BeanRegistrationPhaseBuildItem` build items to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus.\n+\n+[[synthetic_observers]]\n+== Use Case - Synthetic Observers\n+\n+Similar to <<synthetic_beans,synthetic beans>> the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension.\n+\n+=== _Solution 1_: `ObserverRegistrarBuildItem`\n+\n+If you need to register a synthetic observer that requires no _build time context_ use the `ObserverRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ObserverConfigurator` API to build a synthetic observer method definition.\n+\n+NOTE: The <<cdi-reference.adoc#startup_event,`@Startup` feature>> is implemented as a synthetic observer method.\n+\n+.`ObserverRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ObserverRegistrarBuildItem syntheticObserver() {\n+    return new ObserverRegistrarBuildItem(new ObserverRegistrar() {\n+       @Override\n+       public void register(RegistrationContext context) {\n+          // NOTE: You can't produce a build item from within this callback!\n+          context.configure().observedType(String.class) <1>\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+            }\n+        }));\n+}\n+----\n+<1> The output of a `ObserverConfigurator` is recorded as bytecode. Therefore, there are some limitations in how a synthetic observer is invoked at runtime. Currently, you must generate the bytecode of the method body directly.\n+\n+=== _Solution 2_: `ObserverRegistrationPhaseBuildItem`\n+\n+If a build step *needs to produce other build items during the registration* it should use the `ObserverRegistrationPhaseBuildItem`.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+.`ObserverRegistrationPhaseBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurators) {\n+   observerConfigurators.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext().configure().observedType(String.class)\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+   myBuildItem.produce(new MyBuildItem());\n+}\n+----\n+\n+[[generated_beans]]\n+== Use Case - I Have a Generated Bean Class\n+\n+No problem.\n+You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`.\n+\n+.`GeneratedBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+GeneratedBeanBuildItem generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {\n+    ClassOutput beansClassOutput = new GeneratedBeanGizmoAdaptor(generatedBeans); <1>\n+    ClassCreator beanClassCreator = ClassCreator.builder().classOutput(beansClassOutput)\n+                .className(\"org.acme.MyBean\")\n+                .build();\n+    beanClassCreator.addAnnotation(Singleton.class);\n+    beanClassCreator.close(); <2>\n+}\n+----\n+<1> A convenient `io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` can be used to produce a `GeneratedBeanBuildItem` from Gizmo constructs.\n+<2> The resulting bean class is something like `public class @Singleton MyBean { }`\n+\n+== Use Case - I Need to Validate the Deployment\n+\n+Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong.\n+\n+=== _Solution 1_: register a `BeanDeploymentValidatorBuildItem`\n+\n+If you need to validate the deployment with no _build time context_ use the `BeanDeploymentValidatorBuildItem` and leverage the `io.quarkus.arc.processor.BeanDeploymentValidator`.\n+\n+.`BeanDeploymentValidatorBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDeploymentValidatorBuildItem beanDeploymentValidator() {\n+    return new BeanDeploymentValidatorBuildItem(new BeanDeploymentValidator() {\n+         public void validate(ValidationContext context) {\n+             for (InjectionPointInfo injectionPoint : context.getInjectionPoints()) {\n+                 // NOTE: You can't produce a build item from within this callback!\n+                 System.out.println(\"Injection point: \" + injectionPoint);\n+             }\n+         }\n+    });\n+}\n+----\n+\n+TIP: You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationContext.beans()` method.\n+\n+=== _Solution 2_: `ValidationPhaseBuildItem`\n+\n+If an extension needs to produce other build items during the validation it should use the `ValidationPhaseBuildItem` instead.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI2NjAxNQ=="}, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 417}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQwMDQ5Nw==", "bodyText": "It just feels strange.\n\nI agree. One reason was backwards compatibility. The other reason is that neither of these solutions is \"good enough\".\nWe should probably deprecate the BeanRegistrarBuildItem because we have the SyntheticBeanBuildItem + BeanDiscoveryFinishedBuildItem/SynthesisFinishedBuildItem combo.\nAnd we should probably deprecate BeanDeploymentValidatorBuildItem and ObserverRegistrarBuildItem as well.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538400497", "createdAt": "2020-12-08T13:57:29Z", "author": {"login": "mkouba"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfiguratorio#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder`>> method and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`:\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation of the `Foo` bean instance.\n+====\n+\n+NOTE: It is also possible to use the `BeanRegistrarBuildItem` and `BeanRegistrationPhaseBuildItem` build items to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus.\n+\n+[[synthetic_observers]]\n+== Use Case - Synthetic Observers\n+\n+Similar to <<synthetic_beans,synthetic beans>> the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension.\n+\n+=== _Solution 1_: `ObserverRegistrarBuildItem`\n+\n+If you need to register a synthetic observer that requires no _build time context_ use the `ObserverRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ObserverConfigurator` API to build a synthetic observer method definition.\n+\n+NOTE: The <<cdi-reference.adoc#startup_event,`@Startup` feature>> is implemented as a synthetic observer method.\n+\n+.`ObserverRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ObserverRegistrarBuildItem syntheticObserver() {\n+    return new ObserverRegistrarBuildItem(new ObserverRegistrar() {\n+       @Override\n+       public void register(RegistrationContext context) {\n+          // NOTE: You can't produce a build item from within this callback!\n+          context.configure().observedType(String.class) <1>\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+            }\n+        }));\n+}\n+----\n+<1> The output of a `ObserverConfigurator` is recorded as bytecode. Therefore, there are some limitations in how a synthetic observer is invoked at runtime. Currently, you must generate the bytecode of the method body directly.\n+\n+=== _Solution 2_: `ObserverRegistrationPhaseBuildItem`\n+\n+If a build step *needs to produce other build items during the registration* it should use the `ObserverRegistrationPhaseBuildItem`.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+.`ObserverRegistrationPhaseBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurators) {\n+   observerConfigurators.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext().configure().observedType(String.class)\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+   myBuildItem.produce(new MyBuildItem());\n+}\n+----\n+\n+[[generated_beans]]\n+== Use Case - I Have a Generated Bean Class\n+\n+No problem.\n+You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`.\n+\n+.`GeneratedBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+GeneratedBeanBuildItem generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {\n+    ClassOutput beansClassOutput = new GeneratedBeanGizmoAdaptor(generatedBeans); <1>\n+    ClassCreator beanClassCreator = ClassCreator.builder().classOutput(beansClassOutput)\n+                .className(\"org.acme.MyBean\")\n+                .build();\n+    beanClassCreator.addAnnotation(Singleton.class);\n+    beanClassCreator.close(); <2>\n+}\n+----\n+<1> A convenient `io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` can be used to produce a `GeneratedBeanBuildItem` from Gizmo constructs.\n+<2> The resulting bean class is something like `public class @Singleton MyBean { }`\n+\n+== Use Case - I Need to Validate the Deployment\n+\n+Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong.\n+\n+=== _Solution 1_: register a `BeanDeploymentValidatorBuildItem`\n+\n+If you need to validate the deployment with no _build time context_ use the `BeanDeploymentValidatorBuildItem` and leverage the `io.quarkus.arc.processor.BeanDeploymentValidator`.\n+\n+.`BeanDeploymentValidatorBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDeploymentValidatorBuildItem beanDeploymentValidator() {\n+    return new BeanDeploymentValidatorBuildItem(new BeanDeploymentValidator() {\n+         public void validate(ValidationContext context) {\n+             for (InjectionPointInfo injectionPoint : context.getInjectionPoints()) {\n+                 // NOTE: You can't produce a build item from within this callback!\n+                 System.out.println(\"Injection point: \" + injectionPoint);\n+             }\n+         }\n+    });\n+}\n+----\n+\n+TIP: You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationContext.beans()` method.\n+\n+=== _Solution 2_: `ValidationPhaseBuildItem`\n+\n+If an extension needs to produce other build items during the validation it should use the `ValidationPhaseBuildItem` instead.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI2NjAxNQ=="}, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 417}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzNTI3Ng==", "bodyText": "BeanRegistrarBuildItem, BeanDeploymentValidatorBuildItem and ObserverRegistrarBuildItem are now deprecated. I'm not sure about the ContextRegistrarBuildItem - there is actually a chicken-egg problem with scope annotations. I'll try to fix it tomorrow.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538435276", "createdAt": "2020-12-08T14:31:01Z", "author": {"login": "mkouba"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfiguratorio#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder`>> method and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`:\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation of the `Foo` bean instance.\n+====\n+\n+NOTE: It is also possible to use the `BeanRegistrarBuildItem` and `BeanRegistrationPhaseBuildItem` build items to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus.\n+\n+[[synthetic_observers]]\n+== Use Case - Synthetic Observers\n+\n+Similar to <<synthetic_beans,synthetic beans>> the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension.\n+\n+=== _Solution 1_: `ObserverRegistrarBuildItem`\n+\n+If you need to register a synthetic observer that requires no _build time context_ use the `ObserverRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ObserverConfigurator` API to build a synthetic observer method definition.\n+\n+NOTE: The <<cdi-reference.adoc#startup_event,`@Startup` feature>> is implemented as a synthetic observer method.\n+\n+.`ObserverRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ObserverRegistrarBuildItem syntheticObserver() {\n+    return new ObserverRegistrarBuildItem(new ObserverRegistrar() {\n+       @Override\n+       public void register(RegistrationContext context) {\n+          // NOTE: You can't produce a build item from within this callback!\n+          context.configure().observedType(String.class) <1>\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+            }\n+        }));\n+}\n+----\n+<1> The output of a `ObserverConfigurator` is recorded as bytecode. Therefore, there are some limitations in how a synthetic observer is invoked at runtime. Currently, you must generate the bytecode of the method body directly.\n+\n+=== _Solution 2_: `ObserverRegistrationPhaseBuildItem`\n+\n+If a build step *needs to produce other build items during the registration* it should use the `ObserverRegistrationPhaseBuildItem`.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+.`ObserverRegistrationPhaseBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurators) {\n+   observerConfigurators.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext().configure().observedType(String.class)\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+   myBuildItem.produce(new MyBuildItem());\n+}\n+----\n+\n+[[generated_beans]]\n+== Use Case - I Have a Generated Bean Class\n+\n+No problem.\n+You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`.\n+\n+.`GeneratedBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+GeneratedBeanBuildItem generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {\n+    ClassOutput beansClassOutput = new GeneratedBeanGizmoAdaptor(generatedBeans); <1>\n+    ClassCreator beanClassCreator = ClassCreator.builder().classOutput(beansClassOutput)\n+                .className(\"org.acme.MyBean\")\n+                .build();\n+    beanClassCreator.addAnnotation(Singleton.class);\n+    beanClassCreator.close(); <2>\n+}\n+----\n+<1> A convenient `io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` can be used to produce a `GeneratedBeanBuildItem` from Gizmo constructs.\n+<2> The resulting bean class is something like `public class @Singleton MyBean { }`\n+\n+== Use Case - I Need to Validate the Deployment\n+\n+Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong.\n+\n+=== _Solution 1_: register a `BeanDeploymentValidatorBuildItem`\n+\n+If you need to validate the deployment with no _build time context_ use the `BeanDeploymentValidatorBuildItem` and leverage the `io.quarkus.arc.processor.BeanDeploymentValidator`.\n+\n+.`BeanDeploymentValidatorBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDeploymentValidatorBuildItem beanDeploymentValidator() {\n+    return new BeanDeploymentValidatorBuildItem(new BeanDeploymentValidator() {\n+         public void validate(ValidationContext context) {\n+             for (InjectionPointInfo injectionPoint : context.getInjectionPoints()) {\n+                 // NOTE: You can't produce a build item from within this callback!\n+                 System.out.println(\"Injection point: \" + injectionPoint);\n+             }\n+         }\n+    });\n+}\n+----\n+\n+TIP: You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationContext.beans()` method.\n+\n+=== _Solution 2_: `ValidationPhaseBuildItem`\n+\n+If an extension needs to produce other build items during the validation it should use the `ValidationPhaseBuildItem` instead.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI2NjAxNQ=="}, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 417}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ5NDgyNA==", "bodyText": "ContextRegistrarBuildItem deprecated too. We had to introduce a new build item to register the scope annotation - CustomScopeBuildItem. The API is a bit cumbersome but I have no other idea how to fix the chicken-egg problem with bean defining annotations.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538494824", "createdAt": "2020-12-08T15:25:00Z", "author": {"login": "mkouba"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfiguratorio#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder`>> method and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`:\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation of the `Foo` bean instance.\n+====\n+\n+NOTE: It is also possible to use the `BeanRegistrarBuildItem` and `BeanRegistrationPhaseBuildItem` build items to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus.\n+\n+[[synthetic_observers]]\n+== Use Case - Synthetic Observers\n+\n+Similar to <<synthetic_beans,synthetic beans>> the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension.\n+\n+=== _Solution 1_: `ObserverRegistrarBuildItem`\n+\n+If you need to register a synthetic observer that requires no _build time context_ use the `ObserverRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ObserverConfigurator` API to build a synthetic observer method definition.\n+\n+NOTE: The <<cdi-reference.adoc#startup_event,`@Startup` feature>> is implemented as a synthetic observer method.\n+\n+.`ObserverRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ObserverRegistrarBuildItem syntheticObserver() {\n+    return new ObserverRegistrarBuildItem(new ObserverRegistrar() {\n+       @Override\n+       public void register(RegistrationContext context) {\n+          // NOTE: You can't produce a build item from within this callback!\n+          context.configure().observedType(String.class) <1>\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+            }\n+        }));\n+}\n+----\n+<1> The output of a `ObserverConfigurator` is recorded as bytecode. Therefore, there are some limitations in how a synthetic observer is invoked at runtime. Currently, you must generate the bytecode of the method body directly.\n+\n+=== _Solution 2_: `ObserverRegistrationPhaseBuildItem`\n+\n+If a build step *needs to produce other build items during the registration* it should use the `ObserverRegistrationPhaseBuildItem`.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+.`ObserverRegistrationPhaseBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurators) {\n+   observerConfigurators.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext().configure().observedType(String.class)\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+   myBuildItem.produce(new MyBuildItem());\n+}\n+----\n+\n+[[generated_beans]]\n+== Use Case - I Have a Generated Bean Class\n+\n+No problem.\n+You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`.\n+\n+.`GeneratedBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+GeneratedBeanBuildItem generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {\n+    ClassOutput beansClassOutput = new GeneratedBeanGizmoAdaptor(generatedBeans); <1>\n+    ClassCreator beanClassCreator = ClassCreator.builder().classOutput(beansClassOutput)\n+                .className(\"org.acme.MyBean\")\n+                .build();\n+    beanClassCreator.addAnnotation(Singleton.class);\n+    beanClassCreator.close(); <2>\n+}\n+----\n+<1> A convenient `io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` can be used to produce a `GeneratedBeanBuildItem` from Gizmo constructs.\n+<2> The resulting bean class is something like `public class @Singleton MyBean { }`\n+\n+== Use Case - I Need to Validate the Deployment\n+\n+Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong.\n+\n+=== _Solution 1_: register a `BeanDeploymentValidatorBuildItem`\n+\n+If you need to validate the deployment with no _build time context_ use the `BeanDeploymentValidatorBuildItem` and leverage the `io.quarkus.arc.processor.BeanDeploymentValidator`.\n+\n+.`BeanDeploymentValidatorBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDeploymentValidatorBuildItem beanDeploymentValidator() {\n+    return new BeanDeploymentValidatorBuildItem(new BeanDeploymentValidator() {\n+         public void validate(ValidationContext context) {\n+             for (InjectionPointInfo injectionPoint : context.getInjectionPoints()) {\n+                 // NOTE: You can't produce a build item from within this callback!\n+                 System.out.println(\"Injection point: \" + injectionPoint);\n+             }\n+         }\n+    });\n+}\n+----\n+\n+TIP: You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationContext.beans()` method.\n+\n+=== _Solution 2_: `ValidationPhaseBuildItem`\n+\n+If an extension needs to produce other build items during the validation it should use the `ValidationPhaseBuildItem` instead.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI2NjAxNQ=="}, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 417}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTMwNTY0OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMTozOTowMFrOIBVONA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMTo1MDoxNFrOIBV4dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI2NzE4OA==", "bodyText": "Similarly to a previous question -- sounds like this shouldn't be used in some earlier phases?", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538267188", "createdAt": "2020-12-08T11:39:00Z", "author": {"login": "Ladicek"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfiguratorio#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder`>> method and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`:\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation of the `Foo` bean instance.\n+====\n+\n+NOTE: It is also possible to use the `BeanRegistrarBuildItem` and `BeanRegistrationPhaseBuildItem` build items to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus.\n+\n+[[synthetic_observers]]\n+== Use Case - Synthetic Observers\n+\n+Similar to <<synthetic_beans,synthetic beans>> the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension.\n+\n+=== _Solution 1_: `ObserverRegistrarBuildItem`\n+\n+If you need to register a synthetic observer that requires no _build time context_ use the `ObserverRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ObserverConfigurator` API to build a synthetic observer method definition.\n+\n+NOTE: The <<cdi-reference.adoc#startup_event,`@Startup` feature>> is implemented as a synthetic observer method.\n+\n+.`ObserverRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ObserverRegistrarBuildItem syntheticObserver() {\n+    return new ObserverRegistrarBuildItem(new ObserverRegistrar() {\n+       @Override\n+       public void register(RegistrationContext context) {\n+          // NOTE: You can't produce a build item from within this callback!\n+          context.configure().observedType(String.class) <1>\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+            }\n+        }));\n+}\n+----\n+<1> The output of a `ObserverConfigurator` is recorded as bytecode. Therefore, there are some limitations in how a synthetic observer is invoked at runtime. Currently, you must generate the bytecode of the method body directly.\n+\n+=== _Solution 2_: `ObserverRegistrationPhaseBuildItem`\n+\n+If a build step *needs to produce other build items during the registration* it should use the `ObserverRegistrationPhaseBuildItem`.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+.`ObserverRegistrationPhaseBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurators) {\n+   observerConfigurators.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext().configure().observedType(String.class)\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+   myBuildItem.produce(new MyBuildItem());\n+}\n+----\n+\n+[[generated_beans]]\n+== Use Case - I Have a Generated Bean Class\n+\n+No problem.\n+You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`.\n+\n+.`GeneratedBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+GeneratedBeanBuildItem generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {\n+    ClassOutput beansClassOutput = new GeneratedBeanGizmoAdaptor(generatedBeans); <1>\n+    ClassCreator beanClassCreator = ClassCreator.builder().classOutput(beansClassOutput)\n+                .className(\"org.acme.MyBean\")\n+                .build();\n+    beanClassCreator.addAnnotation(Singleton.class);\n+    beanClassCreator.close(); <2>\n+}\n+----\n+<1> A convenient `io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` can be used to produce a `GeneratedBeanBuildItem` from Gizmo constructs.\n+<2> The resulting bean class is something like `public class @Singleton MyBean { }`\n+\n+== Use Case - I Need to Validate the Deployment\n+\n+Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong.\n+\n+=== _Solution 1_: register a `BeanDeploymentValidatorBuildItem`\n+\n+If you need to validate the deployment with no _build time context_ use the `BeanDeploymentValidatorBuildItem` and leverage the `io.quarkus.arc.processor.BeanDeploymentValidator`.\n+\n+.`BeanDeploymentValidatorBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDeploymentValidatorBuildItem beanDeploymentValidator() {\n+    return new BeanDeploymentValidatorBuildItem(new BeanDeploymentValidator() {\n+         public void validate(ValidationContext context) {\n+             for (InjectionPointInfo injectionPoint : context.getInjectionPoints()) {\n+                 // NOTE: You can't produce a build item from within this callback!\n+                 System.out.println(\"Injection point: \" + injectionPoint);\n+             }\n+         }\n+    });\n+}\n+----\n+\n+TIP: You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationContext.beans()` method.\n+\n+=== _Solution 2_: `ValidationPhaseBuildItem`\n+\n+If an extension needs to produce other build items during the validation it should use the `ValidationPhaseBuildItem` instead.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ValidationPhaseBuildItem` should always produce a `ValidationErrorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+[source,java]\n+----\n+@BuildStep\n+void validate(ValidationPhaseBuildItem validationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ValidationErrorBuildItem> errors) {\n+   if (someCondition) {\n+     errors.produce(new ValidationErrorBuildItem(new IllegalStateException()));\n+     myBuildItem.produce(new MyBuildItem());\n+   }\n+}\n+----\n+\n+[[custom_context]]\n+== Use Case - Register a Custom CDI Context\n+\n+Sometimes extensions need to extend the set of built-in CDI scopes and contexts.\n+\n+=== _Solution 1_: `ContextRegistrarBuildItem`\n+\n+If you need to add a custom context and you're not going to produce a build item within the registration then use the `ContextRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ContextRegistrar` API.\n+\n+.`ContextRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ContextRegistrarBuildItem registerContext() {\n+    return new ContextRegistrarBuildItem(new ContextRegistrar() {\n+         public void register(RegistrationContext context) {\n+            // NOTE: You can't produce a build item from within this callback!\n+            context.configure(TransactionScoped.class).normal().contextClass(TransactionContext.class).done();\n+         }\n+    });\n+}\n+----\n+\n+=== _Solution 2_: `ContextRegistrationPhaseBuildItem`\n+\n+If an extension needs to produce other build items during the registration it should use the `ContextRegistrationPhaseBuildItem` instead.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ContextRegistrationPhaseBuildItem` should always produce a `ContextConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+[source,java]\n+----\n+@BuildStep\n+void registerContext(MyConfig config, ContextRegistrationPhaseBuildItem phase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ContextConfiguratorBuildItem> contexts) {\n+   if (config.isEnabled()) {\n+      ContextConfigurator configurator = phase.getContext().configure(TransactionScoped.class).normal().contextClass(TransactionContext.class).done();\n+      contexts.produce(new ContextConfiguratorBuildItem(configurator));\n+      myBuildItem.produce(new MyBuildItem());\n+   }\n+}\n+----\n+\n+=== What if I Need to Know All the Scopes Used in the Application?\n+\n+_Solution_: You can inject the `CustomScopeAnnotationsBuildItem` in a build step and use the convenient methods such as `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 481}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI3ODAwNg==", "bodyText": "It can be used before the bootrap actually starts.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538278006", "createdAt": "2020-12-08T11:50:14Z", "author": {"login": "mkouba"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfiguratorio#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder`>> method and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`:\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation of the `Foo` bean instance.\n+====\n+\n+NOTE: It is also possible to use the `BeanRegistrarBuildItem` and `BeanRegistrationPhaseBuildItem` build items to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus.\n+\n+[[synthetic_observers]]\n+== Use Case - Synthetic Observers\n+\n+Similar to <<synthetic_beans,synthetic beans>> the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension.\n+\n+=== _Solution 1_: `ObserverRegistrarBuildItem`\n+\n+If you need to register a synthetic observer that requires no _build time context_ use the `ObserverRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ObserverConfigurator` API to build a synthetic observer method definition.\n+\n+NOTE: The <<cdi-reference.adoc#startup_event,`@Startup` feature>> is implemented as a synthetic observer method.\n+\n+.`ObserverRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ObserverRegistrarBuildItem syntheticObserver() {\n+    return new ObserverRegistrarBuildItem(new ObserverRegistrar() {\n+       @Override\n+       public void register(RegistrationContext context) {\n+          // NOTE: You can't produce a build item from within this callback!\n+          context.configure().observedType(String.class) <1>\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+            }\n+        }));\n+}\n+----\n+<1> The output of a `ObserverConfigurator` is recorded as bytecode. Therefore, there are some limitations in how a synthetic observer is invoked at runtime. Currently, you must generate the bytecode of the method body directly.\n+\n+=== _Solution 2_: `ObserverRegistrationPhaseBuildItem`\n+\n+If a build step *needs to produce other build items during the registration* it should use the `ObserverRegistrationPhaseBuildItem`.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+.`ObserverRegistrationPhaseBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurators) {\n+   observerConfigurators.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext().configure().observedType(String.class)\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+   myBuildItem.produce(new MyBuildItem());\n+}\n+----\n+\n+[[generated_beans]]\n+== Use Case - I Have a Generated Bean Class\n+\n+No problem.\n+You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`.\n+\n+.`GeneratedBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+GeneratedBeanBuildItem generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {\n+    ClassOutput beansClassOutput = new GeneratedBeanGizmoAdaptor(generatedBeans); <1>\n+    ClassCreator beanClassCreator = ClassCreator.builder().classOutput(beansClassOutput)\n+                .className(\"org.acme.MyBean\")\n+                .build();\n+    beanClassCreator.addAnnotation(Singleton.class);\n+    beanClassCreator.close(); <2>\n+}\n+----\n+<1> A convenient `io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` can be used to produce a `GeneratedBeanBuildItem` from Gizmo constructs.\n+<2> The resulting bean class is something like `public class @Singleton MyBean { }`\n+\n+== Use Case - I Need to Validate the Deployment\n+\n+Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong.\n+\n+=== _Solution 1_: register a `BeanDeploymentValidatorBuildItem`\n+\n+If you need to validate the deployment with no _build time context_ use the `BeanDeploymentValidatorBuildItem` and leverage the `io.quarkus.arc.processor.BeanDeploymentValidator`.\n+\n+.`BeanDeploymentValidatorBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDeploymentValidatorBuildItem beanDeploymentValidator() {\n+    return new BeanDeploymentValidatorBuildItem(new BeanDeploymentValidator() {\n+         public void validate(ValidationContext context) {\n+             for (InjectionPointInfo injectionPoint : context.getInjectionPoints()) {\n+                 // NOTE: You can't produce a build item from within this callback!\n+                 System.out.println(\"Injection point: \" + injectionPoint);\n+             }\n+         }\n+    });\n+}\n+----\n+\n+TIP: You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationContext.beans()` method.\n+\n+=== _Solution 2_: `ValidationPhaseBuildItem`\n+\n+If an extension needs to produce other build items during the validation it should use the `ValidationPhaseBuildItem` instead.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ValidationPhaseBuildItem` should always produce a `ValidationErrorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+[source,java]\n+----\n+@BuildStep\n+void validate(ValidationPhaseBuildItem validationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ValidationErrorBuildItem> errors) {\n+   if (someCondition) {\n+     errors.produce(new ValidationErrorBuildItem(new IllegalStateException()));\n+     myBuildItem.produce(new MyBuildItem());\n+   }\n+}\n+----\n+\n+[[custom_context]]\n+== Use Case - Register a Custom CDI Context\n+\n+Sometimes extensions need to extend the set of built-in CDI scopes and contexts.\n+\n+=== _Solution 1_: `ContextRegistrarBuildItem`\n+\n+If you need to add a custom context and you're not going to produce a build item within the registration then use the `ContextRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ContextRegistrar` API.\n+\n+.`ContextRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ContextRegistrarBuildItem registerContext() {\n+    return new ContextRegistrarBuildItem(new ContextRegistrar() {\n+         public void register(RegistrationContext context) {\n+            // NOTE: You can't produce a build item from within this callback!\n+            context.configure(TransactionScoped.class).normal().contextClass(TransactionContext.class).done();\n+         }\n+    });\n+}\n+----\n+\n+=== _Solution 2_: `ContextRegistrationPhaseBuildItem`\n+\n+If an extension needs to produce other build items during the registration it should use the `ContextRegistrationPhaseBuildItem` instead.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ContextRegistrationPhaseBuildItem` should always produce a `ContextConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+[source,java]\n+----\n+@BuildStep\n+void registerContext(MyConfig config, ContextRegistrationPhaseBuildItem phase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ContextConfiguratorBuildItem> contexts) {\n+   if (config.isEnabled()) {\n+      ContextConfigurator configurator = phase.getContext().configure(TransactionScoped.class).normal().contextClass(TransactionContext.class).done();\n+      contexts.produce(new ContextConfiguratorBuildItem(configurator));\n+      myBuildItem.produce(new MyBuildItem());\n+   }\n+}\n+----\n+\n+=== What if I Need to Know All the Scopes Used in the Application?\n+\n+_Solution_: You can inject the `CustomScopeAnnotationsBuildItem` in a build step and use the convenient methods such as `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI2NzE4OA=="}, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 481}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTMxOTk0OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMTo0MjowMlrOIBVWyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMTo0MjowMlrOIBVWyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI2OTM4Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            NOTE: In theory, you can use <<annotations_transformer_build_item,an `AnnotationsTransformer`>> to achieve the same goal. However, there are few differences that make `InjectionPointsTransformer` more suitable for this particular task: (1) Annotation transformers are applied before to all classes during bean discovery whereas `InjectionPointsTransformer` is only applied to discovered injection point after bean discovery and (2) with `InjectionPointsTransformer` you don't need to handle various types of injection points (field, parameters of initializer methods, etc.).\n          \n          \n            \n            NOTE: In theory, you can use <<annotations_transformer_build_item,an `AnnotationsTransformer`>> to achieve the same goal. However, there are few differences that make `InjectionPointsTransformer` more suitable for this particular task: (1) annotation transformers are applied to all classes during bean discovery, whereas `InjectionPointsTransformer` is only applied to discovered injection points after bean discovery; (2) with `InjectionPointsTransformer` you don't need to handle various types of injection points (field, parameters of initializer methods, etc.).", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538269386", "createdAt": "2020-12-08T11:42:02Z", "author": {"login": "Ladicek"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfiguratorio#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder`>> method and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`:\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation of the `Foo` bean instance.\n+====\n+\n+NOTE: It is also possible to use the `BeanRegistrarBuildItem` and `BeanRegistrationPhaseBuildItem` build items to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus.\n+\n+[[synthetic_observers]]\n+== Use Case - Synthetic Observers\n+\n+Similar to <<synthetic_beans,synthetic beans>> the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension.\n+\n+=== _Solution 1_: `ObserverRegistrarBuildItem`\n+\n+If you need to register a synthetic observer that requires no _build time context_ use the `ObserverRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ObserverConfigurator` API to build a synthetic observer method definition.\n+\n+NOTE: The <<cdi-reference.adoc#startup_event,`@Startup` feature>> is implemented as a synthetic observer method.\n+\n+.`ObserverRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ObserverRegistrarBuildItem syntheticObserver() {\n+    return new ObserverRegistrarBuildItem(new ObserverRegistrar() {\n+       @Override\n+       public void register(RegistrationContext context) {\n+          // NOTE: You can't produce a build item from within this callback!\n+          context.configure().observedType(String.class) <1>\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+            }\n+        }));\n+}\n+----\n+<1> The output of a `ObserverConfigurator` is recorded as bytecode. Therefore, there are some limitations in how a synthetic observer is invoked at runtime. Currently, you must generate the bytecode of the method body directly.\n+\n+=== _Solution 2_: `ObserverRegistrationPhaseBuildItem`\n+\n+If a build step *needs to produce other build items during the registration* it should use the `ObserverRegistrationPhaseBuildItem`.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+.`ObserverRegistrationPhaseBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurators) {\n+   observerConfigurators.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext().configure().observedType(String.class)\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+   myBuildItem.produce(new MyBuildItem());\n+}\n+----\n+\n+[[generated_beans]]\n+== Use Case - I Have a Generated Bean Class\n+\n+No problem.\n+You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`.\n+\n+.`GeneratedBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+GeneratedBeanBuildItem generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {\n+    ClassOutput beansClassOutput = new GeneratedBeanGizmoAdaptor(generatedBeans); <1>\n+    ClassCreator beanClassCreator = ClassCreator.builder().classOutput(beansClassOutput)\n+                .className(\"org.acme.MyBean\")\n+                .build();\n+    beanClassCreator.addAnnotation(Singleton.class);\n+    beanClassCreator.close(); <2>\n+}\n+----\n+<1> A convenient `io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` can be used to produce a `GeneratedBeanBuildItem` from Gizmo constructs.\n+<2> The resulting bean class is something like `public class @Singleton MyBean { }`\n+\n+== Use Case - I Need to Validate the Deployment\n+\n+Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong.\n+\n+=== _Solution 1_: register a `BeanDeploymentValidatorBuildItem`\n+\n+If you need to validate the deployment with no _build time context_ use the `BeanDeploymentValidatorBuildItem` and leverage the `io.quarkus.arc.processor.BeanDeploymentValidator`.\n+\n+.`BeanDeploymentValidatorBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDeploymentValidatorBuildItem beanDeploymentValidator() {\n+    return new BeanDeploymentValidatorBuildItem(new BeanDeploymentValidator() {\n+         public void validate(ValidationContext context) {\n+             for (InjectionPointInfo injectionPoint : context.getInjectionPoints()) {\n+                 // NOTE: You can't produce a build item from within this callback!\n+                 System.out.println(\"Injection point: \" + injectionPoint);\n+             }\n+         }\n+    });\n+}\n+----\n+\n+TIP: You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationContext.beans()` method.\n+\n+=== _Solution 2_: `ValidationPhaseBuildItem`\n+\n+If an extension needs to produce other build items during the validation it should use the `ValidationPhaseBuildItem` instead.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ValidationPhaseBuildItem` should always produce a `ValidationErrorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+[source,java]\n+----\n+@BuildStep\n+void validate(ValidationPhaseBuildItem validationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ValidationErrorBuildItem> errors) {\n+   if (someCondition) {\n+     errors.produce(new ValidationErrorBuildItem(new IllegalStateException()));\n+     myBuildItem.produce(new MyBuildItem());\n+   }\n+}\n+----\n+\n+[[custom_context]]\n+== Use Case - Register a Custom CDI Context\n+\n+Sometimes extensions need to extend the set of built-in CDI scopes and contexts.\n+\n+=== _Solution 1_: `ContextRegistrarBuildItem`\n+\n+If you need to add a custom context and you're not going to produce a build item within the registration then use the `ContextRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ContextRegistrar` API.\n+\n+.`ContextRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ContextRegistrarBuildItem registerContext() {\n+    return new ContextRegistrarBuildItem(new ContextRegistrar() {\n+         public void register(RegistrationContext context) {\n+            // NOTE: You can't produce a build item from within this callback!\n+            context.configure(TransactionScoped.class).normal().contextClass(TransactionContext.class).done();\n+         }\n+    });\n+}\n+----\n+\n+=== _Solution 2_: `ContextRegistrationPhaseBuildItem`\n+\n+If an extension needs to produce other build items during the registration it should use the `ContextRegistrationPhaseBuildItem` instead.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ContextRegistrationPhaseBuildItem` should always produce a `ContextConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+[source,java]\n+----\n+@BuildStep\n+void registerContext(MyConfig config, ContextRegistrationPhaseBuildItem phase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ContextConfiguratorBuildItem> contexts) {\n+   if (config.isEnabled()) {\n+      ContextConfigurator configurator = phase.getContext().configure(TransactionScoped.class).normal().contextClass(TransactionContext.class).done();\n+      contexts.produce(new ContextConfiguratorBuildItem(configurator));\n+      myBuildItem.produce(new MyBuildItem());\n+   }\n+}\n+----\n+\n+=== What if I Need to Know All the Scopes Used in the Application?\n+\n+_Solution_: You can inject the `CustomScopeAnnotationsBuildItem` in a build step and use the convenient methods such as `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()`.\n+\n+[[additional_interceptor_bindings]]\n+== Use Case - Additional Interceptor Bindings\n+\n+In rare cases it might be handy to programmatically register an existing annotation that is not annotated with `@javax.interceptor.InterceptorBinding` as an interceptor binding.\n+This is similar to what CDI achieves through `BeforeBeanDiscovery#addInterceptorBinding()`.\n+Though here we are going to use `InterceptorBindingRegistrarBuildItem` to get it done.\n+\n+.`InterceptorBindingRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+InterceptorBindingRegistrarBuildItem addInterceptorBindings() {\n+    return new InterceptorBindingRegistrarBuildItem(new InterceptorBindingRegistrar() {\n+        @Override\n+        public Map<DotName, Set<String>> registerAdditionalBindings() { <1>\n+            return Collections.singletonMap(DotName.createSimple(NotAnInterceptorBinding.class.getName()),\n+                                        Collections.emptySet());\n+        }\n+    });\n+}\n+----\n+\n+[[injection_point_transformation]]\n+== Use Case - Injection Point Transformation\n+\n+Every now and then it is handy to be able to change the qualifiers of an injection point programmatically.\n+You can do just that with `InjectionPointTransformerBuildItem`.\n+The following sample shows how to apply transformation to injection points with type `Foo` that contain qualifier `MyQualifier`:\n+\n+.`InjectionPointTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+InjectionPointTransformerBuildItem transformer() {\n+    return new InjectionPointTransformerBuildItem(new InjectionPointsTransformer() {\n+\n+        public boolean appliesTo(Type requiredType) {\n+            return requiredType.name().equals(DotName.createSimple(Foo.class.getName()));\n+        }\n+\n+        public void transform(TransformationContext context) {\n+            if (context.getQualifiers().stream()\n+                    .anyMatch(a -> a.name().equals(DotName.createSimple(MyQualifier.class.getName())))) {\n+                context.transform()\n+                        .removeAll()\n+                        .add(DotName.createSimple(MyOtherQualifier.class.getName()))\n+                        .done();\n+            }\n+        }\n+    });\n+}\n+----\n+\n+NOTE: In theory, you can use <<annotations_transformer_build_item,an `AnnotationsTransformer`>> to achieve the same goal. However, there are few differences that make `InjectionPointsTransformer` more suitable for this particular task: (1) Annotation transformers are applied before to all classes during bean discovery whereas `InjectionPointsTransformer` is only applied to discovered injection point after bean discovery and (2) with `InjectionPointsTransformer` you don't need to handle various types of injection points (field, parameters of initializer methods, etc.).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 536}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTMyMzUzOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMTo0Mjo0NVrOIBVY8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMTo0Mjo0NVrOIBVY8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI2OTkzNw==", "bodyText": "Jakarta EE perhaps? Not sure what we refer to elsewhere.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538269937", "createdAt": "2020-12-08T11:42:45Z", "author": {"login": "Ladicek"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfiguratorio#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder`>> method and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`:\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation of the `Foo` bean instance.\n+====\n+\n+NOTE: It is also possible to use the `BeanRegistrarBuildItem` and `BeanRegistrationPhaseBuildItem` build items to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus.\n+\n+[[synthetic_observers]]\n+== Use Case - Synthetic Observers\n+\n+Similar to <<synthetic_beans,synthetic beans>> the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension.\n+\n+=== _Solution 1_: `ObserverRegistrarBuildItem`\n+\n+If you need to register a synthetic observer that requires no _build time context_ use the `ObserverRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ObserverConfigurator` API to build a synthetic observer method definition.\n+\n+NOTE: The <<cdi-reference.adoc#startup_event,`@Startup` feature>> is implemented as a synthetic observer method.\n+\n+.`ObserverRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ObserverRegistrarBuildItem syntheticObserver() {\n+    return new ObserverRegistrarBuildItem(new ObserverRegistrar() {\n+       @Override\n+       public void register(RegistrationContext context) {\n+          // NOTE: You can't produce a build item from within this callback!\n+          context.configure().observedType(String.class) <1>\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+            }\n+        }));\n+}\n+----\n+<1> The output of a `ObserverConfigurator` is recorded as bytecode. Therefore, there are some limitations in how a synthetic observer is invoked at runtime. Currently, you must generate the bytecode of the method body directly.\n+\n+=== _Solution 2_: `ObserverRegistrationPhaseBuildItem`\n+\n+If a build step *needs to produce other build items during the registration* it should use the `ObserverRegistrationPhaseBuildItem`.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+.`ObserverRegistrationPhaseBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurators) {\n+   observerConfigurators.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext().configure().observedType(String.class)\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+   myBuildItem.produce(new MyBuildItem());\n+}\n+----\n+\n+[[generated_beans]]\n+== Use Case - I Have a Generated Bean Class\n+\n+No problem.\n+You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`.\n+\n+.`GeneratedBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+GeneratedBeanBuildItem generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {\n+    ClassOutput beansClassOutput = new GeneratedBeanGizmoAdaptor(generatedBeans); <1>\n+    ClassCreator beanClassCreator = ClassCreator.builder().classOutput(beansClassOutput)\n+                .className(\"org.acme.MyBean\")\n+                .build();\n+    beanClassCreator.addAnnotation(Singleton.class);\n+    beanClassCreator.close(); <2>\n+}\n+----\n+<1> A convenient `io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` can be used to produce a `GeneratedBeanBuildItem` from Gizmo constructs.\n+<2> The resulting bean class is something like `public class @Singleton MyBean { }`\n+\n+== Use Case - I Need to Validate the Deployment\n+\n+Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong.\n+\n+=== _Solution 1_: register a `BeanDeploymentValidatorBuildItem`\n+\n+If you need to validate the deployment with no _build time context_ use the `BeanDeploymentValidatorBuildItem` and leverage the `io.quarkus.arc.processor.BeanDeploymentValidator`.\n+\n+.`BeanDeploymentValidatorBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDeploymentValidatorBuildItem beanDeploymentValidator() {\n+    return new BeanDeploymentValidatorBuildItem(new BeanDeploymentValidator() {\n+         public void validate(ValidationContext context) {\n+             for (InjectionPointInfo injectionPoint : context.getInjectionPoints()) {\n+                 // NOTE: You can't produce a build item from within this callback!\n+                 System.out.println(\"Injection point: \" + injectionPoint);\n+             }\n+         }\n+    });\n+}\n+----\n+\n+TIP: You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationContext.beans()` method.\n+\n+=== _Solution 2_: `ValidationPhaseBuildItem`\n+\n+If an extension needs to produce other build items during the validation it should use the `ValidationPhaseBuildItem` instead.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ValidationPhaseBuildItem` should always produce a `ValidationErrorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+[source,java]\n+----\n+@BuildStep\n+void validate(ValidationPhaseBuildItem validationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ValidationErrorBuildItem> errors) {\n+   if (someCondition) {\n+     errors.produce(new ValidationErrorBuildItem(new IllegalStateException()));\n+     myBuildItem.produce(new MyBuildItem());\n+   }\n+}\n+----\n+\n+[[custom_context]]\n+== Use Case - Register a Custom CDI Context\n+\n+Sometimes extensions need to extend the set of built-in CDI scopes and contexts.\n+\n+=== _Solution 1_: `ContextRegistrarBuildItem`\n+\n+If you need to add a custom context and you're not going to produce a build item within the registration then use the `ContextRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ContextRegistrar` API.\n+\n+.`ContextRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ContextRegistrarBuildItem registerContext() {\n+    return new ContextRegistrarBuildItem(new ContextRegistrar() {\n+         public void register(RegistrationContext context) {\n+            // NOTE: You can't produce a build item from within this callback!\n+            context.configure(TransactionScoped.class).normal().contextClass(TransactionContext.class).done();\n+         }\n+    });\n+}\n+----\n+\n+=== _Solution 2_: `ContextRegistrationPhaseBuildItem`\n+\n+If an extension needs to produce other build items during the registration it should use the `ContextRegistrationPhaseBuildItem` instead.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ContextRegistrationPhaseBuildItem` should always produce a `ContextConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+[source,java]\n+----\n+@BuildStep\n+void registerContext(MyConfig config, ContextRegistrationPhaseBuildItem phase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ContextConfiguratorBuildItem> contexts) {\n+   if (config.isEnabled()) {\n+      ContextConfigurator configurator = phase.getContext().configure(TransactionScoped.class).normal().contextClass(TransactionContext.class).done();\n+      contexts.produce(new ContextConfiguratorBuildItem(configurator));\n+      myBuildItem.produce(new MyBuildItem());\n+   }\n+}\n+----\n+\n+=== What if I Need to Know All the Scopes Used in the Application?\n+\n+_Solution_: You can inject the `CustomScopeAnnotationsBuildItem` in a build step and use the convenient methods such as `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()`.\n+\n+[[additional_interceptor_bindings]]\n+== Use Case - Additional Interceptor Bindings\n+\n+In rare cases it might be handy to programmatically register an existing annotation that is not annotated with `@javax.interceptor.InterceptorBinding` as an interceptor binding.\n+This is similar to what CDI achieves through `BeforeBeanDiscovery#addInterceptorBinding()`.\n+Though here we are going to use `InterceptorBindingRegistrarBuildItem` to get it done.\n+\n+.`InterceptorBindingRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+InterceptorBindingRegistrarBuildItem addInterceptorBindings() {\n+    return new InterceptorBindingRegistrarBuildItem(new InterceptorBindingRegistrar() {\n+        @Override\n+        public Map<DotName, Set<String>> registerAdditionalBindings() { <1>\n+            return Collections.singletonMap(DotName.createSimple(NotAnInterceptorBinding.class.getName()),\n+                                        Collections.emptySet());\n+        }\n+    });\n+}\n+----\n+\n+[[injection_point_transformation]]\n+== Use Case - Injection Point Transformation\n+\n+Every now and then it is handy to be able to change the qualifiers of an injection point programmatically.\n+You can do just that with `InjectionPointTransformerBuildItem`.\n+The following sample shows how to apply transformation to injection points with type `Foo` that contain qualifier `MyQualifier`:\n+\n+.`InjectionPointTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+InjectionPointTransformerBuildItem transformer() {\n+    return new InjectionPointTransformerBuildItem(new InjectionPointsTransformer() {\n+\n+        public boolean appliesTo(Type requiredType) {\n+            return requiredType.name().equals(DotName.createSimple(Foo.class.getName()));\n+        }\n+\n+        public void transform(TransformationContext context) {\n+            if (context.getQualifiers().stream()\n+                    .anyMatch(a -> a.name().equals(DotName.createSimple(MyQualifier.class.getName())))) {\n+                context.transform()\n+                        .removeAll()\n+                        .add(DotName.createSimple(MyOtherQualifier.class.getName()))\n+                        .done();\n+            }\n+        }\n+    });\n+}\n+----\n+\n+NOTE: In theory, you can use <<annotations_transformer_build_item,an `AnnotationsTransformer`>> to achieve the same goal. However, there are few differences that make `InjectionPointsTransformer` more suitable for this particular task: (1) Annotation transformers are applied before to all classes during bean discovery whereas `InjectionPointsTransformer` is only applied to discovered injection point after bean discovery and (2) with `InjectionPointsTransformer` you don't need to handle various types of injection points (field, parameters of initializer methods, etc.).\n+\n+== Use Case - Resource Annotations and Injection\n+\n+The `ResourceAnnotationBuildItem` can be used to specify resource annotations that make it possible to resolve non-CDI injection points, such as Java EE resources.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 540}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTMzOTczOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMTo0NToyNVrOIBVjoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMjowMzo0MFrOIBWoJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI3MjY3Mg==", "bodyText": "Something I found during the CDI Lite work: this is actually incorrect (and not caught by javac :-) ), the Map stored in the context is in fact Map<DotName, StereotypeInfo>. Which actually makes more sense.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538272672", "createdAt": "2020-12-08T11:45:25Z", "author": {"login": "Ladicek"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfiguratorio#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder`>> method and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`:\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation of the `Foo` bean instance.\n+====\n+\n+NOTE: It is also possible to use the `BeanRegistrarBuildItem` and `BeanRegistrationPhaseBuildItem` build items to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus.\n+\n+[[synthetic_observers]]\n+== Use Case - Synthetic Observers\n+\n+Similar to <<synthetic_beans,synthetic beans>> the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension.\n+\n+=== _Solution 1_: `ObserverRegistrarBuildItem`\n+\n+If you need to register a synthetic observer that requires no _build time context_ use the `ObserverRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ObserverConfigurator` API to build a synthetic observer method definition.\n+\n+NOTE: The <<cdi-reference.adoc#startup_event,`@Startup` feature>> is implemented as a synthetic observer method.\n+\n+.`ObserverRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ObserverRegistrarBuildItem syntheticObserver() {\n+    return new ObserverRegistrarBuildItem(new ObserverRegistrar() {\n+       @Override\n+       public void register(RegistrationContext context) {\n+          // NOTE: You can't produce a build item from within this callback!\n+          context.configure().observedType(String.class) <1>\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+            }\n+        }));\n+}\n+----\n+<1> The output of a `ObserverConfigurator` is recorded as bytecode. Therefore, there are some limitations in how a synthetic observer is invoked at runtime. Currently, you must generate the bytecode of the method body directly.\n+\n+=== _Solution 2_: `ObserverRegistrationPhaseBuildItem`\n+\n+If a build step *needs to produce other build items during the registration* it should use the `ObserverRegistrationPhaseBuildItem`.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+.`ObserverRegistrationPhaseBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurators) {\n+   observerConfigurators.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext().configure().observedType(String.class)\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+   myBuildItem.produce(new MyBuildItem());\n+}\n+----\n+\n+[[generated_beans]]\n+== Use Case - I Have a Generated Bean Class\n+\n+No problem.\n+You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`.\n+\n+.`GeneratedBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+GeneratedBeanBuildItem generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {\n+    ClassOutput beansClassOutput = new GeneratedBeanGizmoAdaptor(generatedBeans); <1>\n+    ClassCreator beanClassCreator = ClassCreator.builder().classOutput(beansClassOutput)\n+                .className(\"org.acme.MyBean\")\n+                .build();\n+    beanClassCreator.addAnnotation(Singleton.class);\n+    beanClassCreator.close(); <2>\n+}\n+----\n+<1> A convenient `io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` can be used to produce a `GeneratedBeanBuildItem` from Gizmo constructs.\n+<2> The resulting bean class is something like `public class @Singleton MyBean { }`\n+\n+== Use Case - I Need to Validate the Deployment\n+\n+Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong.\n+\n+=== _Solution 1_: register a `BeanDeploymentValidatorBuildItem`\n+\n+If you need to validate the deployment with no _build time context_ use the `BeanDeploymentValidatorBuildItem` and leverage the `io.quarkus.arc.processor.BeanDeploymentValidator`.\n+\n+.`BeanDeploymentValidatorBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDeploymentValidatorBuildItem beanDeploymentValidator() {\n+    return new BeanDeploymentValidatorBuildItem(new BeanDeploymentValidator() {\n+         public void validate(ValidationContext context) {\n+             for (InjectionPointInfo injectionPoint : context.getInjectionPoints()) {\n+                 // NOTE: You can't produce a build item from within this callback!\n+                 System.out.println(\"Injection point: \" + injectionPoint);\n+             }\n+         }\n+    });\n+}\n+----\n+\n+TIP: You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationContext.beans()` method.\n+\n+=== _Solution 2_: `ValidationPhaseBuildItem`\n+\n+If an extension needs to produce other build items during the validation it should use the `ValidationPhaseBuildItem` instead.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ValidationPhaseBuildItem` should always produce a `ValidationErrorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+[source,java]\n+----\n+@BuildStep\n+void validate(ValidationPhaseBuildItem validationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ValidationErrorBuildItem> errors) {\n+   if (someCondition) {\n+     errors.produce(new ValidationErrorBuildItem(new IllegalStateException()));\n+     myBuildItem.produce(new MyBuildItem());\n+   }\n+}\n+----\n+\n+[[custom_context]]\n+== Use Case - Register a Custom CDI Context\n+\n+Sometimes extensions need to extend the set of built-in CDI scopes and contexts.\n+\n+=== _Solution 1_: `ContextRegistrarBuildItem`\n+\n+If you need to add a custom context and you're not going to produce a build item within the registration then use the `ContextRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ContextRegistrar` API.\n+\n+.`ContextRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ContextRegistrarBuildItem registerContext() {\n+    return new ContextRegistrarBuildItem(new ContextRegistrar() {\n+         public void register(RegistrationContext context) {\n+            // NOTE: You can't produce a build item from within this callback!\n+            context.configure(TransactionScoped.class).normal().contextClass(TransactionContext.class).done();\n+         }\n+    });\n+}\n+----\n+\n+=== _Solution 2_: `ContextRegistrationPhaseBuildItem`\n+\n+If an extension needs to produce other build items during the registration it should use the `ContextRegistrationPhaseBuildItem` instead.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ContextRegistrationPhaseBuildItem` should always produce a `ContextConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+[source,java]\n+----\n+@BuildStep\n+void registerContext(MyConfig config, ContextRegistrationPhaseBuildItem phase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ContextConfiguratorBuildItem> contexts) {\n+   if (config.isEnabled()) {\n+      ContextConfigurator configurator = phase.getContext().configure(TransactionScoped.class).normal().contextClass(TransactionContext.class).done();\n+      contexts.produce(new ContextConfiguratorBuildItem(configurator));\n+      myBuildItem.produce(new MyBuildItem());\n+   }\n+}\n+----\n+\n+=== What if I Need to Know All the Scopes Used in the Application?\n+\n+_Solution_: You can inject the `CustomScopeAnnotationsBuildItem` in a build step and use the convenient methods such as `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()`.\n+\n+[[additional_interceptor_bindings]]\n+== Use Case - Additional Interceptor Bindings\n+\n+In rare cases it might be handy to programmatically register an existing annotation that is not annotated with `@javax.interceptor.InterceptorBinding` as an interceptor binding.\n+This is similar to what CDI achieves through `BeforeBeanDiscovery#addInterceptorBinding()`.\n+Though here we are going to use `InterceptorBindingRegistrarBuildItem` to get it done.\n+\n+.`InterceptorBindingRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+InterceptorBindingRegistrarBuildItem addInterceptorBindings() {\n+    return new InterceptorBindingRegistrarBuildItem(new InterceptorBindingRegistrar() {\n+        @Override\n+        public Map<DotName, Set<String>> registerAdditionalBindings() { <1>\n+            return Collections.singletonMap(DotName.createSimple(NotAnInterceptorBinding.class.getName()),\n+                                        Collections.emptySet());\n+        }\n+    });\n+}\n+----\n+\n+[[injection_point_transformation]]\n+== Use Case - Injection Point Transformation\n+\n+Every now and then it is handy to be able to change the qualifiers of an injection point programmatically.\n+You can do just that with `InjectionPointTransformerBuildItem`.\n+The following sample shows how to apply transformation to injection points with type `Foo` that contain qualifier `MyQualifier`:\n+\n+.`InjectionPointTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+InjectionPointTransformerBuildItem transformer() {\n+    return new InjectionPointTransformerBuildItem(new InjectionPointsTransformer() {\n+\n+        public boolean appliesTo(Type requiredType) {\n+            return requiredType.name().equals(DotName.createSimple(Foo.class.getName()));\n+        }\n+\n+        public void transform(TransformationContext context) {\n+            if (context.getQualifiers().stream()\n+                    .anyMatch(a -> a.name().equals(DotName.createSimple(MyQualifier.class.getName())))) {\n+                context.transform()\n+                        .removeAll()\n+                        .add(DotName.createSimple(MyOtherQualifier.class.getName()))\n+                        .done();\n+            }\n+        }\n+    });\n+}\n+----\n+\n+NOTE: In theory, you can use <<annotations_transformer_build_item,an `AnnotationsTransformer`>> to achieve the same goal. However, there are few differences that make `InjectionPointsTransformer` more suitable for this particular task: (1) Annotation transformers are applied before to all classes during bean discovery whereas `InjectionPointsTransformer` is only applied to discovered injection point after bean discovery and (2) with `InjectionPointsTransformer` you don't need to handle various types of injection points (field, parameters of initializer methods, etc.).\n+\n+== Use Case - Resource Annotations and Injection\n+\n+The `ResourceAnnotationBuildItem` can be used to specify resource annotations that make it possible to resolve non-CDI injection points, such as Java EE resources.\n+An integrator must also provide a corresponding `io.quarkus.arc.ResourceReferenceProvider` service provider implementation. \n+\n+.`ResourceAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void setupResourceInjection(BuildProducer<ResourceAnnotationBuildItem> resourceAnnotations, BuildProducer<GeneratedResourceBuildItem> resources) {\n+    resources.produce(new GeneratedResourceBuildItem(\"META-INF/services/io.quarkus.arc.ResourceReferenceProvider\",\n+        MyResourceReferenceProvider.class.getName().getBytes()));\n+    resourceAnnotations.produce(new ResourceAnnotationBuildItem(DotName.createSimple(MyAnnotation.class.getName())));\n+}\n+----\n+\n+[[build_metadata]]\n+== Available Build Time Metadata\n+\n+Any of the above extensions that operates with `BuildExtension.BuildContext` can leverage certain build time metadata that are generated during build.\n+The built-in keys located in `io.quarkus.arc.processor.BuildExtension.Key` are:\n+\n+* `ANNOTATION_STORE`\n+** Contains an `AnnotationStore` that keeps information about all `AnnotationTarget` annotations after application of annotation transformers\n+* `INJECTION_POINTS`\n+** `Collection<InjectionPointInfo>` containing all injection points\n+* `BEANS`\n+** `Collection<BeanInfo>` containing all beans\n+* `REMOVED_BEANS`\n+** `Collection<BeanInfo>` containing all the removed beans; see <<remove_unused_beans>> for more information\n+* `OBSERVERS`\n+** `Collection<ObserverInfo>` containing all observers\n+* `SCOPES`\n+** `Collection<ScopeInfo>` containing all scopes, including custom ones\n+* `QUALIFIERS`\n+** `Map<DotName, ClassInfo>` containing all qualifiers\n+* `INTERCEPTOR_BINDINGS`\n+** `Map<DotName, ClassInfo>` containing all interceptor bindings\n+* `STEREOTYPES`\n+** `Map<DotName, ClassInfo>` containing all stereotypes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 577}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI5MDIxMg==", "bodyText": "Ok. This part was CTRL+C and CTRL+V. At least we can fix it right away ;-)", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538290212", "createdAt": "2020-12-08T12:03:40Z", "author": {"login": "mkouba"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfiguratorio#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder`>> method and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`:\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation of the `Foo` bean instance.\n+====\n+\n+NOTE: It is also possible to use the `BeanRegistrarBuildItem` and `BeanRegistrationPhaseBuildItem` build items to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus.\n+\n+[[synthetic_observers]]\n+== Use Case - Synthetic Observers\n+\n+Similar to <<synthetic_beans,synthetic beans>> the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension.\n+\n+=== _Solution 1_: `ObserverRegistrarBuildItem`\n+\n+If you need to register a synthetic observer that requires no _build time context_ use the `ObserverRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ObserverConfigurator` API to build a synthetic observer method definition.\n+\n+NOTE: The <<cdi-reference.adoc#startup_event,`@Startup` feature>> is implemented as a synthetic observer method.\n+\n+.`ObserverRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ObserverRegistrarBuildItem syntheticObserver() {\n+    return new ObserverRegistrarBuildItem(new ObserverRegistrar() {\n+       @Override\n+       public void register(RegistrationContext context) {\n+          // NOTE: You can't produce a build item from within this callback!\n+          context.configure().observedType(String.class) <1>\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+            }\n+        }));\n+}\n+----\n+<1> The output of a `ObserverConfigurator` is recorded as bytecode. Therefore, there are some limitations in how a synthetic observer is invoked at runtime. Currently, you must generate the bytecode of the method body directly.\n+\n+=== _Solution 2_: `ObserverRegistrationPhaseBuildItem`\n+\n+If a build step *needs to produce other build items during the registration* it should use the `ObserverRegistrationPhaseBuildItem`.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+.`ObserverRegistrationPhaseBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurators) {\n+   observerConfigurators.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext().configure().observedType(String.class)\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+   myBuildItem.produce(new MyBuildItem());\n+}\n+----\n+\n+[[generated_beans]]\n+== Use Case - I Have a Generated Bean Class\n+\n+No problem.\n+You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`.\n+\n+.`GeneratedBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+GeneratedBeanBuildItem generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {\n+    ClassOutput beansClassOutput = new GeneratedBeanGizmoAdaptor(generatedBeans); <1>\n+    ClassCreator beanClassCreator = ClassCreator.builder().classOutput(beansClassOutput)\n+                .className(\"org.acme.MyBean\")\n+                .build();\n+    beanClassCreator.addAnnotation(Singleton.class);\n+    beanClassCreator.close(); <2>\n+}\n+----\n+<1> A convenient `io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` can be used to produce a `GeneratedBeanBuildItem` from Gizmo constructs.\n+<2> The resulting bean class is something like `public class @Singleton MyBean { }`\n+\n+== Use Case - I Need to Validate the Deployment\n+\n+Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong.\n+\n+=== _Solution 1_: register a `BeanDeploymentValidatorBuildItem`\n+\n+If you need to validate the deployment with no _build time context_ use the `BeanDeploymentValidatorBuildItem` and leverage the `io.quarkus.arc.processor.BeanDeploymentValidator`.\n+\n+.`BeanDeploymentValidatorBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDeploymentValidatorBuildItem beanDeploymentValidator() {\n+    return new BeanDeploymentValidatorBuildItem(new BeanDeploymentValidator() {\n+         public void validate(ValidationContext context) {\n+             for (InjectionPointInfo injectionPoint : context.getInjectionPoints()) {\n+                 // NOTE: You can't produce a build item from within this callback!\n+                 System.out.println(\"Injection point: \" + injectionPoint);\n+             }\n+         }\n+    });\n+}\n+----\n+\n+TIP: You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationContext.beans()` method.\n+\n+=== _Solution 2_: `ValidationPhaseBuildItem`\n+\n+If an extension needs to produce other build items during the validation it should use the `ValidationPhaseBuildItem` instead.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ValidationPhaseBuildItem` should always produce a `ValidationErrorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+[source,java]\n+----\n+@BuildStep\n+void validate(ValidationPhaseBuildItem validationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ValidationErrorBuildItem> errors) {\n+   if (someCondition) {\n+     errors.produce(new ValidationErrorBuildItem(new IllegalStateException()));\n+     myBuildItem.produce(new MyBuildItem());\n+   }\n+}\n+----\n+\n+[[custom_context]]\n+== Use Case - Register a Custom CDI Context\n+\n+Sometimes extensions need to extend the set of built-in CDI scopes and contexts.\n+\n+=== _Solution 1_: `ContextRegistrarBuildItem`\n+\n+If you need to add a custom context and you're not going to produce a build item within the registration then use the `ContextRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ContextRegistrar` API.\n+\n+.`ContextRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ContextRegistrarBuildItem registerContext() {\n+    return new ContextRegistrarBuildItem(new ContextRegistrar() {\n+         public void register(RegistrationContext context) {\n+            // NOTE: You can't produce a build item from within this callback!\n+            context.configure(TransactionScoped.class).normal().contextClass(TransactionContext.class).done();\n+         }\n+    });\n+}\n+----\n+\n+=== _Solution 2_: `ContextRegistrationPhaseBuildItem`\n+\n+If an extension needs to produce other build items during the registration it should use the `ContextRegistrationPhaseBuildItem` instead.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ContextRegistrationPhaseBuildItem` should always produce a `ContextConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+[source,java]\n+----\n+@BuildStep\n+void registerContext(MyConfig config, ContextRegistrationPhaseBuildItem phase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ContextConfiguratorBuildItem> contexts) {\n+   if (config.isEnabled()) {\n+      ContextConfigurator configurator = phase.getContext().configure(TransactionScoped.class).normal().contextClass(TransactionContext.class).done();\n+      contexts.produce(new ContextConfiguratorBuildItem(configurator));\n+      myBuildItem.produce(new MyBuildItem());\n+   }\n+}\n+----\n+\n+=== What if I Need to Know All the Scopes Used in the Application?\n+\n+_Solution_: You can inject the `CustomScopeAnnotationsBuildItem` in a build step and use the convenient methods such as `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()`.\n+\n+[[additional_interceptor_bindings]]\n+== Use Case - Additional Interceptor Bindings\n+\n+In rare cases it might be handy to programmatically register an existing annotation that is not annotated with `@javax.interceptor.InterceptorBinding` as an interceptor binding.\n+This is similar to what CDI achieves through `BeforeBeanDiscovery#addInterceptorBinding()`.\n+Though here we are going to use `InterceptorBindingRegistrarBuildItem` to get it done.\n+\n+.`InterceptorBindingRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+InterceptorBindingRegistrarBuildItem addInterceptorBindings() {\n+    return new InterceptorBindingRegistrarBuildItem(new InterceptorBindingRegistrar() {\n+        @Override\n+        public Map<DotName, Set<String>> registerAdditionalBindings() { <1>\n+            return Collections.singletonMap(DotName.createSimple(NotAnInterceptorBinding.class.getName()),\n+                                        Collections.emptySet());\n+        }\n+    });\n+}\n+----\n+\n+[[injection_point_transformation]]\n+== Use Case - Injection Point Transformation\n+\n+Every now and then it is handy to be able to change the qualifiers of an injection point programmatically.\n+You can do just that with `InjectionPointTransformerBuildItem`.\n+The following sample shows how to apply transformation to injection points with type `Foo` that contain qualifier `MyQualifier`:\n+\n+.`InjectionPointTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+InjectionPointTransformerBuildItem transformer() {\n+    return new InjectionPointTransformerBuildItem(new InjectionPointsTransformer() {\n+\n+        public boolean appliesTo(Type requiredType) {\n+            return requiredType.name().equals(DotName.createSimple(Foo.class.getName()));\n+        }\n+\n+        public void transform(TransformationContext context) {\n+            if (context.getQualifiers().stream()\n+                    .anyMatch(a -> a.name().equals(DotName.createSimple(MyQualifier.class.getName())))) {\n+                context.transform()\n+                        .removeAll()\n+                        .add(DotName.createSimple(MyOtherQualifier.class.getName()))\n+                        .done();\n+            }\n+        }\n+    });\n+}\n+----\n+\n+NOTE: In theory, you can use <<annotations_transformer_build_item,an `AnnotationsTransformer`>> to achieve the same goal. However, there are few differences that make `InjectionPointsTransformer` more suitable for this particular task: (1) Annotation transformers are applied before to all classes during bean discovery whereas `InjectionPointsTransformer` is only applied to discovered injection point after bean discovery and (2) with `InjectionPointsTransformer` you don't need to handle various types of injection points (field, parameters of initializer methods, etc.).\n+\n+== Use Case - Resource Annotations and Injection\n+\n+The `ResourceAnnotationBuildItem` can be used to specify resource annotations that make it possible to resolve non-CDI injection points, such as Java EE resources.\n+An integrator must also provide a corresponding `io.quarkus.arc.ResourceReferenceProvider` service provider implementation. \n+\n+.`ResourceAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void setupResourceInjection(BuildProducer<ResourceAnnotationBuildItem> resourceAnnotations, BuildProducer<GeneratedResourceBuildItem> resources) {\n+    resources.produce(new GeneratedResourceBuildItem(\"META-INF/services/io.quarkus.arc.ResourceReferenceProvider\",\n+        MyResourceReferenceProvider.class.getName().getBytes()));\n+    resourceAnnotations.produce(new ResourceAnnotationBuildItem(DotName.createSimple(MyAnnotation.class.getName())));\n+}\n+----\n+\n+[[build_metadata]]\n+== Available Build Time Metadata\n+\n+Any of the above extensions that operates with `BuildExtension.BuildContext` can leverage certain build time metadata that are generated during build.\n+The built-in keys located in `io.quarkus.arc.processor.BuildExtension.Key` are:\n+\n+* `ANNOTATION_STORE`\n+** Contains an `AnnotationStore` that keeps information about all `AnnotationTarget` annotations after application of annotation transformers\n+* `INJECTION_POINTS`\n+** `Collection<InjectionPointInfo>` containing all injection points\n+* `BEANS`\n+** `Collection<BeanInfo>` containing all beans\n+* `REMOVED_BEANS`\n+** `Collection<BeanInfo>` containing all the removed beans; see <<remove_unused_beans>> for more information\n+* `OBSERVERS`\n+** `Collection<ObserverInfo>` containing all observers\n+* `SCOPES`\n+** `Collection<ScopeInfo>` containing all scopes, including custom ones\n+* `QUALIFIERS`\n+** `Map<DotName, ClassInfo>` containing all qualifiers\n+* `INTERCEPTOR_BINDINGS`\n+** `Map<DotName, ClassInfo>` containing all interceptor bindings\n+* `STEREOTYPES`\n+** `Map<DotName, ClassInfo>` containing all stereotypes", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI3MjY3Mg=="}, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 577}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTM0Njk2OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMTo0NjozMVrOIBVoaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMTo0NjozMVrOIBVoaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI3Mzg5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Note that these metadata are made available as build proceeds which means that extensions can only leverage metadata that were build before they are invoked.\n          \n          \n            \n            Note that these metadata are made available as build proceeds which means that extensions can only leverage metadata that were built before the extensions are invoked.\n          \n      \n    \n    \n  \n\n(Two subjects, not clear to which the \"they\" refers.)", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538273897", "createdAt": "2020-12-08T11:46:31Z", "author": {"login": "Ladicek"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfiguratorio#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder`>> method and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`:\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation of the `Foo` bean instance.\n+====\n+\n+NOTE: It is also possible to use the `BeanRegistrarBuildItem` and `BeanRegistrationPhaseBuildItem` build items to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus.\n+\n+[[synthetic_observers]]\n+== Use Case - Synthetic Observers\n+\n+Similar to <<synthetic_beans,synthetic beans>> the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension.\n+\n+=== _Solution 1_: `ObserverRegistrarBuildItem`\n+\n+If you need to register a synthetic observer that requires no _build time context_ use the `ObserverRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ObserverConfigurator` API to build a synthetic observer method definition.\n+\n+NOTE: The <<cdi-reference.adoc#startup_event,`@Startup` feature>> is implemented as a synthetic observer method.\n+\n+.`ObserverRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ObserverRegistrarBuildItem syntheticObserver() {\n+    return new ObserverRegistrarBuildItem(new ObserverRegistrar() {\n+       @Override\n+       public void register(RegistrationContext context) {\n+          // NOTE: You can't produce a build item from within this callback!\n+          context.configure().observedType(String.class) <1>\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+            }\n+        }));\n+}\n+----\n+<1> The output of a `ObserverConfigurator` is recorded as bytecode. Therefore, there are some limitations in how a synthetic observer is invoked at runtime. Currently, you must generate the bytecode of the method body directly.\n+\n+=== _Solution 2_: `ObserverRegistrationPhaseBuildItem`\n+\n+If a build step *needs to produce other build items during the registration* it should use the `ObserverRegistrationPhaseBuildItem`.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+.`ObserverRegistrationPhaseBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurators) {\n+   observerConfigurators.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext().configure().observedType(String.class)\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+   myBuildItem.produce(new MyBuildItem());\n+}\n+----\n+\n+[[generated_beans]]\n+== Use Case - I Have a Generated Bean Class\n+\n+No problem.\n+You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`.\n+\n+.`GeneratedBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+GeneratedBeanBuildItem generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {\n+    ClassOutput beansClassOutput = new GeneratedBeanGizmoAdaptor(generatedBeans); <1>\n+    ClassCreator beanClassCreator = ClassCreator.builder().classOutput(beansClassOutput)\n+                .className(\"org.acme.MyBean\")\n+                .build();\n+    beanClassCreator.addAnnotation(Singleton.class);\n+    beanClassCreator.close(); <2>\n+}\n+----\n+<1> A convenient `io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` can be used to produce a `GeneratedBeanBuildItem` from Gizmo constructs.\n+<2> The resulting bean class is something like `public class @Singleton MyBean { }`\n+\n+== Use Case - I Need to Validate the Deployment\n+\n+Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong.\n+\n+=== _Solution 1_: register a `BeanDeploymentValidatorBuildItem`\n+\n+If you need to validate the deployment with no _build time context_ use the `BeanDeploymentValidatorBuildItem` and leverage the `io.quarkus.arc.processor.BeanDeploymentValidator`.\n+\n+.`BeanDeploymentValidatorBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDeploymentValidatorBuildItem beanDeploymentValidator() {\n+    return new BeanDeploymentValidatorBuildItem(new BeanDeploymentValidator() {\n+         public void validate(ValidationContext context) {\n+             for (InjectionPointInfo injectionPoint : context.getInjectionPoints()) {\n+                 // NOTE: You can't produce a build item from within this callback!\n+                 System.out.println(\"Injection point: \" + injectionPoint);\n+             }\n+         }\n+    });\n+}\n+----\n+\n+TIP: You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationContext.beans()` method.\n+\n+=== _Solution 2_: `ValidationPhaseBuildItem`\n+\n+If an extension needs to produce other build items during the validation it should use the `ValidationPhaseBuildItem` instead.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ValidationPhaseBuildItem` should always produce a `ValidationErrorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+[source,java]\n+----\n+@BuildStep\n+void validate(ValidationPhaseBuildItem validationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ValidationErrorBuildItem> errors) {\n+   if (someCondition) {\n+     errors.produce(new ValidationErrorBuildItem(new IllegalStateException()));\n+     myBuildItem.produce(new MyBuildItem());\n+   }\n+}\n+----\n+\n+[[custom_context]]\n+== Use Case - Register a Custom CDI Context\n+\n+Sometimes extensions need to extend the set of built-in CDI scopes and contexts.\n+\n+=== _Solution 1_: `ContextRegistrarBuildItem`\n+\n+If you need to add a custom context and you're not going to produce a build item within the registration then use the `ContextRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ContextRegistrar` API.\n+\n+.`ContextRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ContextRegistrarBuildItem registerContext() {\n+    return new ContextRegistrarBuildItem(new ContextRegistrar() {\n+         public void register(RegistrationContext context) {\n+            // NOTE: You can't produce a build item from within this callback!\n+            context.configure(TransactionScoped.class).normal().contextClass(TransactionContext.class).done();\n+         }\n+    });\n+}\n+----\n+\n+=== _Solution 2_: `ContextRegistrationPhaseBuildItem`\n+\n+If an extension needs to produce other build items during the registration it should use the `ContextRegistrationPhaseBuildItem` instead.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ContextRegistrationPhaseBuildItem` should always produce a `ContextConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+[source,java]\n+----\n+@BuildStep\n+void registerContext(MyConfig config, ContextRegistrationPhaseBuildItem phase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ContextConfiguratorBuildItem> contexts) {\n+   if (config.isEnabled()) {\n+      ContextConfigurator configurator = phase.getContext().configure(TransactionScoped.class).normal().contextClass(TransactionContext.class).done();\n+      contexts.produce(new ContextConfiguratorBuildItem(configurator));\n+      myBuildItem.produce(new MyBuildItem());\n+   }\n+}\n+----\n+\n+=== What if I Need to Know All the Scopes Used in the Application?\n+\n+_Solution_: You can inject the `CustomScopeAnnotationsBuildItem` in a build step and use the convenient methods such as `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()`.\n+\n+[[additional_interceptor_bindings]]\n+== Use Case - Additional Interceptor Bindings\n+\n+In rare cases it might be handy to programmatically register an existing annotation that is not annotated with `@javax.interceptor.InterceptorBinding` as an interceptor binding.\n+This is similar to what CDI achieves through `BeforeBeanDiscovery#addInterceptorBinding()`.\n+Though here we are going to use `InterceptorBindingRegistrarBuildItem` to get it done.\n+\n+.`InterceptorBindingRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+InterceptorBindingRegistrarBuildItem addInterceptorBindings() {\n+    return new InterceptorBindingRegistrarBuildItem(new InterceptorBindingRegistrar() {\n+        @Override\n+        public Map<DotName, Set<String>> registerAdditionalBindings() { <1>\n+            return Collections.singletonMap(DotName.createSimple(NotAnInterceptorBinding.class.getName()),\n+                                        Collections.emptySet());\n+        }\n+    });\n+}\n+----\n+\n+[[injection_point_transformation]]\n+== Use Case - Injection Point Transformation\n+\n+Every now and then it is handy to be able to change the qualifiers of an injection point programmatically.\n+You can do just that with `InjectionPointTransformerBuildItem`.\n+The following sample shows how to apply transformation to injection points with type `Foo` that contain qualifier `MyQualifier`:\n+\n+.`InjectionPointTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+InjectionPointTransformerBuildItem transformer() {\n+    return new InjectionPointTransformerBuildItem(new InjectionPointsTransformer() {\n+\n+        public boolean appliesTo(Type requiredType) {\n+            return requiredType.name().equals(DotName.createSimple(Foo.class.getName()));\n+        }\n+\n+        public void transform(TransformationContext context) {\n+            if (context.getQualifiers().stream()\n+                    .anyMatch(a -> a.name().equals(DotName.createSimple(MyQualifier.class.getName())))) {\n+                context.transform()\n+                        .removeAll()\n+                        .add(DotName.createSimple(MyOtherQualifier.class.getName()))\n+                        .done();\n+            }\n+        }\n+    });\n+}\n+----\n+\n+NOTE: In theory, you can use <<annotations_transformer_build_item,an `AnnotationsTransformer`>> to achieve the same goal. However, there are few differences that make `InjectionPointsTransformer` more suitable for this particular task: (1) Annotation transformers are applied before to all classes during bean discovery whereas `InjectionPointsTransformer` is only applied to discovered injection point after bean discovery and (2) with `InjectionPointsTransformer` you don't need to handle various types of injection points (field, parameters of initializer methods, etc.).\n+\n+== Use Case - Resource Annotations and Injection\n+\n+The `ResourceAnnotationBuildItem` can be used to specify resource annotations that make it possible to resolve non-CDI injection points, such as Java EE resources.\n+An integrator must also provide a corresponding `io.quarkus.arc.ResourceReferenceProvider` service provider implementation. \n+\n+.`ResourceAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void setupResourceInjection(BuildProducer<ResourceAnnotationBuildItem> resourceAnnotations, BuildProducer<GeneratedResourceBuildItem> resources) {\n+    resources.produce(new GeneratedResourceBuildItem(\"META-INF/services/io.quarkus.arc.ResourceReferenceProvider\",\n+        MyResourceReferenceProvider.class.getName().getBytes()));\n+    resourceAnnotations.produce(new ResourceAnnotationBuildItem(DotName.createSimple(MyAnnotation.class.getName())));\n+}\n+----\n+\n+[[build_metadata]]\n+== Available Build Time Metadata\n+\n+Any of the above extensions that operates with `BuildExtension.BuildContext` can leverage certain build time metadata that are generated during build.\n+The built-in keys located in `io.quarkus.arc.processor.BuildExtension.Key` are:\n+\n+* `ANNOTATION_STORE`\n+** Contains an `AnnotationStore` that keeps information about all `AnnotationTarget` annotations after application of annotation transformers\n+* `INJECTION_POINTS`\n+** `Collection<InjectionPointInfo>` containing all injection points\n+* `BEANS`\n+** `Collection<BeanInfo>` containing all beans\n+* `REMOVED_BEANS`\n+** `Collection<BeanInfo>` containing all the removed beans; see <<remove_unused_beans>> for more information\n+* `OBSERVERS`\n+** `Collection<ObserverInfo>` containing all observers\n+* `SCOPES`\n+** `Collection<ScopeInfo>` containing all scopes, including custom ones\n+* `QUALIFIERS`\n+** `Map<DotName, ClassInfo>` containing all qualifiers\n+* `INTERCEPTOR_BINDINGS`\n+** `Map<DotName, ClassInfo>` containing all interceptor bindings\n+* `STEREOTYPES`\n+** `Map<DotName, ClassInfo>` containing all stereotypes\n+\n+To get hold of these, simply query the extension context object for given key.\n+Note that these metadata are made available as build proceeds which means that extensions can only leverage metadata that were build before they are invoked.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 580}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTQzOTYyOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMjowMjoyN1rOIBWkIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMjowNToyNlrOIBWt3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI4OTE4Nw==", "bodyText": "What's \"simplified development mode\"? Isn't it just \"development mode\"?", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538289187", "createdAt": "2020-12-08T12:02:27Z", "author": {"login": "Ladicek"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI5MTY3OQ==", "bodyText": "IDK. copy&paste. I'll fix it.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538291679", "createdAt": "2020-12-08T12:05:26Z", "author": {"login": "mkouba"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI4OTE4Nw=="}, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3OTQ0NzUzOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMjowNDowMVrOIBWpZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMjowNDowMVrOIBWpZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI5MDUzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.\n          \n          \n            \n            If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>>, they are just ignored.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538290533", "createdAt": "2020-12-08T12:04:01Z", "author": {"login": "Ladicek"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,597 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,simplified development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>> they are just ignored.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cfb3dc0b9a37bfd36f516402eff4dc64f322680"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MDMxODc2OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDoyNzo0M1rOIBfS2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDoyNzo0M1rOIBfS2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMjIxNg==", "bodyText": "s/extenions/extensions", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538432216", "createdAt": "2020-12-08T14:27:43Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,606 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99be638fb2a0db6a7d56f1a773551adf837b21f1"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MDMyNzEyOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDoyOTowN1rOIBfYDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDoyOTowN1rOIBfYDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzMzU0OA==", "bodyText": "I think you can drop convenient here - it doesn't add anything to the sentence", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538433548", "createdAt": "2020-12-08T14:29:07Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,606 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99be638fb2a0db6a7d56f1a773551adf837b21f1"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MDM1NDAzOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDozMzoxN1rOIBfoqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDozMzoxN1rOIBfoqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQzNzgwMQ==", "bodyText": "Is there a reason why two backticks are used?", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538437801", "createdAt": "2020-12-08T14:33:17Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,606 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>>, they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+Bean classes added via `BeanDefiningAnnotationBuildItem` are _not removable_ by default, i.e. the resulting beans must not be removed even if they are considered unused.\n+However, you can change the default behavior.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to specify the default scope.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99be638fb2a0db6a7d56f1a773551adf837b21f1"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MDM4MTc4OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDozNzoyNFrOIBf6Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDozNzoyNFrOIBf6Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ0MjMwNw==", "bodyText": "I think you meant to return void here", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538442307", "createdAt": "2020-12-08T14:37:24Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,606 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>>, they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+Bean classes added via `BeanDefiningAnnotationBuildItem` are _not removable_ by default, i.e. the resulting beans must not be removed even if they are considered unused.\n+However, you can change the default behavior.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to specify the default scope.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfigurator#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder`>> method and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`:\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation of the `Foo` bean instance.\n+====\n+\n+NOTE: It is also possible to use the `BeanRegistrarBuildItem` and `BeanRegistrationPhaseBuildItem` build items to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus.\n+\n+[[synthetic_observers]]\n+== Use Case - Synthetic Observers\n+\n+Similar to <<synthetic_beans,synthetic beans>>, the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension.\n+\n+=== _Solution 1_: `ObserverRegistrarBuildItem`\n+\n+If you need to register a synthetic observer that requires no _build time context_, use the `ObserverRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ObserverConfigurator` API to build a synthetic observer method definition.\n+\n+NOTE: The <<cdi-reference.adoc#startup_event,`@Startup` feature>> is implemented as a synthetic observer method.\n+\n+.`ObserverRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ObserverRegistrarBuildItem syntheticObserver() {\n+    return new ObserverRegistrarBuildItem(new ObserverRegistrar() {\n+       @Override\n+       public void register(RegistrationContext context) {\n+          // NOTE: You can't produce a build item from within this callback!\n+          context.configure().observedType(String.class) <1>\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+            }\n+        }));\n+}\n+----\n+<1> The output of a `ObserverConfigurator` is recorded as bytecode. Therefore, there are some limitations in how a synthetic observer is invoked at runtime. Currently, you must generate the bytecode of the method body directly.\n+\n+=== _Solution 2_: `ObserverRegistrationPhaseBuildItem`\n+\n+If a build step *needs to produce other build items during the registration* it should use the `ObserverRegistrationPhaseBuildItem`.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+.`ObserverRegistrationPhaseBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurators) {\n+   observerConfigurators.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext().configure().observedType(String.class)\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+   myBuildItem.produce(new MyBuildItem());\n+}\n+----\n+\n+[[generated_beans]]\n+== Use Case - I Have a Generated Bean Class\n+\n+No problem.\n+You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`.\n+\n+.`GeneratedBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+GeneratedBeanBuildItem generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99be638fb2a0db6a7d56f1a773551adf837b21f1"}, "originalPosition": 386}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MDM5MTU2OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDozODo0N1rOIBgAag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNDozODo0N1rOIBgAag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ0Mzg4Mg==", "bodyText": "I would rephrase as: Using io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor makes it easy to produce GeneratedBeanBuildItem from Gizmo constructs", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538443882", "createdAt": "2020-12-08T14:38:47Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,606 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extenions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> Convenient `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>>, they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+Bean classes added via `BeanDefiningAnnotationBuildItem` are _not removable_ by default, i.e. the resulting beans must not be removed even if they are considered unused.\n+However, you can change the default behavior.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to specify the default scope.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of ``BeanDiscoveryFinishedBuildItem`` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfigurator#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder`>> method and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`:\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation of the `Foo` bean instance.\n+====\n+\n+NOTE: It is also possible to use the `BeanRegistrarBuildItem` and `BeanRegistrationPhaseBuildItem` build items to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus.\n+\n+[[synthetic_observers]]\n+== Use Case - Synthetic Observers\n+\n+Similar to <<synthetic_beans,synthetic beans>>, the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension.\n+\n+=== _Solution 1_: `ObserverRegistrarBuildItem`\n+\n+If you need to register a synthetic observer that requires no _build time context_, use the `ObserverRegistrarBuildItem` and leverage the `io.quarkus.arc.processor.ObserverConfigurator` API to build a synthetic observer method definition.\n+\n+NOTE: The <<cdi-reference.adoc#startup_event,`@Startup` feature>> is implemented as a synthetic observer method.\n+\n+.`ObserverRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ObserverRegistrarBuildItem syntheticObserver() {\n+    return new ObserverRegistrarBuildItem(new ObserverRegistrar() {\n+       @Override\n+       public void register(RegistrationContext context) {\n+          // NOTE: You can't produce a build item from within this callback!\n+          context.configure().observedType(String.class) <1>\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+            }\n+        }));\n+}\n+----\n+<1> The output of a `ObserverConfigurator` is recorded as bytecode. Therefore, there are some limitations in how a synthetic observer is invoked at runtime. Currently, you must generate the bytecode of the method body directly.\n+\n+=== _Solution 2_: `ObserverRegistrationPhaseBuildItem`\n+\n+If a build step *needs to produce other build items during the registration* it should use the `ObserverRegistrationPhaseBuildItem`.\n+The reason is that an injected `BuildProducer` is only valid during a `@BuildStep` method invocation.\n+\n+IMPORTANT: A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+.`ObserverRegistrationPhaseBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurators) {\n+   observerConfigurators.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext().configure().observedType(String.class)\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+   myBuildItem.produce(new MyBuildItem());\n+}\n+----\n+\n+[[generated_beans]]\n+== Use Case - I Have a Generated Bean Class\n+\n+No problem.\n+You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`.\n+\n+.`GeneratedBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+GeneratedBeanBuildItem generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {\n+    ClassOutput beansClassOutput = new GeneratedBeanGizmoAdaptor(generatedBeans); <1>\n+    ClassCreator beanClassCreator = ClassCreator.builder().classOutput(beansClassOutput)\n+                .className(\"org.acme.MyBean\")\n+                .build();\n+    beanClassCreator.addAnnotation(Singleton.class);\n+    beanClassCreator.close(); <2>\n+}\n+----\n+<1> A convenient `io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` can be used to produce a `GeneratedBeanBuildItem` from Gizmo constructs.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99be638fb2a0db6a7d56f1a773551adf837b21f1"}, "originalPosition": 395}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MjM4OTU3OnYy", "diffSide": "RIGHT", "path": "extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/SynthesisFinishedBuildItem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMDowMDozOVrOIBzseQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMDowMDozOVrOIBzseQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2NjQ1Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Additionaly, the bean resolver can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean\n          \n          \n            \n             * Additionaly, the bean resolver can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538766457", "createdAt": "2020-12-08T20:00:39Z", "author": {"login": "metacosm"}, "path": "extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/SynthesisFinishedBuildItem.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package io.quarkus.arc.deployment;\n+\n+import io.quarkus.arc.processor.BeanDeployment;\n+\n+/**\n+ * Consumers of this build item can easily inspect all beans, observers and injection points registered in the\n+ * application. Synthetic beans and observers are included. If interested in class-based components only you can use the\n+ * {@link BeanDiscoveryFinishedBuildItem} instead.\n+ * <p>\n+ * Additionaly, the bean resolver can be used to apply the type-safe resolution rules, e.g. to find out wheter there is a bean", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bbbcdfa3421fece1bceaba43c61d5cb0c29d7c0"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MjQxNTEzOnYy", "diffSide": "RIGHT", "path": "extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/SyntheticBeanBuildItem.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMDowNzowMlrOIBz7Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODo1NToxNFrOICJVxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MDI0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    \"It is not defined how a bean instance should be created, use ExtendedBeanConfigurator#creator(), ExtendedBeanConfigurator#supplier() or ExtendedBeanConfigurator#runtimeValue()\");\n          \n          \n            \n                                    \"No creation modality has been defined for SyntheticBean of type \" + getImplClazz() + \", use ExtendedBeanConfigurator#creator(), ExtendedBeanConfigurator#supplier() or ExtendedBeanConfigurator#runtimeValue()\");", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538770243", "createdAt": "2020-12-08T20:07:02Z", "author": {"login": "metacosm"}, "path": "extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/SyntheticBeanBuildItem.java", "diffHunk": "@@ -65,8 +84,9 @@ public SyntheticBeanBuildItem done() {\n             if (supplier != null && runtimeValue != null) {\n                 throw new IllegalStateException(\"It is not possible to specify both - a supplier and a runtime value\");\n             }\n-            if (supplier == null && runtimeValue == null) {\n-                throw new IllegalStateException(\"Either a supplier or a runtime value must be set\");\n+            if (creatorConsumer == null && supplier == null && runtimeValue == null) {\n+                throw new IllegalStateException(\n+                        \"It is not defined how a bean instance should be created, use ExtendedBeanConfigurator#creator(), ExtendedBeanConfigurator#supplier() or ExtendedBeanConfigurator#runtimeValue()\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bbbcdfa3421fece1bceaba43c61d5cb0c29d7c0"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3MzI3Nw==", "bodyText": "With all respect, I find \"No creation modality has been defined\" really cryptic. Also the class info is not that important because the stack will contain the exact location of the failure and the extension developer should immediately fix the problem.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539073277", "createdAt": "2020-12-09T07:37:46Z", "author": {"login": "mkouba"}, "path": "extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/SyntheticBeanBuildItem.java", "diffHunk": "@@ -65,8 +84,9 @@ public SyntheticBeanBuildItem done() {\n             if (supplier != null && runtimeValue != null) {\n                 throw new IllegalStateException(\"It is not possible to specify both - a supplier and a runtime value\");\n             }\n-            if (supplier == null && runtimeValue == null) {\n-                throw new IllegalStateException(\"Either a supplier or a runtime value must be set\");\n+            if (creatorConsumer == null && supplier == null && runtimeValue == null) {\n+                throw new IllegalStateException(\n+                        \"It is not defined how a bean instance should be created, use ExtendedBeanConfigurator#creator(), ExtendedBeanConfigurator#supplier() or ExtendedBeanConfigurator#runtimeValue()\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MDI0Mw=="}, "originalCommit": {"oid": "6bbbcdfa3421fece1bceaba43c61d5cb0c29d7c0"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTExMDkzOQ==", "bodyText": "Does it hurt to add the class info? If not, I'd add it.\nAs for No creation modality, I agree that it's not the best wording. How about:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    \"It is not defined how a bean instance should be created, use ExtendedBeanConfigurator#creator(), ExtendedBeanConfigurator#supplier() or ExtendedBeanConfigurator#runtimeValue()\");\n          \n          \n            \n                                    \"SyntheticBean for type \" + getImplClazz() + \" does not provide a creation method. Use either ExtendedBeanConfigurator#creator(), ExtendedBeanConfigurator#supplier() or ExtendedBeanConfigurator#runtimeValue()\");", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539110939", "createdAt": "2020-12-09T08:40:09Z", "author": {"login": "metacosm"}, "path": "extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/SyntheticBeanBuildItem.java", "diffHunk": "@@ -65,8 +84,9 @@ public SyntheticBeanBuildItem done() {\n             if (supplier != null && runtimeValue != null) {\n                 throw new IllegalStateException(\"It is not possible to specify both - a supplier and a runtime value\");\n             }\n-            if (supplier == null && runtimeValue == null) {\n-                throw new IllegalStateException(\"Either a supplier or a runtime value must be set\");\n+            if (creatorConsumer == null && supplier == null && runtimeValue == null) {\n+                throw new IllegalStateException(\n+                        \"It is not defined how a bean instance should be created, use ExtendedBeanConfigurator#creator(), ExtendedBeanConfigurator#supplier() or ExtendedBeanConfigurator#runtimeValue()\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MDI0Mw=="}, "originalCommit": {"oid": "6bbbcdfa3421fece1bceaba43c61d5cb0c29d7c0"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEyMTA5NQ==", "bodyText": "Does it hurt to add the class info? If not, I'd add it.\n\nIt does not hurt but it's not that relevant in the context of a synthetic bean, e.g. if you add a synthetic bean for java.lang.String it does not help much.\nI like the \"Synthetic bean does not provide a creation method...\" though!", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539121095", "createdAt": "2020-12-09T08:55:14Z", "author": {"login": "mkouba"}, "path": "extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/SyntheticBeanBuildItem.java", "diffHunk": "@@ -65,8 +84,9 @@ public SyntheticBeanBuildItem done() {\n             if (supplier != null && runtimeValue != null) {\n                 throw new IllegalStateException(\"It is not possible to specify both - a supplier and a runtime value\");\n             }\n-            if (supplier == null && runtimeValue == null) {\n-                throw new IllegalStateException(\"Either a supplier or a runtime value must be set\");\n+            if (creatorConsumer == null && supplier == null && runtimeValue == null) {\n+                throw new IllegalStateException(\n+                        \"It is not defined how a bean instance should be created, use ExtendedBeanConfigurator#creator(), ExtendedBeanConfigurator#supplier() or ExtendedBeanConfigurator#runtimeValue()\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MDI0Mw=="}, "originalCommit": {"oid": "6bbbcdfa3421fece1bceaba43c61d5cb0c29d7c0"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzAzNTI0OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjozOToxMVrOIB5fww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjozOToxMVrOIB5fww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2MTUwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n          \n          \n            \n            Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.\n          \n      \n    \n    \n  \n\nIt would also be helpful to add an example of what is meant by \"not derived from an existing class\" to make synthetic beans more palatable to users. In particular, when they make sense as opposed to \"regular\" beans\u2026", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538861507", "createdAt": "2020-12-08T22:39:11Z", "author": {"login": "metacosm"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,544 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bbbcdfa3421fece1bceaba43c61d5cb0c29d7c0"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzA0NzY3OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjo0MjozOVrOIB5mrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwOTowMToyMFrOICJm1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2MzI3Ng==", "bodyText": "It would be helpful to explain in greater details why it's important (because some beans that you might expect might not be there anymore at the end of the process, more are added, etc.) and maybe provide some examples to show concretely what might happen.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538863276", "createdAt": "2020-12-08T22:42:39Z", "author": {"login": "metacosm"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,544 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extensions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bbbcdfa3421fece1bceaba43c61d5cb0c29d7c0"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA4MTMzOQ==", "bodyText": "That's a good idea but I'd like to keep this part of the docs concise. What about this: \"Extensions can turn classes, that would be otherwise ignored, into beans and vice versa. For example, a class that declares a @Scheduled method is always registered as a bean even if it is not annotated with a bean defining annotation and would be normally ignored.\"\nIn fact, it's probably a good topic for a blogpost or something like that. The list of examples of \"what might happen\" could be very long...", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539081339", "createdAt": "2020-12-09T07:53:16Z", "author": {"login": "mkouba"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,544 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extensions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2MzI3Ng=="}, "originalCommit": {"oid": "6bbbcdfa3421fece1bceaba43c61d5cb0c29d7c0"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTExNDI4MQ==", "bodyText": "I agree that it would be a good material for a blog post (and I intend to document some of my extension writing experience in such blogs).\nHowever, when looking at reference doc, I'd also expect it to be as complete as possible so that I don't have to look at lots of different places to find the information I need. The example you give would probably be good enough if we don't want to get into too many details here.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539114281", "createdAt": "2020-12-09T08:45:08Z", "author": {"login": "metacosm"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,544 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extensions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2MzI3Ng=="}, "originalCommit": {"oid": "6bbbcdfa3421fece1bceaba43c61d5cb0c29d7c0"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTExNDc0OQ==", "bodyText": "I think it is pretty clear, which might be my CDI deformation :)\nEspecially those two sentences below specifically say that extensions can turn classes into beans and vice versa.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539114749", "createdAt": "2020-12-09T08:45:51Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,544 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extensions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2MzI3Ng=="}, "originalCommit": {"oid": "6bbbcdfa3421fece1bceaba43c61d5cb0c29d7c0"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEyNTQ2MA==", "bodyText": "I'd also expect it to be as complete as possible so that I don't have to look at lots of different places to find the information I need.\n\nIt's always a question of balance. My concern is that \"too exhaustive\" docs may scare people ;-).\nWe can always add more examples.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539125460", "createdAt": "2020-12-09T09:01:20Z", "author": {"login": "mkouba"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,544 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extensions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2MzI3Ng=="}, "originalCommit": {"oid": "6bbbcdfa3421fece1bceaba43c61d5cb0c29d7c0"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzA0OTA1OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjo0MzowNlrOIB5ndQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMjo0MzowNlrOIB5ndQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg2MzQ3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.\n          \n          \n            \n            Sometimes an injection point cannot be satisfied even if there is a class on the class path that appears to be eligible for injection.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r538863477", "createdAt": "2020-12-08T22:43:06Z", "author": {"login": "metacosm"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,544 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully contolled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extensions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisifed even if there is a class on the class path that appears to be eligible for injection.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bbbcdfa3421fece1bceaba43c61d5cb0c29d7c0"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDc4MTkwOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODozNDo1MFrOICIgoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwOTo0NjoxN1rOICLnwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEwNzQ4OA==", "bodyText": "I thought we wanted to avoid mentioning ArC in guides? We could just replace that with The CDI container ....\nAlternatively, you could introduce Arc with - ArC, the CDI container, is bootstrapped at ...", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539107488", "createdAt": "2020-12-09T08:34:50Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,547 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e083b504ea6919df6f6233e0b4554bb440837d1"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE1ODQ2Ng==", "bodyText": "I don't think we have a \"strong\" policy, i.e. we already mention ArC in the ref guide. But I like the wording \"ArC, the CDI container,...\"", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539158466", "createdAt": "2020-12-09T09:46:17Z", "author": {"login": "mkouba"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,547 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEwNzQ4OA=="}, "originalCommit": {"oid": "0e083b504ea6919df6f6233e0b4554bb440837d1"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDg2NDc4OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODo1MzoyOVrOICJQvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwODo1MzoyOVrOICJQvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTExOTgwNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            It is aso possible to specify the default scope.\n          \n          \n            \n            It is also possible to specify the default scope.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539119804", "createdAt": "2020-12-09T08:53:29Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,547 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extensions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+\n+This way, extensions can turn classes, that would be otherwise ignored, into beans and vice versa.\n+For example, a class that declares a `@Scheduled` method is always registered as a bean even if it is not annotated with a bean defining annotation and would be normally ignored.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisfied even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>>, they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+Bean classes added via `BeanDefiningAnnotationBuildItem` are _not removable_ by default, i.e. the resulting beans must not be removed even if they are considered unused.\n+However, you can change the default behavior.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to specify the default scope.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e083b504ea6919df6f6233e0b4554bb440837d1"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDg5ODc3OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwOTowMDoyM1rOICJkOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwOTowMDoyM1rOICJkOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEyNDc5NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n          \n          \n            \n            NOTE: There are other build items specialized in transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539124795", "createdAt": "2020-12-09T09:00:23Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,547 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extensions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+\n+This way, extensions can turn classes, that would be otherwise ignored, into beans and vice versa.\n+For example, a class that declares a `@Scheduled` method is always registered as a bean even if it is not annotated with a bean defining annotation and would be normally ignored.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisfied even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>>, they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+Bean classes added via `BeanDefiningAnnotationBuildItem` are _not removable_ by default, i.e. the resulting beans must not be removed even if they are considered unused.\n+However, you can change the default behavior.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to specify the default scope.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e083b504ea6919df6f6233e0b4554bb440837d1"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDkzMjAyOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwOTowNzoyN1rOICJ3pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwOTowNzoyN1rOICJ3pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEyOTc2Ng==", "bodyText": "Maybe add a link to other Quarkus docs explaining difference between the two?", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539129766", "createdAt": "2020-12-09T09:07:27Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,547 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+The ArC container is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extensions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+\n+This way, extensions can turn classes, that would be otherwise ignored, into beans and vice versa.\n+For example, a class that declares a `@Scheduled` method is always registered as a bean even if it is not annotated with a bean defining annotation and would be normally ignored.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisfied even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>>, they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+Bean classes added via `BeanDefiningAnnotationBuildItem` are _not removable_ by default, i.e. the resulting beans must not be removed even if they are considered unused.\n+However, you can change the default behavior.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to specify the default scope.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized on transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of `BeanDiscoveryFinishedBuildItem` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation via `ExtendedBeanConfigurator#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder`>> method and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e083b504ea6919df6f6233e0b4554bb440837d1"}, "originalPosition": 291}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NTMwMjM5OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDoyNDo1NlrOICNSDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMToyMTo1NlrOICPnig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NTY3Ng==", "bodyText": "I'm surprised by the comma in -X,--debug ?", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539185676", "createdAt": "2020-12-09T10:24:56Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,548 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+ArC, the CDI container, is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fad305a9e2bbcb1c9c59e6d77798e526725bbd4"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIwNjc0OA==", "bodyText": "Those should be two different options to achieve the same logging. You can use -X or -debug or --debug to achieve the same thing.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539206748", "createdAt": "2020-12-09T10:55:45Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,548 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+ArC, the CDI container, is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NTY3Ng=="}, "originalCommit": {"oid": "6fad305a9e2bbcb1c9c59e6d77798e526725bbd4"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIyMzk0Ng==", "bodyText": "It should read -X or --debug.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539223946", "createdAt": "2020-12-09T11:21:56Z", "author": {"login": "mkouba"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,548 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+ArC, the CDI container, is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NTY3Ng=="}, "originalCommit": {"oid": "6fad305a9e2bbcb1c9c59e6d77798e526725bbd4"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NTMwODUxOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDoyNjoxM1rOICNVhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDoyNjoxM1rOICNVhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NjU2Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Sometimes an injection point cannot be satisfied even if there is a class on the class path that appears to be eligible for injection.\n          \n          \n            \n            Sometimes an injection point cannot be satisfied even if there is a class on the classpath that appears to be eligible for injection.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539186566", "createdAt": "2020-12-09T10:26:13Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,548 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+ArC, the CDI container, is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extensions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+\n+This way, extensions can turn classes, that would be otherwise ignored, into beans and vice versa.\n+For example, a class that declares a `@Scheduled` method is always registered as a bean even if it is not annotated with a bean defining annotation and would be normally ignored.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisfied even if there is a class on the class path that appears to be eligible for injection.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fad305a9e2bbcb1c9c59e6d77798e526725bbd4"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NTMyMjMzOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDoyOToxMlrOICNdsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDoyOToxMlrOICNdsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4ODY1Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n          \n          \n            \n            Therefore, bean classes that don't have a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539188656", "createdAt": "2020-12-09T10:29:12Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,548 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+ArC, the CDI container, is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extensions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+\n+This way, extensions can turn classes, that would be otherwise ignored, into beans and vice versa.\n+For example, a class that declares a `@Scheduled` method is always registered as a bean even if it is not annotated with a bean defining annotation and would be normally ignored.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisfied even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>>, they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fad305a9e2bbcb1c9c59e6d77798e526725bbd4"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NTMyNjM3OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDozMDowNVrOICNgGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDozMDowNVrOICNgGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4OTI3Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n          \n          \n            \n            <2> Add `@Singleton` as default scope. Classes already annotated with a scope are skipped automatically.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539189272", "createdAt": "2020-12-09T10:30:05Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,548 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+ArC, the CDI container, is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extensions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+\n+This way, extensions can turn classes, that would be otherwise ignored, into beans and vice versa.\n+For example, a class that declares a `@Scheduled` method is always registered as a bean even if it is not annotated with a bean defining annotation and would be normally ignored.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisfied even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>>, they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fad305a9e2bbcb1c9c59e6d77798e526725bbd4"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NTM0MDMyOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDozMzowMFrOICNoaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDozMzowMFrOICNoaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE5MTQwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 myBuildItem.produce(new MyBuildItem(););\n          \n          \n            \n                 myBuildItem.produce(new MyBuildItem());", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539191400", "createdAt": "2020-12-09T10:33:00Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,548 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+ArC, the CDI container, is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extensions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+\n+This way, extensions can turn classes, that would be otherwise ignored, into beans and vice versa.\n+For example, a class that declares a `@Scheduled` method is always registered as a bean even if it is not annotated with a bean defining annotation and would be normally ignored.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisfied even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>>, they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+Bean classes added via `BeanDefiningAnnotationBuildItem` are _not removable_ by default, i.e. the resulting beans must not be removed even if they are considered unused.\n+However, you can change the default behavior.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is also possible to specify the default scope.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fad305a9e2bbcb1c9c59e6d77798e526725bbd4"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NTM0MjIwOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDozMzoyNlrOICNpjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMTo0OTowNFrOICQpzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE5MTY5Mg==", "bodyText": "I think it would be nice to add a note saying explicitly that the index is not modified.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539191692", "createdAt": "2020-12-09T10:33:26Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,548 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+ArC, the CDI container, is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extensions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+\n+This way, extensions can turn classes, that would be otherwise ignored, into beans and vice versa.\n+For example, a class that declares a `@Scheduled` method is always registered as a bean even if it is not annotated with a bean defining annotation and would be normally ignored.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisfied even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>>, they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+Bean classes added via `BeanDefiningAnnotationBuildItem` are _not removable_ by default, i.e. the resulting beans must not be removed even if they are considered unused.\n+However, you can change the default behavior.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is also possible to specify the default scope.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fad305a9e2bbcb1c9c59e6d77798e526725bbd4"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIwODA4NQ==", "bodyText": "Hmm, this might be a good addition to the Metadata Sources paragraph. Generally stating that extensions alter metamodel but not the index itself.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539208085", "createdAt": "2020-12-09T10:57:38Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,548 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+ArC, the CDI container, is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extensions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+\n+This way, extensions can turn classes, that would be otherwise ignored, into beans and vice versa.\n+For example, a class that declares a `@Scheduled` method is always registered as a bean even if it is not annotated with a bean defining annotation and would be normally ignored.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisfied even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>>, they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+Bean classes added via `BeanDefiningAnnotationBuildItem` are _not removable_ by default, i.e. the resulting beans must not be removed even if they are considered unused.\n+However, you can change the default behavior.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is also possible to specify the default scope.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE5MTY5Mg=="}, "originalCommit": {"oid": "6fad305a9e2bbcb1c9c59e6d77798e526725bbd4"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI0MDkxMQ==", "bodyText": "Metadata Sources is now a separate section and the jandex index is mentioned there. I believe it's clear enough now ;-).", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539240911", "createdAt": "2020-12-09T11:49:04Z", "author": {"login": "mkouba"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,548 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+ArC, the CDI container, is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extensions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+\n+This way, extensions can turn classes, that would be otherwise ignored, into beans and vice versa.\n+For example, a class that declares a `@Scheduled` method is always registered as a bean even if it is not annotated with a bean defining annotation and would be normally ignored.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisfied even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>>, they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+Bean classes added via `BeanDefiningAnnotationBuildItem` are _not removable_ by default, i.e. the resulting beans must not be removed even if they are considered unused.\n+However, you can change the default behavior.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is also possible to specify the default scope.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE5MTY5Mg=="}, "originalCommit": {"oid": "6fad305a9e2bbcb1c9c59e6d77798e526725bbd4"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NTQwMzM4OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/cdi-integration.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDo0Njo0OVrOICONWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMToxNDo1NlrOICPV_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIwMDg1Ng==", "bodyText": "You might or might not want to change it but for this sort of things, you have Asciidoc's description lists: https://asciidoctor.org/docs/asciidoc-writers-guide/#description-lists", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539200856", "createdAt": "2020-12-09T10:46:49Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,548 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+ArC, the CDI container, is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extensions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+\n+This way, extensions can turn classes, that would be otherwise ignored, into beans and vice versa.\n+For example, a class that declares a `@Scheduled` method is always registered as a bean even if it is not annotated with a bean defining annotation and would be normally ignored.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisfied even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>>, they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+Bean classes added via `BeanDefiningAnnotationBuildItem` are _not removable_ by default, i.e. the resulting beans must not be removed even if they are considered unused.\n+However, you can change the default behavior.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is also possible to specify the default scope.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized in transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of `BeanDiscoveryFinishedBuildItem` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode of the `Contextual#create(CreationalContext<T>)` method directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation class via `ExtendedBeanConfigurator#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder` method>> and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`.\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`.\n+See the <<writing-extensions.adoc#bootstrap-three-phases,Three Phases of Bootstrap and Quarkus Philosophy>> for more information about the difference between `STATIC_INIT` and `RUNTIME_INIT`.\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation upon the `Foo` bean instance and thus we need to make sure that the build step is executed after all synthetic beans are initialized.\n+====\n+\n+NOTE: It is also possible to use the `BeanRegistrationPhaseBuildItem` to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus.\n+\n+[[synthetic_observers]]\n+== Use Case - Synthetic Observers\n+\n+Similar to <<synthetic_beans,synthetic beans>>, the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension.\n+\n+_Solution_: If you need to register a synthetic observer, use the `ObserverRegistrationPhaseBuildItem`.\n+\n+IMPORTANT: A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+.`ObserverRegistrationPhaseBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurators) {\n+   observerConfigurators.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext().configure().observedType(String.class)\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+   myBuildItem.produce(new MyBuildItem());\n+}\n+----\n+\n+The output of a `ObserverConfigurator` is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic observer is invoked at runtime. \n+Currently, you must generate the bytecode of the method body directly.\n+\n+[[generated_beans]]\n+== Use Case - I Have a Generated Bean Class\n+\n+No problem.\n+You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`.\n+\n+.`GeneratedBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {\n+    ClassOutput beansClassOutput = new GeneratedBeanGizmoAdaptor(generatedBeans); <1>\n+    ClassCreator beanClassCreator = ClassCreator.builder().classOutput(beansClassOutput)\n+                .className(\"org.acme.MyBean\")\n+                .build();\n+    beanClassCreator.addAnnotation(Singleton.class);\n+    beanClassCreator.close(); <2>\n+}\n+----\n+<1> `io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` makes it easy to produce ``GeneratedBeanBuildItem``s from Gizmo constructs.\n+<2> The resulting bean class is something like `public class @Singleton MyBean { }`.\n+\n+== Use Case - I Need to Validate the Deployment\n+\n+Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong.\n+\n+_Solution_: If an extension needs to validate the deployment it should use the `ValidationPhaseBuildItem`.\n+\n+IMPORTANT: A build step that consumes the `ValidationPhaseBuildItem` should always produce a `ValidationErrorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+[source,java]\n+----\n+@BuildStep\n+void validate(ValidationPhaseBuildItem validationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ValidationErrorBuildItem> errors) {\n+   if (someCondition) {\n+     errors.produce(new ValidationErrorBuildItem(new IllegalStateException()));\n+     myBuildItem.produce(new MyBuildItem());\n+   }\n+}\n+----\n+\n+TIP: You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationPhaseBuildItem.getContext().beans()` method.\n+\n+[[custom_context]]\n+== Use Case - Register a Custom CDI Context\n+\n+Sometimes extensions need to extend the set of built-in CDI contexts.\n+\n+_Solution_: If you need to register a custom context, use the `ContextRegistrationPhaseBuildItem`.\n+\n+IMPORTANT: A build step that consumes the `ContextRegistrationPhaseBuildItem` should always produce a `ContextConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+`ContextRegistrationPhaseBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ContextConfiguratorBuildItem registerContext(ContextRegistrationPhaseBuildItem phase) {\n+      return new ContextConfiguratorBuildItem(phase.getContext().configure(TransactionScoped.class).normal().contextClass(TransactionContext.class));\n+}\n+----\n+\n+Additionally, each extension that registers a custom CDI context via `ContextRegistrationPhaseBuildItem` should also produce the `CustomScopeBuildItem` in order to contribute the custom scope annotation name to the set of bean defining annotations.\n+\n+`CustomScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+CustomScopeBuildItem customScope() {\n+   return new CustomScopeBuildItem(DotName.createSimple(TransactionScoped.class.getName()));\n+}\n+----\n+\n+=== What if I Need to Know All the Scopes Used in the Application?\n+\n+_Solution_: You can inject the `CustomScopeAnnotationsBuildItem` in a build step and use the convenient methods such as `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()`.\n+\n+[[additional_interceptor_bindings]]\n+== Use Case - Additional Interceptor Bindings\n+\n+In rare cases it might be handy to programmatically register an existing annotation that is not annotated with `@javax.interceptor.InterceptorBinding` as an interceptor binding.\n+This is similar to what CDI achieves through `BeforeBeanDiscovery#addInterceptorBinding()`.\n+Though here we are going to use `InterceptorBindingRegistrarBuildItem` to get it done.\n+\n+.`InterceptorBindingRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+InterceptorBindingRegistrarBuildItem addInterceptorBindings() {\n+    return new InterceptorBindingRegistrarBuildItem(new InterceptorBindingRegistrar() {\n+        @Override\n+        public Map<DotName, Set<String>> registerAdditionalBindings() { <1>\n+            return Collections.singletonMap(DotName.createSimple(NotAnInterceptorBinding.class.getName()),\n+                                        Collections.emptySet());\n+        }\n+    });\n+}\n+----\n+\n+[[injection_point_transformation]]\n+== Use Case - Injection Point Transformation\n+\n+Every now and then it is handy to be able to change the qualifiers of an injection point programmatically.\n+You can do just that with `InjectionPointTransformerBuildItem`.\n+The following sample shows how to apply transformation to injection points with type `Foo` that contain qualifier `MyQualifier`:\n+\n+.`InjectionPointTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+InjectionPointTransformerBuildItem transformer() {\n+    return new InjectionPointTransformerBuildItem(new InjectionPointsTransformer() {\n+\n+        public boolean appliesTo(Type requiredType) {\n+            return requiredType.name().equals(DotName.createSimple(Foo.class.getName()));\n+        }\n+\n+        public void transform(TransformationContext context) {\n+            if (context.getQualifiers().stream()\n+                    .anyMatch(a -> a.name().equals(DotName.createSimple(MyQualifier.class.getName())))) {\n+                context.transform()\n+                        .removeAll()\n+                        .add(DotName.createSimple(MyOtherQualifier.class.getName()))\n+                        .done();\n+            }\n+        }\n+    });\n+}\n+----\n+\n+NOTE: In theory, you can use <<annotations_transformer_build_item,an `AnnotationsTransformer`>> to achieve the same goal. However, there are few differences that make `InjectionPointsTransformer` more suitable for this particular task: (1) annotation transformers are applied to all classes during bean discovery, whereas `InjectionPointsTransformer` is only applied to discovered injection points after bean discovery; (2) with `InjectionPointsTransformer` you don't need to handle various types of injection points (field, parameters of initializer methods, etc.).\n+\n+== Use Case - Resource Annotations and Injection\n+\n+The `ResourceAnnotationBuildItem` can be used to specify resource annotations that make it possible to resolve non-CDI injection points, such as Jakarta EE resources.\n+An integrator must also provide a corresponding `io.quarkus.arc.ResourceReferenceProvider` service provider implementation. \n+\n+.`ResourceAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void setupResourceInjection(BuildProducer<ResourceAnnotationBuildItem> resourceAnnotations, BuildProducer<GeneratedResourceBuildItem> resources) {\n+    resources.produce(new GeneratedResourceBuildItem(\"META-INF/services/io.quarkus.arc.ResourceReferenceProvider\",\n+        MyResourceReferenceProvider.class.getName().getBytes()));\n+    resourceAnnotations.produce(new ResourceAnnotationBuildItem(DotName.createSimple(MyAnnotation.class.getName())));\n+}\n+----\n+\n+[[build_metadata]]\n+== Available Build Time Metadata\n+\n+Any of the above extensions that operates with `BuildExtension.BuildContext` can leverage certain build time metadata that are generated during build.\n+The built-in keys located in `io.quarkus.arc.processor.BuildExtension.Key` are:\n+\n+* `ANNOTATION_STORE`\n+** Contains an `AnnotationStore` that keeps information about all `AnnotationTarget` annotations after application of annotation transformers\n+* `INJECTION_POINTS`\n+** `Collection<InjectionPointInfo>` containing all injection points\n+* `BEANS`\n+** `Collection<BeanInfo>` containing all beans\n+* `REMOVED_BEANS`\n+** `Collection<BeanInfo>` containing all the removed beans; see <<remove_unused_beans>> for more information\n+* `OBSERVERS`\n+** `Collection<ObserverInfo>` containing all observers\n+* `SCOPES`\n+** `Collection<ScopeInfo>` containing all scopes, including custom ones\n+* `QUALIFIERS`\n+** `Map<DotName, ClassInfo>` containing all qualifiers\n+* `INTERCEPTOR_BINDINGS`\n+** `Map<DotName, ClassInfo>` containing all interceptor bindings\n+* `STEREOTYPES`\n+** `Map<DotName, StereotypeInfo>` containing all stereotypes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fad305a9e2bbcb1c9c59e6d77798e526725bbd4"}, "originalPosition": 528}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIxOTQ1Mw==", "bodyText": "Interesting, will use it.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539219453", "createdAt": "2020-12-09T11:14:56Z", "author": {"login": "mkouba"}, "path": "docs/src/main/asciidoc/cdi-integration.adoc", "diffHunk": "@@ -0,0 +1,548 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - CDI Integration Guide\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+:toclevels: 2\n+\n+ArC, the CDI container, is bootstrapped at build time.\n+The downside of this approach is that CDI Portable Extensions cannot be supported.\n+Nevertheless, the functionality can be achieved using the Quarkus-specific extensions API.\n+\n+The container is bootstrapped in multiple phases.\n+From a high level perspective these phases go as follows:\n+\n+1. Initialization\n+2. Bean discovery \n+3. Registration of synthetic components\n+4. Validation\n+\n+In the _initialization_ phase the preparatory work is being carried out and custom contexts are registered.\n+_Bean discovery_ is then the process where the container analyzes all application classes, identifies beans and wires them all together based on the provided metadata.\n+Subsequently, the extensions can register _synthetic components_.\n+Attributes of these components are fully controlled by the extensions, i.e. are not derived from an existing class.\n+Finally, the _deployment is validated_.\n+For example, the container validates every injection point in the application and fails the build if there is no bean that satisfies the given required type and qualifiers.\n+\n+TIP: You can see more information about the bootstrap by enabling additional logging. Simply run the Maven build with `-X,--debug` and grep lines that contain `io.quarkus.arc`. In the <<cdi-reference.adoc#dev-mode,development mode>>, you can use `quarkus.log.category.\"io.quarkus.arc.processor\".level=DEBUG` and two special endpoints are also registered automatically to provide some basic debug info in the JSON format.\n+\n+Quarkus build steps can produce and consume various build items and hook into each phase.\n+In the following sections we will describe all the relevant build items and common scenarios.\n+\n+[IMPORTANT]\n+.Metadata Sources\n+====\n+Classes and annotations are the primary source of bean-level metadata.\n+However, extensions can add, remove or transform the metadata at certain stages of the bootstrap.\n+Moreover, extensions can also register <<synthetic_beans,synthetic components>>. \n+This is an important aspect to realize when integrating CDI components in Quarkus.\n+\n+This way, extensions can turn classes, that would be otherwise ignored, into beans and vice versa.\n+For example, a class that declares a `@Scheduled` method is always registered as a bean even if it is not annotated with a bean defining annotation and would be normally ignored.\n+====\n+\n+== Use Case - My Class Is Not Recognized as a Bean\n+\n+An `UnsatisfiedResolutionException` indicates a problem during <<cdi.adoc#typesafe_resolution,typesafe resolution>>.\n+Sometimes an injection point cannot be satisfied even if there is a class on the class path that appears to be eligible for injection.\n+There are several reasons why a class is not recognized and also several ways to fix it.\n+In the first step we should identify the _reason_.\n+\n+[[additional_bean_build_item]]\n+=== _Reason 1_: Class Is Not discovered \n+\n+Quarkus has a <<cdi-reference.adoc#bean_discovery,simplified discovery>>.\n+It might happen that the class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem`. \n+This build item can be used to specify one or more additional classes to be analyzed during the discovery. \n+Additional bean classes are transparently added to the application index processed by the container.\n+\n+.`AdditionalBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AdditionalBeanBuildItem additionalBeans() {\n+     return new AdditionalBeanBuildItem(SmallRyeHealthReporter.class, HealthServlet.class)); <1>\n+}\n+----\n+<1> `AdditionalBeanBuildItem.Builder` can be used for more complex use cases.\n+\n+Bean classes added via `AdditionalBeanBuildItem` are _removable_ by default.\n+If the container considers them <<cdi-reference.adoc#remove_unused_beans,unused>>, they are just ignored.\n+However, you can use `AdditionalBeanBuildItem.Builder.setUnremovable()` method to instruct the container to never remove bean classes registered via this build item.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is aso possible to set the default scope via `AdditionalBeanBuildItem.Builder#setDefaultScope()`.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+=== _Reason 2_: Class Is Discovered but Has No Bean Defining Annotation\n+\n+In Quarkus, the application is represented by a single bean archive with the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#default_bean_discovery[bean discovery mode `annotated`, window=\"_blank\"].\n+Therefore, bean classes that don't have a http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#bean_defining_annotations[bean defining annotation, window=\"_blank\"] are ignored.\n+Bean defining annotations are declared on the class-level and incluce scopes, stereotypes and `@Interceptor`.\n+\n+_Solution 1_: Use the `AutoAddScopeBuildItem`. This build item can be used to add a scope to a class that meets certain conditions.\n+\n+.`AutoAddScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AutoAddScopeBuildItem autoAddScope() {\n+   return AutoAddScopeBuildItem.builder().containsAnnotations(SCHEDULED_NAME, SCHEDULES_NAME) <1>\n+      .defaultScope(BuiltinScope.SINGLETON) <2>\n+      .build();\n+}\n+----\n+<1> Find all classes annotated with `@Scheduled`.\n+<2> Add `@Singleton`. Classes annotated with a scope are skipped automatically.\n+\n+_Solution 2_: If you need to process classes annotated with a specific annotation then it's possible to extend the set of bean defining annotations via the `BeanDefiningAnnotationBuildItem`.\n+\n+.`BeanDefiningAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+BeanDefiningAnnotationBuildItem additionalBeanDefiningAnnotation() {\n+   return new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API); <1>\n+}\n+----\n+<1> Add `org.eclipse.microprofile.graphql.GraphQLApi` to the set of bean defining annotations.\n+\n+Bean classes added via `BeanDefiningAnnotationBuildItem` are _not removable_ by default, i.e. the resulting beans must not be removed even if they are considered unused.\n+However, you can change the default behavior.\n+See also <<cdi-reference.adoc#remove_unused_beans,Removing Unused Beans>> and <<unremovable_builditem>> for more details.\n+\n+It is also possible to specify the default scope.\n+The default scope is only used if there is no scope declared on the bean class. \n+\n+NOTE: If no default scope is specified the `@Dependent` pseudo-scope is used.\n+\n+[[unremovable_builditem]]\n+=== _Reason 3_: Class Was Discovered and Has a Bean Defining Annotation but Was Removed\n+\n+The container attempts to <<cdi-reference.adoc#remove_unused_beans,remove all unused beans>> during the build by default.\n+This optimization allows for _framework-level dead code elimination_.\n+In few special cases, it's not possible to correctly identify an unused bean. \n+In particular, Quarkus is not able to detect the usage of the `CDI.current()` static method yet.\n+Extensions can eliminate possible false positives by producing an `UnremovableBeanBuildItem`.\n+\n+.`UnremovableBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+UnremovableBeanBuildItem unremovableBeans() {\n+   return UnremovableBeanBuildItem.targetWithAnnotation(STARTUP_NAME); <1>\n+}\n+----\n+<1> Make all classes annotated with `@Startup` unremovable.\n+\n+== Use Case - My Annotation Is Not Recognized as a Qualifier or an Interceptor Binding\n+\n+It is likely that the annotation class is not part of the application index.\n+For example, classes from the _runtime module_ of a Quarkus extension are not indexed automatically.\n+\n+_Solution_: Use the `AdditionalBeanBuildItem` as described in <<additional_bean_build_item>>. \n+\n+[[annotations_transformer_build_item]]\n+== Use Case - I Need To Transform Metadata\n+\n+In some cases, it's useful to be able to modify the metadata.\n+Quarkus provides a powerful alternative to https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#process_annotated_type[`javax.enterprise.inject.spi.ProcessAnnotatedType`, window=\"_blank\"].\n+With an `AnnotationsTransformerBuildItem` it's possible to override the annotations that exist on bean classes.\n+\n+For example, you might want to add an interceptor binding to a specific bean class.\n+Here is how to do it: \n+\n+.`AnnotationsTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+AnnotationsTransformerBuildItem transform() {\n+   return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+\n+      public boolean appliesTo(org.jboss.jandex.AnnotationTarget.Kind kind) {\n+         return kind == org.jboss.jandex.AnnotationTarget.Kind.CLASS; <1>\n+      }\n+\n+      public void transform(TransformationContext context) {\n+         if (context.getTarget().asClass().name().toString().equals(\"org.acme.Bar\")) {\n+            context.transform().add(MyInterceptorBinding.class).done(); <2>\n+         }\n+      }\n+    });\n+}\n+----\n+<1> The transformer is only applied to classes.\n+<2> If the class name equals to `org.acme.Bar` then add `@MyInterceptorBinding`. Don't forget to invoke `Transformation#done()`.\n+\n+NOTE: Keep in mind that annotation transformers must be produced _before_ the bean discovery starts.\n+\n+Build steps can query the transformed annotations for a given annotation target via the `TransformedAnnotationsBuildItem`.\n+\n+.`TransformedAnnotationsBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void queryAnnotations(TransformedAnnotationsBuildItem transformedAnnotations, BuildProducer<MyBuildItem> myBuildItem) {\n+   ClassInfo myClazz = ...;\n+   if (transformedAnnotations.getAnnotations(myClazz).isEmpty()) { <1>\n+     myBuildItem.produce(new MyBuildItem(););\n+   }\n+}\n+----\n+<1> `TransformedAnnotationsBuildItem.getAnnotations()` will return a possibly transformed set of annotations.\n+\n+NOTE: There are other build items specialized in transformation: <<additional_interceptor_bindings>> and <<injection_point_transformation>>.\n+\n+[[inspect_beans]]\n+== Use Case - Inspect Beans, Observers and Injection Points\n+\n+=== _Solution 1_: `BeanDiscoveryFinishedBuildItem`\n+\n+Consumers of `BeanDiscoveryFinishedBuildItem` can easily inspect all class-based beans, observers and injection points registered in the application.\n+However, synthetic beans and observers are _not included_ because this build item is produced _before_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `BeanDiscoveryFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`BeanDiscoveryFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(BeanDiscoveryFinishedBuildItem beanDiscovery, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = beanDiscovery.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will not contain `@Named` synthetic beans.\n+\n+=== _Solution 2_: `SynthesisFinishedBuildItem`\n+\n+Consumers of `SynthesisFinishedBuildItem` can easily inspect all beans, observers and injection points registered in the application. Synthetic beans and observers are included because this build item is produced _after_ the synthetic components are registered.\n+\n+Additionaly, the bean resolver returned from `SynthesisFinishedBuildItem#getBeanResolver()` can be used to apply the type-safe resolution rules, e.g. to find out whether there is a bean that would satisfy certain combination of required type and qualifiers.\n+\n+.`SynthesisFinishedBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void doSomethingWithNamedBeans(SynthesisFinishedBuildItem synthesisFinished, BuildProducer<NamedBeansBuildItem> namedBeans) {\n+   List<BeanInfo> namedBeans = synthesisFinished.beanStream().withName().collect(toList())); <1>\n+   namedBeans.produce(new NamedBeansBuildItem(namedBeans));\n+}\n+----\n+<1> The resulting list will contain `@Named` synthetic beans.\n+\n+[[synthetic_beans]]\n+== Use Case - The Need for Synthetic Beans\n+\n+Sometimes it is practical to be able to register a _synthetic bean_.\n+Bean attributes of a synthetic bean are not derived from a Java class, method or field.\n+Instead, all the attributes are defined by an extension.\n+In regular CDI, this could be achieved using the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#after_bean_discovery[`AfterBeanDiscovery.addBean()`, window=\"_blank\"] methods.\n+\n+_Solution_: If you need to register a synthetic bean then use the `SyntheticBeanBuildItem`.\n+\n+.`SyntheticBeanBuildItem` Example 1\n+[source,java]\n+----\n+@BuildStep\n+SyntheticBeanBuildItem syntheticBean() {\n+   return SyntheticBeanBuildItem.configure(String.class)\n+             .qualifiers(new MyQualifierLiteral())\n+             .creator(mc -> mc.returnValue(mc.load(\"foo\"))) <1>\n+             .done();\n+}\n+----\n+<1> Generate the bytecode of the `javax.enterprise.context.spi.Contextual#create(CreationalContext<T>)` implementation.\n+\n+The output of a bean configurator is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic bean instance is created at runtime. \n+You can:\n+\n+1. Generate the bytecode of the `Contextual#create(CreationalContext<T>)` method directly via `ExtendedBeanConfigurator.creator(Consumer<MethodCreator>)`.\n+2. Pass a `io.quarkus.arc.BeanCreator` implementation class via `ExtendedBeanConfigurator#creator(Class<? extends BeanCreator<U>>)`, and possibly specify some parameters via `ExtendedBeanConfigurator#param()`.\n+3. Produce the runtime instance through a proxy returned from a <<writing-extensions.adoc#bytecode-recording,`@Recorder` method>> and set it via `ExtendedBeanConfigurator#runtimeValue(RuntimeValue<?>)` or `ExtendedBeanConfigurator#supplier(Supplier<?>)`.\n+\n+.`SyntheticBeanBuildItem` Example 2\n+[source,java]\n+----\n+@BuildStep\n+@Record(STATIC_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .runtimeValue(recorder.createFoo()) <2>\n+                .done();\n+}\n+----\n+<1> By default, a synthetic bean is initialized during `STATIC_INIT`.\n+<2> The bean instance is supplied by a value returned from a recorder method.\n+\n+It is possible to mark a synthetic bean to be initialized during `RUNTIME_INIT`.\n+See the <<writing-extensions.adoc#bootstrap-three-phases,Three Phases of Bootstrap and Quarkus Philosophy>> for more information about the difference between `STATIC_INIT` and `RUNTIME_INIT`.\n+\n+.`RUNTIME_INIT` `SyntheticBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) <1>\n+SyntheticBeanBuildItem syntheticBean(TestRecorder recorder) {\n+   return SyntheticBeanBuildItem.configure(Foo.class).scope(Singleton.class)\n+                .setRuntimeInit() <2>\n+                .runtimeValue(recorder.createFoo())\n+                .done();\n+}\n+----\n+<1> The recorder must be executed in the `ExecutionTime.RUNTIME_INIT` phase.\n+<2> The bean instance is initialized during `RUNTIME_INIT`.\n+\n+[IMPORTANT]\n+====\n+Synthetic beans initialized during `RUNTIME_INIT` must not be accessed during `STATIC_INIT`. `RUNTIME_INIT` build steps that access a runtime-init synthetic bean should consume the `SyntheticBeansRuntimeInitBuildItem`:\n+\n+[source,java]\n+----\n+@BuildStep\n+@Record(RUNTIME_INIT) \n+@Consume(SyntheticBeansRuntimeInitBuildItem.class) <1>\n+void accessFoo(TestRecorder recorder) {\n+   recorder.foo(); <2>\n+}\n+----\n+<1> This build step must be executed after `syntheticBean()` completes.\n+<2> This recorder method results in an invocation upon the `Foo` bean instance and thus we need to make sure that the build step is executed after all synthetic beans are initialized.\n+====\n+\n+NOTE: It is also possible to use the `BeanRegistrationPhaseBuildItem` to register a synthetic bean. However, we recommend extension authors to stick with `SyntheticBeanBuildItem` which is more idiomatic for Quarkus.\n+\n+[[synthetic_observers]]\n+== Use Case - Synthetic Observers\n+\n+Similar to <<synthetic_beans,synthetic beans>>, the attributes of a synthetic observer method are not derived from a Java method. Instead, all the attributes are defined by an extension.\n+\n+_Solution_: If you need to register a synthetic observer, use the `ObserverRegistrationPhaseBuildItem`.\n+\n+IMPORTANT: A build step that consumes the `ObserverRegistrationPhaseBuildItem` should always produce an `ObserverConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+.`ObserverRegistrationPhaseBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void syntheticObserver(ObserverRegistrationPhaseBuildItem observerRegistrationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ObserverConfiguratorBuildItem> observerConfigurators) {\n+   observerConfigurators.produce(new ObserverConfiguratorBuildItem(observerRegistrationPhase.getContext().configure().observedType(String.class)\n+                             .notify(mc -> {\n+                               // do some gizmo bytecode generation...\n+                             }).done();\n+   myBuildItem.produce(new MyBuildItem());\n+}\n+----\n+\n+The output of a `ObserverConfigurator` is recorded as bytecode. \n+Therefore, there are some limitations in how a synthetic observer is invoked at runtime. \n+Currently, you must generate the bytecode of the method body directly.\n+\n+[[generated_beans]]\n+== Use Case - I Have a Generated Bean Class\n+\n+No problem.\n+You can generate the bytecode of a bean class manually and then all you need to do is to produce a `GeneratedBeanBuildItem` instead of `GeneratedClassBuildItem`.\n+\n+.`GeneratedBeanBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void generatedBean(BuildProducer<GeneratedBeanBuildItem> generatedBeans) {\n+    ClassOutput beansClassOutput = new GeneratedBeanGizmoAdaptor(generatedBeans); <1>\n+    ClassCreator beanClassCreator = ClassCreator.builder().classOutput(beansClassOutput)\n+                .className(\"org.acme.MyBean\")\n+                .build();\n+    beanClassCreator.addAnnotation(Singleton.class);\n+    beanClassCreator.close(); <2>\n+}\n+----\n+<1> `io.quarkus.arc.deployment.GeneratedBeanGizmoAdaptor` makes it easy to produce ``GeneratedBeanBuildItem``s from Gizmo constructs.\n+<2> The resulting bean class is something like `public class @Singleton MyBean { }`.\n+\n+== Use Case - I Need to Validate the Deployment\n+\n+Sometimes extensions need to inspect the beans, observers and injection points, then perform additional validations and fail the build if something is wrong.\n+\n+_Solution_: If an extension needs to validate the deployment it should use the `ValidationPhaseBuildItem`.\n+\n+IMPORTANT: A build step that consumes the `ValidationPhaseBuildItem` should always produce a `ValidationErrorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+[source,java]\n+----\n+@BuildStep\n+void validate(ValidationPhaseBuildItem validationPhase,\n+            BuildProducer<MyBuildItem> myBuildItem, \n+            BuildProducer<ValidationErrorBuildItem> errors) {\n+   if (someCondition) {\n+     errors.produce(new ValidationErrorBuildItem(new IllegalStateException()));\n+     myBuildItem.produce(new MyBuildItem());\n+   }\n+}\n+----\n+\n+TIP: You can easily filter all registered beans via the convenient `BeanStream` returned from the `ValidationPhaseBuildItem.getContext().beans()` method.\n+\n+[[custom_context]]\n+== Use Case - Register a Custom CDI Context\n+\n+Sometimes extensions need to extend the set of built-in CDI contexts.\n+\n+_Solution_: If you need to register a custom context, use the `ContextRegistrationPhaseBuildItem`.\n+\n+IMPORTANT: A build step that consumes the `ContextRegistrationPhaseBuildItem` should always produce a `ContextConfiguratorBuildItem` or at least inject a `BuildProducer` for this build item, otherwise it could be ignored or processed at the wrong time (e.g. after the correct CDI bootstrap phase).\n+\n+`ContextRegistrationPhaseBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+ContextConfiguratorBuildItem registerContext(ContextRegistrationPhaseBuildItem phase) {\n+      return new ContextConfiguratorBuildItem(phase.getContext().configure(TransactionScoped.class).normal().contextClass(TransactionContext.class));\n+}\n+----\n+\n+Additionally, each extension that registers a custom CDI context via `ContextRegistrationPhaseBuildItem` should also produce the `CustomScopeBuildItem` in order to contribute the custom scope annotation name to the set of bean defining annotations.\n+\n+`CustomScopeBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+CustomScopeBuildItem customScope() {\n+   return new CustomScopeBuildItem(DotName.createSimple(TransactionScoped.class.getName()));\n+}\n+----\n+\n+=== What if I Need to Know All the Scopes Used in the Application?\n+\n+_Solution_: You can inject the `CustomScopeAnnotationsBuildItem` in a build step and use the convenient methods such as `CustomScopeAnnotationsBuildItem.isScopeDeclaredOn()`.\n+\n+[[additional_interceptor_bindings]]\n+== Use Case - Additional Interceptor Bindings\n+\n+In rare cases it might be handy to programmatically register an existing annotation that is not annotated with `@javax.interceptor.InterceptorBinding` as an interceptor binding.\n+This is similar to what CDI achieves through `BeforeBeanDiscovery#addInterceptorBinding()`.\n+Though here we are going to use `InterceptorBindingRegistrarBuildItem` to get it done.\n+\n+.`InterceptorBindingRegistrarBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+InterceptorBindingRegistrarBuildItem addInterceptorBindings() {\n+    return new InterceptorBindingRegistrarBuildItem(new InterceptorBindingRegistrar() {\n+        @Override\n+        public Map<DotName, Set<String>> registerAdditionalBindings() { <1>\n+            return Collections.singletonMap(DotName.createSimple(NotAnInterceptorBinding.class.getName()),\n+                                        Collections.emptySet());\n+        }\n+    });\n+}\n+----\n+\n+[[injection_point_transformation]]\n+== Use Case - Injection Point Transformation\n+\n+Every now and then it is handy to be able to change the qualifiers of an injection point programmatically.\n+You can do just that with `InjectionPointTransformerBuildItem`.\n+The following sample shows how to apply transformation to injection points with type `Foo` that contain qualifier `MyQualifier`:\n+\n+.`InjectionPointTransformerBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+InjectionPointTransformerBuildItem transformer() {\n+    return new InjectionPointTransformerBuildItem(new InjectionPointsTransformer() {\n+\n+        public boolean appliesTo(Type requiredType) {\n+            return requiredType.name().equals(DotName.createSimple(Foo.class.getName()));\n+        }\n+\n+        public void transform(TransformationContext context) {\n+            if (context.getQualifiers().stream()\n+                    .anyMatch(a -> a.name().equals(DotName.createSimple(MyQualifier.class.getName())))) {\n+                context.transform()\n+                        .removeAll()\n+                        .add(DotName.createSimple(MyOtherQualifier.class.getName()))\n+                        .done();\n+            }\n+        }\n+    });\n+}\n+----\n+\n+NOTE: In theory, you can use <<annotations_transformer_build_item,an `AnnotationsTransformer`>> to achieve the same goal. However, there are few differences that make `InjectionPointsTransformer` more suitable for this particular task: (1) annotation transformers are applied to all classes during bean discovery, whereas `InjectionPointsTransformer` is only applied to discovered injection points after bean discovery; (2) with `InjectionPointsTransformer` you don't need to handle various types of injection points (field, parameters of initializer methods, etc.).\n+\n+== Use Case - Resource Annotations and Injection\n+\n+The `ResourceAnnotationBuildItem` can be used to specify resource annotations that make it possible to resolve non-CDI injection points, such as Jakarta EE resources.\n+An integrator must also provide a corresponding `io.quarkus.arc.ResourceReferenceProvider` service provider implementation. \n+\n+.`ResourceAnnotationBuildItem` Example\n+[source,java]\n+----\n+@BuildStep\n+void setupResourceInjection(BuildProducer<ResourceAnnotationBuildItem> resourceAnnotations, BuildProducer<GeneratedResourceBuildItem> resources) {\n+    resources.produce(new GeneratedResourceBuildItem(\"META-INF/services/io.quarkus.arc.ResourceReferenceProvider\",\n+        MyResourceReferenceProvider.class.getName().getBytes()));\n+    resourceAnnotations.produce(new ResourceAnnotationBuildItem(DotName.createSimple(MyAnnotation.class.getName())));\n+}\n+----\n+\n+[[build_metadata]]\n+== Available Build Time Metadata\n+\n+Any of the above extensions that operates with `BuildExtension.BuildContext` can leverage certain build time metadata that are generated during build.\n+The built-in keys located in `io.quarkus.arc.processor.BuildExtension.Key` are:\n+\n+* `ANNOTATION_STORE`\n+** Contains an `AnnotationStore` that keeps information about all `AnnotationTarget` annotations after application of annotation transformers\n+* `INJECTION_POINTS`\n+** `Collection<InjectionPointInfo>` containing all injection points\n+* `BEANS`\n+** `Collection<BeanInfo>` containing all beans\n+* `REMOVED_BEANS`\n+** `Collection<BeanInfo>` containing all the removed beans; see <<remove_unused_beans>> for more information\n+* `OBSERVERS`\n+** `Collection<ObserverInfo>` containing all observers\n+* `SCOPES`\n+** `Collection<ScopeInfo>` containing all scopes, including custom ones\n+* `QUALIFIERS`\n+** `Map<DotName, ClassInfo>` containing all qualifiers\n+* `INTERCEPTOR_BINDINGS`\n+** `Map<DotName, ClassInfo>` containing all interceptor bindings\n+* `STEREOTYPES`\n+** `Map<DotName, StereotypeInfo>` containing all stereotypes", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIwMDg1Ng=="}, "originalCommit": {"oid": "6fad305a9e2bbcb1c9c59e6d77798e526725bbd4"}, "originalPosition": 528}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NTQyMzAyOnYy", "diffSide": "LEFT", "path": "extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/ArcProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDo1MTozMFrOICOZJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMToxNDoyM1rOICPUYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIwMzg3OA==", "bodyText": "So just to be extra sure, you handle that differently now?", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539203878", "createdAt": "2020-12-09T10:51:30Z", "author": {"login": "gsmet"}, "path": "extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/ArcProcessor.java", "diffHunk": "@@ -278,9 +281,6 @@ protected DotName getDotName(BeanInfo bean) {\n                 builder.addRemovalExclusion(new BeanClassAnnotationExclusion(annotation.getName()));\n             }\n         }\n-        for (UnremovableBeanBuildItem exclusion : removalExclusions) {\n-            builder.addRemovalExclusion(exclusion.getPredicate());\n-        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fad305a9e2bbcb1c9c59e6d77798e526725bbd4"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIxOTA0Mg==", "bodyText": "Yes, UnremovableBeanBuildItems are processed in the io.quarkus.arc.deployment.ArcProcessor.validate() phase and passed directly to the BeanProcessor. The advantage of this approach is that you can register an UnremovableBeanBuildItem based on e.g. an existing injection point.", "url": "https://github.com/quarkusio/quarkus/pull/13749#discussion_r539219042", "createdAt": "2020-12-09T11:14:23Z", "author": {"login": "mkouba"}, "path": "extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/ArcProcessor.java", "diffHunk": "@@ -278,9 +281,6 @@ protected DotName getDotName(BeanInfo bean) {\n                 builder.addRemovalExclusion(new BeanClassAnnotationExclusion(annotation.getName()));\n             }\n         }\n-        for (UnremovableBeanBuildItem exclusion : removalExclusions) {\n-            builder.addRemovalExclusion(exclusion.getPredicate());\n-        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIwMzg3OA=="}, "originalCommit": {"oid": "6fad305a9e2bbcb1c9c59e6d77798e526725bbd4"}, "originalPosition": 61}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3811, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}