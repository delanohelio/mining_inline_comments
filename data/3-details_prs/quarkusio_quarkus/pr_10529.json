{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1NDA2MTg4", "number": 10529, "title": "Docs - add \"Introduction to CDI\"", "bodyText": "CDI is quite complex. Our CDI reference guide mainly covers the differences of our implementation (non-standard features, limitations, etc.). In this guide, we'd like to cover some basic topics for CDI newcomers. It has a form of questions & answers and it's intended to be read as a conversation. I've tried to be intelligible but also precise. So this introduction is a compromise because it's not always possible (esp. when trying to explain topics like type-safe resolution and client proxies ;-).", "createdAt": "2020-07-07T13:16:02Z", "url": "https://github.com/quarkusio/quarkus/pull/10529", "merged": true, "mergeCommit": {"oid": "0ba90de41ae88a46bbf26da54ca87cad2ed022c8"}, "closed": true, "closedAt": "2020-07-10T11:21:28Z", "author": {"login": "mkouba"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcylsW5ABqjM1MjAzNzk5NDM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABczh1Q-AFqTQ0NjMyMzgwNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "405a633a0b2bc42bce2098cc46ba38a05a544cf3", "author": {"user": {"login": "mkouba", "name": "Martin Kouba"}}, "url": "https://github.com/quarkusio/quarkus/commit/405a633a0b2bc42bce2098cc46ba38a05a544cf3", "committedDate": "2020-07-07T13:05:32Z", "message": "Docs - add Introduction to CDI"}, "afterCommit": {"oid": "63d155041a5447adba997da8577b662969847b05", "author": {"user": {"login": "mkouba", "name": "Martin Kouba"}}, "url": "https://github.com/quarkusio/quarkus/commit/63d155041a5447adba997da8577b662969847b05", "committedDate": "2020-07-07T13:17:00Z", "message": "Docs - add Introduction to CDI"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzOTMzNjQ1", "url": "https://github.com/quarkusio/quarkus/pull/10529#pullrequestreview-443933645", "createdAt": "2020-07-07T14:14:52Z", "commit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDoxNDo1MlrOGuAl-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDoxNDo1MlrOGuAl-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg5NzQwMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            == _Q: Wait a minute. What does it mean container-managed?_\n          \n          \n            \n            == _Q: Wait a minute. What does \"container-managed\" mean?_", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450897400", "createdAt": "2020-07-07T14:14:52Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzOTMzOTc5", "url": "https://github.com/quarkusio/quarkus/pull/10529#pullrequestreview-443933979", "createdAt": "2020-07-07T14:15:11Z", "commit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDoxNToxMVrOGuAnBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDoxNToxMVrOGuAnBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg5NzY2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n          \n          \n            \n            Instead, you can affect the lifecycle through declarative means, such as annotations, configuration, etc.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450897668", "createdAt": "2020-07-07T14:15:11Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzOTM5ODcy", "url": "https://github.com/quarkusio/quarkus/pull/10529#pullrequestreview-443939872", "createdAt": "2020-07-07T14:21:11Z", "commit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDoyMToxMVrOGuA4-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDoyMToxMVrOGuA4-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkwMjI2NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n          \n          \n            \n            A: An application developer can focus on the business logic rather than \"where and how\" of obtaining a fully initialized component with all of its dependencies.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450902265", "createdAt": "2020-07-07T14:21:11Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzOTQxMDMw", "url": "https://github.com/quarkusio/quarkus/pull/10529#pullrequestreview-443941030", "createdAt": "2020-07-07T14:22:18Z", "commit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDoyMjoxOVrOGuA8aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDoyMjoxOVrOGuA8aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkwMzE0NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            == _Q: OK. And what does a bean look like?_\n          \n          \n            \n            == _Q: But does a bean look like?_", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450903145", "createdAt": "2020-07-07T14:22:19Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzOTQyMDk3", "url": "https://github.com/quarkusio/quarkus/pull/10529#pullrequestreview-443942097", "createdAt": "2020-07-07T14:23:21Z", "commit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDoyMzoyMVrOGuA_sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDoyMzoyMVrOGuA_sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkwMzk4NA==", "bodyText": "I am sure that users will not know what dependants means here. Wouldn't it better to say and used throughout the application?", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450903984", "createdAt": "2020-07-07T14:23:21Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzOTU3MzUz", "url": "https://github.com/quarkusio/quarkus/pull/10529#pullrequestreview-443957353", "createdAt": "2020-07-07T14:38:42Z", "commit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDozODo0MlrOGuBtmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDozODo0MlrOGuBtmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxNTczOA==", "bodyText": "Should it also be mentioned that no @Inject is needed here since there is only one constructor?", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450915738", "createdAt": "2020-07-07T14:38:42Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 129}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzOTU5NTY4", "url": "https://github.com/quarkusio/quarkus/pull/10529#pullrequestreview-443959568", "createdAt": "2020-07-07T14:40:58Z", "commit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDo0MDo1OFrOGuB0Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDo0MDo1OFrOGuB0Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxNzQ0Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. \n          \n          \n            \n            * Circular dependencies in the dependency graph. Having circular dependencies is often an indication that a redesign should be considered, but sometimes they're inevitable.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450917443", "createdAt": "2020-07-07T14:40:58Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).\n+Client proxies allow for:\n+\n+* Lazy instantiation - the instance is created once a method is invoked upon the proxy.\n+* Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.\n+* Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 191}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzOTYwOTg1", "url": "https://github.com/quarkusio/quarkus/pull/10529#pullrequestreview-443960985", "createdAt": "2020-07-07T14:42:30Z", "commit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDo0MjozMFrOGuB4nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDo0MjozMFrOGuB4nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxODU1Ng==", "bodyText": "Can we add a note that I personally hate producer fields? \ud83d\ude06", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450918556", "createdAt": "2020-07-07T14:42:30Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).\n+Client proxies allow for:\n+\n+* Lazy instantiation - the instance is created once a method is invoked upon the proxy.\n+* Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.\n+* Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. \n+* In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.\n+ \n+ \n+== _Q: OK. You said that there are several kinds of beans?_\n+\n+A: Yes. In general, in Quarkus we distinguish:\n+\n+1. Class beans\n+2. Producer methods\n+3. Producer fields\n+4. Synthetic beans\n+\n+Producer methods are useful if you need additional control over instantiation of a bean.\n+They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.\n+\n+.Producer Method Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PiProducer {\n+\n+    @Produces <1>\n+    double producePi() { \n+       return Math.PI; <2>\n+    }\n+}\n+\n+@ApplicationScoped\n+public class PiConsumer {\n+\n+   @Inject\n+   double pi; <3>\n+   \n+   double twoPis() {\n+     return pi * 2;\n+   }\n+} \n+----\n+<1> The container analyses the method annotations to build a bean metadata.\n+The return type is used to build the set of bean types. \n+In this case, it will be `double` and `java.lang.Object`.\n+No scope annotation is declared and so it's defaulted to `@Dependent`.\n+<2> The container will delegate to this method when creating the bean instance.\n+<3> `PiProducer#producePi()` is invoked and the result is set to `PiConsumer#pi` when the `PiConsumer` instance is created.\n+\n+NOTE: One of the limitations of producers is that interceptors are not applied to the result of a producer method/field.\n+\n+Producer fields are very similar to producer methods except that the field value is read when obtaining a bean instance.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 239}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzOTYxOTYy", "url": "https://github.com/quarkusio/quarkus/pull/10529#pullrequestreview-443961962", "createdAt": "2020-07-07T14:43:24Z", "commit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDo0MzoyNFrOGuB7jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNDo0MzoyNFrOGuB7jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxOTMwOQ==", "bodyText": "I think it makes sense to mention if the ordering is from highest to lowest or the inverse", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450919309", "createdAt": "2020-07-07T14:43:24Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).\n+Client proxies allow for:\n+\n+* Lazy instantiation - the instance is created once a method is invoked upon the proxy.\n+* Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.\n+* Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. \n+* In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.\n+ \n+ \n+== _Q: OK. You said that there are several kinds of beans?_\n+\n+A: Yes. In general, in Quarkus we distinguish:\n+\n+1. Class beans\n+2. Producer methods\n+3. Producer fields\n+4. Synthetic beans\n+\n+Producer methods are useful if you need additional control over instantiation of a bean.\n+They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.\n+\n+.Producer Method Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PiProducer {\n+\n+    @Produces <1>\n+    double producePi() { \n+       return Math.PI; <2>\n+    }\n+}\n+\n+@ApplicationScoped\n+public class PiConsumer {\n+\n+   @Inject\n+   double pi; <3>\n+   \n+   double twoPis() {\n+     return pi * 2;\n+   }\n+} \n+----\n+<1> The container analyses the method annotations to build a bean metadata.\n+The return type is used to build the set of bean types. \n+In this case, it will be `double` and `java.lang.Object`.\n+No scope annotation is declared and so it's defaulted to `@Dependent`.\n+<2> The container will delegate to this method when creating the bean instance.\n+<3> `PiProducer#producePi()` is invoked and the result is set to `PiConsumer#pi` when the `PiConsumer` instance is created.\n+\n+NOTE: One of the limitations of producers is that interceptors are not applied to the result of a producer method/field.\n+\n+Producer fields are very similar to producer methods except that the field value is read when obtaining a bean instance.\n+\n+TIP: There's more about producers. You can declare qualifiers, inject dependencies into the producer methods parameters, etc. You can read more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/beanscdi.html#_producer_methods[Weld docs, window=\"_blank\"].\n+\n+Synthetic beans are usually provided by extensions.\n+A synthetic bean is not backed by a class/method/field.\n+Application developers usually only consume this kind of beans.\n+\n+== _Q: OK injection looks cool. What other services are provided?_\n+\n+=== Lifecycle Callbacks\n+\n+A bean class may declare lifecycle `@PostConstruct` and `@PreDestroy` callbacks:\n+\n+.Lifecycle Callbacks Example\n+[source,java]\n+----\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+\n+@ApplicationScoped\n+public class Translator {\n+\n+    @PostConstruct <1>\n+    void init() {\n+       // ...\n+    }\n+    \n+    @PreDestroy <2>\n+    void destroy() {\n+      // ...\n+    }\n+}\n+----\n+<1> This callback is invoked before the bean instance is put into service. It is safe to perform some initialization here.\n+<2> This callback is invoked before the bean instance is destroyed. It is safe to perform some cleanup tasks here.\n+\n+TIP: It's a good practice to keep the logic in the callbacks \"without side effects\", i.e. you should avoid calling other beans inside the callbacks.\n+\n+=== Interceptors\n+\n+Interceptors are used to separate cross-cutting concerns from business logic. \n+There is a separate specification - Java Interceptors - that defines the basic programming model and semantics.\n+\n+.Simple Interceptor Example\n+[source,java]\n+----\n+import javax.interceptor.Interceptor;\n+import javax.annotation.Priority;\n+\n+@Logged <1>\n+@Priority(2020) <2>\n+@Interceptor <3>\n+public class LoggingInterceptor {\n+\n+   @Inject <4>\n+   Logger logger;\n+\n+   @AroundInvoke <5>\n+   Objec logInvocation(InvocationContext context) {\n+      // ...log before\n+      Objec ret = context.proceed(); <6>\n+      // ...log after\n+      return ret;\n+   }\n+    \n+}\n+----\n+<1> This is an interceptor binding annotation that is used to bind our interceptor to a bean. Simply annotate a bean class with `@Logged`.\n+<2> `Priority` enables the interceptor and affects the the interceptor ordering. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 308}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzOTYyNDIz", "url": "https://github.com/quarkusio/quarkus/pull/10529#pullrequestreview-443962423", "createdAt": "2020-07-07T14:43:53Z", "commit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzOTgyMzYw", "url": "https://github.com/quarkusio/quarkus/pull/10529#pullrequestreview-443982360", "createdAt": "2020-07-07T15:03:52Z", "commit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNTowMzo1MlrOGuC5Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjoxMjozNlrOGuFy2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkzNTEwMw==", "bodyText": "Or and used by all beans inside which it will be injected  (or a better sentence with the same meaning)", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450935103", "createdAt": "2020-07-07T15:03:52Z", "author": {"login": "loicmathieu"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkwMzk4NA=="}, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk0MzI5NA==", "bodyText": "This notion of \"depends\" disturb me.\nI didn't understand it clearly, for me it tells the container to set the field inside the bean, nothing more ...", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450943294", "createdAt": "2020-07-07T15:14:56Z", "author": {"login": "loicmathieu"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk0Mzc3OQ==", "bodyText": "Maybe introduce interceptor binding later on as it's a more complex principle and it's better to introduce one principle at a time", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450943779", "createdAt": "2020-07-07T15:15:37Z", "author": {"login": "loicmathieu"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk0NjQ5NQ==", "bodyText": "Maybe explain when it will be created like for the other scopes.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450946495", "createdAt": "2020-07-07T15:19:35Z", "author": {"login": "loicmathieu"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3NDkwOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n          \n          \n            \n            NOTE: There can be other custom scopes provided by Quarkus extension. For example, `quarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450974909", "createdAt": "2020-07-07T16:00:53Z", "author": {"login": "loicmathieu"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3NTk4Ng==", "bodyText": "contextual instance: maybe find a more straightforward term: instead of an object of the bean class.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450975986", "createdAt": "2020-07-07T16:02:29Z", "author": {"login": "loicmathieu"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3NzgyNg==", "bodyText": "As it didn't target developers, maybe don't introduce them ? It's and introduction guide we don't need to cover everything", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450977826", "createdAt": "2020-07-07T16:05:22Z", "author": {"login": "loicmathieu"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).\n+Client proxies allow for:\n+\n+* Lazy instantiation - the instance is created once a method is invoked upon the proxy.\n+* Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.\n+* Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. \n+* In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.\n+ \n+ \n+== _Q: OK. You said that there are several kinds of beans?_\n+\n+A: Yes. In general, in Quarkus we distinguish:\n+\n+1. Class beans\n+2. Producer methods\n+3. Producer fields\n+4. Synthetic beans\n+\n+Producer methods are useful if you need additional control over instantiation of a bean.\n+They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.\n+\n+.Producer Method Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PiProducer {\n+\n+    @Produces <1>\n+    double producePi() { \n+       return Math.PI; <2>\n+    }\n+}\n+\n+@ApplicationScoped\n+public class PiConsumer {\n+\n+   @Inject\n+   double pi; <3>\n+   \n+   double twoPis() {\n+     return pi * 2;\n+   }\n+} \n+----\n+<1> The container analyses the method annotations to build a bean metadata.\n+The return type is used to build the set of bean types. \n+In this case, it will be `double` and `java.lang.Object`.\n+No scope annotation is declared and so it's defaulted to `@Dependent`.\n+<2> The container will delegate to this method when creating the bean instance.\n+<3> `PiProducer#producePi()` is invoked and the result is set to `PiConsumer#pi` when the `PiConsumer` instance is created.\n+\n+NOTE: One of the limitations of producers is that interceptors are not applied to the result of a producer method/field.\n+\n+Producer fields are very similar to producer methods except that the field value is read when obtaining a bean instance.\n+\n+TIP: There's more about producers. You can declare qualifiers, inject dependencies into the producer methods parameters, etc. You can read more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/beanscdi.html#_producer_methods[Weld docs, window=\"_blank\"].\n+\n+Synthetic beans are usually provided by extensions.\n+A synthetic bean is not backed by a class/method/field.\n+Application developers usually only consume this kind of beans.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3ODQ1Nw==", "bodyText": "Maybe add a note that Quarkus support custom callback global to the application via https://quarkus.io/guides/lifecycle ?", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450978457", "createdAt": "2020-07-07T16:06:22Z", "author": {"login": "loicmathieu"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).\n+Client proxies allow for:\n+\n+* Lazy instantiation - the instance is created once a method is invoked upon the proxy.\n+* Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.\n+* Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. \n+* In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.\n+ \n+ \n+== _Q: OK. You said that there are several kinds of beans?_\n+\n+A: Yes. In general, in Quarkus we distinguish:\n+\n+1. Class beans\n+2. Producer methods\n+3. Producer fields\n+4. Synthetic beans\n+\n+Producer methods are useful if you need additional control over instantiation of a bean.\n+They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.\n+\n+.Producer Method Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PiProducer {\n+\n+    @Produces <1>\n+    double producePi() { \n+       return Math.PI; <2>\n+    }\n+}\n+\n+@ApplicationScoped\n+public class PiConsumer {\n+\n+   @Inject\n+   double pi; <3>\n+   \n+   double twoPis() {\n+     return pi * 2;\n+   }\n+} \n+----\n+<1> The container analyses the method annotations to build a bean metadata.\n+The return type is used to build the set of bean types. \n+In this case, it will be `double` and `java.lang.Object`.\n+No scope annotation is declared and so it's defaulted to `@Dependent`.\n+<2> The container will delegate to this method when creating the bean instance.\n+<3> `PiProducer#producePi()` is invoked and the result is set to `PiConsumer#pi` when the `PiConsumer` instance is created.\n+\n+NOTE: One of the limitations of producers is that interceptors are not applied to the result of a producer method/field.\n+\n+Producer fields are very similar to producer methods except that the field value is read when obtaining a bean instance.\n+\n+TIP: There's more about producers. You can declare qualifiers, inject dependencies into the producer methods parameters, etc. You can read more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/beanscdi.html#_producer_methods[Weld docs, window=\"_blank\"].\n+\n+Synthetic beans are usually provided by extensions.\n+A synthetic bean is not backed by a class/method/field.\n+Application developers usually only consume this kind of beans.\n+\n+== _Q: OK injection looks cool. What other services are provided?_\n+\n+=== Lifecycle Callbacks\n+\n+A bean class may declare lifecycle `@PostConstruct` and `@PreDestroy` callbacks:\n+\n+.Lifecycle Callbacks Example\n+[source,java]\n+----\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+\n+@ApplicationScoped\n+public class Translator {\n+\n+    @PostConstruct <1>\n+    void init() {\n+       // ...\n+    }\n+    \n+    @PreDestroy <2>\n+    void destroy() {\n+      // ...\n+    }\n+}\n+----\n+<1> This callback is invoked before the bean instance is put into service. It is safe to perform some initialization here.\n+<2> This callback is invoked before the bean instance is destroyed. It is safe to perform some cleanup tasks here.\n+\n+TIP: It's a good practice to keep the logic in the callbacks \"without side effects\", i.e. you should avoid calling other beans inside the callbacks.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 277}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3ODk2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <2> `Priority` enables the interceptor and affects the the interceptor ordering. \n          \n          \n            \n            <2> `Priority` enables the interceptor and affects the interceptor ordering.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450978963", "createdAt": "2020-07-07T16:07:12Z", "author": {"login": "loicmathieu"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).\n+Client proxies allow for:\n+\n+* Lazy instantiation - the instance is created once a method is invoked upon the proxy.\n+* Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.\n+* Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. \n+* In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.\n+ \n+ \n+== _Q: OK. You said that there are several kinds of beans?_\n+\n+A: Yes. In general, in Quarkus we distinguish:\n+\n+1. Class beans\n+2. Producer methods\n+3. Producer fields\n+4. Synthetic beans\n+\n+Producer methods are useful if you need additional control over instantiation of a bean.\n+They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.\n+\n+.Producer Method Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PiProducer {\n+\n+    @Produces <1>\n+    double producePi() { \n+       return Math.PI; <2>\n+    }\n+}\n+\n+@ApplicationScoped\n+public class PiConsumer {\n+\n+   @Inject\n+   double pi; <3>\n+   \n+   double twoPis() {\n+     return pi * 2;\n+   }\n+} \n+----\n+<1> The container analyses the method annotations to build a bean metadata.\n+The return type is used to build the set of bean types. \n+In this case, it will be `double` and `java.lang.Object`.\n+No scope annotation is declared and so it's defaulted to `@Dependent`.\n+<2> The container will delegate to this method when creating the bean instance.\n+<3> `PiProducer#producePi()` is invoked and the result is set to `PiConsumer#pi` when the `PiConsumer` instance is created.\n+\n+NOTE: One of the limitations of producers is that interceptors are not applied to the result of a producer method/field.\n+\n+Producer fields are very similar to producer methods except that the field value is read when obtaining a bean instance.\n+\n+TIP: There's more about producers. You can declare qualifiers, inject dependencies into the producer methods parameters, etc. You can read more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/beanscdi.html#_producer_methods[Weld docs, window=\"_blank\"].\n+\n+Synthetic beans are usually provided by extensions.\n+A synthetic bean is not backed by a class/method/field.\n+Application developers usually only consume this kind of beans.\n+\n+== _Q: OK injection looks cool. What other services are provided?_\n+\n+=== Lifecycle Callbacks\n+\n+A bean class may declare lifecycle `@PostConstruct` and `@PreDestroy` callbacks:\n+\n+.Lifecycle Callbacks Example\n+[source,java]\n+----\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+\n+@ApplicationScoped\n+public class Translator {\n+\n+    @PostConstruct <1>\n+    void init() {\n+       // ...\n+    }\n+    \n+    @PreDestroy <2>\n+    void destroy() {\n+      // ...\n+    }\n+}\n+----\n+<1> This callback is invoked before the bean instance is put into service. It is safe to perform some initialization here.\n+<2> This callback is invoked before the bean instance is destroyed. It is safe to perform some cleanup tasks here.\n+\n+TIP: It's a good practice to keep the logic in the callbacks \"without side effects\", i.e. you should avoid calling other beans inside the callbacks.\n+\n+=== Interceptors\n+\n+Interceptors are used to separate cross-cutting concerns from business logic. \n+There is a separate specification - Java Interceptors - that defines the basic programming model and semantics.\n+\n+.Simple Interceptor Example\n+[source,java]\n+----\n+import javax.interceptor.Interceptor;\n+import javax.annotation.Priority;\n+\n+@Logged <1>\n+@Priority(2020) <2>\n+@Interceptor <3>\n+public class LoggingInterceptor {\n+\n+   @Inject <4>\n+   Logger logger;\n+\n+   @AroundInvoke <5>\n+   Objec logInvocation(InvocationContext context) {\n+      // ...log before\n+      Objec ret = context.proceed(); <6>\n+      // ...log after\n+      return ret;\n+   }\n+    \n+}\n+----\n+<1> This is an interceptor binding annotation that is used to bind our interceptor to a bean. Simply annotate a bean class with `@Logged`.\n+<2> `Priority` enables the interceptor and affects the the interceptor ordering. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 308}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3OTgwNg==", "bodyText": "Maybe list the other interceptor pointcut ? (BeforeInvoke, AfterInvoke)", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450979806", "createdAt": "2020-07-07T16:08:27Z", "author": {"login": "loicmathieu"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).\n+Client proxies allow for:\n+\n+* Lazy instantiation - the instance is created once a method is invoked upon the proxy.\n+* Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.\n+* Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. \n+* In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.\n+ \n+ \n+== _Q: OK. You said that there are several kinds of beans?_\n+\n+A: Yes. In general, in Quarkus we distinguish:\n+\n+1. Class beans\n+2. Producer methods\n+3. Producer fields\n+4. Synthetic beans\n+\n+Producer methods are useful if you need additional control over instantiation of a bean.\n+They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.\n+\n+.Producer Method Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PiProducer {\n+\n+    @Produces <1>\n+    double producePi() { \n+       return Math.PI; <2>\n+    }\n+}\n+\n+@ApplicationScoped\n+public class PiConsumer {\n+\n+   @Inject\n+   double pi; <3>\n+   \n+   double twoPis() {\n+     return pi * 2;\n+   }\n+} \n+----\n+<1> The container analyses the method annotations to build a bean metadata.\n+The return type is used to build the set of bean types. \n+In this case, it will be `double` and `java.lang.Object`.\n+No scope annotation is declared and so it's defaulted to `@Dependent`.\n+<2> The container will delegate to this method when creating the bean instance.\n+<3> `PiProducer#producePi()` is invoked and the result is set to `PiConsumer#pi` when the `PiConsumer` instance is created.\n+\n+NOTE: One of the limitations of producers is that interceptors are not applied to the result of a producer method/field.\n+\n+Producer fields are very similar to producer methods except that the field value is read when obtaining a bean instance.\n+\n+TIP: There's more about producers. You can declare qualifiers, inject dependencies into the producer methods parameters, etc. You can read more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/beanscdi.html#_producer_methods[Weld docs, window=\"_blank\"].\n+\n+Synthetic beans are usually provided by extensions.\n+A synthetic bean is not backed by a class/method/field.\n+Application developers usually only consume this kind of beans.\n+\n+== _Q: OK injection looks cool. What other services are provided?_\n+\n+=== Lifecycle Callbacks\n+\n+A bean class may declare lifecycle `@PostConstruct` and `@PreDestroy` callbacks:\n+\n+.Lifecycle Callbacks Example\n+[source,java]\n+----\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+\n+@ApplicationScoped\n+public class Translator {\n+\n+    @PostConstruct <1>\n+    void init() {\n+       // ...\n+    }\n+    \n+    @PreDestroy <2>\n+    void destroy() {\n+      // ...\n+    }\n+}\n+----\n+<1> This callback is invoked before the bean instance is put into service. It is safe to perform some initialization here.\n+<2> This callback is invoked before the bean instance is destroyed. It is safe to perform some cleanup tasks here.\n+\n+TIP: It's a good practice to keep the logic in the callbacks \"without side effects\", i.e. you should avoid calling other beans inside the callbacks.\n+\n+=== Interceptors\n+\n+Interceptors are used to separate cross-cutting concerns from business logic. \n+There is a separate specification - Java Interceptors - that defines the basic programming model and semantics.\n+\n+.Simple Interceptor Example\n+[source,java]\n+----\n+import javax.interceptor.Interceptor;\n+import javax.annotation.Priority;\n+\n+@Logged <1>\n+@Priority(2020) <2>\n+@Interceptor <3>\n+public class LoggingInterceptor {\n+\n+   @Inject <4>\n+   Logger logger;\n+\n+   @AroundInvoke <5>\n+   Objec logInvocation(InvocationContext context) {\n+      // ...log before\n+      Objec ret = context.proceed(); <6>\n+      // ...log after\n+      return ret;\n+   }\n+    \n+}\n+----\n+<1> This is an interceptor binding annotation that is used to bind our interceptor to a bean. Simply annotate a bean class with `@Logged`.\n+<2> `Priority` enables the interceptor and affects the the interceptor ordering. \n+<3> Marks an interceptor component.\n+<4> An interceptor instance may be the target of dependency injection.\n+<5> `AroundInvoke` denotes a method that interposes on business methods.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 311}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4MDA2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            NOTE: Instances of interceptors are dependent objects of the bean instance they intercept, i.e. a new interceptor instance is created for each intercepred bean.\n          \n          \n            \n            NOTE: Instances of interceptors are dependent objects of the bean instance they intercept, i.e. a new interceptor instance is created for each intercepted bean.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450980068", "createdAt": "2020-07-07T16:08:51Z", "author": {"login": "loicmathieu"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).\n+Client proxies allow for:\n+\n+* Lazy instantiation - the instance is created once a method is invoked upon the proxy.\n+* Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.\n+* Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. \n+* In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.\n+ \n+ \n+== _Q: OK. You said that there are several kinds of beans?_\n+\n+A: Yes. In general, in Quarkus we distinguish:\n+\n+1. Class beans\n+2. Producer methods\n+3. Producer fields\n+4. Synthetic beans\n+\n+Producer methods are useful if you need additional control over instantiation of a bean.\n+They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.\n+\n+.Producer Method Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PiProducer {\n+\n+    @Produces <1>\n+    double producePi() { \n+       return Math.PI; <2>\n+    }\n+}\n+\n+@ApplicationScoped\n+public class PiConsumer {\n+\n+   @Inject\n+   double pi; <3>\n+   \n+   double twoPis() {\n+     return pi * 2;\n+   }\n+} \n+----\n+<1> The container analyses the method annotations to build a bean metadata.\n+The return type is used to build the set of bean types. \n+In this case, it will be `double` and `java.lang.Object`.\n+No scope annotation is declared and so it's defaulted to `@Dependent`.\n+<2> The container will delegate to this method when creating the bean instance.\n+<3> `PiProducer#producePi()` is invoked and the result is set to `PiConsumer#pi` when the `PiConsumer` instance is created.\n+\n+NOTE: One of the limitations of producers is that interceptors are not applied to the result of a producer method/field.\n+\n+Producer fields are very similar to producer methods except that the field value is read when obtaining a bean instance.\n+\n+TIP: There's more about producers. You can declare qualifiers, inject dependencies into the producer methods parameters, etc. You can read more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/beanscdi.html#_producer_methods[Weld docs, window=\"_blank\"].\n+\n+Synthetic beans are usually provided by extensions.\n+A synthetic bean is not backed by a class/method/field.\n+Application developers usually only consume this kind of beans.\n+\n+== _Q: OK injection looks cool. What other services are provided?_\n+\n+=== Lifecycle Callbacks\n+\n+A bean class may declare lifecycle `@PostConstruct` and `@PreDestroy` callbacks:\n+\n+.Lifecycle Callbacks Example\n+[source,java]\n+----\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+\n+@ApplicationScoped\n+public class Translator {\n+\n+    @PostConstruct <1>\n+    void init() {\n+       // ...\n+    }\n+    \n+    @PreDestroy <2>\n+    void destroy() {\n+      // ...\n+    }\n+}\n+----\n+<1> This callback is invoked before the bean instance is put into service. It is safe to perform some initialization here.\n+<2> This callback is invoked before the bean instance is destroyed. It is safe to perform some cleanup tasks here.\n+\n+TIP: It's a good practice to keep the logic in the callbacks \"without side effects\", i.e. you should avoid calling other beans inside the callbacks.\n+\n+=== Interceptors\n+\n+Interceptors are used to separate cross-cutting concerns from business logic. \n+There is a separate specification - Java Interceptors - that defines the basic programming model and semantics.\n+\n+.Simple Interceptor Example\n+[source,java]\n+----\n+import javax.interceptor.Interceptor;\n+import javax.annotation.Priority;\n+\n+@Logged <1>\n+@Priority(2020) <2>\n+@Interceptor <3>\n+public class LoggingInterceptor {\n+\n+   @Inject <4>\n+   Logger logger;\n+\n+   @AroundInvoke <5>\n+   Objec logInvocation(InvocationContext context) {\n+      // ...log before\n+      Objec ret = context.proceed(); <6>\n+      // ...log after\n+      return ret;\n+   }\n+    \n+}\n+----\n+<1> This is an interceptor binding annotation that is used to bind our interceptor to a bean. Simply annotate a bean class with `@Logged`.\n+<2> `Priority` enables the interceptor and affects the the interceptor ordering. \n+<3> Marks an interceptor component.\n+<4> An interceptor instance may be the target of dependency injection.\n+<5> `AroundInvoke` denotes a method that interposes on business methods.\n+<6> Proceed to the next interceptor in the interceptor chain or invoke the intercepted business method.\n+\n+NOTE: Instances of interceptors are dependent objects of the bean instance they intercept, i.e. a new interceptor instance is created for each intercepred bean.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 314}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4MjYxNg==", "bodyText": "Is event part of the CDI Spec ?\nWe already have the Vert.x eventbus for that purpose maybe we can skip this part or just link to the spec here.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450982616", "createdAt": "2020-07-07T16:12:36Z", "author": {"login": "loicmathieu"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).\n+Client proxies allow for:\n+\n+* Lazy instantiation - the instance is created once a method is invoked upon the proxy.\n+* Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.\n+* Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. \n+* In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.\n+ \n+ \n+== _Q: OK. You said that there are several kinds of beans?_\n+\n+A: Yes. In general, in Quarkus we distinguish:\n+\n+1. Class beans\n+2. Producer methods\n+3. Producer fields\n+4. Synthetic beans\n+\n+Producer methods are useful if you need additional control over instantiation of a bean.\n+They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.\n+\n+.Producer Method Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PiProducer {\n+\n+    @Produces <1>\n+    double producePi() { \n+       return Math.PI; <2>\n+    }\n+}\n+\n+@ApplicationScoped\n+public class PiConsumer {\n+\n+   @Inject\n+   double pi; <3>\n+   \n+   double twoPis() {\n+     return pi * 2;\n+   }\n+} \n+----\n+<1> The container analyses the method annotations to build a bean metadata.\n+The return type is used to build the set of bean types. \n+In this case, it will be `double` and `java.lang.Object`.\n+No scope annotation is declared and so it's defaulted to `@Dependent`.\n+<2> The container will delegate to this method when creating the bean instance.\n+<3> `PiProducer#producePi()` is invoked and the result is set to `PiConsumer#pi` when the `PiConsumer` instance is created.\n+\n+NOTE: One of the limitations of producers is that interceptors are not applied to the result of a producer method/field.\n+\n+Producer fields are very similar to producer methods except that the field value is read when obtaining a bean instance.\n+\n+TIP: There's more about producers. You can declare qualifiers, inject dependencies into the producer methods parameters, etc. You can read more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/beanscdi.html#_producer_methods[Weld docs, window=\"_blank\"].\n+\n+Synthetic beans are usually provided by extensions.\n+A synthetic bean is not backed by a class/method/field.\n+Application developers usually only consume this kind of beans.\n+\n+== _Q: OK injection looks cool. What other services are provided?_\n+\n+=== Lifecycle Callbacks\n+\n+A bean class may declare lifecycle `@PostConstruct` and `@PreDestroy` callbacks:\n+\n+.Lifecycle Callbacks Example\n+[source,java]\n+----\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+\n+@ApplicationScoped\n+public class Translator {\n+\n+    @PostConstruct <1>\n+    void init() {\n+       // ...\n+    }\n+    \n+    @PreDestroy <2>\n+    void destroy() {\n+      // ...\n+    }\n+}\n+----\n+<1> This callback is invoked before the bean instance is put into service. It is safe to perform some initialization here.\n+<2> This callback is invoked before the bean instance is destroyed. It is safe to perform some cleanup tasks here.\n+\n+TIP: It's a good practice to keep the logic in the callbacks \"without side effects\", i.e. you should avoid calling other beans inside the callbacks.\n+\n+=== Interceptors\n+\n+Interceptors are used to separate cross-cutting concerns from business logic. \n+There is a separate specification - Java Interceptors - that defines the basic programming model and semantics.\n+\n+.Simple Interceptor Example\n+[source,java]\n+----\n+import javax.interceptor.Interceptor;\n+import javax.annotation.Priority;\n+\n+@Logged <1>\n+@Priority(2020) <2>\n+@Interceptor <3>\n+public class LoggingInterceptor {\n+\n+   @Inject <4>\n+   Logger logger;\n+\n+   @AroundInvoke <5>\n+   Objec logInvocation(InvocationContext context) {\n+      // ...log before\n+      Objec ret = context.proceed(); <6>\n+      // ...log after\n+      return ret;\n+   }\n+    \n+}\n+----\n+<1> This is an interceptor binding annotation that is used to bind our interceptor to a bean. Simply annotate a bean class with `@Logged`.\n+<2> `Priority` enables the interceptor and affects the the interceptor ordering. \n+<3> Marks an interceptor component.\n+<4> An interceptor instance may be the target of dependency injection.\n+<5> `AroundInvoke` denotes a method that interposes on business methods.\n+<6> Proceed to the next interceptor in the interceptor chain or invoke the intercepted business method.\n+\n+NOTE: Instances of interceptors are dependent objects of the bean instance they intercept, i.e. a new interceptor instance is created for each intercepred bean.\n+\n+=== Events and Observers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 316}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MDY1Njc5", "url": "https://github.com/quarkusio/quarkus/pull/10529#pullrequestreview-444065679", "createdAt": "2020-07-07T16:37:43Z", "commit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjozNzo0M1rOGuGvtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxNjo1MTozMFrOGuHQYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk5ODE5Ng==", "bodyText": "I think this part is too detailed for the introduction of this guide. I would put it at the end. Keep in mind that you target people not knowing CDI so they do not really care about this.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450998196", "createdAt": "2020-07-07T16:37:43Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk5ODkyOQ==", "bodyText": "There's a word missing in the suggestion.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450998929", "createdAt": "2020-07-07T16:38:56Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkwMzE0NQ=="}, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk5OTUxMA==", "bodyText": "Yeah I would focus on the fact that the service will be made available to the bean via injection.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450999510", "createdAt": "2020-07-07T16:39:54Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk0MzI5NA=="}, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk5OTY3OA==", "bodyText": "Yeah, I would introduce it later too.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r450999678", "createdAt": "2020-07-07T16:40:11Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk0Mzc3OQ=="}, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwMTIyNw==", "bodyText": "I dunno if we should mention the fact that it's not supported by other implementations here. Do we really care?", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451001227", "createdAt": "2020-07-07T16:42:39Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxNTczOA=="}, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwMTc0Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n          \n          \n            \n            This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not to `@Inject Translator`.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451001743", "createdAt": "2020-07-07T16:43:26Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwMjExNw==", "bodyText": "Should we explain how you create a qualifier?", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451002117", "createdAt": "2020-07-07T16:44:01Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwMjY2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            |`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n          \n          \n            \n            |`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instance is a dependent object of the bean it is injected into.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451002663", "createdAt": "2020-07-07T16:44:55Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwMjg2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            |`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n          \n          \n            \n            |`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if the `quarkus-undertow` extension is used.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451002867", "createdAt": "2020-07-07T16:45:13Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwMzEwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n          \n          \n            \n            NOTE: There can be other custom scopes provided by Quarkus extensions. For example, `quarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451003106", "createdAt": "2020-07-07T16:45:34Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwNTE5Mw==", "bodyText": "Do producer fields bring something to the mix? If not, maybe I wouldn't introduce them here.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451005193", "createdAt": "2020-07-07T16:49:12Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).\n+Client proxies allow for:\n+\n+* Lazy instantiation - the instance is created once a method is invoked upon the proxy.\n+* Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.\n+* Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. \n+* In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.\n+ \n+ \n+== _Q: OK. You said that there are several kinds of beans?_\n+\n+A: Yes. In general, in Quarkus we distinguish:\n+\n+1. Class beans\n+2. Producer methods\n+3. Producer fields\n+4. Synthetic beans\n+\n+Producer methods are useful if you need additional control over instantiation of a bean.\n+They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.\n+\n+.Producer Method Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PiProducer {\n+\n+    @Produces <1>\n+    double producePi() { \n+       return Math.PI; <2>\n+    }\n+}\n+\n+@ApplicationScoped\n+public class PiConsumer {\n+\n+   @Inject\n+   double pi; <3>\n+   \n+   double twoPis() {\n+     return pi * 2;\n+   }\n+} \n+----\n+<1> The container analyses the method annotations to build a bean metadata.\n+The return type is used to build the set of bean types. \n+In this case, it will be `double` and `java.lang.Object`.\n+No scope annotation is declared and so it's defaulted to `@Dependent`.\n+<2> The container will delegate to this method when creating the bean instance.\n+<3> `PiProducer#producePi()` is invoked and the result is set to `PiConsumer#pi` when the `PiConsumer` instance is created.\n+\n+NOTE: One of the limitations of producers is that interceptors are not applied to the result of a producer method/field.\n+\n+Producer fields are very similar to producer methods except that the field value is read when obtaining a bean instance.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxODU1Ng=="}, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwNTUzNw==", "bodyText": "Yeah, I think they shouldn't be introduced here.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451005537", "createdAt": "2020-07-07T16:49:46Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).\n+Client proxies allow for:\n+\n+* Lazy instantiation - the instance is created once a method is invoked upon the proxy.\n+* Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.\n+* Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. \n+* In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.\n+ \n+ \n+== _Q: OK. You said that there are several kinds of beans?_\n+\n+A: Yes. In general, in Quarkus we distinguish:\n+\n+1. Class beans\n+2. Producer methods\n+3. Producer fields\n+4. Synthetic beans\n+\n+Producer methods are useful if you need additional control over instantiation of a bean.\n+They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.\n+\n+.Producer Method Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PiProducer {\n+\n+    @Produces <1>\n+    double producePi() { \n+       return Math.PI; <2>\n+    }\n+}\n+\n+@ApplicationScoped\n+public class PiConsumer {\n+\n+   @Inject\n+   double pi; <3>\n+   \n+   double twoPis() {\n+     return pi * 2;\n+   }\n+} \n+----\n+<1> The container analyses the method annotations to build a bean metadata.\n+The return type is used to build the set of bean types. \n+In this case, it will be `double` and `java.lang.Object`.\n+No scope annotation is declared and so it's defaulted to `@Dependent`.\n+<2> The container will delegate to this method when creating the bean instance.\n+<3> `PiProducer#producePi()` is invoked and the result is set to `PiConsumer#pi` when the `PiConsumer` instance is created.\n+\n+NOTE: One of the limitations of producers is that interceptors are not applied to the result of a producer method/field.\n+\n+Producer fields are very similar to producer methods except that the field value is read when obtaining a bean instance.\n+\n+TIP: There's more about producers. You can declare qualifiers, inject dependencies into the producer methods parameters, etc. You can read more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/beanscdi.html#_producer_methods[Weld docs, window=\"_blank\"].\n+\n+Synthetic beans are usually provided by extensions.\n+A synthetic bean is not backed by a class/method/field.\n+Application developers usually only consume this kind of beans.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3NzgyNg=="}, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwNjU2Mg==", "bodyText": "I think it makes sense to have them here.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451006562", "createdAt": "2020-07-07T16:51:30Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).\n+Client proxies allow for:\n+\n+* Lazy instantiation - the instance is created once a method is invoked upon the proxy.\n+* Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.\n+* Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. \n+* In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.\n+ \n+ \n+== _Q: OK. You said that there are several kinds of beans?_\n+\n+A: Yes. In general, in Quarkus we distinguish:\n+\n+1. Class beans\n+2. Producer methods\n+3. Producer fields\n+4. Synthetic beans\n+\n+Producer methods are useful if you need additional control over instantiation of a bean.\n+They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.\n+\n+.Producer Method Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PiProducer {\n+\n+    @Produces <1>\n+    double producePi() { \n+       return Math.PI; <2>\n+    }\n+}\n+\n+@ApplicationScoped\n+public class PiConsumer {\n+\n+   @Inject\n+   double pi; <3>\n+   \n+   double twoPis() {\n+     return pi * 2;\n+   }\n+} \n+----\n+<1> The container analyses the method annotations to build a bean metadata.\n+The return type is used to build the set of bean types. \n+In this case, it will be `double` and `java.lang.Object`.\n+No scope annotation is declared and so it's defaulted to `@Dependent`.\n+<2> The container will delegate to this method when creating the bean instance.\n+<3> `PiProducer#producePi()` is invoked and the result is set to `PiConsumer#pi` when the `PiConsumer` instance is created.\n+\n+NOTE: One of the limitations of producers is that interceptors are not applied to the result of a producer method/field.\n+\n+Producer fields are very similar to producer methods except that the field value is read when obtaining a bean instance.\n+\n+TIP: There's more about producers. You can declare qualifiers, inject dependencies into the producer methods parameters, etc. You can read more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/beanscdi.html#_producer_methods[Weld docs, window=\"_blank\"].\n+\n+Synthetic beans are usually provided by extensions.\n+A synthetic bean is not backed by a class/method/field.\n+Application developers usually only consume this kind of beans.\n+\n+== _Q: OK injection looks cool. What other services are provided?_\n+\n+=== Lifecycle Callbacks\n+\n+A bean class may declare lifecycle `@PostConstruct` and `@PreDestroy` callbacks:\n+\n+.Lifecycle Callbacks Example\n+[source,java]\n+----\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+\n+@ApplicationScoped\n+public class Translator {\n+\n+    @PostConstruct <1>\n+    void init() {\n+       // ...\n+    }\n+    \n+    @PreDestroy <2>\n+    void destroy() {\n+      // ...\n+    }\n+}\n+----\n+<1> This callback is invoked before the bean instance is put into service. It is safe to perform some initialization here.\n+<2> This callback is invoked before the bean instance is destroyed. It is safe to perform some cleanup tasks here.\n+\n+TIP: It's a good practice to keep the logic in the callbacks \"without side effects\", i.e. you should avoid calling other beans inside the callbacks.\n+\n+=== Interceptors\n+\n+Interceptors are used to separate cross-cutting concerns from business logic. \n+There is a separate specification - Java Interceptors - that defines the basic programming model and semantics.\n+\n+.Simple Interceptor Example\n+[source,java]\n+----\n+import javax.interceptor.Interceptor;\n+import javax.annotation.Priority;\n+\n+@Logged <1>\n+@Priority(2020) <2>\n+@Interceptor <3>\n+public class LoggingInterceptor {\n+\n+   @Inject <4>\n+   Logger logger;\n+\n+   @AroundInvoke <5>\n+   Objec logInvocation(InvocationContext context) {\n+      // ...log before\n+      Objec ret = context.proceed(); <6>\n+      // ...log after\n+      return ret;\n+   }\n+    \n+}\n+----\n+<1> This is an interceptor binding annotation that is used to bind our interceptor to a bean. Simply annotate a bean class with `@Logged`.\n+<2> `Priority` enables the interceptor and affects the the interceptor ordering. \n+<3> Marks an interceptor component.\n+<4> An interceptor instance may be the target of dependency injection.\n+<5> `AroundInvoke` denotes a method that interposes on business methods.\n+<6> Proceed to the next interceptor in the interceptor chain or invoke the intercepted business method.\n+\n+NOTE: Instances of interceptors are dependent objects of the bean instance they intercept, i.e. a new interceptor instance is created for each intercepred bean.\n+\n+=== Events and Observers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4MjYxNg=="}, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 316}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NDgyOTM1", "url": "https://github.com/quarkusio/quarkus/pull/10529#pullrequestreview-444482935", "createdAt": "2020-07-08T07:34:02Z", "commit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNzozNDowMlrOGubrQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwNzozNDowMlrOGubrQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM0MTEyMw==", "bodyText": "I'm not find of those examples that uses a CDI bean to produce String/long/doubles/...\nThis is not usually how we use them, we use them to instantiate and object from a third party library or to initialize complex objects.\nCan you use a different example to make more sense ?", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451341123", "createdAt": "2020-07-08T07:34:02Z", "author": {"login": "loicmathieu"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).\n+Client proxies allow for:\n+\n+* Lazy instantiation - the instance is created once a method is invoked upon the proxy.\n+* Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.\n+* Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. \n+* In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.\n+ \n+ \n+== _Q: OK. You said that there are several kinds of beans?_\n+\n+A: Yes. In general, in Quarkus we distinguish:\n+\n+1. Class beans\n+2. Producer methods\n+3. Producer fields\n+4. Synthetic beans\n+\n+Producer methods are useful if you need additional control over instantiation of a bean.\n+They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.\n+\n+.Producer Method Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PiProducer {\n+\n+    @Produces <1>\n+    double producePi() { \n+       return Math.PI; <2>\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 216}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NTQyNDQ4", "url": "https://github.com/quarkusio/quarkus/pull/10529#pullrequestreview-444542448", "createdAt": "2020-07-08T08:53:19Z", "commit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwODo1MzoxOVrOGuehoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwOTo0MDo0MFrOGugP8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4NzgwOA==", "bodyText": "Maybe just say that the field value is a bean set by container and keep the note of failure if there is no matching bean.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451387808", "createdAt": "2020-07-08T08:53:19Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk0MzI5NA=="}, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5NDczNQ==", "bodyText": "+1 to mention you don't need @Inject\nAnd I think we can avoid the no-args comment instead, most users won't even know it's needed and the fact that it is required just rises more questions IMO", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451394735", "createdAt": "2020-07-08T09:04:38Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxNTczOA=="}, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5NjA0Mg==", "bodyText": "I think that's covered in the links to spec. You literally just copy the code it links to.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451396042", "createdAt": "2020-07-08T09:06:58Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTAwMjExNw=="}, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5Njc2Ng==", "bodyText": "Should we also mention why would you want to use qualifiers? E.g. to distinguish between several beans having same type(s)?", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451396766", "createdAt": "2020-07-08T09:08:14Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM5ODcwNA==", "bodyText": "The notion of being created eagerly can be misleading. It is eager as in not having to call a method on the bean. However, not as eager as automatically creating it on app startup (which is something we cover with another annotation). I'd probably remove that.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451398704", "createdAt": "2020-07-08T09:11:43Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQwMTcyNQ==", "bodyText": "I would be a bit more verbose, for a CDI newbie I think your description won't be clear enough (maybe I am not giving them enough credit though :)):\nThis is a pseudo-scope. The instances are not shared and every injection point spawns a new instance of dependent bean. The lifecycle of dependent bean is bound to the bean injecting it - it will be created and destroyed along with the bean injecting it.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451401725", "createdAt": "2020-07-08T09:16:43Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk0NjQ5NQ=="}, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQwNDMyMw==", "bodyText": "contextual instance is a term used within CDI spec. I think it is good to introduce it so that the reader understands it if they decide to open the specification.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451404323", "createdAt": "2020-07-08T09:21:02Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3NTk4Ng=="}, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQwNjgyMQ==", "bodyText": "Maybe we should also note that a producer method needs to be declared inside another bean?", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451406821", "createdAt": "2020-07-08T09:25:08Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).\n+Client proxies allow for:\n+\n+* Lazy instantiation - the instance is created once a method is invoked upon the proxy.\n+* Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.\n+* Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. \n+* In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.\n+ \n+ \n+== _Q: OK. You said that there are several kinds of beans?_\n+\n+A: Yes. In general, in Quarkus we distinguish:\n+\n+1. Class beans\n+2. Producer methods\n+3. Producer fields\n+4. Synthetic beans\n+\n+Producer methods are useful if you need additional control over instantiation of a bean.\n+They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.\n+\n+.Producer Method Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PiProducer {\n+\n+    @Produces <1>\n+    double producePi() { \n+       return Math.PI; <2>\n+    }\n+}\n+\n+@ApplicationScoped\n+public class PiConsumer {\n+\n+   @Inject\n+   double pi; <3>\n+   \n+   double twoPis() {\n+     return pi * 2;\n+   }\n+} \n+----\n+<1> The container analyses the method annotations to build a bean metadata.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQwODI0Ng==", "bodyText": "Do producer fields bring something to the mix? If not, maybe I wouldn't introduce them here.\n\nThey are just \"simpler producer methods\" because sometimes you don't need whole method to declare it.\nThe text related to producer fields is so tiny, I would probably keep it.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451408246", "createdAt": "2020-07-08T09:27:27Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).\n+Client proxies allow for:\n+\n+* Lazy instantiation - the instance is created once a method is invoked upon the proxy.\n+* Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.\n+* Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. \n+* In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.\n+ \n+ \n+== _Q: OK. You said that there are several kinds of beans?_\n+\n+A: Yes. In general, in Quarkus we distinguish:\n+\n+1. Class beans\n+2. Producer methods\n+3. Producer fields\n+4. Synthetic beans\n+\n+Producer methods are useful if you need additional control over instantiation of a bean.\n+They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.\n+\n+.Producer Method Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PiProducer {\n+\n+    @Produces <1>\n+    double producePi() { \n+       return Math.PI; <2>\n+    }\n+}\n+\n+@ApplicationScoped\n+public class PiConsumer {\n+\n+   @Inject\n+   double pi; <3>\n+   \n+   double twoPis() {\n+     return pi * 2;\n+   }\n+} \n+----\n+<1> The container analyses the method annotations to build a bean metadata.\n+The return type is used to build the set of bean types. \n+In this case, it will be `double` and `java.lang.Object`.\n+No scope annotation is declared and so it's defaulted to `@Dependent`.\n+<2> The container will delegate to this method when creating the bean instance.\n+<3> `PiProducer#producePi()` is invoked and the result is set to `PiConsumer#pi` when the `PiConsumer` instance is created.\n+\n+NOTE: One of the limitations of producers is that interceptors are not applied to the result of a producer method/field.\n+\n+Producer fields are very similar to producer methods except that the field value is read when obtaining a bean instance.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDkxODU1Ng=="}, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQwOTgxOA==", "bodyText": "I am biased about it. On one hand developers only consume them, OTOH they need to know they exist otherwise they will keep seeing injection of beans that have no classes/producers backing them and are seemingly conjured out of thin air.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451409818", "createdAt": "2020-07-08T09:30:08Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).\n+Client proxies allow for:\n+\n+* Lazy instantiation - the instance is created once a method is invoked upon the proxy.\n+* Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.\n+* Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. \n+* In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.\n+ \n+ \n+== _Q: OK. You said that there are several kinds of beans?_\n+\n+A: Yes. In general, in Quarkus we distinguish:\n+\n+1. Class beans\n+2. Producer methods\n+3. Producer fields\n+4. Synthetic beans\n+\n+Producer methods are useful if you need additional control over instantiation of a bean.\n+They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.\n+\n+.Producer Method Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PiProducer {\n+\n+    @Produces <1>\n+    double producePi() { \n+       return Math.PI; <2>\n+    }\n+}\n+\n+@ApplicationScoped\n+public class PiConsumer {\n+\n+   @Inject\n+   double pi; <3>\n+   \n+   double twoPis() {\n+     return pi * 2;\n+   }\n+} \n+----\n+<1> The container analyses the method annotations to build a bean metadata.\n+The return type is used to build the set of bean types. \n+In this case, it will be `double` and `java.lang.Object`.\n+No scope annotation is declared and so it's defaulted to `@Dependent`.\n+<2> The container will delegate to this method when creating the bean instance.\n+<3> `PiProducer#producePi()` is invoked and the result is set to `PiConsumer#pi` when the `PiConsumer` instance is created.\n+\n+NOTE: One of the limitations of producers is that interceptors are not applied to the result of a producer method/field.\n+\n+Producer fields are very similar to producer methods except that the field value is read when obtaining a bean instance.\n+\n+TIP: There's more about producers. You can declare qualifiers, inject dependencies into the producer methods parameters, etc. You can read more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/beanscdi.html#_producer_methods[Weld docs, window=\"_blank\"].\n+\n+Synthetic beans are usually provided by extensions.\n+A synthetic bean is not backed by a class/method/field.\n+Application developers usually only consume this kind of beans.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3NzgyNg=="}, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQxMDMyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            == _Q: OK injection looks cool. What other services are provided?_\n          \n          \n            \n            == _Q: OK, injection looks cool. What other services are provided?_", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451410328", "createdAt": "2020-07-08T09:30:57Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).\n+Client proxies allow for:\n+\n+* Lazy instantiation - the instance is created once a method is invoked upon the proxy.\n+* Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.\n+* Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. \n+* In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.\n+ \n+ \n+== _Q: OK. You said that there are several kinds of beans?_\n+\n+A: Yes. In general, in Quarkus we distinguish:\n+\n+1. Class beans\n+2. Producer methods\n+3. Producer fields\n+4. Synthetic beans\n+\n+Producer methods are useful if you need additional control over instantiation of a bean.\n+They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.\n+\n+.Producer Method Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PiProducer {\n+\n+    @Produces <1>\n+    double producePi() { \n+       return Math.PI; <2>\n+    }\n+}\n+\n+@ApplicationScoped\n+public class PiConsumer {\n+\n+   @Inject\n+   double pi; <3>\n+   \n+   double twoPis() {\n+     return pi * 2;\n+   }\n+} \n+----\n+<1> The container analyses the method annotations to build a bean metadata.\n+The return type is used to build the set of bean types. \n+In this case, it will be `double` and `java.lang.Object`.\n+No scope annotation is declared and so it's defaulted to `@Dependent`.\n+<2> The container will delegate to this method when creating the bean instance.\n+<3> `PiProducer#producePi()` is invoked and the result is set to `PiConsumer#pi` when the `PiConsumer` instance is created.\n+\n+NOTE: One of the limitations of producers is that interceptors are not applied to the result of a producer method/field.\n+\n+Producer fields are very similar to producer methods except that the field value is read when obtaining a bean instance.\n+\n+TIP: There's more about producers. You can declare qualifiers, inject dependencies into the producer methods parameters, etc. You can read more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/beanscdi.html#_producer_methods[Weld docs, window=\"_blank\"].\n+\n+Synthetic beans are usually provided by extensions.\n+A synthetic bean is not backed by a class/method/field.\n+Application developers usually only consume this kind of beans.\n+\n+== _Q: OK injection looks cool. What other services are provided?_", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQxMzU3Nw==", "bodyText": "Events and observers are part of core CDI. I don't think it's anyhow linked to Vert.x.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451413577", "createdAt": "2020-07-08T09:36:21Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).\n+Client proxies allow for:\n+\n+* Lazy instantiation - the instance is created once a method is invoked upon the proxy.\n+* Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.\n+* Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. \n+* In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.\n+ \n+ \n+== _Q: OK. You said that there are several kinds of beans?_\n+\n+A: Yes. In general, in Quarkus we distinguish:\n+\n+1. Class beans\n+2. Producer methods\n+3. Producer fields\n+4. Synthetic beans\n+\n+Producer methods are useful if you need additional control over instantiation of a bean.\n+They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.\n+\n+.Producer Method Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PiProducer {\n+\n+    @Produces <1>\n+    double producePi() { \n+       return Math.PI; <2>\n+    }\n+}\n+\n+@ApplicationScoped\n+public class PiConsumer {\n+\n+   @Inject\n+   double pi; <3>\n+   \n+   double twoPis() {\n+     return pi * 2;\n+   }\n+} \n+----\n+<1> The container analyses the method annotations to build a bean metadata.\n+The return type is used to build the set of bean types. \n+In this case, it will be `double` and `java.lang.Object`.\n+No scope annotation is declared and so it's defaulted to `@Dependent`.\n+<2> The container will delegate to this method when creating the bean instance.\n+<3> `PiProducer#producePi()` is invoked and the result is set to `PiConsumer#pi` when the `PiConsumer` instance is created.\n+\n+NOTE: One of the limitations of producers is that interceptors are not applied to the result of a producer method/field.\n+\n+Producer fields are very similar to producer methods except that the field value is read when obtaining a bean instance.\n+\n+TIP: There's more about producers. You can declare qualifiers, inject dependencies into the producer methods parameters, etc. You can read more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/beanscdi.html#_producer_methods[Weld docs, window=\"_blank\"].\n+\n+Synthetic beans are usually provided by extensions.\n+A synthetic bean is not backed by a class/method/field.\n+Application developers usually only consume this kind of beans.\n+\n+== _Q: OK injection looks cool. What other services are provided?_\n+\n+=== Lifecycle Callbacks\n+\n+A bean class may declare lifecycle `@PostConstruct` and `@PreDestroy` callbacks:\n+\n+.Lifecycle Callbacks Example\n+[source,java]\n+----\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+\n+@ApplicationScoped\n+public class Translator {\n+\n+    @PostConstruct <1>\n+    void init() {\n+       // ...\n+    }\n+    \n+    @PreDestroy <2>\n+    void destroy() {\n+      // ...\n+    }\n+}\n+----\n+<1> This callback is invoked before the bean instance is put into service. It is safe to perform some initialization here.\n+<2> This callback is invoked before the bean instance is destroyed. It is safe to perform some cleanup tasks here.\n+\n+TIP: It's a good practice to keep the logic in the callbacks \"without side effects\", i.e. you should avoid calling other beans inside the callbacks.\n+\n+=== Interceptors\n+\n+Interceptors are used to separate cross-cutting concerns from business logic. \n+There is a separate specification - Java Interceptors - that defines the basic programming model and semantics.\n+\n+.Simple Interceptor Example\n+[source,java]\n+----\n+import javax.interceptor.Interceptor;\n+import javax.annotation.Priority;\n+\n+@Logged <1>\n+@Priority(2020) <2>\n+@Interceptor <3>\n+public class LoggingInterceptor {\n+\n+   @Inject <4>\n+   Logger logger;\n+\n+   @AroundInvoke <5>\n+   Objec logInvocation(InvocationContext context) {\n+      // ...log before\n+      Objec ret = context.proceed(); <6>\n+      // ...log after\n+      return ret;\n+   }\n+    \n+}\n+----\n+<1> This is an interceptor binding annotation that is used to bind our interceptor to a bean. Simply annotate a bean class with `@Logged`.\n+<2> `Priority` enables the interceptor and affects the the interceptor ordering. \n+<3> Marks an interceptor component.\n+<4> An interceptor instance may be the target of dependency injection.\n+<5> `AroundInvoke` denotes a method that interposes on business methods.\n+<6> Proceed to the next interceptor in the interceptor chain or invoke the intercepted business method.\n+\n+NOTE: Instances of interceptors are dependent objects of the bean instance they intercept, i.e. a new interceptor instance is created for each intercepred bean.\n+\n+=== Events and Observers", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4MjYxNg=="}, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQxNDgxMw==", "bodyText": "I would add a second sample which will use qualifiers to demonstrate the typesafe resolution for observers.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451414813", "createdAt": "2020-07-08T09:38:30Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).\n+Client proxies allow for:\n+\n+* Lazy instantiation - the instance is created once a method is invoked upon the proxy.\n+* Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.\n+* Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. \n+* In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.\n+ \n+ \n+== _Q: OK. You said that there are several kinds of beans?_\n+\n+A: Yes. In general, in Quarkus we distinguish:\n+\n+1. Class beans\n+2. Producer methods\n+3. Producer fields\n+4. Synthetic beans\n+\n+Producer methods are useful if you need additional control over instantiation of a bean.\n+They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.\n+\n+.Producer Method Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PiProducer {\n+\n+    @Produces <1>\n+    double producePi() { \n+       return Math.PI; <2>\n+    }\n+}\n+\n+@ApplicationScoped\n+public class PiConsumer {\n+\n+   @Inject\n+   double pi; <3>\n+   \n+   double twoPis() {\n+     return pi * 2;\n+   }\n+} \n+----\n+<1> The container analyses the method annotations to build a bean metadata.\n+The return type is used to build the set of bean types. \n+In this case, it will be `double` and `java.lang.Object`.\n+No scope annotation is declared and so it's defaulted to `@Dependent`.\n+<2> The container will delegate to this method when creating the bean instance.\n+<3> `PiProducer#producePi()` is invoked and the result is set to `PiConsumer#pi` when the `PiConsumer` instance is created.\n+\n+NOTE: One of the limitations of producers is that interceptors are not applied to the result of a producer method/field.\n+\n+Producer fields are very similar to producer methods except that the field value is read when obtaining a bean instance.\n+\n+TIP: There's more about producers. You can declare qualifiers, inject dependencies into the producer methods parameters, etc. You can read more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/beanscdi.html#_producer_methods[Weld docs, window=\"_blank\"].\n+\n+Synthetic beans are usually provided by extensions.\n+A synthetic bean is not backed by a class/method/field.\n+Application developers usually only consume this kind of beans.\n+\n+== _Q: OK injection looks cool. What other services are provided?_\n+\n+=== Lifecycle Callbacks\n+\n+A bean class may declare lifecycle `@PostConstruct` and `@PreDestroy` callbacks:\n+\n+.Lifecycle Callbacks Example\n+[source,java]\n+----\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+\n+@ApplicationScoped\n+public class Translator {\n+\n+    @PostConstruct <1>\n+    void init() {\n+       // ...\n+    }\n+    \n+    @PreDestroy <2>\n+    void destroy() {\n+      // ...\n+    }\n+}\n+----\n+<1> This callback is invoked before the bean instance is put into service. It is safe to perform some initialization here.\n+<2> This callback is invoked before the bean instance is destroyed. It is safe to perform some cleanup tasks here.\n+\n+TIP: It's a good practice to keep the logic in the callbacks \"without side effects\", i.e. you should avoid calling other beans inside the callbacks.\n+\n+=== Interceptors\n+\n+Interceptors are used to separate cross-cutting concerns from business logic. \n+There is a separate specification - Java Interceptors - that defines the basic programming model and semantics.\n+\n+.Simple Interceptor Example\n+[source,java]\n+----\n+import javax.interceptor.Interceptor;\n+import javax.annotation.Priority;\n+\n+@Logged <1>\n+@Priority(2020) <2>\n+@Interceptor <3>\n+public class LoggingInterceptor {\n+\n+   @Inject <4>\n+   Logger logger;\n+\n+   @AroundInvoke <5>\n+   Objec logInvocation(InvocationContext context) {\n+      // ...log before\n+      Objec ret = context.proceed(); <6>\n+      // ...log after\n+      return ret;\n+   }\n+    \n+}\n+----\n+<1> This is an interceptor binding annotation that is used to bind our interceptor to a bean. Simply annotate a bean class with `@Logged`.\n+<2> `Priority` enables the interceptor and affects the the interceptor ordering. \n+<3> Marks an interceptor component.\n+<4> An interceptor instance may be the target of dependency injection.\n+<5> `AroundInvoke` denotes a method that interposes on business methods.\n+<6> Proceed to the next interceptor in the interceptor chain or invoke the intercepted business method.\n+\n+NOTE: Instances of interceptors are dependent objects of the bean instance they intercept, i.e. a new interceptor instance is created for each intercepred bean.\n+\n+=== Events and Observers\n+\t\n+Beans may also produce and consume events to interact in a completely decoupled fashion.\n+Any Java object can serve as an event payload.\n+The optional qualifiers act as topic selectors.\n+\n+.Simple Event Example\n+[source,java]\n+----\n+\n+class TaskCompleted {\n+  // ...\n+}\n+\n+@ApplicationScoped\n+class ComplicatedService {\n+\n+   @Inject\n+   Event<Task> event; <1>\n+\n+   void doSomething() {\n+      // ...\n+      event.fire(new TaskCompleted()); <2>\n+   }\n+\n+}\n+\n+@ApplicationScoped\n+class Logger {\n+\n+   void onTaskCompleted(@Observes TaskCompleted task) { <3>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 346}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQxNTQxNQ==", "bodyText": "I am not sure linking to Weld makes sense here, I'd probably remove it.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451415415", "createdAt": "2020-07-08T09:39:33Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).\n+Client proxies allow for:\n+\n+* Lazy instantiation - the instance is created once a method is invoked upon the proxy.\n+* Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.\n+* Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. \n+* In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.\n+ \n+ \n+== _Q: OK. You said that there are several kinds of beans?_\n+\n+A: Yes. In general, in Quarkus we distinguish:\n+\n+1. Class beans\n+2. Producer methods\n+3. Producer fields\n+4. Synthetic beans\n+\n+Producer methods are useful if you need additional control over instantiation of a bean.\n+They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.\n+\n+.Producer Method Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PiProducer {\n+\n+    @Produces <1>\n+    double producePi() { \n+       return Math.PI; <2>\n+    }\n+}\n+\n+@ApplicationScoped\n+public class PiConsumer {\n+\n+   @Inject\n+   double pi; <3>\n+   \n+   double twoPis() {\n+     return pi * 2;\n+   }\n+} \n+----\n+<1> The container analyses the method annotations to build a bean metadata.\n+The return type is used to build the set of bean types. \n+In this case, it will be `double` and `java.lang.Object`.\n+No scope annotation is declared and so it's defaulted to `@Dependent`.\n+<2> The container will delegate to this method when creating the bean instance.\n+<3> `PiProducer#producePi()` is invoked and the result is set to `PiConsumer#pi` when the `PiConsumer` instance is created.\n+\n+NOTE: One of the limitations of producers is that interceptors are not applied to the result of a producer method/field.\n+\n+Producer fields are very similar to producer methods except that the field value is read when obtaining a bean instance.\n+\n+TIP: There's more about producers. You can declare qualifiers, inject dependencies into the producer methods parameters, etc. You can read more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/beanscdi.html#_producer_methods[Weld docs, window=\"_blank\"].\n+\n+Synthetic beans are usually provided by extensions.\n+A synthetic bean is not backed by a class/method/field.\n+Application developers usually only consume this kind of beans.\n+\n+== _Q: OK injection looks cool. What other services are provided?_\n+\n+=== Lifecycle Callbacks\n+\n+A bean class may declare lifecycle `@PostConstruct` and `@PreDestroy` callbacks:\n+\n+.Lifecycle Callbacks Example\n+[source,java]\n+----\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+\n+@ApplicationScoped\n+public class Translator {\n+\n+    @PostConstruct <1>\n+    void init() {\n+       // ...\n+    }\n+    \n+    @PreDestroy <2>\n+    void destroy() {\n+      // ...\n+    }\n+}\n+----\n+<1> This callback is invoked before the bean instance is put into service. It is safe to perform some initialization here.\n+<2> This callback is invoked before the bean instance is destroyed. It is safe to perform some cleanup tasks here.\n+\n+TIP: It's a good practice to keep the logic in the callbacks \"without side effects\", i.e. you should avoid calling other beans inside the callbacks.\n+\n+=== Interceptors\n+\n+Interceptors are used to separate cross-cutting concerns from business logic. \n+There is a separate specification - Java Interceptors - that defines the basic programming model and semantics.\n+\n+.Simple Interceptor Example\n+[source,java]\n+----\n+import javax.interceptor.Interceptor;\n+import javax.annotation.Priority;\n+\n+@Logged <1>\n+@Priority(2020) <2>\n+@Interceptor <3>\n+public class LoggingInterceptor {\n+\n+   @Inject <4>\n+   Logger logger;\n+\n+   @AroundInvoke <5>\n+   Objec logInvocation(InvocationContext context) {\n+      // ...log before\n+      Objec ret = context.proceed(); <6>\n+      // ...log after\n+      return ret;\n+   }\n+    \n+}\n+----\n+<1> This is an interceptor binding annotation that is used to bind our interceptor to a bean. Simply annotate a bean class with `@Logged`.\n+<2> `Priority` enables the interceptor and affects the the interceptor ordering. \n+<3> Marks an interceptor component.\n+<4> An interceptor instance may be the target of dependency injection.\n+<5> `AroundInvoke` denotes a method that interposes on business methods.\n+<6> Proceed to the next interceptor in the interceptor chain or invoke the intercepted business method.\n+\n+NOTE: Instances of interceptors are dependent objects of the bean instance they intercept, i.e. a new interceptor instance is created for each intercepred bean.\n+\n+=== Events and Observers\n+\t\n+Beans may also produce and consume events to interact in a completely decoupled fashion.\n+Any Java object can serve as an event payload.\n+The optional qualifiers act as topic selectors.\n+\n+.Simple Event Example\n+[source,java]\n+----\n+\n+class TaskCompleted {\n+  // ...\n+}\n+\n+@ApplicationScoped\n+class ComplicatedService {\n+\n+   @Inject\n+   Event<Task> event; <1>\n+\n+   void doSomething() {\n+      // ...\n+      event.fire(new TaskCompleted()); <2>\n+   }\n+\n+}\n+\n+@ApplicationScoped\n+class Logger {\n+\n+   void onTaskCompleted(@Observes TaskCompleted task) { <3>\n+      // ...log the task\n+   }\n+\n+}\n+----\n+<1> `javax.enterprise.event.Event` is used to fire events.\n+<2> Fire the event synchronously.\n+<3> This method is notified when a `TaskCompleted` event is fired.\n+\n+== Conclusion\n+\n+CDI is very mature and powerful technology.\n+In this guide, we've covered some of the basic topics.\n+There is a Quarkus link:cdi-reference[CDI Reference Guide] that covers some Quarkus-specific features and limitations.\n+We also recommend you to read the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[CDI specification] and the https://docs.jboss.org/weld/reference/latest/en-US/html/[Weld documentation] (Weld is a CDI Reference Implementation) to get acquainted with more complex topics.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 361}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQxNjA0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            There is a Quarkus link:cdi-reference[CDI Reference Guide] that covers some Quarkus-specific features and limitations.\n          \n          \n            \n            If you wish to learn more, there is a Quarkus link:cdi-reference[CDI Reference Guide] that covers some Quarkus-specific features and limitations.", "url": "https://github.com/quarkusio/quarkus/pull/10529#discussion_r451416048", "createdAt": "2020-07-08T09:40:40Z", "author": {"login": "manovotn"}, "path": "docs/src/main/asciidoc/cdi.adoc", "diffHunk": "@@ -0,0 +1,361 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Introduction to Contexts and Dependency Injection\n+\n+include::./attributes.adoc[]\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+In this guide we're going to describe the basic principles of the programming model used all over the Quarkus universe. \n+Quarkus programming model is based on the http://docs.jboss.org/cdi/spec/2.0/cdi-spec.html[Contexts and Dependency Injection for Java 2.0, window=\"_blank\"] specification.\n+However, a full CDI implementation is not used under the hood.\n+Quarkus only implements a subset of the CDI features - see also <<cdi-reference.adoc#supported_features,the list of supported features>> and <<cdi-reference.adoc#limitations,the list of limitations>>.\n+On the other hand, there are quite a few <<cdi-reference#nonstandard_features,non-standard features>> and <<cdi-reference.adoc#build_time_apis,Quarkus-specific APIs>>.\n+We believe that our efforts will drive the innovation of the CDI specification towards the build-time oriented developer stacks in the future.\n+\n+== _Q: OK. Let's start simple. What is a bean?_\n+\n+A: Well, a bean is a _container-managed_ object that supports a set of basic services, such as injection of dependencies, lifecycle callbacks and interceptors.\n+\n+== _Q: Wait a minute. What does it mean container-managed?_\n+\n+A: Simply put, you don't control the lifecycle of the object instance directly.\n+Instead, you can affect the lifecycle through the declarative means, such as annotations, configuration, etc.\n+The container is the _environment_ where your application runs.\n+It creates and destroys the instances of beans, associates the instances with a designated context, and injects them into other beans.\n+\n+== _Q: What is it good for?_\n+\n+A: An application developer can focus on the business logic rather than \"where and how\" to obtain a fully initialized component with all of its dependencies.\n+\n+NOTE: You've probably heard of the _inversion of control_ (IoC) programming principle. Dependency injection is one of the implementation techniques of IoC. \n+\n+== _Q: OK. And what does a bean look like?_\n+\n+A: There are several kinds of beans.\n+The most common ones are class-based beans:\n+\n+.Simple Bean Example\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+import org.eclipse.microprofile.metrics.annotation.Counted;\n+\n+@ApplicationScoped <1>\n+public class Translator {\n+\n+    @Inject\n+    Dictionary dictionary; <2>\n+    \n+    @Counted  <3>\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> This is a scope annotation. It tells the container which context to associate the bean instance with. In this particular case, a *single bean instance* is created for the application and used by all dependants.\n+<2> This is a field injection point. It tells the container that `Translator` depends on the `Dictionary` bean. If there is no matching bean the build fails.\n+<3> This is an interceptor binding annotation. In this case, the annotation comes from the MicroProfile Metrics. The relevant interceptor intercepts the invocation and updates the relevant metrics.\n+\n+== _Q: Nice. How does the dependency resolution work? I see no names or identifiers._\n+\n+A: That's a good question.\n+In CDI the process of matching a bean to an injection point is *type-safe*.\n+Each bean declares a set of bean types.\n+In our example above, the `Translator` bean has two bean types: `Translator` and `java.lang.Object`.\n+Subsequently, a bean is assignable to an injection point if the bean has a bean type that matches the _required type_ and has all the _required qualifiers_.\n+We'll talk about qualifiers later.\n+For now, it's enough to know that the bean above is assignable to an injection point of type `Translator` and `java.lang.Object`.\n+\n+== _Q: Hm, wait a minute. What happens if multiple beans declare the same type?_\n+\n+A: There is a simple rule: *exactly one bean must be assignable to an injection point, otherwise the build fails*.\n+If none is assignable the build fails with `UnsatisfiedResolutionException`.\n+If multiple are assignable the build fails with `AmbiguousResolutionException`.\n+This is very useful because your application fails fast whenever the container is not able to find an unambiguous dependency for any injection point.\n+\n+[TIP]\n+====\n+Your can use programmatic lookup via  `javax.enterprise.inject.Instance` to resolve ambiguities at runtime and even iterate over all beans implementing a given type:\n+\n+[source,java]\n+----\n+public class Translator {\n+\n+    @Inject\n+    Instance<Dictionary> dictionaries; <1>\n+    \n+    String translate(String sentence) { \n+      for (Dictionary dict : dictionaries) { <2>\n+         // ...\n+      }\n+    }\n+}\n+----\n+<1> This injection point will not result in an ambiguous dependency even if there are multiple beans that implement the `Dictionary` type.\n+<2> `javax.enterprise.inject.Instance` extends `Iterable`.\n+====\n+\n+== _Q: Can I use setter and constructor injection?_\n+\n+A: Yes, you can.\n+In fact, in CDI the \"setter injection\" is superseded by more powerful https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#initializer_methods[initializer methods, window=\"_blank\"].\n+Intializers may accept multiple parameters and don't have to follow the JavaBean naming conventions.\n+\n+.Initialized and Constructor Injection Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class Translator {\n+\n+    private final TranslatorHelper helper\n+\n+    Translator(TranslatorHelper helper) { <1>\n+       this.helper = helper;\n+    }\n+\n+    @Inject <2>\n+    void setDeps(Dictionary dic, LocalizationService locService) { <3>\n+      / ...\n+    }\n+}\n+----\n+<1> This is a constructor injection. In fact, this code would not work in regular CDI implementations where a bean with a normal scope must always declare a no-args constructor. In Quarkus we detect this problem and \"add\" such a constructor directly in the bytecode.\n+<2> An initializer method must be annotated with `@Inject`. \n+<3> An initializer may accept multiple parameters - each one is an injection point.\n+\n+== _Q: You talked about some qualifiers?_\n+\n+A: https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#qualifiers[Qualifiers, window=\"_blank\"] are annotations that help the container to distinguish beans that implement the same type.\n+As we already said a bean is assignable to an injection point if it has all the required qualifiers.\n+If you declare no qualifier at an injection point the `@Default` qualifier is assumed.\n+\n+.Bean With Custom Qualifier Example\n+[source,java]\n+----\n+@Superior <1>\n+@ApplicationScoped\n+public class SuperiorTranslator extends Translator {\n+\n+    String translate(String sentence) { \n+      // ...\n+    }\n+}\n+----\n+<1> `@Superior` is a https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#defining_qualifier_types[qualifier annotation, window=\"_blank\"].\n+\n+This bean would be assignable to `@Inject @Superior Translator` and `@Inject @Superior SuperiorTranslator` but not in `@Inject Translator`.\n+The reason is that `@Inject Translator` is automatically transformed to `@Inject @Default Translator` during typesafe resolution.\n+And since our `SuperiorTranslator` does not declare `@Default` only the original `Translator` bean is assignable.\n+\n+== _Q: Looks good. What is the bean scope?_\n+\n+The scope of a bean determines the lifecycle of its instances, i.e. when and where an instance should be created and destroyed.\n+\n+NOTE: Every bean has exactly one scope.\n+\n+== _Q: What scopes can I actually use in my Quarkus application?_\n+\n+A: You can use all the built-in scopes mentioned by the specification except for `javax.enterprise.context.ConversationScoped`.\n+\n+[options=\"header\",cols=\"1,1\"]\n+|===\n+|Annotation   |Description   \n+//----------------------\n+|`@javax.enterprise.context.ApplicationScoped`   | A single bean instance is used for the application and shared among all injection points. The instance is created lazily, i.e. once a method is invoked upon the <<client_proxies, client proxy>>. \n+|`@javax.inject.Singleton`   | Just like `@ApplicationScoped` except that no client proxy is used. The instance is created eagerly.\n+|`@javax.enterprise.context.RequestScoped`   | The bean instance is associated with the current _request_ (usually an HTTP request). \n+|`@javax.enterprise.context.Dependent`   | This is a pseudo-scope. There is no context object that holds all dependent instances. Instead, a dependent instace is a dependent object of the bean it is injected into.\n+|`@javax.enterprise.context.SessionScoped`   | This scope is backed by an `javax.servlet.http.HttpSession` object. It's only available if `quarkus-undertow` extension is used.\n+|===\n+\n+NOTE: There can be other custom scopes provided by Quarkus extension. For example, `qquarkus-narayana-jta` provides `javax.transaction.TransactionScoped`.\n+\n+[[client_proxies]]\n+== _Q: I don't undestand the concept of client proxies._\n+\n+Indeed, the https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#client_proxies[client proxies, window=\"_blank\"] could be hard to grasp but they provide some useful functionality.\n+A client proxy is basically an object that delegates all method invocations to a target bean instance.\n+It's a container construct that implements `io.quarkus.arc.ClientProxy` and extends the bean class.\n+The client proxy instance is always injected instead of a contextual instance of a normal scoped bean (e.g. `@ApplicationScoped` and `@RequestScoped`).\n+Client proxies allow for:\n+\n+* Lazy instantiation - the instance is created once a method is invoked upon the proxy.\n+* Ability to inject a bean with \"narrower\" scope to a bean with \"wider\" scope; i.e. you can inject a `@RequestScoped` bean into an `@ApplicationScoped` bean.\n+* Circular dependencies in the dependency graph. Circular dependencies are \"bad design\" but sometimes they're inevitable. \n+* In rare cases it's practical to destroy the beans manually. A direct injected reference would lead to a stale bean instance.\n+ \n+ \n+== _Q: OK. You said that there are several kinds of beans?_\n+\n+A: Yes. In general, in Quarkus we distinguish:\n+\n+1. Class beans\n+2. Producer methods\n+3. Producer fields\n+4. Synthetic beans\n+\n+Producer methods are useful if you need additional control over instantiation of a bean.\n+They are also useful when integrating third-party libraries where you don't control the class source and may not add additional annotations etc.\n+\n+.Producer Method Example\n+[source,java]\n+----\n+@ApplicationScoped\n+public class PiProducer {\n+\n+    @Produces <1>\n+    double producePi() { \n+       return Math.PI; <2>\n+    }\n+}\n+\n+@ApplicationScoped\n+public class PiConsumer {\n+\n+   @Inject\n+   double pi; <3>\n+   \n+   double twoPis() {\n+     return pi * 2;\n+   }\n+} \n+----\n+<1> The container analyses the method annotations to build a bean metadata.\n+The return type is used to build the set of bean types. \n+In this case, it will be `double` and `java.lang.Object`.\n+No scope annotation is declared and so it's defaulted to `@Dependent`.\n+<2> The container will delegate to this method when creating the bean instance.\n+<3> `PiProducer#producePi()` is invoked and the result is set to `PiConsumer#pi` when the `PiConsumer` instance is created.\n+\n+NOTE: One of the limitations of producers is that interceptors are not applied to the result of a producer method/field.\n+\n+Producer fields are very similar to producer methods except that the field value is read when obtaining a bean instance.\n+\n+TIP: There's more about producers. You can declare qualifiers, inject dependencies into the producer methods parameters, etc. You can read more about producers for example in the https://docs.jboss.org/weld/reference/latest/en-US/html/beanscdi.html#_producer_methods[Weld docs, window=\"_blank\"].\n+\n+Synthetic beans are usually provided by extensions.\n+A synthetic bean is not backed by a class/method/field.\n+Application developers usually only consume this kind of beans.\n+\n+== _Q: OK injection looks cool. What other services are provided?_\n+\n+=== Lifecycle Callbacks\n+\n+A bean class may declare lifecycle `@PostConstruct` and `@PreDestroy` callbacks:\n+\n+.Lifecycle Callbacks Example\n+[source,java]\n+----\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+\n+@ApplicationScoped\n+public class Translator {\n+\n+    @PostConstruct <1>\n+    void init() {\n+       // ...\n+    }\n+    \n+    @PreDestroy <2>\n+    void destroy() {\n+      // ...\n+    }\n+}\n+----\n+<1> This callback is invoked before the bean instance is put into service. It is safe to perform some initialization here.\n+<2> This callback is invoked before the bean instance is destroyed. It is safe to perform some cleanup tasks here.\n+\n+TIP: It's a good practice to keep the logic in the callbacks \"without side effects\", i.e. you should avoid calling other beans inside the callbacks.\n+\n+=== Interceptors\n+\n+Interceptors are used to separate cross-cutting concerns from business logic. \n+There is a separate specification - Java Interceptors - that defines the basic programming model and semantics.\n+\n+.Simple Interceptor Example\n+[source,java]\n+----\n+import javax.interceptor.Interceptor;\n+import javax.annotation.Priority;\n+\n+@Logged <1>\n+@Priority(2020) <2>\n+@Interceptor <3>\n+public class LoggingInterceptor {\n+\n+   @Inject <4>\n+   Logger logger;\n+\n+   @AroundInvoke <5>\n+   Objec logInvocation(InvocationContext context) {\n+      // ...log before\n+      Objec ret = context.proceed(); <6>\n+      // ...log after\n+      return ret;\n+   }\n+    \n+}\n+----\n+<1> This is an interceptor binding annotation that is used to bind our interceptor to a bean. Simply annotate a bean class with `@Logged`.\n+<2> `Priority` enables the interceptor and affects the the interceptor ordering. \n+<3> Marks an interceptor component.\n+<4> An interceptor instance may be the target of dependency injection.\n+<5> `AroundInvoke` denotes a method that interposes on business methods.\n+<6> Proceed to the next interceptor in the interceptor chain or invoke the intercepted business method.\n+\n+NOTE: Instances of interceptors are dependent objects of the bean instance they intercept, i.e. a new interceptor instance is created for each intercepred bean.\n+\n+=== Events and Observers\n+\t\n+Beans may also produce and consume events to interact in a completely decoupled fashion.\n+Any Java object can serve as an event payload.\n+The optional qualifiers act as topic selectors.\n+\n+.Simple Event Example\n+[source,java]\n+----\n+\n+class TaskCompleted {\n+  // ...\n+}\n+\n+@ApplicationScoped\n+class ComplicatedService {\n+\n+   @Inject\n+   Event<Task> event; <1>\n+\n+   void doSomething() {\n+      // ...\n+      event.fire(new TaskCompleted()); <2>\n+   }\n+\n+}\n+\n+@ApplicationScoped\n+class Logger {\n+\n+   void onTaskCompleted(@Observes TaskCompleted task) { <3>\n+      // ...log the task\n+   }\n+\n+}\n+----\n+<1> `javax.enterprise.event.Event` is used to fire events.\n+<2> Fire the event synchronously.\n+<3> This method is notified when a `TaskCompleted` event is fired.\n+\n+== Conclusion\n+\n+CDI is very mature and powerful technology.\n+In this guide, we've covered some of the basic topics.\n+There is a Quarkus link:cdi-reference[CDI Reference Guide] that covers some Quarkus-specific features and limitations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63d155041a5447adba997da8577b662969847b05"}, "originalPosition": 360}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "63d155041a5447adba997da8577b662969847b05", "author": {"user": {"login": "mkouba", "name": "Martin Kouba"}}, "url": "https://github.com/quarkusio/quarkus/commit/63d155041a5447adba997da8577b662969847b05", "committedDate": "2020-07-07T13:17:00Z", "message": "Docs - add Introduction to CDI"}, "afterCommit": {"oid": "4af996f333a5691769ff66a8dcd8fb883c807ea9", "author": {"user": {"login": "mkouba", "name": "Martin Kouba"}}, "url": "https://github.com/quarkusio/quarkus/commit/4af996f333a5691769ff66a8dcd8fb883c807ea9", "committedDate": "2020-07-08T10:42:23Z", "message": "Docs - add Introduction to CDI"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4af996f333a5691769ff66a8dcd8fb883c807ea9", "author": {"user": {"login": "mkouba", "name": "Martin Kouba"}}, "url": "https://github.com/quarkusio/quarkus/commit/4af996f333a5691769ff66a8dcd8fb883c807ea9", "committedDate": "2020-07-08T10:42:23Z", "message": "Docs - add Introduction to CDI"}, "afterCommit": {"oid": "6e35ed5b348e82c797d77d9288eea0cb6fe84bfc", "author": {"user": {"login": "mkouba", "name": "Martin Kouba"}}, "url": "https://github.com/quarkusio/quarkus/commit/6e35ed5b348e82c797d77d9288eea0cb6fe84bfc", "committedDate": "2020-07-08T11:26:14Z", "message": "Docs - add Introduction to CDI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4d69b9f9c4087e8dce17b61bd92da5808231446", "author": {"user": {"login": "mkouba", "name": "Martin Kouba"}}, "url": "https://github.com/quarkusio/quarkus/commit/e4d69b9f9c4087e8dce17b61bd92da5808231446", "committedDate": "2020-07-08T11:30:13Z", "message": "Docs - add Introduction to CDI"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6e35ed5b348e82c797d77d9288eea0cb6fe84bfc", "author": {"user": {"login": "mkouba", "name": "Martin Kouba"}}, "url": "https://github.com/quarkusio/quarkus/commit/6e35ed5b348e82c797d77d9288eea0cb6fe84bfc", "committedDate": "2020-07-08T11:26:14Z", "message": "Docs - add Introduction to CDI"}, "afterCommit": {"oid": "e4d69b9f9c4087e8dce17b61bd92da5808231446", "author": {"user": {"login": "mkouba", "name": "Martin Kouba"}}, "url": "https://github.com/quarkusio/quarkus/commit/e4d69b9f9c4087e8dce17b61bd92da5808231446", "committedDate": "2020-07-08T11:30:13Z", "message": "Docs - add Introduction to CDI"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NjYxNTgy", "url": "https://github.com/quarkusio/quarkus/pull/10529#pullrequestreview-444661582", "createdAt": "2020-07-08T11:42:20Z", "commit": {"oid": "e4d69b9f9c4087e8dce17b61bd92da5808231446"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzgwNDA4", "url": "https://github.com/quarkusio/quarkus/pull/10529#pullrequestreview-444780408", "createdAt": "2020-07-08T13:46:21Z", "commit": {"oid": "e4d69b9f9c4087e8dce17b61bd92da5808231446"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MzIzODA0", "url": "https://github.com/quarkusio/quarkus/pull/10529#pullrequestreview-446323804", "createdAt": "2020-07-10T11:21:16Z", "commit": {"oid": "e4d69b9f9c4087e8dce17b61bd92da5808231446"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3660, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}