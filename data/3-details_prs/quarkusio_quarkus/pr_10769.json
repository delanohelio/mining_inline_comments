{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUwMDAwMDkz", "number": 10769, "title": "Panache reactive based on Hibernate Reactive", "bodyText": "Probably a few things left to fix, but at least all the tests pass, so a good candidate for running tests in CI.", "createdAt": "2020-07-16T08:20:41Z", "url": "https://github.com/quarkusio/quarkus/pull/10769", "merged": true, "mergeCommit": {"oid": "796808c0f3be736ee94b86cde75bb6f0bd5abc09"}, "closed": true, "closedAt": "2020-09-17T13:12:49Z", "author": {"login": "FroMage"}, "timelineItems": {"totalCount": 41, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc2yVu3gBqjM1NjYwNzM2NTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdJJAu7ABqjM3Njg3ODY4NDA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "592c9114898320c553436e898414e4a594fa68e8", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/592c9114898320c553436e898414e4a594fa68e8", "committedDate": "2020-07-16T08:15:13Z", "message": "junit5-mutiny: do not mock ClientProxy interfaces\n\nThey don't have generics"}, "afterCommit": {"oid": "521c6770f3ec626ef7e579af188e34cb614c04ce", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/521c6770f3ec626ef7e579af188e34cb614c04ce", "committedDate": "2020-07-20T14:16:51Z", "message": "junit5-mutiny: do not mock ClientProxy interfaces\n\nThey don't have generics"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "521c6770f3ec626ef7e579af188e34cb614c04ce", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/521c6770f3ec626ef7e579af188e34cb614c04ce", "committedDate": "2020-07-20T14:16:51Z", "message": "junit5-mutiny: do not mock ClientProxy interfaces\n\nThey don't have generics"}, "afterCommit": {"oid": "71f49320b6f75890f760f9ee2ab72e257f65755a", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/71f49320b6f75890f760f9ee2ab72e257f65755a", "committedDate": "2020-07-21T09:05:33Z", "message": "junit5-mutiny: do not mock ClientProxy interfaces\n\nThey don't have generics"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "71f49320b6f75890f760f9ee2ab72e257f65755a", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/71f49320b6f75890f760f9ee2ab72e257f65755a", "committedDate": "2020-07-21T09:05:33Z", "message": "junit5-mutiny: do not mock ClientProxy interfaces\n\nThey don't have generics"}, "afterCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/66cd30adf5f65e235831e3cb55ea57ad8f317b48", "committedDate": "2020-07-21T15:33:19Z", "message": "junit5-mockito: do not mock ClientProxy interfaces\n\nThey don't have generics"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzMDc3OTk1", "url": "https://github.com/quarkusio/quarkus/pull/10769#pullrequestreview-453077995", "createdAt": "2020-07-22T07:53:20Z", "commit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNzo1MzoyMFrOG1W9Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNzo1MzoyMFrOG1W9Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYwMzgzMA==", "bodyText": "You won't have a specific guide?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r458603830", "createdAt": "2020-07-22T07:53:20Z", "author": {"login": "gsmet"}, "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/resources/META-INF/quarkus-extension.yaml", "diffHunk": "@@ -0,0 +1,12 @@\n+---\n+name: \"Hibernate Reactive with Panache\"\n+metadata:\n+  keywords:\n+  - \"hibernate-reactive-panache\"\n+  - \"panache\"\n+  - \"hibernate\"\n+  - \"jpa\"\n+  guide: \"https://quarkus.io/guides/hibernate-orm-panache\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NzU3OTE1", "url": "https://github.com/quarkusio/quarkus/pull/10769#pullrequestreview-454757915", "createdAt": "2020-07-24T09:42:47Z", "commit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwOTo0Mjo0N1rOG2pXKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwOTo0Mjo0N1rOG2pXKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1Mzk2Mw==", "bodyText": "What if the settings don't match from a previously cached mock you might have created for the same klass?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459953963", "createdAt": "2020-07-24T09:42:47Z", "author": {"login": "Sanne"}, "path": "extensions/panache/panache-mock/src/main/java/io/quarkus/panache/mock/PanacheMock.java", "diffHunk": "@@ -40,6 +41,13 @@ public static void mock(Class<?>... classes) {\n         IsMockEnabled = !mocks.isEmpty();\n     }\n \n+    public static void mock(MockSettings settings, Class<?>... classes) {\n+        for (Class<?> klass : classes) {\n+            mocks.computeIfAbsent(klass, v -> Mockito.mock(klass, settings));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NzU5MzI0", "url": "https://github.com/quarkusio/quarkus/pull/10769#pullrequestreview-454759324", "createdAt": "2020-07-24T09:45:20Z", "commit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwOTo0NToyMFrOG2pbrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwOTo0NToyMFrOG2pbrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NTExNg==", "bodyText": "you have a race condition here; maybe it's not an issues as I don't expect many will invoke this method concurrecntly, but perhaps you'd still prefer to use a safer locking pattern?\nI don't think this needs to be \"high throughput\" or high performance, so just synchronize it all?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459955116", "createdAt": "2020-07-24T09:45:20Z", "author": {"login": "Sanne"}, "path": "extensions/panache/panache-mock/src/main/java/io/quarkus/panache/mock/PanacheMock.java", "diffHunk": "@@ -40,6 +41,13 @@ public static void mock(Class<?>... classes) {\n         IsMockEnabled = !mocks.isEmpty();\n     }\n \n+    public static void mock(MockSettings settings, Class<?>... classes) {\n+        for (Class<?> klass : classes) {\n+            mocks.computeIfAbsent(klass, v -> Mockito.mock(klass, settings));\n+        }\n+        IsMockEnabled = !mocks.isEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NzYxODgw", "url": "https://github.com/quarkusio/quarkus/pull/10769#pullrequestreview-454761880", "createdAt": "2020-07-24T09:49:42Z", "commit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwOTo0OTo0MlrOG2pjUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwOTo0OTo0MlrOG2pjUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NzA3NQ==", "bodyText": "What is the purpose of this check? And why should it not be persisted otherwise?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459957075", "createdAt": "2020-07-24T09:49:42Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NzY1NTU5", "url": "https://github.com/quarkusio/quarkus/pull/10769#pullrequestreview-454765559", "createdAt": "2020-07-24T09:55:50Z", "commit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwOTo1NTo1MFrOG2pulw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwOTo1NTo1MFrOG2pulw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1OTk1OQ==", "bodyText": "why name this \"getEntityManager\" when it doesn't return one? :)\nAlso: why returning an Uni, when you could just get the Session right away? opening a Session is non-blocking.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459959959", "createdAt": "2020-07-24T09:55:50Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NzcyOTIy", "url": "https://github.com/quarkusio/quarkus/pull/10769#pullrequestreview-454772922", "createdAt": "2020-07-24T10:08:28Z", "commit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMDowODoyOFrOG2qDzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMDowODoyOFrOG2qDzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2NTM4OQ==", "bodyText": "Should we remove this for now?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459965389", "createdAt": "2020-07-24T10:08:28Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {\n+        @SuppressWarnings(\"serial\")\n+        Uni<Session> entityManager = Arc.container().instance(new TypeLiteral<Uni<Mutiny.Session>>() {\n+        }).get();\n+        // FIXME: handle null or exception?\n+        if (entityManager == null) {\n+            throw new PersistenceException(\"No Mutiny.Session found. Do you have any JPA entities defined?\");\n+        }\n+        return entityManager;\n+    }\n+\n+    public TransactionManager getTransactionManager() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 96}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0Nzc1OTQz", "url": "https://github.com/quarkusio/quarkus/pull/10769#pullrequestreview-454775943", "createdAt": "2020-07-24T10:13:52Z", "commit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMDoxMzo1MlrOG2qMRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMDoxMzo1MlrOG2qMRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2NzU1Ng==", "bodyText": "All this stuff with string manipulation is extremely dodgy .. :)", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459967556", "createdAt": "2020-07-24T10:13:52Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here\n+                return applyFilters(em, () -> countQuery.getSingleResult());\n+            });\n+        }\n+        return count;\n+    }\n+\n+    private String countQuery() {\n+        if (countQuery != null) {\n+            return countQuery;\n+        }\n+\n+        // try to generate a good count query from the existing query", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 223}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0Nzc4MDAx", "url": "https://github.com/quarkusio/quarkus/pull/10769#pullrequestreview-454778001", "createdAt": "2020-07-24T10:17:40Z", "commit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMDoxNzo0MVrOG2qSQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMDoxNzo0MVrOG2qSQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2OTA5MQ==", "bodyText": "Don't we normally have integration tests in the /integration-testsdirectory, in the root of the Quarkus source tree?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459969091", "createdAt": "2020-07-24T10:17:41Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache/deployment/pom.xml", "diffHunk": "@@ -0,0 +1,243 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <parent>\n+        <artifactId>quarkus-hibernate-reactive-panache-parent</artifactId>\n+        <groupId>io.quarkus</groupId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../</relativePath>\n+    </parent>\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <properties>\n+        <maven.compiler.parameters>true</maven.compiler.parameters>\n+        <postgres.image>postgres:10.5</postgres.image>\n+        <postgres.reactive.url>vertx-reactive:postgresql://localhost:5432/hibernate_orm_test</postgres.reactive.url>\n+    </properties>\n+\n+    <artifactId>quarkus-hibernate-reactive-panache-deployment</artifactId>\n+    <name>Quarkus - Hibernate Reactive with Panache - Deployment</name>\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-core-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-hibernate-reactive-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-hibernate-reactive-panache-common-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-panache-common-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-hibernate-reactive-panache</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.ow2.asm</groupId>\n+            <artifactId>asm</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.ow2.asm</groupId>\n+            <artifactId>asm-tree</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.ow2.asm</groupId>\n+            <artifactId>asm-analysis</artifactId>\n+        </dependency>\n+\n+        <!-- test dependencies -->\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-junit5-internal</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-reactive-pg-client</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-resteasy</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-resteasy-mutiny</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-resteasy-jsonb</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.rest-assured</groupId>\n+            <artifactId>rest-assured</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <testResources>\n+            <testResource>\n+                <directory>src/test/resources</directory>\n+                <filtering>true</filtering>\n+            </testResource>\n+        </testResources>\n+        <plugins>\n+            <plugin>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <skip>true</skip>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <artifactId>maven-failsafe-plugin</artifactId>\n+                <configuration>\n+                    <skip>true</skip>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>io.quarkus</groupId>\n+                <artifactId>quarkus-maven-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <goals>\n+                            <goal>build</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <annotationProcessorPaths>\n+                        <path>\n+                            <groupId>io.quarkus</groupId>\n+                            <artifactId>quarkus-extension-processor</artifactId>\n+                            <version>${project.version}</version>\n+                        </path>\n+                    </annotationProcessorPaths>\n+                </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+\n+    <profiles>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 134}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0Nzc4NzUz", "url": "https://github.com/quarkusio/quarkus/pull/10769#pullrequestreview-454778753", "createdAt": "2020-07-24T10:19:06Z", "commit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMDoxOTowNlrOG2qUiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMDoxOTowNlrOG2qUiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2OTY3Mw==", "bodyText": "Why using System.err here?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459969673", "createdAt": "2020-07-24T10:19:06Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache/deployment/src/main/java/io/quarkus/hibernate/reactive/panache/deployment/PanacheHibernateResourceProcessor.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package io.quarkus.hibernate.reactive.panache.deployment;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import javax.persistence.Id;\n+\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.ClassType;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.ParameterizedType;\n+import org.jboss.jandex.Type;\n+import org.jboss.jandex.Type.Kind;\n+\n+import io.quarkus.arc.deployment.UnremovableBeanBuildItem;\n+import io.quarkus.arc.deployment.ValidationPhaseBuildItem;\n+import io.quarkus.arc.processor.BeanInfo;\n+import io.quarkus.bootstrap.classloading.ClassPathElement;\n+import io.quarkus.bootstrap.classloading.QuarkusClassLoader;\n+import io.quarkus.builder.BuildException;\n+import io.quarkus.deployment.Feature;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.AdditionalApplicationArchiveMarkerBuildItem;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.util.JandexUtil;\n+import io.quarkus.hibernate.orm.deployment.AdditionalJpaModelBuildItem;\n+import io.quarkus.hibernate.orm.deployment.HibernateEnhancersRegisteredBuildItem;\n+import io.quarkus.hibernate.reactive.panache.PanacheEntity;\n+import io.quarkus.hibernate.reactive.panache.PanacheEntityBase;\n+import io.quarkus.hibernate.reactive.panache.PanacheRepository;\n+import io.quarkus.hibernate.reactive.panache.PanacheRepositoryBase;\n+import io.quarkus.panache.common.deployment.EntityField;\n+import io.quarkus.panache.common.deployment.EntityModel;\n+import io.quarkus.panache.common.deployment.MetamodelInfo;\n+import io.quarkus.panache.common.deployment.PanacheEntityClassesBuildItem;\n+import io.quarkus.panache.common.deployment.PanacheFieldAccessEnhancer;\n+import io.quarkus.panache.common.deployment.PanacheMethodCustomizer;\n+import io.quarkus.panache.common.deployment.PanacheMethodCustomizerBuildItem;\n+import io.quarkus.panache.common.deployment.PanacheRepositoryEnhancer;\n+import io.smallrye.mutiny.Uni;\n+\n+public final class PanacheHibernateResourceProcessor {\n+\n+    static final DotName DOTNAME_PANACHE_REPOSITORY_BASE = DotName.createSimple(PanacheRepositoryBase.class.getName());\n+    private static final DotName DOTNAME_PANACHE_REPOSITORY = DotName.createSimple(PanacheRepository.class.getName());\n+    static final DotName DOTNAME_PANACHE_ENTITY_BASE = DotName.createSimple(PanacheEntityBase.class.getName());\n+    private static final DotName DOTNAME_PANACHE_ENTITY = DotName.createSimple(PanacheEntity.class.getName());\n+\n+    private static final DotName DOTNAME_REACTIVE_SESSION = DotName.createSimple(Mutiny.Session.class.getName());\n+    private static final DotName DOTNAME_UNI = DotName.createSimple(Uni.class.getName());\n+\n+    private static final DotName DOTNAME_ID = DotName.createSimple(Id.class.getName());\n+    protected static final String META_INF_PANACHE_ARCHIVE_MARKER = \"META-INF/panache-archive.marker\";\n+\n+    protected static final ParameterizedType SESSION_TYPE = ParameterizedType.create(DOTNAME_UNI,\n+            new Type[] { ClassType.create(DOTNAME_REACTIVE_SESSION, Kind.CLASS) }, null);\n+\n+    @BuildStep\n+    FeatureBuildItem featureBuildItem() {\n+        // FIXME\n+        return new FeatureBuildItem(Feature.HIBERNATE_ORM_PANACHE.getName() + \"-reactive\");\n+    }\n+\n+    @BuildStep\n+    List<AdditionalJpaModelBuildItem> produceModel() {\n+        // only useful for the index resolution: hibernate will register it to be transformed, but BuildMojo\n+        // only transforms classes from the application jar, so we do our own transforming\n+        return Collections.singletonList(\n+                new AdditionalJpaModelBuildItem(PanacheEntity.class));\n+    }\n+\n+    @BuildStep\n+    UnremovableBeanBuildItem ensureBeanLookupAvailable() {\n+        //        [types=[io.smallrye.mutiny.Uni<org.hibernate.reactive.mutiny.Mutiny$Session>, java.lang.Object], \n+        //                qualifiers=[@Default, @Any], \n+        //                target=io.smallrye.mutiny.Uni<org.hibernate.reactive.mutiny.Mutiny$Session> mutinySession(), \n+        //                declaringBean=io.quarkus.hibernate.reactive.runtime.ReactiveSessionProducer]\n+\n+        return new UnremovableBeanBuildItem(new Predicate<BeanInfo>() {\n+            @Override\n+            public boolean test(BeanInfo t) {\n+                boolean m1 = t.hasType(DOTNAME_UNI);\n+                if (m1) {\n+                    boolean m2 = t.getTypes().contains(SESSION_TYPE);\n+                    System.err.println(\"REMOVE \" + t + \" m1: \" + m1 + \" m2: \" + m2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NzgxMjAz", "url": "https://github.com/quarkusio/quarkus/pull/10769#pullrequestreview-454781203", "createdAt": "2020-07-24T10:23:50Z", "commit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMDoyMzo1MVrOG2qb4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMDoyMzo1MVrOG2qb4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk3MTU1Mw==", "bodyText": "So Panache can't deal with composite IDs ?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459971553", "createdAt": "2020-07-24T10:23:51Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache/deployment/src/test/java/io/quarkus/hibernate/reactive/panache/test/DuplicateIdEntityTest.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package io.quarkus.hibernate.reactive.panache.test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import io.quarkus.builder.BuildException;\n+import io.quarkus.test.QuarkusUnitTest;\n+\n+public class DuplicateIdEntityTest {\n+\n+    @RegisterExtension\n+    static QuarkusUnitTest runner = new QuarkusUnitTest()\n+            .setExpectedException(BuildException.class)\n+            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n+                    .addClasses(DuplicateIdEntity.class));\n+\n+    @Test\n+    void shouldThrow() {\n+        fail(\"A BuildException should have been thrown due to duplicate entity ID\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NzgyMzEw", "url": "https://github.com/quarkusio/quarkus/pull/10769#pullrequestreview-454782310", "createdAt": "2020-07-24T10:25:48Z", "commit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMDoyNTo0OFrOG2qfNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMDoyNTo0OFrOG2qfNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk3MjQwNg==", "bodyText": "It's not an EntityManager .. in this case since it's public API I'd definitely fix it.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459972406", "createdAt": "2020-07-24T10:25:48Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/Panache.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package io.quarkus.hibernate.reactive.panache;\n+\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.persistence.EntityManager;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.hibernate.reactive.panache.runtime.JpaOperations;\n+import io.quarkus.panache.common.Parameters;\n+import io.smallrye.mutiny.Uni;\n+\n+/**\n+ * Utility class for Panache.\n+ *\n+ * @author St\u00e9phane \u00c9pardaud\n+ */\n+public class Panache {\n+\n+    /**\n+     * Returns the current {@link EntityManager}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2NjQ1ODEw", "url": "https://github.com/quarkusio/quarkus/pull/10769#pullrequestreview-456645810", "createdAt": "2020-07-28T13:45:19Z", "commit": {"oid": "32a3f43141080ba1504c0dbcfaf069954d0a69d5"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMzo0NToyMFrOG4NTgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNDozMzowOFrOG4PnYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU5MTQyNg==", "bodyText": "Any  particular reason to use the collector?\nIt's possible to convert a Stream using Multi and return a Uni<Void> by using ignore().\nIt would look something like:\nreturn getEntityManager.flatMap( em -> \n    Multi.createFrom().items( entities )\n        .onItem().invoke( entity -> em.persist( entity ) )\n        .onItem().ignoreAsUni()\n);", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r461591426", "createdAt": "2020-07-28T13:45:20Z", "author": {"login": "DavideD"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a3f43141080ba1504c0dbcfaf069954d0a69d5"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYxNjkyNg==", "bodyText": "You could use ifNull and IfNotNull here:\nfindById(entityClass, id)\n    .onItem().ifNotNull().transformToUni( entity -> s.remove( entity ).onItem().transform( ignore -> Boolean.TRUE ))\n    .onItem().ifNull().continueWith( Boolean.FALSE );", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r461616926", "createdAt": "2020-07-28T14:17:09Z", "author": {"login": "DavideD"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {\n+        @SuppressWarnings(\"serial\")\n+        Uni<Session> entityManager = Arc.container().instance(new TypeLiteral<Uni<Mutiny.Session>>() {\n+        }).get();\n+        // FIXME: handle null or exception?\n+        if (entityManager == null) {\n+            throw new PersistenceException(\"No Mutiny.Session found. Do you have any JPA entities defined?\");\n+        }\n+        return entityManager;\n+    }\n+\n+    public TransactionManager getTransactionManager() {\n+        return Arc.container().instance(TransactionManager.class).get();\n+    }\n+\n+    public static Mutiny.Query<?> bindParameters(Mutiny.Query<?> query, Object[] params) {\n+        if (params == null || params.length == 0)\n+            return query;\n+        for (int i = 0; i < params.length; i++) {\n+            query.setParameter(i + 1, params[i]);\n+        }\n+        return query;\n+    }\n+\n+    public static Mutiny.Query<?> bindParameters(Mutiny.Query<?> query, Map<String, Object> params) {\n+        if (params == null || params.size() == 0)\n+            return query;\n+        for (Entry<String, Object> entry : params.entrySet()) {\n+            query.setParameter(entry.getKey(), entry.getValue());\n+        }\n+        return query;\n+    }\n+\n+    public int paramCount(Object[] params) {\n+        return params != null ? params.length : 0;\n+    }\n+\n+    public int paramCount(Map<String, Object> params) {\n+        return params != null ? params.size() : 0;\n+    }\n+\n+    private String getEntityName(Class<?> entityClass) {\n+        // FIXME: not true?\n+        return entityClass.getName();\n+    }\n+\n+    public String createFindQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null) {\n+            return \"FROM \" + getEntityName(entityClass);\n+        }\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty()) {\n+            return \"FROM \" + getEntityName(entityClass);\n+        }\n+\n+        if (isNamedQuery(query)) {\n+            // we return named query as is\n+            return query;\n+        }\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \") || trimmedLc.startsWith(\"select \")) {\n+            return query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            return \"FROM \" + getEntityName(entityClass) + \" \" + query;\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    static boolean isNamedQuery(String query) {\n+        if (query == null || query.isEmpty()) {\n+            return false;\n+        }\n+        return query.charAt(0) == '#';\n+    }\n+\n+    private String createCountQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null)\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty())\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"SELECT COUNT(*) \" + query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            // ignore it\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    private String createUpdateQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null) {\n+            throw new PanacheQueryException(\"Query string cannot be null\");\n+        }\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty()) {\n+            throw new PanacheQueryException(\"Query string cannot be empty\");\n+        }\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"update \")) {\n+            return query;\n+        }\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"UPDATE \" + query;\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        if (trimmedLc.startsWith(\"set \")) {\n+            return \"UPDATE FROM \" + getEntityName(entityClass) + \" \" + query;\n+        }\n+        return \"UPDATE FROM \" + getEntityName(entityClass) + \" SET \" + query;\n+    }\n+\n+    private String createDeleteQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null)\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty())\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"DELETE \" + query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            // ignore it\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"DELETE FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    public String toOrderBy(Sort sort) {\n+        if (sort == null) {\n+            return null;\n+        }\n+        if (sort.getColumns().size() == 0) {\n+            return \"\";\n+        }\n+        StringBuilder sb = new StringBuilder(\" ORDER BY \");\n+        for (int i = 0; i < sort.getColumns().size(); i++) {\n+            Sort.Column column = sort.getColumns().get(i);\n+            if (i > 0)\n+                sb.append(\" , \");\n+            sb.append(column.getName());\n+            if (column.getDirection() != Sort.Direction.Ascending)\n+                sb.append(\" DESC\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    //\n+    // Queries\n+\n+    public Uni<?> findById(Class<?> entityClass, Object id) {\n+        return getEntityManager().flatMap(em -> em.find(entityClass, id));\n+    }\n+\n+    public Uni<?> findById(Class<?> entityClass, Object id, LockModeType lockModeType) {\n+        return getEntityManager().flatMap(em -> em.find(entityClass, id, LockModeConverter.convertToLockMode(lockModeType)));\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Object... params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        String findQuery = createFindQuery(entityClass, query, paramCount(params));\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        // FIXME: check for duplicate ORDER BY clause?\n+        if (isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            NamedQueryUtil.checkNamedQuery(entityClass, namedQuery);\n+            return createPanacheQuery(em, query, toOrderBy(sort), params);\n+        }\n+        return createPanacheQuery(em, findQuery, toOrderBy(sort), params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        String findQuery = createFindQuery(entityClass, query, paramCount(params));\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        // FIXME: check for duplicate ORDER BY clause?\n+        if (isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            NamedQueryUtil.checkNamedQuery(entityClass, namedQuery);\n+            return createPanacheQuery(em, query, toOrderBy(sort), params);\n+        }\n+        return createPanacheQuery(em, findQuery, toOrderBy(sort), params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Parameters params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return find(entityClass, query, sort, params.map());\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Object... params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Parameters params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Object... params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Parameters params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public PanacheQueryType findAll(Class<?> entityClass) {\n+        String query = \"FROM \" + getEntityName(entityClass);\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        return createPanacheQuery(em, query, null, null);\n+    }\n+\n+    public PanacheQueryType findAll(Class<?> entityClass, Sort sort) {\n+        String query = \"FROM \" + getEntityName(entityClass);\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        return createPanacheQuery(em, query, toOrderBy(sort), null);\n+    }\n+\n+    public Uni<List<?>> listAll(Class<?> entityClass) {\n+        return list(findAll(entityClass));\n+    }\n+\n+    public Uni<List<?>> listAll(Class<?> entityClass, Sort sort) {\n+        return list(findAll(entityClass, sort));\n+    }\n+\n+    public Multi<?> streamAll(Class<?> entityClass) {\n+        return stream(findAll(entityClass));\n+    }\n+\n+    public Multi<?> streamAll(Class<?> entityClass, Sort sort) {\n+        return stream(findAll(entityClass, sort));\n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public Uni<Long> count(Class<?> entityClass) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) em.createQuery(\"SELECT COUNT(*) FROM \" + getEntityName(entityClass)).getSingleResult());\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public Uni<Long> count(Class<?> entityClass, String query, Object... params) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) bindParameters(em.createQuery(createCountQuery(entityClass, query, paramCount(params))),\n+                        params).getSingleResult());\n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public Uni<Long> count(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) bindParameters(em.createQuery(createCountQuery(entityClass, query, paramCount(params))),\n+                        params).getSingleResult());\n+    }\n+\n+    public Uni<Long> count(Class<?> entityClass, String query, Parameters params) {\n+        return count(entityClass, query, params.map());\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass) {\n+        return count(entityClass).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Object... params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Parameters params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Long> deleteAll(Class<?> entityClass) {\n+        return getEntityManager().flatMap(em -> em.createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate()\n+                .map(i -> i.longValue()));\n+    }\n+\n+    public Uni<Boolean> deleteById(Class<?> entityClass, Object id) {\n+        // Impl note : we load the entity then delete it because it's the only implementation generic enough for any model,\n+        // and correct in all cases (composite key, graph of entities, ...). HQL cannot be directly used for these reasons.\n+        return findById(entityClass, id)\n+                .flatMap(entity -> {\n+                    if (entity == null) {\n+                        return Uni.createFrom().item(false);\n+                    }\n+                    return getEntityManager().flatMap(em -> em.remove(entity).map(v -> true));\n+                });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a3f43141080ba1504c0dbcfaf069954d0a69d5"}, "originalPosition": 436}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYyNzY5Ng==", "bodyText": "What about this:\n\t\treturn em.persist( entity ).onItem().ignore().andContinueWithNull();", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r461627696", "createdAt": "2020-07-28T14:31:10Z", "author": {"login": "DavideD"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a3f43141080ba1504c0dbcfaf069954d0a69d5"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYyOTI4Mg==", "bodyText": "Similar for delete and flush", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r461629282", "createdAt": "2020-07-28T14:33:08Z", "author": {"login": "DavideD"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU5MTQyNg=="}, "originalCommit": {"oid": "32a3f43141080ba1504c0dbcfaf069954d0a69d5"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MzYxNTA5", "url": "https://github.com/quarkusio/quarkus/pull/10769#pullrequestreview-457361509", "createdAt": "2020-07-29T09:43:37Z", "commit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwOTo0MzozN1rOG4w26A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMDo1OTo0MFrOG4zW2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3MzkyOA==", "bodyText": "See how I did in the MongoDB ReactivePanacheQueryImpl, I do cache the Uni count.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462173928", "createdAt": "2020-07-29T09:43:37Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NTYwNA==", "bodyText": "This is legacy code ;)\nThis was done like this in the first implementation of PanacheQuery, we already question this some times ago and decided to keep it I don't remember why ...\nBut default are no paging this is why there is the Hibernate related stuff right ,", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462175604", "createdAt": "2020-07-29T09:46:29Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here\n+                return applyFilters(em, () -> countQuery.getSingleResult());\n+            });\n+        }\n+        return count;\n+    }\n+\n+    private String countQuery() {\n+        if (countQuery != null) {\n+            return countQuery;\n+        }\n+\n+        // try to generate a good count query from the existing query\n+        Matcher selectMatcher = SELECT_PATTERN.matcher(query);\n+        String countQuery;\n+        if (selectMatcher.matches()) {\n+            // this one cannot be null\n+            String firstSelection = selectMatcher.group(1).trim();\n+            if (firstSelection.toLowerCase().startsWith(\"distinct \")) {\n+                // this one can be null\n+                String secondSelection = selectMatcher.group(2);\n+                // we can only count distinct single columns\n+                if (secondSelection != null && !secondSelection.trim().isEmpty()) {\n+                    throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+                }\n+                countQuery = \"SELECT COUNT(\" + firstSelection + \") \" + selectMatcher.group(3);\n+            } else {\n+                // it's not distinct, forget the column list\n+                countQuery = \"SELECT COUNT(*) \" + selectMatcher.group(3);\n+            }\n+        } else if (FROM_PATTERN.matcher(query).matches()) {\n+            countQuery = \"SELECT COUNT(*) \" + query;\n+        } else {\n+            throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+        }\n+\n+        // remove the order by clause\n+        String lcQuery = countQuery.toLowerCase();\n+        int orderByIndex = lcQuery.lastIndexOf(\" order by \");\n+        if (orderByIndex != -1) {\n+            countQuery = countQuery.substring(0, orderByIndex);\n+        }\n+        return countQuery;\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public <T extends Entity> Uni<List<T>> list() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return (Uni) applyFilters(em, () -> jpaQuery.getResultList());\n+        });\n+    }\n+\n+    public <T extends Entity> Multi<T> stream() {\n+        // FIXME: requires Hibernate support\n+        //        Mutiny.Query<?> jpaQuery = createQuery();\n+        //        return applyFilters(jpaQuery.getResultStream());\n+        Uni<List<T>> results = list();\n+        return (Multi<T>) results.toMulti().flatMap(list -> {\n+            return Multi.createFrom().iterable(list);\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> firstResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em, 1);\n+            return applyFilters(em, () -> jpaQuery.getResultList().map(list -> list.isEmpty() ? null : (T) list.get(0)));\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> singleResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return applyFilters(em, () -> jpaQuery.getSingleResult().map(v -> (T) v));\n+            // FIXME: workaround https://github.com/hibernate/hibernate-reactive/issues/263\n+        }).onFailure(CompletionException.class).apply(t -> t.getCause());\n+    }\n+\n+    private Mutiny.Query<?> createQuery(Mutiny.Session em) {\n+        Mutiny.Query<?> jpaQuery = createBaseQuery(em);\n+\n+        if (range != null) {\n+            jpaQuery.setFirstResult(range.getStartIndex());\n+            // range is 0 based, so we add 1\n+            jpaQuery.setMaxResults(range.getLastIndex() - range.getStartIndex() + 1);\n+        } else if (page != null) {\n+            jpaQuery.setFirstResult(page.index * page.size);\n+            jpaQuery.setMaxResults(page.size);\n+        } else {\n+            // Use deprecated API in org.hibernate.Query that will be moved to org.hibernate.query.Query on Hibernate 6.0\n+            // FIXME: requires Hibernate support\n+            //            @SuppressWarnings(\"deprecation\")\n+            //            RowSelection options = jpaQuery.unwrap(org.hibernate.query.Query.class).getQueryOptions();\n+            //            options.setFirstRow(null);\n+            //            options.setMaxRows(null);\n+            // FIXME: why would we even do that? those are the defaults, let's leave them blank", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 308}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NjY0NQ==", "bodyText": "If hint are not supported, better remove the withHint() method or make it throw an UnsupportedOperationException.\nIf they will be supported in a near future, opennning a followup issue may be a good idead", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462176645", "createdAt": "2020-07-29T09:48:22Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here\n+                return applyFilters(em, () -> countQuery.getSingleResult());\n+            });\n+        }\n+        return count;\n+    }\n+\n+    private String countQuery() {\n+        if (countQuery != null) {\n+            return countQuery;\n+        }\n+\n+        // try to generate a good count query from the existing query\n+        Matcher selectMatcher = SELECT_PATTERN.matcher(query);\n+        String countQuery;\n+        if (selectMatcher.matches()) {\n+            // this one cannot be null\n+            String firstSelection = selectMatcher.group(1).trim();\n+            if (firstSelection.toLowerCase().startsWith(\"distinct \")) {\n+                // this one can be null\n+                String secondSelection = selectMatcher.group(2);\n+                // we can only count distinct single columns\n+                if (secondSelection != null && !secondSelection.trim().isEmpty()) {\n+                    throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+                }\n+                countQuery = \"SELECT COUNT(\" + firstSelection + \") \" + selectMatcher.group(3);\n+            } else {\n+                // it's not distinct, forget the column list\n+                countQuery = \"SELECT COUNT(*) \" + selectMatcher.group(3);\n+            }\n+        } else if (FROM_PATTERN.matcher(query).matches()) {\n+            countQuery = \"SELECT COUNT(*) \" + query;\n+        } else {\n+            throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+        }\n+\n+        // remove the order by clause\n+        String lcQuery = countQuery.toLowerCase();\n+        int orderByIndex = lcQuery.lastIndexOf(\" order by \");\n+        if (orderByIndex != -1) {\n+            countQuery = countQuery.substring(0, orderByIndex);\n+        }\n+        return countQuery;\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public <T extends Entity> Uni<List<T>> list() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return (Uni) applyFilters(em, () -> jpaQuery.getResultList());\n+        });\n+    }\n+\n+    public <T extends Entity> Multi<T> stream() {\n+        // FIXME: requires Hibernate support\n+        //        Mutiny.Query<?> jpaQuery = createQuery();\n+        //        return applyFilters(jpaQuery.getResultStream());\n+        Uni<List<T>> results = list();\n+        return (Multi<T>) results.toMulti().flatMap(list -> {\n+            return Multi.createFrom().iterable(list);\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> firstResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em, 1);\n+            return applyFilters(em, () -> jpaQuery.getResultList().map(list -> list.isEmpty() ? null : (T) list.get(0)));\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> singleResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return applyFilters(em, () -> jpaQuery.getSingleResult().map(v -> (T) v));\n+            // FIXME: workaround https://github.com/hibernate/hibernate-reactive/issues/263\n+        }).onFailure(CompletionException.class).apply(t -> t.getCause());\n+    }\n+\n+    private Mutiny.Query<?> createQuery(Mutiny.Session em) {\n+        Mutiny.Query<?> jpaQuery = createBaseQuery(em);\n+\n+        if (range != null) {\n+            jpaQuery.setFirstResult(range.getStartIndex());\n+            // range is 0 based, so we add 1\n+            jpaQuery.setMaxResults(range.getLastIndex() - range.getStartIndex() + 1);\n+        } else if (page != null) {\n+            jpaQuery.setFirstResult(page.index * page.size);\n+            jpaQuery.setMaxResults(page.size);\n+        } else {\n+            // Use deprecated API in org.hibernate.Query that will be moved to org.hibernate.query.Query on Hibernate 6.0\n+            // FIXME: requires Hibernate support\n+            //            @SuppressWarnings(\"deprecation\")\n+            //            RowSelection options = jpaQuery.unwrap(org.hibernate.query.Query.class).getQueryOptions();\n+            //            options.setFirstRow(null);\n+            //            options.setMaxRows(null);\n+            // FIXME: why would we even do that? those are the defaults, let's leave them blank\n+            // if we don't, we get a LIMIT\n+            //            jpaQuery.setFirstResult(0);\n+            //            jpaQuery.setMaxResults(Integer.MAX_VALUE);\n+        }\n+\n+        return jpaQuery;\n+    }\n+\n+    private Mutiny.Query<?> createQuery(Mutiny.Session em, int maxResults) {\n+        Mutiny.Query<?> jpaQuery = createBaseQuery(em);\n+\n+        if (range != null) {\n+            jpaQuery.setFirstResult(range.getStartIndex());\n+        } else if (page != null) {\n+            jpaQuery.setFirstResult(page.index * page.size);\n+        } else {\n+            // Use deprecated API in org.hibernate.Query that will be moved to org.hibernate.query.Query on Hibernate 6.0\n+            // FIXME: requires Hibernate support\n+            //            @SuppressWarnings(\"deprecation\")\n+            //            RowSelection options = jpaQuery.unwrap(org.hibernate.query.Query.class).getQueryOptions();\n+            //            options.setFirstRow(null);\n+            jpaQuery.setFirstResult(0);\n+        }\n+        jpaQuery.setMaxResults(maxResults);\n+\n+        return jpaQuery;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Mutiny.Query<?> createBaseQuery(Mutiny.Session em) {\n+        Mutiny.Query<?> jpaQuery;\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            jpaQuery = em.createNamedQuery(namedQuery);\n+        } else {\n+            jpaQuery = em.createQuery(orderBy != null ? query + orderBy : query);\n+        }\n+\n+        if (paramsArrayOrMap instanceof Map) {\n+            AbstractJpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        } else {\n+            AbstractJpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+        }\n+\n+        if (this.lockModeType != null) {\n+            jpaQuery.setLockMode(LockModeConverter.convertToLockMode(lockModeType));\n+        }\n+\n+        if (hints != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3OTE4Nw==", "bodyText": "In the MongoDB reactive version I do keep this code imperative for the sake of simplicity.\nI think that as long as there is no IO operations, such very quick code can stay imperative but maybe I'm wrong.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462179187", "createdAt": "2020-07-29T09:52:27Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4MTE3OQ==", "bodyText": "In MongoDB panache reactive I have the following implementation, why is it the same not possible for Hibernate ?\n    public <T extends Entity> Uni<ReactivePanacheQuery<T>> lastPage() {\n        checkPagination();\n        return pageCount().map(pageCount -> page(page.index(pageCount - 1)));\n    }", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462181179", "createdAt": "2020-07-29T09:55:47Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4OTE4Mg==", "bodyText": "It misses firstResultOptional() and singleResultOptional() methods.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462189182", "createdAt": "2020-07-29T10:09:48Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/PanacheQuery.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package io.quarkus.hibernate.reactive.panache;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.persistence.LockModeType;\n+import javax.persistence.NoResultException;\n+import javax.persistence.NonUniqueResultException;\n+\n+import org.hibernate.Session;\n+import org.hibernate.annotations.FilterDef;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Parameters;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+/**\n+ * <p>\n+ * Interface representing an entity query, which abstracts the use of paging, getting the number of results, and\n+ * operating on {@link List} or {@link Stream}.\n+ * </p>\n+ * <p>\n+ * Instances of this interface cannot mutate the query itself or its parameters: only paging information can be\n+ * modified, and instances of this interface can be reused to obtain multiple pages of results.\n+ * </p>\n+ *\n+ * @author St\u00e9phane \u00c9pardaud\n+ * @param <Entity> The entity type being queried\n+ */\n+public interface PanacheQuery<Entity> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE5MjYxMg==", "bodyText": "As it's new maybe use the status preview instead of stable ?\nMoreover, the undermying Hibernate reactive extension is in preview state.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462192612", "createdAt": "2020-07-29T10:16:09Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/resources/META-INF/quarkus-extension.yaml", "diffHunk": "@@ -0,0 +1,12 @@\n+---\n+name: \"Hibernate Reactive with Panache\"\n+metadata:\n+  keywords:\n+  - \"hibernate-reactive-panache\"\n+  - \"panache\"\n+  - \"hibernate\"\n+  - \"jpa\"\n+  guide: \"https://quarkus.io/guides/hibernate-orm-panache\"\n+  categories:\n+  - \"data\"\n+  status: \"stable\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE5NTEwOA==", "bodyText": "What is the purpose of this file ?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462195108", "createdAt": "2020-07-29T10:21:22Z", "author": {"login": "loicmathieu"}, "path": "integration-tests/hibernate-reactive-panache/providers.txt", "diffHunk": "@@ -0,0 +1,4 @@\n+io.quarkus.resteasy.runtime.ForbiddenExceptionMapper", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwMzc5Nw==", "bodyText": "+1 this is what reactive MongoDB panache uses", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462203797", "createdAt": "2020-07-29T10:36:47Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYyNzY5Ng=="}, "originalCommit": {"oid": "32a3f43141080ba1504c0dbcfaf069954d0a69d5"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwNTU5OA==", "bodyText": "Maybe encapsulate this inside a Uni.createFrom().deferred(() -> {} block to traverse the entities array asynchronously", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462205598", "createdAt": "2020-07-29T10:40:24Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwNzExMg==", "bodyText": "+1 this would remove a lot of flatMap operations !", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462207112", "createdAt": "2020-07-29T10:43:26Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1OTk1OQ=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxMTA4MQ==", "bodyText": "You should use NotFoundException instead", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462211081", "createdAt": "2020-07-29T10:51:40Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache/deployment/src/test/java/io/quarkus/hibernate/reactive/panache/test/MyOtherTestResource.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package io.quarkus.hibernate.reactive.panache.test;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.WebApplicationException;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"other-entity\")\n+public class MyOtherTestResource {\n+\n+    @GET\n+    @Path(\"{id}\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Uni<MyOtherEntity> get(@PathParam long id) {\n+        return MyOtherEntity.<MyOtherEntity> findById(id)\n+                .onItem().ifNull().failWith(() -> new WebApplicationException(Response.Status.NOT_FOUND));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxMzI5OA==", "bodyText": "Are transaction mandatory for the test ?\nCan we block and make the assertions out of the reactive code?\nThis test is very hard to read with all the flatMap operations ...", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462213298", "createdAt": "2020-07-29T10:56:22Z", "author": {"login": "loicmathieu"}, "path": "integration-tests/hibernate-reactive-panache/src/main/java/io/quarkus/it/panache/reactive/TestEndpoint.java", "diffHunk": "@@ -0,0 +1,1772 @@\n+package io.quarkus.it.panache.reactive;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+import javax.inject.Inject;\n+import javax.persistence.LockModeType;\n+import javax.persistence.NoResultException;\n+import javax.persistence.NonUniqueResultException;\n+import javax.transaction.Transactional;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.xml.bind.annotation.XmlAttribute;\n+import javax.xml.bind.annotation.XmlElements;\n+import javax.xml.bind.annotation.XmlTransient;\n+\n+import org.hibernate.engine.spi.SelfDirtinessTracker;\n+import org.hibernate.jpa.QueryHints;\n+import org.junit.jupiter.api.Assertions;\n+\n+import io.quarkus.hibernate.reactive.panache.Panache;\n+import io.quarkus.hibernate.reactive.panache.PanacheQuery;\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+/**\n+ * Various tests covering Panache functionality. All tests should work in both standard JVM and in native mode.\n+ */\n+@Path(\"test\")\n+public class TestEndpoint {\n+\n+    // fake unused injection point to force ArC to not remove this otherwise I can't mock it in the tests\n+    @Inject\n+    MockablePersonRepository mockablePersonRepository;\n+\n+    @GET\n+    @Path(\"model\")\n+    @Transactional\n+    public Uni<String> testModel() {\n+        return Panache.withTransaction(() -> Person.findAll().list()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxNDg3Mg==", "bodyText": "Are these methods used somewhere?\nBecause there is no exists operation at entity/repository level ...", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462214872", "createdAt": "2020-07-29T10:59:40Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {\n+        @SuppressWarnings(\"serial\")\n+        Uni<Session> entityManager = Arc.container().instance(new TypeLiteral<Uni<Mutiny.Session>>() {\n+        }).get();\n+        // FIXME: handle null or exception?\n+        if (entityManager == null) {\n+            throw new PersistenceException(\"No Mutiny.Session found. Do you have any JPA entities defined?\");\n+        }\n+        return entityManager;\n+    }\n+\n+    public TransactionManager getTransactionManager() {\n+        return Arc.container().instance(TransactionManager.class).get();\n+    }\n+\n+    public static Mutiny.Query<?> bindParameters(Mutiny.Query<?> query, Object[] params) {\n+        if (params == null || params.length == 0)\n+            return query;\n+        for (int i = 0; i < params.length; i++) {\n+            query.setParameter(i + 1, params[i]);\n+        }\n+        return query;\n+    }\n+\n+    public static Mutiny.Query<?> bindParameters(Mutiny.Query<?> query, Map<String, Object> params) {\n+        if (params == null || params.size() == 0)\n+            return query;\n+        for (Entry<String, Object> entry : params.entrySet()) {\n+            query.setParameter(entry.getKey(), entry.getValue());\n+        }\n+        return query;\n+    }\n+\n+    public int paramCount(Object[] params) {\n+        return params != null ? params.length : 0;\n+    }\n+\n+    public int paramCount(Map<String, Object> params) {\n+        return params != null ? params.size() : 0;\n+    }\n+\n+    private String getEntityName(Class<?> entityClass) {\n+        // FIXME: not true?\n+        return entityClass.getName();\n+    }\n+\n+    public String createFindQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null) {\n+            return \"FROM \" + getEntityName(entityClass);\n+        }\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty()) {\n+            return \"FROM \" + getEntityName(entityClass);\n+        }\n+\n+        if (isNamedQuery(query)) {\n+            // we return named query as is\n+            return query;\n+        }\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \") || trimmedLc.startsWith(\"select \")) {\n+            return query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            return \"FROM \" + getEntityName(entityClass) + \" \" + query;\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    static boolean isNamedQuery(String query) {\n+        if (query == null || query.isEmpty()) {\n+            return false;\n+        }\n+        return query.charAt(0) == '#';\n+    }\n+\n+    private String createCountQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null)\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty())\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"SELECT COUNT(*) \" + query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            // ignore it\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    private String createUpdateQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null) {\n+            throw new PanacheQueryException(\"Query string cannot be null\");\n+        }\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty()) {\n+            throw new PanacheQueryException(\"Query string cannot be empty\");\n+        }\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"update \")) {\n+            return query;\n+        }\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"UPDATE \" + query;\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        if (trimmedLc.startsWith(\"set \")) {\n+            return \"UPDATE FROM \" + getEntityName(entityClass) + \" \" + query;\n+        }\n+        return \"UPDATE FROM \" + getEntityName(entityClass) + \" SET \" + query;\n+    }\n+\n+    private String createDeleteQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null)\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty())\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"DELETE \" + query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            // ignore it\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"DELETE FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    public String toOrderBy(Sort sort) {\n+        if (sort == null) {\n+            return null;\n+        }\n+        if (sort.getColumns().size() == 0) {\n+            return \"\";\n+        }\n+        StringBuilder sb = new StringBuilder(\" ORDER BY \");\n+        for (int i = 0; i < sort.getColumns().size(); i++) {\n+            Sort.Column column = sort.getColumns().get(i);\n+            if (i > 0)\n+                sb.append(\" , \");\n+            sb.append(column.getName());\n+            if (column.getDirection() != Sort.Direction.Ascending)\n+                sb.append(\" DESC\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    //\n+    // Queries\n+\n+    public Uni<?> findById(Class<?> entityClass, Object id) {\n+        return getEntityManager().flatMap(em -> em.find(entityClass, id));\n+    }\n+\n+    public Uni<?> findById(Class<?> entityClass, Object id, LockModeType lockModeType) {\n+        return getEntityManager().flatMap(em -> em.find(entityClass, id, LockModeConverter.convertToLockMode(lockModeType)));\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Object... params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        String findQuery = createFindQuery(entityClass, query, paramCount(params));\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        // FIXME: check for duplicate ORDER BY clause?\n+        if (isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            NamedQueryUtil.checkNamedQuery(entityClass, namedQuery);\n+            return createPanacheQuery(em, query, toOrderBy(sort), params);\n+        }\n+        return createPanacheQuery(em, findQuery, toOrderBy(sort), params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        String findQuery = createFindQuery(entityClass, query, paramCount(params));\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        // FIXME: check for duplicate ORDER BY clause?\n+        if (isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            NamedQueryUtil.checkNamedQuery(entityClass, namedQuery);\n+            return createPanacheQuery(em, query, toOrderBy(sort), params);\n+        }\n+        return createPanacheQuery(em, findQuery, toOrderBy(sort), params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Parameters params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return find(entityClass, query, sort, params.map());\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Object... params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Parameters params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Object... params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Parameters params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public PanacheQueryType findAll(Class<?> entityClass) {\n+        String query = \"FROM \" + getEntityName(entityClass);\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        return createPanacheQuery(em, query, null, null);\n+    }\n+\n+    public PanacheQueryType findAll(Class<?> entityClass, Sort sort) {\n+        String query = \"FROM \" + getEntityName(entityClass);\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        return createPanacheQuery(em, query, toOrderBy(sort), null);\n+    }\n+\n+    public Uni<List<?>> listAll(Class<?> entityClass) {\n+        return list(findAll(entityClass));\n+    }\n+\n+    public Uni<List<?>> listAll(Class<?> entityClass, Sort sort) {\n+        return list(findAll(entityClass, sort));\n+    }\n+\n+    public Multi<?> streamAll(Class<?> entityClass) {\n+        return stream(findAll(entityClass));\n+    }\n+\n+    public Multi<?> streamAll(Class<?> entityClass, Sort sort) {\n+        return stream(findAll(entityClass, sort));\n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public Uni<Long> count(Class<?> entityClass) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) em.createQuery(\"SELECT COUNT(*) FROM \" + getEntityName(entityClass)).getSingleResult());\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public Uni<Long> count(Class<?> entityClass, String query, Object... params) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) bindParameters(em.createQuery(createCountQuery(entityClass, query, paramCount(params))),\n+                        params).getSingleResult());\n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public Uni<Long> count(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) bindParameters(em.createQuery(createCountQuery(entityClass, query, paramCount(params))),\n+                        params).getSingleResult());\n+    }\n+\n+    public Uni<Long> count(Class<?> entityClass, String query, Parameters params) {\n+        return count(entityClass, query, params.map());\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass) {\n+        return count(entityClass).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Object... params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Parameters params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 420}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/66cd30adf5f65e235831e3cb55ea57ad8f317b48", "committedDate": "2020-07-21T15:33:19Z", "message": "junit5-mockito: do not mock ClientProxy interfaces\n\nThey don't have generics"}, "afterCommit": {"oid": "ceddafd3ade3f55aef65c58a49bac51f24d08443", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/ceddafd3ade3f55aef65c58a49bac51f24d08443", "committedDate": "2020-08-07T15:11:52Z", "message": "PanacheMock: made synchronized"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ceddafd3ade3f55aef65c58a49bac51f24d08443", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/ceddafd3ade3f55aef65c58a49bac51f24d08443", "committedDate": "2020-08-07T15:11:52Z", "message": "PanacheMock: made synchronized"}, "afterCommit": {"oid": "912673b901fbd88dbd3693e48f32ed9bde546259", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/912673b901fbd88dbd3693e48f32ed9bde546259", "committedDate": "2020-08-07T15:41:04Z", "message": "PanacheMock: made synchronized"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "912673b901fbd88dbd3693e48f32ed9bde546259", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/912673b901fbd88dbd3693e48f32ed9bde546259", "committedDate": "2020-08-07T15:41:04Z", "message": "PanacheMock: made synchronized"}, "afterCommit": {"oid": "eb3d97df37f249b790e86b1670c2323c700ac23e", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/eb3d97df37f249b790e86b1670c2323c700ac23e", "committedDate": "2020-08-13T13:57:10Z", "message": "PanacheMock: made synchronized"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eb3d97df37f249b790e86b1670c2323c700ac23e", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/eb3d97df37f249b790e86b1670c2323c700ac23e", "committedDate": "2020-08-13T13:57:10Z", "message": "PanacheMock: made synchronized"}, "afterCommit": {"oid": "86d5f706682b76591f72f4df20fd3fb727f96f5a", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/86d5f706682b76591f72f4df20fd3fb727f96f5a", "committedDate": "2020-08-17T09:13:11Z", "message": "PanacheMock: made synchronized"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "85bc58d441b7258061bb9bb73b17db50d93aa2b2", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/85bc58d441b7258061bb9bb73b17db50d93aa2b2", "committedDate": "2020-08-17T15:07:17Z", "message": "Fixed AlphaObserver test by making the mocked method public\n\nMockito doesn't know how to mock package-private methods. This only\nworks if we're mocking the ClientProxy class instead of the real bean\nclass."}, "afterCommit": {"oid": "92cd43d1f5a6720acfdf1f03fe840f71d06790ed", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/92cd43d1f5a6720acfdf1f03fe840f71d06790ed", "committedDate": "2020-08-18T12:55:11Z", "message": "Fixed AlphaObserver test by making the mocked method public\n\nMockito doesn't know how to mock package-private methods. This only\nworks if we're mocking the ClientProxy class instead of the real bean\nclass."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "92cd43d1f5a6720acfdf1f03fe840f71d06790ed", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/92cd43d1f5a6720acfdf1f03fe840f71d06790ed", "committedDate": "2020-08-18T12:55:11Z", "message": "Fixed AlphaObserver test by making the mocked method public\n\nMockito doesn't know how to mock package-private methods. This only\nworks if we're mocking the ClientProxy class instead of the real bean\nclass."}, "afterCommit": {"oid": "ac942666d342fc064fb9c877957de4b08a73ed2e", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/ac942666d342fc064fb9c877957de4b08a73ed2e", "committedDate": "2020-08-25T08:10:01Z", "message": "Fixed AlphaObserver test by making the mocked method public\n\nMockito doesn't know how to mock package-private methods. This only\nworks if we're mocking the ClientProxy class instead of the real bean\nclass."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ac942666d342fc064fb9c877957de4b08a73ed2e", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/ac942666d342fc064fb9c877957de4b08a73ed2e", "committedDate": "2020-08-25T08:10:01Z", "message": "Fixed AlphaObserver test by making the mocked method public\n\nMockito doesn't know how to mock package-private methods. This only\nworks if we're mocking the ClientProxy class instead of the real bean\nclass."}, "afterCommit": {"oid": "64c0ebb0435729dc77355004d7ceef7c1a67f6da", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/64c0ebb0435729dc77355004d7ceef7c1a67f6da", "committedDate": "2020-08-28T15:53:29Z", "message": "Fixed AlphaObserver test by making the mocked method public\n\nMockito doesn't know how to mock package-private methods. This only\nworks if we're mocking the ClientProxy class instead of the real bean\nclass."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "64c0ebb0435729dc77355004d7ceef7c1a67f6da", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/64c0ebb0435729dc77355004d7ceef7c1a67f6da", "committedDate": "2020-08-28T15:53:29Z", "message": "Fixed AlphaObserver test by making the mocked method public\n\nMockito doesn't know how to mock package-private methods. This only\nworks if we're mocking the ClientProxy class instead of the real bean\nclass."}, "afterCommit": {"oid": "6c2c15b390751490539f8d015f3761d45c98d621", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/6c2c15b390751490539f8d015f3761d45c98d621", "committedDate": "2020-08-28T15:57:16Z", "message": "Fixed AlphaObserver test by making the mocked method public\n\nMockito doesn't know how to mock package-private methods. This only\nworks if we're mocking the ClientProxy class instead of the real bean\nclass."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3ODY1Njgw", "url": "https://github.com/quarkusio/quarkus/pull/10769#pullrequestreview-477865680", "createdAt": "2020-08-28T16:25:38Z", "commit": {"oid": "6c2c15b390751490539f8d015f3761d45c98d621"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6c2c15b390751490539f8d015f3761d45c98d621", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/6c2c15b390751490539f8d015f3761d45c98d621", "committedDate": "2020-08-28T15:57:16Z", "message": "Fixed AlphaObserver test by making the mocked method public\n\nMockito doesn't know how to mock package-private methods. This only\nworks if we're mocking the ClientProxy class instead of the real bean\nclass."}, "afterCommit": {"oid": "f3af0b36effdfc439ecba7b8fca91ed50c8fa116", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/f3af0b36effdfc439ecba7b8fca91ed50c8fa116", "committedDate": "2020-08-31T10:35:21Z", "message": "Added AsmUtilCopy to ArC and use it to create signatures in _ClientProxy classes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f3af0b36effdfc439ecba7b8fca91ed50c8fa116", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/f3af0b36effdfc439ecba7b8fca91ed50c8fa116", "committedDate": "2020-08-31T10:35:21Z", "message": "Added AsmUtilCopy to ArC and use it to create signatures in _ClientProxy classes"}, "afterCommit": {"oid": "9358e690449035e4aad0eebc24af8163da420687", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/9358e690449035e4aad0eebc24af8163da420687", "committedDate": "2020-08-31T13:22:25Z", "message": "Added AsmUtilCopy to ArC and use it to create signatures in _ClientProxy classes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9358e690449035e4aad0eebc24af8163da420687", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/9358e690449035e4aad0eebc24af8163da420687", "committedDate": "2020-08-31T13:22:25Z", "message": "Added AsmUtilCopy to ArC and use it to create signatures in _ClientProxy classes"}, "afterCommit": {"oid": "238a8b2f1a4aaaa5c2f1193dc760c90e12ac9c34", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/238a8b2f1a4aaaa5c2f1193dc760c90e12ac9c34", "committedDate": "2020-08-31T16:17:23Z", "message": "Make the Kotlin MongoDB with Panache tests pass"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3016d33c61cc6d95b5ffc77299f30db022f51fc8", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/3016d33c61cc6d95b5ffc77299f30db022f51fc8", "committedDate": "2020-09-01T08:05:36Z", "message": "Factored all visitParameter into AsmUtil to better avoid missing parameter names"}, "afterCommit": {"oid": "3ca542415b5b339ac02b6449c72078aaa1c9523a", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/3ca542415b5b339ac02b6449c72078aaa1c9523a", "committedDate": "2020-09-01T08:13:45Z", "message": "Factored all visitParameter into AsmUtil to better avoid missing parameter names"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3ca542415b5b339ac02b6449c72078aaa1c9523a", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/3ca542415b5b339ac02b6449c72078aaa1c9523a", "committedDate": "2020-09-01T08:13:45Z", "message": "Factored all visitParameter into AsmUtil to better avoid missing parameter names"}, "afterCommit": {"oid": "a8a19fcafdeebf4f899a5413023abb35e4330ea5", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/a8a19fcafdeebf4f899a5413023abb35e4330ea5", "committedDate": "2020-09-01T09:55:31Z", "message": "Factored all visitParameter into AsmUtil to better avoid missing parameter names"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a8a19fcafdeebf4f899a5413023abb35e4330ea5", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/a8a19fcafdeebf4f899a5413023abb35e4330ea5", "committedDate": "2020-09-01T09:55:31Z", "message": "Factored all visitParameter into AsmUtil to better avoid missing parameter names"}, "afterCommit": {"oid": "c805c9b1d6274646cf119275e105a5acdda63afe", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/c805c9b1d6274646cf119275e105a5acdda63afe", "committedDate": "2020-09-02T08:22:38Z", "message": "Factored all visitParameter into AsmUtil to better avoid missing parameter names"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f6371d5523f93e9e1865d13b9d19e7a82a2a23b", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/1f6371d5523f93e9e1865d13b9d19e7a82a2a23b", "committedDate": "2020-09-15T14:52:20Z", "message": "Panache Reactive"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cec9f2fed05e73f473f789e03709d9a5b3d2ef2", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/5cec9f2fed05e73f473f789e03709d9a5b3d2ef2", "committedDate": "2020-09-15T14:52:20Z", "message": "HR: conditionally add the producers\n\nTo make sure we don't add producers that depend on something that ORM didn't add"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b0a48ab919dead81036ba1b6bf741b22c13da43", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/6b0a48ab919dead81036ba1b6bf741b22c13da43", "committedDate": "2020-09-15T14:52:20Z", "message": "junit5-mockito: support mocking Mutiny method default values"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60221f52d57fd731c5ec5c636e563134509baec6", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/60221f52d57fd731c5ec5c636e563134509baec6", "committedDate": "2020-09-15T14:52:20Z", "message": "junit5-mockito: Do not mock the proxy classes but rather their superclass"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f33134cd837a76d7ec55e82fcdd18103c14c49cd", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/f33134cd837a76d7ec55e82fcdd18103c14c49cd", "committedDate": "2020-09-15T14:52:20Z", "message": "PanacheMock: made synchronized"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52fb6851e4b4a53385eb3b6cb6eea03cbde9b6e5", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/52fb6851e4b4a53385eb3b6cb6eea03cbde9b6e5", "committedDate": "2020-09-15T14:52:20Z", "message": "Fixed AlphaObserver test by making the mocked method public\n\nMockito doesn't know how to mock package-private methods. This only\nworks if we're mocking the ClientProxy class instead of the real bean\nclass."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "daafa61cc70224f7c2987583802ab96e69c29932", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/daafa61cc70224f7c2987583802ab96e69c29932", "committedDate": "2020-09-15T14:52:20Z", "message": "Added AsmUtilCopy to ArC and use it to create signatures in _ClientProxy classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3834ed76ffa4dc62883ee8fdd6d9b3ddfa200c1", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/a3834ed76ffa4dc62883ee8fdd6d9b3ddfa200c1", "committedDate": "2020-09-15T14:52:20Z", "message": "Make the Kotlin MongoDB with Panache tests pass"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74d8b7161710321176695e5d2733dbe2b96403d1", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/74d8b7161710321176695e5d2733dbe2b96403d1", "committedDate": "2020-09-15T14:52:20Z", "message": "Factored all visitParameter into AsmUtil to better avoid missing parameter names"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c805c9b1d6274646cf119275e105a5acdda63afe", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/c805c9b1d6274646cf119275e105a5acdda63afe", "committedDate": "2020-09-02T08:22:38Z", "message": "Factored all visitParameter into AsmUtil to better avoid missing parameter names"}, "afterCommit": {"oid": "74d8b7161710321176695e5d2733dbe2b96403d1", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/74d8b7161710321176695e5d2733dbe2b96403d1", "committedDate": "2020-09-15T14:52:20Z", "message": "Factored all visitParameter into AsmUtil to better avoid missing parameter names"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1163, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}