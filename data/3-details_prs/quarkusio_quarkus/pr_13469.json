{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3NDY1NTky", "number": 13469, "title": "Added HTTP and Web Socket reactive messaging connector", "bodyText": "fixes #3044", "createdAt": "2020-11-25T14:01:09Z", "url": "https://github.com/quarkusio/quarkus/pull/13469", "merged": true, "mergeCommit": {"oid": "344a1bde05a57a8d670c05950c21b4b38cf7abf8"}, "closed": true, "closedAt": "2020-12-03T16:58:44Z", "author": {"login": "michalszynkiewicz"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdf_GsUgBqjQwMzgzMTU4NjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdimKevAFqTU0NDE3NzE3Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2ec999cf956fe989311507f9a4957f4a9c8c95b5", "author": {"user": {"login": "michalszynkiewicz", "name": "Micha\u0142 Szynkiewicz"}}, "url": "https://github.com/quarkusio/quarkus/commit/2ec999cf956fe989311507f9a4957f4a9c8c95b5", "committedDate": "2020-11-25T13:57:59Z", "message": "Added HTTP and Web Socket reactive messaging connector\n\nfixes #3044"}, "afterCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "author": {"user": {"login": "michalszynkiewicz", "name": "Micha\u0142 Szynkiewicz"}}, "url": "https://github.com/quarkusio/quarkus/commit/58f1366e7cd7b7f98d0d29d579df8c27b71d56d7", "committedDate": "2020-11-25T14:19:04Z", "message": "Added HTTP and Web Socket reactive messaging connector\n\nfixes #3044"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4NjEzNzE4", "url": "https://github.com/quarkusio/quarkus/pull/13469#pullrequestreview-538613718", "createdAt": "2020-11-25T15:29:33Z", "commit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNToyOTozM1rOH54n9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjowNzoyOVrOH56U2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ1ODYxMg==", "bodyText": "You may want to enable the annotation processor from SmallRye Reactive Messaging to generate the config class and the documentation based on the attribute.", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530458612", "createdAt": "2020-11-25T15:29:33Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-messaging-http/deployment/pom.xml", "diffHunk": "@@ -0,0 +1,92 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-reactive-messaging-http-parent</artifactId>\n+    <version>999-SNAPSHOT</version>\n+  </parent>\n+\n+  <artifactId>quarkus-reactive-messaging-http-deployment</artifactId>\n+  <name>Quarkus - SmallRye Reactive Messaging - Http and Web Sockets - Deployment</name>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-core-deployment</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-smallrye-reactive-messaging-deployment</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-reactive-messaging-http</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-vertx-web-deployment</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-junit5-internal</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.assertj</groupId>\n+      <artifactId>assertj-core</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.rest-assured</groupId>\n+      <artifactId>rest-assured</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.awaitility</groupId>\n+      <artifactId>awaitility</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-undertow-websockets</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-resteasy-deployment</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+  </dependencies>\n+\n+  <build>\n+    <plugins>\n+      <plugin>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <configuration>\n+          <systemProperties>\n+            <java.util.logging.manager>org.jboss.logmanager.LogManager</java.util.logging.manager>\n+          </systemProperties>\n+        </configuration>\n+      </plugin>\n+      <plugin>\n+        <artifactId>maven-compiler-plugin</artifactId>\n+        <configuration>\n+          <annotationProcessorPaths>\n+            <path>\n+              <groupId>io.quarkus</groupId>\n+              <artifactId>quarkus-extension-processor</artifactId>\n+              <version>${project.version}</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2MDQ5Mg==", "bodyText": "If we find a way to use the annotation processor, this won't be used anymore.", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530460492", "createdAt": "2020-11-25T15:32:06Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/QuarkusWebSocketConnector.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import static io.quarkus.reactivemessaging.http.runtime.QuarkusWebSocketConnector.DEFAULT_JITTER;\n+import static io.smallrye.reactive.messaging.annotations.ConnectorAttribute.Direction.INCOMING;\n+import static io.smallrye.reactive.messaging.annotations.ConnectorAttribute.Direction.OUTGOING;\n+\n+import java.net.URI;\n+import java.time.Duration;\n+import java.util.Optional;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.spi.Connector;\n+import org.eclipse.microprofile.reactive.messaging.spi.IncomingConnectorFactory;\n+import org.eclipse.microprofile.reactive.messaging.spi.OutgoingConnectorFactory;\n+import org.eclipse.microprofile.reactive.streams.operators.PublisherBuilder;\n+import org.eclipse.microprofile.reactive.streams.operators.ReactiveStreams;\n+import org.eclipse.microprofile.reactive.streams.operators.SubscriberBuilder;\n+\n+import io.quarkus.reactivemessaging.http.runtime.serializers.SerializerFactoryBase;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.reactive.messaging.annotations.ConnectorAttribute;\n+import io.vertx.core.Vertx;\n+\n+/**\n+ * Quarkus-specific reactive messaging connector for web sockets\n+ */\n+@Connector(QuarkusWebSocketConnector.NAME)\n+\n+@ConnectorAttribute(name = \"url\", type = \"string\", direction = OUTGOING, description = \"The target URL\", mandatory = true)\n+@ConnectorAttribute(name = \"serializer\", type = \"string\", direction = OUTGOING, description = \"Message serializer\")\n+@ConnectorAttribute(name = \"maxRetries\", type = \"int\", direction = OUTGOING, description = \"The number of retries to make for sending a message to a remote websocket endpoint. A value greater than 0 is advised. Otherwise, a web socket timeout can result in a dropped message\", defaultValue = QuarkusWebSocketConnector.DEFAULT_MAX_ATTEMPTS_STR)\n+@ConnectorAttribute(name = \"jitter\", type = \"string\", direction = OUTGOING, description = \"Configures the random factor when using back-off with maxAttempts > 1\")\n+@ConnectorAttribute(name = \"delay\", type = \"string\", direction = OUTGOING, description = \"Configures a back-off delay between attempts to send a request. A random factor (jitter) is applied to increase the delay when several failures happen.\", defaultValue = DEFAULT_JITTER)\n+\n+@ConnectorAttribute(name = \"path\", type = \"string\", direction = INCOMING, description = \"The path of the endpoint\", mandatory = true)\n+@ConnectorAttribute(name = \"buffer-size\", type = \"string\", direction = INCOMING, description = \"Web socket endpoint buffers messages if a consumer is not able to keep up. This setting specifies the size of the buffer.\", defaultValue = QuarkusHttpConnector.DEFAULT_SOURCE_BUFFER_STR)\n+@ApplicationScoped\n+public class QuarkusWebSocketConnector implements IncomingConnectorFactory, OutgoingConnectorFactory {\n+    public static final String NAME = \"quarkus-websocket\";\n+\n+    static final String DEFAULT_JITTER = \"0.5\";\n+    static final String DEFAULT_MAX_ATTEMPTS_STR = \"1\";\n+    static final Integer DEFAULT_MAX_ATTEMPTS = Integer.valueOf(DEFAULT_MAX_ATTEMPTS_STR);\n+\n+    static final String DEFAULT_SOURCE_BUFFER_STR = \"8\";\n+\n+    public static final Integer DEFAULT_SOURCE_BUFFER = Integer.valueOf(DEFAULT_SOURCE_BUFFER_STR);\n+\n+    @Inject\n+    ReactiveWebSocketHandlerBean handlerBean;\n+\n+    @Inject\n+    SerializerFactoryBase serializerFactory;\n+\n+    @Inject\n+    Vertx vertx;\n+\n+    @Override\n+    public PublisherBuilder<WebSocketMessage<?>> getPublisherBuilder(Config config) {\n+        String path = getRequiredAttribute(config, \"path\", String.class);\n+\n+        Multi<WebSocketMessage<?>> processor = handlerBean.getProcessor(path);\n+        return ReactiveStreams.fromPublisher(processor);\n+    }\n+\n+    @Override\n+    public SubscriberBuilder<? extends Message<?>, Void> getSubscriberBuilder(Config config) {\n+        String serializer = config.getOptionalValue(\"serializer\", String.class).orElse(null);\n+        Optional<Duration> delay = config.getOptionalValue(\"delay\", Duration.class);\n+        String jitterAsString = config.getOptionalValue(\"jitter\", String.class).orElse(DEFAULT_JITTER);\n+        Integer maxRetries = config.getOptionalValue(\"maxRetries\", Integer.class).orElse(DEFAULT_MAX_ATTEMPTS);\n+        URI url = getRequiredAttribute(config, \"url\", URI.class);\n+\n+        double jitter;\n+        try {\n+            jitter = Double.valueOf(jitterAsString);\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"Failed to parse jitter value '\" + jitterAsString + \"' to a double.\");\n+        }\n+\n+        return new WebSocketSink(vertx, url, serializer, serializerFactory, maxRetries, delay, jitter).sink();\n+    }\n+\n+    private <T> T getRequiredAttribute(Config config, String attributeName, Class<T> type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2MTI2MQ==", "bodyText": "Maybe wrap that call in a try catch and on exception to rc.fail(exception)", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530461261", "createdAt": "2020-11-25T15:33:13Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/ReactiveHttpHandler.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+class ReactiveHttpHandler implements Handler<RoutingContext> {\n+    private final ReactiveHttpHandlerBean handler;\n+\n+    ReactiveHttpHandler(ReactiveHttpHandlerBean handler) {\n+        this.handler = handler;\n+    }\n+\n+    @Override\n+    public void handle(RoutingContext event) {\n+        handler.handle(event);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2NTc0Mw==", "bodyText": "you have an extra space in the end message.", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530465743", "createdAt": "2020-11-25T15:39:36Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/ReactiveHttpHandlerBean.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.reactivemessaging.http.runtime.config.HttpStreamConfig;\n+import io.quarkus.reactivemessaging.http.runtime.config.ReactiveHttpConfig;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.subscription.BackPressureStrategy;\n+import io.smallrye.mutiny.subscription.MultiEmitter;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * a bean that handles incoming http requests\n+ */\n+@Singleton\n+public class ReactiveHttpHandlerBean {\n+\n+    private static final Logger log = Logger.getLogger(ReactiveHttpHandlerBean.class);\n+\n+    @Inject\n+    ReactiveHttpConfig config;\n+\n+    private final Map<String, Bundle<HttpMessage<?>>> httpProcessors = new HashMap<>();\n+\n+    @PostConstruct\n+    void init() {\n+        config.getHttpConfigs()\n+                .forEach(this::addHttpProcessor);\n+    }\n+\n+    void handle(RoutingContext event) {\n+        String path = event.normalisedPath();\n+        HttpMethod method = event.request().method();\n+        String key = key(path, method);\n+        Bundle<HttpMessage<?>> httpProcessorBundle = httpProcessors.get(key);\n+        if (httpProcessorBundle != null) {\n+            MultiEmitter<? super HttpMessage<?>> emitter = httpProcessorBundle.emitter;\n+            StrictQueueSizeGuard guard = httpProcessorBundle.guard;\n+            if (guard.prepareToEmit()) {\n+                try {\n+                    HttpMessage<Buffer> message = new HttpMessage<>(event.getBody(), new IncomingHttpMetadata(event.request()),\n+                            () -> event.response().setStatusCode(202).end(),\n+                            error -> {\n+                                log.error(\"Failed to process message.\", error);\n+                                event.response().setStatusCode(500).end(\"Failed to process \");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2NzgzNQ==", "bodyText": "I'm not totally sure why you don't use the built-in back-pressure support.\nYou could just do:\nif (emitter.requested() > 0) {\n x = ...\n emitter.emit(x);\n} else {\n  event.response().setStatusCode(500).end();\n}", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530467835", "createdAt": "2020-11-25T15:42:30Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/ReactiveHttpHandlerBean.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.reactivemessaging.http.runtime.config.HttpStreamConfig;\n+import io.quarkus.reactivemessaging.http.runtime.config.ReactiveHttpConfig;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.subscription.BackPressureStrategy;\n+import io.smallrye.mutiny.subscription.MultiEmitter;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * a bean that handles incoming http requests\n+ */\n+@Singleton\n+public class ReactiveHttpHandlerBean {\n+\n+    private static final Logger log = Logger.getLogger(ReactiveHttpHandlerBean.class);\n+\n+    @Inject\n+    ReactiveHttpConfig config;\n+\n+    private final Map<String, Bundle<HttpMessage<?>>> httpProcessors = new HashMap<>();\n+\n+    @PostConstruct\n+    void init() {\n+        config.getHttpConfigs()\n+                .forEach(this::addHttpProcessor);\n+    }\n+\n+    void handle(RoutingContext event) {\n+        String path = event.normalisedPath();\n+        HttpMethod method = event.request().method();\n+        String key = key(path, method);\n+        Bundle<HttpMessage<?>> httpProcessorBundle = httpProcessors.get(key);\n+        if (httpProcessorBundle != null) {\n+            MultiEmitter<? super HttpMessage<?>> emitter = httpProcessorBundle.emitter;\n+            StrictQueueSizeGuard guard = httpProcessorBundle.guard;\n+            if (guard.prepareToEmit()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2OTA2MQ==", "bodyText": "What about 429 or 503?", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530469061", "createdAt": "2020-11-25T15:44:06Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/ReactiveHttpHandlerBean.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.reactivemessaging.http.runtime.config.HttpStreamConfig;\n+import io.quarkus.reactivemessaging.http.runtime.config.ReactiveHttpConfig;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.subscription.BackPressureStrategy;\n+import io.smallrye.mutiny.subscription.MultiEmitter;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * a bean that handles incoming http requests\n+ */\n+@Singleton\n+public class ReactiveHttpHandlerBean {\n+\n+    private static final Logger log = Logger.getLogger(ReactiveHttpHandlerBean.class);\n+\n+    @Inject\n+    ReactiveHttpConfig config;\n+\n+    private final Map<String, Bundle<HttpMessage<?>>> httpProcessors = new HashMap<>();\n+\n+    @PostConstruct\n+    void init() {\n+        config.getHttpConfigs()\n+                .forEach(this::addHttpProcessor);\n+    }\n+\n+    void handle(RoutingContext event) {\n+        String path = event.normalisedPath();\n+        HttpMethod method = event.request().method();\n+        String key = key(path, method);\n+        Bundle<HttpMessage<?>> httpProcessorBundle = httpProcessors.get(key);\n+        if (httpProcessorBundle != null) {\n+            MultiEmitter<? super HttpMessage<?>> emitter = httpProcessorBundle.emitter;\n+            StrictQueueSizeGuard guard = httpProcessorBundle.guard;\n+            if (guard.prepareToEmit()) {\n+                try {\n+                    HttpMessage<Buffer> message = new HttpMessage<>(event.getBody(), new IncomingHttpMetadata(event.request()),\n+                            () -> event.response().setStatusCode(202).end(),\n+                            error -> {\n+                                log.error(\"Failed to process message.\", error);\n+                                event.response().setStatusCode(500).end(\"Failed to process \");\n+                            });\n+                    emitter.emit(message);\n+                } catch (Exception any) {\n+                    guard.dequeue();\n+\n+                    log.error(\"Emitting message failed\", any);\n+                    event.response().setStatusCode(500).end();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2OTM5OA==", "bodyText": "Probably indicate that it's lacking of downstream requests.", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530469398", "createdAt": "2020-11-25T15:44:35Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/ReactiveHttpHandlerBean.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.reactivemessaging.http.runtime.config.HttpStreamConfig;\n+import io.quarkus.reactivemessaging.http.runtime.config.ReactiveHttpConfig;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.subscription.BackPressureStrategy;\n+import io.smallrye.mutiny.subscription.MultiEmitter;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * a bean that handles incoming http requests\n+ */\n+@Singleton\n+public class ReactiveHttpHandlerBean {\n+\n+    private static final Logger log = Logger.getLogger(ReactiveHttpHandlerBean.class);\n+\n+    @Inject\n+    ReactiveHttpConfig config;\n+\n+    private final Map<String, Bundle<HttpMessage<?>>> httpProcessors = new HashMap<>();\n+\n+    @PostConstruct\n+    void init() {\n+        config.getHttpConfigs()\n+                .forEach(this::addHttpProcessor);\n+    }\n+\n+    void handle(RoutingContext event) {\n+        String path = event.normalisedPath();\n+        HttpMethod method = event.request().method();\n+        String key = key(path, method);\n+        Bundle<HttpMessage<?>> httpProcessorBundle = httpProcessors.get(key);\n+        if (httpProcessorBundle != null) {\n+            MultiEmitter<? super HttpMessage<?>> emitter = httpProcessorBundle.emitter;\n+            StrictQueueSizeGuard guard = httpProcessorBundle.guard;\n+            if (guard.prepareToEmit()) {\n+                try {\n+                    HttpMessage<Buffer> message = new HttpMessage<>(event.getBody(), new IncomingHttpMetadata(event.request()),\n+                            () -> event.response().setStatusCode(202).end(),\n+                            error -> {\n+                                log.error(\"Failed to process message.\", error);\n+                                event.response().setStatusCode(500).end(\"Failed to process \");\n+                            });\n+                    emitter.emit(message);\n+                } catch (Exception any) {\n+                    guard.dequeue();\n+\n+                    log.error(\"Emitting message failed\", any);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ2OTc5MQ==", "bodyText": "I would keep the message empty. 404 is explicit.", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530469791", "createdAt": "2020-11-25T15:45:09Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/ReactiveHttpHandlerBean.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.reactivemessaging.http.runtime.config.HttpStreamConfig;\n+import io.quarkus.reactivemessaging.http.runtime.config.ReactiveHttpConfig;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.subscription.BackPressureStrategy;\n+import io.smallrye.mutiny.subscription.MultiEmitter;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * a bean that handles incoming http requests\n+ */\n+@Singleton\n+public class ReactiveHttpHandlerBean {\n+\n+    private static final Logger log = Logger.getLogger(ReactiveHttpHandlerBean.class);\n+\n+    @Inject\n+    ReactiveHttpConfig config;\n+\n+    private final Map<String, Bundle<HttpMessage<?>>> httpProcessors = new HashMap<>();\n+\n+    @PostConstruct\n+    void init() {\n+        config.getHttpConfigs()\n+                .forEach(this::addHttpProcessor);\n+    }\n+\n+    void handle(RoutingContext event) {\n+        String path = event.normalisedPath();\n+        HttpMethod method = event.request().method();\n+        String key = key(path, method);\n+        Bundle<HttpMessage<?>> httpProcessorBundle = httpProcessors.get(key);\n+        if (httpProcessorBundle != null) {\n+            MultiEmitter<? super HttpMessage<?>> emitter = httpProcessorBundle.emitter;\n+            StrictQueueSizeGuard guard = httpProcessorBundle.guard;\n+            if (guard.prepareToEmit()) {\n+                try {\n+                    HttpMessage<Buffer> message = new HttpMessage<>(event.getBody(), new IncomingHttpMetadata(event.request()),\n+                            () -> event.response().setStatusCode(202).end(),\n+                            error -> {\n+                                log.error(\"Failed to process message.\", error);\n+                                event.response().setStatusCode(500).end(\"Failed to process \");\n+                            });\n+                    emitter.emit(message);\n+                } catch (Exception any) {\n+                    guard.dequeue();\n+\n+                    log.error(\"Emitting message failed\", any);\n+                    event.response().setStatusCode(500).end();\n+                }\n+            } else {\n+                event.response().setStatusCode(503).end();\n+            }\n+        } else {\n+            event.response().setStatusCode(404).end(\"No http consumer for the given path and method\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3MDc5OA==", "bodyText": "@jponge We don't have a variant that accepts the buffer size here (in the emitter method). As we added it to onOVerflow we may want to add it here too.", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530470798", "createdAt": "2020-11-25T15:46:28Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/ReactiveHttpHandlerBean.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.reactivemessaging.http.runtime.config.HttpStreamConfig;\n+import io.quarkus.reactivemessaging.http.runtime.config.ReactiveHttpConfig;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.subscription.BackPressureStrategy;\n+import io.smallrye.mutiny.subscription.MultiEmitter;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * a bean that handles incoming http requests\n+ */\n+@Singleton\n+public class ReactiveHttpHandlerBean {\n+\n+    private static final Logger log = Logger.getLogger(ReactiveHttpHandlerBean.class);\n+\n+    @Inject\n+    ReactiveHttpConfig config;\n+\n+    private final Map<String, Bundle<HttpMessage<?>>> httpProcessors = new HashMap<>();\n+\n+    @PostConstruct\n+    void init() {\n+        config.getHttpConfigs()\n+                .forEach(this::addHttpProcessor);\n+    }\n+\n+    void handle(RoutingContext event) {\n+        String path = event.normalisedPath();\n+        HttpMethod method = event.request().method();\n+        String key = key(path, method);\n+        Bundle<HttpMessage<?>> httpProcessorBundle = httpProcessors.get(key);\n+        if (httpProcessorBundle != null) {\n+            MultiEmitter<? super HttpMessage<?>> emitter = httpProcessorBundle.emitter;\n+            StrictQueueSizeGuard guard = httpProcessorBundle.guard;\n+            if (guard.prepareToEmit()) {\n+                try {\n+                    HttpMessage<Buffer> message = new HttpMessage<>(event.getBody(), new IncomingHttpMetadata(event.request()),\n+                            () -> event.response().setStatusCode(202).end(),\n+                            error -> {\n+                                log.error(\"Failed to process message.\", error);\n+                                event.response().setStatusCode(500).end(\"Failed to process \");\n+                            });\n+                    emitter.emit(message);\n+                } catch (Exception any) {\n+                    guard.dequeue();\n+\n+                    log.error(\"Emitting message failed\", any);\n+                    event.response().setStatusCode(500).end();\n+                }\n+            } else {\n+                event.response().setStatusCode(503).end();\n+            }\n+        } else {\n+            event.response().setStatusCode(404).end(\"No http consumer for the given path and method\");\n+        }\n+    }\n+\n+    private void addHttpProcessor(HttpStreamConfig streamConfig) {\n+        String key = key(streamConfig.path, streamConfig.method);\n+\n+        // emitter with an unbounded queue, we control the size ourselves, with the guard\n+        StrictQueueSizeGuard guard = new StrictQueueSizeGuard(streamConfig.bufferSize);\n+        Bundle<HttpMessage<?>> bundle = new Bundle<>(guard);\n+        Multi<HttpMessage<?>> processor = Multi.createFrom()\n+                .<HttpMessage<?>> emitter(bundle::setEmitter, BackPressureStrategy.BUFFER).onItem().invoke(guard::dequeue);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3Mjg5Mg==", "bodyText": "I believe there is a build item to request the body handler.", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530472892", "createdAt": "2020-11-25T15:49:17Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/ReactiveHttpRecorder.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.runtime.annotations.Recorder;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+import io.vertx.ext.web.handler.BodyHandler;\n+\n+@Recorder\n+public class ReactiveHttpRecorder {\n+\n+    public Handler<RoutingContext> createWebSocketeHandler() {\n+        ReactiveWebSocketHandlerBean bean = Arc.container().instance(ReactiveWebSocketHandlerBean.class).get();\n+        return new ReactiveWebSocketHandler(bean);\n+    }\n+\n+    public Handler<RoutingContext> createHttpHandler() {\n+        ReactiveHttpHandlerBean bean = Arc.container().instance(ReactiveHttpHandlerBean.class).get();\n+        return new ReactiveHttpHandler(bean);\n+    }\n+\n+    public Handler<RoutingContext> createBodyHandler() {\n+        return BodyHandler.create();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3NDQwNg==", "bodyText": "I would just close the web socket and indicate a processing failure.\nAnother approach could be to use a JSON payload wrapping the failure like https://github.com/zalando/problem", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530474406", "createdAt": "2020-11-25T15:51:13Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/ReactiveWebSocketHandlerBean.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.reactivemessaging.http.runtime.config.ReactiveHttpConfig;\n+import io.quarkus.reactivemessaging.http.runtime.config.WebSocketStreamConfig;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.subscription.BackPressureStrategy;\n+import io.smallrye.mutiny.subscription.MultiEmitter;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.ServerWebSocket;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * a bean that handles incoming web socket messages\n+ */\n+@Singleton\n+public class ReactiveWebSocketHandlerBean {\n+\n+    private static final Logger log = Logger.getLogger(ReactiveWebSocketHandlerBean.class);\n+\n+    @Inject\n+    ReactiveHttpConfig config;\n+\n+    private final Map<String, Bundle<WebSocketMessage<?>>> websocketProcessors = new HashMap<>();\n+\n+    @PostConstruct\n+    void init() {\n+        config.getWebSocketConfigs()\n+                .forEach(this::addWebSocketProcessor);\n+    }\n+\n+    void handle(RoutingContext event) {\n+        String path = event.normalisedPath();\n+        Bundle<WebSocketMessage<?>> bundle = websocketProcessors.get(path);\n+        if (bundle != null) {\n+            MultiEmitter<? super WebSocketMessage<?>> emitter = bundle.emitter;\n+            StrictQueueSizeGuard guard = bundle.guard;\n+            event.request().toWebSocket(\n+                    websocket -> {\n+                        if (websocket.failed()) {\n+                            log.error(\"failed to connect websocket\", websocket.cause());\n+                        } else {\n+                            ServerWebSocket serverWebSocket = websocket.result();\n+                            serverWebSocket.handler(\n+                                    b -> {\n+                                        if (guard.prepareToEmit()) {\n+                                            try {\n+                                                emitter.emit(new WebSocketMessage<>(b,\n+                                                        () -> serverWebSocket.write(Buffer.buffer(\"ACK\")),\n+                                                        error -> {\n+                                                            log.error(\"Failed to process message.\", error);\n+                                                            // TODO some error message for the client? exception mapper would be best...\n+                                                            serverWebSocket.write(Buffer.buffer(\"Failed to process message\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3NDkyNw==", "bodyText": "There is a lot of duplicated code with the HTTP variant. We should have a look to try to reuse some code.", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530474927", "createdAt": "2020-11-25T15:51:58Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/ReactiveWebSocketHandlerBean.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.annotation.PostConstruct;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.reactivemessaging.http.runtime.config.ReactiveHttpConfig;\n+import io.quarkus.reactivemessaging.http.runtime.config.WebSocketStreamConfig;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.subscription.BackPressureStrategy;\n+import io.smallrye.mutiny.subscription.MultiEmitter;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.ServerWebSocket;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * a bean that handles incoming web socket messages\n+ */\n+@Singleton\n+public class ReactiveWebSocketHandlerBean {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3NjU1Nw==", "bodyText": "Don't use runAsync here.\nThe handler is async, so just to:\n() -> {\n  successHandler.run();\n  return CompletableFuture.completed(null); // or something like this\n}\n\nThis also applies to the nack.", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530476557", "createdAt": "2020-11-25T15:54:10Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/WebSocketMessage.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+\n+class WebSocketMessage<PayloadType> implements Message<PayloadType> {\n+\n+    private final PayloadType payload;\n+    private final Runnable successHandler;\n+    private final Consumer<Throwable> failureHandler;\n+\n+    WebSocketMessage(PayloadType payload, Runnable successHandler, Consumer<Throwable> failureHandler) {\n+        this.payload = payload;\n+        this.successHandler = successHandler;\n+        this.failureHandler = failureHandler;\n+    }\n+\n+    @Override\n+    public PayloadType getPayload() {\n+        return payload;\n+    }\n+\n+    @Override\n+    public Supplier<CompletionStage<Void>> getAck() {\n+        return () -> CompletableFuture.runAsync(successHandler);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3OTIxMw==", "bodyText": "Any reason to not use the mutiny API all way long?\nThe switches between the bare and mutiny API are a bit convoluted.", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530479213", "createdAt": "2020-11-25T15:57:25Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/WebSocketSink.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import static java.util.Arrays.asList;\n+\n+import java.net.URI;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.streams.operators.ReactiveStreams;\n+import org.eclipse.microprofile.reactive.streams.operators.SubscriberBuilder;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.reactivemessaging.http.runtime.serializers.Serializer;\n+import io.quarkus.reactivemessaging.http.runtime.serializers.SerializerFactoryBase;\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.mutiny.groups.UniRetry;\n+import io.smallrye.mutiny.vertx.AsyncResultUni;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpClient;\n+import io.vertx.core.http.WebSocket;\n+import io.vertx.core.http.WebSocketConnectOptions;\n+\n+class WebSocketSink {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4MDk4Mw==", "bodyText": "Wondering if we should not have these converters directly in Reactive Messaging.\nDefinitely useful!", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530480983", "createdAt": "2020-11-25T15:59:41Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/converters/ObjectConverter.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package io.quarkus.reactivemessaging.http.runtime.converters;\n+\n+import java.lang.reflect.Type;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+\n+import io.smallrye.reactive.messaging.MessageConverter;\n+import io.vertx.core.buffer.Buffer;\n+\n+/**\n+ * Converts message payload to objects of specified class.\n+ *\n+ * Used as the last converter\n+ */\n+@ApplicationScoped\n+public class ObjectConverter implements MessageConverter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4MjYyNA==", "bodyText": "Dto? Not a Person, Pet, or Pokemon object?\nYou're making tests boring :-D", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530482624", "createdAt": "2020-11-25T16:01:54Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-messaging-http/deployment/src/test/java/io/quarkus/reactivemessaging/http/sink/app/Dto.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package io.quarkus.reactivemessaging.http.sink.app;\n+\n+public class Dto {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4MzQ4Nw==", "bodyText": "Any reason to not use plain payloads here?\nString passThroughWithCustomSerializer(Buffer payload) {\nreturn payload.toString();\n}", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530483487", "createdAt": "2020-11-25T16:03:12Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-messaging-http/deployment/src/test/java/io/quarkus/reactivemessaging/http/sink/app/HttpEmitter.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package io.quarkus.reactivemessaging.http.sink.app;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Supplier;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.eclipse.microprofile.reactive.messaging.Channel;\n+import org.eclipse.microprofile.reactive.messaging.Emitter;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import io.vertx.core.buffer.Buffer;\n+\n+@ApplicationScoped\n+public class HttpEmitter {\n+\n+    @Channel(\"my-http-sink\")\n+    Emitter<Object> emitter;\n+\n+    @Channel(\"http-sink-with-path-param\")\n+    Emitter<Object> emitterWithPathParam;\n+\n+    @Channel(\"retrying-http-sink\")\n+    Emitter<Object> retryingEmitter;\n+\n+    @Incoming(\"custom-http-source\")\n+    @Outgoing(\"custom-http-sink\")\n+    Message<String> passThroughWithCustomSerializer(Message<Buffer> message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4NDk1NQ==", "bodyText": "You should remove the traces", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530484955", "createdAt": "2020-11-25T16:05:16Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-messaging-http/deployment/src/test/java/io/quarkus/reactivemessaging/websocket/sink/WebSocketSinkTest.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package io.quarkus.reactivemessaging.websocket.sink;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.await;\n+import static org.hamcrest.Matchers.hasSize;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import io.quarkus.reactivemessaging.utils.ToUpperCaseSerializer;\n+import io.quarkus.reactivemessaging.websocket.sink.app.WsEmitter;\n+import io.quarkus.reactivemessaging.websocket.sink.app.WsEndpoint;\n+import io.quarkus.test.QuarkusUnitTest;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+class WebSocketSinkTest {\n+    @RegisterExtension\n+    static final QuarkusUnitTest config = new QuarkusUnitTest()\n+            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n+                    .addClasses(WsEndpoint.class, WsEmitter.class, ToUpperCaseSerializer.class))\n+            .withConfigurationResource(\"websocket-sink-test-application.properties\");\n+\n+    @Inject\n+    WsEndpoint wsEndpoint;\n+\n+    @Inject\n+    WsEmitter emitter;\n+\n+    @Test\n+    void shouldSerializeBuffer() {\n+        System.out.println(\"buffer\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4NTU2Nw==", "bodyText": "As for web socket, don't use runAsync", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530485567", "createdAt": "2020-11-25T16:06:13Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/HttpMessage.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Metadata;\n+\n+/**\n+ * used by http source\n+ * \n+ * @param <T> payload type\n+ */\n+class HttpMessage<T> implements Message<T> {\n+\n+    private final T payload;\n+    private final Runnable successHandler;\n+    private final Consumer<Throwable> failureHandler;\n+    private final Metadata metadata;\n+\n+    HttpMessage(T payload, IncomingHttpMetadata requestMetadata, Runnable successHandler,\n+            Consumer<Throwable> failureHandler) {\n+        this.payload = payload;\n+        this.successHandler = successHandler;\n+        this.failureHandler = failureHandler;\n+        metadata = Metadata.of(requestMetadata);\n+    }\n+\n+    @Override\n+    public T getPayload() {\n+        return payload;\n+    }\n+\n+    @Override\n+    public Metadata getMetadata() {\n+        return metadata;\n+    }\n+\n+    @Override\n+    public Supplier<CompletionStage<Void>> getAck() {\n+        return () -> CompletableFuture.runAsync(successHandler);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4NTkwMA==", "bodyText": "@kenfinnigan Should we do something around Open Telemetry tracing here?", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530485900", "createdAt": "2020-11-25T16:06:41Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/HttpMessage.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Metadata;\n+\n+/**\n+ * used by http source\n+ * \n+ * @param <T> payload type\n+ */\n+class HttpMessage<T> implements Message<T> {\n+\n+    private final T payload;\n+    private final Runnable successHandler;\n+    private final Consumer<Throwable> failureHandler;\n+    private final Metadata metadata;\n+\n+    HttpMessage(T payload, IncomingHttpMetadata requestMetadata, Runnable successHandler,\n+            Consumer<Throwable> failureHandler) {\n+        this.payload = payload;\n+        this.successHandler = successHandler;\n+        this.failureHandler = failureHandler;\n+        metadata = Metadata.of(requestMetadata);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4NjQ4OA==", "bodyText": "Can you add an unwrap method returning the request directly?", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530486488", "createdAt": "2020-11-25T16:07:29Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/IncomingHttpMetadata.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpServerRequest;\n+\n+/**\n+ * Metadata for Http Source. Provides a way to get headers, method and path from a http request\n+ */\n+public class IncomingHttpMetadata {\n+\n+    private final HttpMethod method;\n+    private final MultiMap headers;\n+    private final String path;\n+\n+    IncomingHttpMetadata(HttpServerRequest request) {\n+        path = request.path();\n+        headers = request.headers();\n+        method = request.method();\n+    }\n+\n+    /**\n+     * http method of the request\n+     * \n+     * @return either POST or PUT\n+     */\n+    public HttpMethod getMethod() {\n+        return method;\n+    }\n+\n+    /**\n+     * headers of the request\n+     * \n+     * @return a MultiMap of headers\n+     */\n+    public MultiMap getHeaders() {\n+        return headers;\n+    }\n+\n+    /**\n+     * path of the request\n+     * \n+     * @return path\n+     */\n+    public String getPath() {\n+        return path;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4NjU3MzMw", "url": "https://github.com/quarkusio/quarkus/pull/13469#pullrequestreview-538657330", "createdAt": "2020-11-25T16:16:12Z", "commit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjoxNjoxM1rOH56sFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNjoxNjozNVrOH56tCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5MjQzOA==", "bodyText": "Is this dependency needed if we're depending on quarkus-smallrye-reactive-messaging?", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530492438", "createdAt": "2020-11-25T16:16:13Z", "author": {"login": "kenfinnigan"}, "path": "extensions/reactive-messaging-http/runtime/pom.xml", "diffHunk": "@@ -0,0 +1,74 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-reactive-messaging-http-parent</artifactId>\n+    <version>999-SNAPSHOT</version>\n+  </parent>\n+\n+  <artifactId>quarkus-reactive-messaging-http</artifactId>\n+  <name>Quarkus - SmallRye Reactive Messaging - HTTP - Runtime</name>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>com.fasterxml.jackson.core</groupId>\n+      <artifactId>jackson-databind</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-smallrye-reactive-messaging</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-arc</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-vertx-web</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.smallrye.reactive</groupId>\n+      <artifactId>smallrye-mutiny-vertx-web-client</artifactId>\n+    </dependency>\n+\n+    <dependency>\n+      <groupId>io.smallrye.reactive</groupId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ5MjY4MA==", "bodyText": "Ideally yes, but we don't have OpenTelemetry in Quarkus yet. It will need to wait", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530492680", "createdAt": "2020-11-25T16:16:35Z", "author": {"login": "kenfinnigan"}, "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/HttpMessage.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Metadata;\n+\n+/**\n+ * used by http source\n+ * \n+ * @param <T> payload type\n+ */\n+class HttpMessage<T> implements Message<T> {\n+\n+    private final T payload;\n+    private final Runnable successHandler;\n+    private final Consumer<Throwable> failureHandler;\n+    private final Metadata metadata;\n+\n+    HttpMessage(T payload, IncomingHttpMetadata requestMetadata, Runnable successHandler,\n+            Consumer<Throwable> failureHandler) {\n+        this.payload = payload;\n+        this.successHandler = successHandler;\n+        this.failureHandler = failureHandler;\n+        metadata = Metadata.of(requestMetadata);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ4NTkwMA=="}, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4ODMwNTIy", "url": "https://github.com/quarkusio/quarkus/pull/13469#pullrequestreview-538830522", "createdAt": "2020-11-25T20:35:29Z", "commit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMDozNToyOVrOH6DGPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMDo0MzozMFrOH6DS2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYzMDIwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              <name>Quarkus - SmallRye Reactive Messaging - Http and Web Sockets - Deployment</name>\n          \n          \n            \n              <name>Quarkus - SmallRye Reactive Messaging - HTTP and WebSockets - Deployment</name>", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530630204", "createdAt": "2020-11-25T20:35:29Z", "author": {"login": "gsmet"}, "path": "extensions/reactive-messaging-http/deployment/pom.xml", "diffHunk": "@@ -0,0 +1,92 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-reactive-messaging-http-parent</artifactId>\n+    <version>999-SNAPSHOT</version>\n+  </parent>\n+\n+  <artifactId>quarkus-reactive-messaging-http-deployment</artifactId>\n+  <name>Quarkus - SmallRye Reactive Messaging - Http and Web Sockets - Deployment</name>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYzMDU4NA==", "bodyText": "The POM files should be indented with 4 spaces. I know we are not consistent everywhere but let's try to be consistent for the new extensions.", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530630584", "createdAt": "2020-11-25T20:36:23Z", "author": {"login": "gsmet"}, "path": "extensions/reactive-messaging-http/deployment/pom.xml", "diffHunk": "@@ -0,0 +1,92 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYzMTExNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                <name>Quarkus - Reactive Messaging - Http and Web Sockets</name>\n          \n          \n            \n                <name>Quarkus - Reactive Messaging - HTTP and WebSockets</name>", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530631117", "createdAt": "2020-11-25T20:37:42Z", "author": {"login": "gsmet"}, "path": "extensions/reactive-messaging-http/pom.xml", "diffHunk": "@@ -0,0 +1,20 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <parent>\n+        <artifactId>quarkus-build-parent</artifactId>\n+        <groupId>io.quarkus</groupId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../../build-parent/pom.xml</relativePath>\n+    </parent>\n+    <modelVersion>4.0.0</modelVersion>\n+    <artifactId>quarkus-reactive-messaging-http-parent</artifactId>\n+    <name>Quarkus - Reactive Messaging - Http and Web Sockets</name>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYzMTI0NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              <name>Quarkus - SmallRye Reactive Messaging - HTTP - Runtime</name>\n          \n          \n            \n              <name>Quarkus - SmallRye Reactive Messaging - HTTP and WebSockets - Runtime</name>", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530631245", "createdAt": "2020-11-25T20:38:06Z", "author": {"login": "gsmet"}, "path": "extensions/reactive-messaging-http/runtime/pom.xml", "diffHunk": "@@ -0,0 +1,74 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-reactive-messaging-http-parent</artifactId>\n+    <version>999-SNAPSHOT</version>\n+  </parent>\n+\n+  <artifactId>quarkus-reactive-messaging-http</artifactId>\n+  <name>Quarkus - SmallRye Reactive Messaging - HTTP - Runtime</name>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYzMTYwNw==", "bodyText": "You need a description for the runtime module, it's what appears in code.quarkus.io. Try to be consistent with the rest, should start with a verb \"Connect to...\" or something similar.", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530631607", "createdAt": "2020-11-25T20:38:56Z", "author": {"login": "gsmet"}, "path": "extensions/reactive-messaging-http/runtime/pom.xml", "diffHunk": "@@ -0,0 +1,74 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-reactive-messaging-http-parent</artifactId>\n+    <version>999-SNAPSHOT</version>\n+  </parent>\n+\n+  <artifactId>quarkus-reactive-messaging-http</artifactId>\n+  <name>Quarkus - SmallRye Reactive Messaging - HTTP - Runtime</name>\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYzMjE2Ng==", "bodyText": "Is it me or you have a jackson runtime dependency in the runtime module but no corresponding deployment module here?", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530632166", "createdAt": "2020-11-25T20:40:15Z", "author": {"login": "gsmet"}, "path": "extensions/reactive-messaging-http/deployment/pom.xml", "diffHunk": "@@ -0,0 +1,92 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-reactive-messaging-http-parent</artifactId>\n+    <version>999-SNAPSHOT</version>\n+  </parent>\n+\n+  <artifactId>quarkus-reactive-messaging-http-deployment</artifactId>\n+  <name>Quarkus - SmallRye Reactive Messaging - Http and Web Sockets - Deployment</name>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-core-deployment</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-smallrye-reactive-messaging-deployment</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-reactive-messaging-http</artifactId>\n+    </dependency>\n+    <dependency>\n+      <groupId>io.quarkus</groupId>\n+      <artifactId>quarkus-vertx-web-deployment</artifactId>\n+    </dependency>\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYzMjQwOA==", "bodyText": "It should be quarkus-jackson and you should add the deployment module to the deployment POM.", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530632408", "createdAt": "2020-11-25T20:40:50Z", "author": {"login": "gsmet"}, "path": "extensions/reactive-messaging-http/runtime/pom.xml", "diffHunk": "@@ -0,0 +1,74 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-reactive-messaging-http-parent</artifactId>\n+    <version>999-SNAPSHOT</version>\n+  </parent>\n+\n+  <artifactId>quarkus-reactive-messaging-http</artifactId>\n+  <name>Quarkus - SmallRye Reactive Messaging - HTTP - Runtime</name>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>com.fasterxml.jackson.core</groupId>\n+      <artifactId>jackson-databind</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYzMzQzMg==", "bodyText": "I wouldn't use Ws. It can also mean Web Services. Same for the other classes prefixed the same way.\nI know it's test classes but it's better anyway.", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r530633432", "createdAt": "2020-11-25T20:43:30Z", "author": {"login": "gsmet"}, "path": "extensions/reactive-messaging-http/deployment/src/test/java/io/quarkus/reactivemessaging/websocket/WsClient.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package io.quarkus.reactivemessaging.websocket;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.WebSocket;\n+\n+public class WsClient {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f1366e7cd7b7f98d0d29d579df8c27b71d56d7"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5Nzg4MDc1", "url": "https://github.com/quarkusio/quarkus/pull/13469#pullrequestreview-539788075", "createdAt": "2020-11-27T08:31:54Z", "commit": {"oid": "b1561cd640ceb74b3f4d8c3c5e3edd8042be59ed"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwODozMTo1NFrOH61IXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwODozMTo1NFrOH61IXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ0OTk1MA==", "bodyText": "I'll change it to store request only", "url": "https://github.com/quarkusio/quarkus/pull/13469#discussion_r531449950", "createdAt": "2020-11-27T08:31:54Z", "author": {"login": "michalszynkiewicz"}, "path": "extensions/reactive-messaging-http/runtime/src/main/java/io/quarkus/reactivemessaging/http/runtime/IncomingHttpMetadata.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package io.quarkus.reactivemessaging.http.runtime;\n+\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpServerRequest;\n+\n+/**\n+ * Metadata for Http Source. Provides a way to get headers, method and path from a http request\n+ */\n+public class IncomingHttpMetadata {\n+\n+    private final HttpMethod method;\n+    private final MultiMap headers;\n+    private final String path;\n+    private final HttpServerRequest request;\n+\n+    IncomingHttpMetadata(HttpServerRequest request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1561cd640ceb74b3f4d8c3c5e3edd8042be59ed"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwNTMyMDIx", "url": "https://github.com/quarkusio/quarkus/pull/13469#pullrequestreview-540532021", "createdAt": "2020-11-29T22:59:25Z", "commit": {"oid": "530a88c2a28af3a2a162e60b37212611a1565ceb"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "530a88c2a28af3a2a162e60b37212611a1565ceb", "author": {"user": {"login": "michalszynkiewicz", "name": "Micha\u0142 Szynkiewicz"}}, "url": "https://github.com/quarkusio/quarkus/commit/530a88c2a28af3a2a162e60b37212611a1565ceb", "committedDate": "2020-11-27T12:24:14Z", "message": "dropped the guard"}, "afterCommit": {"oid": "79f62fc0b8d3f7a26114303195e13f8ba0af246f", "author": {"user": {"login": "michalszynkiewicz", "name": "Micha\u0142 Szynkiewicz"}}, "url": "https://github.com/quarkusio/quarkus/commit/79f62fc0b8d3f7a26114303195e13f8ba0af246f", "committedDate": "2020-11-30T21:03:46Z", "message": "Added HTTP and Web Socket reactive messaging connector\n\nfixes #3044"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "79f62fc0b8d3f7a26114303195e13f8ba0af246f", "author": {"user": {"login": "michalszynkiewicz", "name": "Micha\u0142 Szynkiewicz"}}, "url": "https://github.com/quarkusio/quarkus/commit/79f62fc0b8d3f7a26114303195e13f8ba0af246f", "committedDate": "2020-11-30T21:03:46Z", "message": "Added HTTP and Web Socket reactive messaging connector\n\nfixes #3044"}, "afterCommit": {"oid": "d04a7e159826027aeb26e0cb90c702cf993b8c67", "author": {"user": {"login": "michalszynkiewicz", "name": "Micha\u0142 Szynkiewicz"}}, "url": "https://github.com/quarkusio/quarkus/commit/d04a7e159826027aeb26e0cb90c702cf993b8c67", "committedDate": "2020-11-30T22:11:35Z", "message": "Added HTTP and Web Socket reactive messaging connector\n\nfixes #3044"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b1a98fcb8a884e3274e492e3b3359a4c714f4061", "author": {"user": {"login": "michalszynkiewicz", "name": "Micha\u0142 Szynkiewicz"}}, "url": "https://github.com/quarkusio/quarkus/commit/b1a98fcb8a884e3274e492e3b3359a4c714f4061", "committedDate": "2020-12-01T09:59:28Z", "message": "WebSocketSInkTest: wait for sessions to be closed"}, "afterCommit": {"oid": "104340a145f9b1330889c2a251be76ba0bf648f6", "author": {"user": {"login": "michalszynkiewicz", "name": "Micha\u0142 Szynkiewicz"}}, "url": "https://github.com/quarkusio/quarkus/commit/104340a145f9b1330889c2a251be76ba0bf648f6", "committedDate": "2020-12-01T12:48:08Z", "message": "Added HTTP and Web Socket reactive messaging connector\n\nfixes #3044"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "104340a145f9b1330889c2a251be76ba0bf648f6", "author": {"user": {"login": "michalszynkiewicz", "name": "Micha\u0142 Szynkiewicz"}}, "url": "https://github.com/quarkusio/quarkus/commit/104340a145f9b1330889c2a251be76ba0bf648f6", "committedDate": "2020-12-01T12:48:08Z", "message": "Added HTTP and Web Socket reactive messaging connector\n\nfixes #3044"}, "afterCommit": {"oid": "0f5d29fba275706ef9bc9bd1cb2f0c9ee707e5aa", "author": {"user": {"login": "michalszynkiewicz", "name": "Micha\u0142 Szynkiewicz"}}, "url": "https://github.com/quarkusio/quarkus/commit/0f5d29fba275706ef9bc9bd1cb2f0c9ee707e5aa", "committedDate": "2020-12-01T14:07:55Z", "message": "Added HTTP and Web Socket reactive messaging connector\n\nfixes #3044"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0f5d29fba275706ef9bc9bd1cb2f0c9ee707e5aa", "author": {"user": {"login": "michalszynkiewicz", "name": "Micha\u0142 Szynkiewicz"}}, "url": "https://github.com/quarkusio/quarkus/commit/0f5d29fba275706ef9bc9bd1cb2f0c9ee707e5aa", "committedDate": "2020-12-01T14:07:55Z", "message": "Added HTTP and Web Socket reactive messaging connector\n\nfixes #3044"}, "afterCommit": {"oid": "0cbe708183ce0e34a2455fc882d55f9fc073ef3f", "author": {"user": {"login": "michalszynkiewicz", "name": "Micha\u0142 Szynkiewicz"}}, "url": "https://github.com/quarkusio/quarkus/commit/0cbe708183ce0e34a2455fc882d55f9fc073ef3f", "committedDate": "2020-12-01T16:18:29Z", "message": "Added HTTP and Web Socket reactive messaging connector\n\nfixes #3044"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e464b6026684a8d6c527a2ddc7abc1ec40c42848", "author": {"user": {"login": "michalszynkiewicz", "name": "Micha\u0142 Szynkiewicz"}}, "url": "https://github.com/quarkusio/quarkus/commit/e464b6026684a8d6c527a2ddc7abc1ec40c42848", "committedDate": "2020-12-02T18:19:11Z", "message": "Added HTTP and Web Socket reactive messaging connector\n\nfixes #3044"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0cbe708183ce0e34a2455fc882d55f9fc073ef3f", "author": {"user": {"login": "michalszynkiewicz", "name": "Micha\u0142 Szynkiewicz"}}, "url": "https://github.com/quarkusio/quarkus/commit/0cbe708183ce0e34a2455fc882d55f9fc073ef3f", "committedDate": "2020-12-01T16:18:29Z", "message": "Added HTTP and Web Socket reactive messaging connector\n\nfixes #3044"}, "afterCommit": {"oid": "e464b6026684a8d6c527a2ddc7abc1ec40c42848", "author": {"user": {"login": "michalszynkiewicz", "name": "Micha\u0142 Szynkiewicz"}}, "url": "https://github.com/quarkusio/quarkus/commit/e464b6026684a8d6c527a2ddc7abc1ec40c42848", "committedDate": "2020-12-02T18:19:11Z", "message": "Added HTTP and Web Socket reactive messaging connector\n\nfixes #3044"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MTc3MTc3", "url": "https://github.com/quarkusio/quarkus/pull/13469#pullrequestreview-544177177", "createdAt": "2020-12-03T16:58:30Z", "commit": {"oid": "e464b6026684a8d6c527a2ddc7abc1ec40c42848"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1290, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}