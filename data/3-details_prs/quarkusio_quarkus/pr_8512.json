{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNjc2MDg4", "number": 8512, "title": "[fixes #4481] - RP-Initiated Logout and session verification", "bodyText": "", "createdAt": "2020-04-09T22:31:42Z", "url": "https://github.com/quarkusio/quarkus/pull/8512", "merged": true, "mergeCommit": {"oid": "4b4723dcf3d4f738301198d6508fe45debf28935"}, "closed": true, "closedAt": "2020-04-20T10:28:37Z", "author": {"login": "pedroigor"}, "timelineItems": {"totalCount": 57, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcWEXewgBqjMyMjAyMDIzNjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcZchqdAFqTM5NjMzMDE4MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "94cab89e6c81b283e678f75ec5ec2ffbd046e47c", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/94cab89e6c81b283e678f75ec5ec2ffbd046e47c", "committedDate": "2020-04-09T22:28:53Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/af1c474e6be13e90cb65a2156ac4588f03c7df5d", "committedDate": "2020-04-09T22:37:32Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMzc1NDY5", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391375469", "createdAt": "2020-04-10T10:23:41Z", "commit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMDoyMzo0MVrOGD29KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMDoyMzo0MVrOGD29KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5OTMwNA==", "bodyText": "@pedroigor should we have a check here that the token has expired ? At the moment the way to do is to check the exception message, Vertx reports JWT is expired or something like that. I'm going to work on a few Vertx PRs soon enough and perhaps we can introduce a dedicated exception too. I.e I'm not sure we should refresh in all the cases, only if the token has expired", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406699304", "createdAt": "2020-04-10T10:23:41Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -59,34 +70,73 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public CompletionStage<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n     public CompletionStage<SecurityIdentity> authenticate(RoutingContext context,\n             IdentityProviderManager identityProviderManager,\n             DefaultTenantConfigResolver resolver) {\n         Cookie sessionCookie = context.request().getCookie(SESSION_COOKIE_NAME);\n+        TenantConfigContext configContext = resolver.resolve(context, true);\n \n         // if session already established, try to re-authenticate\n         if (sessionCookie != null) {\n             String[] tokens = sessionCookie.getValue().split(COOKIE_DELIM);\n-            return authenticate(identityProviderManager, new IdTokenCredential(tokens[0], context))\n-                    .thenCompose(new Function<SecurityIdentity, CompletionStage<SecurityIdentity>>() {\n+            String idToken = tokens[0];\n+            String accessToken = tokens[1];\n+            String refreshToken = tokens[2];\n+\n+            return authenticate(identityProviderManager, new IdTokenCredential(idToken, context))\n+                    .handle(new BiFunction<SecurityIdentity, Throwable, SecurityIdentity>() {\n                         @Override\n-                        public CompletionStage<SecurityIdentity> apply(SecurityIdentity securityIdentity) {\n-                            return CompletableFuture\n-                                    .completedFuture(augmentIdentity(securityIdentity, tokens[1], tokens[2], context));\n+                        public SecurityIdentity apply(SecurityIdentity identity, Throwable throwable) {\n+                            if (isLogout(context, configContext)) {\n+                                // force logout, the challenge will be built accordingly and redirect to the logout endpoint at the OP\n+                                throw new AuthenticationFailedException();\n+                            }\n+\n+                            // if authentication failed, the reason could be the token no longer being valid, so we try a \n+                            // silent refresh if required\n+                            if (throwable != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "originalPosition": 95}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMzc5OTQy", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391379942", "createdAt": "2020-04-10T10:37:18Z", "commit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMDozNzoxOFrOGD3NBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMDozNzoxOFrOGD3NBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMzM2Nw==", "bodyText": "The code around here should throw AuthenticationCompletionException to prevent the redirect loops, so that the user gets 401, otherwise a challenge will be created again and the OIDC will redirect again given that a user has just authenticated, we've had these problems before :-)", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406703367", "createdAt": "2020-04-10T10:37:18Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -59,34 +70,73 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public CompletionStage<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n     public CompletionStage<SecurityIdentity> authenticate(RoutingContext context,\n             IdentityProviderManager identityProviderManager,\n             DefaultTenantConfigResolver resolver) {\n         Cookie sessionCookie = context.request().getCookie(SESSION_COOKIE_NAME);\n+        TenantConfigContext configContext = resolver.resolve(context, true);\n \n         // if session already established, try to re-authenticate\n         if (sessionCookie != null) {\n             String[] tokens = sessionCookie.getValue().split(COOKIE_DELIM);\n-            return authenticate(identityProviderManager, new IdTokenCredential(tokens[0], context))\n-                    .thenCompose(new Function<SecurityIdentity, CompletionStage<SecurityIdentity>>() {\n+            String idToken = tokens[0];\n+            String accessToken = tokens[1];\n+            String refreshToken = tokens[2];\n+\n+            return authenticate(identityProviderManager, new IdTokenCredential(idToken, context))\n+                    .handle(new BiFunction<SecurityIdentity, Throwable, SecurityIdentity>() {\n                         @Override\n-                        public CompletionStage<SecurityIdentity> apply(SecurityIdentity securityIdentity) {\n-                            return CompletableFuture\n-                                    .completedFuture(augmentIdentity(securityIdentity, tokens[1], tokens[2], context));\n+                        public SecurityIdentity apply(SecurityIdentity identity, Throwable throwable) {\n+                            if (isLogout(context, configContext)) {\n+                                // force logout, the challenge will be built accordingly and redirect to the logout endpoint at the OP\n+                                throw new AuthenticationFailedException();\n+                            }\n+\n+                            // if authentication failed, the reason could be the token no longer being valid, so we try a \n+                            // silent refresh if required\n+                            if (throwable != null) {\n+                                if ((identity = trySilentRefresh(configContext, idToken, refreshToken, context)) == null) {\n+                                    // if the refresh fails, we just propagate the original exception\n+                                    if (throwable instanceof AuthenticationFailedException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "originalPosition": 98}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMzgxMjg0", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391381284", "createdAt": "2020-04-10T10:41:14Z", "commit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMDo0MToxNFrOGD3RqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMDo0MToxNFrOGD3RqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwNDU1Mw==", "bodyText": "Can sessionCookie be null here ?", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406704553", "createdAt": "2020-04-10T10:41:14Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -59,34 +70,73 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public CompletionStage<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n     public CompletionStage<SecurityIdentity> authenticate(RoutingContext context,\n             IdentityProviderManager identityProviderManager,\n             DefaultTenantConfigResolver resolver) {\n         Cookie sessionCookie = context.request().getCookie(SESSION_COOKIE_NAME);\n+        TenantConfigContext configContext = resolver.resolve(context, true);\n \n         // if session already established, try to re-authenticate\n         if (sessionCookie != null) {\n             String[] tokens = sessionCookie.getValue().split(COOKIE_DELIM);\n-            return authenticate(identityProviderManager, new IdTokenCredential(tokens[0], context))\n-                    .thenCompose(new Function<SecurityIdentity, CompletionStage<SecurityIdentity>>() {\n+            String idToken = tokens[0];\n+            String accessToken = tokens[1];\n+            String refreshToken = tokens[2];\n+\n+            return authenticate(identityProviderManager, new IdTokenCredential(idToken, context))\n+                    .handle(new BiFunction<SecurityIdentity, Throwable, SecurityIdentity>() {\n                         @Override\n-                        public CompletionStage<SecurityIdentity> apply(SecurityIdentity securityIdentity) {\n-                            return CompletableFuture\n-                                    .completedFuture(augmentIdentity(securityIdentity, tokens[1], tokens[2], context));\n+                        public SecurityIdentity apply(SecurityIdentity identity, Throwable throwable) {\n+                            if (isLogout(context, configContext)) {\n+                                // force logout, the challenge will be built accordingly and redirect to the logout endpoint at the OP\n+                                throw new AuthenticationFailedException();\n+                            }\n+\n+                            // if authentication failed, the reason could be the token no longer being valid, so we try a \n+                            // silent refresh if required\n+                            if (throwable != null) {\n+                                if ((identity = trySilentRefresh(configContext, idToken, refreshToken, context)) == null) {\n+                                    // if the refresh fails, we just propagate the original exception\n+                                    if (throwable instanceof AuthenticationFailedException) {\n+                                        throw AuthenticationFailedException.class.cast(throwable);\n+                                    }\n+                                    throw new AuthenticationFailedException(throwable);\n+                                }\n+                            }\n+\n+                            return augmentIdentity(identity, accessToken, refreshToken, context);\n                         }\n                     });\n         }\n \n         // start a new session by starting the code flow dance\n-        return performCodeFlow(identityProviderManager, context, resolver);\n+        return performCodeFlow(identityProviderManager, context, configContext);\n     }\n \n     public CompletionStage<ChallengeData> getChallenge(RoutingContext context, DefaultTenantConfigResolver resolver) {\n         TenantConfigContext configContext = resolver.resolve(context, false);\n+        ServerCookie sessionCookie = (ServerCookie) context.cookieMap().get(SESSION_COOKIE_NAME);\n+\n+        if (isLogout(context, configContext)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "originalPosition": 119}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMzgxOTk0", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391381994", "createdAt": "2020-04-10T10:43:23Z", "commit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMDo0MzoyM1rOGD3UOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMDo0MzoyM1rOGD3UOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwNTIxMA==", "bodyText": "Might be worth adding a comment here it is an OIDC logout endpoint and check it is not null", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406705210", "createdAt": "2020-04-10T10:43:23Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -59,34 +70,73 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public CompletionStage<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n     public CompletionStage<SecurityIdentity> authenticate(RoutingContext context,\n             IdentityProviderManager identityProviderManager,\n             DefaultTenantConfigResolver resolver) {\n         Cookie sessionCookie = context.request().getCookie(SESSION_COOKIE_NAME);\n+        TenantConfigContext configContext = resolver.resolve(context, true);\n \n         // if session already established, try to re-authenticate\n         if (sessionCookie != null) {\n             String[] tokens = sessionCookie.getValue().split(COOKIE_DELIM);\n-            return authenticate(identityProviderManager, new IdTokenCredential(tokens[0], context))\n-                    .thenCompose(new Function<SecurityIdentity, CompletionStage<SecurityIdentity>>() {\n+            String idToken = tokens[0];\n+            String accessToken = tokens[1];\n+            String refreshToken = tokens[2];\n+\n+            return authenticate(identityProviderManager, new IdTokenCredential(idToken, context))\n+                    .handle(new BiFunction<SecurityIdentity, Throwable, SecurityIdentity>() {\n                         @Override\n-                        public CompletionStage<SecurityIdentity> apply(SecurityIdentity securityIdentity) {\n-                            return CompletableFuture\n-                                    .completedFuture(augmentIdentity(securityIdentity, tokens[1], tokens[2], context));\n+                        public SecurityIdentity apply(SecurityIdentity identity, Throwable throwable) {\n+                            if (isLogout(context, configContext)) {\n+                                // force logout, the challenge will be built accordingly and redirect to the logout endpoint at the OP\n+                                throw new AuthenticationFailedException();\n+                            }\n+\n+                            // if authentication failed, the reason could be the token no longer being valid, so we try a \n+                            // silent refresh if required\n+                            if (throwable != null) {\n+                                if ((identity = trySilentRefresh(configContext, idToken, refreshToken, context)) == null) {\n+                                    // if the refresh fails, we just propagate the original exception\n+                                    if (throwable instanceof AuthenticationFailedException) {\n+                                        throw AuthenticationFailedException.class.cast(throwable);\n+                                    }\n+                                    throw new AuthenticationFailedException(throwable);\n+                                }\n+                            }\n+\n+                            return augmentIdentity(identity, accessToken, refreshToken, context);\n                         }\n                     });\n         }\n \n         // start a new session by starting the code flow dance\n-        return performCodeFlow(identityProviderManager, context, resolver);\n+        return performCodeFlow(identityProviderManager, context, configContext);\n     }\n \n     public CompletionStage<ChallengeData> getChallenge(RoutingContext context, DefaultTenantConfigResolver resolver) {\n         TenantConfigContext configContext = resolver.resolve(context, false);\n+        ServerCookie sessionCookie = (ServerCookie) context.cookieMap().get(SESSION_COOKIE_NAME);\n+\n+        if (isLogout(context, configContext)) {\n+            String logoutPath = OAuth2AuthProviderImpl.class.cast(configContext.auth).getConfig().getLogoutPath();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "originalPosition": 120}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMzg2MTM0", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391386134", "createdAt": "2020-04-10T10:56:34Z", "commit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMDo1NjozNFrOGD3igw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMDo1NjozNFrOGD3igw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwODg2Nw==", "bodyText": "We can probably just use removeCookie here because it is then removed anyway if it is logout or not", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406708867", "createdAt": "2020-04-10T10:56:34Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -59,34 +70,73 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public CompletionStage<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n     public CompletionStage<SecurityIdentity> authenticate(RoutingContext context,\n             IdentityProviderManager identityProviderManager,\n             DefaultTenantConfigResolver resolver) {\n         Cookie sessionCookie = context.request().getCookie(SESSION_COOKIE_NAME);\n+        TenantConfigContext configContext = resolver.resolve(context, true);\n \n         // if session already established, try to re-authenticate\n         if (sessionCookie != null) {\n             String[] tokens = sessionCookie.getValue().split(COOKIE_DELIM);\n-            return authenticate(identityProviderManager, new IdTokenCredential(tokens[0], context))\n-                    .thenCompose(new Function<SecurityIdentity, CompletionStage<SecurityIdentity>>() {\n+            String idToken = tokens[0];\n+            String accessToken = tokens[1];\n+            String refreshToken = tokens[2];\n+\n+            return authenticate(identityProviderManager, new IdTokenCredential(idToken, context))\n+                    .handle(new BiFunction<SecurityIdentity, Throwable, SecurityIdentity>() {\n                         @Override\n-                        public CompletionStage<SecurityIdentity> apply(SecurityIdentity securityIdentity) {\n-                            return CompletableFuture\n-                                    .completedFuture(augmentIdentity(securityIdentity, tokens[1], tokens[2], context));\n+                        public SecurityIdentity apply(SecurityIdentity identity, Throwable throwable) {\n+                            if (isLogout(context, configContext)) {\n+                                // force logout, the challenge will be built accordingly and redirect to the logout endpoint at the OP\n+                                throw new AuthenticationFailedException();\n+                            }\n+\n+                            // if authentication failed, the reason could be the token no longer being valid, so we try a \n+                            // silent refresh if required\n+                            if (throwable != null) {\n+                                if ((identity = trySilentRefresh(configContext, idToken, refreshToken, context)) == null) {\n+                                    // if the refresh fails, we just propagate the original exception\n+                                    if (throwable instanceof AuthenticationFailedException) {\n+                                        throw AuthenticationFailedException.class.cast(throwable);\n+                                    }\n+                                    throw new AuthenticationFailedException(throwable);\n+                                }\n+                            }\n+\n+                            return augmentIdentity(identity, accessToken, refreshToken, context);\n                         }\n                     });\n         }\n \n         // start a new session by starting the code flow dance\n-        return performCodeFlow(identityProviderManager, context, resolver);\n+        return performCodeFlow(identityProviderManager, context, configContext);\n     }\n \n     public CompletionStage<ChallengeData> getChallenge(RoutingContext context, DefaultTenantConfigResolver resolver) {\n         TenantConfigContext configContext = resolver.resolve(context, false);\n+        ServerCookie sessionCookie = (ServerCookie) context.cookieMap().get(SESSION_COOKIE_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "originalPosition": 117}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMzg4MTQy", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391388142", "createdAt": "2020-04-10T11:03:18Z", "commit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMTowMzoxOVrOGD3pMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMTowMzoxOVrOGD3pMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcxMDU3Ng==", "bodyText": "The refactoring from buildRedirectUri to buildUri itself is neat but we've just calculated absoluteUri above, URI calculation is quite expensive, so IMHO it would be more optimal to keep buildRedirectUri as is, and have buildLogoutUri as well which would also accept absoluteUri - a bit more verbose I agree :-), but would also be clearer IMHO.", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406710576", "createdAt": "2020-04-10T11:03:19Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -101,7 +151,7 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n         // redirect_uri\n         URI absoluteUri = URI.create(context.request().absoluteURI());\n         String redirectPath = getRedirectPath(configContext, absoluteUri);\n-        String redirectUriParam = buildRedirectUri(context, absoluteUri, redirectPath);\n+        String redirectUriParam = buildUri(context, redirectPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "originalPosition": 144}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNDA2MjAz", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391406203", "createdAt": "2020-04-10T11:58:57Z", "commit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMTo1ODo1OFrOGD4nZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMTo1ODo1OFrOGD4nZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyNjUwMg==", "bodyText": "It looks like this check should be after a throwable check, otherwise we will be initiating a logout flow even if the token signature has failed for example, but the user session must have a valid token (except for the possible expiry)", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406726502", "createdAt": "2020-04-10T11:58:58Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -59,34 +70,73 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public CompletionStage<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n     public CompletionStage<SecurityIdentity> authenticate(RoutingContext context,\n             IdentityProviderManager identityProviderManager,\n             DefaultTenantConfigResolver resolver) {\n         Cookie sessionCookie = context.request().getCookie(SESSION_COOKIE_NAME);\n+        TenantConfigContext configContext = resolver.resolve(context, true);\n \n         // if session already established, try to re-authenticate\n         if (sessionCookie != null) {\n             String[] tokens = sessionCookie.getValue().split(COOKIE_DELIM);\n-            return authenticate(identityProviderManager, new IdTokenCredential(tokens[0], context))\n-                    .thenCompose(new Function<SecurityIdentity, CompletionStage<SecurityIdentity>>() {\n+            String idToken = tokens[0];\n+            String accessToken = tokens[1];\n+            String refreshToken = tokens[2];\n+\n+            return authenticate(identityProviderManager, new IdTokenCredential(idToken, context))\n+                    .handle(new BiFunction<SecurityIdentity, Throwable, SecurityIdentity>() {\n                         @Override\n-                        public CompletionStage<SecurityIdentity> apply(SecurityIdentity securityIdentity) {\n-                            return CompletableFuture\n-                                    .completedFuture(augmentIdentity(securityIdentity, tokens[1], tokens[2], context));\n+                        public SecurityIdentity apply(SecurityIdentity identity, Throwable throwable) {\n+                            if (isLogout(context, configContext)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNDA3MTYy", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391407162", "createdAt": "2020-04-10T12:01:25Z", "commit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjowMToyNVrOGD4qvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjowMToyNVrOGD4qvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyNzM1OQ==", "bodyText": "AuthenticationCompletionException should be here", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406727359", "createdAt": "2020-04-10T12:01:25Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -298,5 +344,66 @@ private void removeCookie(RoutingContext context, TenantConfigContext configCont\n                 cookie.setPath(auth.cookiePath.get());\n             }\n         }\n+        return cookie;\n+    }\n+\n+    private boolean isLogout(RoutingContext context, TenantConfigContext configContext) {\n+        Optional<String> logoutPath = configContext.oidcConfig.logout.path;\n+\n+        if (logoutPath.isPresent()) {\n+            return context.request().absoluteURI().equals(\n+                    buildUri(context, logoutPath.get()));\n+        }\n+\n+        return false;\n+    }\n+\n+    private SecurityIdentity trySilentRefresh(TenantConfigContext configContext, String idToken, String refreshToken,\n+            RoutingContext context) {\n+        OidcTenantConfig config = configContext.oidcConfig;\n+\n+        if (config.token.refreshTimeout.isPresent()) {\n+            OAuth2AuthProviderImpl auth = ((OAuth2AuthProviderImpl) configContext.auth);\n+            JWT jwt = auth.getJWT();\n+            JsonObject tokenJson;\n+\n+            try {\n+                tokenJson = jwt.decode(idToken);\n+            } catch (Exception cause) {\n+                throw new AuthenticationFailedException(cause);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "originalPosition": 254}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNDA4MDI1", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391408025", "createdAt": "2020-04-10T12:04:00Z", "commit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjowNDowMFrOGD4uAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjowNDowMFrOGD4uAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyODE5NQ==", "bodyText": "AuthenticationCompletionException", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406728195", "createdAt": "2020-04-10T12:04:00Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -298,5 +344,66 @@ private void removeCookie(RoutingContext context, TenantConfigContext configCont\n                 cookie.setPath(auth.cookiePath.get());\n             }\n         }\n+        return cookie;\n+    }\n+\n+    private boolean isLogout(RoutingContext context, TenantConfigContext configContext) {\n+        Optional<String> logoutPath = configContext.oidcConfig.logout.path;\n+\n+        if (logoutPath.isPresent()) {\n+            return context.request().absoluteURI().equals(\n+                    buildUri(context, logoutPath.get()));\n+        }\n+\n+        return false;\n+    }\n+\n+    private SecurityIdentity trySilentRefresh(TenantConfigContext configContext, String idToken, String refreshToken,\n+            RoutingContext context) {\n+        OidcTenantConfig config = configContext.oidcConfig;\n+\n+        if (config.token.refreshTimeout.isPresent()) {\n+            OAuth2AuthProviderImpl auth = ((OAuth2AuthProviderImpl) configContext.auth);\n+            JWT jwt = auth.getJWT();\n+            JsonObject tokenJson;\n+\n+            try {\n+                tokenJson = jwt.decode(idToken);\n+            } catch (Exception cause) {\n+                throw new AuthenticationFailedException(cause);\n+            }\n+\n+            Long iat = tokenJson.getLong(\"iat\");\n+            long now = System.currentTimeMillis() / 1000;\n+            Integer timeout = config.token.refreshTimeout.get();\n+\n+            if (now - iat >= timeout) {\n+                CompletableFuture<SecurityIdentity> cf = new CompletableFuture<>();\n+                OAuth2TokenImpl token = new OAuth2TokenImpl(configContext.auth, new JsonObject());\n+\n+                token.principal().put(\"refresh_token\", refreshToken);\n+\n+                token.refresh(new Handler<AsyncResult<Void>>() {\n+                    @Override\n+                    public void handle(AsyncResult<Void> result) {\n+                        if (result.succeeded()) {\n+                            String rawIdToken = token.principal().getString(\"id_token\");\n+                            IdTokenCredential idToken = new IdTokenCredential(rawIdToken, context);\n+                            QuarkusSecurityIdentity identity = validateAndCreateIdentity(idToken, config,\n+                                    jwt.decode(idToken.getToken()));\n+                            // after a successful refresh, rebuild the identity and update the cookie \n+                            processSuccessfulAuthentication(context, configContext, token, identity);\n+                            cf.complete(identity);\n+                        } else {\n+                            cf.completeExceptionally(new AuthenticationFailedException(result.cause()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "originalPosition": 279}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNDEyNDQ5", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391412449", "createdAt": "2020-04-10T12:16:23Z", "commit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjoxNjoyM1rOGD48wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjoxNjoyM1rOGD48wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczMTk2OQ==", "bodyText": "Should we just call it logoutEndpoint :-) ?", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406731969", "createdAt": "2020-04-10T12:16:23Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcRecorder.java", "diffHunk": "@@ -171,6 +171,14 @@ public void handle(AsyncResult<OAuth2Auth> event) {\n                 });\n \n                 auth = cf.join();\n+\n+                String endSessionEndpoint = OAuth2AuthProviderImpl.class.cast(auth).getConfig().getLogoutPath();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNDEyNTUw", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391412550", "createdAt": "2020-04-10T12:16:39Z", "commit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjoxNjozOVrOGD49Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjoxNjozOVrOGD49Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczMjA1NA==", "bodyText": "OIDCException", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406732054", "createdAt": "2020-04-10T12:16:39Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcRecorder.java", "diffHunk": "@@ -171,6 +171,14 @@ public void handle(AsyncResult<OAuth2Auth> event) {\n                 });\n \n                 auth = cf.join();\n+\n+                String endSessionEndpoint = OAuth2AuthProviderImpl.class.cast(auth).getConfig().getLogoutPath();\n+\n+                if (endSessionEndpoint == null && oidcConfig.logout.path.isPresent()) {\n+                    throw new RuntimeException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNDE2NDg2", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391416486", "createdAt": "2020-04-10T12:27:24Z", "commit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjoyNzoyNFrOGD5KbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjoyNzoyNFrOGD5KbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczNTQ2OA==", "bodyText": "It is not used as a URI in the code. I also propose to rename the property to something less technical such as  landingPath or postLogoutPath or similar and doc it as Relative path of the application endpoint where the user should be redirected to after the logging out from the OpenID Connect Provider or similar", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406735468", "createdAt": "2020-04-10T12:27:24Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcTenantConfig.java", "diffHunk": "@@ -119,6 +125,40 @@\n \n     }\n \n+    @ConfigGroup\n+    public static class Logout {\n+\n+        /**\n+         * The logout endpoint at the application. If provided, the application is able to initiate the logout through this\n+         * endpoint in conformance with the OpenID Connect RP-Initiated Logout specification.\n+         */\n+        @ConfigItem\n+        Optional<String> path;\n+\n+        /**\n+         * The {@code URI} to redirect the user after the logging out from the OpenID Connect Provider. This {@code URI} must be\n+         * properly registered at the OpenID Connect Provider as a valid redirect URI.\n+         */\n+        @ConfigItem\n+        Optional<String> redirectUri;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNDE2OTAx", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391416901", "createdAt": "2020-04-10T12:28:32Z", "commit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjoyODozMlrOGD5L0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjoyODozMlrOGD5L0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczNTgyNg==", "bodyText": "Please replace The logout endpoint at the application with something like The relative path of the logout endpoint...", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406735826", "createdAt": "2020-04-10T12:28:32Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcTenantConfig.java", "diffHunk": "@@ -119,6 +125,40 @@\n \n     }\n \n+    @ConfigGroup\n+    public static class Logout {\n+\n+        /**\n+         * The logout endpoint at the application. If provided, the application is able to initiate the logout through this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNDE3OTI0", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391417924", "createdAt": "2020-04-10T12:31:20Z", "commit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjozMToyMFrOGD5PMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjozMToyMFrOGD5PMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczNjY5MA==", "bodyText": "I believe we need to support the OIDCs without the discovery (as we already do with introspectionPath and jwksPath), so adding logoutPath or logoutUri may be (doc-ed as either relative path or relative URI of the OIDC logout) and checking it if no discovery is available would make sense IMHO", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406736690", "createdAt": "2020-04-10T12:31:20Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcTenantConfig.java", "diffHunk": "@@ -119,6 +125,40 @@\n \n     }\n \n+    @ConfigGroup\n+    public static class Logout {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNDE4NzI2", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391418726", "createdAt": "2020-04-10T12:33:23Z", "commit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjozMzoyNFrOGD5Ryg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjozMzoyNFrOGD5Ryg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczNzM1NA==", "bodyText": "If you agree with the logout_path proposal above, then path should likely be renamed to localPath may be, not 100% sure :-)", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406737354", "createdAt": "2020-04-10T12:33:24Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcTenantConfig.java", "diffHunk": "@@ -119,6 +125,40 @@\n \n     }\n \n+    @ConfigGroup\n+    public static class Logout {\n+\n+        /**\n+         * The logout endpoint at the application. If provided, the application is able to initiate the logout through this\n+         * endpoint in conformance with the OpenID Connect RP-Initiated Logout specification.\n+         */\n+        @ConfigItem\n+        Optional<String> path;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNDIxMjA2", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391421206", "createdAt": "2020-04-10T12:39:52Z", "commit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjozOTo1M1rOGD5aTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjozOTo1M1rOGD5aTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjczOTUzNQ==", "bodyText": "I'd drop the word silent and would not even refer to the logout. If we have an expired ID Token then this refresh timeout will refresh all the token types for web-app applications. I can later use it for the pre-emtive refresh for the service applications too :-)", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406739535", "createdAt": "2020-04-10T12:39:53Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcTenantConfig.java", "diffHunk": "@@ -475,6 +523,14 @@ public static Token fromAudience(String... audience) {\n         @ConfigItem\n         public Optional<String> principalClaim = Optional.empty();\n \n+        /**\n+         * The time, in seconds, that tokens should be silently refreshed so that tokens with no active session at the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNDIyNTM5", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391422539", "createdAt": "2020-04-10T12:43:07Z", "commit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjo0MzowN1rOGD5eqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjo0MzowN1rOGD5eqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0MDY0OA==", "bodyText": "That should be in KeycloakRealmResourceManager ? I see, please introduce a dedicated client id, same as I did for the jwt. though it has not been merget yet :-)", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406740648", "createdAt": "2020-04-10T12:43:07Z", "author": {"login": "sberyozkin"}, "path": "integration-tests/oidc-code-flow/src/test/java/io/quarkus/it/keycloak/CodeFlowTest.java", "diffHunk": "@@ -111,6 +118,67 @@ public void testTokenTimeoutLogout() throws IOException, InterruptedException {\n         }\n     }\n \n+    @Test\n+    public void testRPInitiatedLogout() throws IOException, InterruptedException {\n+        Keycloak keycloak = KeycloakRealmResourceManager.createKeycloakClient();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNDI0MTQ1", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391424145", "createdAt": "2020-04-10T12:47:18Z", "commit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjo0NzoxOFrOGD5kLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjo0NzoxOFrOGD5kLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0MjA2Mg==", "bodyText": "IMHO it would be simpler to keep the realm updates here, see above", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406742062", "createdAt": "2020-04-10T12:47:18Z", "author": {"login": "sberyozkin"}, "path": "integration-tests/oidc-code-flow/src/test/java/io/quarkus/it/keycloak/KeycloakRealmResourceManager.java", "diffHunk": "@@ -34,16 +34,20 @@\n         realm.getUsers().add(createUser(\"admin\", \"user\", \"admin\"));\n         realm.getUsers().add(createUser(\"jdoe\", \"user\", \"confidential\"));\n \n-        keycloak = KeycloakBuilder.builder()\n+        keycloak = createKeycloakClient();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNDI0MTQ4", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391424148", "createdAt": "2020-04-10T12:47:18Z", "commit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjo0NzoxOFrOGD5kMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjo0NzoxOFrOGD5kMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0MjA2Ng==", "bodyText": "IMHO it would be simpler to keep the realm updates here, see above", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406742066", "createdAt": "2020-04-10T12:47:18Z", "author": {"login": "sberyozkin"}, "path": "integration-tests/oidc-code-flow/src/test/java/io/quarkus/it/keycloak/KeycloakRealmResourceManager.java", "diffHunk": "@@ -34,16 +34,20 @@\n         realm.getUsers().add(createUser(\"admin\", \"user\", \"admin\"));\n         realm.getUsers().add(createUser(\"jdoe\", \"user\", \"confidential\"));\n \n-        keycloak = KeycloakBuilder.builder()\n+        keycloak = createKeycloakClient();\n+        keycloak.realms().create(realm);\n+\n+        return Collections.emptyMap();\n+    }\n+\n+    static Keycloak createKeycloakClient() {\n+        return KeycloakBuilder.builder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNDI0NTk2", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391424596", "createdAt": "2020-04-10T12:48:14Z", "commit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjo0ODoxNFrOGD5liQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjo0ODoxNFrOGD5liQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0MjQwOQ==", "bodyText": "quarkus-app-logout as a client id would help with the proposed simplifications", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406742409", "createdAt": "2020-04-10T12:48:14Z", "author": {"login": "sberyozkin"}, "path": "integration-tests/oidc-code-flow/src/main/resources/application.properties", "diffHunk": "@@ -44,8 +44,24 @@ quarkus.oidc.tenant-3.authentication.redirect-path=/some/other/path\n quarkus.oidc.tenant-3.authentication.restore-path-after-redirect=false\n quarkus.oidc.tenant-3.application-type=web-app\n \n+quarkus.oidc.tenant-logout.auth-server-url=${keycloak.url}/realms/quarkus\n+quarkus.oidc.tenant-logout.client-id=quarkus-app", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNDI2NjEw", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391426610", "createdAt": "2020-04-10T12:53:28Z", "commit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjo1MzoyOFrOGD5sYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMjo1MzoyOFrOGD5sYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0NDE2Mg==", "bodyText": "What would be really good is to verify idtoken (and also AT at least) has been refreshed. There is a code somewhere in this class which checks the cookie content (disables the auto-redirect and then re-enables - not sure it will be needed yet). So in this test you can record id_token before the refresh and assert it is not the same after the refresh.\nAlso, this is not part of this PR, but there is a timeout test here as well, so please add awaitility there, sorry :-)", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406744162", "createdAt": "2020-04-10T12:53:28Z", "author": {"login": "sberyozkin"}, "path": "integration-tests/oidc-code-flow/src/test/java/io/quarkus/it/keycloak/CodeFlowTest.java", "diffHunk": "@@ -111,6 +118,67 @@ public void testTokenTimeoutLogout() throws IOException, InterruptedException {\n         }\n     }\n \n+    @Test\n+    public void testRPInitiatedLogout() throws IOException, InterruptedException {\n+        Keycloak keycloak = KeycloakRealmResourceManager.createKeycloakClient();\n+\n+        RealmResource realm = keycloak.realm(KeycloakRealmResourceManager.KEYCLOAK_REALM);\n+        RealmRepresentation representation = realm\n+                .toRepresentation();\n+\n+        Integer ssoSessionMaxLifespan = representation.getSsoSessionMaxLifespan();\n+        representation.setSsoSessionMaxLifespan(20);\n+\n+        Integer accessCodeLifespan = representation.getAccessCodeLifespan();\n+        representation.setAccessTokenLifespan(5);\n+\n+        realm.update(representation);\n+\n+        try (final WebClient webClient = createWebClient()) {\n+            HtmlPage page = webClient.getPage(\"http://localhost:8081/tenant-logout\");\n+            assertEquals(\"Log in to quarkus\", page.getTitleText());\n+            HtmlForm loginForm = page.getForms().get(0);\n+            loginForm.getInputByName(\"username\").setValueAttribute(\"alice\");\n+            loginForm.getInputByName(\"password\").setValueAttribute(\"alice\");\n+            page = loginForm.getInputByName(\"login\").click();\n+            assertTrue(page.asText().contains(\"Tenant Logout\"));\n+            assertNotNull(getSessionCookie(webClient));\n+\n+            page = webClient.getPage(\"http://localhost:8081/tenant-logout/logout\");\n+            assertTrue(page.asText().contains(\"You were logged out\"));\n+            assertNull(getSessionCookie(webClient));\n+\n+            page = webClient.getPage(\"http://localhost:8081/tenant-logout\");\n+            assertEquals(\"Log in to quarkus\", page.getTitleText());\n+            loginForm = page.getForms().get(0);\n+            loginForm.getInputByName(\"username\").setValueAttribute(\"alice\");\n+            loginForm.getInputByName(\"password\").setValueAttribute(\"alice\");\n+            page = loginForm.getInputByName(\"login\").click();\n+            assertTrue(page.asText().contains(\"Tenant Logout\"));\n+\n+            //wait now so that we reach the refresh timeout\n+            await().atMost(10, TimeUnit.SECONDS)\n+                    .pollInterval(Duration.ofSeconds(5))\n+                    .until(new Callable<Boolean>() {\n+                        @Override\n+                        public Boolean call() throws Exception {\n+                            webClient.getOptions().setRedirectEnabled(false);\n+                            WebResponse webResponse = webClient\n+                                    .loadWebResponse(new WebRequest(URI.create(\"http://localhost:8081/tenant-logout\").toURL()));\n+                            // Should not redirect to OP but silently refresh token", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d"}, "originalPosition": 74}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "af1c474e6be13e90cb65a2156ac4588f03c7df5d", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/af1c474e6be13e90cb65a2156ac4588f03c7df5d", "committedDate": "2020-04-09T22:37:32Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "775004398b9d7d0e8fde8c1c881a516d6e65cfd2", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/775004398b9d7d0e8fde8c1c881a516d6e65cfd2", "committedDate": "2020-04-10T13:16:09Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "775004398b9d7d0e8fde8c1c881a516d6e65cfd2", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/775004398b9d7d0e8fde8c1c881a516d6e65cfd2", "committedDate": "2020-04-10T13:16:09Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "fca62d107d55e343cda45e820b6c58ee9ff3c09d", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/fca62d107d55e343cda45e820b6c58ee9ff3c09d", "committedDate": "2020-04-10T13:24:38Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNDYzNTQw", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391463540", "createdAt": "2020-04-10T14:13:19Z", "commit": {"oid": "fca62d107d55e343cda45e820b6c58ee9ff3c09d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNDoxMzoxOVrOGD7nUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNDoxMzoxOVrOGD7nUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc3NTYzNQ==", "bodyText": "What is this refreshingTokens about, why would we want to have this cache ?", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406775635", "createdAt": "2020-04-10T14:13:19Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -298,5 +352,74 @@ private void removeCookie(RoutingContext context, TenantConfigContext configCont\n                 cookie.setPath(auth.cookiePath.get());\n             }\n         }\n+        return cookie;\n+    }\n+\n+    private boolean isLogout(RoutingContext context, TenantConfigContext configContext) {\n+        Optional<String> logoutPath = configContext.oidcConfig.logout.path;\n+\n+        if (logoutPath.isPresent()) {\n+            return context.request().absoluteURI().equals(\n+                    buildUri(context, logoutPath.get()));\n+        }\n+\n+        return false;\n+    }\n+\n+    private SecurityIdentity trySilentRefresh(TenantConfigContext configContext, String idToken, String refreshToken,\n+            RoutingContext context) {\n+        OidcTenantConfig config = configContext.oidcConfig;\n+\n+        if (config.token.refreshTimeout.isPresent()) {\n+            OAuth2AuthProviderImpl auth = ((OAuth2AuthProviderImpl) configContext.auth);\n+            JWT jwt = auth.getJWT();\n+            JsonObject tokenJson;\n+\n+            try {\n+                tokenJson = jwt.decode(idToken);\n+            } catch (Exception cause) {\n+                throw new AuthenticationCompletionException(cause);\n+            }\n+\n+            Long iat = tokenJson.getLong(\"iat\");\n+            long now = System.currentTimeMillis() / 1000;\n+            Integer timeout = config.token.refreshTimeout.get();\n+\n+            if (now - iat >= timeout) {\n+                try {\n+                    if (!refreshingTokens.add(refreshToken)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fca62d107d55e343cda45e820b6c58ee9ff3c09d"}, "originalPosition": 303}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fca62d107d55e343cda45e820b6c58ee9ff3c09d", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/fca62d107d55e343cda45e820b6c58ee9ff3c09d", "committedDate": "2020-04-10T13:24:38Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "99a97ea4e9f652be5abc7ea0c07240219a7a43fd", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/99a97ea4e9f652be5abc7ea0c07240219a7a43fd", "committedDate": "2020-04-10T14:53:09Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "99a97ea4e9f652be5abc7ea0c07240219a7a43fd", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/99a97ea4e9f652be5abc7ea0c07240219a7a43fd", "committedDate": "2020-04-10T14:53:09Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "8c71b88232fa545ea85ff6972c8c948b7ee6ea41", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/8c71b88232fa545ea85ff6972c8c948b7ee6ea41", "committedDate": "2020-04-10T15:00:14Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8c71b88232fa545ea85ff6972c8c948b7ee6ea41", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/8c71b88232fa545ea85ff6972c8c948b7ee6ea41", "committedDate": "2020-04-10T15:00:14Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "efe51530e8c60189fed4a84004eac72c8273ec26", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/efe51530e8c60189fed4a84004eac72c8273ec26", "committedDate": "2020-04-10T15:43:49Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "efe51530e8c60189fed4a84004eac72c8273ec26", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/efe51530e8c60189fed4a84004eac72c8273ec26", "committedDate": "2020-04-10T15:43:49Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "542ad49dc1f9d44ef36e8842f989f6a8e3866816", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/542ad49dc1f9d44ef36e8842f989f6a8e3866816", "committedDate": "2020-04-10T16:11:37Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNTI5NTE2", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391529516", "createdAt": "2020-04-10T16:20:13Z", "commit": {"oid": "542ad49dc1f9d44ef36e8842f989f6a8e3866816"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNjoyMDoxM1rOGD_AFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxNjoyMDoxM1rOGD_AFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTEyNw==", "bodyText": "Hi Pedro @pedroigor That looks safer but I'm really not sure it is the right solution as it still does not resolve the issue that the RT can be recycled so this map may not really be reflecting the current status. IMHO we may need to give it a bit more thinking.", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r406831127", "createdAt": "2020-04-10T16:20:13Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -59,35 +72,82 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public CompletionStage<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n+    /**\n+     * A bounded map that limits the number of refresh tokens we can process concurrently\n+     */\n+    private final Map<String, String> refreshingTokens = Collections", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "542ad49dc1f9d44ef36e8842f989f6a8e3866816"}, "originalPosition": 71}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "542ad49dc1f9d44ef36e8842f989f6a8e3866816", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/542ad49dc1f9d44ef36e8842f989f6a8e3866816", "committedDate": "2020-04-10T16:11:37Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "ddeb46199407056372e186cde30a91121eec71d7", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/ddeb46199407056372e186cde30a91121eec71d7", "committedDate": "2020-04-10T19:44:16Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ddeb46199407056372e186cde30a91121eec71d7", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/ddeb46199407056372e186cde30a91121eec71d7", "committedDate": "2020-04-10T19:44:16Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "9aad5e46b909588d90aeda102ac9d44ff692d05b", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/9aad5e46b909588d90aeda102ac9d44ff692d05b", "committedDate": "2020-04-10T19:58:27Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9aad5e46b909588d90aeda102ac9d44ff692d05b", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/9aad5e46b909588d90aeda102ac9d44ff692d05b", "committedDate": "2020-04-10T19:58:27Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "931e789e8740df0964dcda8d1f9283299a32197e", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/931e789e8740df0964dcda8d1f9283299a32197e", "committedDate": "2020-04-11T11:36:09Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "931e789e8740df0964dcda8d1f9283299a32197e", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/931e789e8740df0964dcda8d1f9283299a32197e", "committedDate": "2020-04-11T11:36:09Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "bf4174280dc3515e66e7f9c35f43308a3f140c4f", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/bf4174280dc3515e66e7f9c35f43308a3f140c4f", "committedDate": "2020-04-11T12:30:07Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bf4174280dc3515e66e7f9c35f43308a3f140c4f", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/bf4174280dc3515e66e7f9c35f43308a3f140c4f", "committedDate": "2020-04-11T12:30:07Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "e029283361bfb208a4e20216cc259ca5dff6e758", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/e029283361bfb208a4e20216cc259ca5dff6e758", "committedDate": "2020-04-11T12:55:09Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e029283361bfb208a4e20216cc259ca5dff6e758", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/e029283361bfb208a4e20216cc259ca5dff6e758", "committedDate": "2020-04-11T12:55:09Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "c6a659a9b09840c531124c051f19cc442f209d50", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/c6a659a9b09840c531124c051f19cc442f209d50", "committedDate": "2020-04-11T14:31:32Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNzgzNTEz", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-391783513", "createdAt": "2020-04-11T17:07:42Z", "commit": {"oid": "c6a659a9b09840c531124c051f19cc442f209d50"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxNzowNzo0M1rOGEOnJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxNzowNzo0M1rOGEOnJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA4Njg4NQ==", "bodyText": "@pedroigor That is different to what was done about the logout earlier where a challenge was attempted with a valid identity only. IMHO the refresh can only be attempted if the token has expired, which can happen on any other request, so IMHO your original flow should be restored (the logout request initiates a challenge flow only if the identity is available) and again, please just check if \"Token has expired\".equals(throwable.getMessage()) :-), please check Vertx OAuth2 JWT class for the exact message text", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407086885", "createdAt": "2020-04-11T17:07:43Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -61,23 +70,63 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public Uni<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n+    /**\n+     * A bounded map that limits the number of refresh tokens we can process concurrently\n+     */\n+    private final Map<String, TokenEntry> refreshingTokens = Collections\n+            .synchronizedMap(new LinkedHashMap<String, TokenEntry>(16, 0.75f, true) {\n+                @Override\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    // we could make the max number of entries configurable\n+                    return size() > 30;\n+                }\n+            });\n+\n     public Uni<SecurityIdentity> authenticate(RoutingContext context,\n             IdentityProviderManager identityProviderManager,\n             DefaultTenantConfigResolver resolver) {\n         Cookie sessionCookie = context.request().getCookie(SESSION_COOKIE_NAME);\n+        TenantConfigContext configContext = resolver.resolve(context, true);\n \n         // if session already established, try to re-authenticate\n         if (sessionCookie != null) {\n             String[] tokens = sessionCookie.getValue().split(COOKIE_DELIM);\n+            String idToken = tokens[0];\n+            String accessToken = tokens[1];\n+            String refreshToken = tokens[2];\n+\n             return authenticate(identityProviderManager, new IdTokenCredential(tokens[0], context))\n                     .map(new Function<SecurityIdentity, SecurityIdentity>() {\n                         @Override\n-                        public SecurityIdentity apply(SecurityIdentity securityIdentity) {\n-                            return augmentIdentity(securityIdentity, tokens[1], tokens[2], context);\n+                        public SecurityIdentity apply(SecurityIdentity identity) {\n+                            if (isLogout(context, configContext)) {\n+                                // force logout, the challenge will be built accordingly and redirect to the logout endpoint at the OP\n+                                throw new AuthenticationFailedException();\n+                            }\n+\n+                            return augmentIdentity(identity, accessToken, refreshToken, context);\n+                        }\n+                    }).on().failure().recoverWithItem(new Function<Throwable, SecurityIdentity>() {\n+                        @Override\n+                        public SecurityIdentity apply(Throwable throwable) {\n+                            SecurityIdentity identity;\n+\n+                            // if authentication failed, the reason could be the token no longer being valid, so we try a \n+                            // silent refresh if required\n+                            if (isLogout(context, configContext) ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6a659a9b09840c531124c051f19cc442f209d50"}, "originalPosition": 103}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c6a659a9b09840c531124c051f19cc442f209d50", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/c6a659a9b09840c531124c051f19cc442f209d50", "committedDate": "2020-04-11T14:31:32Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "018b88b02346ac87ae8a48a4e60ed10431d26334", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/018b88b02346ac87ae8a48a4e60ed10431d26334", "committedDate": "2020-04-13T19:02:04Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNDIzOTcw", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-392423970", "createdAt": "2020-04-13T20:41:45Z", "commit": {"oid": "018b88b02346ac87ae8a48a4e60ed10431d26334"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDo0MTo0NVrOGE0igg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDo0MTo0NVrOGE0igg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwODI5MA==", "bodyText": "@pedroigor Thank you :-) :-)", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407708290", "createdAt": "2020-04-13T20:41:45Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -61,23 +70,65 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public Uni<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n+    /**\n+     * A bounded map that limits the number of refresh tokens we can process concurrently\n+     */\n+    private final Map<String, TokenEntry> refreshingTokens = Collections\n+            .synchronizedMap(new LinkedHashMap<String, TokenEntry>(16, 0.75f, true) {\n+                @Override\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    // we could make the max number of entries configurable\n+                    return size() > 30;\n+                }\n+            });\n+\n     public Uni<SecurityIdentity> authenticate(RoutingContext context,\n             IdentityProviderManager identityProviderManager,\n             DefaultTenantConfigResolver resolver) {\n         Cookie sessionCookie = context.request().getCookie(SESSION_COOKIE_NAME);\n+        TenantConfigContext configContext = resolver.resolve(context, true);\n \n         // if session already established, try to re-authenticate\n         if (sessionCookie != null) {\n             String[] tokens = sessionCookie.getValue().split(COOKIE_DELIM);\n+            String idToken = tokens[0];\n+            String accessToken = tokens[1];\n+            String refreshToken = tokens[2];\n+\n             return authenticate(identityProviderManager, new IdTokenCredential(tokens[0], context))\n                     .map(new Function<SecurityIdentity, SecurityIdentity>() {\n                         @Override\n-                        public SecurityIdentity apply(SecurityIdentity securityIdentity) {\n-                            return augmentIdentity(securityIdentity, tokens[1], tokens[2], context);\n+                        public SecurityIdentity apply(SecurityIdentity identity) {\n+                            if (isLogout(context, configContext)) {\n+                                redirectToLogoutEndpoint(context, configContext, idToken);\n+                            }\n+\n+                            return augmentIdentity(identity, accessToken, refreshToken, context);\n+                        }\n+                    }).on().failure().recoverWithItem(new Function<Throwable, SecurityIdentity>() {\n+                        @Override\n+                        public SecurityIdentity apply(Throwable throwable) {\n+                            Throwable cause = throwable.getCause();\n+\n+                            // we should have proper exception hierarchy to represent token expiration errors\n+                            if (cause != null && !cause.getMessage().equalsIgnoreCase(\"expired token\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "018b88b02346ac87ae8a48a4e60ed10431d26334"}, "originalPosition": 101}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "018b88b02346ac87ae8a48a4e60ed10431d26334", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/018b88b02346ac87ae8a48a4e60ed10431d26334", "committedDate": "2020-04-13T19:02:04Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "625e17ed0fe29743257238edf7032c94c54c50ff", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/625e17ed0fe29743257238edf7032c94c54c50ff", "committedDate": "2020-04-13T20:47:34Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNDU3MDMw", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-392457030", "createdAt": "2020-04-13T21:35:49Z", "commit": {"oid": "625e17ed0fe29743257238edf7032c94c54c50ff"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMTozNTo0OVrOGE2NbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMTozNTo0OVrOGE2NbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTY2MA==", "bodyText": "@pedroigor I think this looks nice but may be something still needs to be tweaked. So if we have a failure due to the expiry then\n\nif it is a logout request - we just redirect to the OP logout URI - this makes sense\notherwise we just refresh, if identity is not null, all is good,  but if it is null, I think we should return AuthenticationFailedException so that a user's session is invalidated and we redirect the user to the login site, as opposed to the logout site, this is because the OP logout endpoint may not be even available, and even if it is available, I don't think the user, after his ID token has failed to refresh, should be redirected to the OP logout site - what if OP asks, would you like to logout ? while the users was doing some GET /mybook...\n\nWhat do you think ?", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407735660", "createdAt": "2020-04-13T21:35:49Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -61,23 +70,65 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public Uni<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n+    /**\n+     * A bounded map that limits the number of refresh tokens we can process concurrently\n+     */\n+    private final Map<String, TokenEntry> refreshingTokens = Collections\n+            .synchronizedMap(new LinkedHashMap<String, TokenEntry>(16, 0.75f, true) {\n+                @Override\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    // we could make the max number of entries configurable\n+                    return size() > 30;\n+                }\n+            });\n+\n     public Uni<SecurityIdentity> authenticate(RoutingContext context,\n             IdentityProviderManager identityProviderManager,\n             DefaultTenantConfigResolver resolver) {\n         Cookie sessionCookie = context.request().getCookie(SESSION_COOKIE_NAME);\n+        TenantConfigContext configContext = resolver.resolve(context, true);\n \n         // if session already established, try to re-authenticate\n         if (sessionCookie != null) {\n             String[] tokens = sessionCookie.getValue().split(COOKIE_DELIM);\n+            String idToken = tokens[0];\n+            String accessToken = tokens[1];\n+            String refreshToken = tokens[2];\n+\n             return authenticate(identityProviderManager, new IdTokenCredential(tokens[0], context))\n                     .map(new Function<SecurityIdentity, SecurityIdentity>() {\n                         @Override\n-                        public SecurityIdentity apply(SecurityIdentity securityIdentity) {\n-                            return augmentIdentity(securityIdentity, tokens[1], tokens[2], context);\n+                        public SecurityIdentity apply(SecurityIdentity identity) {\n+                            if (isLogout(context, configContext)) {\n+                                redirectToLogoutEndpoint(context, configContext, idToken);\n+                            }\n+\n+                            return augmentIdentity(identity, accessToken, refreshToken, context);\n+                        }\n+                    }).on().failure().recoverWithItem(new Function<Throwable, SecurityIdentity>() {\n+                        @Override\n+                        public SecurityIdentity apply(Throwable throwable) {\n+                            Throwable cause = throwable.getCause();\n+\n+                            // we should have proper exception hierarchy to represent token expiration errors\n+                            if (cause != null && !cause.getMessage().equalsIgnoreCase(\"expired token\")) {\n+                                throw new AuthenticationFailedException(throwable);\n+                            }\n+\n+                            SecurityIdentity identity = null;\n+\n+                            // if authentication failed, the reason could be the token no longer being valid, so we try a \n+                            // silent refresh if required\n+                            if (isLogout(context, configContext) ||\n+                                    (identity = trySilentRefresh(configContext, idToken, refreshToken, context,\n+                                            identityProviderManager)) == null) {\n+                                redirectToLogoutEndpoint(context, configContext, idToken);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "625e17ed0fe29743257238edf7032c94c54c50ff"}, "originalPosition": 112}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNDU5MTc5", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-392459179", "createdAt": "2020-04-13T21:39:53Z", "commit": {"oid": "625e17ed0fe29743257238edf7032c94c54c50ff"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMTozOTo1M1rOGE2UrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMTozOTo1M1rOGE2UrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNzUxNg==", "bodyText": "So yeah, what happens here to the blocking threads, they get the refresh token and proceed with their own refresh ? Or can we just let those blocking threads pick up the refreshed token/etc and continue without the refresh ?", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407737516", "createdAt": "2020-04-13T21:39:53Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -301,4 +348,114 @@ private void removeCookie(RoutingContext context, TenantConfigContext configCont\n             }\n         }\n     }\n+\n+    private boolean isLogout(RoutingContext context, TenantConfigContext configContext) {\n+        Optional<String> logoutPath = configContext.oidcConfig.logout.path;\n+\n+        if (logoutPath.isPresent()) {\n+            return context.request().absoluteURI().equals(\n+                    buildUri(context, logoutPath.get()));\n+        }\n+\n+        return false;\n+    }\n+\n+    private SecurityIdentity trySilentRefresh(TenantConfigContext configContext, String idToken, String refreshToken,\n+            RoutingContext context, IdentityProviderManager identityProviderManager) {\n+        OidcTenantConfig config = configContext.oidcConfig;\n+\n+        if (config.token.refreshTimeout.isPresent()) {\n+            OAuth2AuthProviderImpl auth = ((OAuth2AuthProviderImpl) configContext.auth);\n+            JWT jwt = auth.getJWT();\n+            JsonObject tokenJson;\n+\n+            try {\n+                tokenJson = jwt.decode(idToken);\n+            } catch (Exception cause) {\n+                throw new AuthenticationCompletionException(cause);\n+            }\n+\n+            Long iat = tokenJson.getLong(\"iat\");\n+            long now = System.currentTimeMillis() / 1000;\n+            Integer timeout = config.token.refreshTimeout.get();\n+\n+            if (now - iat >= timeout) {\n+                String sub = tokenJson.getString(\"sub\");\n+\n+                TokenEntry entry = refreshingTokens.computeIfAbsent(sub,\n+                        new Function<String, TokenEntry>() {\n+                            @Override\n+                            public TokenEntry apply(String token) {\n+                                return new TokenEntry(refreshToken);\n+                            }\n+                        });\n+\n+                // synchronize on the entry associated with the current subject\n+                synchronized (entry) {\n+                    Uni<SecurityIdentity> cf = Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                        @Override\n+                        public void accept(UniEmitter<? super SecurityIdentity> emitter) {\n+                            OAuth2TokenImpl token = new OAuth2TokenImpl(configContext.auth, new JsonObject());\n+\n+                            // always get the last token\n+                            token.principal().put(\"refresh_token\", entry.getToken());\n+\n+                            token.refresh(new Handler<AsyncResult<Void>>() {\n+                                @Override\n+                                public void handle(AsyncResult<Void> result) {\n+                                    if (result.succeeded()) {\n+                                        authenticate(identityProviderManager,\n+                                                new IdTokenCredential(token.opaqueIdToken(), context))\n+                                                        .subscribe().with(new Consumer<SecurityIdentity>() {\n+                                                            @Override\n+                                                            public void accept(SecurityIdentity identity) {\n+                                                                // after a successful refresh, rebuild the identity and update the cookie \n+                                                                processSuccessfulAuthentication(context, configContext, token,\n+                                                                        identity);\n+                                                                // update the token so that blocking threads get the latest one\n+                                                                entry.setToken(token.opaqueRefreshToken());\n+                                                                emitter.complete(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "625e17ed0fe29743257238edf7032c94c54c50ff"}, "originalPosition": 295}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "625e17ed0fe29743257238edf7032c94c54c50ff", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/625e17ed0fe29743257238edf7032c94c54c50ff", "committedDate": "2020-04-13T20:47:34Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "6b5edfee40acf0c30824113446f4677b5c5a57af", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/6b5edfee40acf0c30824113446f4677b5c5a57af", "committedDate": "2020-04-13T22:23:24Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6b5edfee40acf0c30824113446f4677b5c5a57af", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/6b5edfee40acf0c30824113446f4677b5c5a57af", "committedDate": "2020-04-13T22:23:24Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "7dc3131b86e6b74ab0736fcd957545397bb61a66", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/7dc3131b86e6b74ab0736fcd957545397bb61a66", "committedDate": "2020-04-13T22:27:11Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7dc3131b86e6b74ab0736fcd957545397bb61a66", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/7dc3131b86e6b74ab0736fcd957545397bb61a66", "committedDate": "2020-04-13T22:27:11Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "1051986b26679a9f5a0d02854b06cdbcf7968f42", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/1051986b26679a9f5a0d02854b06cdbcf7968f42", "committedDate": "2020-04-13T22:28:44Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNTY5MTY3", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-392569167", "createdAt": "2020-04-14T02:52:24Z", "commit": {"oid": "1051986b26679a9f5a0d02854b06cdbcf7968f42"}, "state": "DISMISSED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMjo1MjoyNFrOGE8SCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMzoxMDo1MlrOGE8lng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgzNTE0Ng==", "bodyText": "Why do we need this map? I don't really like the idea of making the authenticators stateful, and I really don't like the arbitrary size limit.", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407835146", "createdAt": "2020-04-14T02:52:24Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -301,4 +351,114 @@ private void removeCookie(RoutingContext context, TenantConfigContext configCont\n             }\n         }\n     }\n+\n+    private boolean isLogout(RoutingContext context, TenantConfigContext configContext) {\n+        Optional<String> logoutPath = configContext.oidcConfig.logout.path;\n+\n+        if (logoutPath.isPresent()) {\n+            return context.request().absoluteURI().equals(\n+                    buildUri(context, logoutPath.get()));\n+        }\n+\n+        return false;\n+    }\n+\n+    private SecurityIdentity trySilentRefresh(TenantConfigContext configContext, String idToken, String refreshToken,\n+            RoutingContext context, IdentityProviderManager identityProviderManager) {\n+        OidcTenantConfig config = configContext.oidcConfig;\n+\n+        if (config.token.refreshTimeout.isPresent()) {\n+            OAuth2AuthProviderImpl auth = ((OAuth2AuthProviderImpl) configContext.auth);\n+            JWT jwt = auth.getJWT();\n+            JsonObject tokenJson;\n+\n+            try {\n+                tokenJson = jwt.decode(idToken);\n+            } catch (Exception cause) {\n+                throw new AuthenticationCompletionException(cause);\n+            }\n+\n+            Long iat = tokenJson.getLong(\"iat\");\n+            long now = System.currentTimeMillis() / 1000;\n+            Integer timeout = config.token.refreshTimeout.get();\n+\n+            if (now - iat >= timeout) {\n+                String sub = tokenJson.getString(\"sub\");\n+\n+                TokenEntry entry = refreshingTokens.computeIfAbsent(sub,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1051986b26679a9f5a0d02854b06cdbcf7968f42"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgzOTI1MA==", "bodyText": "Even if this is a new token it will still be refreshed?", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407839250", "createdAt": "2020-04-14T03:07:14Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -301,4 +351,114 @@ private void removeCookie(RoutingContext context, TenantConfigContext configCont\n             }\n         }\n     }\n+\n+    private boolean isLogout(RoutingContext context, TenantConfigContext configContext) {\n+        Optional<String> logoutPath = configContext.oidcConfig.logout.path;\n+\n+        if (logoutPath.isPresent()) {\n+            return context.request().absoluteURI().equals(\n+                    buildUri(context, logoutPath.get()));\n+        }\n+\n+        return false;\n+    }\n+\n+    private SecurityIdentity trySilentRefresh(TenantConfigContext configContext, String idToken, String refreshToken,\n+            RoutingContext context, IdentityProviderManager identityProviderManager) {\n+        OidcTenantConfig config = configContext.oidcConfig;\n+\n+        if (config.token.refreshTimeout.isPresent()) {\n+            OAuth2AuthProviderImpl auth = ((OAuth2AuthProviderImpl) configContext.auth);\n+            JWT jwt = auth.getJWT();\n+            JsonObject tokenJson;\n+\n+            try {\n+                tokenJson = jwt.decode(idToken);\n+            } catch (Exception cause) {\n+                throw new AuthenticationCompletionException(cause);\n+            }\n+\n+            Long iat = tokenJson.getLong(\"iat\");\n+            long now = System.currentTimeMillis() / 1000;\n+            Integer timeout = config.token.refreshTimeout.get();\n+\n+            if (now - iat >= timeout) {\n+                String sub = tokenJson.getString(\"sub\");\n+\n+                TokenEntry entry = refreshingTokens.computeIfAbsent(sub,\n+                        new Function<String, TokenEntry>() {\n+                            @Override\n+                            public TokenEntry apply(String token) {\n+                                return new TokenEntry(refreshToken);\n+                            }\n+                        });\n+\n+                // synchronize on the entry associated with the current subject\n+                synchronized (entry) {\n+                    Uni<SecurityIdentity> cf = Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                        @Override\n+                        public void accept(UniEmitter<? super SecurityIdentity> emitter) {\n+                            OAuth2TokenImpl token = new OAuth2TokenImpl(configContext.auth, new JsonObject());\n+\n+                            // always get the last token\n+                            token.principal().put(\"refresh_token\", entry.getToken());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1051986b26679a9f5a0d02854b06cdbcf7968f42"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0MDE1OA==", "bodyText": "So can this bit perform blocking operations? If so you need to check if you are on the IO thread and dispatch to an executor.", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r407840158", "createdAt": "2020-04-14T03:10:52Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -301,4 +348,114 @@ private void removeCookie(RoutingContext context, TenantConfigContext configCont\n             }\n         }\n     }\n+\n+    private boolean isLogout(RoutingContext context, TenantConfigContext configContext) {\n+        Optional<String> logoutPath = configContext.oidcConfig.logout.path;\n+\n+        if (logoutPath.isPresent()) {\n+            return context.request().absoluteURI().equals(\n+                    buildUri(context, logoutPath.get()));\n+        }\n+\n+        return false;\n+    }\n+\n+    private SecurityIdentity trySilentRefresh(TenantConfigContext configContext, String idToken, String refreshToken,\n+            RoutingContext context, IdentityProviderManager identityProviderManager) {\n+        OidcTenantConfig config = configContext.oidcConfig;\n+\n+        if (config.token.refreshTimeout.isPresent()) {\n+            OAuth2AuthProviderImpl auth = ((OAuth2AuthProviderImpl) configContext.auth);\n+            JWT jwt = auth.getJWT();\n+            JsonObject tokenJson;\n+\n+            try {\n+                tokenJson = jwt.decode(idToken);\n+            } catch (Exception cause) {\n+                throw new AuthenticationCompletionException(cause);\n+            }\n+\n+            Long iat = tokenJson.getLong(\"iat\");\n+            long now = System.currentTimeMillis() / 1000;\n+            Integer timeout = config.token.refreshTimeout.get();\n+\n+            if (now - iat >= timeout) {\n+                String sub = tokenJson.getString(\"sub\");\n+\n+                TokenEntry entry = refreshingTokens.computeIfAbsent(sub,\n+                        new Function<String, TokenEntry>() {\n+                            @Override\n+                            public TokenEntry apply(String token) {\n+                                return new TokenEntry(refreshToken);\n+                            }\n+                        });\n+\n+                // synchronize on the entry associated with the current subject\n+                synchronized (entry) {\n+                    Uni<SecurityIdentity> cf = Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                        @Override\n+                        public void accept(UniEmitter<? super SecurityIdentity> emitter) {\n+                            OAuth2TokenImpl token = new OAuth2TokenImpl(configContext.auth, new JsonObject());\n+\n+                            // always get the last token\n+                            token.principal().put(\"refresh_token\", entry.getToken());\n+\n+                            token.refresh(new Handler<AsyncResult<Void>>() {\n+                                @Override\n+                                public void handle(AsyncResult<Void> result) {\n+                                    if (result.succeeded()) {\n+                                        authenticate(identityProviderManager,\n+                                                new IdTokenCredential(token.opaqueIdToken(), context))\n+                                                        .subscribe().with(new Consumer<SecurityIdentity>() {\n+                                                            @Override\n+                                                            public void accept(SecurityIdentity identity) {\n+                                                                // after a successful refresh, rebuild the identity and update the cookie \n+                                                                processSuccessfulAuthentication(context, configContext, token,\n+                                                                        identity);\n+                                                                // update the token so that blocking threads get the latest one\n+                                                                entry.setToken(token.opaqueRefreshToken());\n+                                                                emitter.complete(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNzUxNg=="}, "originalCommit": {"oid": "625e17ed0fe29743257238edf7032c94c54c50ff"}, "originalPosition": 295}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1051986b26679a9f5a0d02854b06cdbcf7968f42", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/1051986b26679a9f5a0d02854b06cdbcf7968f42", "committedDate": "2020-04-13T22:28:44Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "883895b76ad63c35f30af0ca484c3125b2ec7ad4", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/883895b76ad63c35f30af0ca484c3125b2ec7ad4", "committedDate": "2020-04-14T07:56:56Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "883895b76ad63c35f30af0ca484c3125b2ec7ad4", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/883895b76ad63c35f30af0ca484c3125b2ec7ad4", "committedDate": "2020-04-14T07:56:56Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "fc99ef40252c902ff133064c64f09999e13fe871", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/fc99ef40252c902ff133064c64f09999e13fe871", "committedDate": "2020-04-14T08:17:33Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNzcxNDkw", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-392771490", "createdAt": "2020-04-14T09:48:35Z", "commit": {"oid": "fc99ef40252c902ff133064c64f09999e13fe871"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwOTo0ODozNVrOGFG3Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwOTo0ODozNVrOGFG3Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAwODUwMg==", "bodyText": "Pretty sure now this should be AuthenticationCompletionException to get 401 out if it is something anything but expiry related.", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r408008502", "createdAt": "2020-04-14T09:48:35Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/CodeAuthenticationMechanism.java", "diffHunk": "@@ -66,23 +73,56 @@ private static QuarkusSecurityIdentity augmentIdentity(SecurityIdentity security\n                     public Uni<Boolean> apply(Permission permission) {\n                         return securityIdentity.checkPermission(permission);\n                     }\n-                })\n-                .build();\n+                }).build();\n     }\n \n     public Uni<SecurityIdentity> authenticate(RoutingContext context,\n             IdentityProviderManager identityProviderManager,\n             DefaultTenantConfigResolver resolver) {\n         Cookie sessionCookie = context.request().getCookie(SESSION_COOKIE_NAME);\n+        TenantConfigContext configContext = resolver.resolve(context, true);\n \n         // if session already established, try to re-authenticate\n         if (sessionCookie != null) {\n             String[] tokens = sessionCookie.getValue().split(COOKIE_DELIM);\n+            String idToken = tokens[0];\n+            String accessToken = tokens[1];\n+            String refreshToken = tokens[2];\n+\n             return authenticate(identityProviderManager, new IdTokenCredential(tokens[0], context))\n                     .map(new Function<SecurityIdentity, SecurityIdentity>() {\n                         @Override\n-                        public SecurityIdentity apply(SecurityIdentity securityIdentity) {\n-                            return augmentIdentity(securityIdentity, tokens[1], tokens[2], context);\n+                        public SecurityIdentity apply(SecurityIdentity identity) {\n+                            if (isLogout(context, configContext)) {\n+                                throw redirectToLogoutEndpoint(context, configContext, idToken);\n+                            }\n+\n+                            return augmentIdentity(identity, accessToken, refreshToken, context);\n+                        }\n+                    }).on().failure().recoverWithItem(new Function<Throwable, SecurityIdentity>() {\n+                        @Override\n+                        public SecurityIdentity apply(Throwable throwable) {\n+                            if (throwable instanceof AuthenticationRedirectException) {\n+                                throw AuthenticationRedirectException.class.cast(throwable);\n+                            }\n+\n+                            Throwable cause = throwable.getCause();\n+\n+                            // we should have proper exception hierarchy to represent token expiration errors\n+                            if (cause != null && !cause.getMessage().equalsIgnoreCase(\"expired token\")) {\n+                                throw new AuthenticationFailedException(throwable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc99ef40252c902ff133064c64f09999e13fe871"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNzc5NjYy", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-392779662", "createdAt": "2020-04-14T09:59:35Z", "commit": {"oid": "fc99ef40252c902ff133064c64f09999e13fe871"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwOTo1OTozNVrOGFHR0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwOTo1OTozNVrOGFHR0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAxNTMxNA==", "bodyText": "@pedroigor But what if the refresh is never even utilized ? Example the user will logout manually before the refresh is even needed ? I wonder if what Stuart said can be done somehow, switch to the blocking mode dynamically only for refresh.\n@stuartwdouglas As Pedro said, the blocking vs event loop decision is done early, but we don't even know if refresh will be needed for a current request at that stage, is it possible to switch back to the blocking mode when the request is already running in the even loop ?", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r408015314", "createdAt": "2020-04-14T09:59:35Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/DefaultTenantConfigResolver.java", "diffHunk": "@@ -81,7 +81,14 @@ private TenantConfigContext getTenantConfigFromTenantResolver(RoutingContext con\n     }\n \n     boolean isBlocking(RoutingContext context) {\n-        return getTenantConfigFromConfigResolver(context, false) == null;\n+        TenantConfigContext resolver = getTenantConfigFromConfigResolver(context, false);\n+\n+        if (resolver != null) {\n+            // we always run blocking if refresh token is enabled even if the tenant was already resolved", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc99ef40252c902ff133064c64f09999e13fe871"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNzgyOTQ0", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-392782944", "createdAt": "2020-04-14T10:03:53Z", "commit": {"oid": "fc99ef40252c902ff133064c64f09999e13fe871"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMDowMzo1M1rOGFHb_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMDowMzo1M1rOGFHb_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAxNzkxOQ==", "bodyText": "@pedroigor Would you like to support the case where no discovery is possible ? We simply add that extra property and check if no discovered path is available. I can do it later though, up to you", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r408017919", "createdAt": "2020-04-14T10:03:53Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcRecorder.java", "diffHunk": "@@ -165,6 +165,27 @@ public void handle(AsyncResult<OAuth2Auth> event) {\n                 });\n \n                 auth = cf.join();\n+\n+                if (!ApplicationType.WEB_APP.equals(oidcConfig.applicationType)) {\n+                    if (oidcConfig.token.refreshTimeout.isPresent()) {\n+                        throw new RuntimeException(\n+                                \"The logout path can only be enabled for \" + ApplicationType.WEB_APP + \" application types\");\n+                    }\n+                    if (oidcConfig.logout.path.isPresent()) {\n+                        throw new RuntimeException(\n+                                \"The logout path can only be enabled for \" + ApplicationType.WEB_APP + \" application types\");\n+                    }\n+                }\n+\n+                String endSessionEndpoint = OAuth2AuthProviderImpl.class.cast(auth).getConfig().getLogoutPath();\n+\n+                if (oidcConfig.logout.path.isPresent()) {\n+                    if (endSessionEndpoint == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc99ef40252c902ff133064c64f09999e13fe871"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNzg5ODk3", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-392789897", "createdAt": "2020-04-14T10:13:50Z", "commit": {"oid": "fc99ef40252c902ff133064c64f09999e13fe871"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMDoxMzo1MFrOGFHzKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMDoxMzo1MFrOGFHzKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyMzg1MQ==", "bodyText": "@pedroigor As mentioned earlier, IMHO it would be better if we drop silent and any reference to the logout. We just say something like \"Refresh token timeout in seconds. If enabled, the expired ID token will be refreshed if the difference between the current time and the issued at time is less than this timeout\" (but in a better worded way :-) ). And may be add \" and will invalidate the old sessions at the RP and OP sites.\" or similar as you prefer", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r408023851", "createdAt": "2020-04-14T10:13:50Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcTenantConfig.java", "diffHunk": "@@ -530,6 +580,14 @@ public static Token fromAudience(String... audience) {\n         @ConfigItem\n         public Optional<String> principalClaim = Optional.empty();\n \n+        /**\n+         * The time, in seconds, that tokens should be silently refreshed so that tokens with no active session at the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc99ef40252c902ff133064c64f09999e13fe871"}, "originalPosition": 76}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNzkwODMz", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-392790833", "createdAt": "2020-04-14T10:15:10Z", "commit": {"oid": "fc99ef40252c902ff133064c64f09999e13fe871"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMDoxNToxMFrOGFH2dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMDoxNToxMFrOGFH2dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyNDY5NQ==", "bodyText": "In all other cases we set Optional internally, so just pass Integer", "url": "https://github.com/quarkusio/quarkus/pull/8512#discussion_r408024695", "createdAt": "2020-04-14T10:15:10Z", "author": {"login": "sberyozkin"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcTenantConfig.java", "diffHunk": "@@ -561,6 +619,14 @@ public void setExpirationGrace(int expirationGrace) {\n         public void setPrincipalClaim(String principalClaim) {\n             this.principalClaim = Optional.of(principalClaim);\n         }\n+\n+        public Optional<Integer> getRefreshTimeout() {\n+            return refreshTimeout;\n+        }\n+\n+        public void setRefreshTimeout(Optional<Integer> refreshTimeout) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc99ef40252c902ff133064c64f09999e13fe871"}, "originalPosition": 95}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fc99ef40252c902ff133064c64f09999e13fe871", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/fc99ef40252c902ff133064c64f09999e13fe871", "committedDate": "2020-04-14T08:17:33Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "e569b9f1f062ce4f635ffcbe553e191e9465bd0c", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/e569b9f1f062ce4f635ffcbe553e191e9465bd0c", "committedDate": "2020-04-14T15:23:27Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78a539fbb8694f1c84ef1d1f8afde96d5ff0ad7b", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/78a539fbb8694f1c84ef1d1f8afde96d5ff0ad7b", "committedDate": "2020-04-17T12:29:14Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e569b9f1f062ce4f635ffcbe553e191e9465bd0c", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/e569b9f1f062ce4f635ffcbe553e191e9465bd0c", "committedDate": "2020-04-14T15:23:27Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}, "afterCommit": {"oid": "78a539fbb8694f1c84ef1d1f8afde96d5ff0ad7b", "author": {"user": {"login": "pedroigor", "name": "Pedro Igor"}}, "url": "https://github.com/quarkusio/quarkus/commit/78a539fbb8694f1c84ef1d1f8afde96d5ff0ad7b", "committedDate": "2020-04-17T12:29:14Z", "message": "[fixes #4481] - RP-Initiated Logout and session verification"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2MzMwMTgw", "url": "https://github.com/quarkusio/quarkus/pull/8512#pullrequestreview-396330180", "createdAt": "2020-04-20T10:28:18Z", "commit": {"oid": "78a539fbb8694f1c84ef1d1f8afde96d5ff0ad7b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4530, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}