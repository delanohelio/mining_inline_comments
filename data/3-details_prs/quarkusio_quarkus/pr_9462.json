{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwMTk4MjM5", "number": 9462, "title": "Add a TROUBLESHOOTING.md page with performance related tips", "bodyText": "Following this discussion on Zulip: https://quarkusio.zulipchat.com/#narrow/stream/187038-dev/topic/Performance", "createdAt": "2020-05-19T15:33:32Z", "url": "https://github.com/quarkusio/quarkus/pull/9462", "merged": true, "mergeCommit": {"oid": "cf41109f191c91fe9e796ab1259fa203775ef814"}, "closed": true, "closedAt": "2020-06-24T07:10:53Z", "author": {"login": "loicmathieu"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABci2VA4AFqTQxNDU3NDg1NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcjFby5gBqjMzNTU1MDEzNTg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NTc0ODU1", "url": "https://github.com/quarkusio/quarkus/pull/9462#pullrequestreview-414574855", "createdAt": "2020-05-19T15:37:20Z", "commit": {"oid": "a2fda849ff22860417cc7632e7157a802463d02b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjE5NDEy", "url": "https://github.com/quarkusio/quarkus/pull/9462#pullrequestreview-414619412", "createdAt": "2020-05-19T16:26:57Z", "commit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "state": "COMMENTED", "comments": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjoyNjo1OFrOGXolbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNjo1MToyN1rOGXpkww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzNTM3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Or definitively using `sysctl`:\n          \n          \n            \n            Or permanently using `sysctl`:", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427435374", "createdAt": "2020-05-19T16:26:58Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzNTUyMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For your session:\n          \n          \n            \n            For your terminal session:", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427435521", "createdAt": "2020-05-19T16:27:10Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzNjU0Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n          \n          \n            \n            If you want a deeper introduction to Async Profiler, do checkout [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427436542", "createdAt": "2020-05-19T16:28:38Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzNjk4OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            you must make some OS configuration.\n          \n          \n            \n            you must first apply a couple OS configuration options.", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427436989", "createdAt": "2020-05-19T16:29:18Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzOTA4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n          \n          \n            \n            If needed, see [this](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling) section in the documentation site for details.", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427439085", "createdAt": "2020-05-19T16:32:16Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MDI1OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n          \n          \n            \n            To profile application while it is running, it is recommended to use the command line as you can choose when to start the profiler and prevent your profile data from being bloated with startup events. <br/>", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427440258", "createdAt": "2020-05-19T16:33:41Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MTIxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n          \n          \n            \n            This can be important as any application performs a lot of bootstrapping operation upon startup that won't occur at any other during the application lifecycle. <br/>", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427441214", "createdAt": "2020-05-19T16:35:08Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MTQ4NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n          \n          \n            \n            By starting the profiling on demand, you prevent these bootstrap instructions from being part of the profile data.", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427441484", "createdAt": "2020-05-19T16:35:37Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MTkxMQ==", "bodyText": "Maybe we  should have some links for wrk(2), gatling, hyperfoil etc...", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427441911", "createdAt": "2020-05-19T16:36:17Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MzY5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n          \n          \n            \n            It is usually advised to profile an application under load. Such load could be created by a load generator tool (wrk, gatling, ...)", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427443691", "createdAt": "2020-05-19T16:39:11Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NDkxNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n          \n          \n            \n            and to start profiling only after some warmup time to allow Java's Just In Time compiler of Java to optimize your application code (not to mention giving the opportunity for database caches to warmup, etc...).", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427444915", "createdAt": "2020-05-19T16:41:02Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NTAxMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To start CPU profiling, enter the following command:\n          \n          \n            \n            To start CPU profiling, execute the following command:", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427445010", "createdAt": "2020-05-19T16:41:13Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NTE3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n          \n          \n            \n            `-b 4000000` is used to increase the frame buffer size as the default is often too small.", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427445171", "createdAt": "2020-05-19T16:41:30Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NTQ3OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n          \n          \n            \n            To end profiling and gather the results you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427445479", "createdAt": "2020-05-19T16:41:59Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NTgyMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n          \n          \n            \n            It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the `svg` file extension)", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427445821", "createdAt": "2020-05-19T16:42:32Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NjcwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n          \n          \n            \n            One very useful option is `-s` (or `--simple`) that results in simple class names being used instead of FQDNs, thus making the FlameGraph more readable (at cost of not showing the package names of classes). <br/>", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427446708", "createdAt": "2020-05-19T16:43:52Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NzI1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To start allocation profiling, enter the following command:\n          \n          \n            \n            To start allocation profiling, execute the following command:", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427447254", "createdAt": "2020-05-19T16:44:42Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0ODE5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n          \n          \n            \n            `-e` (or `--event`) allow to specify the type of event to profile. The default profile type is CPU, but in this case as we are interested in allocation profiling, we specify `alloc` as the `-e` value.", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427448197", "createdAt": "2020-05-19T16:46:12Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0ODYzMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Then you can stop your profiling the same way as for CPU profiling.\n          \n          \n            \n            Stopping allocation profiling is done in the same way as for the previously shown CPU profiling.", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427448630", "createdAt": "2020-05-19T16:46:53Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n+\n+Then you can stop your profiling the same way as for CPU profiling.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0OTAwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Here is some example command lines:\n          \n          \n            \n            Some example usages are:", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427449008", "createdAt": "2020-05-19T16:47:28Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n+\n+Then you can stop your profiling the same way as for CPU profiling.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/alloc-profile.svg --width 1600 <pid>\n+```\n+\n+## Profiling application startup with Async Profiler\n+\n+When you want to profile application startup, you cannot use the command line tool as you need a way to start the profiler with your application.\n+\n+For this case, the Java agent is the best tool.\n+It will start profiling when you start the application, then record the profiling data when the application exits.\n+\n+Here is some example command lines:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0OTI1NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Be careful that short options are not supported inside the agent, you need to use the long version.\n          \n          \n            \n            Note that short options are not supported inside the agent, you need to use their long versions.", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427449255", "createdAt": "2020-05-19T16:47:48Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n+\n+Then you can stop your profiling the same way as for CPU profiling.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/alloc-profile.svg --width 1600 <pid>\n+```\n+\n+## Profiling application startup with Async Profiler\n+\n+When you want to profile application startup, you cannot use the command line tool as you need a way to start the profiler with your application.\n+\n+For this case, the Java agent is the best tool.\n+It will start profiling when you start the application, then record the profiling data when the application exits.\n+\n+Here is some example command lines:\n+\n+```shell script\n+# profile CPU startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+\n+# profile allocation startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+```\n+\n+Be careful that short options are not supported inside the agent, you need to use the long version.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ1MDA3Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            By default, Async Profiler sample events each 10ms, for debugging Quarkus startup issue this is too much as we start very fast ;) <br/>\n          \n          \n            \n            By default, Async Profiler sample events every 10ms. When it comes to profiling / debugging a Quarkus startup issue, this value is often too high as Quarkus starst very fast ;) <br/>", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427450076", "createdAt": "2020-05-19T16:49:07Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n+\n+Then you can stop your profiling the same way as for CPU profiling.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/alloc-profile.svg --width 1600 <pid>\n+```\n+\n+## Profiling application startup with Async Profiler\n+\n+When you want to profile application startup, you cannot use the command line tool as you need a way to start the profiler with your application.\n+\n+For this case, the Java agent is the best tool.\n+It will start profiling when you start the application, then record the profiling data when the application exits.\n+\n+Here is some example command lines:\n+\n+```shell script\n+# profile CPU startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+\n+# profile allocation startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+```\n+\n+Be careful that short options are not supported inside the agent, you need to use the long version.\n+\n+By default, Async Profiler sample events each 10ms, for debugging Quarkus startup issue this is too much as we start very fast ;) <br/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ1MDUxOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            That's why I configure the profiling interval to 1000000ns (so 1ms).\n          \n          \n            \n            For that reason, it is not uncommon to configure the profiling interval to 1000000ns (i.e. 1ms).", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427450518", "createdAt": "2020-05-19T16:49:52Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n+\n+Then you can stop your profiling the same way as for CPU profiling.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/alloc-profile.svg --width 1600 <pid>\n+```\n+\n+## Profiling application startup with Async Profiler\n+\n+When you want to profile application startup, you cannot use the command line tool as you need a way to start the profiler with your application.\n+\n+For this case, the Java agent is the best tool.\n+It will start profiling when you start the application, then record the profiling data when the application exits.\n+\n+Here is some example command lines:\n+\n+```shell script\n+# profile CPU startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+\n+# profile allocation startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+```\n+\n+Be careful that short options are not supported inside the agent, you need to use the long version.\n+\n+By default, Async Profiler sample events each 10ms, for debugging Quarkus startup issue this is too much as we start very fast ;) <br/>\n+That's why I configure the profiling interval to 1000000ns (so 1ms).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ1MTU4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For profiling Quarkus dev mode, you also need to use the Java agent, you can use it the same way as for production run, but you need to pass the `agentpath` option inside the `jvm.args` system property.\n          \n          \n            \n            For profiling Quarkus dev mode, the Java agent is again necessary. It can be used in the same way as for the production application with the exception that `agentpath` option needs to be set via the `jvm.args` system property.", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427451587", "createdAt": "2020-05-19T16:51:27Z", "author": {"login": "geoand"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n+\n+Then you can stop your profiling the same way as for CPU profiling.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/alloc-profile.svg --width 1600 <pid>\n+```\n+\n+## Profiling application startup with Async Profiler\n+\n+When you want to profile application startup, you cannot use the command line tool as you need a way to start the profiler with your application.\n+\n+For this case, the Java agent is the best tool.\n+It will start profiling when you start the application, then record the profiling data when the application exits.\n+\n+Here is some example command lines:\n+\n+```shell script\n+# profile CPU startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+\n+# profile allocation startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+```\n+\n+Be careful that short options are not supported inside the agent, you need to use the long version.\n+\n+By default, Async Profiler sample events each 10ms, for debugging Quarkus startup issue this is too much as we start very fast ;) <br/>\n+That's why I configure the profiling interval to 1000000ns (so 1ms).\n+\n+## Profiling application dev mode with Async Profiler\n+\n+For profiling Quarkus dev mode, you also need to use the Java agent, you can use it the same way as for production run, but you need to pass the `agentpath` option inside the `jvm.args` system property.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 132}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjY5OTYz", "url": "https://github.com/quarkusio/quarkus/pull/9462#pullrequestreview-414669963", "createdAt": "2020-05-19T17:29:46Z", "commit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzoyOTo0NlrOGXrDKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzoyOTo0NlrOGXrDKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NTc1Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # On CentOS, RHEL and some other RPM-based distributions\n          \n          \n            \n            # On CentOS, RHEL and some other RPM-based distributions - Java 8", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427475753", "createdAt": "2020-05-19T17:29:46Z", "author": {"login": "johnaohara"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjYyNzU4", "url": "https://github.com/quarkusio/quarkus/pull/9462#pullrequestreview-414662758", "createdAt": "2020-05-19T17:20:41Z", "commit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "state": "DISMISSED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzoyMDo0MVrOGXqr-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzozMDoxNFrOGXrEoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2OTgxOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To help us to troubleshoot your issues, we will need some performance insight from your application.\n          \n          \n            \n            To help us troubleshooting your issues, we will need some performance insights from your application.", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427469818", "createdAt": "2020-05-19T17:20:41Z", "author": {"login": "gsmet"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ2OTkzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n          \n          \n            \n            On Linux or macOS, one of the best way to gather performance insights would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph)", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427469939", "createdAt": "2020-05-19T17:20:54Z", "author": {"login": "gsmet"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MDQwOQ==", "bodyText": "<br/>? Maybe we can avoid that :)", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427470409", "createdAt": "2020-05-19T17:21:36Z", "author": {"login": "gsmet"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MTAzOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For allocation profiling, you also need to install HotStop debug symbol.\n          \n          \n            \n            For allocation profiling, you also need to install HotSpot debug symbol.", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427471038", "createdAt": "2020-05-19T17:22:32Z", "author": {"login": "gsmet"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MTM0Mg==", "bodyText": "I'm not sure I would recommend that. I think most people don't use the JDK from the distribution.", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427471342", "createdAt": "2020-05-19T17:23:01Z", "author": {"login": "gsmet"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MTYzMQ==", "bodyText": "what is documentation site?", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427471631", "createdAt": "2020-05-19T17:23:27Z", "author": {"login": "gsmet"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzOTA4NQ=="}, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MTc1NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Asych Profiler comes with a Java agent, and a command line.\n          \n          \n            \n            Async Profiler comes with a Java agent, and a command line.", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427471755", "createdAt": "2020-05-19T17:23:40Z", "author": {"login": "gsmet"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MTk5MQ==", "bodyText": "Let's remove all the <br/>", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427471991", "createdAt": "2020-05-19T17:24:01Z", "author": {"login": "gsmet"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0MDI1OA=="}, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MjU5Mw==", "bodyText": "It's unclear where profiler.sh comes from.", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427472593", "createdAt": "2020-05-19T17:25:03Z", "author": {"login": "gsmet"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3Mjg5Nw==", "bodyText": "s/this will tells/this will tell/", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427472897", "createdAt": "2020-05-19T17:25:29Z", "author": {"login": "gsmet"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NTQ3OQ=="}, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MzA5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n          \n          \n            \n            The output is a text file that is not really usable, so let's use our preferred performance representation: the FlameGraph.", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427473097", "createdAt": "2020-05-19T17:25:47Z", "author": {"login": "gsmet"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3MzQwNg==", "bodyText": "s/automatically detect/automatically detects/", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427473406", "createdAt": "2020-05-19T17:26:14Z", "author": {"login": "gsmet"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NTgyMQ=="}, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3Mzg3Nw==", "bodyText": "FQCNs?", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427473877", "createdAt": "2020-05-19T17:26:58Z", "author": {"login": "gsmet"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ0NjcwOA=="}, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NDAyNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n          \n          \n            \n            You can also limit the profiling duration by using `-d` (or `--duration`) followed by the duration in seconds.", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427474024", "createdAt": "2020-05-19T17:27:11Z", "author": {"login": "gsmet"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NTAyNA==", "bodyText": "I would remove the smiley.", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427475024", "createdAt": "2020-05-19T17:28:40Z", "author": {"login": "gsmet"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n+\n+Then you can stop your profiling the same way as for CPU profiling.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/alloc-profile.svg --width 1600 <pid>\n+```\n+\n+## Profiling application startup with Async Profiler\n+\n+When you want to profile application startup, you cannot use the command line tool as you need a way to start the profiler with your application.\n+\n+For this case, the Java agent is the best tool.\n+It will start profiling when you start the application, then record the profiling data when the application exits.\n+\n+Here is some example command lines:\n+\n+```shell script\n+# profile CPU startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+\n+# profile allocation startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+```\n+\n+Be careful that short options are not supported inside the agent, you need to use the long version.\n+\n+By default, Async Profiler sample events each 10ms, for debugging Quarkus startup issue this is too much as we start very fast ;) <br/>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ1MDA3Ng=="}, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NTMzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can also configure the `jvm.args` system property directly inside the `quarkus-maven-plugin` configuration inside your pom.xml.\n          \n          \n            \n            You can also configure the `jvm.args` system property directly inside the `quarkus-maven-plugin` section of your pom.xml.", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427475331", "createdAt": "2020-05-19T17:29:09Z", "author": {"login": "gsmet"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n+\n+Then you can stop your profiling the same way as for CPU profiling.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/alloc-profile.svg --width 1600 <pid>\n+```\n+\n+## Profiling application startup with Async Profiler\n+\n+When you want to profile application startup, you cannot use the command line tool as you need a way to start the profiler with your application.\n+\n+For this case, the Java agent is the best tool.\n+It will start profiling when you start the application, then record the profiling data when the application exits.\n+\n+Here is some example command lines:\n+\n+```shell script\n+# profile CPU startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+\n+# profile allocation startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+```\n+\n+Be careful that short options are not supported inside the agent, you need to use the long version.\n+\n+By default, Async Profiler sample events each 10ms, for debugging Quarkus startup issue this is too much as we start very fast ;) <br/>\n+That's why I configure the profiling interval to 1000000ns (so 1ms).\n+\n+## Profiling application dev mode with Async Profiler\n+\n+For profiling Quarkus dev mode, you also need to use the Java agent, you can use it the same way as for production run, but you need to pass the `agentpath` option inside the `jvm.args` system property.\n+\n+```shell script\n+# profile CPU startup\n+mvn quarkus:dev -Djvm.args=\"agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\"\n+\n+# profile allocation startup\n+mvn quarkus:dev -Djvm.args=\"-agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\"\n+```\n+\n+You can also configure the `jvm.args` system property directly inside the `quarkus-maven-plugin` configuration inside your pom.xml.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NTQ0Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ## And what about Windows ?\n          \n          \n            \n            ## And what about Windows?", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427475443", "createdAt": "2020-05-19T17:29:19Z", "author": {"login": "gsmet"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n+\n+Then you can stop your profiling the same way as for CPU profiling.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/alloc-profile.svg --width 1600 <pid>\n+```\n+\n+## Profiling application startup with Async Profiler\n+\n+When you want to profile application startup, you cannot use the command line tool as you need a way to start the profiler with your application.\n+\n+For this case, the Java agent is the best tool.\n+It will start profiling when you start the application, then record the profiling data when the application exits.\n+\n+Here is some example command lines:\n+\n+```shell script\n+# profile CPU startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+\n+# profile allocation startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+```\n+\n+Be careful that short options are not supported inside the agent, you need to use the long version.\n+\n+By default, Async Profiler sample events each 10ms, for debugging Quarkus startup issue this is too much as we start very fast ;) <br/>\n+That's why I configure the profiling interval to 1000000ns (so 1ms).\n+\n+## Profiling application dev mode with Async Profiler\n+\n+For profiling Quarkus dev mode, you also need to use the Java agent, you can use it the same way as for production run, but you need to pass the `agentpath` option inside the `jvm.args` system property.\n+\n+```shell script\n+# profile CPU startup\n+mvn quarkus:dev -Djvm.args=\"agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\"\n+\n+# profile allocation startup\n+mvn quarkus:dev -Djvm.args=\"-agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\"\n+```\n+\n+You can also configure the `jvm.args` system property directly inside the `quarkus-maven-plugin` configuration inside your pom.xml.\n+\n+## And what about Windows ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NTU2NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The following java options will enable JFR to record profiling data inside a `myrecording.jfr` file that can then be used by JMC - Java Mission Control for analysis.\n          \n          \n            \n            The following Java options will enable JFR to record profiling data inside a `myrecording.jfr` file that can then be used by JMC - Java Mission Control for analysis.", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427475564", "createdAt": "2020-05-19T17:29:32Z", "author": {"login": "gsmet"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n+\n+Then you can stop your profiling the same way as for CPU profiling.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/alloc-profile.svg --width 1600 <pid>\n+```\n+\n+## Profiling application startup with Async Profiler\n+\n+When you want to profile application startup, you cannot use the command line tool as you need a way to start the profiler with your application.\n+\n+For this case, the Java agent is the best tool.\n+It will start profiling when you start the application, then record the profiling data when the application exits.\n+\n+Here is some example command lines:\n+\n+```shell script\n+# profile CPU startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+\n+# profile allocation startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+```\n+\n+Be careful that short options are not supported inside the agent, you need to use the long version.\n+\n+By default, Async Profiler sample events each 10ms, for debugging Quarkus startup issue this is too much as we start very fast ;) <br/>\n+That's why I configure the profiling interval to 1000000ns (so 1ms).\n+\n+## Profiling application dev mode with Async Profiler\n+\n+For profiling Quarkus dev mode, you also need to use the Java agent, you can use it the same way as for production run, but you need to pass the `agentpath` option inside the `jvm.args` system property.\n+\n+```shell script\n+# profile CPU startup\n+mvn quarkus:dev -Djvm.args=\"agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\"\n+\n+# profile allocation startup\n+mvn quarkus:dev -Djvm.args=\"-agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\"\n+```\n+\n+You can also configure the `jvm.args` system property directly inside the `quarkus-maven-plugin` configuration inside your pom.xml.\n+\n+## And what about Windows ?\n+\n+If you are on Windows, you can still get useful performance insights using JFR - Java Flight Recorder.\n+\n+The following java options will enable JFR to record profiling data inside a `myrecording.jfr` file that can then be used by JMC - Java Mission Control for analysis.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NTc4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Here I configure JFR with a deeper stack depth as the default is usually not enough.\n          \n          \n            \n            Here we configure JFR with a deeper stack depth as the default is usually not enough.", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427475785", "createdAt": "2020-05-19T17:29:49Z", "author": {"login": "gsmet"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n+\n+### Allocation profiling\n+\n+To start allocation profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 -e alloc <pid>\n+```\n+\n+`-e` (or `--event`) allow to give the event to profile, by default it's CPU, here we want allocation profiling.\n+\n+Then you can stop your profiling the same way as for CPU profiling.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/alloc-profile.svg --width 1600 <pid>\n+```\n+\n+## Profiling application startup with Async Profiler\n+\n+When you want to profile application startup, you cannot use the command line tool as you need a way to start the profiler with your application.\n+\n+For this case, the Java agent is the best tool.\n+It will start profiling when you start the application, then record the profiling data when the application exits.\n+\n+Here is some example command lines:\n+\n+```shell script\n+# profile CPU startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+\n+# profile allocation startup\n+java -agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\\\n+    -jar my-application.jar\n+```\n+\n+Be careful that short options are not supported inside the agent, you need to use the long version.\n+\n+By default, Async Profiler sample events each 10ms, for debugging Quarkus startup issue this is too much as we start very fast ;) <br/>\n+That's why I configure the profiling interval to 1000000ns (so 1ms).\n+\n+## Profiling application dev mode with Async Profiler\n+\n+For profiling Quarkus dev mode, you also need to use the Java agent, you can use it the same way as for production run, but you need to pass the `agentpath` option inside the `jvm.args` system property.\n+\n+```shell script\n+# profile CPU startup\n+mvn quarkus:dev -Djvm.args=\"agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=cpu,file=startup-cpu-profile.svg,interval=1000000,width=1600,simple\"\n+\n+# profile allocation startup\n+mvn quarkus:dev -Djvm.args=\"-agentpath:/path/to/async-profiler/build/libasyncProfiler.so=start,event=alloc,file=/tmp/startup-alloc-profile.svg,interval=1000000,width=1600,simple\"\n+```\n+\n+You can also configure the `jvm.args` system property directly inside the `quarkus-maven-plugin` configuration inside your pom.xml.\n+\n+## And what about Windows ?\n+\n+If you are on Windows, you can still get useful performance insights using JFR - Java Flight Recorder.\n+\n+The following java options will enable JFR to record profiling data inside a `myrecording.jfr` file that can then be used by JMC - Java Mission Control for analysis.\n+\n+```shell script\n+-XX:+FlightRecorder -XX:StartFlightRecording=filename=myrecording.jfr,settings=profile -XX:FlightRecorderOptions=stackdepth=64\n+```\n+\n+Here I configure JFR with a deeper stack depth as the default is usually not enough.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NjEyOA==", "bodyText": "General comment: s/FlameGraphs/flame graphs/g", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427476128", "createdAt": "2020-05-19T17:30:14Z", "author": {"login": "gsmet"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 3}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0Njc3NDAz", "url": "https://github.com/quarkusio/quarkus/pull/9462#pullrequestreview-414677403", "createdAt": "2020-05-19T17:39:16Z", "commit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzozOToxN1rOGXrbXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzo0NjoxN1rOGXrs5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4MTk0OQ==", "bodyText": "I wanted to add a suggestion here, but suggestion syntax is the same as a code block;\nOn CentOS, RHEL and some other RPM-based distributions - Java 11\ndebuginfo-install java-11-openjdk", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427481949", "createdAt": "2020-05-19T17:39:17Z", "author": {"login": "johnaohara"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4NjQzOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.\n          \n          \n            \n            You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds. If you use the `--duration` option, the output file will be created automatically at the end of the duration period. You do not need to start and stop the profiler.", "url": "https://github.com/quarkusio/quarkus/pull/9462#discussion_r427486438", "createdAt": "2020-05-19T17:46:17Z", "author": {"login": "johnaohara"}, "path": "TROUBLESHOOTING.md", "diffHunk": "@@ -0,0 +1,155 @@\n+# Troubleshooting performance issues\n+\n+Performance is at the heart of Quarkus.\n+\n+If you are facing performance issues (runtime or startup issues), and would like to discuss them with the Quarkus Team,\n+you are more than welcome on our [mailing list](https://groups.google.com/d/forum/quarkus-dev),\n+[Zulip chat](https://quarkusio.zulipchat.com) or [Github issue tracker](https://github.com/quarkusio/quarkus/issues).\n+\n+To help us to troubleshoot your issues, we will need some performance insight from your application.\n+\n+On Linux or macOS, one of the best way to gather performance insight would be to generate CPU and allocation [FlameGraphs](https://github.com/brendangregg/FlameGraph) \n+via [Async Profiler](https://github.com/jvm-profiling-tools/async-profiler).\n+\n+If you want a deeper introduction to Async Profiler, go read [this article](https://hackernoon.com/profiling-java-applications-with-async-profiler-049s2790).\n+\n+## Installing Async Profiler\n+\n+To install Async Profiler, go to the [release page](https://github.com/jvm-profiling-tools/async-profiler/releases) and download the latest release.\n+\n+Async Profiler depends on `perf_events`. <br/>\n+To allow capturing kernel call stacks using `perf_events` from a non-root process,\n+you must make some OS configuration.\n+\n+For your session:\n+\n+```shell script\n+echo 1 | sudo tee /proc/sys/kernel/perf_event_paranoid\n+echo 0 | sudo tee /proc/sys/kernel/kptr_restrict\n+```\n+\n+Or definitively using `sysctl`:\n+\n+```shell script\n+sudo sysctl -w kernel.perf_event_paranoid=1\n+sudo sysctl -w kernel.kptr_restrict=0\n+```\n+\n+For allocation profiling, you also need to install HotStop debug symbol.\n+\n+Depending on your Linux and Java distribution this can be done via:\n+\n+```shell script\n+# Ubuntu/Debian - Java 8\n+apt install openjdk-8-dbg\n+\n+# Ubuntu/Debian - Java 11\n+ apt install openjdk-11-dbg\n+\n+# On CentOS, RHEL and some other RPM-based distributions\n+debuginfo-install java-1.8.0-openjdk\n+```\n+\n+If needed, see this section in the documentation site for details: [allocation profiling](https://github.com/jvm-profiling-tools/async-profiler#allocation-profiling).\n+\n+## Profiling application runtime with Async Profiler\n+\n+Asych Profiler comes with a Java agent, and a command line.\n+\n+To profile application during its runtime, I recommend using the command line as you can choose when to start the profiler, and avoid your profile to be bloated with startup events. <br/>\n+Indeed, when an application start, it does a lot a bootstraping instruction, that will no more occur during the rest of the run of your application. <br/>\n+By starting the profiling when needed, you avoid these bootstrap instructions to be part of the profile.\n+\n+When you profile an application runtime, it's good to create some load on your application using a load generator tool (wrk, gatling, ...),\n+and to start profiling only after some warmup time to allow the Just In Time compiler of Java to optimize your application code (and your database cache to warmup, etc...).\n+\n+### CPU profiling\n+\n+To start CPU profiling, enter the following command:\n+\n+```shell script\n+./profiler.sh start -b 4000000 <pid>\n+```\n+\n+`-b 4000000` is used to increase the frame buffer size as the default is usually too small.\n+\n+To end profiling and gathering the result you can launch the same command with the `stop` subcommand, this will tells you if the buffer frame was too small. <br/>\n+The output is a text file that is not really usable, so let's use our preferred performance representation: The FlameGraph.\n+\n+```shell script\n+./profiler.sh stop -f /tmp/cpu-profile.svg --width 1600 <pid>\n+```\n+\n+It will create an SVG FlameGraph (Async Profiler automatically detect that you ask for a FlameGraph thanks to the svg extension)\n+that you can open in your browser (and even zoom inside it by clicking on a frame). <br/>\n+The example command will create an SVG of 1600 pixels width.\n+\n+One of our favorite options is `-s` (or `--simple`) that use simple class names instead of FQDNs, the FlameGraph will be more readable with it, but you will lose the package name. <br/>\n+You can also limit the profiling duration by using `-d` (or `--duration`) follow by the duration in seconds.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd3d3059e6d383d5b6334b6dad6afaba4eb174b5"}, "originalPosition": 88}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7da0950819a64843b9e9b40e28a9e9a4667760db", "author": {"user": {"login": "loicmathieu", "name": "Lo\u00efc Mathieu"}}, "url": "https://github.com/quarkusio/quarkus/commit/7da0950819a64843b9e9b40e28a9e9a4667760db", "committedDate": "2020-05-20T07:28:49Z", "message": "WIP Apply suggestions from code review\n\nCo-authored-by: Guillaume Smet <guillaume.smet@gmail.com>\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\nCo-authored-by: John O'Hara <johara@redhat.com>"}, "afterCommit": {"oid": "68c7e8bf8f3d57c139151976a61f4d41ecb66d1e", "author": {"user": {"login": "loicmathieu", "name": "Lo\u00efc Mathieu"}}, "url": "https://github.com/quarkusio/quarkus/commit/68c7e8bf8f3d57c139151976a61f4d41ecb66d1e", "committedDate": "2020-05-20T08:07:37Z", "message": "Add a TROUBLESHOOTING.md page with performance related tips"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2539d5084f621e862e2cafcf94956d09e401130e", "author": {"user": {"login": "loicmathieu", "name": "Lo\u00efc Mathieu"}}, "url": "https://github.com/quarkusio/quarkus/commit/2539d5084f621e862e2cafcf94956d09e401130e", "committedDate": "2020-05-20T08:21:59Z", "message": "Apply suggestions from code review\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>"}, "afterCommit": {"oid": "cbf487948c19603fea184fbb564d85b3d739cdc8", "author": {"user": {"login": "loicmathieu", "name": "Lo\u00efc Mathieu"}}, "url": "https://github.com/quarkusio/quarkus/commit/cbf487948c19603fea184fbb564d85b3d739cdc8", "committedDate": "2020-05-20T08:31:51Z", "message": "Add a TROUBLESHOOTING.md page with performance related tips"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cbf487948c19603fea184fbb564d85b3d739cdc8", "author": {"user": {"login": "loicmathieu", "name": "Lo\u00efc Mathieu"}}, "url": "https://github.com/quarkusio/quarkus/commit/cbf487948c19603fea184fbb564d85b3d739cdc8", "committedDate": "2020-05-20T08:31:51Z", "message": "Add a TROUBLESHOOTING.md page with performance related tips"}, "afterCommit": {"oid": "50c8f13a4c49231ca2996d5c3e40d96a4c124478", "author": {"user": {"login": "loicmathieu", "name": "Lo\u00efc Mathieu"}}, "url": "https://github.com/quarkusio/quarkus/commit/50c8f13a4c49231ca2996d5c3e40d96a4c124478", "committedDate": "2020-05-20T08:47:56Z", "message": "Add a TROUBLESHOOTING.md page with performance related tips"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7db7c044658c666c5ad94b0d05bcd791e3cede95", "author": {"user": {"login": "loicmathieu", "name": "Lo\u00efc Mathieu"}}, "url": "https://github.com/quarkusio/quarkus/commit/7db7c044658c666c5ad94b0d05bcd791e3cede95", "committedDate": "2020-05-20T09:10:42Z", "message": "Add a TROUBLESHOOTING.md page with performance related tips"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "50c8f13a4c49231ca2996d5c3e40d96a4c124478", "author": {"user": {"login": "loicmathieu", "name": "Lo\u00efc Mathieu"}}, "url": "https://github.com/quarkusio/quarkus/commit/50c8f13a4c49231ca2996d5c3e40d96a4c124478", "committedDate": "2020-05-20T08:47:56Z", "message": "Add a TROUBLESHOOTING.md page with performance related tips"}, "afterCommit": {"oid": "7db7c044658c666c5ad94b0d05bcd791e3cede95", "author": {"user": {"login": "loicmathieu", "name": "Lo\u00efc Mathieu"}}, "url": "https://github.com/quarkusio/quarkus/commit/7db7c044658c666c5ad94b0d05bcd791e3cede95", "committedDate": "2020-05-20T09:10:42Z", "message": "Add a TROUBLESHOOTING.md page with performance related tips"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3328, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}