{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2MjUxODIw", "number": 11331, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNzo0OTowOFrOEXUUGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMjoyMDowMlrOEcxJUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODg1NTMxOnYy", "diffSide": "RIGHT", "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNzo0OTowOFrOG_CtqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMDo1ODoyNlrOHDY1sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc1NzkyOA==", "bodyText": "Example:\n$ mvn clean validate -f integration-tests/cache/\n[INFO] Scanning for projects...\n[INFO]\n[INFO] -------------< io.quarkus:quarkus-integration-test-cache >--------------\n[INFO] Building Quarkus - Integration Tests - Cache 999-SNAPSHOT\n[INFO] --------------------------------[ jar ]---------------------------------\n[INFO]\n[INFO] --- maven-clean-plugin:3.1.0:clean (default-clean) @ quarkus-integration-test-cache ---\n[INFO]\n[INFO] --- maven-enforcer-plugin:3.0.0-M3:enforce (enforce) @ quarkus-integration-test-cache ---\n[INFO]\n[INFO] --- maven-enforcer-plugin:3.0.0-M3:enforce (enforce-java-version) @ quarkus-integration-test-cache ---\n[INFO]\n[INFO] --- maven-enforcer-plugin:3.0.0-M3:enforce (enforce-maven-version) @ quarkus-integration-test-cache ---\n[INFO]\n[INFO] --- maven-enforcer-plugin:3.0.0-M3:enforce (enforce-deployment-deps) @ quarkus-integration-test-cache ---\n[WARNING] Artifact is not resolved, consider using a later build goal like 'package': io.quarkus:quarkus-junit5:jar:999-SNAPSHOT:test\n[WARNING] Artifact is not resolved, consider using a later build goal like 'package': io.quarkus:quarkus-resteasy-jsonb:jar:999-SNAPSHOT:compile\n[WARNING] Artifact is not resolved, consider using a later build goal like 'package': io.quarkus:quarkus-hibernate-orm-panache:jar:999-SNAPSHOT:compile\n[WARNING] Artifact is not resolved, consider using a later build goal like 'package': io.quarkus:quarkus-cache:jar:999-SNAPSHOT:compile\n[WARNING] Artifact is not resolved, consider using a later build goal like 'package': io.quarkus:quarkus-smallrye-context-propagation:jar:999-SNAPSHOT:compile\n[WARNING] Artifact is not resolved, consider using a later build goal like 'package': io.quarkus:quarkus-jdbc-h2:jar:999-SNAPSHOT:compile\n[WARNING] Artifact is not resolved, consider using a later build goal like 'package': io.quarkus:quarkus-test-h2:jar:999-SNAPSHOT:test\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n\nThe warnings vanish when test is used instead of validate and the build will fail (because some deployment deps are missing).\nThis is not ideal, but I'd say it is sufficient for what the rule is supposed to do, which is to enforce the build order primarily in CI.\nCI will always use a \"late\" phase/goal (at least test).", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r468757928", "createdAt": "2020-08-11T17:49:08Z", "author": {"login": "famod"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule {\n+\n+    private static final String GROUP_ID_FILTER = \"io.quarkus\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Dependency> directQuarkusDepsByGAV = project.getDependencies().stream()\n+                .filter(d -> d.getGroupId().equals(GROUP_ID_FILTER))\n+                .collect(Collectors.toMap(d -> d.getGroupId() + \":\" + d.getArtifactId() + \":\" + d.getVersion(), d -> d));\n+\n+        Map<String, Artifact> nonDeploymentQuarkusArtifactsByGAV = project.getArtifacts().stream()\n+                .filter(artifact -> artifact.getGroupId().equals(GROUP_ID_FILTER))\n+                .filter(artifact -> !artifact.getArtifactId().endsWith(\"-deployment\"))\n+                .collect(Collectors.toMap(a -> a.getGroupId() + \":\" + a.getArtifactId() + \":\" + a.getVersion(), a -> a));\n+\n+        String missingDeploymentDeps = nonDeploymentQuarkusArtifactsByGAV.entrySet().parallelStream()\n+                .filter(entry -> directQuarkusDepsByGAV.containsKey(entry.getKey())) // only direct deps\n+                .map(entry -> DEPLOYMENT_GAV_CACHE.computeIfAbsent(entry.getKey(), k -> parseDeploymentGAV(entry.getValue())))\n+                .filter(optDeploymentGAV -> optDeploymentGAV\n+                        .map(deploymentGAV -> !isMinimalDeploymentDepPresent(deploymentGAV, directQuarkusDepsByGAV))\n+                        .orElse(false))\n+                .map(Optional::get)\n+                .sorted()\n+                .collect(Collectors.joining(\"\\n    \"));\n+\n+        if (!missingDeploymentDeps.isEmpty()) {\n+            throw new EnforcerRuleException(\"The following *-deployment dependencies are missing/configured incorrectly:\\n\"\n+                    + \"    \" + missingDeploymentDeps\n+                    + \"\\n\\nEach of these dependencies has to be configured as follows to get a consistent build order:\\n\"\n+                    + \"    <dependency>\\n\"\n+                    + \"        <groupId>GROUP-IP</groupId>\\n\"\n+                    + \"        <artifactId>ARTIFACT-ID</artifactId>\\n\"\n+                    + \"        <version>${project.version}</version>\\n\"\n+                    + \"        <type>pom</type>\\n\"\n+                    + \"        <scope>test</scope>\\n\"\n+                    + \"        <exclusions>\\n\"\n+                    + \"            <exclusion>\\n\"\n+                    + \"                <groupId>*</groupId>\\n\"\n+                    + \"                <artifactId>*</artifactId>\\n\"\n+                    + \"            </exclusion>\\n\"\n+                    + \"        </exclusions>\\n\"\n+                    + \"    </dependency>\");\n+        }\n+    }\n+\n+    private Optional<String> parseDeploymentGAV(Artifact artifact) {\n+        if (!artifact.isResolved()) {\n+            // To avoid this \"soft exit\", explicit resolving would be necessary but that is pretty elaborate in an enforcer rule.\n+            // If the build goal is \"late\" enough, artifacts for the respective scope *will* be resolved automatically.\n+            logger.warn(\"Artifact is not resolved, consider using a later build goal like 'package': \" + artifact);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b606b3670d63f2389796bb519be51dee6ac2ff30"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExMjYwNg==", "bodyText": "@famod , do I understand it correctly test  vs validate makes difference only if you build the whole project and not when you only select -f integration-tests/cache/?", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r469112606", "createdAt": "2020-08-12T09:00:48Z", "author": {"login": "michalszynkiewicz"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule {\n+\n+    private static final String GROUP_ID_FILTER = \"io.quarkus\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Dependency> directQuarkusDepsByGAV = project.getDependencies().stream()\n+                .filter(d -> d.getGroupId().equals(GROUP_ID_FILTER))\n+                .collect(Collectors.toMap(d -> d.getGroupId() + \":\" + d.getArtifactId() + \":\" + d.getVersion(), d -> d));\n+\n+        Map<String, Artifact> nonDeploymentQuarkusArtifactsByGAV = project.getArtifacts().stream()\n+                .filter(artifact -> artifact.getGroupId().equals(GROUP_ID_FILTER))\n+                .filter(artifact -> !artifact.getArtifactId().endsWith(\"-deployment\"))\n+                .collect(Collectors.toMap(a -> a.getGroupId() + \":\" + a.getArtifactId() + \":\" + a.getVersion(), a -> a));\n+\n+        String missingDeploymentDeps = nonDeploymentQuarkusArtifactsByGAV.entrySet().parallelStream()\n+                .filter(entry -> directQuarkusDepsByGAV.containsKey(entry.getKey())) // only direct deps\n+                .map(entry -> DEPLOYMENT_GAV_CACHE.computeIfAbsent(entry.getKey(), k -> parseDeploymentGAV(entry.getValue())))\n+                .filter(optDeploymentGAV -> optDeploymentGAV\n+                        .map(deploymentGAV -> !isMinimalDeploymentDepPresent(deploymentGAV, directQuarkusDepsByGAV))\n+                        .orElse(false))\n+                .map(Optional::get)\n+                .sorted()\n+                .collect(Collectors.joining(\"\\n    \"));\n+\n+        if (!missingDeploymentDeps.isEmpty()) {\n+            throw new EnforcerRuleException(\"The following *-deployment dependencies are missing/configured incorrectly:\\n\"\n+                    + \"    \" + missingDeploymentDeps\n+                    + \"\\n\\nEach of these dependencies has to be configured as follows to get a consistent build order:\\n\"\n+                    + \"    <dependency>\\n\"\n+                    + \"        <groupId>GROUP-IP</groupId>\\n\"\n+                    + \"        <artifactId>ARTIFACT-ID</artifactId>\\n\"\n+                    + \"        <version>${project.version}</version>\\n\"\n+                    + \"        <type>pom</type>\\n\"\n+                    + \"        <scope>test</scope>\\n\"\n+                    + \"        <exclusions>\\n\"\n+                    + \"            <exclusion>\\n\"\n+                    + \"                <groupId>*</groupId>\\n\"\n+                    + \"                <artifactId>*</artifactId>\\n\"\n+                    + \"            </exclusion>\\n\"\n+                    + \"        </exclusions>\\n\"\n+                    + \"    </dependency>\");\n+        }\n+    }\n+\n+    private Optional<String> parseDeploymentGAV(Artifact artifact) {\n+        if (!artifact.isResolved()) {\n+            // To avoid this \"soft exit\", explicit resolving would be necessary but that is pretty elaborate in an enforcer rule.\n+            // If the build goal is \"late\" enough, artifacts for the respective scope *will* be resolved automatically.\n+            logger.warn(\"Artifact is not resolved, consider using a later build goal like 'package': \" + artifact);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc1NzkyOA=="}, "originalCommit": {"oid": "b606b3670d63f2389796bb519be51dee6ac2ff30"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU0NDE2Ng==", "bodyText": "It also makes a difference when building the entire project.\nmvn validate called from root would then log many warnings, but failing the build just because artifacts have not yet been resolved would be worse, IMO.\nTo me, this is an edge case, because usually everyone (including CI) is at least using compile, test, package or even install.\nI could also squash this into a single warning making it less noisy. WDYT?", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r469544166", "createdAt": "2020-08-12T21:00:50Z", "author": {"login": "famod"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule {\n+\n+    private static final String GROUP_ID_FILTER = \"io.quarkus\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Dependency> directQuarkusDepsByGAV = project.getDependencies().stream()\n+                .filter(d -> d.getGroupId().equals(GROUP_ID_FILTER))\n+                .collect(Collectors.toMap(d -> d.getGroupId() + \":\" + d.getArtifactId() + \":\" + d.getVersion(), d -> d));\n+\n+        Map<String, Artifact> nonDeploymentQuarkusArtifactsByGAV = project.getArtifacts().stream()\n+                .filter(artifact -> artifact.getGroupId().equals(GROUP_ID_FILTER))\n+                .filter(artifact -> !artifact.getArtifactId().endsWith(\"-deployment\"))\n+                .collect(Collectors.toMap(a -> a.getGroupId() + \":\" + a.getArtifactId() + \":\" + a.getVersion(), a -> a));\n+\n+        String missingDeploymentDeps = nonDeploymentQuarkusArtifactsByGAV.entrySet().parallelStream()\n+                .filter(entry -> directQuarkusDepsByGAV.containsKey(entry.getKey())) // only direct deps\n+                .map(entry -> DEPLOYMENT_GAV_CACHE.computeIfAbsent(entry.getKey(), k -> parseDeploymentGAV(entry.getValue())))\n+                .filter(optDeploymentGAV -> optDeploymentGAV\n+                        .map(deploymentGAV -> !isMinimalDeploymentDepPresent(deploymentGAV, directQuarkusDepsByGAV))\n+                        .orElse(false))\n+                .map(Optional::get)\n+                .sorted()\n+                .collect(Collectors.joining(\"\\n    \"));\n+\n+        if (!missingDeploymentDeps.isEmpty()) {\n+            throw new EnforcerRuleException(\"The following *-deployment dependencies are missing/configured incorrectly:\\n\"\n+                    + \"    \" + missingDeploymentDeps\n+                    + \"\\n\\nEach of these dependencies has to be configured as follows to get a consistent build order:\\n\"\n+                    + \"    <dependency>\\n\"\n+                    + \"        <groupId>GROUP-IP</groupId>\\n\"\n+                    + \"        <artifactId>ARTIFACT-ID</artifactId>\\n\"\n+                    + \"        <version>${project.version}</version>\\n\"\n+                    + \"        <type>pom</type>\\n\"\n+                    + \"        <scope>test</scope>\\n\"\n+                    + \"        <exclusions>\\n\"\n+                    + \"            <exclusion>\\n\"\n+                    + \"                <groupId>*</groupId>\\n\"\n+                    + \"                <artifactId>*</artifactId>\\n\"\n+                    + \"            </exclusion>\\n\"\n+                    + \"        </exclusions>\\n\"\n+                    + \"    </dependency>\");\n+        }\n+    }\n+\n+    private Optional<String> parseDeploymentGAV(Artifact artifact) {\n+        if (!artifact.isResolved()) {\n+            // To avoid this \"soft exit\", explicit resolving would be necessary but that is pretty elaborate in an enforcer rule.\n+            // If the build goal is \"late\" enough, artifacts for the respective scope *will* be resolved automatically.\n+            logger.warn(\"Artifact is not resolved, consider using a later build goal like 'package': \" + artifact);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc1NzkyOA=="}, "originalCommit": {"oid": "b606b3670d63f2389796bb519be51dee6ac2ff30"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMxNDczNw==", "bodyText": "I squashed it to a single message for less noise, e.g.:\n[INFO] --- maven-enforcer-plugin:3.0.0-M2:enforce (enforce-deployment-deps) @ quarkus-integration-test-cache ---\n[WARNING] Skipping rule RequiresMinimalDeploymentDependency: Artifacts are not resolved, consider using a later build goal like 'package'.", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r473314737", "createdAt": "2020-08-19T20:58:26Z", "author": {"login": "famod"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule {\n+\n+    private static final String GROUP_ID_FILTER = \"io.quarkus\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Dependency> directQuarkusDepsByGAV = project.getDependencies().stream()\n+                .filter(d -> d.getGroupId().equals(GROUP_ID_FILTER))\n+                .collect(Collectors.toMap(d -> d.getGroupId() + \":\" + d.getArtifactId() + \":\" + d.getVersion(), d -> d));\n+\n+        Map<String, Artifact> nonDeploymentQuarkusArtifactsByGAV = project.getArtifacts().stream()\n+                .filter(artifact -> artifact.getGroupId().equals(GROUP_ID_FILTER))\n+                .filter(artifact -> !artifact.getArtifactId().endsWith(\"-deployment\"))\n+                .collect(Collectors.toMap(a -> a.getGroupId() + \":\" + a.getArtifactId() + \":\" + a.getVersion(), a -> a));\n+\n+        String missingDeploymentDeps = nonDeploymentQuarkusArtifactsByGAV.entrySet().parallelStream()\n+                .filter(entry -> directQuarkusDepsByGAV.containsKey(entry.getKey())) // only direct deps\n+                .map(entry -> DEPLOYMENT_GAV_CACHE.computeIfAbsent(entry.getKey(), k -> parseDeploymentGAV(entry.getValue())))\n+                .filter(optDeploymentGAV -> optDeploymentGAV\n+                        .map(deploymentGAV -> !isMinimalDeploymentDepPresent(deploymentGAV, directQuarkusDepsByGAV))\n+                        .orElse(false))\n+                .map(Optional::get)\n+                .sorted()\n+                .collect(Collectors.joining(\"\\n    \"));\n+\n+        if (!missingDeploymentDeps.isEmpty()) {\n+            throw new EnforcerRuleException(\"The following *-deployment dependencies are missing/configured incorrectly:\\n\"\n+                    + \"    \" + missingDeploymentDeps\n+                    + \"\\n\\nEach of these dependencies has to be configured as follows to get a consistent build order:\\n\"\n+                    + \"    <dependency>\\n\"\n+                    + \"        <groupId>GROUP-IP</groupId>\\n\"\n+                    + \"        <artifactId>ARTIFACT-ID</artifactId>\\n\"\n+                    + \"        <version>${project.version}</version>\\n\"\n+                    + \"        <type>pom</type>\\n\"\n+                    + \"        <scope>test</scope>\\n\"\n+                    + \"        <exclusions>\\n\"\n+                    + \"            <exclusion>\\n\"\n+                    + \"                <groupId>*</groupId>\\n\"\n+                    + \"                <artifactId>*</artifactId>\\n\"\n+                    + \"            </exclusion>\\n\"\n+                    + \"        </exclusions>\\n\"\n+                    + \"    </dependency>\");\n+        }\n+    }\n+\n+    private Optional<String> parseDeploymentGAV(Artifact artifact) {\n+        if (!artifact.isResolved()) {\n+            // To avoid this \"soft exit\", explicit resolving would be necessary but that is pretty elaborate in an enforcer rule.\n+            // If the build goal is \"late\" enough, artifacts for the respective scope *will* be resolved automatically.\n+            logger.warn(\"Artifact is not resolved, consider using a later build goal like 'package': \" + artifact);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc1NzkyOA=="}, "originalCommit": {"oid": "b606b3670d63f2389796bb519be51dee6ac2ff30"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODg2Njc2OnYy", "diffSide": "RIGHT", "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNzo1MjowMFrOG_C0og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNzo1MjowMFrOG_C0og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc1OTcxNA==", "bodyText": "Note: This shall avoid re-checking for (and eventually re-parsing of) quarkus-extension.properties for dependencies that are used multiple times throughout the entire build reactor.", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r468759714", "createdAt": "2020-08-11T17:52:00Z", "author": {"login": "famod"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule {\n+\n+    private static final String GROUP_ID_FILTER = \"io.quarkus\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b606b3670d63f2389796bb519be51dee6ac2ff30"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDU3MTc0OnYy", "diffSide": "RIGHT", "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNTo1NjozMFrOG_SyuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMDo1NDowMFrOHDYsoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyMTM2OQ==", "bodyText": "It would be good to have some message for this exception", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r469021369", "createdAt": "2020-08-12T05:56:30Z", "author": {"login": "michalszynkiewicz"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule {\n+\n+    private static final String GROUP_ID_FILTER = \"io.quarkus\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b606b3670d63f2389796bb519be51dee6ac2ff30"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUyOTI4Mg==", "bodyText": "This should never happen but you are right, adding a message is best practise.", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r469529282", "createdAt": "2020-08-12T20:37:13Z", "author": {"login": "famod"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule {\n+\n+    private static final String GROUP_ID_FILTER = \"io.quarkus\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyMTM2OQ=="}, "originalCommit": {"oid": "b606b3670d63f2389796bb519be51dee6ac2ff30"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMxMjQxNg==", "bodyText": "Message added as suggested.", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r473312416", "createdAt": "2020-08-19T20:54:00Z", "author": {"login": "famod"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule {\n+\n+    private static final String GROUP_ID_FILTER = \"io.quarkus\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyMTM2OQ=="}, "originalCommit": {"oid": "b606b3670d63f2389796bb519be51dee6ac2ff30"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDYzOTY4OnYy", "diffSide": "RIGHT", "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNjoyNTo0MVrOG_TagQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMDo1Mzo0OFrOHDYsOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzMTU1Mw==", "bodyText": "just a note, I'm wondering if startsWith won't be safer here (and in line 55) in case we e.g. wanted to move grpc stuff to io.quarkus.grpc", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r469031553", "createdAt": "2020-08-12T06:25:41Z", "author": {"login": "michalszynkiewicz"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule {\n+\n+    private static final String GROUP_ID_FILTER = \"io.quarkus\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Dependency> directQuarkusDepsByGAV = project.getDependencies().stream()\n+                .filter(d -> d.getGroupId().equals(GROUP_ID_FILTER))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b606b3670d63f2389796bb519be51dee6ac2ff30"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMxMjMxNQ==", "bodyText": "Replaced with startsWith as suggested.", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r473312315", "createdAt": "2020-08-19T20:53:48Z", "author": {"login": "famod"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule {\n+\n+    private static final String GROUP_ID_FILTER = \"io.quarkus\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Dependency> directQuarkusDepsByGAV = project.getDependencies().stream()\n+                .filter(d -> d.getGroupId().equals(GROUP_ID_FILTER))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzMTU1Mw=="}, "originalCommit": {"oid": "b606b3670d63f2389796bb519be51dee6ac2ff30"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDY1MTc2OnYy", "diffSide": "RIGHT", "path": "integration-tests/cache/pom.xml", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNjozMDo0MlrOG_ThvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQyMDo1MzoxNVrOHDYrHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzMzQwNQ==", "bodyText": "this will eventually go into integration-tests/pom.xml, right?", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r469033405", "createdAt": "2020-08-12T06:30:42Z", "author": {"login": "michalszynkiewicz"}, "path": "integration-tests/cache/pom.xml", "diffHunk": "@@ -67,6 +80,31 @@\n                     </execution>\n                 </executions>\n             </plugin>\n+            <plugin>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b606b3670d63f2389796bb519be51dee6ac2ff30"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTE3MTMzNA==", "bodyText": "If we move extension ITs into its own module, e.g. integration-tests/extensions we could configure it in one place. FYI @zakkak", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r469171334", "createdAt": "2020-08-12T10:48:09Z", "author": {"login": "aloubyansky"}, "path": "integration-tests/cache/pom.xml", "diffHunk": "@@ -67,6 +80,31 @@\n                     </execution>\n                 </executions>\n             </plugin>\n+            <plugin>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzMzQwNQ=="}, "originalCommit": {"oid": "b606b3670d63f2389796bb519be51dee6ac2ff30"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzNDE5Ng==", "bodyText": "this will eventually go into integration-tests/pom.xml, right?\n\nYes, that's the plan.\n\nIf we move extension ITs into its own module, e.g. integration-tests/extensions we could configure it in one place.\n\nI am probably missing something, but I don't see any real harm letting the rule run for all of integration-tests.", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r469534196", "createdAt": "2020-08-12T20:41:32Z", "author": {"login": "famod"}, "path": "integration-tests/cache/pom.xml", "diffHunk": "@@ -67,6 +80,31 @@\n                     </execution>\n                 </executions>\n             </plugin>\n+            <plugin>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzMzQwNQ=="}, "originalCommit": {"oid": "b606b3670d63f2389796bb519be51dee6ac2ff30"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMxMjAzMA==", "bodyText": "Pulled up to integration-tests but level has to be switched from WARN to ERROR after every submodule was extended.", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r473312030", "createdAt": "2020-08-19T20:53:15Z", "author": {"login": "famod"}, "path": "integration-tests/cache/pom.xml", "diffHunk": "@@ -67,6 +80,31 @@\n                     </execution>\n                 </executions>\n             </plugin>\n+            <plugin>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzMzQwNQ=="}, "originalCommit": {"oid": "b606b3670d63f2389796bb519be51dee6ac2ff30"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MjQyNDE0OnYy", "diffSide": "RIGHT", "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMzowNjo1MFrOHD_4SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMzo1MjoxNlrOHHk9BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1NDM3Nw==", "bodyText": "This is a bit fishy, but I had to introduce this check for at least one it-submodule (forgot the name).\nIt almost feels like that submodule is violating the \"no runtime deps in deployment modules\" rule...", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r473954377", "createdAt": "2020-08-20T13:06:50Z", "author": {"login": "famod"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,183 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerLevel;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule2;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule2 {\n+\n+    private static final String GROUP_ID_PREFIX = \"io.quarkus\";\n+    private static final String DEPLOYMENT_ARTIFACT_ID_SUFFIX = \"-deployment\";\n+\n+    private static final String EXT_PROPERTIES_PATH = \"META-INF/quarkus-extension.properties\";\n+\n+    private static final String REQ_TYPE = \"pom\";\n+    private static final String REQ_SCOPE = \"test\";\n+\n+    private static final String DEP_TEMPLATE = \"        <dependency>\\n\"\n+            + \"            <groupId>%s</groupId>\\n\"\n+            + \"            <artifactId>%s</artifactId>\\n\"\n+            + \"            <version>${project.version}</version>\\n\"\n+            + \"            <type>\" + REQ_TYPE + \"</type>\\n\"\n+            + \"            <scope>\" + REQ_SCOPE + \"</scope>\\n\"\n+            + \"            <exclusions>\\n\"\n+            + \"                <exclusion>\\n\"\n+            + \"                    <groupId>*</groupId>\\n\"\n+            + \"                    <artifactId>*</artifactId>\\n\"\n+            + \"                </exclusion>\\n\"\n+            + \"            </exclusions>\\n\"\n+            + \"        </dependency>\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    private EnforcerLevel level = EnforcerLevel.ERROR;\n+\n+    @Override\n+    public EnforcerLevel getLevel() {\n+        return level;\n+    }\n+\n+    public void setLevel(EnforcerLevel level) {\n+        this.level = level;\n+    }\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(\"Failed to get project from EnforcerRuleHelper\", e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Artifact> nonDeploymentArtifactsByGAV = project.getArtifacts().stream()\n+                .filter(artifact -> \"jar\".equals(artifact.getType()))\n+                .filter(artifact -> artifact.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .filter(artifact -> !artifact.getArtifactId().endsWith(DEPLOYMENT_ARTIFACT_ID_SUFFIX))\n+                .collect(Collectors.toMap(this::buildGAVKey, a -> a));\n+\n+        // Skip if artifacts are not resolved.\n+        // To avoid this \"soft exit\", explicit resolving would be necessary but that is pretty elaborate in an enforcer rule.\n+        // If the build goal is \"late\" enough, artifacts for the respective scope *will* be resolved automatically.\n+        if (nonDeploymentArtifactsByGAV.values().stream().anyMatch(artifact -> !artifact.isResolved())) {\n+            logger.warn(\"Skipping rule \" + RequiresMinimalDeploymentDependency.class.getSimpleName()\n+                    + \": Artifacts are not resolved, consider using a later build goal like 'package'.\");\n+            return;\n+        }\n+\n+        String projArtifactKey = buildGAVKey(project.getArtifact());\n+\n+        Map<String, Dependency> directDepsByGAV = project.getDependencies().stream()\n+                .filter(d -> d.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .collect(Collectors.toMap(d -> d.getGroupId() + \":\" + d.getArtifactId() + \":\" + d.getVersion(), d -> d));\n+\n+        List<String> missingDeploymentDeps = nonDeploymentArtifactsByGAV.entrySet().parallelStream()\n+                .filter(entry -> directDepsByGAV.containsKey(entry.getKey())) // only direct deps\n+                .map(entry -> DEPLOYMENT_GAV_CACHE.computeIfAbsent(entry.getKey(), k -> parseDeploymentGAV(entry.getValue())))\n+                .filter(optDeploymentGAV -> optDeploymentGAV\n+                        .map(deploymentGAV -> !isMinDeploymentDepPresent(deploymentGAV, projArtifactKey, directDepsByGAV))\n+                        .orElse(false))\n+                .map(Optional::get)\n+                .sorted()\n+                .collect(Collectors.toList());\n+\n+        if (!missingDeploymentDeps.isEmpty()) {\n+            String requiredDeps = missingDeploymentDeps.stream()\n+                    .map(gav -> (Object[]) gav.split(\":\"))\n+                    .map(gavArray -> String.format(DEP_TEMPLATE, gavArray))\n+                    .collect(Collectors.joining(\"\\n\"));\n+            throw new EnforcerRuleException(missingDeploymentDeps.size()\n+                    + \" *-deployment dependencies are missing/configured incorrectly:\\n\"\n+                    + \"    \" + missingDeploymentDeps.stream().collect(Collectors.joining(\"\\n    \"))\n+                    + \"\\n\\nTo fix this issue, add the following dependencies to pom.xml:\\n\\n\"\n+                    + \"        <!-- \\\"Symbolic\\\" test dependencies to *-deployment artifacts for consistent build order -->\\n\"\n+                    + requiredDeps);\n+        }\n+    }\n+\n+    private String buildGAVKey(Artifact artifact) {\n+        return artifact.getGroupId() + \":\" + artifact.getArtifactId() + \":\" + artifact.getVersion();\n+    }\n+\n+    private Optional<String> parseDeploymentGAV(Artifact artifact) {\n+        File artifactFile = artifact.getFile();\n+        if (artifactFile == null || !artifactFile.exists()) {\n+            throw new IllegalStateException(\"Artifact file not found for \" + artifact);\n+        }\n+\n+        Properties extProperties = new Properties();\n+        try (ZipFile zipFile = new ZipFile(artifactFile)) {\n+            ZipEntry entry = zipFile.getEntry(EXT_PROPERTIES_PATH);\n+            if (entry == null) {\n+                return Optional.empty();\n+            }\n+            extProperties.load(new InputStreamReader(zipFile.getInputStream(entry), StandardCharsets.UTF_8));\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(\"Failed to read \" + EXT_PROPERTIES_PATH + \" from \" + artifactFile, e);\n+        }\n+\n+        String deploymentGAV = extProperties.getProperty(\"deployment-artifact\");\n+        if (deploymentGAV == null) {\n+            throw new IllegalStateException(\n+                    \"deployment-artifact artifact not found in \" + EXT_PROPERTIES_PATH + \" from \" + artifactFile);\n+        }\n+        return Optional.of(deploymentGAV);\n+    }\n+\n+    private boolean isMinDeploymentDepPresent(String deploymentGAV, String projArtifactKey,\n+            Map<String, Dependency> directDepsByGAV) {\n+        return deploymentGAV.equals(projArtifactKey) // special case: current project itself is the \"required dependency\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "849fd61afbcda043afb07565aacbf6575c1f0a55"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQyMzk5NA==", "bodyText": "I think the rule is opposite, \"no deployment deps in runtime modules\", and if there's a violation, then I guess we really want to know :-) Though I'm not sure if this indicates violation of that rule.", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r475423994", "createdAt": "2020-08-24T08:26:42Z", "author": {"login": "Ladicek"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,183 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerLevel;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule2;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule2 {\n+\n+    private static final String GROUP_ID_PREFIX = \"io.quarkus\";\n+    private static final String DEPLOYMENT_ARTIFACT_ID_SUFFIX = \"-deployment\";\n+\n+    private static final String EXT_PROPERTIES_PATH = \"META-INF/quarkus-extension.properties\";\n+\n+    private static final String REQ_TYPE = \"pom\";\n+    private static final String REQ_SCOPE = \"test\";\n+\n+    private static final String DEP_TEMPLATE = \"        <dependency>\\n\"\n+            + \"            <groupId>%s</groupId>\\n\"\n+            + \"            <artifactId>%s</artifactId>\\n\"\n+            + \"            <version>${project.version}</version>\\n\"\n+            + \"            <type>\" + REQ_TYPE + \"</type>\\n\"\n+            + \"            <scope>\" + REQ_SCOPE + \"</scope>\\n\"\n+            + \"            <exclusions>\\n\"\n+            + \"                <exclusion>\\n\"\n+            + \"                    <groupId>*</groupId>\\n\"\n+            + \"                    <artifactId>*</artifactId>\\n\"\n+            + \"                </exclusion>\\n\"\n+            + \"            </exclusions>\\n\"\n+            + \"        </dependency>\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    private EnforcerLevel level = EnforcerLevel.ERROR;\n+\n+    @Override\n+    public EnforcerLevel getLevel() {\n+        return level;\n+    }\n+\n+    public void setLevel(EnforcerLevel level) {\n+        this.level = level;\n+    }\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(\"Failed to get project from EnforcerRuleHelper\", e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Artifact> nonDeploymentArtifactsByGAV = project.getArtifacts().stream()\n+                .filter(artifact -> \"jar\".equals(artifact.getType()))\n+                .filter(artifact -> artifact.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .filter(artifact -> !artifact.getArtifactId().endsWith(DEPLOYMENT_ARTIFACT_ID_SUFFIX))\n+                .collect(Collectors.toMap(this::buildGAVKey, a -> a));\n+\n+        // Skip if artifacts are not resolved.\n+        // To avoid this \"soft exit\", explicit resolving would be necessary but that is pretty elaborate in an enforcer rule.\n+        // If the build goal is \"late\" enough, artifacts for the respective scope *will* be resolved automatically.\n+        if (nonDeploymentArtifactsByGAV.values().stream().anyMatch(artifact -> !artifact.isResolved())) {\n+            logger.warn(\"Skipping rule \" + RequiresMinimalDeploymentDependency.class.getSimpleName()\n+                    + \": Artifacts are not resolved, consider using a later build goal like 'package'.\");\n+            return;\n+        }\n+\n+        String projArtifactKey = buildGAVKey(project.getArtifact());\n+\n+        Map<String, Dependency> directDepsByGAV = project.getDependencies().stream()\n+                .filter(d -> d.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .collect(Collectors.toMap(d -> d.getGroupId() + \":\" + d.getArtifactId() + \":\" + d.getVersion(), d -> d));\n+\n+        List<String> missingDeploymentDeps = nonDeploymentArtifactsByGAV.entrySet().parallelStream()\n+                .filter(entry -> directDepsByGAV.containsKey(entry.getKey())) // only direct deps\n+                .map(entry -> DEPLOYMENT_GAV_CACHE.computeIfAbsent(entry.getKey(), k -> parseDeploymentGAV(entry.getValue())))\n+                .filter(optDeploymentGAV -> optDeploymentGAV\n+                        .map(deploymentGAV -> !isMinDeploymentDepPresent(deploymentGAV, projArtifactKey, directDepsByGAV))\n+                        .orElse(false))\n+                .map(Optional::get)\n+                .sorted()\n+                .collect(Collectors.toList());\n+\n+        if (!missingDeploymentDeps.isEmpty()) {\n+            String requiredDeps = missingDeploymentDeps.stream()\n+                    .map(gav -> (Object[]) gav.split(\":\"))\n+                    .map(gavArray -> String.format(DEP_TEMPLATE, gavArray))\n+                    .collect(Collectors.joining(\"\\n\"));\n+            throw new EnforcerRuleException(missingDeploymentDeps.size()\n+                    + \" *-deployment dependencies are missing/configured incorrectly:\\n\"\n+                    + \"    \" + missingDeploymentDeps.stream().collect(Collectors.joining(\"\\n    \"))\n+                    + \"\\n\\nTo fix this issue, add the following dependencies to pom.xml:\\n\\n\"\n+                    + \"        <!-- \\\"Symbolic\\\" test dependencies to *-deployment artifacts for consistent build order -->\\n\"\n+                    + requiredDeps);\n+        }\n+    }\n+\n+    private String buildGAVKey(Artifact artifact) {\n+        return artifact.getGroupId() + \":\" + artifact.getArtifactId() + \":\" + artifact.getVersion();\n+    }\n+\n+    private Optional<String> parseDeploymentGAV(Artifact artifact) {\n+        File artifactFile = artifact.getFile();\n+        if (artifactFile == null || !artifactFile.exists()) {\n+            throw new IllegalStateException(\"Artifact file not found for \" + artifact);\n+        }\n+\n+        Properties extProperties = new Properties();\n+        try (ZipFile zipFile = new ZipFile(artifactFile)) {\n+            ZipEntry entry = zipFile.getEntry(EXT_PROPERTIES_PATH);\n+            if (entry == null) {\n+                return Optional.empty();\n+            }\n+            extProperties.load(new InputStreamReader(zipFile.getInputStream(entry), StandardCharsets.UTF_8));\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(\"Failed to read \" + EXT_PROPERTIES_PATH + \" from \" + artifactFile, e);\n+        }\n+\n+        String deploymentGAV = extProperties.getProperty(\"deployment-artifact\");\n+        if (deploymentGAV == null) {\n+            throw new IllegalStateException(\n+                    \"deployment-artifact artifact not found in \" + EXT_PROPERTIES_PATH + \" from \" + artifactFile);\n+        }\n+        return Optional.of(deploymentGAV);\n+    }\n+\n+    private boolean isMinDeploymentDepPresent(String deploymentGAV, String projArtifactKey,\n+            Map<String, Dependency> directDepsByGAV) {\n+        return deploymentGAV.equals(projArtifactKey) // special case: current project itself is the \"required dependency\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1NDM3Nw=="}, "originalCommit": {"oid": "849fd61afbcda043afb07565aacbf6575c1f0a55"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQzNTA3Mw==", "bodyText": "\"no deployment deps in runtime modules\" makes sense as well but I meant: #11174", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r475435073", "createdAt": "2020-08-24T08:46:11Z", "author": {"login": "famod"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,183 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerLevel;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule2;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule2 {\n+\n+    private static final String GROUP_ID_PREFIX = \"io.quarkus\";\n+    private static final String DEPLOYMENT_ARTIFACT_ID_SUFFIX = \"-deployment\";\n+\n+    private static final String EXT_PROPERTIES_PATH = \"META-INF/quarkus-extension.properties\";\n+\n+    private static final String REQ_TYPE = \"pom\";\n+    private static final String REQ_SCOPE = \"test\";\n+\n+    private static final String DEP_TEMPLATE = \"        <dependency>\\n\"\n+            + \"            <groupId>%s</groupId>\\n\"\n+            + \"            <artifactId>%s</artifactId>\\n\"\n+            + \"            <version>${project.version}</version>\\n\"\n+            + \"            <type>\" + REQ_TYPE + \"</type>\\n\"\n+            + \"            <scope>\" + REQ_SCOPE + \"</scope>\\n\"\n+            + \"            <exclusions>\\n\"\n+            + \"                <exclusion>\\n\"\n+            + \"                    <groupId>*</groupId>\\n\"\n+            + \"                    <artifactId>*</artifactId>\\n\"\n+            + \"                </exclusion>\\n\"\n+            + \"            </exclusions>\\n\"\n+            + \"        </dependency>\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    private EnforcerLevel level = EnforcerLevel.ERROR;\n+\n+    @Override\n+    public EnforcerLevel getLevel() {\n+        return level;\n+    }\n+\n+    public void setLevel(EnforcerLevel level) {\n+        this.level = level;\n+    }\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(\"Failed to get project from EnforcerRuleHelper\", e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Artifact> nonDeploymentArtifactsByGAV = project.getArtifacts().stream()\n+                .filter(artifact -> \"jar\".equals(artifact.getType()))\n+                .filter(artifact -> artifact.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .filter(artifact -> !artifact.getArtifactId().endsWith(DEPLOYMENT_ARTIFACT_ID_SUFFIX))\n+                .collect(Collectors.toMap(this::buildGAVKey, a -> a));\n+\n+        // Skip if artifacts are not resolved.\n+        // To avoid this \"soft exit\", explicit resolving would be necessary but that is pretty elaborate in an enforcer rule.\n+        // If the build goal is \"late\" enough, artifacts for the respective scope *will* be resolved automatically.\n+        if (nonDeploymentArtifactsByGAV.values().stream().anyMatch(artifact -> !artifact.isResolved())) {\n+            logger.warn(\"Skipping rule \" + RequiresMinimalDeploymentDependency.class.getSimpleName()\n+                    + \": Artifacts are not resolved, consider using a later build goal like 'package'.\");\n+            return;\n+        }\n+\n+        String projArtifactKey = buildGAVKey(project.getArtifact());\n+\n+        Map<String, Dependency> directDepsByGAV = project.getDependencies().stream()\n+                .filter(d -> d.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .collect(Collectors.toMap(d -> d.getGroupId() + \":\" + d.getArtifactId() + \":\" + d.getVersion(), d -> d));\n+\n+        List<String> missingDeploymentDeps = nonDeploymentArtifactsByGAV.entrySet().parallelStream()\n+                .filter(entry -> directDepsByGAV.containsKey(entry.getKey())) // only direct deps\n+                .map(entry -> DEPLOYMENT_GAV_CACHE.computeIfAbsent(entry.getKey(), k -> parseDeploymentGAV(entry.getValue())))\n+                .filter(optDeploymentGAV -> optDeploymentGAV\n+                        .map(deploymentGAV -> !isMinDeploymentDepPresent(deploymentGAV, projArtifactKey, directDepsByGAV))\n+                        .orElse(false))\n+                .map(Optional::get)\n+                .sorted()\n+                .collect(Collectors.toList());\n+\n+        if (!missingDeploymentDeps.isEmpty()) {\n+            String requiredDeps = missingDeploymentDeps.stream()\n+                    .map(gav -> (Object[]) gav.split(\":\"))\n+                    .map(gavArray -> String.format(DEP_TEMPLATE, gavArray))\n+                    .collect(Collectors.joining(\"\\n\"));\n+            throw new EnforcerRuleException(missingDeploymentDeps.size()\n+                    + \" *-deployment dependencies are missing/configured incorrectly:\\n\"\n+                    + \"    \" + missingDeploymentDeps.stream().collect(Collectors.joining(\"\\n    \"))\n+                    + \"\\n\\nTo fix this issue, add the following dependencies to pom.xml:\\n\\n\"\n+                    + \"        <!-- \\\"Symbolic\\\" test dependencies to *-deployment artifacts for consistent build order -->\\n\"\n+                    + requiredDeps);\n+        }\n+    }\n+\n+    private String buildGAVKey(Artifact artifact) {\n+        return artifact.getGroupId() + \":\" + artifact.getArtifactId() + \":\" + artifact.getVersion();\n+    }\n+\n+    private Optional<String> parseDeploymentGAV(Artifact artifact) {\n+        File artifactFile = artifact.getFile();\n+        if (artifactFile == null || !artifactFile.exists()) {\n+            throw new IllegalStateException(\"Artifact file not found for \" + artifact);\n+        }\n+\n+        Properties extProperties = new Properties();\n+        try (ZipFile zipFile = new ZipFile(artifactFile)) {\n+            ZipEntry entry = zipFile.getEntry(EXT_PROPERTIES_PATH);\n+            if (entry == null) {\n+                return Optional.empty();\n+            }\n+            extProperties.load(new InputStreamReader(zipFile.getInputStream(entry), StandardCharsets.UTF_8));\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(\"Failed to read \" + EXT_PROPERTIES_PATH + \" from \" + artifactFile, e);\n+        }\n+\n+        String deploymentGAV = extProperties.getProperty(\"deployment-artifact\");\n+        if (deploymentGAV == null) {\n+            throw new IllegalStateException(\n+                    \"deployment-artifact artifact not found in \" + EXT_PROPERTIES_PATH + \" from \" + artifactFile);\n+        }\n+        return Optional.of(deploymentGAV);\n+    }\n+\n+    private boolean isMinDeploymentDepPresent(String deploymentGAV, String projArtifactKey,\n+            Map<String, Dependency> directDepsByGAV) {\n+        return deploymentGAV.equals(projArtifactKey) // special case: current project itself is the \"required dependency\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1NDM3Nw=="}, "originalCommit": {"oid": "849fd61afbcda043afb07565aacbf6575c1f0a55"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0NTI1OA==", "bodyText": "Ah interesting, I didn't know about that one! Thanks.", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r475445258", "createdAt": "2020-08-24T09:02:11Z", "author": {"login": "Ladicek"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,183 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerLevel;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule2;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule2 {\n+\n+    private static final String GROUP_ID_PREFIX = \"io.quarkus\";\n+    private static final String DEPLOYMENT_ARTIFACT_ID_SUFFIX = \"-deployment\";\n+\n+    private static final String EXT_PROPERTIES_PATH = \"META-INF/quarkus-extension.properties\";\n+\n+    private static final String REQ_TYPE = \"pom\";\n+    private static final String REQ_SCOPE = \"test\";\n+\n+    private static final String DEP_TEMPLATE = \"        <dependency>\\n\"\n+            + \"            <groupId>%s</groupId>\\n\"\n+            + \"            <artifactId>%s</artifactId>\\n\"\n+            + \"            <version>${project.version}</version>\\n\"\n+            + \"            <type>\" + REQ_TYPE + \"</type>\\n\"\n+            + \"            <scope>\" + REQ_SCOPE + \"</scope>\\n\"\n+            + \"            <exclusions>\\n\"\n+            + \"                <exclusion>\\n\"\n+            + \"                    <groupId>*</groupId>\\n\"\n+            + \"                    <artifactId>*</artifactId>\\n\"\n+            + \"                </exclusion>\\n\"\n+            + \"            </exclusions>\\n\"\n+            + \"        </dependency>\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    private EnforcerLevel level = EnforcerLevel.ERROR;\n+\n+    @Override\n+    public EnforcerLevel getLevel() {\n+        return level;\n+    }\n+\n+    public void setLevel(EnforcerLevel level) {\n+        this.level = level;\n+    }\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(\"Failed to get project from EnforcerRuleHelper\", e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Artifact> nonDeploymentArtifactsByGAV = project.getArtifacts().stream()\n+                .filter(artifact -> \"jar\".equals(artifact.getType()))\n+                .filter(artifact -> artifact.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .filter(artifact -> !artifact.getArtifactId().endsWith(DEPLOYMENT_ARTIFACT_ID_SUFFIX))\n+                .collect(Collectors.toMap(this::buildGAVKey, a -> a));\n+\n+        // Skip if artifacts are not resolved.\n+        // To avoid this \"soft exit\", explicit resolving would be necessary but that is pretty elaborate in an enforcer rule.\n+        // If the build goal is \"late\" enough, artifacts for the respective scope *will* be resolved automatically.\n+        if (nonDeploymentArtifactsByGAV.values().stream().anyMatch(artifact -> !artifact.isResolved())) {\n+            logger.warn(\"Skipping rule \" + RequiresMinimalDeploymentDependency.class.getSimpleName()\n+                    + \": Artifacts are not resolved, consider using a later build goal like 'package'.\");\n+            return;\n+        }\n+\n+        String projArtifactKey = buildGAVKey(project.getArtifact());\n+\n+        Map<String, Dependency> directDepsByGAV = project.getDependencies().stream()\n+                .filter(d -> d.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .collect(Collectors.toMap(d -> d.getGroupId() + \":\" + d.getArtifactId() + \":\" + d.getVersion(), d -> d));\n+\n+        List<String> missingDeploymentDeps = nonDeploymentArtifactsByGAV.entrySet().parallelStream()\n+                .filter(entry -> directDepsByGAV.containsKey(entry.getKey())) // only direct deps\n+                .map(entry -> DEPLOYMENT_GAV_CACHE.computeIfAbsent(entry.getKey(), k -> parseDeploymentGAV(entry.getValue())))\n+                .filter(optDeploymentGAV -> optDeploymentGAV\n+                        .map(deploymentGAV -> !isMinDeploymentDepPresent(deploymentGAV, projArtifactKey, directDepsByGAV))\n+                        .orElse(false))\n+                .map(Optional::get)\n+                .sorted()\n+                .collect(Collectors.toList());\n+\n+        if (!missingDeploymentDeps.isEmpty()) {\n+            String requiredDeps = missingDeploymentDeps.stream()\n+                    .map(gav -> (Object[]) gav.split(\":\"))\n+                    .map(gavArray -> String.format(DEP_TEMPLATE, gavArray))\n+                    .collect(Collectors.joining(\"\\n\"));\n+            throw new EnforcerRuleException(missingDeploymentDeps.size()\n+                    + \" *-deployment dependencies are missing/configured incorrectly:\\n\"\n+                    + \"    \" + missingDeploymentDeps.stream().collect(Collectors.joining(\"\\n    \"))\n+                    + \"\\n\\nTo fix this issue, add the following dependencies to pom.xml:\\n\\n\"\n+                    + \"        <!-- \\\"Symbolic\\\" test dependencies to *-deployment artifacts for consistent build order -->\\n\"\n+                    + requiredDeps);\n+        }\n+    }\n+\n+    private String buildGAVKey(Artifact artifact) {\n+        return artifact.getGroupId() + \":\" + artifact.getArtifactId() + \":\" + artifact.getVersion();\n+    }\n+\n+    private Optional<String> parseDeploymentGAV(Artifact artifact) {\n+        File artifactFile = artifact.getFile();\n+        if (artifactFile == null || !artifactFile.exists()) {\n+            throw new IllegalStateException(\"Artifact file not found for \" + artifact);\n+        }\n+\n+        Properties extProperties = new Properties();\n+        try (ZipFile zipFile = new ZipFile(artifactFile)) {\n+            ZipEntry entry = zipFile.getEntry(EXT_PROPERTIES_PATH);\n+            if (entry == null) {\n+                return Optional.empty();\n+            }\n+            extProperties.load(new InputStreamReader(zipFile.getInputStream(entry), StandardCharsets.UTF_8));\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(\"Failed to read \" + EXT_PROPERTIES_PATH + \" from \" + artifactFile, e);\n+        }\n+\n+        String deploymentGAV = extProperties.getProperty(\"deployment-artifact\");\n+        if (deploymentGAV == null) {\n+            throw new IllegalStateException(\n+                    \"deployment-artifact artifact not found in \" + EXT_PROPERTIES_PATH + \" from \" + artifactFile);\n+        }\n+        return Optional.of(deploymentGAV);\n+    }\n+\n+    private boolean isMinDeploymentDepPresent(String deploymentGAV, String projArtifactKey,\n+            Map<String, Dependency> directDepsByGAV) {\n+        return deploymentGAV.equals(projArtifactKey) // special case: current project itself is the \"required dependency\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1NDM3Nw=="}, "originalCommit": {"oid": "849fd61afbcda043afb07565aacbf6575c1f0a55"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzcwNzUyNQ==", "bodyText": "I just realized that #11174 is about runtime dependencies of other extensions.\nIt is perfectly valid (and required!) that the deployment module of an extension A has a dependency on the runtime artifact of extension A.\nIt would not be valid if that deployment module would depend on the runtime artifact of an extension B!\nLong story short: This check is not \"fishy\". I reworded #11174 a little for clarification.", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r477707525", "createdAt": "2020-08-26T23:52:16Z", "author": {"login": "famod"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,183 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerLevel;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule2;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule2 {\n+\n+    private static final String GROUP_ID_PREFIX = \"io.quarkus\";\n+    private static final String DEPLOYMENT_ARTIFACT_ID_SUFFIX = \"-deployment\";\n+\n+    private static final String EXT_PROPERTIES_PATH = \"META-INF/quarkus-extension.properties\";\n+\n+    private static final String REQ_TYPE = \"pom\";\n+    private static final String REQ_SCOPE = \"test\";\n+\n+    private static final String DEP_TEMPLATE = \"        <dependency>\\n\"\n+            + \"            <groupId>%s</groupId>\\n\"\n+            + \"            <artifactId>%s</artifactId>\\n\"\n+            + \"            <version>${project.version}</version>\\n\"\n+            + \"            <type>\" + REQ_TYPE + \"</type>\\n\"\n+            + \"            <scope>\" + REQ_SCOPE + \"</scope>\\n\"\n+            + \"            <exclusions>\\n\"\n+            + \"                <exclusion>\\n\"\n+            + \"                    <groupId>*</groupId>\\n\"\n+            + \"                    <artifactId>*</artifactId>\\n\"\n+            + \"                </exclusion>\\n\"\n+            + \"            </exclusions>\\n\"\n+            + \"        </dependency>\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    private EnforcerLevel level = EnforcerLevel.ERROR;\n+\n+    @Override\n+    public EnforcerLevel getLevel() {\n+        return level;\n+    }\n+\n+    public void setLevel(EnforcerLevel level) {\n+        this.level = level;\n+    }\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(\"Failed to get project from EnforcerRuleHelper\", e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Artifact> nonDeploymentArtifactsByGAV = project.getArtifacts().stream()\n+                .filter(artifact -> \"jar\".equals(artifact.getType()))\n+                .filter(artifact -> artifact.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .filter(artifact -> !artifact.getArtifactId().endsWith(DEPLOYMENT_ARTIFACT_ID_SUFFIX))\n+                .collect(Collectors.toMap(this::buildGAVKey, a -> a));\n+\n+        // Skip if artifacts are not resolved.\n+        // To avoid this \"soft exit\", explicit resolving would be necessary but that is pretty elaborate in an enforcer rule.\n+        // If the build goal is \"late\" enough, artifacts for the respective scope *will* be resolved automatically.\n+        if (nonDeploymentArtifactsByGAV.values().stream().anyMatch(artifact -> !artifact.isResolved())) {\n+            logger.warn(\"Skipping rule \" + RequiresMinimalDeploymentDependency.class.getSimpleName()\n+                    + \": Artifacts are not resolved, consider using a later build goal like 'package'.\");\n+            return;\n+        }\n+\n+        String projArtifactKey = buildGAVKey(project.getArtifact());\n+\n+        Map<String, Dependency> directDepsByGAV = project.getDependencies().stream()\n+                .filter(d -> d.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .collect(Collectors.toMap(d -> d.getGroupId() + \":\" + d.getArtifactId() + \":\" + d.getVersion(), d -> d));\n+\n+        List<String> missingDeploymentDeps = nonDeploymentArtifactsByGAV.entrySet().parallelStream()\n+                .filter(entry -> directDepsByGAV.containsKey(entry.getKey())) // only direct deps\n+                .map(entry -> DEPLOYMENT_GAV_CACHE.computeIfAbsent(entry.getKey(), k -> parseDeploymentGAV(entry.getValue())))\n+                .filter(optDeploymentGAV -> optDeploymentGAV\n+                        .map(deploymentGAV -> !isMinDeploymentDepPresent(deploymentGAV, projArtifactKey, directDepsByGAV))\n+                        .orElse(false))\n+                .map(Optional::get)\n+                .sorted()\n+                .collect(Collectors.toList());\n+\n+        if (!missingDeploymentDeps.isEmpty()) {\n+            String requiredDeps = missingDeploymentDeps.stream()\n+                    .map(gav -> (Object[]) gav.split(\":\"))\n+                    .map(gavArray -> String.format(DEP_TEMPLATE, gavArray))\n+                    .collect(Collectors.joining(\"\\n\"));\n+            throw new EnforcerRuleException(missingDeploymentDeps.size()\n+                    + \" *-deployment dependencies are missing/configured incorrectly:\\n\"\n+                    + \"    \" + missingDeploymentDeps.stream().collect(Collectors.joining(\"\\n    \"))\n+                    + \"\\n\\nTo fix this issue, add the following dependencies to pom.xml:\\n\\n\"\n+                    + \"        <!-- \\\"Symbolic\\\" test dependencies to *-deployment artifacts for consistent build order -->\\n\"\n+                    + requiredDeps);\n+        }\n+    }\n+\n+    private String buildGAVKey(Artifact artifact) {\n+        return artifact.getGroupId() + \":\" + artifact.getArtifactId() + \":\" + artifact.getVersion();\n+    }\n+\n+    private Optional<String> parseDeploymentGAV(Artifact artifact) {\n+        File artifactFile = artifact.getFile();\n+        if (artifactFile == null || !artifactFile.exists()) {\n+            throw new IllegalStateException(\"Artifact file not found for \" + artifact);\n+        }\n+\n+        Properties extProperties = new Properties();\n+        try (ZipFile zipFile = new ZipFile(artifactFile)) {\n+            ZipEntry entry = zipFile.getEntry(EXT_PROPERTIES_PATH);\n+            if (entry == null) {\n+                return Optional.empty();\n+            }\n+            extProperties.load(new InputStreamReader(zipFile.getInputStream(entry), StandardCharsets.UTF_8));\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(\"Failed to read \" + EXT_PROPERTIES_PATH + \" from \" + artifactFile, e);\n+        }\n+\n+        String deploymentGAV = extProperties.getProperty(\"deployment-artifact\");\n+        if (deploymentGAV == null) {\n+            throw new IllegalStateException(\n+                    \"deployment-artifact artifact not found in \" + EXT_PROPERTIES_PATH + \" from \" + artifactFile);\n+        }\n+        return Optional.of(deploymentGAV);\n+    }\n+\n+    private boolean isMinDeploymentDepPresent(String deploymentGAV, String projArtifactKey,\n+            Map<String, Dependency> directDepsByGAV) {\n+        return deploymentGAV.equals(projArtifactKey) // special case: current project itself is the \"required dependency\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1NDM3Nw=="}, "originalCommit": {"oid": "849fd61afbcda043afb07565aacbf6575c1f0a55"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MjIyMTQ3OnYy", "diffSide": "RIGHT", "path": "build-parent/pom.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwODoxMToyNlrOHFZF3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwOTowMDozMFrOHFaxbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQxNjAzMQ==", "bodyText": "Is this used anywhere?", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r475416031", "createdAt": "2020-08-24T08:11:26Z", "author": {"login": "Ladicek"}, "path": "build-parent/pom.xml", "diffHunk": "@@ -27,6 +27,7 @@\n         <scala.version>2.12.8</scala.version>\n         <scala-plugin.version>4.1.1</scala-plugin.version>\n \n+        <version.enforcer.plugin>3.0.0-M3</version.enforcer.plugin>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "760ecadc9c783a18e2f3be9a843571eeceba18eb"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQyNTkyNw==", "bodyText": "It is overriding the version from jboss-parent, just like the surefire property below.", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r475425927", "createdAt": "2020-08-24T08:29:53Z", "author": {"login": "famod"}, "path": "build-parent/pom.xml", "diffHunk": "@@ -27,6 +27,7 @@\n         <scala.version>2.12.8</scala.version>\n         <scala-plugin.version>4.1.1</scala-plugin.version>\n \n+        <version.enforcer.plugin>3.0.0-M3</version.enforcer.plugin>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQxNjAzMQ=="}, "originalCommit": {"oid": "760ecadc9c783a18e2f3be9a843571eeceba18eb"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0MzU2NA==", "bodyText": "Ah! Thanks!", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r475443564", "createdAt": "2020-08-24T09:00:30Z", "author": {"login": "Ladicek"}, "path": "build-parent/pom.xml", "diffHunk": "@@ -27,6 +27,7 @@\n         <scala.version>2.12.8</scala.version>\n         <scala-plugin.version>4.1.1</scala-plugin.version>\n \n+        <version.enforcer.plugin>3.0.0-M3</version.enforcer.plugin>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQxNjAzMQ=="}, "originalCommit": {"oid": "760ecadc9c783a18e2f3be9a843571eeceba18eb"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MjIyNzYzOnYy", "diffSide": "RIGHT", "path": "devtools/enforcer-rules/pom.xml", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwODoxMzoxNlrOHFZJkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwODozNDoxMlrOHFZ17g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQxNjk3OA==", "bodyText": "Care to put this version string into a property? There's a couple of other modules that use Maven Invoker plugin, and perhaps we should centralize its version. Can be an extra PR too, I don't mind.", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r475416978", "createdAt": "2020-08-24T08:13:16Z", "author": {"login": "Ladicek"}, "path": "devtools/enforcer-rules/pom.xml", "diffHunk": "@@ -0,0 +1,68 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <parent>\n+        <artifactId>quarkus-devtools-all</artifactId>\n+        <groupId>io.quarkus</groupId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../</relativePath>\n+    </parent>\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <artifactId>quarkus-enforcer-rules</artifactId>\n+    <name>Quarkus - Enforcer Rules</name>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.apache.maven.enforcer</groupId>\n+            <artifactId>enforcer-api</artifactId>\n+            <version>${version.enforcer.plugin}</version>\n+            <scope>provided</scope>\n+            <!-- avoid dependencyConvergence issues -->\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>org.eclipse.sisu</groupId>\n+                    <artifactId>org.eclipse.sisu.plexus</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.maven</groupId>\n+            <artifactId>maven-core</artifactId>\n+            <scope>provided</scope>\n+            <!-- avoid dependencyConvergence issues -->\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>*</groupId>\n+                    <artifactId>*</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <artifactId>maven-invoker-plugin</artifactId>\n+                <version>3.2.1</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "760ecadc9c783a18e2f3be9a843571eeceba18eb"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQyMjAyMA==", "bodyText": "Good point. I actually had a look first whether other modules are using this plugin and back then I found none.\nBut there are two \"maven-invoker-way\" submodules under integration-tests that are using this plugin.\nExtra PR sounds reasonable since the versions in those two modules are already inconsistent.", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r475422020", "createdAt": "2020-08-24T08:23:06Z", "author": {"login": "famod"}, "path": "devtools/enforcer-rules/pom.xml", "diffHunk": "@@ -0,0 +1,68 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <parent>\n+        <artifactId>quarkus-devtools-all</artifactId>\n+        <groupId>io.quarkus</groupId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../</relativePath>\n+    </parent>\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <artifactId>quarkus-enforcer-rules</artifactId>\n+    <name>Quarkus - Enforcer Rules</name>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.apache.maven.enforcer</groupId>\n+            <artifactId>enforcer-api</artifactId>\n+            <version>${version.enforcer.plugin}</version>\n+            <scope>provided</scope>\n+            <!-- avoid dependencyConvergence issues -->\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>org.eclipse.sisu</groupId>\n+                    <artifactId>org.eclipse.sisu.plexus</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.maven</groupId>\n+            <artifactId>maven-core</artifactId>\n+            <scope>provided</scope>\n+            <!-- avoid dependencyConvergence issues -->\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>*</groupId>\n+                    <artifactId>*</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <artifactId>maven-invoker-plugin</artifactId>\n+                <version>3.2.1</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQxNjk3OA=="}, "originalCommit": {"oid": "760ecadc9c783a18e2f3be9a843571eeceba18eb"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQyNTMzMg==", "bodyText": "Agree.", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r475425332", "createdAt": "2020-08-24T08:28:52Z", "author": {"login": "Ladicek"}, "path": "devtools/enforcer-rules/pom.xml", "diffHunk": "@@ -0,0 +1,68 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <parent>\n+        <artifactId>quarkus-devtools-all</artifactId>\n+        <groupId>io.quarkus</groupId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../</relativePath>\n+    </parent>\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <artifactId>quarkus-enforcer-rules</artifactId>\n+    <name>Quarkus - Enforcer Rules</name>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.apache.maven.enforcer</groupId>\n+            <artifactId>enforcer-api</artifactId>\n+            <version>${version.enforcer.plugin}</version>\n+            <scope>provided</scope>\n+            <!-- avoid dependencyConvergence issues -->\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>org.eclipse.sisu</groupId>\n+                    <artifactId>org.eclipse.sisu.plexus</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.maven</groupId>\n+            <artifactId>maven-core</artifactId>\n+            <scope>provided</scope>\n+            <!-- avoid dependencyConvergence issues -->\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>*</groupId>\n+                    <artifactId>*</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <artifactId>maven-invoker-plugin</artifactId>\n+                <version>3.2.1</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQxNjk3OA=="}, "originalCommit": {"oid": "760ecadc9c783a18e2f3be9a843571eeceba18eb"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQyODMzNA==", "bodyText": "As a reminder I'll leave this open until this PR is merged.", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r475428334", "createdAt": "2020-08-24T08:34:12Z", "author": {"login": "famod"}, "path": "devtools/enforcer-rules/pom.xml", "diffHunk": "@@ -0,0 +1,68 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <parent>\n+        <artifactId>quarkus-devtools-all</artifactId>\n+        <groupId>io.quarkus</groupId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../</relativePath>\n+    </parent>\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <artifactId>quarkus-enforcer-rules</artifactId>\n+    <name>Quarkus - Enforcer Rules</name>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.apache.maven.enforcer</groupId>\n+            <artifactId>enforcer-api</artifactId>\n+            <version>${version.enforcer.plugin}</version>\n+            <scope>provided</scope>\n+            <!-- avoid dependencyConvergence issues -->\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>org.eclipse.sisu</groupId>\n+                    <artifactId>org.eclipse.sisu.plexus</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.apache.maven</groupId>\n+            <artifactId>maven-core</artifactId>\n+            <scope>provided</scope>\n+            <!-- avoid dependencyConvergence issues -->\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>*</groupId>\n+                    <artifactId>*</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <artifactId>maven-invoker-plugin</artifactId>\n+                <version>3.2.1</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQxNjk3OA=="}, "originalCommit": {"oid": "760ecadc9c783a18e2f3be9a843571eeceba18eb"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MjI2MjQ0OnYy", "diffSide": "RIGHT", "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwODoyMzozNlrOHFZeSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwOTozNjo0NlrOHGQBTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQyMjI4Mg==", "bodyText": "I'd just remove the \"Symbolic\" part, they are in no way symbolic, they are perfectly real :-) And their purpose is explained by \"for consistent build order\". We could add something like (not needed for any other reason) to the end, but I think that wouldn't be necessary.", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r475422282", "createdAt": "2020-08-24T08:23:36Z", "author": {"login": "Ladicek"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,184 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerLevel;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule2;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule2 {\n+\n+    private static final String GROUP_ID_PREFIX = \"io.quarkus\";\n+    private static final String DEPLOYMENT_ARTIFACT_ID_SUFFIX = \"-deployment\";\n+\n+    private static final String EXT_PROPERTIES_PATH = \"META-INF/quarkus-extension.properties\";\n+\n+    private static final String REQ_TYPE = \"pom\";\n+    private static final String REQ_SCOPE = \"test\";\n+\n+    private static final String DEP_TEMPLATE = \"        <dependency>\\n\"\n+            + \"            <groupId>%s</groupId>\\n\"\n+            + \"            <artifactId>%s</artifactId>\\n\"\n+            + \"            <version>${project.version}</version>\\n\"\n+            + \"            <type>\" + REQ_TYPE + \"</type>\\n\"\n+            + \"            <scope>\" + REQ_SCOPE + \"</scope>\\n\"\n+            + \"            <exclusions>\\n\"\n+            + \"                <exclusion>\\n\"\n+            + \"                    <groupId>*</groupId>\\n\"\n+            + \"                    <artifactId>*</artifactId>\\n\"\n+            + \"                </exclusion>\\n\"\n+            + \"            </exclusions>\\n\"\n+            + \"        </dependency>\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    private EnforcerLevel level = EnforcerLevel.ERROR;\n+\n+    @Override\n+    public EnforcerLevel getLevel() {\n+        return level;\n+    }\n+\n+    public void setLevel(EnforcerLevel level) {\n+        this.level = level;\n+    }\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(\"Failed to get project from EnforcerRuleHelper\", e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Artifact> nonDeploymentArtifactsByGAV = project.getArtifacts().stream()\n+                .filter(artifact -> \"jar\".equals(artifact.getType()))\n+                .filter(artifact -> artifact.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .filter(artifact -> !artifact.getArtifactId().endsWith(DEPLOYMENT_ARTIFACT_ID_SUFFIX))\n+                .collect(Collectors.toMap(this::buildGAVKey, a -> a));\n+\n+        // Skip if artifacts are not resolved.\n+        // To avoid this \"soft exit\", explicit resolving would be necessary but that is pretty elaborate in an enforcer rule.\n+        // If the build goal is \"late\" enough, artifacts for the respective scope *will* be resolved automatically.\n+        if (nonDeploymentArtifactsByGAV.values().stream().anyMatch(artifact -> !artifact.isResolved())) {\n+            logger.warn(\"Skipping rule \" + RequiresMinimalDeploymentDependency.class.getSimpleName()\n+                    + \": Artifacts are not resolved, consider using a later build goal like 'package'.\");\n+            return;\n+        }\n+\n+        String projArtifactKey = buildGAVKey(project.getArtifact());\n+\n+        Map<String, Dependency> directDepsByGAV = project.getDependencies().stream()\n+                .filter(d -> d.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .collect(Collectors.toMap(d -> d.getGroupId() + \":\" + d.getArtifactId() + \":\" + d.getVersion(), d -> d,\n+                        (a, b) -> a));\n+\n+        List<String> missingDeploymentDeps = nonDeploymentArtifactsByGAV.entrySet().parallelStream()\n+                .filter(entry -> directDepsByGAV.containsKey(entry.getKey())) // only direct deps\n+                .map(entry -> DEPLOYMENT_GAV_CACHE.computeIfAbsent(entry.getKey(), k -> parseDeploymentGAV(entry.getValue())))\n+                .filter(optDeploymentGAV -> optDeploymentGAV\n+                        .map(deploymentGAV -> !isMinDeploymentDepPresent(deploymentGAV, projArtifactKey, directDepsByGAV))\n+                        .orElse(false))\n+                .map(Optional::get)\n+                .sorted()\n+                .collect(Collectors.toList());\n+\n+        if (!missingDeploymentDeps.isEmpty()) {\n+            String requiredDeps = missingDeploymentDeps.stream()\n+                    .map(gav -> (Object[]) gav.split(\":\"))\n+                    .map(gavArray -> String.format(DEP_TEMPLATE, gavArray))\n+                    .collect(Collectors.joining(\"\\n\"));\n+            throw new EnforcerRuleException(missingDeploymentDeps.size()\n+                    + \" *-deployment dependencies are missing/configured incorrectly:\\n\"\n+                    + \"    \" + missingDeploymentDeps.stream().collect(Collectors.joining(\"\\n    \"))\n+                    + \"\\n\\nTo fix this issue, add the following dependencies to pom.xml:\\n\\n\"\n+                    + \"        <!-- \\\"Symbolic\\\" test dependencies to *-deployment artifacts for consistent build order -->\\n\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "760ecadc9c783a18e2f3be9a843571eeceba18eb"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQyNzQ1OQ==", "bodyText": "Glad you see it this way because I was not entirely happy with \"symbolic\" vs./+ \"minimal\" either.\nHow about replacing \"Symbolic\" with \"Minimal\", hinting at the rule class and adding some javadoc to the rule?", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r475427459", "createdAt": "2020-08-24T08:32:42Z", "author": {"login": "famod"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,184 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerLevel;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule2;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule2 {\n+\n+    private static final String GROUP_ID_PREFIX = \"io.quarkus\";\n+    private static final String DEPLOYMENT_ARTIFACT_ID_SUFFIX = \"-deployment\";\n+\n+    private static final String EXT_PROPERTIES_PATH = \"META-INF/quarkus-extension.properties\";\n+\n+    private static final String REQ_TYPE = \"pom\";\n+    private static final String REQ_SCOPE = \"test\";\n+\n+    private static final String DEP_TEMPLATE = \"        <dependency>\\n\"\n+            + \"            <groupId>%s</groupId>\\n\"\n+            + \"            <artifactId>%s</artifactId>\\n\"\n+            + \"            <version>${project.version}</version>\\n\"\n+            + \"            <type>\" + REQ_TYPE + \"</type>\\n\"\n+            + \"            <scope>\" + REQ_SCOPE + \"</scope>\\n\"\n+            + \"            <exclusions>\\n\"\n+            + \"                <exclusion>\\n\"\n+            + \"                    <groupId>*</groupId>\\n\"\n+            + \"                    <artifactId>*</artifactId>\\n\"\n+            + \"                </exclusion>\\n\"\n+            + \"            </exclusions>\\n\"\n+            + \"        </dependency>\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    private EnforcerLevel level = EnforcerLevel.ERROR;\n+\n+    @Override\n+    public EnforcerLevel getLevel() {\n+        return level;\n+    }\n+\n+    public void setLevel(EnforcerLevel level) {\n+        this.level = level;\n+    }\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(\"Failed to get project from EnforcerRuleHelper\", e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Artifact> nonDeploymentArtifactsByGAV = project.getArtifacts().stream()\n+                .filter(artifact -> \"jar\".equals(artifact.getType()))\n+                .filter(artifact -> artifact.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .filter(artifact -> !artifact.getArtifactId().endsWith(DEPLOYMENT_ARTIFACT_ID_SUFFIX))\n+                .collect(Collectors.toMap(this::buildGAVKey, a -> a));\n+\n+        // Skip if artifacts are not resolved.\n+        // To avoid this \"soft exit\", explicit resolving would be necessary but that is pretty elaborate in an enforcer rule.\n+        // If the build goal is \"late\" enough, artifacts for the respective scope *will* be resolved automatically.\n+        if (nonDeploymentArtifactsByGAV.values().stream().anyMatch(artifact -> !artifact.isResolved())) {\n+            logger.warn(\"Skipping rule \" + RequiresMinimalDeploymentDependency.class.getSimpleName()\n+                    + \": Artifacts are not resolved, consider using a later build goal like 'package'.\");\n+            return;\n+        }\n+\n+        String projArtifactKey = buildGAVKey(project.getArtifact());\n+\n+        Map<String, Dependency> directDepsByGAV = project.getDependencies().stream()\n+                .filter(d -> d.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .collect(Collectors.toMap(d -> d.getGroupId() + \":\" + d.getArtifactId() + \":\" + d.getVersion(), d -> d,\n+                        (a, b) -> a));\n+\n+        List<String> missingDeploymentDeps = nonDeploymentArtifactsByGAV.entrySet().parallelStream()\n+                .filter(entry -> directDepsByGAV.containsKey(entry.getKey())) // only direct deps\n+                .map(entry -> DEPLOYMENT_GAV_CACHE.computeIfAbsent(entry.getKey(), k -> parseDeploymentGAV(entry.getValue())))\n+                .filter(optDeploymentGAV -> optDeploymentGAV\n+                        .map(deploymentGAV -> !isMinDeploymentDepPresent(deploymentGAV, projArtifactKey, directDepsByGAV))\n+                        .orElse(false))\n+                .map(Optional::get)\n+                .sorted()\n+                .collect(Collectors.toList());\n+\n+        if (!missingDeploymentDeps.isEmpty()) {\n+            String requiredDeps = missingDeploymentDeps.stream()\n+                    .map(gav -> (Object[]) gav.split(\":\"))\n+                    .map(gavArray -> String.format(DEP_TEMPLATE, gavArray))\n+                    .collect(Collectors.joining(\"\\n\"));\n+            throw new EnforcerRuleException(missingDeploymentDeps.size()\n+                    + \" *-deployment dependencies are missing/configured incorrectly:\\n\"\n+                    + \"    \" + missingDeploymentDeps.stream().collect(Collectors.joining(\"\\n    \"))\n+                    + \"\\n\\nTo fix this issue, add the following dependencies to pom.xml:\\n\\n\"\n+                    + \"        <!-- \\\"Symbolic\\\" test dependencies to *-deployment artifacts for consistent build order -->\\n\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQyMjI4Mg=="}, "originalCommit": {"oid": "760ecadc9c783a18e2f3be9a843571eeceba18eb"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0NjU4Mg==", "bodyText": "Minimal makes a lot more sense, as the enforcer rule attempts to find a minimal set of -deployment dependencies to add. I personally don't think it's necessary, but I'll leave it to you :-)", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r475446582", "createdAt": "2020-08-24T09:04:31Z", "author": {"login": "Ladicek"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,184 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerLevel;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule2;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule2 {\n+\n+    private static final String GROUP_ID_PREFIX = \"io.quarkus\";\n+    private static final String DEPLOYMENT_ARTIFACT_ID_SUFFIX = \"-deployment\";\n+\n+    private static final String EXT_PROPERTIES_PATH = \"META-INF/quarkus-extension.properties\";\n+\n+    private static final String REQ_TYPE = \"pom\";\n+    private static final String REQ_SCOPE = \"test\";\n+\n+    private static final String DEP_TEMPLATE = \"        <dependency>\\n\"\n+            + \"            <groupId>%s</groupId>\\n\"\n+            + \"            <artifactId>%s</artifactId>\\n\"\n+            + \"            <version>${project.version}</version>\\n\"\n+            + \"            <type>\" + REQ_TYPE + \"</type>\\n\"\n+            + \"            <scope>\" + REQ_SCOPE + \"</scope>\\n\"\n+            + \"            <exclusions>\\n\"\n+            + \"                <exclusion>\\n\"\n+            + \"                    <groupId>*</groupId>\\n\"\n+            + \"                    <artifactId>*</artifactId>\\n\"\n+            + \"                </exclusion>\\n\"\n+            + \"            </exclusions>\\n\"\n+            + \"        </dependency>\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    private EnforcerLevel level = EnforcerLevel.ERROR;\n+\n+    @Override\n+    public EnforcerLevel getLevel() {\n+        return level;\n+    }\n+\n+    public void setLevel(EnforcerLevel level) {\n+        this.level = level;\n+    }\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(\"Failed to get project from EnforcerRuleHelper\", e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Artifact> nonDeploymentArtifactsByGAV = project.getArtifacts().stream()\n+                .filter(artifact -> \"jar\".equals(artifact.getType()))\n+                .filter(artifact -> artifact.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .filter(artifact -> !artifact.getArtifactId().endsWith(DEPLOYMENT_ARTIFACT_ID_SUFFIX))\n+                .collect(Collectors.toMap(this::buildGAVKey, a -> a));\n+\n+        // Skip if artifacts are not resolved.\n+        // To avoid this \"soft exit\", explicit resolving would be necessary but that is pretty elaborate in an enforcer rule.\n+        // If the build goal is \"late\" enough, artifacts for the respective scope *will* be resolved automatically.\n+        if (nonDeploymentArtifactsByGAV.values().stream().anyMatch(artifact -> !artifact.isResolved())) {\n+            logger.warn(\"Skipping rule \" + RequiresMinimalDeploymentDependency.class.getSimpleName()\n+                    + \": Artifacts are not resolved, consider using a later build goal like 'package'.\");\n+            return;\n+        }\n+\n+        String projArtifactKey = buildGAVKey(project.getArtifact());\n+\n+        Map<String, Dependency> directDepsByGAV = project.getDependencies().stream()\n+                .filter(d -> d.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .collect(Collectors.toMap(d -> d.getGroupId() + \":\" + d.getArtifactId() + \":\" + d.getVersion(), d -> d,\n+                        (a, b) -> a));\n+\n+        List<String> missingDeploymentDeps = nonDeploymentArtifactsByGAV.entrySet().parallelStream()\n+                .filter(entry -> directDepsByGAV.containsKey(entry.getKey())) // only direct deps\n+                .map(entry -> DEPLOYMENT_GAV_CACHE.computeIfAbsent(entry.getKey(), k -> parseDeploymentGAV(entry.getValue())))\n+                .filter(optDeploymentGAV -> optDeploymentGAV\n+                        .map(deploymentGAV -> !isMinDeploymentDepPresent(deploymentGAV, projArtifactKey, directDepsByGAV))\n+                        .orElse(false))\n+                .map(Optional::get)\n+                .sorted()\n+                .collect(Collectors.toList());\n+\n+        if (!missingDeploymentDeps.isEmpty()) {\n+            String requiredDeps = missingDeploymentDeps.stream()\n+                    .map(gav -> (Object[]) gav.split(\":\"))\n+                    .map(gavArray -> String.format(DEP_TEMPLATE, gavArray))\n+                    .collect(Collectors.joining(\"\\n\"));\n+            throw new EnforcerRuleException(missingDeploymentDeps.size()\n+                    + \" *-deployment dependencies are missing/configured incorrectly:\\n\"\n+                    + \"    \" + missingDeploymentDeps.stream().collect(Collectors.joining(\"\\n    \"))\n+                    + \"\\n\\nTo fix this issue, add the following dependencies to pom.xml:\\n\\n\"\n+                    + \"        <!-- \\\"Symbolic\\\" test dependencies to *-deployment artifacts for consistent build order -->\\n\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQyMjI4Mg=="}, "originalCommit": {"oid": "760ecadc9c783a18e2f3be9a843571eeceba18eb"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxNTk4Mw==", "bodyText": "Done.", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r476315983", "createdAt": "2020-08-25T09:36:46Z", "author": {"login": "famod"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,184 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerLevel;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule2;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule2 {\n+\n+    private static final String GROUP_ID_PREFIX = \"io.quarkus\";\n+    private static final String DEPLOYMENT_ARTIFACT_ID_SUFFIX = \"-deployment\";\n+\n+    private static final String EXT_PROPERTIES_PATH = \"META-INF/quarkus-extension.properties\";\n+\n+    private static final String REQ_TYPE = \"pom\";\n+    private static final String REQ_SCOPE = \"test\";\n+\n+    private static final String DEP_TEMPLATE = \"        <dependency>\\n\"\n+            + \"            <groupId>%s</groupId>\\n\"\n+            + \"            <artifactId>%s</artifactId>\\n\"\n+            + \"            <version>${project.version}</version>\\n\"\n+            + \"            <type>\" + REQ_TYPE + \"</type>\\n\"\n+            + \"            <scope>\" + REQ_SCOPE + \"</scope>\\n\"\n+            + \"            <exclusions>\\n\"\n+            + \"                <exclusion>\\n\"\n+            + \"                    <groupId>*</groupId>\\n\"\n+            + \"                    <artifactId>*</artifactId>\\n\"\n+            + \"                </exclusion>\\n\"\n+            + \"            </exclusions>\\n\"\n+            + \"        </dependency>\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    private EnforcerLevel level = EnforcerLevel.ERROR;\n+\n+    @Override\n+    public EnforcerLevel getLevel() {\n+        return level;\n+    }\n+\n+    public void setLevel(EnforcerLevel level) {\n+        this.level = level;\n+    }\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(\"Failed to get project from EnforcerRuleHelper\", e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Artifact> nonDeploymentArtifactsByGAV = project.getArtifacts().stream()\n+                .filter(artifact -> \"jar\".equals(artifact.getType()))\n+                .filter(artifact -> artifact.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .filter(artifact -> !artifact.getArtifactId().endsWith(DEPLOYMENT_ARTIFACT_ID_SUFFIX))\n+                .collect(Collectors.toMap(this::buildGAVKey, a -> a));\n+\n+        // Skip if artifacts are not resolved.\n+        // To avoid this \"soft exit\", explicit resolving would be necessary but that is pretty elaborate in an enforcer rule.\n+        // If the build goal is \"late\" enough, artifacts for the respective scope *will* be resolved automatically.\n+        if (nonDeploymentArtifactsByGAV.values().stream().anyMatch(artifact -> !artifact.isResolved())) {\n+            logger.warn(\"Skipping rule \" + RequiresMinimalDeploymentDependency.class.getSimpleName()\n+                    + \": Artifacts are not resolved, consider using a later build goal like 'package'.\");\n+            return;\n+        }\n+\n+        String projArtifactKey = buildGAVKey(project.getArtifact());\n+\n+        Map<String, Dependency> directDepsByGAV = project.getDependencies().stream()\n+                .filter(d -> d.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .collect(Collectors.toMap(d -> d.getGroupId() + \":\" + d.getArtifactId() + \":\" + d.getVersion(), d -> d,\n+                        (a, b) -> a));\n+\n+        List<String> missingDeploymentDeps = nonDeploymentArtifactsByGAV.entrySet().parallelStream()\n+                .filter(entry -> directDepsByGAV.containsKey(entry.getKey())) // only direct deps\n+                .map(entry -> DEPLOYMENT_GAV_CACHE.computeIfAbsent(entry.getKey(), k -> parseDeploymentGAV(entry.getValue())))\n+                .filter(optDeploymentGAV -> optDeploymentGAV\n+                        .map(deploymentGAV -> !isMinDeploymentDepPresent(deploymentGAV, projArtifactKey, directDepsByGAV))\n+                        .orElse(false))\n+                .map(Optional::get)\n+                .sorted()\n+                .collect(Collectors.toList());\n+\n+        if (!missingDeploymentDeps.isEmpty()) {\n+            String requiredDeps = missingDeploymentDeps.stream()\n+                    .map(gav -> (Object[]) gav.split(\":\"))\n+                    .map(gavArray -> String.format(DEP_TEMPLATE, gavArray))\n+                    .collect(Collectors.joining(\"\\n\"));\n+            throw new EnforcerRuleException(missingDeploymentDeps.size()\n+                    + \" *-deployment dependencies are missing/configured incorrectly:\\n\"\n+                    + \"    \" + missingDeploymentDeps.stream().collect(Collectors.joining(\"\\n    \"))\n+                    + \"\\n\\nTo fix this issue, add the following dependencies to pom.xml:\\n\\n\"\n+                    + \"        <!-- \\\"Symbolic\\\" test dependencies to *-deployment artifacts for consistent build order -->\\n\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQyMjI4Mg=="}, "originalCommit": {"oid": "760ecadc9c783a18e2f3be9a843571eeceba18eb"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NTk4Mjg0OnYy", "diffSide": "RIGHT", "path": "devtools/enforcer-rules/src/it/smoketest/ext1/deployment/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMjoxMDoxMlrOHHfdWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMjozODo0N1rOHHgG2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYxNzQ5Ng==", "bodyText": "To be 100% accurate, the deployment module should depend on the runtime one.", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r477617496", "createdAt": "2020-08-26T22:10:12Z", "author": {"login": "aloubyansky"}, "path": "devtools/enforcer-rules/src/it/smoketest/ext1/deployment/pom.xml", "diffHunk": "@@ -0,0 +1,13 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-enforcer-rules-smoketest-ext1-parent</artifactId>\n+        <version>1.0-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>quarkus-enforcer-rules-smoketest-ext1-deployment</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3260a3f5ce255e113aaeda090f914339e93da602"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYyODEyMQ==", "bodyText": "Good point, will add it!", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r477628121", "createdAt": "2020-08-26T22:38:47Z", "author": {"login": "famod"}, "path": "devtools/enforcer-rules/src/it/smoketest/ext1/deployment/pom.xml", "diffHunk": "@@ -0,0 +1,13 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-enforcer-rules-smoketest-ext1-parent</artifactId>\n+        <version>1.0-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>quarkus-enforcer-rules-smoketest-ext1-deployment</artifactId>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYxNzQ5Ng=="}, "originalCommit": {"oid": "3260a3f5ce255e113aaeda090f914339e93da602"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4NjAwNzg2OnYy", "diffSide": "RIGHT", "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMjoyMDowMlrOHHfr7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMTo0NDozMFrOHIMcMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYyMTIyOA==", "bodyText": "One thing to keep in mind for the future is other extension projects (out there in the community) may want to benefit from this too. In which case GROUP_ID_PREFIX should be either configurable or simply removed in favor of a different approach. E.g. these artifacts are supposed to be resolved at this point, aren't they? We could simply check for the presence of the extension descriptor and also filter based on the resolved path (to collect only those that are found in the current workspace).", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r477621228", "createdAt": "2020-08-26T22:20:02Z", "author": {"login": "aloubyansky"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,188 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerLevel;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule2;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+/**\n+ * Enforces that for each direct \"runtime\" dependency the current project also defines a direct minimal \"*-deployment\"\n+ * dependency to produce a consistent build order.\n+ */\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule2 {\n+\n+    private static final String GROUP_ID_PREFIX = \"io.quarkus\";\n+    private static final String DEPLOYMENT_ARTIFACT_ID_SUFFIX = \"-deployment\";\n+\n+    private static final String EXT_PROPERTIES_PATH = \"META-INF/quarkus-extension.properties\";\n+\n+    private static final String REQ_TYPE = \"pom\";\n+    private static final String REQ_SCOPE = \"test\";\n+\n+    private static final String DEP_TEMPLATE = \"        <dependency>\\n\"\n+            + \"            <groupId>%s</groupId>\\n\"\n+            + \"            <artifactId>%s</artifactId>\\n\"\n+            + \"            <version>${project.version}</version>\\n\"\n+            + \"            <type>\" + REQ_TYPE + \"</type>\\n\"\n+            + \"            <scope>\" + REQ_SCOPE + \"</scope>\\n\"\n+            + \"            <exclusions>\\n\"\n+            + \"                <exclusion>\\n\"\n+            + \"                    <groupId>*</groupId>\\n\"\n+            + \"                    <artifactId>*</artifactId>\\n\"\n+            + \"                </exclusion>\\n\"\n+            + \"            </exclusions>\\n\"\n+            + \"        </dependency>\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    private EnforcerLevel level = EnforcerLevel.ERROR;\n+\n+    @Override\n+    public EnforcerLevel getLevel() {\n+        return level;\n+    }\n+\n+    public void setLevel(EnforcerLevel level) {\n+        this.level = level;\n+    }\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(\"Failed to get project from EnforcerRuleHelper\", e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Artifact> nonDeploymentArtifactsByGAV = project.getArtifacts().stream()\n+                .filter(artifact -> \"jar\".equals(artifact.getType()))\n+                .filter(artifact -> artifact.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .filter(artifact -> !artifact.getArtifactId().endsWith(DEPLOYMENT_ARTIFACT_ID_SUFFIX))\n+                .collect(Collectors.toMap(this::buildGAVKey, a -> a));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3260a3f5ce255e113aaeda090f914339e93da602"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYyNzkwMA==", "bodyText": "E.g. these artifacts are supposed to be resolved at this point, aren't they?\n\nYes!\n\nIn which case GROUP_ID_PREFIX should be either configurable\n\nRules can have parameters so this would be pretty simple, yes.\n\nWe could simply check for the presence of the extension descriptor\n\nIf I understood you correctly, this would mean we would \"open\" each jar artifact to check whether it contains a descriptor file. This will come at a price, but maybe it is just a few additional milliseconds in the end.\n\nalso filter based on the resolved path (to collect only those that are found in the current workspace)\n\nCertainly possible but I see problems when building only a subtree of the repo (reactor does not contain all modules in this case).", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r477627900", "createdAt": "2020-08-26T22:38:11Z", "author": {"login": "famod"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,188 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerLevel;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule2;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+/**\n+ * Enforces that for each direct \"runtime\" dependency the current project also defines a direct minimal \"*-deployment\"\n+ * dependency to produce a consistent build order.\n+ */\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule2 {\n+\n+    private static final String GROUP_ID_PREFIX = \"io.quarkus\";\n+    private static final String DEPLOYMENT_ARTIFACT_ID_SUFFIX = \"-deployment\";\n+\n+    private static final String EXT_PROPERTIES_PATH = \"META-INF/quarkus-extension.properties\";\n+\n+    private static final String REQ_TYPE = \"pom\";\n+    private static final String REQ_SCOPE = \"test\";\n+\n+    private static final String DEP_TEMPLATE = \"        <dependency>\\n\"\n+            + \"            <groupId>%s</groupId>\\n\"\n+            + \"            <artifactId>%s</artifactId>\\n\"\n+            + \"            <version>${project.version}</version>\\n\"\n+            + \"            <type>\" + REQ_TYPE + \"</type>\\n\"\n+            + \"            <scope>\" + REQ_SCOPE + \"</scope>\\n\"\n+            + \"            <exclusions>\\n\"\n+            + \"                <exclusion>\\n\"\n+            + \"                    <groupId>*</groupId>\\n\"\n+            + \"                    <artifactId>*</artifactId>\\n\"\n+            + \"                </exclusion>\\n\"\n+            + \"            </exclusions>\\n\"\n+            + \"        </dependency>\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    private EnforcerLevel level = EnforcerLevel.ERROR;\n+\n+    @Override\n+    public EnforcerLevel getLevel() {\n+        return level;\n+    }\n+\n+    public void setLevel(EnforcerLevel level) {\n+        this.level = level;\n+    }\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(\"Failed to get project from EnforcerRuleHelper\", e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Artifact> nonDeploymentArtifactsByGAV = project.getArtifacts().stream()\n+                .filter(artifact -> \"jar\".equals(artifact.getType()))\n+                .filter(artifact -> artifact.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .filter(artifact -> !artifact.getArtifactId().endsWith(DEPLOYMENT_ARTIFACT_ID_SUFFIX))\n+                .collect(Collectors.toMap(this::buildGAVKey, a -> a));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYyMTIyOA=="}, "originalCommit": {"oid": "3260a3f5ce255e113aaeda090f914339e93da602"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODEwNDA3Ng==", "bodyText": "I don't think checking for the presence of the descriptor will be a bottle neck. We are actually doing this check everywhere where we are analyzing the classpath.\nAs to the subtree, you could use Quarkus bootstrap MavenArtifactResolver instead. There we discover the workspace and it'll work consistently for every build phase and won't depend on the module which was targeted by the mvn cli. I've done this trick in other mojos.", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r478104076", "createdAt": "2020-08-27T04:34:51Z", "author": {"login": "aloubyansky"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,188 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerLevel;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule2;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+/**\n+ * Enforces that for each direct \"runtime\" dependency the current project also defines a direct minimal \"*-deployment\"\n+ * dependency to produce a consistent build order.\n+ */\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule2 {\n+\n+    private static final String GROUP_ID_PREFIX = \"io.quarkus\";\n+    private static final String DEPLOYMENT_ARTIFACT_ID_SUFFIX = \"-deployment\";\n+\n+    private static final String EXT_PROPERTIES_PATH = \"META-INF/quarkus-extension.properties\";\n+\n+    private static final String REQ_TYPE = \"pom\";\n+    private static final String REQ_SCOPE = \"test\";\n+\n+    private static final String DEP_TEMPLATE = \"        <dependency>\\n\"\n+            + \"            <groupId>%s</groupId>\\n\"\n+            + \"            <artifactId>%s</artifactId>\\n\"\n+            + \"            <version>${project.version}</version>\\n\"\n+            + \"            <type>\" + REQ_TYPE + \"</type>\\n\"\n+            + \"            <scope>\" + REQ_SCOPE + \"</scope>\\n\"\n+            + \"            <exclusions>\\n\"\n+            + \"                <exclusion>\\n\"\n+            + \"                    <groupId>*</groupId>\\n\"\n+            + \"                    <artifactId>*</artifactId>\\n\"\n+            + \"                </exclusion>\\n\"\n+            + \"            </exclusions>\\n\"\n+            + \"        </dependency>\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    private EnforcerLevel level = EnforcerLevel.ERROR;\n+\n+    @Override\n+    public EnforcerLevel getLevel() {\n+        return level;\n+    }\n+\n+    public void setLevel(EnforcerLevel level) {\n+        this.level = level;\n+    }\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(\"Failed to get project from EnforcerRuleHelper\", e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Artifact> nonDeploymentArtifactsByGAV = project.getArtifacts().stream()\n+                .filter(artifact -> \"jar\".equals(artifact.getType()))\n+                .filter(artifact -> artifact.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .filter(artifact -> !artifact.getArtifactId().endsWith(DEPLOYMENT_ARTIFACT_ID_SUFFIX))\n+                .collect(Collectors.toMap(this::buildGAVKey, a -> a));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYyMTIyOA=="}, "originalCommit": {"oid": "3260a3f5ce255e113aaeda090f914339e93da602"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1NDQ4MQ==", "bodyText": "As to the subtree, you could use Quarkus bootstrap MavenArtifactResolver instead\n\nI actually thought about that when I hit that artifact resolve problem but I decided for KISS until we really, really need it.\nIn the current form, the rule is really \"independent\".", "url": "https://github.com/quarkusio/quarkus/pull/11331#discussion_r478354481", "createdAt": "2020-08-27T11:44:30Z", "author": {"login": "famod"}, "path": "devtools/enforcer-rules/src/main/java/io/quarkus/enforcer/RequiresMinimalDeploymentDependency.java", "diffHunk": "@@ -0,0 +1,188 @@\n+package io.quarkus.enforcer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import org.apache.maven.artifact.Artifact;\n+import org.apache.maven.enforcer.rule.api.EnforcerLevel;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule;\n+import org.apache.maven.enforcer.rule.api.EnforcerRule2;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleException;\n+import org.apache.maven.enforcer.rule.api.EnforcerRuleHelper;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.plugin.logging.Log;\n+import org.apache.maven.project.MavenProject;\n+import org.codehaus.plexus.component.configurator.expression.ExpressionEvaluationException;\n+\n+/**\n+ * Enforces that for each direct \"runtime\" dependency the current project also defines a direct minimal \"*-deployment\"\n+ * dependency to produce a consistent build order.\n+ */\n+public class RequiresMinimalDeploymentDependency implements EnforcerRule2 {\n+\n+    private static final String GROUP_ID_PREFIX = \"io.quarkus\";\n+    private static final String DEPLOYMENT_ARTIFACT_ID_SUFFIX = \"-deployment\";\n+\n+    private static final String EXT_PROPERTIES_PATH = \"META-INF/quarkus-extension.properties\";\n+\n+    private static final String REQ_TYPE = \"pom\";\n+    private static final String REQ_SCOPE = \"test\";\n+\n+    private static final String DEP_TEMPLATE = \"        <dependency>\\n\"\n+            + \"            <groupId>%s</groupId>\\n\"\n+            + \"            <artifactId>%s</artifactId>\\n\"\n+            + \"            <version>${project.version}</version>\\n\"\n+            + \"            <type>\" + REQ_TYPE + \"</type>\\n\"\n+            + \"            <scope>\" + REQ_SCOPE + \"</scope>\\n\"\n+            + \"            <exclusions>\\n\"\n+            + \"                <exclusion>\\n\"\n+            + \"                    <groupId>*</groupId>\\n\"\n+            + \"                    <artifactId>*</artifactId>\\n\"\n+            + \"                </exclusion>\\n\"\n+            + \"            </exclusions>\\n\"\n+            + \"        </dependency>\";\n+\n+    private static final Map<String, Optional<String>> DEPLOYMENT_GAV_CACHE = new ConcurrentHashMap<>();\n+\n+    private Log logger;\n+\n+    private EnforcerLevel level = EnforcerLevel.ERROR;\n+\n+    @Override\n+    public EnforcerLevel getLevel() {\n+        return level;\n+    }\n+\n+    public void setLevel(EnforcerLevel level) {\n+        this.level = level;\n+    }\n+\n+    @Override\n+    public void execute(EnforcerRuleHelper helper) throws EnforcerRuleException {\n+        logger = helper.getLog();\n+        MavenProject project;\n+        try {\n+            project = (MavenProject) helper.evaluate(\"${project}\");\n+        } catch (ExpressionEvaluationException e) {\n+            throw new IllegalStateException(\"Failed to get project from EnforcerRuleHelper\", e);\n+        }\n+\n+        // general notes:\n+        // - \"artifacts\" are needed to retrieve the actual jar files\n+        // - \"dependencies\" are needed to limit the scope to only the direct dependencies of the current module\n+        //   and to check for the proper scope, type and exclusions\n+        // - parents are not gathered here since it is expected that the rule is also active for those parents\n+        //   or those parents are not relevant\n+\n+        Map<String, Artifact> nonDeploymentArtifactsByGAV = project.getArtifacts().stream()\n+                .filter(artifact -> \"jar\".equals(artifact.getType()))\n+                .filter(artifact -> artifact.getGroupId().startsWith(GROUP_ID_PREFIX))\n+                .filter(artifact -> !artifact.getArtifactId().endsWith(DEPLOYMENT_ARTIFACT_ID_SUFFIX))\n+                .collect(Collectors.toMap(this::buildGAVKey, a -> a));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYyMTIyOA=="}, "originalCommit": {"oid": "3260a3f5ce255e113aaeda090f914339e93da602"}, "originalPosition": 92}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 726, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}