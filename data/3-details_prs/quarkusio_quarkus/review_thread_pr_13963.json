{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQyMjg4MTE1", "number": 13963, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNDoyODoyMVrOFHNJKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQxNDoyOTowMVrOFgZcWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDk5NjkwOnYy", "diffSide": "RIGHT", "path": "core/deployment/src/main/java/io/quarkus/deployment/pkg/steps/NativeImageBuildStep.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNDoyODoyMVrOIIk78A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNTo0Mjo1MlrOIIoMpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg2NDY4OA==", "bodyText": "Why is the log.info() conditionalized on isContainerBuild? Why ...replace(\"$\", \"\\\\$\")) only then? AFAIK, this is shell-escaping the GC policy in use which might be an inner class ($ separation). I believe it's because maybeRunInContainer conditionally already replaces the $. It makes the code overly complicated to read.", "url": "https://github.com/quarkusio/quarkus/pull/13963#discussion_r545864688", "createdAt": "2020-12-18T14:28:21Z", "author": {"login": "jerboaa"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/pkg/steps/NativeImageBuildStep.java", "diffHunk": "@@ -101,166 +101,60 @@ public NativeImageBuildItem build(NativeConfig nativeConfig, NativeImageSourceJa\n         final String runnerJarName = runnerJar.getFileName().toString();\n \n         HashMap<String, String> env = new HashMap<>(System.getenv());\n-        List<String> nativeImage;\n-\n-        String noPIE = \"\";\n+        List<String> containerCommand = null;\n+        List<String> nativeImage = null;\n \n         boolean isContainerBuild = nativeConfig.containerRuntime.isPresent() || nativeConfig.containerBuild;\n-        if (!isContainerBuild && SystemUtils.IS_OS_LINUX) {\n-            noPIE = detectNoPIE();\n+        if (!isContainerBuild) {\n+            nativeImage = getNativeImage(nativeConfig, processInheritIODisabled.isPresent(), outputDir, env);\n+            if (nativeImage == null) {\n+                assert SystemUtils.IS_OS_LINUX;\n+                // If we are on linux we can fallback to the builder image and expect the resulting binary to be able to\n+                // run on the host. Unfortunately the same is not true for other platforms.\n+                log.warn(\"Cannot find `native-image` in the GRAALVM_HOME, JAVA_HOME and System PATH.\" +\n+                        \"Install it using `gu install native-image`. Attempting to fall back to builder image.\");\n+                isContainerBuild = true;\n+            }\n+        }\n+        if (isContainerBuild) {\n+            containerCommand = setupContainerBuild(nativeConfig, processInheritIODisabled.isPresent(), outputDir);\n+            nativeImage = Collections.singletonList(\"native-image\");\n         }\n \n-        nativeImage = getNativeImage(nativeConfig, processInheritIODisabled, outputDir, env);\n-        final GraalVM.Version graalVMVersion = GraalVM.Version.ofBinary(nativeImage);\n+        final GraalVM.Version graalVMVersion = GraalVM.Version.ofBinary(containerCommand, nativeImage);\n \n         if (graalVMVersion.isDetected()) {\n             checkGraalVMVersion(graalVMVersion);\n         } else {\n             log.error(\"Unable to get GraalVM version from the native-image binary.\");\n         }\n \n+        String executableName = outputTargetBuildItem.getBaseName() + packageConfig.runnerSuffix;\n+        String noPIE = \"\";\n+        if (!isContainerBuild && SystemUtils.IS_OS_LINUX) {\n+            noPIE = detectNoPIE();\n+        }\n         try {\n-            List<String> command = new ArrayList<>(nativeImage);\n             if (nativeConfig.cleanupServer && !graalVMVersion.isMandrel()) {\n                 List<String> cleanup = new ArrayList<>(nativeImage);\n                 cleanup.add(\"--server-shutdown\");\n-                final ProcessBuilder pb = new ProcessBuilder(cleanup.toArray(new String[0]));\n+                cleanup = maybeRunInContainer(containerCommand, cleanup);\n+                final ProcessBuilder pb = new ProcessBuilder(cleanup);\n                 pb.directory(outputDir.toFile());\n                 final Process process = ProcessUtil.launchProcess(pb, processInheritIODisabled.isPresent());\n                 process.waitFor();\n             }\n-            boolean enableSslNative = false;\n-            for (NativeImageSystemPropertyBuildItem prop : nativeImageProperties) {\n-                //todo: this should be specific build items\n-                if (prop.getKey().equals(\"quarkus.ssl.native\") && prop.getValue() != null) {\n-                    enableSslNative = Boolean.parseBoolean(prop.getValue());\n-                } else if (prop.getKey().equals(\"quarkus.jni.enable\") && prop.getValue().equals(\"false\")) {\n-                    log.warn(\"Your application is setting the deprecated 'quarkus.jni.enable' configuration key to false.\"\n-                            + \" Please consider removing this configuration key as it is ignored (JNI is always enabled) and it\"\n-                            + \" will be removed in a future Quarkus version.\");\n-                } else if (prop.getKey().equals(\"quarkus.native.enable-all-security-services\") && prop.getValue() != null) {\n-                    nativeConfig.enableAllSecurityServices |= Boolean.parseBoolean(prop.getValue());\n-                } else if (prop.getKey().equals(\"quarkus.native.enable-all-charsets\") && prop.getValue() != null) {\n-                    nativeConfig.addAllCharsets |= Boolean.parseBoolean(prop.getValue());\n-                } else {\n-                    // todo maybe just -D is better than -J-D in this case\n-                    if (prop.getValue() == null) {\n-                        command.add(\"-J-D\" + prop.getKey());\n-                    } else {\n-                        command.add(\"-J-D\" + prop.getKey() + \"=\" + prop.getValue());\n-                    }\n-                }\n-            }\n-            command.add(\"-J-Duser.language=\" + System.getProperty(\"user.language\"));\n-            // Native image runtime uses the host's (i.e. build time) value of file.encoding\n-            // system property. We intentionally default this to UTF-8 to avoid platform specific\n-            // defaults to be picked up which can then result in inconsistent behaviour in the\n-            // generated native application\n-            command.add(\"-J-Dfile.encoding=UTF-8\");\n-\n-            if (enableSslNative) {\n-                nativeConfig.enableHttpsUrlHandler = true;\n-                nativeConfig.enableAllSecurityServices = true;\n-            }\n-\n-            handleAdditionalProperties(nativeConfig, command, isContainerBuild, outputDir);\n-            command.add(\"--initialize-at-build-time=\");\n-            command.add(\n-                    \"-H:InitialCollectionPolicy=com.oracle.svm.core.genscavenge.CollectionPolicy$BySpaceAndTime\"); //the default collection policy results in full GC's 50% of the time\n-            command.add(\"-H:+JNI\");\n-            command.add(\"-jar\");\n-            command.add(runnerJarName);\n-\n-            if (nativeConfig.enableFallbackImages) {\n-                command.add(\"-H:FallbackThreshold=5\");\n-            } else {\n-                //Default: be strict as those fallback images aren't very useful\n-                //and tend to cover up real problems.\n-                command.add(\"-H:FallbackThreshold=0\");\n-            }\n-\n-            if (nativeConfig.reportErrorsAtRuntime) {\n-                command.add(\"-H:+ReportUnsupportedElementsAtRuntime\");\n-            }\n-            if (nativeConfig.reportExceptionStackTraces) {\n-                command.add(\"-H:+ReportExceptionStackTraces\");\n-            }\n-            if (nativeConfig.debug.enabled) {\n-                if (graalVMVersion.isMandrel() || graalVMVersion.isNewerThan(GraalVM.Version.VERSION_20_1)) {\n-                    command.add(\"-g\");\n-                    command.add(\"-H:DebugInfoSourceSearchPath=\" + APP_SOURCES);\n-                }\n-            }\n-            if (nativeConfig.debugBuildProcess) {\n-                command.add(\"-J-Xrunjdwp:transport=dt_socket,address=\" + DEBUG_BUILD_PROCESS_PORT + \",server=y,suspend=y\");\n-            }\n-            if (nativeConfig.enableReports) {\n-                command.add(\"-H:+PrintAnalysisCallTree\");\n-            }\n-            if (nativeConfig.dumpProxies) {\n-                command.add(\"-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true\");\n-                if (nativeConfig.enableServer) {\n-                    log.warn(\n-                            \"Options dumpProxies and enableServer are both enabled: this will get the proxies dumped in an unknown external working directory\");\n-                }\n-            }\n-            if (nativeConfig.nativeImageXmx.isPresent()) {\n-                command.add(\"-J-Xmx\" + nativeConfig.nativeImageXmx.get());\n-            }\n-            List<String> protocols = new ArrayList<>(2);\n-            if (nativeConfig.enableHttpUrlHandler) {\n-                protocols.add(\"http\");\n-            }\n-            if (nativeConfig.enableHttpsUrlHandler) {\n-                protocols.add(\"https\");\n-            }\n-            if (nativeConfig.addAllCharsets) {\n-                command.add(\"-H:+AddAllCharsets\");\n-            } else {\n-                command.add(\"-H:-AddAllCharsets\");\n-            }\n-            if (!protocols.isEmpty()) {\n-                command.add(\"-H:EnableURLProtocols=\" + String.join(\",\", protocols));\n-            }\n-            if (nativeConfig.enableAllSecurityServices) {\n-                command.add(\"--enable-all-security-services\");\n-            }\n-            if (!noPIE.isEmpty()) {\n-                command.add(\"-H:NativeLinkerOption=\" + noPIE);\n-            }\n-\n-            if (!nativeConfig.enableIsolates) {\n-                command.add(\"-H:-SpawnIsolates\");\n-            }\n-            if (!nativeConfig.enableJni) {\n-                log.warn(\"Your application is setting the deprecated 'quarkus.native.enable-jni' configuration key to false.\"\n-                        + \" Please consider removing this configuration key as it is ignored (JNI is always enabled) and it\"\n-                        + \" will be removed in a future Quarkus version.\");\n-            }\n-            if (!nativeConfig.enableServer && !SystemUtils.IS_OS_WINDOWS && !graalVMVersion.isMandrel()) {\n-                command.add(\"--no-server\");\n-            }\n-            if (nativeConfig.enableVmInspection) {\n-                command.add(\"-H:+AllowVMInspection\");\n-            }\n-            if (nativeConfig.autoServiceLoaderRegistration) {\n-                command.add(\"-H:+UseServiceLoaderFeature\");\n-                //When enabling, at least print what exactly is being added:\n-                command.add(\"-H:+TraceServiceLoaderFeature\");\n+            List<String> buildCommand = getBuildCommand(nativeConfig, nativeImageProperties,\n+                    outputDir, runnerJarName, nativeImage, noPIE, isContainerBuild, graalVMVersion,\n+                    executableName);\n+            buildCommand = maybeRunInContainer(containerCommand, buildCommand);\n+            if (isContainerBuild) {\n+                log.info(String.join(\" \", buildCommand).replace(\"$\", \"\\\\$\"));\n             } else {\n-                command.add(\"-H:-UseServiceLoaderFeature\");\n+                log.info(String.join(\" \", buildCommand));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d66b885e1d1047ae4029f0f0d3fe0419b0ddce1"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg4NTc2OA==", "bodyText": "Correct, and it indeed complicates the code. I wanted the log output to be copy-pasteable so. Suggestions on how to improve this are welcome! Do you think keeping the log.info outside of the if and only do the replace in there would make things better?", "url": "https://github.com/quarkusio/quarkus/pull/13963#discussion_r545885768", "createdAt": "2020-12-18T14:54:53Z", "author": {"login": "zakkak"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/pkg/steps/NativeImageBuildStep.java", "diffHunk": "@@ -101,166 +101,60 @@ public NativeImageBuildItem build(NativeConfig nativeConfig, NativeImageSourceJa\n         final String runnerJarName = runnerJar.getFileName().toString();\n \n         HashMap<String, String> env = new HashMap<>(System.getenv());\n-        List<String> nativeImage;\n-\n-        String noPIE = \"\";\n+        List<String> containerCommand = null;\n+        List<String> nativeImage = null;\n \n         boolean isContainerBuild = nativeConfig.containerRuntime.isPresent() || nativeConfig.containerBuild;\n-        if (!isContainerBuild && SystemUtils.IS_OS_LINUX) {\n-            noPIE = detectNoPIE();\n+        if (!isContainerBuild) {\n+            nativeImage = getNativeImage(nativeConfig, processInheritIODisabled.isPresent(), outputDir, env);\n+            if (nativeImage == null) {\n+                assert SystemUtils.IS_OS_LINUX;\n+                // If we are on linux we can fallback to the builder image and expect the resulting binary to be able to\n+                // run on the host. Unfortunately the same is not true for other platforms.\n+                log.warn(\"Cannot find `native-image` in the GRAALVM_HOME, JAVA_HOME and System PATH.\" +\n+                        \"Install it using `gu install native-image`. Attempting to fall back to builder image.\");\n+                isContainerBuild = true;\n+            }\n+        }\n+        if (isContainerBuild) {\n+            containerCommand = setupContainerBuild(nativeConfig, processInheritIODisabled.isPresent(), outputDir);\n+            nativeImage = Collections.singletonList(\"native-image\");\n         }\n \n-        nativeImage = getNativeImage(nativeConfig, processInheritIODisabled, outputDir, env);\n-        final GraalVM.Version graalVMVersion = GraalVM.Version.ofBinary(nativeImage);\n+        final GraalVM.Version graalVMVersion = GraalVM.Version.ofBinary(containerCommand, nativeImage);\n \n         if (graalVMVersion.isDetected()) {\n             checkGraalVMVersion(graalVMVersion);\n         } else {\n             log.error(\"Unable to get GraalVM version from the native-image binary.\");\n         }\n \n+        String executableName = outputTargetBuildItem.getBaseName() + packageConfig.runnerSuffix;\n+        String noPIE = \"\";\n+        if (!isContainerBuild && SystemUtils.IS_OS_LINUX) {\n+            noPIE = detectNoPIE();\n+        }\n         try {\n-            List<String> command = new ArrayList<>(nativeImage);\n             if (nativeConfig.cleanupServer && !graalVMVersion.isMandrel()) {\n                 List<String> cleanup = new ArrayList<>(nativeImage);\n                 cleanup.add(\"--server-shutdown\");\n-                final ProcessBuilder pb = new ProcessBuilder(cleanup.toArray(new String[0]));\n+                cleanup = maybeRunInContainer(containerCommand, cleanup);\n+                final ProcessBuilder pb = new ProcessBuilder(cleanup);\n                 pb.directory(outputDir.toFile());\n                 final Process process = ProcessUtil.launchProcess(pb, processInheritIODisabled.isPresent());\n                 process.waitFor();\n             }\n-            boolean enableSslNative = false;\n-            for (NativeImageSystemPropertyBuildItem prop : nativeImageProperties) {\n-                //todo: this should be specific build items\n-                if (prop.getKey().equals(\"quarkus.ssl.native\") && prop.getValue() != null) {\n-                    enableSslNative = Boolean.parseBoolean(prop.getValue());\n-                } else if (prop.getKey().equals(\"quarkus.jni.enable\") && prop.getValue().equals(\"false\")) {\n-                    log.warn(\"Your application is setting the deprecated 'quarkus.jni.enable' configuration key to false.\"\n-                            + \" Please consider removing this configuration key as it is ignored (JNI is always enabled) and it\"\n-                            + \" will be removed in a future Quarkus version.\");\n-                } else if (prop.getKey().equals(\"quarkus.native.enable-all-security-services\") && prop.getValue() != null) {\n-                    nativeConfig.enableAllSecurityServices |= Boolean.parseBoolean(prop.getValue());\n-                } else if (prop.getKey().equals(\"quarkus.native.enable-all-charsets\") && prop.getValue() != null) {\n-                    nativeConfig.addAllCharsets |= Boolean.parseBoolean(prop.getValue());\n-                } else {\n-                    // todo maybe just -D is better than -J-D in this case\n-                    if (prop.getValue() == null) {\n-                        command.add(\"-J-D\" + prop.getKey());\n-                    } else {\n-                        command.add(\"-J-D\" + prop.getKey() + \"=\" + prop.getValue());\n-                    }\n-                }\n-            }\n-            command.add(\"-J-Duser.language=\" + System.getProperty(\"user.language\"));\n-            // Native image runtime uses the host's (i.e. build time) value of file.encoding\n-            // system property. We intentionally default this to UTF-8 to avoid platform specific\n-            // defaults to be picked up which can then result in inconsistent behaviour in the\n-            // generated native application\n-            command.add(\"-J-Dfile.encoding=UTF-8\");\n-\n-            if (enableSslNative) {\n-                nativeConfig.enableHttpsUrlHandler = true;\n-                nativeConfig.enableAllSecurityServices = true;\n-            }\n-\n-            handleAdditionalProperties(nativeConfig, command, isContainerBuild, outputDir);\n-            command.add(\"--initialize-at-build-time=\");\n-            command.add(\n-                    \"-H:InitialCollectionPolicy=com.oracle.svm.core.genscavenge.CollectionPolicy$BySpaceAndTime\"); //the default collection policy results in full GC's 50% of the time\n-            command.add(\"-H:+JNI\");\n-            command.add(\"-jar\");\n-            command.add(runnerJarName);\n-\n-            if (nativeConfig.enableFallbackImages) {\n-                command.add(\"-H:FallbackThreshold=5\");\n-            } else {\n-                //Default: be strict as those fallback images aren't very useful\n-                //and tend to cover up real problems.\n-                command.add(\"-H:FallbackThreshold=0\");\n-            }\n-\n-            if (nativeConfig.reportErrorsAtRuntime) {\n-                command.add(\"-H:+ReportUnsupportedElementsAtRuntime\");\n-            }\n-            if (nativeConfig.reportExceptionStackTraces) {\n-                command.add(\"-H:+ReportExceptionStackTraces\");\n-            }\n-            if (nativeConfig.debug.enabled) {\n-                if (graalVMVersion.isMandrel() || graalVMVersion.isNewerThan(GraalVM.Version.VERSION_20_1)) {\n-                    command.add(\"-g\");\n-                    command.add(\"-H:DebugInfoSourceSearchPath=\" + APP_SOURCES);\n-                }\n-            }\n-            if (nativeConfig.debugBuildProcess) {\n-                command.add(\"-J-Xrunjdwp:transport=dt_socket,address=\" + DEBUG_BUILD_PROCESS_PORT + \",server=y,suspend=y\");\n-            }\n-            if (nativeConfig.enableReports) {\n-                command.add(\"-H:+PrintAnalysisCallTree\");\n-            }\n-            if (nativeConfig.dumpProxies) {\n-                command.add(\"-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true\");\n-                if (nativeConfig.enableServer) {\n-                    log.warn(\n-                            \"Options dumpProxies and enableServer are both enabled: this will get the proxies dumped in an unknown external working directory\");\n-                }\n-            }\n-            if (nativeConfig.nativeImageXmx.isPresent()) {\n-                command.add(\"-J-Xmx\" + nativeConfig.nativeImageXmx.get());\n-            }\n-            List<String> protocols = new ArrayList<>(2);\n-            if (nativeConfig.enableHttpUrlHandler) {\n-                protocols.add(\"http\");\n-            }\n-            if (nativeConfig.enableHttpsUrlHandler) {\n-                protocols.add(\"https\");\n-            }\n-            if (nativeConfig.addAllCharsets) {\n-                command.add(\"-H:+AddAllCharsets\");\n-            } else {\n-                command.add(\"-H:-AddAllCharsets\");\n-            }\n-            if (!protocols.isEmpty()) {\n-                command.add(\"-H:EnableURLProtocols=\" + String.join(\",\", protocols));\n-            }\n-            if (nativeConfig.enableAllSecurityServices) {\n-                command.add(\"--enable-all-security-services\");\n-            }\n-            if (!noPIE.isEmpty()) {\n-                command.add(\"-H:NativeLinkerOption=\" + noPIE);\n-            }\n-\n-            if (!nativeConfig.enableIsolates) {\n-                command.add(\"-H:-SpawnIsolates\");\n-            }\n-            if (!nativeConfig.enableJni) {\n-                log.warn(\"Your application is setting the deprecated 'quarkus.native.enable-jni' configuration key to false.\"\n-                        + \" Please consider removing this configuration key as it is ignored (JNI is always enabled) and it\"\n-                        + \" will be removed in a future Quarkus version.\");\n-            }\n-            if (!nativeConfig.enableServer && !SystemUtils.IS_OS_WINDOWS && !graalVMVersion.isMandrel()) {\n-                command.add(\"--no-server\");\n-            }\n-            if (nativeConfig.enableVmInspection) {\n-                command.add(\"-H:+AllowVMInspection\");\n-            }\n-            if (nativeConfig.autoServiceLoaderRegistration) {\n-                command.add(\"-H:+UseServiceLoaderFeature\");\n-                //When enabling, at least print what exactly is being added:\n-                command.add(\"-H:+TraceServiceLoaderFeature\");\n+            List<String> buildCommand = getBuildCommand(nativeConfig, nativeImageProperties,\n+                    outputDir, runnerJarName, nativeImage, noPIE, isContainerBuild, graalVMVersion,\n+                    executableName);\n+            buildCommand = maybeRunInContainer(containerCommand, buildCommand);\n+            if (isContainerBuild) {\n+                log.info(String.join(\" \", buildCommand).replace(\"$\", \"\\\\$\"));\n             } else {\n-                command.add(\"-H:-UseServiceLoaderFeature\");\n+                log.info(String.join(\" \", buildCommand));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg2NDY4OA=="}, "originalCommit": {"oid": "4d66b885e1d1047ae4029f0f0d3fe0419b0ddce1"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg5ODk4Mg==", "bodyText": "Perhaps don't do the replace() call in maybeRunInContainer and do the escaping of $ only when you need it.", "url": "https://github.com/quarkusio/quarkus/pull/13963#discussion_r545898982", "createdAt": "2020-12-18T15:12:20Z", "author": {"login": "jerboaa"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/pkg/steps/NativeImageBuildStep.java", "diffHunk": "@@ -101,166 +101,60 @@ public NativeImageBuildItem build(NativeConfig nativeConfig, NativeImageSourceJa\n         final String runnerJarName = runnerJar.getFileName().toString();\n \n         HashMap<String, String> env = new HashMap<>(System.getenv());\n-        List<String> nativeImage;\n-\n-        String noPIE = \"\";\n+        List<String> containerCommand = null;\n+        List<String> nativeImage = null;\n \n         boolean isContainerBuild = nativeConfig.containerRuntime.isPresent() || nativeConfig.containerBuild;\n-        if (!isContainerBuild && SystemUtils.IS_OS_LINUX) {\n-            noPIE = detectNoPIE();\n+        if (!isContainerBuild) {\n+            nativeImage = getNativeImage(nativeConfig, processInheritIODisabled.isPresent(), outputDir, env);\n+            if (nativeImage == null) {\n+                assert SystemUtils.IS_OS_LINUX;\n+                // If we are on linux we can fallback to the builder image and expect the resulting binary to be able to\n+                // run on the host. Unfortunately the same is not true for other platforms.\n+                log.warn(\"Cannot find `native-image` in the GRAALVM_HOME, JAVA_HOME and System PATH.\" +\n+                        \"Install it using `gu install native-image`. Attempting to fall back to builder image.\");\n+                isContainerBuild = true;\n+            }\n+        }\n+        if (isContainerBuild) {\n+            containerCommand = setupContainerBuild(nativeConfig, processInheritIODisabled.isPresent(), outputDir);\n+            nativeImage = Collections.singletonList(\"native-image\");\n         }\n \n-        nativeImage = getNativeImage(nativeConfig, processInheritIODisabled, outputDir, env);\n-        final GraalVM.Version graalVMVersion = GraalVM.Version.ofBinary(nativeImage);\n+        final GraalVM.Version graalVMVersion = GraalVM.Version.ofBinary(containerCommand, nativeImage);\n \n         if (graalVMVersion.isDetected()) {\n             checkGraalVMVersion(graalVMVersion);\n         } else {\n             log.error(\"Unable to get GraalVM version from the native-image binary.\");\n         }\n \n+        String executableName = outputTargetBuildItem.getBaseName() + packageConfig.runnerSuffix;\n+        String noPIE = \"\";\n+        if (!isContainerBuild && SystemUtils.IS_OS_LINUX) {\n+            noPIE = detectNoPIE();\n+        }\n         try {\n-            List<String> command = new ArrayList<>(nativeImage);\n             if (nativeConfig.cleanupServer && !graalVMVersion.isMandrel()) {\n                 List<String> cleanup = new ArrayList<>(nativeImage);\n                 cleanup.add(\"--server-shutdown\");\n-                final ProcessBuilder pb = new ProcessBuilder(cleanup.toArray(new String[0]));\n+                cleanup = maybeRunInContainer(containerCommand, cleanup);\n+                final ProcessBuilder pb = new ProcessBuilder(cleanup);\n                 pb.directory(outputDir.toFile());\n                 final Process process = ProcessUtil.launchProcess(pb, processInheritIODisabled.isPresent());\n                 process.waitFor();\n             }\n-            boolean enableSslNative = false;\n-            for (NativeImageSystemPropertyBuildItem prop : nativeImageProperties) {\n-                //todo: this should be specific build items\n-                if (prop.getKey().equals(\"quarkus.ssl.native\") && prop.getValue() != null) {\n-                    enableSslNative = Boolean.parseBoolean(prop.getValue());\n-                } else if (prop.getKey().equals(\"quarkus.jni.enable\") && prop.getValue().equals(\"false\")) {\n-                    log.warn(\"Your application is setting the deprecated 'quarkus.jni.enable' configuration key to false.\"\n-                            + \" Please consider removing this configuration key as it is ignored (JNI is always enabled) and it\"\n-                            + \" will be removed in a future Quarkus version.\");\n-                } else if (prop.getKey().equals(\"quarkus.native.enable-all-security-services\") && prop.getValue() != null) {\n-                    nativeConfig.enableAllSecurityServices |= Boolean.parseBoolean(prop.getValue());\n-                } else if (prop.getKey().equals(\"quarkus.native.enable-all-charsets\") && prop.getValue() != null) {\n-                    nativeConfig.addAllCharsets |= Boolean.parseBoolean(prop.getValue());\n-                } else {\n-                    // todo maybe just -D is better than -J-D in this case\n-                    if (prop.getValue() == null) {\n-                        command.add(\"-J-D\" + prop.getKey());\n-                    } else {\n-                        command.add(\"-J-D\" + prop.getKey() + \"=\" + prop.getValue());\n-                    }\n-                }\n-            }\n-            command.add(\"-J-Duser.language=\" + System.getProperty(\"user.language\"));\n-            // Native image runtime uses the host's (i.e. build time) value of file.encoding\n-            // system property. We intentionally default this to UTF-8 to avoid platform specific\n-            // defaults to be picked up which can then result in inconsistent behaviour in the\n-            // generated native application\n-            command.add(\"-J-Dfile.encoding=UTF-8\");\n-\n-            if (enableSslNative) {\n-                nativeConfig.enableHttpsUrlHandler = true;\n-                nativeConfig.enableAllSecurityServices = true;\n-            }\n-\n-            handleAdditionalProperties(nativeConfig, command, isContainerBuild, outputDir);\n-            command.add(\"--initialize-at-build-time=\");\n-            command.add(\n-                    \"-H:InitialCollectionPolicy=com.oracle.svm.core.genscavenge.CollectionPolicy$BySpaceAndTime\"); //the default collection policy results in full GC's 50% of the time\n-            command.add(\"-H:+JNI\");\n-            command.add(\"-jar\");\n-            command.add(runnerJarName);\n-\n-            if (nativeConfig.enableFallbackImages) {\n-                command.add(\"-H:FallbackThreshold=5\");\n-            } else {\n-                //Default: be strict as those fallback images aren't very useful\n-                //and tend to cover up real problems.\n-                command.add(\"-H:FallbackThreshold=0\");\n-            }\n-\n-            if (nativeConfig.reportErrorsAtRuntime) {\n-                command.add(\"-H:+ReportUnsupportedElementsAtRuntime\");\n-            }\n-            if (nativeConfig.reportExceptionStackTraces) {\n-                command.add(\"-H:+ReportExceptionStackTraces\");\n-            }\n-            if (nativeConfig.debug.enabled) {\n-                if (graalVMVersion.isMandrel() || graalVMVersion.isNewerThan(GraalVM.Version.VERSION_20_1)) {\n-                    command.add(\"-g\");\n-                    command.add(\"-H:DebugInfoSourceSearchPath=\" + APP_SOURCES);\n-                }\n-            }\n-            if (nativeConfig.debugBuildProcess) {\n-                command.add(\"-J-Xrunjdwp:transport=dt_socket,address=\" + DEBUG_BUILD_PROCESS_PORT + \",server=y,suspend=y\");\n-            }\n-            if (nativeConfig.enableReports) {\n-                command.add(\"-H:+PrintAnalysisCallTree\");\n-            }\n-            if (nativeConfig.dumpProxies) {\n-                command.add(\"-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true\");\n-                if (nativeConfig.enableServer) {\n-                    log.warn(\n-                            \"Options dumpProxies and enableServer are both enabled: this will get the proxies dumped in an unknown external working directory\");\n-                }\n-            }\n-            if (nativeConfig.nativeImageXmx.isPresent()) {\n-                command.add(\"-J-Xmx\" + nativeConfig.nativeImageXmx.get());\n-            }\n-            List<String> protocols = new ArrayList<>(2);\n-            if (nativeConfig.enableHttpUrlHandler) {\n-                protocols.add(\"http\");\n-            }\n-            if (nativeConfig.enableHttpsUrlHandler) {\n-                protocols.add(\"https\");\n-            }\n-            if (nativeConfig.addAllCharsets) {\n-                command.add(\"-H:+AddAllCharsets\");\n-            } else {\n-                command.add(\"-H:-AddAllCharsets\");\n-            }\n-            if (!protocols.isEmpty()) {\n-                command.add(\"-H:EnableURLProtocols=\" + String.join(\",\", protocols));\n-            }\n-            if (nativeConfig.enableAllSecurityServices) {\n-                command.add(\"--enable-all-security-services\");\n-            }\n-            if (!noPIE.isEmpty()) {\n-                command.add(\"-H:NativeLinkerOption=\" + noPIE);\n-            }\n-\n-            if (!nativeConfig.enableIsolates) {\n-                command.add(\"-H:-SpawnIsolates\");\n-            }\n-            if (!nativeConfig.enableJni) {\n-                log.warn(\"Your application is setting the deprecated 'quarkus.native.enable-jni' configuration key to false.\"\n-                        + \" Please consider removing this configuration key as it is ignored (JNI is always enabled) and it\"\n-                        + \" will be removed in a future Quarkus version.\");\n-            }\n-            if (!nativeConfig.enableServer && !SystemUtils.IS_OS_WINDOWS && !graalVMVersion.isMandrel()) {\n-                command.add(\"--no-server\");\n-            }\n-            if (nativeConfig.enableVmInspection) {\n-                command.add(\"-H:+AllowVMInspection\");\n-            }\n-            if (nativeConfig.autoServiceLoaderRegistration) {\n-                command.add(\"-H:+UseServiceLoaderFeature\");\n-                //When enabling, at least print what exactly is being added:\n-                command.add(\"-H:+TraceServiceLoaderFeature\");\n+            List<String> buildCommand = getBuildCommand(nativeConfig, nativeImageProperties,\n+                    outputDir, runnerJarName, nativeImage, noPIE, isContainerBuild, graalVMVersion,\n+                    executableName);\n+            buildCommand = maybeRunInContainer(containerCommand, buildCommand);\n+            if (isContainerBuild) {\n+                log.info(String.join(\" \", buildCommand).replace(\"$\", \"\\\\$\"));\n             } else {\n-                command.add(\"-H:-UseServiceLoaderFeature\");\n+                log.info(String.join(\" \", buildCommand));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg2NDY4OA=="}, "originalCommit": {"oid": "4d66b885e1d1047ae4029f0f0d3fe0419b0ddce1"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkwMTQ1NQ==", "bodyText": "This means that I will need to check before the invocation if this is a container or not and do the replace. It feels like doing it inside maybeRunInContainer is better. What if I move the log in there?", "url": "https://github.com/quarkusio/quarkus/pull/13963#discussion_r545901455", "createdAt": "2020-12-18T15:16:23Z", "author": {"login": "zakkak"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/pkg/steps/NativeImageBuildStep.java", "diffHunk": "@@ -101,166 +101,60 @@ public NativeImageBuildItem build(NativeConfig nativeConfig, NativeImageSourceJa\n         final String runnerJarName = runnerJar.getFileName().toString();\n \n         HashMap<String, String> env = new HashMap<>(System.getenv());\n-        List<String> nativeImage;\n-\n-        String noPIE = \"\";\n+        List<String> containerCommand = null;\n+        List<String> nativeImage = null;\n \n         boolean isContainerBuild = nativeConfig.containerRuntime.isPresent() || nativeConfig.containerBuild;\n-        if (!isContainerBuild && SystemUtils.IS_OS_LINUX) {\n-            noPIE = detectNoPIE();\n+        if (!isContainerBuild) {\n+            nativeImage = getNativeImage(nativeConfig, processInheritIODisabled.isPresent(), outputDir, env);\n+            if (nativeImage == null) {\n+                assert SystemUtils.IS_OS_LINUX;\n+                // If we are on linux we can fallback to the builder image and expect the resulting binary to be able to\n+                // run on the host. Unfortunately the same is not true for other platforms.\n+                log.warn(\"Cannot find `native-image` in the GRAALVM_HOME, JAVA_HOME and System PATH.\" +\n+                        \"Install it using `gu install native-image`. Attempting to fall back to builder image.\");\n+                isContainerBuild = true;\n+            }\n+        }\n+        if (isContainerBuild) {\n+            containerCommand = setupContainerBuild(nativeConfig, processInheritIODisabled.isPresent(), outputDir);\n+            nativeImage = Collections.singletonList(\"native-image\");\n         }\n \n-        nativeImage = getNativeImage(nativeConfig, processInheritIODisabled, outputDir, env);\n-        final GraalVM.Version graalVMVersion = GraalVM.Version.ofBinary(nativeImage);\n+        final GraalVM.Version graalVMVersion = GraalVM.Version.ofBinary(containerCommand, nativeImage);\n \n         if (graalVMVersion.isDetected()) {\n             checkGraalVMVersion(graalVMVersion);\n         } else {\n             log.error(\"Unable to get GraalVM version from the native-image binary.\");\n         }\n \n+        String executableName = outputTargetBuildItem.getBaseName() + packageConfig.runnerSuffix;\n+        String noPIE = \"\";\n+        if (!isContainerBuild && SystemUtils.IS_OS_LINUX) {\n+            noPIE = detectNoPIE();\n+        }\n         try {\n-            List<String> command = new ArrayList<>(nativeImage);\n             if (nativeConfig.cleanupServer && !graalVMVersion.isMandrel()) {\n                 List<String> cleanup = new ArrayList<>(nativeImage);\n                 cleanup.add(\"--server-shutdown\");\n-                final ProcessBuilder pb = new ProcessBuilder(cleanup.toArray(new String[0]));\n+                cleanup = maybeRunInContainer(containerCommand, cleanup);\n+                final ProcessBuilder pb = new ProcessBuilder(cleanup);\n                 pb.directory(outputDir.toFile());\n                 final Process process = ProcessUtil.launchProcess(pb, processInheritIODisabled.isPresent());\n                 process.waitFor();\n             }\n-            boolean enableSslNative = false;\n-            for (NativeImageSystemPropertyBuildItem prop : nativeImageProperties) {\n-                //todo: this should be specific build items\n-                if (prop.getKey().equals(\"quarkus.ssl.native\") && prop.getValue() != null) {\n-                    enableSslNative = Boolean.parseBoolean(prop.getValue());\n-                } else if (prop.getKey().equals(\"quarkus.jni.enable\") && prop.getValue().equals(\"false\")) {\n-                    log.warn(\"Your application is setting the deprecated 'quarkus.jni.enable' configuration key to false.\"\n-                            + \" Please consider removing this configuration key as it is ignored (JNI is always enabled) and it\"\n-                            + \" will be removed in a future Quarkus version.\");\n-                } else if (prop.getKey().equals(\"quarkus.native.enable-all-security-services\") && prop.getValue() != null) {\n-                    nativeConfig.enableAllSecurityServices |= Boolean.parseBoolean(prop.getValue());\n-                } else if (prop.getKey().equals(\"quarkus.native.enable-all-charsets\") && prop.getValue() != null) {\n-                    nativeConfig.addAllCharsets |= Boolean.parseBoolean(prop.getValue());\n-                } else {\n-                    // todo maybe just -D is better than -J-D in this case\n-                    if (prop.getValue() == null) {\n-                        command.add(\"-J-D\" + prop.getKey());\n-                    } else {\n-                        command.add(\"-J-D\" + prop.getKey() + \"=\" + prop.getValue());\n-                    }\n-                }\n-            }\n-            command.add(\"-J-Duser.language=\" + System.getProperty(\"user.language\"));\n-            // Native image runtime uses the host's (i.e. build time) value of file.encoding\n-            // system property. We intentionally default this to UTF-8 to avoid platform specific\n-            // defaults to be picked up which can then result in inconsistent behaviour in the\n-            // generated native application\n-            command.add(\"-J-Dfile.encoding=UTF-8\");\n-\n-            if (enableSslNative) {\n-                nativeConfig.enableHttpsUrlHandler = true;\n-                nativeConfig.enableAllSecurityServices = true;\n-            }\n-\n-            handleAdditionalProperties(nativeConfig, command, isContainerBuild, outputDir);\n-            command.add(\"--initialize-at-build-time=\");\n-            command.add(\n-                    \"-H:InitialCollectionPolicy=com.oracle.svm.core.genscavenge.CollectionPolicy$BySpaceAndTime\"); //the default collection policy results in full GC's 50% of the time\n-            command.add(\"-H:+JNI\");\n-            command.add(\"-jar\");\n-            command.add(runnerJarName);\n-\n-            if (nativeConfig.enableFallbackImages) {\n-                command.add(\"-H:FallbackThreshold=5\");\n-            } else {\n-                //Default: be strict as those fallback images aren't very useful\n-                //and tend to cover up real problems.\n-                command.add(\"-H:FallbackThreshold=0\");\n-            }\n-\n-            if (nativeConfig.reportErrorsAtRuntime) {\n-                command.add(\"-H:+ReportUnsupportedElementsAtRuntime\");\n-            }\n-            if (nativeConfig.reportExceptionStackTraces) {\n-                command.add(\"-H:+ReportExceptionStackTraces\");\n-            }\n-            if (nativeConfig.debug.enabled) {\n-                if (graalVMVersion.isMandrel() || graalVMVersion.isNewerThan(GraalVM.Version.VERSION_20_1)) {\n-                    command.add(\"-g\");\n-                    command.add(\"-H:DebugInfoSourceSearchPath=\" + APP_SOURCES);\n-                }\n-            }\n-            if (nativeConfig.debugBuildProcess) {\n-                command.add(\"-J-Xrunjdwp:transport=dt_socket,address=\" + DEBUG_BUILD_PROCESS_PORT + \",server=y,suspend=y\");\n-            }\n-            if (nativeConfig.enableReports) {\n-                command.add(\"-H:+PrintAnalysisCallTree\");\n-            }\n-            if (nativeConfig.dumpProxies) {\n-                command.add(\"-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true\");\n-                if (nativeConfig.enableServer) {\n-                    log.warn(\n-                            \"Options dumpProxies and enableServer are both enabled: this will get the proxies dumped in an unknown external working directory\");\n-                }\n-            }\n-            if (nativeConfig.nativeImageXmx.isPresent()) {\n-                command.add(\"-J-Xmx\" + nativeConfig.nativeImageXmx.get());\n-            }\n-            List<String> protocols = new ArrayList<>(2);\n-            if (nativeConfig.enableHttpUrlHandler) {\n-                protocols.add(\"http\");\n-            }\n-            if (nativeConfig.enableHttpsUrlHandler) {\n-                protocols.add(\"https\");\n-            }\n-            if (nativeConfig.addAllCharsets) {\n-                command.add(\"-H:+AddAllCharsets\");\n-            } else {\n-                command.add(\"-H:-AddAllCharsets\");\n-            }\n-            if (!protocols.isEmpty()) {\n-                command.add(\"-H:EnableURLProtocols=\" + String.join(\",\", protocols));\n-            }\n-            if (nativeConfig.enableAllSecurityServices) {\n-                command.add(\"--enable-all-security-services\");\n-            }\n-            if (!noPIE.isEmpty()) {\n-                command.add(\"-H:NativeLinkerOption=\" + noPIE);\n-            }\n-\n-            if (!nativeConfig.enableIsolates) {\n-                command.add(\"-H:-SpawnIsolates\");\n-            }\n-            if (!nativeConfig.enableJni) {\n-                log.warn(\"Your application is setting the deprecated 'quarkus.native.enable-jni' configuration key to false.\"\n-                        + \" Please consider removing this configuration key as it is ignored (JNI is always enabled) and it\"\n-                        + \" will be removed in a future Quarkus version.\");\n-            }\n-            if (!nativeConfig.enableServer && !SystemUtils.IS_OS_WINDOWS && !graalVMVersion.isMandrel()) {\n-                command.add(\"--no-server\");\n-            }\n-            if (nativeConfig.enableVmInspection) {\n-                command.add(\"-H:+AllowVMInspection\");\n-            }\n-            if (nativeConfig.autoServiceLoaderRegistration) {\n-                command.add(\"-H:+UseServiceLoaderFeature\");\n-                //When enabling, at least print what exactly is being added:\n-                command.add(\"-H:+TraceServiceLoaderFeature\");\n+            List<String> buildCommand = getBuildCommand(nativeConfig, nativeImageProperties,\n+                    outputDir, runnerJarName, nativeImage, noPIE, isContainerBuild, graalVMVersion,\n+                    executableName);\n+            buildCommand = maybeRunInContainer(containerCommand, buildCommand);\n+            if (isContainerBuild) {\n+                log.info(String.join(\" \", buildCommand).replace(\"$\", \"\\\\$\"));\n             } else {\n-                command.add(\"-H:-UseServiceLoaderFeature\");\n+                log.info(String.join(\" \", buildCommand));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg2NDY4OA=="}, "originalCommit": {"oid": "4d66b885e1d1047ae4029f0f0d3fe0419b0ddce1"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkxODExNg==", "bodyText": "sounds good.", "url": "https://github.com/quarkusio/quarkus/pull/13963#discussion_r545918116", "createdAt": "2020-12-18T15:42:52Z", "author": {"login": "jerboaa"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/pkg/steps/NativeImageBuildStep.java", "diffHunk": "@@ -101,166 +101,60 @@ public NativeImageBuildItem build(NativeConfig nativeConfig, NativeImageSourceJa\n         final String runnerJarName = runnerJar.getFileName().toString();\n \n         HashMap<String, String> env = new HashMap<>(System.getenv());\n-        List<String> nativeImage;\n-\n-        String noPIE = \"\";\n+        List<String> containerCommand = null;\n+        List<String> nativeImage = null;\n \n         boolean isContainerBuild = nativeConfig.containerRuntime.isPresent() || nativeConfig.containerBuild;\n-        if (!isContainerBuild && SystemUtils.IS_OS_LINUX) {\n-            noPIE = detectNoPIE();\n+        if (!isContainerBuild) {\n+            nativeImage = getNativeImage(nativeConfig, processInheritIODisabled.isPresent(), outputDir, env);\n+            if (nativeImage == null) {\n+                assert SystemUtils.IS_OS_LINUX;\n+                // If we are on linux we can fallback to the builder image and expect the resulting binary to be able to\n+                // run on the host. Unfortunately the same is not true for other platforms.\n+                log.warn(\"Cannot find `native-image` in the GRAALVM_HOME, JAVA_HOME and System PATH.\" +\n+                        \"Install it using `gu install native-image`. Attempting to fall back to builder image.\");\n+                isContainerBuild = true;\n+            }\n+        }\n+        if (isContainerBuild) {\n+            containerCommand = setupContainerBuild(nativeConfig, processInheritIODisabled.isPresent(), outputDir);\n+            nativeImage = Collections.singletonList(\"native-image\");\n         }\n \n-        nativeImage = getNativeImage(nativeConfig, processInheritIODisabled, outputDir, env);\n-        final GraalVM.Version graalVMVersion = GraalVM.Version.ofBinary(nativeImage);\n+        final GraalVM.Version graalVMVersion = GraalVM.Version.ofBinary(containerCommand, nativeImage);\n \n         if (graalVMVersion.isDetected()) {\n             checkGraalVMVersion(graalVMVersion);\n         } else {\n             log.error(\"Unable to get GraalVM version from the native-image binary.\");\n         }\n \n+        String executableName = outputTargetBuildItem.getBaseName() + packageConfig.runnerSuffix;\n+        String noPIE = \"\";\n+        if (!isContainerBuild && SystemUtils.IS_OS_LINUX) {\n+            noPIE = detectNoPIE();\n+        }\n         try {\n-            List<String> command = new ArrayList<>(nativeImage);\n             if (nativeConfig.cleanupServer && !graalVMVersion.isMandrel()) {\n                 List<String> cleanup = new ArrayList<>(nativeImage);\n                 cleanup.add(\"--server-shutdown\");\n-                final ProcessBuilder pb = new ProcessBuilder(cleanup.toArray(new String[0]));\n+                cleanup = maybeRunInContainer(containerCommand, cleanup);\n+                final ProcessBuilder pb = new ProcessBuilder(cleanup);\n                 pb.directory(outputDir.toFile());\n                 final Process process = ProcessUtil.launchProcess(pb, processInheritIODisabled.isPresent());\n                 process.waitFor();\n             }\n-            boolean enableSslNative = false;\n-            for (NativeImageSystemPropertyBuildItem prop : nativeImageProperties) {\n-                //todo: this should be specific build items\n-                if (prop.getKey().equals(\"quarkus.ssl.native\") && prop.getValue() != null) {\n-                    enableSslNative = Boolean.parseBoolean(prop.getValue());\n-                } else if (prop.getKey().equals(\"quarkus.jni.enable\") && prop.getValue().equals(\"false\")) {\n-                    log.warn(\"Your application is setting the deprecated 'quarkus.jni.enable' configuration key to false.\"\n-                            + \" Please consider removing this configuration key as it is ignored (JNI is always enabled) and it\"\n-                            + \" will be removed in a future Quarkus version.\");\n-                } else if (prop.getKey().equals(\"quarkus.native.enable-all-security-services\") && prop.getValue() != null) {\n-                    nativeConfig.enableAllSecurityServices |= Boolean.parseBoolean(prop.getValue());\n-                } else if (prop.getKey().equals(\"quarkus.native.enable-all-charsets\") && prop.getValue() != null) {\n-                    nativeConfig.addAllCharsets |= Boolean.parseBoolean(prop.getValue());\n-                } else {\n-                    // todo maybe just -D is better than -J-D in this case\n-                    if (prop.getValue() == null) {\n-                        command.add(\"-J-D\" + prop.getKey());\n-                    } else {\n-                        command.add(\"-J-D\" + prop.getKey() + \"=\" + prop.getValue());\n-                    }\n-                }\n-            }\n-            command.add(\"-J-Duser.language=\" + System.getProperty(\"user.language\"));\n-            // Native image runtime uses the host's (i.e. build time) value of file.encoding\n-            // system property. We intentionally default this to UTF-8 to avoid platform specific\n-            // defaults to be picked up which can then result in inconsistent behaviour in the\n-            // generated native application\n-            command.add(\"-J-Dfile.encoding=UTF-8\");\n-\n-            if (enableSslNative) {\n-                nativeConfig.enableHttpsUrlHandler = true;\n-                nativeConfig.enableAllSecurityServices = true;\n-            }\n-\n-            handleAdditionalProperties(nativeConfig, command, isContainerBuild, outputDir);\n-            command.add(\"--initialize-at-build-time=\");\n-            command.add(\n-                    \"-H:InitialCollectionPolicy=com.oracle.svm.core.genscavenge.CollectionPolicy$BySpaceAndTime\"); //the default collection policy results in full GC's 50% of the time\n-            command.add(\"-H:+JNI\");\n-            command.add(\"-jar\");\n-            command.add(runnerJarName);\n-\n-            if (nativeConfig.enableFallbackImages) {\n-                command.add(\"-H:FallbackThreshold=5\");\n-            } else {\n-                //Default: be strict as those fallback images aren't very useful\n-                //and tend to cover up real problems.\n-                command.add(\"-H:FallbackThreshold=0\");\n-            }\n-\n-            if (nativeConfig.reportErrorsAtRuntime) {\n-                command.add(\"-H:+ReportUnsupportedElementsAtRuntime\");\n-            }\n-            if (nativeConfig.reportExceptionStackTraces) {\n-                command.add(\"-H:+ReportExceptionStackTraces\");\n-            }\n-            if (nativeConfig.debug.enabled) {\n-                if (graalVMVersion.isMandrel() || graalVMVersion.isNewerThan(GraalVM.Version.VERSION_20_1)) {\n-                    command.add(\"-g\");\n-                    command.add(\"-H:DebugInfoSourceSearchPath=\" + APP_SOURCES);\n-                }\n-            }\n-            if (nativeConfig.debugBuildProcess) {\n-                command.add(\"-J-Xrunjdwp:transport=dt_socket,address=\" + DEBUG_BUILD_PROCESS_PORT + \",server=y,suspend=y\");\n-            }\n-            if (nativeConfig.enableReports) {\n-                command.add(\"-H:+PrintAnalysisCallTree\");\n-            }\n-            if (nativeConfig.dumpProxies) {\n-                command.add(\"-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true\");\n-                if (nativeConfig.enableServer) {\n-                    log.warn(\n-                            \"Options dumpProxies and enableServer are both enabled: this will get the proxies dumped in an unknown external working directory\");\n-                }\n-            }\n-            if (nativeConfig.nativeImageXmx.isPresent()) {\n-                command.add(\"-J-Xmx\" + nativeConfig.nativeImageXmx.get());\n-            }\n-            List<String> protocols = new ArrayList<>(2);\n-            if (nativeConfig.enableHttpUrlHandler) {\n-                protocols.add(\"http\");\n-            }\n-            if (nativeConfig.enableHttpsUrlHandler) {\n-                protocols.add(\"https\");\n-            }\n-            if (nativeConfig.addAllCharsets) {\n-                command.add(\"-H:+AddAllCharsets\");\n-            } else {\n-                command.add(\"-H:-AddAllCharsets\");\n-            }\n-            if (!protocols.isEmpty()) {\n-                command.add(\"-H:EnableURLProtocols=\" + String.join(\",\", protocols));\n-            }\n-            if (nativeConfig.enableAllSecurityServices) {\n-                command.add(\"--enable-all-security-services\");\n-            }\n-            if (!noPIE.isEmpty()) {\n-                command.add(\"-H:NativeLinkerOption=\" + noPIE);\n-            }\n-\n-            if (!nativeConfig.enableIsolates) {\n-                command.add(\"-H:-SpawnIsolates\");\n-            }\n-            if (!nativeConfig.enableJni) {\n-                log.warn(\"Your application is setting the deprecated 'quarkus.native.enable-jni' configuration key to false.\"\n-                        + \" Please consider removing this configuration key as it is ignored (JNI is always enabled) and it\"\n-                        + \" will be removed in a future Quarkus version.\");\n-            }\n-            if (!nativeConfig.enableServer && !SystemUtils.IS_OS_WINDOWS && !graalVMVersion.isMandrel()) {\n-                command.add(\"--no-server\");\n-            }\n-            if (nativeConfig.enableVmInspection) {\n-                command.add(\"-H:+AllowVMInspection\");\n-            }\n-            if (nativeConfig.autoServiceLoaderRegistration) {\n-                command.add(\"-H:+UseServiceLoaderFeature\");\n-                //When enabling, at least print what exactly is being added:\n-                command.add(\"-H:+TraceServiceLoaderFeature\");\n+            List<String> buildCommand = getBuildCommand(nativeConfig, nativeImageProperties,\n+                    outputDir, runnerJarName, nativeImage, noPIE, isContainerBuild, graalVMVersion,\n+                    executableName);\n+            buildCommand = maybeRunInContainer(containerCommand, buildCommand);\n+            if (isContainerBuild) {\n+                log.info(String.join(\" \", buildCommand).replace(\"$\", \"\\\\$\"));\n             } else {\n-                command.add(\"-H:-UseServiceLoaderFeature\");\n+                log.info(String.join(\" \", buildCommand));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg2NDY4OA=="}, "originalCommit": {"oid": "4d66b885e1d1047ae4029f0f0d3fe0419b0ddce1"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMTA5NDgxOnYy", "diffSide": "RIGHT", "path": "core/deployment/src/main/java/io/quarkus/deployment/pkg/steps/NativeImageBuildStep.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNDo0OToyMVrOIIl2fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQwMjowMjoxNFrOIJrv4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg3OTY3OQ==", "bodyText": "Wouldn't this spin up a container 3 times? Ideally, we'd stitch them together so that we can get away with a one time container invocation. I.e. podman run ... --entrypoint=/bin/bash <container> -c 'objcopy --only-keep-debug ... ; objcopy --add-gnu-debuglink=....; objcopy --strip-debug ... or podman run ... --entrypoint=/bin/bash <container> -c 'objcopy --strip-debug ... depending on the -g option.", "url": "https://github.com/quarkusio/quarkus/pull/13963#discussion_r545879679", "createdAt": "2020-12-18T14:49:21Z", "author": {"login": "jerboaa"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/pkg/steps/NativeImageBuildStep.java", "diffHunk": "@@ -269,17 +163,34 @@ public NativeImageBuildItem build(NativeConfig nativeConfig, NativeImageSourceJa\n             errorReportLatch.await();\n             int exitCode = process.waitFor();\n             if (exitCode != 0) {\n-                throw imageGenerationFailed(exitCode, command);\n+                throw imageGenerationFailed(exitCode, buildCommand);\n             }\n             if (SystemUtils.IS_OS_WINDOWS && !(isContainerBuild)) {\n                 //once image is generated it gets added .exe on Windows\n                 executableName = executableName + \".exe\";\n             }\n+\n+            String symbols = String.format(\"%s.debug\", executableName);\n+            if (!isContainerBuild && !objcopyExists(env)) {\n+                log.warn(\"objcopy executable not found in PATH. Debug symbols will not be separated from executable.\");\n+                log.warn(\"That will result in a larger native image with debug symbols embedded in it.\");\n+            } else {\n+                assert !(isContainerBuild && containerCommand == null);\n+                if (nativeConfig.debug.enabled) {\n+                    objcopy(containerCommand, outputDir, \"--only-keep-debug\", executableName, symbols);\n+                    objcopy(containerCommand, outputDir, String.format(\"--add-gnu-debuglink=%s\", symbols), executableName);\n+                }\n+                // Strip debug symbols regardless, because the underlying JDK might contain them\n+                objcopy(containerCommand, outputDir, \"--strip-debug\", executableName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d66b885e1d1047ae4029f0f0d3fe0419b0ddce1"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg4ODM4OQ==", "bodyText": "It will, but that's fairly fast in comparison to the native-image build step. Keeping it this way we don't have to maintain two different code paths for container and host builds, thus keeping it simple and more readable.", "url": "https://github.com/quarkusio/quarkus/pull/13963#discussion_r545888389", "createdAt": "2020-12-18T14:57:55Z", "author": {"login": "zakkak"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/pkg/steps/NativeImageBuildStep.java", "diffHunk": "@@ -269,17 +163,34 @@ public NativeImageBuildItem build(NativeConfig nativeConfig, NativeImageSourceJa\n             errorReportLatch.await();\n             int exitCode = process.waitFor();\n             if (exitCode != 0) {\n-                throw imageGenerationFailed(exitCode, command);\n+                throw imageGenerationFailed(exitCode, buildCommand);\n             }\n             if (SystemUtils.IS_OS_WINDOWS && !(isContainerBuild)) {\n                 //once image is generated it gets added .exe on Windows\n                 executableName = executableName + \".exe\";\n             }\n+\n+            String symbols = String.format(\"%s.debug\", executableName);\n+            if (!isContainerBuild && !objcopyExists(env)) {\n+                log.warn(\"objcopy executable not found in PATH. Debug symbols will not be separated from executable.\");\n+                log.warn(\"That will result in a larger native image with debug symbols embedded in it.\");\n+            } else {\n+                assert !(isContainerBuild && containerCommand == null);\n+                if (nativeConfig.debug.enabled) {\n+                    objcopy(containerCommand, outputDir, \"--only-keep-debug\", executableName, symbols);\n+                    objcopy(containerCommand, outputDir, String.format(\"--add-gnu-debuglink=%s\", symbols), executableName);\n+                }\n+                // Strip debug symbols regardless, because the underlying JDK might contain them\n+                objcopy(containerCommand, outputDir, \"--strip-debug\", executableName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg3OTY3OQ=="}, "originalCommit": {"oid": "4d66b885e1d1047ae4029f0f0d3fe0419b0ddce1"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkwMDY2NA==", "bodyText": "I haven't tested this myself, but apparently running containers on non-Linux isn't as quick. Perhaps mac and windows use-cases with building with the container should be tested.", "url": "https://github.com/quarkusio/quarkus/pull/13963#discussion_r545900664", "createdAt": "2020-12-18T15:15:03Z", "author": {"login": "jerboaa"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/pkg/steps/NativeImageBuildStep.java", "diffHunk": "@@ -269,17 +163,34 @@ public NativeImageBuildItem build(NativeConfig nativeConfig, NativeImageSourceJa\n             errorReportLatch.await();\n             int exitCode = process.waitFor();\n             if (exitCode != 0) {\n-                throw imageGenerationFailed(exitCode, command);\n+                throw imageGenerationFailed(exitCode, buildCommand);\n             }\n             if (SystemUtils.IS_OS_WINDOWS && !(isContainerBuild)) {\n                 //once image is generated it gets added .exe on Windows\n                 executableName = executableName + \".exe\";\n             }\n+\n+            String symbols = String.format(\"%s.debug\", executableName);\n+            if (!isContainerBuild && !objcopyExists(env)) {\n+                log.warn(\"objcopy executable not found in PATH. Debug symbols will not be separated from executable.\");\n+                log.warn(\"That will result in a larger native image with debug symbols embedded in it.\");\n+            } else {\n+                assert !(isContainerBuild && containerCommand == null);\n+                if (nativeConfig.debug.enabled) {\n+                    objcopy(containerCommand, outputDir, \"--only-keep-debug\", executableName, symbols);\n+                    objcopy(containerCommand, outputDir, String.format(\"--add-gnu-debuglink=%s\", symbols), executableName);\n+                }\n+                // Strip debug symbols regardless, because the underlying JDK might contain them\n+                objcopy(containerCommand, outputDir, \"--strip-debug\", executableName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg3OTY3OQ=="}, "originalCommit": {"oid": "4d66b885e1d1047ae4029f0f0d3fe0419b0ddce1"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkwMjI1MQ==", "bodyText": "AFAIK Mac is almost as fast, and windows docker using WSL2 as the backend should also be pretty fast. I can do some testing on Windows, but unfortunately not on Mac.", "url": "https://github.com/quarkusio/quarkus/pull/13963#discussion_r545902251", "createdAt": "2020-12-18T15:17:45Z", "author": {"login": "zakkak"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/pkg/steps/NativeImageBuildStep.java", "diffHunk": "@@ -269,17 +163,34 @@ public NativeImageBuildItem build(NativeConfig nativeConfig, NativeImageSourceJa\n             errorReportLatch.await();\n             int exitCode = process.waitFor();\n             if (exitCode != 0) {\n-                throw imageGenerationFailed(exitCode, command);\n+                throw imageGenerationFailed(exitCode, buildCommand);\n             }\n             if (SystemUtils.IS_OS_WINDOWS && !(isContainerBuild)) {\n                 //once image is generated it gets added .exe on Windows\n                 executableName = executableName + \".exe\";\n             }\n+\n+            String symbols = String.format(\"%s.debug\", executableName);\n+            if (!isContainerBuild && !objcopyExists(env)) {\n+                log.warn(\"objcopy executable not found in PATH. Debug symbols will not be separated from executable.\");\n+                log.warn(\"That will result in a larger native image with debug symbols embedded in it.\");\n+            } else {\n+                assert !(isContainerBuild && containerCommand == null);\n+                if (nativeConfig.debug.enabled) {\n+                    objcopy(containerCommand, outputDir, \"--only-keep-debug\", executableName, symbols);\n+                    objcopy(containerCommand, outputDir, String.format(\"--add-gnu-debuglink=%s\", symbols), executableName);\n+                }\n+                // Strip debug symbols regardless, because the underlying JDK might contain them\n+                objcopy(containerCommand, outputDir, \"--strip-debug\", executableName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg3OTY3OQ=="}, "originalCommit": {"oid": "4d66b885e1d1047ae4029f0f0d3fe0419b0ddce1"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkxNzgxNg==", "bodyText": "This maybe an optimization to do as a later step (once we know this actually is a problem?)", "url": "https://github.com/quarkusio/quarkus/pull/13963#discussion_r545917816", "createdAt": "2020-12-18T15:42:25Z", "author": {"login": "jerboaa"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/pkg/steps/NativeImageBuildStep.java", "diffHunk": "@@ -269,17 +163,34 @@ public NativeImageBuildItem build(NativeConfig nativeConfig, NativeImageSourceJa\n             errorReportLatch.await();\n             int exitCode = process.waitFor();\n             if (exitCode != 0) {\n-                throw imageGenerationFailed(exitCode, command);\n+                throw imageGenerationFailed(exitCode, buildCommand);\n             }\n             if (SystemUtils.IS_OS_WINDOWS && !(isContainerBuild)) {\n                 //once image is generated it gets added .exe on Windows\n                 executableName = executableName + \".exe\";\n             }\n+\n+            String symbols = String.format(\"%s.debug\", executableName);\n+            if (!isContainerBuild && !objcopyExists(env)) {\n+                log.warn(\"objcopy executable not found in PATH. Debug symbols will not be separated from executable.\");\n+                log.warn(\"That will result in a larger native image with debug symbols embedded in it.\");\n+            } else {\n+                assert !(isContainerBuild && containerCommand == null);\n+                if (nativeConfig.debug.enabled) {\n+                    objcopy(containerCommand, outputDir, \"--only-keep-debug\", executableName, symbols);\n+                    objcopy(containerCommand, outputDir, String.format(\"--add-gnu-debuglink=%s\", symbols), executableName);\n+                }\n+                // Strip debug symbols regardless, because the underlying JDK might contain them\n+                objcopy(containerCommand, outputDir, \"--strip-debug\", executableName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg3OTY3OQ=="}, "originalCommit": {"oid": "4d66b885e1d1047ae4029f0f0d3fe0419b0ddce1"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAyNDg2NQ==", "bodyText": "FTR: I tested this on two laptops with similar specs.\nI tested the \"combined\" (single docker container for all 3 processes) vs the \"split\" (1 container per process) approach and the results were:\n\n\n\n\nWindows\nLinux\n\n\n\n\nCombined\n~16s\n~0.8s\n\n\nSplit\n3.5 + 13 + 6.5 = ~23s\n0.5 + 0.5 + 0.6 = ~1.1s\n\n\n\nAlthough the benefit of using the \"combined\" approach is pretty clear, the overhead of the \"split\" approach (~7s) is still relatively low given that the image build took ~260s.", "url": "https://github.com/quarkusio/quarkus/pull/13963#discussion_r547024865", "createdAt": "2020-12-22T02:02:14Z", "author": {"login": "zakkak"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/pkg/steps/NativeImageBuildStep.java", "diffHunk": "@@ -269,17 +163,34 @@ public NativeImageBuildItem build(NativeConfig nativeConfig, NativeImageSourceJa\n             errorReportLatch.await();\n             int exitCode = process.waitFor();\n             if (exitCode != 0) {\n-                throw imageGenerationFailed(exitCode, command);\n+                throw imageGenerationFailed(exitCode, buildCommand);\n             }\n             if (SystemUtils.IS_OS_WINDOWS && !(isContainerBuild)) {\n                 //once image is generated it gets added .exe on Windows\n                 executableName = executableName + \".exe\";\n             }\n+\n+            String symbols = String.format(\"%s.debug\", executableName);\n+            if (!isContainerBuild && !objcopyExists(env)) {\n+                log.warn(\"objcopy executable not found in PATH. Debug symbols will not be separated from executable.\");\n+                log.warn(\"That will result in a larger native image with debug symbols embedded in it.\");\n+            } else {\n+                assert !(isContainerBuild && containerCommand == null);\n+                if (nativeConfig.debug.enabled) {\n+                    objcopy(containerCommand, outputDir, \"--only-keep-debug\", executableName, symbols);\n+                    objcopy(containerCommand, outputDir, String.format(\"--add-gnu-debuglink=%s\", symbols), executableName);\n+                }\n+                // Strip debug symbols regardless, because the underlying JDK might contain them\n+                objcopy(containerCommand, outputDir, \"--strip-debug\", executableName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg3OTY3OQ=="}, "originalCommit": {"oid": "4d66b885e1d1047ae4029f0f0d3fe0419b0ddce1"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY5NTE1NjExOnYy", "diffSide": "RIGHT", "path": "core/deployment/src/main/java/io/quarkus/deployment/pkg/steps/NativeImageBuildRemoteContainerRunner.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQxNDoyOTowMVrOIue2Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wM1QyMzoxMjozMlrOIvrQAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTYxMDgxMA==", "bodyText": "Ideally I would prefer a dynamically generated unique volume name, but I am not sure it's worth the effort.\nWe could also do something like fixed-name-YYYY-MM-DD-HHMM to avoid potential conflicts with existing volumes.\nWDYT?", "url": "https://github.com/quarkusio/quarkus/pull/13963#discussion_r585610810", "createdAt": "2021-03-02T14:29:01Z", "author": {"login": "zakkak"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/pkg/steps/NativeImageBuildRemoteContainerRunner.java", "diffHunk": "@@ -13,6 +15,7 @@\n public class NativeImageBuildRemoteContainerRunner extends NativeImageBuildContainerRunner {\n \n     private static final Logger log = Logger.getLogger(NativeImageBuildRemoteContainerRunner.class);\n+    private static final String CONTAINER_BUILD_VOLUME_NAME = \"quarkus-native-builder-image-project-volume\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efe041cdc05e6acd55e794a4126ac14e2ef3e6bb"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTkwNzc2MA==", "bodyText": "It's straightforward to let docker generate the unique volume id, I quickly tested it locally:\nfinal String[] createVolumeCommand = new String[] { containerRuntime.getExecutableName(), \"volume\", \"create\" };\nvolumeId = runCommandAndReadOutput(createVolumeCommand, \"Failed to create temp volume.\");\n\nUsing this as a first step in preBuild and replacing all CONTAINER_BUILD_VOLUME_NAME with volumeId.", "url": "https://github.com/quarkusio/quarkus/pull/13963#discussion_r585907760", "createdAt": "2021-03-02T21:03:57Z", "author": {"login": "jonathan-meier"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/pkg/steps/NativeImageBuildRemoteContainerRunner.java", "diffHunk": "@@ -13,6 +15,7 @@\n public class NativeImageBuildRemoteContainerRunner extends NativeImageBuildContainerRunner {\n \n     private static final Logger log = Logger.getLogger(NativeImageBuildRemoteContainerRunner.class);\n+    private static final String CONTAINER_BUILD_VOLUME_NAME = \"quarkus-native-builder-image-project-volume\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTYxMDgxMA=="}, "originalCommit": {"oid": "efe041cdc05e6acd55e794a4126ac14e2ef3e6bb"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NjM0ODY4NA==", "bodyText": "Unfortunately it's not that simple. If you manually create the volume before starting the container, the volume (when mount) is owned by root:root and native-image fails to write to it in subsequent steps.\nCreating the volume explicitly\n$ podman volume create test-volume                         \ntest-volume\n$ podman create --name temp -v test-volume:/project quay.io/quarkus/ubi-quarkus-native-image:21.0.0-java11                         \nbfa2406d5fa0a003af99c91f077ed989006eb2441004135773429c425f9ce997\n$ podman run --rm --entrypoint /bin/bash -it -v test-volume:/project quay.io/quarkus/ubi-quarkus-native-image:21.0.0-java11 -c \"ls -la\"\ntotal 0\ndrwxr-xr-x.  2 root root 6 Mar  3 11:40 .\ndrwxr-xr-x. 19 root root 6 Mar  3 11:41 ..\n\nCreating the volume implicitly\n$ podman create --name temp -v test-volume:/project quay.io/quarkus/ubi-quarkus-native-image:21.0.0-java11\ne30ffb76aa320448a3e645d7030c4dcf76b0efb83b68e3bc58a2e655c683d1de\n$ podman run --rm --entrypoint /bin/bash -it -v test-volume:/project quay.io/quarkus/ubi-quarkus-native-image:21.0.0-java11 -c \"ls -la\"\ntotal 0\ndrwxr-xr-x.  2 quarkus quarkus 6 Mar  3 11:42 .\ndrwxr-xr-x. 19 root    root    6 Mar  3 11:42 ..\n\nI am not a containers expert though so I'll be happy to be corrected :)", "url": "https://github.com/quarkusio/quarkus/pull/13963#discussion_r586348684", "createdAt": "2021-03-03T11:44:12Z", "author": {"login": "zakkak"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/pkg/steps/NativeImageBuildRemoteContainerRunner.java", "diffHunk": "@@ -13,6 +15,7 @@\n public class NativeImageBuildRemoteContainerRunner extends NativeImageBuildContainerRunner {\n \n     private static final Logger log = Logger.getLogger(NativeImageBuildRemoteContainerRunner.class);\n+    private static final String CONTAINER_BUILD_VOLUME_NAME = \"quarkus-native-builder-image-project-volume\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTYxMDgxMA=="}, "originalCommit": {"oid": "efe041cdc05e6acd55e794a4126ac14e2ef3e6bb"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NjgyMDYyMA==", "bodyText": "Interesting! I checked the following:\n\ndocker 19.03.13 on Ubuntu 20.10\ndocker 20.10.2 on Ubuntu 20.10 in WSL\npodman 2.0.6 on Ubuntu 20.10\npodman 1.6.4 on CentOS 7.9\npodman 3.0.1 on CentOS 7.9\n\nin all but the last case, the /project folder was owned by the quarkus user also when creating the volume explicitly. So something seems to have changed for podman 3. I'm guessing you're running on podman 3 as well?", "url": "https://github.com/quarkusio/quarkus/pull/13963#discussion_r586820620", "createdAt": "2021-03-03T21:52:58Z", "author": {"login": "jonathan-meier"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/pkg/steps/NativeImageBuildRemoteContainerRunner.java", "diffHunk": "@@ -13,6 +15,7 @@\n public class NativeImageBuildRemoteContainerRunner extends NativeImageBuildContainerRunner {\n \n     private static final Logger log = Logger.getLogger(NativeImageBuildRemoteContainerRunner.class);\n+    private static final String CONTAINER_BUILD_VOLUME_NAME = \"quarkus-native-builder-image-project-volume\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTYxMDgxMA=="}, "originalCommit": {"oid": "efe041cdc05e6acd55e794a4126ac14e2ef3e6bb"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Njg2MjU5NQ==", "bodyText": "Indeed I am using podman 3.0.1 on Fedora 33.\nThanks for the additional info @jonathan-meier, I created containers/podman#9608.", "url": "https://github.com/quarkusio/quarkus/pull/13963#discussion_r586862595", "createdAt": "2021-03-03T23:12:32Z", "author": {"login": "zakkak"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/pkg/steps/NativeImageBuildRemoteContainerRunner.java", "diffHunk": "@@ -13,6 +15,7 @@\n public class NativeImageBuildRemoteContainerRunner extends NativeImageBuildContainerRunner {\n \n     private static final Logger log = Logger.getLogger(NativeImageBuildRemoteContainerRunner.class);\n+    private static final String CONTAINER_BUILD_VOLUME_NAME = \"quarkus-native-builder-image-project-volume\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTYxMDgxMA=="}, "originalCommit": {"oid": "efe041cdc05e6acd55e794a4126ac14e2ef3e6bb"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4427, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}