{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3MDY3NzY1", "number": 10619, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNTo0NDo1NlrOENsMCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMTozOToyMlrOENx87w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzkwOTIzOnYy", "diffSide": "RIGHT", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNTo0NDo1NlrOGwcLIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNTo0NDo1NlrOGwcLIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ0NjQzMg==", "bodyText": "I think the entire contents of this if could be moved to a dedicated method.", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453446432", "createdAt": "2020-07-13T05:44:56Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -253,6 +255,74 @@ public Result parse(MethodInfo methodInfo) {\n \n             String upperPrefix = (ignoreCase || allIgnoreCase) ? \"UPPER(\" : \"\";\n             String upperSuffix = (ignoreCase || allIgnoreCase) ? \")\" : \"\";\n+\n+            // If the fieldName is not a field in the class and in camelcase format,\n+            // then split it as hierarchy of fields\n+            if (entityClass.field(fieldName) == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a28a523ed5f19d28b4c6280f9f21504348c77aec"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzkxMjA0OnYy", "diffSide": "RIGHT", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNTo0NjoxM1rOGwcMxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNTo0NjoxM1rOGwcMxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ0Njg1Mg==", "bodyText": "As it seems that indexView.getClassByName((entityClass.superClassType().name()) and indexView.getClassByName((fieldInfo.type().name()) are used a few times, best move them to a variable with a proper name", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453446852", "createdAt": "2020-07-13T05:46:13Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -253,6 +255,74 @@ public Result parse(MethodInfo methodInfo) {\n \n             String upperPrefix = (ignoreCase || allIgnoreCase) ? \"UPPER(\" : \"\";\n             String upperSuffix = (ignoreCase || allIgnoreCase) ? \")\" : \"\";\n+\n+            // If the fieldName is not a field in the class and in camelcase format,\n+            // then split it as hierarchy of fields\n+            if (entityClass.field(fieldName) == null) {\n+                StringBuilder finalName = new StringBuilder(fieldName);\n+\n+                Set<String> childFields = new HashSet<>();\n+\n+                childFields.addAll(entityClass.fields().stream()\n+                        .map(FieldInfo::name)\n+                        .collect(Collectors.toList()));\n+\n+                // Collecting the current class fields\n+                if (indexView.getClassByName(fieldInfo.type().name()) != null) {\n+                    childFields.addAll(\n+                            indexView.getClassByName(fieldInfo.type().name()).fields()\n+                                    .stream()\n+                                    .map(FieldInfo::name)\n+                                    .collect(Collectors.toList()));\n+                }\n+\n+                // Collecting the inherited fields from the superclass of the actual class\n+                if (entityClass.superClassType().name() != null &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a28a523ed5f19d28b4c6280f9f21504348c77aec"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzkxNDYzOnYy", "diffSide": "RIGHT", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNTo0Nzo0N1rOGwcOVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNTo0Nzo0N1rOGwcOVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ0NzI1Mg==", "bodyText": "Can we have a comment explaining this please?", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453447252", "createdAt": "2020-07-13T05:47:47Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -253,6 +255,74 @@ public Result parse(MethodInfo methodInfo) {\n \n             String upperPrefix = (ignoreCase || allIgnoreCase) ? \"UPPER(\" : \"\";\n             String upperSuffix = (ignoreCase || allIgnoreCase) ? \")\" : \"\";\n+\n+            // If the fieldName is not a field in the class and in camelcase format,\n+            // then split it as hierarchy of fields\n+            if (entityClass.field(fieldName) == null) {\n+                StringBuilder finalName = new StringBuilder(fieldName);\n+\n+                Set<String> childFields = new HashSet<>();\n+\n+                childFields.addAll(entityClass.fields().stream()\n+                        .map(FieldInfo::name)\n+                        .collect(Collectors.toList()));\n+\n+                // Collecting the current class fields\n+                if (indexView.getClassByName(fieldInfo.type().name()) != null) {\n+                    childFields.addAll(\n+                            indexView.getClassByName(fieldInfo.type().name()).fields()\n+                                    .stream()\n+                                    .map(FieldInfo::name)\n+                                    .collect(Collectors.toList()));\n+                }\n+\n+                // Collecting the inherited fields from the superclass of the actual class\n+                if (entityClass.superClassType().name() != null &&\n+                        indexView.getClassByName(entityClass.superClassType().name()) != null &&\n+                        indexView.getClassByName(fieldInfo.type().name()) != null &&\n+                        indexView.getClassByName(fieldInfo.type().name()).superClassType() != null) {\n+\n+                    childFields.addAll(indexView.getClassByName(entityClass.superClassType().name()).fields()\n+                            .stream()\n+                            .map(FieldInfo::name).collect(Collectors.toList()));\n+\n+                    childFields.addAll(indexView.getClassByName(\n+                            indexView.getClassByName(fieldInfo.type().name()).superClassType().name()).fields()\n+                            .stream()\n+                            .map(FieldInfo::name).collect(Collectors.toList()));\n+                }\n+\n+                // Collecting the inherited fields from the superclasses of the attributes\n+                if (indexView.getClassByName(fieldInfo.type().name()) != null &&\n+                        indexView.getClassByName(fieldInfo.type().name()).superClassType() != null &&\n+                        indexView.getClassByName(\n+                                indexView.getClassByName(fieldInfo.type().name()).superClassType().name()) != null) {\n+\n+                    childFields.addAll(\n+                            indexView.getClassByName(indexView.getClassByName(fieldInfo.type().name())\n+                                    .superClassType()\n+                                    .name())\n+                                    .fields()\n+                                    .stream()\n+                                    .map(FieldInfo::name).collect(Collectors.toList()));\n+                }\n+\n+                for (String fieldInf : childFields) {\n+                    if (StringUtils.containsIgnoreCase(fieldName, fieldInf)) {\n+                        String newValue = finalName.toString()\n+                                .replaceAll(\"(?i)\" + fieldInf, lowerFirstLetter(fieldInf) + \".\");\n+                        finalName.delete(0, finalName.length());\n+                        finalName.append(newValue);\n+                    }\n+                }\n+\n+                if (finalName.toString().charAt(finalName.length() - 1) == '.') {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a28a523ed5f19d28b4c6280f9f21504348c77aec"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNzkxNTIyOnYy", "diffSide": "RIGHT", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNTo0ODowNlrOGwcOrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNTo0ODowNlrOGwcOrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ0NzM0Mg==", "bodyText": "A comment on what this section does would be nice", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453447342", "createdAt": "2020-07-13T05:48:06Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -253,6 +255,74 @@ public Result parse(MethodInfo methodInfo) {\n \n             String upperPrefix = (ignoreCase || allIgnoreCase) ? \"UPPER(\" : \"\";\n             String upperSuffix = (ignoreCase || allIgnoreCase) ? \")\" : \"\";\n+\n+            // If the fieldName is not a field in the class and in camelcase format,\n+            // then split it as hierarchy of fields\n+            if (entityClass.field(fieldName) == null) {\n+                StringBuilder finalName = new StringBuilder(fieldName);\n+\n+                Set<String> childFields = new HashSet<>();\n+\n+                childFields.addAll(entityClass.fields().stream()\n+                        .map(FieldInfo::name)\n+                        .collect(Collectors.toList()));\n+\n+                // Collecting the current class fields\n+                if (indexView.getClassByName(fieldInfo.type().name()) != null) {\n+                    childFields.addAll(\n+                            indexView.getClassByName(fieldInfo.type().name()).fields()\n+                                    .stream()\n+                                    .map(FieldInfo::name)\n+                                    .collect(Collectors.toList()));\n+                }\n+\n+                // Collecting the inherited fields from the superclass of the actual class\n+                if (entityClass.superClassType().name() != null &&\n+                        indexView.getClassByName(entityClass.superClassType().name()) != null &&\n+                        indexView.getClassByName(fieldInfo.type().name()) != null &&\n+                        indexView.getClassByName(fieldInfo.type().name()).superClassType() != null) {\n+\n+                    childFields.addAll(indexView.getClassByName(entityClass.superClassType().name()).fields()\n+                            .stream()\n+                            .map(FieldInfo::name).collect(Collectors.toList()));\n+\n+                    childFields.addAll(indexView.getClassByName(\n+                            indexView.getClassByName(fieldInfo.type().name()).superClassType().name()).fields()\n+                            .stream()\n+                            .map(FieldInfo::name).collect(Collectors.toList()));\n+                }\n+\n+                // Collecting the inherited fields from the superclasses of the attributes\n+                if (indexView.getClassByName(fieldInfo.type().name()) != null &&\n+                        indexView.getClassByName(fieldInfo.type().name()).superClassType() != null &&\n+                        indexView.getClassByName(\n+                                indexView.getClassByName(fieldInfo.type().name()).superClassType().name()) != null) {\n+\n+                    childFields.addAll(\n+                            indexView.getClassByName(indexView.getClassByName(fieldInfo.type().name())\n+                                    .superClassType()\n+                                    .name())\n+                                    .fields()\n+                                    .stream()\n+                                    .map(FieldInfo::name).collect(Collectors.toList()));\n+                }\n+\n+                for (String fieldInf : childFields) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a28a523ed5f19d28b4c6280f9f21504348c77aec"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyODg1MDEzOnYy", "diffSide": "RIGHT", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMTozODoxM1rOGwk0jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMTozODoxM1rOGwk0jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODExMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // In some cases; the built hierarchy is ending by a joining point. so we need to remove it\n          \n          \n            \n                    // In some cases, the built hierarchy is ending by a joining point. so we need to remove it", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453588111", "createdAt": "2020-07-13T11:38:13Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -366,6 +375,74 @@ public Result parse(MethodInfo methodInfo) {\n                 topCount);\n     }\n \n+    private String handleFieldsHierarchy(String fieldName, FieldInfo currentField) {\n+        StringBuilder finalName = new StringBuilder(fieldName);\n+\n+        Set<String> childFields = new HashSet<>();\n+\n+        childFields.addAll(entityClass.fields().stream()\n+                .map(FieldInfo::name)\n+                .collect(Collectors.toList()));\n+\n+        // Collecting the current class fields\n+        ClassInfo currentClassInfo = indexView.getClassByName(currentField.type().name());\n+\n+        if (currentClassInfo != null) {\n+            childFields.addAll(\n+                    currentClassInfo.fields()\n+                            .stream()\n+                            .map(FieldInfo::name)\n+                            .collect(Collectors.toList()));\n+        }\n+\n+        // Collecting the inherited fields from the superclass of the actual class\n+        DotName superClassName = entityClass.superClassType().name();\n+        ClassInfo superClassInfo = indexView.getClassByName(superClassName);\n+\n+        ClassInfo classByName;\n+\n+        if (superClassName != null && superClassInfo != null && currentClassInfo != null &&\n+                currentClassInfo.superClassType() != null &&\n+                (classByName = indexView.getClassByName(currentClassInfo.superClassType().name())) != null) {\n+\n+            childFields.addAll(superClassInfo.fields()\n+                    .stream()\n+                    .map(FieldInfo::name).collect(Collectors.toList()));\n+\n+            childFields.addAll(classByName.fields()\n+                    .stream()\n+                    .map(FieldInfo::name).collect(Collectors.toList()));\n+        }\n+\n+        // Collecting the inherited fields from the superclasses of the attributes\n+        if (currentClassInfo != null && currentClassInfo.superClassType() != null\n+                && (classByName = indexView.getClassByName(currentClassInfo.superClassType().name())) != null) {\n+\n+            childFields.addAll(\n+                    classByName.fields()\n+                            .stream()\n+                            .map(FieldInfo::name).collect(Collectors.toList()));\n+        }\n+\n+        // Building the fieldName from the members classes and their superclasses\n+        for (String fieldInf : childFields) {\n+            if (StringUtils.containsIgnoreCase(fieldName, fieldInf)) {\n+                String newValue = finalName.toString()\n+                        .replaceAll(\"(?i)\" + fieldInf, lowerFirstLetter(fieldInf) + \".\");\n+                finalName.delete(0, finalName.length());\n+                finalName.append(newValue);\n+            }\n+        }\n+\n+        // In some cases; the built hierarchy is ending by a joining point. so we need to remove it", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e309f711d078fc641c975bb84d2cb5922b8a614f"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyODg1MDgyOnYy", "diffSide": "RIGHT", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMTozODoyOFrOGwk0-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMTozODoyOFrOGwk0-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODIxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // we need to split the camelcase format and grap the first item\n          \n          \n            \n                    // we need to split the camelcase format and grab the first item", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453588219", "createdAt": "2020-07-13T11:38:28Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -488,7 +565,13 @@ private boolean entityContainsField(String fieldName) {\n     }\n \n     private FieldInfo getField(String fieldName) {\n+        // Before validating the fieldInfo,\n+        // we need to split the camelcase format and grap the first item", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e309f711d078fc641c975bb84d2cb5922b8a614f"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyODg1MzU5OnYy", "diffSide": "RIGHT", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMTozOToyMlrOGwk2pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMzoyNzo1N1rOGwog9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODY0NQ==", "bodyText": "Perhaps add comment about how this works? Regex can be daunting when coming back to them after not having seen them for a while :)", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453588645", "createdAt": "2020-07-13T11:39:22Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -516,10 +599,13 @@ private FieldInfo getField(String fieldName) {\n                 superClassType = parameterizedType.owner();\n             }\n         }\n-        if (mappedSuperClassInfos.size() > 0) {\n-            return mappedSuperClassInfos;\n-        }\n-        return Collections.emptyList();\n+        return mappedSuperClassInfoElements;\n+    }\n+\n+    private static List<String> splitCamelCaseString(String s) {\n+        List<String> result = new ArrayList<>();\n+        Collections.addAll(result, s.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e309f711d078fc641c975bb84d2cb5922b8a614f"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU5MTIzNA==", "bodyText": "Do we have a \"policy\" regarding pre-compiling Pattern? Or is ok here if it is re-compiled every time since it probably won't be thousands of invocations and it is \"just\" deployment code?\nhttps://www.baeldung.com/java-regex-pre-compile", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453591234", "createdAt": "2020-07-13T11:44:22Z", "author": {"login": "famod"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -516,10 +599,13 @@ private FieldInfo getField(String fieldName) {\n                 superClassType = parameterizedType.owner();\n             }\n         }\n-        if (mappedSuperClassInfos.size() > 0) {\n-            return mappedSuperClassInfos;\n-        }\n-        return Collections.emptyList();\n+        return mappedSuperClassInfoElements;\n+    }\n+\n+    private static List<String> splitCamelCaseString(String s) {\n+        List<String> result = new ArrayList<>();\n+        Collections.addAll(result, s.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODY0NQ=="}, "originalCommit": {"oid": "e309f711d078fc641c975bb84d2cb5922b8a614f"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU5OTU2OA==", "bodyText": "We don't really have one, but in this case it's very unlikely we will run into a bottleneck due to the very small number of methods this case handles.", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453599568", "createdAt": "2020-07-13T12:01:37Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -516,10 +599,13 @@ private FieldInfo getField(String fieldName) {\n                 superClassType = parameterizedType.owner();\n             }\n         }\n-        if (mappedSuperClassInfos.size() > 0) {\n-            return mappedSuperClassInfos;\n-        }\n-        return Collections.emptyList();\n+        return mappedSuperClassInfoElements;\n+    }\n+\n+    private static List<String> splitCamelCaseString(String s) {\n+        List<String> result = new ArrayList<>();\n+        Collections.addAll(result, s.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODY0NQ=="}, "originalCommit": {"oid": "e309f711d078fc641c975bb84d2cb5922b8a614f"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYwMTIxNQ==", "bodyText": "@geoand I thought the name of the method was explicit \ud83d\ude05  I will add a comment anyway..\n@famod yes it's a code executed only once..", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453601215", "createdAt": "2020-07-13T12:05:01Z", "author": {"login": "nebrass"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -516,10 +599,13 @@ private FieldInfo getField(String fieldName) {\n                 superClassType = parameterizedType.owner();\n             }\n         }\n-        if (mappedSuperClassInfos.size() > 0) {\n-            return mappedSuperClassInfos;\n-        }\n-        return Collections.emptyList();\n+        return mappedSuperClassInfoElements;\n+    }\n+\n+    private static List<String> splitCamelCaseString(String s) {\n+        List<String> result = new ArrayList<>();\n+        Collections.addAll(result, s.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODY0NQ=="}, "originalCommit": {"oid": "e309f711d078fc641c975bb84d2cb5922b8a614f"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYwMTk4NQ==", "bodyText": "It is, I just want an explanation of the regex itself if possible \ud83d\ude0e", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453601985", "createdAt": "2020-07-13T12:06:34Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -516,10 +599,13 @@ private FieldInfo getField(String fieldName) {\n                 superClassType = parameterizedType.owner();\n             }\n         }\n-        if (mappedSuperClassInfos.size() > 0) {\n-            return mappedSuperClassInfos;\n-        }\n-        return Collections.emptyList();\n+        return mappedSuperClassInfoElements;\n+    }\n+\n+    private static List<String> splitCamelCaseString(String s) {\n+        List<String> result = new ArrayList<>();\n+        Collections.addAll(result, s.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODY0NQ=="}, "originalCommit": {"oid": "e309f711d078fc641c975bb84d2cb5922b8a614f"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYzMzQ3OQ==", "bodyText": "@geoand I found a better choice.. in the apache commons there is the same method StringUtils.splitByCharacterTypeCamelCase() \ud83d\ude01", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453633479", "createdAt": "2020-07-13T13:04:08Z", "author": {"login": "nebrass"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -516,10 +599,13 @@ private FieldInfo getField(String fieldName) {\n                 superClassType = parameterizedType.owner();\n             }\n         }\n-        if (mappedSuperClassInfos.size() > 0) {\n-            return mappedSuperClassInfos;\n-        }\n-        return Collections.emptyList();\n+        return mappedSuperClassInfoElements;\n+    }\n+\n+    private static List<String> splitCamelCaseString(String s) {\n+        List<String> result = new ArrayList<>();\n+        Collections.addAll(result, s.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODY0NQ=="}, "originalCommit": {"oid": "e309f711d078fc641c975bb84d2cb5922b8a614f"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY0ODYzMA==", "bodyText": "Even better!", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453648630", "createdAt": "2020-07-13T13:27:57Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -516,10 +599,13 @@ private FieldInfo getField(String fieldName) {\n                 superClassType = parameterizedType.owner();\n             }\n         }\n-        if (mappedSuperClassInfos.size() > 0) {\n-            return mappedSuperClassInfos;\n-        }\n-        return Collections.emptyList();\n+        return mappedSuperClassInfoElements;\n+    }\n+\n+    private static List<String> splitCamelCaseString(String s) {\n+        List<String> result = new ArrayList<>();\n+        Collections.addAll(result, s.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODY0NQ=="}, "originalCommit": {"oid": "e309f711d078fc641c975bb84d2cb5922b8a614f"}, "originalPosition": 141}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2422, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}