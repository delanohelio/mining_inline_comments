{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5MjA4MDgy", "number": 6398, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQxMDoyNjozMlrODV1h1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQxMDozMzoxN1rODV1izg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MjIzNzAzOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQxMDoyNjozMlrOFaQ2ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQxNzoxMDoyOVrOFaSNKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA4MzQyNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Furthermore, not all stateful applications need to be durable - even when JTA transactions are used, the tend to be the\n          \n          \n            \n            Furthermore, not all stateful applications need to be durable - even when JTA transactions are used, it tends to be the\n          \n      \n    \n    \n  \n\nbut it might just be me not being native.", "url": "https://github.com/quarkusio/quarkus/pull/6398#discussion_r363083427", "createdAt": "2020-01-05T10:26:32Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "diffHunk": "@@ -8,22 +8,79 @@ https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n include::./attributes.adoc[]\n :extension-status: preview\n \n-Quarkus supports the Software Transactional Memory (STM) implementation provided by the\n-Narayana open source project. Narayana STM allows a program to group object accesses into\n-a transaction such that other transactions either see all of the changes at once or they\n-see none of them.\n-\n-STM offers an approach to developing transactional applications in a highly concurrent\n-environment with some of the same characteristics of ACID (Atomicity, Consistency,\n-Isolation and Durability) transactions.\n-\n-To use Narayana STM you must define which objects you would like to be transactional using java\n-annotations. Please refer to the https://narayana.io/docs/project/index.html#d0e16066[Narayana STM manual]\n-and the https://narayana.io//docs/project/index.html#d0e16133[STM annotations guide] for more details.\n+Software Transactional Memory (STM) has been around in research environments since the late\n+1990's and has relatively recently started to appear in products and various programming\n+languages. We won't go into all of the details behind STM but the interested reader could look at https://groups.csail.mit.edu/tds/papers/Shavit/ShavitTouitou-podc95.pdf[this paper].\n+However, suffice it to say that STM offers an approach to developing transactional applications in a highly\n+concurrent environment with some of the same characteristics of ACID transactions, which you've probably already used\n+through JTA. Importantly though, the Durability property is relaxed (removed) within STM implementations,\n+or at least made optional. This is not the situation with JTA, where state changes are made durable\n+to a relational database which supports https://pubs.opengroup.org/onlinepubs/009680699/toc.pdf[the X/Open XA\n+standard].\n+\n+Note, the STM implementation provided by Quarkus is based on the https://narayana.io/docs/project/index.html#d0e16066[Narayana STM] implementation. This document isn't meant to be a replacement for that project's documentation so you may want\n+to look at that for more detail. However, we will try to focus more on how you can combine some of the key capabilities\n+into Quarkus when developing Kubernetes native applications and microservices.\n+\n+== Why use STM with Quarkus?\n+\n+Now you may still be asking yourself \"Why STM instead of JTA?\" or \"What are the benefits\n+to STM that I don't get from JTA?\" Let's try to answer those or similar questions, with\n+a particular focus on why we think they're great for Quarkus, microservices and Kubernetes\n+native applications. So in no specific order ...\n+\n+* The goal of STM is to simplify object reads and writes from multiple threads/protect\n+state from concurrent updates. The Quarkus STM implementation will safely manage any conflicts between\n+these threads using whatever isolation model has been chosen to protect that specific state\n+instance (object in the case of Quarkus). In Quarkus STM, there are two isolation implementations,\n+pessimistic (the default), which would cause conflicting threads to be blocked until the original\n+has completed its updates (committed or aborted the transaction); then there's the optimistic\n+approach which allows all of the threads to proceed and checks for conflicts at commit time, where\n+one or more of the threads may be forced to abort if there have been conflicting updates.\n+\n+* STM objects have state but it doesn't need to be persistent (durable). In fact the\n+default behaviour is for objects managed within transactional memory to be volatile, such that\n+if the service or microservice within which they are being used crashes or is spawned elsewhere, e.g.,\n+by a scheduler, all state in memory is lost and the objects start from scratch. But surely you get this and more\n+with JTA (and a suitable transactional datastore) and don't need to worry about restarting your application?\n+Not quite. There's a trade-off here: we're doing away\n+with persistent state and the overhead of reading from and then writing (and sync-ing) to the datastore during each\n+transaction. This makes updates to (volatile) state very fast but you still get the benefits of atomic updates\n+across multiple STM objects (e.g., objects your team wrote then calling objects you inherited from another team and requiring\n+them to make all-or-nothing updates), as well as consistency\n+and isolation in the presence of concurrent threads/users (common in distributed microservices architectures).\n+Furthermore, not all stateful applications need to be durable - even when JTA transactions are used, the tend to be the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd143c11efadcad61ced77c911fead8c12f34fdc"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzEwNTU3OA==", "bodyText": "Good catch.", "url": "https://github.com/quarkusio/quarkus/pull/6398#discussion_r363105578", "createdAt": "2020-01-05T17:10:29Z", "author": {"login": "nmcl"}, "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "diffHunk": "@@ -8,22 +8,79 @@ https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n include::./attributes.adoc[]\n :extension-status: preview\n \n-Quarkus supports the Software Transactional Memory (STM) implementation provided by the\n-Narayana open source project. Narayana STM allows a program to group object accesses into\n-a transaction such that other transactions either see all of the changes at once or they\n-see none of them.\n-\n-STM offers an approach to developing transactional applications in a highly concurrent\n-environment with some of the same characteristics of ACID (Atomicity, Consistency,\n-Isolation and Durability) transactions.\n-\n-To use Narayana STM you must define which objects you would like to be transactional using java\n-annotations. Please refer to the https://narayana.io/docs/project/index.html#d0e16066[Narayana STM manual]\n-and the https://narayana.io//docs/project/index.html#d0e16133[STM annotations guide] for more details.\n+Software Transactional Memory (STM) has been around in research environments since the late\n+1990's and has relatively recently started to appear in products and various programming\n+languages. We won't go into all of the details behind STM but the interested reader could look at https://groups.csail.mit.edu/tds/papers/Shavit/ShavitTouitou-podc95.pdf[this paper].\n+However, suffice it to say that STM offers an approach to developing transactional applications in a highly\n+concurrent environment with some of the same characteristics of ACID transactions, which you've probably already used\n+through JTA. Importantly though, the Durability property is relaxed (removed) within STM implementations,\n+or at least made optional. This is not the situation with JTA, where state changes are made durable\n+to a relational database which supports https://pubs.opengroup.org/onlinepubs/009680699/toc.pdf[the X/Open XA\n+standard].\n+\n+Note, the STM implementation provided by Quarkus is based on the https://narayana.io/docs/project/index.html#d0e16066[Narayana STM] implementation. This document isn't meant to be a replacement for that project's documentation so you may want\n+to look at that for more detail. However, we will try to focus more on how you can combine some of the key capabilities\n+into Quarkus when developing Kubernetes native applications and microservices.\n+\n+== Why use STM with Quarkus?\n+\n+Now you may still be asking yourself \"Why STM instead of JTA?\" or \"What are the benefits\n+to STM that I don't get from JTA?\" Let's try to answer those or similar questions, with\n+a particular focus on why we think they're great for Quarkus, microservices and Kubernetes\n+native applications. So in no specific order ...\n+\n+* The goal of STM is to simplify object reads and writes from multiple threads/protect\n+state from concurrent updates. The Quarkus STM implementation will safely manage any conflicts between\n+these threads using whatever isolation model has been chosen to protect that specific state\n+instance (object in the case of Quarkus). In Quarkus STM, there are two isolation implementations,\n+pessimistic (the default), which would cause conflicting threads to be blocked until the original\n+has completed its updates (committed or aborted the transaction); then there's the optimistic\n+approach which allows all of the threads to proceed and checks for conflicts at commit time, where\n+one or more of the threads may be forced to abort if there have been conflicting updates.\n+\n+* STM objects have state but it doesn't need to be persistent (durable). In fact the\n+default behaviour is for objects managed within transactional memory to be volatile, such that\n+if the service or microservice within which they are being used crashes or is spawned elsewhere, e.g.,\n+by a scheduler, all state in memory is lost and the objects start from scratch. But surely you get this and more\n+with JTA (and a suitable transactional datastore) and don't need to worry about restarting your application?\n+Not quite. There's a trade-off here: we're doing away\n+with persistent state and the overhead of reading from and then writing (and sync-ing) to the datastore during each\n+transaction. This makes updates to (volatile) state very fast but you still get the benefits of atomic updates\n+across multiple STM objects (e.g., objects your team wrote then calling objects you inherited from another team and requiring\n+them to make all-or-nothing updates), as well as consistency\n+and isolation in the presence of concurrent threads/users (common in distributed microservices architectures).\n+Furthermore, not all stateful applications need to be durable - even when JTA transactions are used, the tend to be the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA4MzQyNw=="}, "originalCommit": {"oid": "fd143c11efadcad61ced77c911fead8c12f34fdc"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MjIzNzQzOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQxMDoyNzo0NFrOFaQ23A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQxMDoyNzo0NFrOFaQ23A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA4MzQ4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            categorising STM-aware and STM-unware classes through an interface bounday; specifically all STM-aware objects\n          \n          \n            \n            categorising STM-aware and STM-unaware classes through an interface boundary; specifically all STM-aware objects", "url": "https://github.com/quarkusio/quarkus/pull/6398#discussion_r363083484", "createdAt": "2020-01-05T10:27:44Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "diffHunk": "@@ -43,12 +100,17 @@ To use the extension include it as a dependency in your application pom:\n </dependencies>\n --\n \n-Now you may use the STM library just like you would normally use it. But briefly, the process is:\n+== Defining STM-aware classes\n \n-== Defining Transactional Objects\n+In order for the STM subsytem to have knowledge about which classes are to be managed within the context\n+of transactional memory it is necessary to provide a minimal level of instrumentation. This occurs by\n+categorising STM-aware and STM-unware classes through an interface bounday; specifically all STM-aware objects", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd143c11efadcad61ced77c911fead8c12f34fdc"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MjIzNzU5OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQxMDoyODozNFrOFaQ29g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQxMDoyODozNFrOFaQ29g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA4MzUxMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            if a transaction aborts.. As mentioned earlier, if those annotations are not present then defaults are chosen to\n          \n          \n            \n            if a transaction aborts. As mentioned earlier, if those annotations are not present then defaults are chosen to", "url": "https://github.com/quarkusio/quarkus/pull/6398#discussion_r363083510", "createdAt": "2020-01-05T10:28:34Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "diffHunk": "@@ -59,15 +121,48 @@ public interface FlightService {\n }\n --\n \n-Unless specified using other annotations, all public methods of implementations of this object will be assumed to modify the state of the object.\n-Please refer to the Narayana guide for details of how to exert finer grained control over the transactional behaviour of objects that implement\n-interfaces marked with the `@Transactional` annotation.\n+Classes which implement this interface are able to use additional annotations from Narayana to tell the STM\n+subsystem about things such as whether a method will modify the state of the object, or what state variables\n+within the class should be managed transactionally, e.g., some instance variables may not need to be rolled back\n+if a transaction aborts.. As mentioned earlier, if those annotations are not present then defaults are chosen to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd143c11efadcad61ced77c911fead8c12f34fdc"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MjIzODA1OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQxMDoyOToyN1rOFaQ3Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQxMDoyOToyN1rOFaQ3Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA4MzU3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For example, by using the ReadLock annotation on the `getNumberOfBookings` method, we are able to tell the\n          \n          \n            \n            For example, by using the `@ReadLock` annotation on the `getNumberOfBookings` method, we are able to tell the", "url": "https://github.com/quarkusio/quarkus/pull/6398#discussion_r363083575", "createdAt": "2020-01-05T10:29:27Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "diffHunk": "@@ -59,15 +121,48 @@ public interface FlightService {\n }\n --\n \n-Unless specified using other annotations, all public methods of implementations of this object will be assumed to modify the state of the object.\n-Please refer to the Narayana guide for details of how to exert finer grained control over the transactional behaviour of objects that implement\n-interfaces marked with the `@Transactional` annotation.\n+Classes which implement this interface are able to use additional annotations from Narayana to tell the STM\n+subsystem about things such as whether a method will modify the state of the object, or what state variables\n+within the class should be managed transactionally, e.g., some instance variables may not need to be rolled back\n+if a transaction aborts.. As mentioned earlier, if those annotations are not present then defaults are chosen to\n+guarantee safety, such as assuming all methods will modify state.\n+\n+[source,java]\n+--\n+public class FlightServiceImpl implements FlightService {\n+    @ReadLock\n+    public int getNumberOfBookings() { ... }\n+    public void makeBooking(String details) {...}\n+    \n+    @NotState\n+    private int timesCalled;\n+}\n+--\n+\n+For example, by using the ReadLock annotation on the `getNumberOfBookings` method, we are able to tell the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd143c11efadcad61ced77c911fead8c12f34fdc"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MjIzODEzOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQxMDoyOTozOFrOFaQ3QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQxMDoyOTozOFrOFaQ3QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA4MzU4NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            memory. Also, the NotState annotation tells the system to ignore `timesCalled` when transactions commit or\n          \n          \n            \n            memory. Also, the `@NotState` annotation tells the system to ignore `timesCalled` when transactions commit or", "url": "https://github.com/quarkusio/quarkus/pull/6398#discussion_r363083585", "createdAt": "2020-01-05T10:29:38Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "diffHunk": "@@ -59,15 +121,48 @@ public interface FlightService {\n }\n --\n \n-Unless specified using other annotations, all public methods of implementations of this object will be assumed to modify the state of the object.\n-Please refer to the Narayana guide for details of how to exert finer grained control over the transactional behaviour of objects that implement\n-interfaces marked with the `@Transactional` annotation.\n+Classes which implement this interface are able to use additional annotations from Narayana to tell the STM\n+subsystem about things such as whether a method will modify the state of the object, or what state variables\n+within the class should be managed transactionally, e.g., some instance variables may not need to be rolled back\n+if a transaction aborts.. As mentioned earlier, if those annotations are not present then defaults are chosen to\n+guarantee safety, such as assuming all methods will modify state.\n+\n+[source,java]\n+--\n+public class FlightServiceImpl implements FlightService {\n+    @ReadLock\n+    public int getNumberOfBookings() { ... }\n+    public void makeBooking(String details) {...}\n+    \n+    @NotState\n+    private int timesCalled;\n+}\n+--\n+\n+For example, by using the ReadLock annotation on the `getNumberOfBookings` method, we are able to tell the\n+STM subsystem that no state modifications will occur in this object when it is used in the transactional\n+memory. Also, the NotState annotation tells the system to ignore `timesCalled` when transactions commit or", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd143c11efadcad61ced77c911fead8c12f34fdc"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MjIzODk3OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQxMDozMTo1M1rOFaQ3sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQxMDozMTo1M1rOFaQ3sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA4MzY5OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            be confusing to use especially in a Kuberenetes native environment such as Quarkus, but hopefully\n          \n          \n            \n            be confusing to use especially in a Kubernetes native environment such as Quarkus, but hopefully", "url": "https://github.com/quarkusio/quarkus/pull/6398#discussion_r363083698", "createdAt": "2020-01-05T10:31:53Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "diffHunk": "@@ -59,15 +121,48 @@ public interface FlightService {\n }\n --\n \n-Unless specified using other annotations, all public methods of implementations of this object will be assumed to modify the state of the object.\n-Please refer to the Narayana guide for details of how to exert finer grained control over the transactional behaviour of objects that implement\n-interfaces marked with the `@Transactional` annotation.\n+Classes which implement this interface are able to use additional annotations from Narayana to tell the STM\n+subsystem about things such as whether a method will modify the state of the object, or what state variables\n+within the class should be managed transactionally, e.g., some instance variables may not need to be rolled back\n+if a transaction aborts.. As mentioned earlier, if those annotations are not present then defaults are chosen to\n+guarantee safety, such as assuming all methods will modify state.\n+\n+[source,java]\n+--\n+public class FlightServiceImpl implements FlightService {\n+    @ReadLock\n+    public int getNumberOfBookings() { ... }\n+    public void makeBooking(String details) {...}\n+    \n+    @NotState\n+    private int timesCalled;\n+}\n+--\n+\n+For example, by using the ReadLock annotation on the `getNumberOfBookings` method, we are able to tell the\n+STM subsystem that no state modifications will occur in this object when it is used in the transactional\n+memory. Also, the NotState annotation tells the system to ignore `timesCalled` when transactions commit or\n+abort, so this value only changes due to application code.\n+\n+Please refer to the Narayana guide for details of how to exert finer grained control over the transactional\n+behaviour of objects that implement interfaces marked with the `@Transactional` annotation.\n \n == Creating STM objects\n \n-The STM library needs to be told which objects it should be managing by providing a container for the transactional memory.\n-The default container (`org.jboss.stm.Container`) provides support for volatile objects that cannot be shared between JVMs\n-(although other constructors do allow for other models):\n+The STM subsystem needs to be told about which objects it should be managing. The Quarkus (aka Narayana) STM implementation\n+does this by providing containers of transactional memory within which these object instances reside. Until an object\n+is placed within one of these STM containers it cannot be managed within transactions and any state changes will\n+not possess the A, C, I (or even D) properties.\n+\n+Note, the term \"container\" was defined within the STM implementation years before Linux containers came along. It may\n+be confusing to use especially in a Kuberenetes native environment such as Quarkus, but hopefully", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd143c11efadcad61ced77c911fead8c12f34fdc"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MjIzOTE3OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQxMDozMjozMlrOFaQ3xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQxNzoxMjowNlrOFaSNkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA4MzcxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            <2> Then you create an instance that implements FlightService. You should not use it directly at this stage because\n          \n          \n            \n            <2> Then you create an instance that implements `FlightService`. You should not use it directly at this stage because", "url": "https://github.com/quarkusio/quarkus/pull/6398#discussion_r363083719", "createdAt": "2020-01-05T10:32:32Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "diffHunk": "@@ -82,25 +177,30 @@ The default container (`org.jboss.stm.Container`) provides support for volatile\n \n <1> You need to tell each Container about the type of objects for which it will be responsible. In this example\n     it will be instances that implement the FlightService interface.\n-<2> Then you create an instance that implements FlightService. You cannot use it directly at this stage because\n-    its operations aren't being monitored by the Container.\n-<3> To obtain a managed instance, pass the instance to the `container` to obtain a reference through which you\n-    will be able perform transactional operations. This reference can be used safely from multiple threads\n-    (provided that each thread uses it in a transaction context - see the next section.\n+<2> Then you create an instance that implements FlightService. You should not use it directly at this stage because", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd143c11efadcad61ced77c911fead8c12f34fdc"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzEwNTY4Mg==", "bodyText": "Must've been there originally because I haven't edited that text yet ...", "url": "https://github.com/quarkusio/quarkus/pull/6398#discussion_r363105682", "createdAt": "2020-01-05T17:12:06Z", "author": {"login": "nmcl"}, "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "diffHunk": "@@ -82,25 +177,30 @@ The default container (`org.jboss.stm.Container`) provides support for volatile\n \n <1> You need to tell each Container about the type of objects for which it will be responsible. In this example\n     it will be instances that implement the FlightService interface.\n-<2> Then you create an instance that implements FlightService. You cannot use it directly at this stage because\n-    its operations aren't being monitored by the Container.\n-<3> To obtain a managed instance, pass the instance to the `container` to obtain a reference through which you\n-    will be able perform transactional operations. This reference can be used safely from multiple threads\n-    (provided that each thread uses it in a transaction context - see the next section.\n+<2> Then you create an instance that implements FlightService. You should not use it directly at this stage because", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA4MzcxOQ=="}, "originalCommit": {"oid": "fd143c11efadcad61ced77c911fead8c12f34fdc"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MjIzOTUwOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQxMDozMzoxN1rOFaQ38Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQxMDozMzoxN1rOFaQ38Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA4Mzc2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            a transaction already associated with the caling thread then each of these annotations behaves slightly differently:\n          \n          \n            \n            a transaction already associated with the calling thread then each of these annotations behaves slightly differently:", "url": "https://github.com/quarkusio/quarkus/pull/6398#discussion_r363083761", "createdAt": "2020-01-05T10:33:17Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/software-transactional-memory.adoc", "diffHunk": "@@ -82,25 +177,30 @@ The default container (`org.jboss.stm.Container`) provides support for volatile\n \n <1> You need to tell each Container about the type of objects for which it will be responsible. In this example\n     it will be instances that implement the FlightService interface.\n-<2> Then you create an instance that implements FlightService. You cannot use it directly at this stage because\n-    its operations aren't being monitored by the Container.\n-<3> To obtain a managed instance, pass the instance to the `container` to obtain a reference through which you\n-    will be able perform transactional operations. This reference can be used safely from multiple threads\n-    (provided that each thread uses it in a transaction context - see the next section.\n+<2> Then you create an instance that implements FlightService. You should not use it directly at this stage because\n+    access to it is not being managed by the STM subsystem.\n+<3> To obtain a managed instance, pass the original object to the STM `container` which then returns a reference\n+    through which you will be able perform transactional operations. This reference can be used safely from multiple threads.\n \n == Defining transaction boundaries\n \n-STM objects must be accessed within a transaction (otherwise they will behave just like any other java object).\n-You can define the transaction boundary in two ways:\n+Once an object is placed within an STM container the application developer can manage the scope of transactions\n+within which it is used. There are some annotations which can be applied to the STM-aware class to have the\n+container automatically create a transaction whenever a specific method is invoked.\n \n === Declarative approach\n \n-The easiest, but less flexible, way to define your transaction boundaries is to place an `@NestedTopLevel` or `@Nested` annotation on the interface.\n-Then when a method of your transactional object is invoked a new transaction will be created for the duration of the method call.\n+If the `@NestedTopLevel` or `@Nested` annotation is placed on a method signature then the STM container will\n+start a new transaction when that method is invoked and attempt to commit it when the method returns. If there is\n+a transaction already associated with the caling thread then each of these annotations behaves slightly differently:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd143c11efadcad61ced77c911fead8c12f34fdc"}, "originalPosition": 198}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1283, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}