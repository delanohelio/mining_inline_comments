{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ5NDI4NzY1", "number": 10745, "title": "Introduce extensions for the Elasticsearch clients", "bodyText": "@loicmathieu this is a continuation of your PR here #8290 with cleaner commits and some additional changes:\n\nI fixed a few doc issues\nI used the Feature class for the features\nI cleaned up the package names for more consistency. Keep in mind that non-API runtime classes should be in the runtime subpackage\nI added a description for the visible runtime extensions as it will be visible at code.quarkus.io.\nI changed the bean initialization a bit by avoiding the @PostConstruct pattern.\n\nAll in all, its all minor changes but I wanted to make a list so that you have them in mind when reviewing (and for the next extensions).\nCould you have a look and check everything is OK with you?\nI preferred opening another PR so that we still have yours handy in case you want to compare or I missed something important.", "createdAt": "2020-07-15T11:46:11Z", "url": "https://github.com/quarkusio/quarkus/pull/10745", "merged": true, "mergeCommit": {"oid": "498f1f06ebad3c49517d78d827869dd4d067a16f"}, "closed": true, "closedAt": "2020-07-22T07:36:42Z", "author": {"login": "gsmet"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc1KJKyAFqTQ0ODg4MDE3OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc3IqPrABqjM1NzIwNjc1MzU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4ODgwMTc4", "url": "https://github.com/quarkusio/quarkus/pull/10745#pullrequestreview-448880178", "createdAt": "2020-07-15T11:54:12Z", "commit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "state": "COMMENTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMTo1NDoxMlrOGx6qpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjo0NzoyMFrOGx8dkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5NDU5Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * The username used for authentication.\n          \n          \n            \n                 * The username for basic HTTP authentication.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r454994596", "createdAt": "2020-07-15T11:54:12Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/ElasticsearchConfig.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigPhase;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot(phase = ConfigPhase.RUN_TIME)\n+public class ElasticsearchConfig {\n+\n+    /**\n+     * The list of hosts of the Elasticsearch servers.\n+     */\n+    @ConfigItem(defaultValue = \"localhost:9200\")\n+    public List<String> hosts;\n+\n+    /**\n+     * The protocol to use when contacting Elasticsearch servers.\n+     * Set to \"https\" to enable SSL/TLS.\n+     */\n+    @ConfigItem(defaultValue = \"http\")\n+    public String protocol;\n+\n+    /**\n+     * The username used for authentication.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5NDcxOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * The password used for authentication.\n          \n          \n            \n                 * The password for basic HTTP authentication.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r454994718", "createdAt": "2020-07-15T11:54:28Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/ElasticsearchConfig.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigPhase;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot(phase = ConfigPhase.RUN_TIME)\n+public class ElasticsearchConfig {\n+\n+    /**\n+     * The list of hosts of the Elasticsearch servers.\n+     */\n+    @ConfigItem(defaultValue = \"localhost:9200\")\n+    public List<String> hosts;\n+\n+    /**\n+     * The protocol to use when contacting Elasticsearch servers.\n+     * Set to \"https\" to enable SSL/TLS.\n+     */\n+    @ConfigItem(defaultValue = \"http\")\n+    public String protocol;\n+\n+    /**\n+     * The username used for authentication.\n+     */\n+    @ConfigItem\n+    public Optional<String> username;\n+\n+    /**\n+     * The password used for authentication.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5NTc0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * By default, this is the number of locally detected processors.\n          \n          \n            \n                 * By default, this is the number of locally detected processors.\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * Thread counts higher than the number of processors should not be necessary because the I/O threads rely on non-blocking operations,\n          \n          \n            \n                 * but you may want to use a thread count lower than the number of processors.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r454995748", "createdAt": "2020-07-15T11:56:27Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/ElasticsearchConfig.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigPhase;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot(phase = ConfigPhase.RUN_TIME)\n+public class ElasticsearchConfig {\n+\n+    /**\n+     * The list of hosts of the Elasticsearch servers.\n+     */\n+    @ConfigItem(defaultValue = \"localhost:9200\")\n+    public List<String> hosts;\n+\n+    /**\n+     * The protocol to use when contacting Elasticsearch servers.\n+     * Set to \"https\" to enable SSL/TLS.\n+     */\n+    @ConfigItem(defaultValue = \"http\")\n+    public String protocol;\n+\n+    /**\n+     * The username used for authentication.\n+     */\n+    @ConfigItem\n+    public Optional<String> username;\n+\n+    /**\n+     * The password used for authentication.\n+     */\n+    @ConfigItem\n+    public Optional<String> password;\n+\n+    /**\n+     * The connection timeout.\n+     */\n+    @ConfigItem(defaultValue = \"1S\")\n+    public Duration connectionTimeout;\n+\n+    /**\n+     * The socket timeout.\n+     */\n+    @ConfigItem(defaultValue = \"30S\")\n+    public Duration socketTimeout;\n+\n+    /**\n+     * The number of IO thread.\n+     * By default, this is the number of locally detected processors.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5Njc5MA==", "bodyText": "Shouldn't the port be optional and default to 9200?", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r454996790", "createdAt": "2020-07-15T11:58:23Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;\n+import org.apache.http.impl.nio.reactor.IOReactorConfig;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.sniff.Sniffer;\n+\n+public final class RestClientBuilderHelper {\n+\n+    private RestClientBuilderHelper() {\n+        // avoid instantiation\n+    }\n+\n+    static RestClientBuilder createRestClientBuilder(ElasticsearchConfig config) {\n+        List<HttpHost> hosts = config.hosts.stream().map(s -> new HttpHost(s.substring(0, s.indexOf(\":\")),\n+                Integer.parseInt(s.substring(s.indexOf(\":\") + 1)), config.protocol)).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5NzYxOA==", "bodyText": "In Hibernate Search, we issue a warning in this case if the protocol is set to http (the default), because then the password will be transmitted using a clear-text connection, which is a security issue on public networks.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r454997618", "createdAt": "2020-07-15T12:00:07Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;\n+import org.apache.http.impl.nio.reactor.IOReactorConfig;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.sniff.Sniffer;\n+\n+public final class RestClientBuilderHelper {\n+\n+    private RestClientBuilderHelper() {\n+        // avoid instantiation\n+    }\n+\n+    static RestClientBuilder createRestClientBuilder(ElasticsearchConfig config) {\n+        List<HttpHost> hosts = config.hosts.stream().map(s -> new HttpHost(s.substring(0, s.indexOf(\":\")),\n+                Integer.parseInt(s.substring(s.indexOf(\":\") + 1)), config.protocol)).collect(Collectors.toList());\n+        RestClientBuilder builder = RestClient.builder(hosts.toArray(new HttpHost[0]));\n+\n+        builder.setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() {\n+            @Override\n+            public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {\n+                return requestConfigBuilder\n+                        .setConnectTimeout((int) config.connectionTimeout.toMillis())\n+                        .setSocketTimeout((int) config.socketTimeout.toMillis());\n+            }\n+        });\n+\n+        builder.setHttpClientConfigCallback(new RestClientBuilder.HttpClientConfigCallback() {\n+            @Override\n+            public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {\n+                if (config.username.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5ODgxMg==", "bodyText": "As far as I know, the passowrd may not be provided here. I believe HTTP authentication with an empty password is legal?\nThe http client seems to handle this case by using the string \"null\" as the password, though. Which I doubt will ever work.\nIn any case, you may want a better exception than the NoSuchElementException currently being thrown by password.get().", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r454998812", "createdAt": "2020-07-15T12:02:23Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;\n+import org.apache.http.impl.nio.reactor.IOReactorConfig;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.sniff.Sniffer;\n+\n+public final class RestClientBuilderHelper {\n+\n+    private RestClientBuilderHelper() {\n+        // avoid instantiation\n+    }\n+\n+    static RestClientBuilder createRestClientBuilder(ElasticsearchConfig config) {\n+        List<HttpHost> hosts = config.hosts.stream().map(s -> new HttpHost(s.substring(0, s.indexOf(\":\")),\n+                Integer.parseInt(s.substring(s.indexOf(\":\") + 1)), config.protocol)).collect(Collectors.toList());\n+        RestClientBuilder builder = RestClient.builder(hosts.toArray(new HttpHost[0]));\n+\n+        builder.setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() {\n+            @Override\n+            public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {\n+                return requestConfigBuilder\n+                        .setConnectTimeout((int) config.connectionTimeout.toMillis())\n+                        .setSocketTimeout((int) config.socketTimeout.toMillis());\n+            }\n+        });\n+\n+        builder.setHttpClientConfigCallback(new RestClientBuilder.HttpClientConfigCallback() {\n+            @Override\n+            public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {\n+                if (config.username.isPresent()) {\n+                    CredentialsProvider credentialsProvider = new BasicCredentialsProvider();\n+                    credentialsProvider.setCredentials(AuthScope.ANY,\n+                            new UsernamePasswordCredentials(config.username.get(), config.password.get()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAwMjUyNw==", "bodyText": "I don't know if you intend to use the same code for the quickstart, but in case you do... this code is prone to injection. Users could potentially insert some very heavy aggregation in your query, for example. I don't know for sure, but I can imagine building on this vulnerability to trigger a DOS.\nThe proper way to do this would be to use a library such as GSON, Jackson, or whatever you fancy to build a structured JSON object, then serializing that object to a string. But then the code gets ugly, there's no denying that :)", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455002527", "createdAt": "2020-07-15T12:09:44Z", "author": {"login": "yrodiere"}, "path": "integration-tests/elasticsearch-rest-client/src/main/java/io/quarkus/it/elasticsearch/FruitService.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package io.quarkus.it.elasticsearch;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.http.util.EntityUtils;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+@ApplicationScoped\n+public class FruitService {\n+    @Inject\n+    RestClient restClient;\n+\n+    public void index(Fruit fruit) throws IOException {\n+        Request request = new Request(\n+                \"PUT\",\n+                \"/fruits/_doc/\" + fruit.id);\n+        request.setJsonEntity(JsonObject.mapFrom(fruit).toString());\n+        restClient.performRequest(request);\n+    }\n+\n+    public Fruit get(String id) throws IOException {\n+        Request request = new Request(\n+                \"GET\",\n+                \"/fruits/_doc/\" + id);\n+        Response response = restClient.performRequest(request);\n+        String responseBody = EntityUtils.toString(response.getEntity());\n+        JsonObject json = new JsonObject(responseBody);\n+        return json.getJsonObject(\"_source\").mapTo(Fruit.class);\n+    }\n+\n+    public List<Fruit> searchByColor(String color) throws IOException {\n+        return search(\"color\", color);\n+    }\n+\n+    public List<Fruit> searchByName(String name) throws IOException {\n+        return search(\"name\", name);\n+    }\n+\n+    private List<Fruit> search(String term, String match) throws IOException {\n+        Request request = new Request(\n+                \"GET\",\n+                \"/fruits/_search\");\n+        String query = String.format(\"{\\\"query\\\": { \\\"match\\\": { \\\"%s\\\":\\\"%s\\\"}}}\", term, match);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAwNDYxMQ==", "bodyText": "You might want to test that the configuration properties actually do something?", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455004611", "createdAt": "2020-07-15T12:13:38Z", "author": {"login": "yrodiere"}, "path": "integration-tests/elasticsearch-rest-client/src/main/resources/application.properties", "diffHunk": "@@ -0,0 +1,2 @@\n+# Configuration file\n+# key = value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAwNzc1Mw==", "bodyText": "Just a heads-up: this will fail in an application that defines multiple rest clients (to communicate with multiple Elasticsearch clusters from the same application).\nI know the current low-level REST client extension doesn't allow that, but users can still define their own beans (which is typically what I would do if I needed to communicate with multiple Elasticsearch clusters).", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455007753", "createdAt": "2020-07-15T12:19:20Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-high-level-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/highlevel/runtime/ElasticsearchRestHighLevelClientProducer.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package io.quarkus.elasticsearch.restclient.highlevel.runtime;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Collections;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestHighLevelClient;\n+\n+@ApplicationScoped\n+public class ElasticsearchRestHighLevelClientProducer {\n+\n+    @Inject\n+    RestClient restClient;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "213034de857bfefe50c74d7a25b0175c1e5a7280"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxMTQ3Ng==", "bodyText": "Since we're all about reactive these days, maybe you could use performRequestAsync instead? It's not exactly reactive, but it's async and accepts a callback, so...\nThe code would definitely be more complex, though.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455011476", "createdAt": "2020-07-15T12:25:58Z", "author": {"login": "yrodiere"}, "path": "integration-tests/elasticsearch-rest-client/src/main/java/io/quarkus/it/elasticsearch/FruitService.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package io.quarkus.it.elasticsearch;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.http.util.EntityUtils;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+@ApplicationScoped\n+public class FruitService {\n+    @Inject\n+    RestClient restClient;\n+\n+    public void index(Fruit fruit) throws IOException {\n+        Request request = new Request(\n+                \"PUT\",\n+                \"/fruits/_doc/\" + fruit.id);\n+        request.setJsonEntity(JsonObject.mapFrom(fruit).toString());\n+        restClient.performRequest(request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxMzY2Ng==", "bodyText": "Not sure \"readiness\" should be mentioned here? Unless Quarkus waits for the health check to pass before bringing the application online, this wording is confusing.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455013666", "createdAt": "2020-07-15T12:29:45Z", "author": {"login": "yrodiere"}, "path": "docs/src/main/asciidoc/elasticsearch.adoc", "diffHunk": "@@ -0,0 +1,414 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Connecting to an Elasticsearch cluster\n+include::./attributes.adoc[]\n+:extension-status: preview\n+\n+Elasticsearch is a well known full text search engine and NoSQL datastore.\n+\n+In this guide, we will see how you can get your REST services to use an Elasticsearch cluster.\n+\n+Quarkus provides two ways of accessing Elasticsearch: via the lower level `RestClient` or via the `RestHighLevelClient` we will call them\n+the low level and the high level clients.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Elasticsearch installed or Docker installed\n+\n+== Architecture\n+\n+The application built in this guide is quite simple: the user can add elements in a list using a form and the list is updated.\n+\n+All the information between the browser and the server is formatted as JSON.\n+\n+The elements are stored in Elasticsearch.\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution for the low level client is located in the `elasticsearch-rest-client-quickstart` {quickstarts-tree-url}/elasticsearch-rest-client-quickstart[directory].\n+\n+The solution for the high level client is located in the `elasticsearch-rest-high-level-client-quickstart` {quickstarts-tree-url}/elasticsearch-rest-high-level-client-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=elasticsearch-quickstart \\\n+    -DclassName=\"org.acme.elasticsearch.FruitResource\" \\\n+    -Dpath=\"/fruits\" \\\n+    -Dextensions=\"resteasy-jackson,elasticsearch-rest-client\"\n+cd elasticsearch-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Jackson, and the Elasticsearch low level client extensions.\n+After this, the `quarkus-elasticsearch-rest-client` extension has been added to your `pom.xml`.\n+\n+If you want to use the high level client instead, replace the `elasticsearch-rest-client` extension by the `elasticsearch-rest-high-level-client` extension.\n+\n+[NOTE]\n+====\n+We use the `resteasy-jackson` extension here and not the JSON-B variant because we will use the Vert.x `JsonObject` helper\n+to serialize/deserialize our objects to/from Elasticsearch and it uses Jackson under the hood.\n+====\n+\n+If you don\u2019t want to generate a new project, add the following dependencies to your pom.xml.\n+\n+For the Elasticsearch low level client, add:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-elasticsearch-rest-client</artifactId>\n+</dependency>\n+----\n+\n+For the Elasticsearch high level client, add:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-elasticsearch-rest-high-level-client</artifactId>\n+</dependency>\n+----\n+\n+== Creating your first JSON REST service\n+\n+In this example, we will create an application to manage a list of fruits.\n+\n+First, let's create the `Fruit` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.elasticsearch;\n+\n+public class Fruit {\n+    public String id;\n+    public String name;\n+    public String color;\n+}\n+----\n+\n+Nothing fancy. One important thing to note is that having a default constructor is required by the JSON serialization layer.\n+\n+Now create a `org.acme.elasticsearch.FruitService` that will be the business layer of our application and store/load the fruits from the Elasticsearch instance.\n+Here we use the low level client, if you want to use the high level client instead follow the instructions in the link:#using-the-high-level-rest-client[Using the High Level REST Client] paragraph instead.\n+\n+[source,java]\n+----\n+package org.acme.elasticsearch;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.http.util.EntityUtils;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+@ApplicationScoped\n+public class FruitService {\n+    @Inject\n+    RestClient restClient; //<1>\n+\n+    public void index(Fruit fruit) throws IOException {\n+        Request request = new Request(\n+                \"PUT\",\n+                \"/fruits/_doc/\" + fruit.id); //<2>\n+        request.setJsonEntity(JsonObject.mapFrom(fruit).toString()); //<3>\n+        restClient.performRequest(request); //<4>\n+    }\n+\n+    public Fruit get(String id) throws IOException {\n+        Request request = new Request(\n+                \"GET\",\n+                \"/fruits/_doc/\" + id);\n+        Response response = restClient.performRequest(request);\n+        String responseBody = EntityUtils.toString(response.getEntity());\n+        JsonObject json = new JsonObject(responseBody); //<5>\n+        return json.getJsonObject(\"_source\").mapTo(Fruit.class);\n+    }\n+\n+    public List<Fruit> searchByColor(String color) throws IOException {\n+        return search(\"color\", color);\n+    }\n+\n+    public List<Fruit> searchByName(String name) throws IOException {\n+        return search(\"name\", name);\n+    }\n+\n+    private List<Fruit> search(String term, String match) throws IOException {\n+        Request request = new Request(\n+                \"GET\",\n+                \"/fruits/_search\");\n+        String query = String.format(\"{\\\"query\\\": { \\\"match\\\": { \\\"%s\\\":\\\"%s\\\"}}}\", term, match);\n+        request.setJsonEntity(query);\n+        Response response = restClient.performRequest(request);\n+        String responseBody = EntityUtils.toString(response.getEntity());\n+\n+        JsonObject json = new JsonObject(responseBody);\n+        JsonArray hits = json.getJsonObject(\"hits\").getJsonArray(\"hits\");\n+        List<Fruit> results = new ArrayList<>(hits.size());\n+        for (int i = 0; i < hits.size(); i++) {\n+            JsonObject hit = hits.getJsonObject(i);\n+            Fruit fruit = hit.getJsonObject(\"_source\").mapTo(Fruit.class);\n+            results.add(fruit);\n+        }\n+        return results;\n+    }\n+}\n+----\n+\n+In this example you can note the following:\n+\n+1. We inject an Elasticsearch low level `RestClient` into our service.\n+2. We create an Elasticsearch request.\n+3. We use Vert.x `JsonObject` to serialize the object before sending it to Elasticsearch, you can use whatever you want to serialize to JSON.\n+4. We send the request (indexing request here) to Elasticsearch.\n+5. In order to deserialize the object from Elasticsearch, we again use Vert.x `JsonObject`.\n+\n+Now, edit the `org.acme.elasticsearch.FruitResource` class as follows:\n+\n+[source,java]\n+----\n+@Path(\"/fruits\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class FruitResource {\n+    @Inject\n+    FruitService fruitService;\n+\n+    @POST\n+    public Response index(Fruit fruit) throws IOException {\n+        if (fruit.id == null) {\n+            fruit.id = UUID.randomUUID().toString();\n+        }\n+        fruitService.index(fruit);\n+        return Response.created(URI.create(\"/fruits/\" + fruit.id)).build();\n+    }\n+\n+    @GET\n+    @Path(\"/{id}\")\n+    public Fruit get(@PathParam(\"id\") String id) throws IOException {\n+        return fruitService.get(id);\n+    }\n+\n+    @GET\n+    @Path(\"/search\")\n+    public List<Fruit> search(@QueryParam(\"name\") String name, @QueryParam(\"color\") String color) throws IOException {\n+        if (name != null) {\n+            return fruitService.searchByName(name);\n+        } else if (color != null) {\n+            return fruitService.searchByColor(color);\n+        } else {\n+            throw new BadRequestException(\"Should provide name or color query parameter\");\n+        }\n+    }\n+\n+}\n+----\n+\n+The implementation is pretty straightforward and you just need to define your endpoints using the JAX-RS annotations and use the `FruitService` to list/add new fruits.\n+\n+== Configuring Elasticsearch\n+The main property to configure is the URL to connect to the Elasticsearch cluster.\n+\n+A sample configuration should look like this:\n+\n+[source,properties]\n+----\n+# configure the Elasticsearch client for a cluster of two nodes\n+quarkus.elasticsearch.hosts = elasticsearch1:9200,elasticsearch2:9200\n+----\n+\n+In this example, we are using a single instance running on localhost:\n+\n+[source,properties]\n+----\n+# configure the Elasticsearch client for a single instance on localhost\n+quarkus.elasticsearch.hosts = localhost:9200\n+----\n+\n+If you need a more advanced configuration, you can find the comprehensive list of supported configuration properties at the end of this guide.\n+\n+\n+== Running an Elasticsearch cluster\n+\n+As by default, the Elasticsearch client is configured to access a local Elasticsearch cluster on port 9200 (the default Elasticsearch port),\n+if you have a local running instance on this port, there is nothing more to do before being able to test it!\n+\n+If you want to use Docker to run an Elasticsearch instance, you can use the following command to launch one:\n+\n+[source,shell,subs=attributes+]\n+----\n+docker run --name elasticsearch  -e \"discovery.type=single-node\" -e \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"\\\n+       --rm -p 9200:9200 docker.elastic.co/elasticsearch/elasticsearch-oss:{elasticsearch-version}\n+----\n+\n+== Creating a frontend\n+\n+Now let's add a simple web page to interact with our `FruitResource`.\n+Quarkus automatically serves static resources located under the `META-INF/resources` directory.\n+In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the content from this {quickstarts-blob-url}/elasticsearch-low-level-client-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] file in it.\n+\n+You can now interact with your REST service:\n+\n+* start Quarkus with `./mvnw quarkus:dev`\n+* open a browser to `http://localhost:8080/fruits.html`\n+* add new fruits to the list via the 'Add fruit' form\n+* search for fruits by name or color via the 'Search Fruit' form\n+\n+== Using the High Level REST Client\n+\n+Quarkus provides support for the Elasticsearch High Level REST Client but keep in mind that it comes with some caveats:\n+\n+- It drags a lot of dependencies - especially Lucene -, which doesn't fit well with Quarkus philosophy. The Elasticsearch team is aware of this issue and it might improve sometime in the future.\n+- It is tied to a certain version of the Elasticsearch server: you cannot use a High Level REST Client version 7 to access a server version 6.\n+\n+Here is a version of the `FruitService` using the high level client instead of the low level one:\n+\n+[source,java]\n+----\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import io.vertx.core.json.JsonObject;\n+\n+@ApplicationScoped\n+public class FruitService {\n+    @Inject\n+    RestHighLevelClient restHighLevelClient; // <1>\n+\n+    public void index(Fruit fruit) throws IOException {\n+        IndexRequest request = new IndexRequest(\"fruits\"); // <2>\n+        request.id(fruit.id);\n+        request.source(JsonObject.mapFrom(fruit).toString(), XContentType.JSON); // <3>\n+        restHighLevelClient.index(request, RequestOptions.DEFAULT); // <4>\n+    }\n+\n+    public Fruit get(String id) throws IOException {\n+        GetRequest getRequest = new GetRequest(\"fruits\", id);\n+        GetResponse getResponse = restHighLevelClient.get(getRequest, RequestOptions.DEFAULT);\n+        if (getResponse.isExists()) {\n+            String sourceAsString = getResponse.getSourceAsString();\n+            JsonObject json = new JsonObject(sourceAsString); // <5>\n+            return json.mapTo(Fruit.class);\n+        }\n+        return null;\n+    }\n+\n+    public List<Fruit> searchByColor(String color) throws IOException {\n+        return search(\"color\", color);\n+    }\n+\n+    public List<Fruit> searchByName(String name) throws IOException {\n+        return search(\"name\", name);\n+    }\n+\n+    private List<Fruit> search(String term, String match) throws IOException {\n+        SearchRequest searchRequest = new SearchRequest(\"fruits\");\n+        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\n+        searchSourceBuilder.query(QueryBuilders.matchQuery(term, match));\n+        searchRequest.source(searchSourceBuilder);\n+\n+        SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);\n+        SearchHits hits = searchResponse.getHits();\n+        List<Fruit> results = new ArrayList<>(hits.getHits().length);\n+        for (SearchHit hit : hits.getHits()) {\n+            String sourceAsString = hit.getSourceAsString();\n+            JsonObject json = new JsonObject(sourceAsString);\n+            results.add(json.mapTo(Fruit.class));\n+        }\n+        return results;\n+    }\n+}\n+----\n+\n+In this example you can note the following:\n+\n+1. We inject an Elasticsearch `RestHighLevelClient` inside the service.\n+2. We create an Elasticsearch index request.\n+3. We use Vert.x `JsonObject` to serialize the object before sending it to Elasticsearch, you can use whatever you want to serialize to JSON.\n+4. We send the request to Elasticsearch.\n+5. In order to deserialize the object from Elasticsearch, we again use Vert.x `JsonObject`.\n+\n+== Hibernate Search Elasticsearch\n+\n+Quarkus supports Hibernate Search with Elasticsearch via the `hibernate-search-elasticsearch` extension.\n+\n+Hibernate Search Elasticsearch allows to synchronize your JPA entities to an Elasticsearch cluster and offers a way to query your Elasticsearch cluster using the Hibernate Search API.\n+\n+If you're interested in it, you can read the link:hibernate-search-elasticsearch[Hibernate Search with Elasticsearch guide].\n+\n+== Cluster Health Check\n+\n+If you are using the `quarkus-smallrye-health` extension, both the extension will automatically add a readiness health check", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fa8866fb9dabe4a656c9d7c4ac78da2ffaf85e6"}, "originalPosition": 390}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxOTE4Mg==", "bodyText": "Connections settings, which I think are quite important, are missing:\n\nmax_connections: the maximum number of connections to the cluster.\nmax_connections_per_route: the maximum number of connections to each node in the cluster.\n\nSee https://github.com/hibernate/hibernate-search/blob/9da99d7de8f346aa0ec81ae2ce0a1fa2c1657b2a/backend/elasticsearch/src/main/java/org/hibernate/search/backend/elasticsearch/client/impl/ElasticsearchClientFactoryImpl.java#L201-L200", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455019182", "createdAt": "2020-07-15T12:39:28Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/ElasticsearchConfig.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigPhase;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot(phase = ConfigPhase.RUN_TIME)\n+public class ElasticsearchConfig {\n+\n+    /**\n+     * The list of hosts of the Elasticsearch servers.\n+     */\n+    @ConfigItem(defaultValue = \"localhost:9200\")\n+    public List<String> hosts;\n+\n+    /**\n+     * The protocol to use when contacting Elasticsearch servers.\n+     * Set to \"https\" to enable SSL/TLS.\n+     */\n+    @ConfigItem(defaultValue = \"http\")\n+    public String protocol;\n+\n+    /**\n+     * The username used for authentication.\n+     */\n+    @ConfigItem\n+    public Optional<String> username;\n+\n+    /**\n+     * The password used for authentication.\n+     */\n+    @ConfigItem\n+    public Optional<String> password;\n+\n+    /**\n+     * The connection timeout.\n+     */\n+    @ConfigItem(defaultValue = \"1S\")\n+    public Duration connectionTimeout;\n+\n+    /**\n+     * The socket timeout.\n+     */\n+    @ConfigItem(defaultValue = \"30S\")\n+    public Duration socketTimeout;\n+\n+    /**\n+     * The number of IO thread.\n+     * By default, this is the number of locally detected processors.\n+     *\n+     * @see <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/_number_of_threads.html\">number of\n+     *      threads</a>\n+     */\n+    @ConfigItem\n+    public Optional<Integer> ioThreadCounts;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAyMDI0Nw==", "bodyText": "You may want to customize the thread factory to give a better name to client threads (something that mentions Elasticsearch).\nSee https://github.com/hibernate/hibernate-search/blob/9da99d7de8f346aa0ec81ae2ce0a1fa2c1657b2a/backend/elasticsearch/src/main/java/org/hibernate/search/backend/elasticsearch/client/impl/ElasticsearchClientFactoryImpl.java#L203", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455020247", "createdAt": "2020-07-15T12:41:18Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;\n+import org.apache.http.impl.nio.reactor.IOReactorConfig;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.sniff.Sniffer;\n+\n+public final class RestClientBuilderHelper {\n+\n+    private RestClientBuilderHelper() {\n+        // avoid instantiation\n+    }\n+\n+    static RestClientBuilder createRestClientBuilder(ElasticsearchConfig config) {\n+        List<HttpHost> hosts = config.hosts.stream().map(s -> new HttpHost(s.substring(0, s.indexOf(\":\")),\n+                Integer.parseInt(s.substring(s.indexOf(\":\") + 1)), config.protocol)).collect(Collectors.toList());\n+        RestClientBuilder builder = RestClient.builder(hosts.toArray(new HttpHost[0]));\n+\n+        builder.setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() {\n+            @Override\n+            public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {\n+                return requestConfigBuilder\n+                        .setConnectTimeout((int) config.connectionTimeout.toMillis())\n+                        .setSocketTimeout((int) config.socketTimeout.toMillis());\n+            }\n+        });\n+\n+        builder.setHttpClientConfigCallback(new RestClientBuilder.HttpClientConfigCallback() {\n+            @Override\n+            public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {\n+                if (config.username.isPresent()) {\n+                    CredentialsProvider credentialsProvider = new BasicCredentialsProvider();\n+                    credentialsProvider.setCredentials(AuthScope.ANY,\n+                            new UsernamePasswordCredentials(config.username.get(), config.password.get()));\n+                    httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider);\n+                }\n+\n+                if (config.ioThreadCounts.isPresent()) {\n+                    IOReactorConfig ioReactorConfig = IOReactorConfig.custom()\n+                            .setIoThreadCount(config.ioThreadCounts.get())\n+                            .build();\n+                    httpClientBuilder.setDefaultIOReactorConfig(ioReactorConfig);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAyMTEzNA==", "bodyText": "You don't seem to be using the \"protocol\" setting. You should use it here to disable SSL if it's not necessary, because SSL causes significant slowdowns on startup.\nSee https://github.com/hibernate/hibernate-search/blob/9da99d7de8f346aa0ec81ae2ce0a1fa2c1657b2a/backend/elasticsearch/src/main/java/org/hibernate/search/backend/elasticsearch/client/impl/ElasticsearchClientFactoryImpl.java#L204-L208", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455021134", "createdAt": "2020-07-15T12:42:48Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;\n+import org.apache.http.impl.nio.reactor.IOReactorConfig;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.sniff.Sniffer;\n+\n+public final class RestClientBuilderHelper {\n+\n+    private RestClientBuilderHelper() {\n+        // avoid instantiation\n+    }\n+\n+    static RestClientBuilder createRestClientBuilder(ElasticsearchConfig config) {\n+        List<HttpHost> hosts = config.hosts.stream().map(s -> new HttpHost(s.substring(0, s.indexOf(\":\")),\n+                Integer.parseInt(s.substring(s.indexOf(\":\") + 1)), config.protocol)).collect(Collectors.toList());\n+        RestClientBuilder builder = RestClient.builder(hosts.toArray(new HttpHost[0]));\n+\n+        builder.setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() {\n+            @Override\n+            public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {\n+                return requestConfigBuilder\n+                        .setConnectTimeout((int) config.connectionTimeout.toMillis())\n+                        .setSocketTimeout((int) config.socketTimeout.toMillis());\n+            }\n+        });\n+\n+        builder.setHttpClientConfigCallback(new RestClientBuilder.HttpClientConfigCallback() {\n+            @Override\n+            public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {\n+                if (config.username.isPresent()) {\n+                    CredentialsProvider credentialsProvider = new BasicCredentialsProvider();\n+                    credentialsProvider.setCredentials(AuthScope.ANY,\n+                            new UsernamePasswordCredentials(config.username.get(), config.password.get()));\n+                    httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider);\n+                }\n+\n+                if (config.ioThreadCounts.isPresent()) {\n+                    IOReactorConfig ioReactorConfig = IOReactorConfig.custom()\n+                            .setIoThreadCount(config.ioThreadCounts.get())\n+                            .build();\n+                    httpClientBuilder.setDefaultIOReactorConfig(ioReactorConfig);\n+                }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAyMTg2Mw==", "bodyText": "You need to take the protocol into account here, too.\nSee https://github.com/hibernate/hibernate-search/blob/9da99d7de8f346aa0ec81ae2ce0a1fa2c1657b2a/backend/elasticsearch/src/main/java/org/hibernate/search/backend/elasticsearch/client/impl/ElasticsearchClientFactoryImpl.java#L182-L190", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455021863", "createdAt": "2020-07-15T12:43:58Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;\n+import org.apache.http.impl.nio.reactor.IOReactorConfig;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.sniff.Sniffer;\n+\n+public final class RestClientBuilderHelper {\n+\n+    private RestClientBuilderHelper() {\n+        // avoid instantiation\n+    }\n+\n+    static RestClientBuilder createRestClientBuilder(ElasticsearchConfig config) {\n+        List<HttpHost> hosts = config.hosts.stream().map(s -> new HttpHost(s.substring(0, s.indexOf(\":\")),\n+                Integer.parseInt(s.substring(s.indexOf(\":\") + 1)), config.protocol)).collect(Collectors.toList());\n+        RestClientBuilder builder = RestClient.builder(hosts.toArray(new HttpHost[0]));\n+\n+        builder.setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() {\n+            @Override\n+            public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {\n+                return requestConfigBuilder\n+                        .setConnectTimeout((int) config.connectionTimeout.toMillis())\n+                        .setSocketTimeout((int) config.socketTimeout.toMillis());\n+            }\n+        });\n+\n+        builder.setHttpClientConfigCallback(new RestClientBuilder.HttpClientConfigCallback() {\n+            @Override\n+            public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {\n+                if (config.username.isPresent()) {\n+                    CredentialsProvider credentialsProvider = new BasicCredentialsProvider();\n+                    credentialsProvider.setCredentials(AuthScope.ANY,\n+                            new UsernamePasswordCredentials(config.username.get(), config.password.get()));\n+                    httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider);\n+                }\n+\n+                if (config.ioThreadCounts.isPresent()) {\n+                    IOReactorConfig ioReactorConfig = IOReactorConfig.custom()\n+                            .setIoThreadCount(config.ioThreadCounts.get())\n+                            .build();\n+                    httpClientBuilder.setDefaultIOReactorConfig(ioReactorConfig);\n+                }\n+\n+                return httpClientBuilder;\n+            }\n+        });\n+\n+        return builder;\n+    }\n+\n+    static Sniffer createSniffer(RestClient client, ElasticsearchConfig config) {\n+        return Sniffer.builder(client)\n+                .setSniffIntervalMillis((int) config.discovery.refreshInterval.toMillis())\n+                .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAyNDAxNg==", "bodyText": "Not sure it's still relevant nowadays, but you might want to call setConnectionRequestTimeout( 0 ) here to avoid requests being flagged as timed out even when they didn't time out.\nSee https://hibernate.atlassian.net/browse/HSEARCH-2681\nSee https://github.com/hibernate/hibernate-search/blob/9da99d7de8f346aa0ec81ae2ce0a1fa2c1657b2a/backend/elasticsearch/src/main/java/org/hibernate/search/backend/elasticsearch/client/impl/ElasticsearchClientFactoryImpl.java#L236", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455024016", "createdAt": "2020-07-15T12:47:20Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;\n+import org.apache.http.impl.nio.reactor.IOReactorConfig;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.sniff.Sniffer;\n+\n+public final class RestClientBuilderHelper {\n+\n+    private RestClientBuilderHelper() {\n+        // avoid instantiation\n+    }\n+\n+    static RestClientBuilder createRestClientBuilder(ElasticsearchConfig config) {\n+        List<HttpHost> hosts = config.hosts.stream().map(s -> new HttpHost(s.substring(0, s.indexOf(\":\")),\n+                Integer.parseInt(s.substring(s.indexOf(\":\") + 1)), config.protocol)).collect(Collectors.toList());\n+        RestClientBuilder builder = RestClient.builder(hosts.toArray(new HttpHost[0]));\n+\n+        builder.setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() {\n+            @Override\n+            public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {\n+                return requestConfigBuilder\n+                        .setConnectTimeout((int) config.connectionTimeout.toMillis())\n+                        .setSocketTimeout((int) config.socketTimeout.toMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4OTA2NDE4", "url": "https://github.com/quarkusio/quarkus/pull/10745#pullrequestreview-448906418", "createdAt": "2020-07-15T12:32:36Z", "commit": {"oid": "b7384a1267e6bcc24c35ef167363d57e347f1b39"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjozMjozN1rOGx77nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjo1NDozOFrOGx8uyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxNTMyNQ==", "bodyText": "I thought enumeration of the features inside th Feature class was something we want to avoid for now.\nI remember some discussion about this last time I created an extension ...", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455015325", "createdAt": "2020-07-15T12:32:37Z", "author": {"login": "loicmathieu"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/Feature.java", "diffHunk": "@@ -23,7 +23,9 @@\n     CDI,\n     CONFIG_YAML,\n     CONSUL_CONFIG,\n+    ELASTICSEARCH_REST_CLIENT_COMMON,\n     ELASTICSEARCH_REST_CLIENT,\n+    ELASTICSEARCH_REST_HIGH_LEVEL_CLIENT,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7384a1267e6bcc24c35ef167363d57e347f1b39"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxNzA5OQ==", "bodyText": "Shouldn't it be the REST client ?", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455017099", "createdAt": "2020-07-15T12:35:42Z", "author": {"login": "loicmathieu"}, "path": "extensions/elasticsearch-rest-client/runtime/pom.xml", "diffHunk": "@@ -2,49 +2,35 @@\n <project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n     <parent>\n-        <artifactId>quarkus-elasticsearch-rest-client-parent</artifactId>\n         <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-elasticsearch-rest-client-parent</artifactId>\n         <version>999-SNAPSHOT</version>\n-        <relativePath>../</relativePath>\n+        <relativePath>../pom.xml</relativePath>\n     </parent>\n-    <modelVersion>4.0.0</modelVersion>\n \n     <artifactId>quarkus-elasticsearch-rest-client</artifactId>\n     <name>Quarkus - Elasticsearch REST client - Runtime</name>\n-    <description>Elasticsearch REST client</description>\n+    <description>Connect to an Elasticsearch cluster using the low level client</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7384a1267e6bcc24c35ef167363d57e347f1b39"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAyODQyNA==", "bodyText": "Named Elasticsearch client (to allow connecting to multiple cluster) will be done in a followup PR, I'll open a followup PR to keep track of it.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455028424", "createdAt": "2020-07-15T12:54:38Z", "author": {"login": "loicmathieu"}, "path": "extensions/elasticsearch-rest-high-level-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/highlevel/runtime/ElasticsearchRestHighLevelClientProducer.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package io.quarkus.elasticsearch.restclient.highlevel.runtime;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Collections;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestHighLevelClient;\n+\n+@ApplicationScoped\n+public class ElasticsearchRestHighLevelClientProducer {\n+\n+    @Inject\n+    RestClient restClient;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAwNzc1Mw=="}, "originalCommit": {"oid": "213034de857bfefe50c74d7a25b0175c1e5a7280"}, "originalPosition": 20}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c02eb2b4e36fef13981573c0b6b0080fe94bfb1d", "author": {"user": {"login": "gsmet", "name": "Guillaume Smet"}}, "url": "https://github.com/quarkusio/quarkus/commit/c02eb2b4e36fef13981573c0b6b0080fe94bfb1d", "committedDate": "2020-07-15T14:36:09Z", "message": "Apply suggestions from code review\n\nCo-authored-by: Yoann Rodi\u00e8re <yoann@hibernate.org>"}, "afterCommit": {"oid": "c107b74552e0470c353b64024fb8afab96ef5295", "author": {"user": {"login": "gsmet", "name": "Guillaume Smet"}}, "url": "https://github.com/quarkusio/quarkus/commit/c107b74552e0470c353b64024fb8afab96ef5295", "committedDate": "2020-07-15T14:39:52Z", "message": "Move the Elasticsearch native ITs to a specific Data6 job"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d19542b4cbefcb659a760e2546dcc87bfd5abca4", "author": {"user": {"login": "gsmet", "name": "Guillaume Smet"}}, "url": "https://github.com/quarkusio/quarkus/commit/d19542b4cbefcb659a760e2546dcc87bfd5abca4", "committedDate": "2020-07-15T14:55:00Z", "message": "fixup! Add an Elasticsearch low level client extension"}, "afterCommit": {"oid": "34841460b38014249e79333d59dafc3b4c3c9e27", "author": {"user": {"login": "loicmathieu", "name": "Lo\u00efc Mathieu"}}, "url": "https://github.com/quarkusio/quarkus/commit/34841460b38014249e79333d59dafc3b4c3c9e27", "committedDate": "2020-07-21T15:30:42Z", "message": "fixup! Add an Elasticsearch low level client extension"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNjAyNTY1", "url": "https://github.com/quarkusio/quarkus/pull/10745#pullrequestreview-452602565", "createdAt": "2020-07-21T15:56:57Z", "commit": {"oid": "dfbccaab4633b8901adc7eb98eaf50fe0cfd1980"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNTo1Njo1N1rOG0-0WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNTo1Njo1N1rOG0-0WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwODM0NA==", "bodyText": "From the javadoc:\n * This class implements an IP Socket Address (IP address + port number)\n * It can also be a pair (hostname + port number), in which case an attempt\n * will be made to resolve the hostname.\n\nDo you really want that?", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r458208344", "createdAt": "2020-07-21T15:56:57Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/ElasticsearchConfig.java", "diffHunk": "@@ -16,7 +17,7 @@\n      * The list of hosts of the Elasticsearch servers.\n      */\n     @ConfigItem(defaultValue = \"localhost:9200\")\n-    public List<String> hosts;\n+    public List<InetSocketAddress> hosts;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfbccaab4633b8901adc7eb98eaf50fe0cfd1980"}, "originalPosition": 12}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dfbccaab4633b8901adc7eb98eaf50fe0cfd1980", "author": {"user": {"login": "gsmet", "name": "Guillaume Smet"}}, "url": "https://github.com/quarkusio/quarkus/commit/dfbccaab4633b8901adc7eb98eaf50fe0cfd1980", "committedDate": "2020-07-21T15:45:25Z", "message": "fixup! Add an Elasticsearch low level client extension"}, "afterCommit": {"oid": "52438312c5d04b33f37495576c467b6d185f79db", "author": {"user": {"login": "gsmet", "name": "Guillaume Smet"}}, "url": "https://github.com/quarkusio/quarkus/commit/52438312c5d04b33f37495576c467b6d185f79db", "committedDate": "2020-07-21T16:14:20Z", "message": "Move the Elasticsearch native ITs to a specific Data6 job"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f669a2620e17d75f62899fc127f5999abb436169", "author": {"user": {"login": "loicmathieu", "name": "Lo\u00efc Mathieu"}}, "url": "https://github.com/quarkusio/quarkus/commit/f669a2620e17d75f62899fc127f5999abb436169", "committedDate": "2020-07-21T16:16:39Z", "message": "Rename elasticsearch-rest-client extension to -common\n\nIt will be used by both the Hibernate Search - Elasticsearch extension\nand the Elasticsearch client extensions.\n\nCo-authored-by: Guillaume Smet <guillaume.smet@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85643a2bcab8f34fe81c579cae8efc1fbf119190", "author": {"user": {"login": "loicmathieu", "name": "Lo\u00efc Mathieu"}}, "url": "https://github.com/quarkusio/quarkus/commit/85643a2bcab8f34fe81c579cae8efc1fbf119190", "committedDate": "2020-07-21T16:16:53Z", "message": "Add an Elasticsearch low level client extension\n\nCo-authored-by: Guillaume Smet <guillaume.smet@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "183f04ea4acf9a64cb8594cf729fee2e5e664717", "author": {"user": {"login": "loicmathieu", "name": "Lo\u00efc Mathieu"}}, "url": "https://github.com/quarkusio/quarkus/commit/183f04ea4acf9a64cb8594cf729fee2e5e664717", "committedDate": "2020-07-21T16:16:57Z", "message": "Add an Elasticsearch high level client extension\n\nCo-authored-by: Guillaume Smet <guillaume.smet@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95c51da0d6c545e4ab2030c76c291ccc63a04bb4", "author": {"user": {"login": "loicmathieu", "name": "Lo\u00efc Mathieu"}}, "url": "https://github.com/quarkusio/quarkus/commit/95c51da0d6c545e4ab2030c76c291ccc63a04bb4", "committedDate": "2020-07-21T16:17:01Z", "message": "Add documentation for the new Elasticsearch client extensions\n\nCo-authored-by: Guillaume Smet <guillaume.smet@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecf34a658402acac868b43fd66ba07c07b215286", "author": {"user": {"login": "gsmet", "name": "Guillaume Smet"}}, "url": "https://github.com/quarkusio/quarkus/commit/ecf34a658402acac868b43fd66ba07c07b215286", "committedDate": "2020-07-21T16:17:05Z", "message": "Move the Elasticsearch native ITs to a specific Data6 job"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "52438312c5d04b33f37495576c467b6d185f79db", "author": {"user": {"login": "gsmet", "name": "Guillaume Smet"}}, "url": "https://github.com/quarkusio/quarkus/commit/52438312c5d04b33f37495576c467b6d185f79db", "committedDate": "2020-07-21T16:14:20Z", "message": "Move the Elasticsearch native ITs to a specific Data6 job"}, "afterCommit": {"oid": "ecf34a658402acac868b43fd66ba07c07b215286", "author": {"user": {"login": "gsmet", "name": "Guillaume Smet"}}, "url": "https://github.com/quarkusio/quarkus/commit/ecf34a658402acac868b43fd66ba07c07b215286", "committedDate": "2020-07-21T16:17:05Z", "message": "Move the Elasticsearch native ITs to a specific Data6 job"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3574, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}