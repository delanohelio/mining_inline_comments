{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU4OTIwMjQw", "number": 6387, "title": "Add JSON-B and Jackson serialization to the Kafka guide", "bodyText": "Add JSON serialization documentation to the Kafka guide.\nWhen using reactive messaging, I had a hard time figuring out that I need to use @SseElementType(MediaType.APPLICATION_JSON) to be able to generates JSON SSE, I didn't add this to the guide because I'm not sure it needs to be put here or inside a more general reactive guide ?", "createdAt": "2020-01-03T09:15:03Z", "url": "https://github.com/quarkusio/quarkus/pull/6387", "merged": true, "mergeCommit": {"oid": "c730ce9683d4f06b75e5c71f63b1f2fd41e0d9f6"}, "closed": true, "closedAt": "2020-01-03T13:02:47Z", "author": {"login": "loicmathieu"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb2rXqOAFqTMzODAwOTk4OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABb3mr-FgFqTMzODQ5MzEyMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4MDA5OTg4", "url": "https://github.com/quarkusio/quarkus/pull/6387#pullrequestreview-338009988", "createdAt": "2020-01-03T09:55:04Z", "commit": {"oid": "b07574a9589794cafb098c722b60096916ab0dcd"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QwOTo1NTowNFrOFZ8wRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QwOTo1ODowNlrOFZ8z0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NDExOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Quarkus has built-in capabilities to deals with JSON Kafka messages.\n          \n          \n            \n            Quarkus has built-in capabilities to deal with JSON Kafka messages.", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362754119", "createdAt": "2020-01-03T09:55:04Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b07574a9589794cafb098c722b60096916ab0dcd"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NDE4NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Imagine we have a `Fruit` pojo as following:\n          \n          \n            \n            Imagine we have a `Fruit` pojo as follows:", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362754184", "createdAt": "2020-01-03T09:55:18Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as following:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b07574a9589794cafb098c722b60096916ab0dcd"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NDQ5Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            First, you need to include the `quarkus-jsonb` dependency (if you already use the `quarkus-resteasy-jsonb` dependency this is not needed).\n          \n          \n            \n            First, you need to include the `quarkus-jsonb` extension (if you already use the `quarkus-resteasy-jsonb` extension, this is not needed).", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362754496", "createdAt": "2020-01-03T09:56:17Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as following:\n+\n+[source,java]\n+----\n+public class Fruit {\n+\n+    public String name;\n+    public int price;\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, int price) {\n+        this.name = name;\n+        this.price = price;\n+    }\n+}\n+----\n+\n+And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.\n+\n+[source,java]\n+----\n+import io.smallrye.reactive.messaging.annotations.Broadcast;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+/**\n+* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n+* The result is pushed to the \"fruit-out\" stream.\n+*/\n+@ApplicationScoped\n+public class FruitProcessor {\n+\n+    private static final double CONVERSION_RATE = 0.88;\n+\n+    @Incoming(\"fruit-in\")\n+    @Outgoing(\"fruit-out\")\n+    @Broadcast\n+    public double process(Fruit fruit) {\n+        fruit.price = fruit.price * CONVERSION_RATE;\n+        return fruit;\n+    }\n+\n+}\n+----\n+\n+To do this, we will need to setup JSON serialization with JSON-B or Jackson.\n+\n+NOTE: With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`.\n+\n+=== Serializing via JSON-B\n+\n+First, you need to include the `quarkus-jsonb` dependency (if you already use the `quarkus-resteasy-jsonb` dependency this is not needed).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b07574a9589794cafb098c722b60096916ab0dcd"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NDc0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Now, your Kafka messages will contains a JSON-B serialized representation of your Fruit pojo !\n          \n          \n            \n            Now, your Kafka messages will contain a JSON-B serialized representation of your Fruit pojo.", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362754748", "createdAt": "2020-01-03T09:57:10Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as following:\n+\n+[source,java]\n+----\n+public class Fruit {\n+\n+    public String name;\n+    public int price;\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, int price) {\n+        this.name = name;\n+        this.price = price;\n+    }\n+}\n+----\n+\n+And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.\n+\n+[source,java]\n+----\n+import io.smallrye.reactive.messaging.annotations.Broadcast;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+/**\n+* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n+* The result is pushed to the \"fruit-out\" stream.\n+*/\n+@ApplicationScoped\n+public class FruitProcessor {\n+\n+    private static final double CONVERSION_RATE = 0.88;\n+\n+    @Incoming(\"fruit-in\")\n+    @Outgoing(\"fruit-out\")\n+    @Broadcast\n+    public double process(Fruit fruit) {\n+        fruit.price = fruit.price * CONVERSION_RATE;\n+        return fruit;\n+    }\n+\n+}\n+----\n+\n+To do this, we will need to setup JSON serialization with JSON-B or Jackson.\n+\n+NOTE: With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`.\n+\n+=== Serializing via JSON-B\n+\n+First, you need to include the `quarkus-jsonb` dependency (if you already use the `quarkus-resteasy-jsonb` dependency this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jsonb</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jsonb;\n+\n+import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n+\n+public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+NOTE: If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer`\n+that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.\n+\n+Finally, configure your streams to use the JSON-B serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n+----\n+\n+Now, your Kafka messages will contains a JSON-B serialized representation of your Fruit pojo !", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b07574a9589794cafb098c722b60096916ab0dcd"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NDgyOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            First, you need to include the `quarkus-jackson` dependency (if you already use the `quarkus-jackson-jsonb` dependency this is not needed).\n          \n          \n            \n            First, you need to include the `quarkus-jackson` extension (if you already use the `quarkus-jackson-jsonb` extension, this is not needed).", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362754829", "createdAt": "2020-01-03T09:57:27Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as following:\n+\n+[source,java]\n+----\n+public class Fruit {\n+\n+    public String name;\n+    public int price;\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, int price) {\n+        this.name = name;\n+        this.price = price;\n+    }\n+}\n+----\n+\n+And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.\n+\n+[source,java]\n+----\n+import io.smallrye.reactive.messaging.annotations.Broadcast;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+/**\n+* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n+* The result is pushed to the \"fruit-out\" stream.\n+*/\n+@ApplicationScoped\n+public class FruitProcessor {\n+\n+    private static final double CONVERSION_RATE = 0.88;\n+\n+    @Incoming(\"fruit-in\")\n+    @Outgoing(\"fruit-out\")\n+    @Broadcast\n+    public double process(Fruit fruit) {\n+        fruit.price = fruit.price * CONVERSION_RATE;\n+        return fruit;\n+    }\n+\n+}\n+----\n+\n+To do this, we will need to setup JSON serialization with JSON-B or Jackson.\n+\n+NOTE: With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`.\n+\n+=== Serializing via JSON-B\n+\n+First, you need to include the `quarkus-jsonb` dependency (if you already use the `quarkus-resteasy-jsonb` dependency this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jsonb</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jsonb;\n+\n+import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n+\n+public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+NOTE: If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer`\n+that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.\n+\n+Finally, configure your streams to use the JSON-B serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n+----\n+\n+Now, your Kafka messages will contains a JSON-B serialized representation of your Fruit pojo !\n+\n+=== Serializing via Jackson\n+\n+First, you need to include the `quarkus-jackson` dependency (if you already use the `quarkus-jackson-jsonb` dependency this is not needed).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b07574a9589794cafb098c722b60096916ab0dcd"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NDk2NA==", "bodyText": "Let's get rid of the blank lines.", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362754964", "createdAt": "2020-01-03T09:57:54Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as following:\n+\n+[source,java]\n+----\n+public class Fruit {\n+\n+    public String name;\n+    public int price;\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, int price) {\n+        this.name = name;\n+        this.price = price;\n+    }\n+}\n+----\n+\n+And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.\n+\n+[source,java]\n+----\n+import io.smallrye.reactive.messaging.annotations.Broadcast;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+/**\n+* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n+* The result is pushed to the \"fruit-out\" stream.\n+*/\n+@ApplicationScoped\n+public class FruitProcessor {\n+\n+    private static final double CONVERSION_RATE = 0.88;\n+\n+    @Incoming(\"fruit-in\")\n+    @Outgoing(\"fruit-out\")\n+    @Broadcast\n+    public double process(Fruit fruit) {\n+        fruit.price = fruit.price * CONVERSION_RATE;\n+        return fruit;\n+    }\n+\n+}\n+----\n+\n+To do this, we will need to setup JSON serialization with JSON-B or Jackson.\n+\n+NOTE: With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`.\n+\n+=== Serializing via JSON-B\n+\n+First, you need to include the `quarkus-jsonb` dependency (if you already use the `quarkus-resteasy-jsonb` dependency this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jsonb</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jsonb;\n+\n+import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n+\n+public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+NOTE: If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer`\n+that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.\n+\n+Finally, configure your streams to use the JSON-B serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n+----\n+\n+Now, your Kafka messages will contains a JSON-B serialized representation of your Fruit pojo !\n+\n+=== Serializing via Jackson\n+\n+First, you need to include the `quarkus-jackson` dependency (if you already use the `quarkus-jackson-jsonb` dependency this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jackson</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `ObjectMapperSerializer` that can be used to serialize all pojos via Jackson,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jackson;\n+\n+import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n+\n+public class FruitDeserializer extends ObjectMapperDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+Finally, configure your streams to use the Jackson serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b07574a9589794cafb098c722b60096916ab0dcd"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NTAyNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Now, your Kafka messages will contains a Jackson serialized representation of your Fruit pojo !\n          \n          \n            \n            Now, your Kafka messages will contain a Jackson serialized representation of your Fruit pojo.", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362755024", "createdAt": "2020-01-03T09:58:06Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as following:\n+\n+[source,java]\n+----\n+public class Fruit {\n+\n+    public String name;\n+    public int price;\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, int price) {\n+        this.name = name;\n+        this.price = price;\n+    }\n+}\n+----\n+\n+And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.\n+\n+[source,java]\n+----\n+import io.smallrye.reactive.messaging.annotations.Broadcast;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+/**\n+* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n+* The result is pushed to the \"fruit-out\" stream.\n+*/\n+@ApplicationScoped\n+public class FruitProcessor {\n+\n+    private static final double CONVERSION_RATE = 0.88;\n+\n+    @Incoming(\"fruit-in\")\n+    @Outgoing(\"fruit-out\")\n+    @Broadcast\n+    public double process(Fruit fruit) {\n+        fruit.price = fruit.price * CONVERSION_RATE;\n+        return fruit;\n+    }\n+\n+}\n+----\n+\n+To do this, we will need to setup JSON serialization with JSON-B or Jackson.\n+\n+NOTE: With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`.\n+\n+=== Serializing via JSON-B\n+\n+First, you need to include the `quarkus-jsonb` dependency (if you already use the `quarkus-resteasy-jsonb` dependency this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jsonb</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jsonb;\n+\n+import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n+\n+public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+NOTE: If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer`\n+that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.\n+\n+Finally, configure your streams to use the JSON-B serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n+----\n+\n+Now, your Kafka messages will contains a JSON-B serialized representation of your Fruit pojo !\n+\n+=== Serializing via Jackson\n+\n+First, you need to include the `quarkus-jackson` dependency (if you already use the `quarkus-jackson-jsonb` dependency this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jackson</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `ObjectMapperSerializer` that can be used to serialize all pojos via Jackson,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jackson;\n+\n+import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n+\n+public class FruitDeserializer extends ObjectMapperDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+Finally, configure your streams to use the Jackson serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer\n+\n+\n+----\n+\n+Now, your Kafka messages will contains a Jackson serialized representation of your Fruit pojo !", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b07574a9589794cafb098c722b60096916ab0dcd"}, "originalPosition": 160}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bc5b4f4d39f3bf90f063d98d116dd9c7851e2fc9", "author": {"user": {"login": "loicmathieu", "name": "Lo\u00efc Mathieu"}}, "url": "https://github.com/quarkusio/quarkus/commit/bc5b4f4d39f3bf90f063d98d116dd9c7851e2fc9", "committedDate": "2020-01-03T10:28:44Z", "message": "Apply suggestions from code review\n\nCo-Authored-By: Guillaume Smet <guillaume.smet@gmail.com>"}, "afterCommit": {"oid": "788f76461826f85dddfa1e529c35a40f96bc2f2b", "author": {"user": {"login": "loicmathieu", "name": "Lo\u00efc Mathieu"}}, "url": "https://github.com/quarkusio/quarkus/commit/788f76461826f85dddfa1e529c35a40f96bc2f2b", "committedDate": "2020-01-03T11:04:01Z", "message": "Add JSON-B and Jackson serialization to the Kafka guide"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "788f76461826f85dddfa1e529c35a40f96bc2f2b", "author": {"user": {"login": "loicmathieu", "name": "Lo\u00efc Mathieu"}}, "url": "https://github.com/quarkusio/quarkus/commit/788f76461826f85dddfa1e529c35a40f96bc2f2b", "committedDate": "2020-01-03T11:04:01Z", "message": "Add JSON-B and Jackson serialization to the Kafka guide"}, "afterCommit": {"oid": "400475b22bd9e783faa7f4a788779ecf1e3dd96d", "author": {"user": {"login": "loicmathieu", "name": "Lo\u00efc Mathieu"}}, "url": "https://github.com/quarkusio/quarkus/commit/400475b22bd9e783faa7f4a788779ecf1e3dd96d", "committedDate": "2020-01-03T11:19:13Z", "message": "Add JSON-B and Jackson serialization to the Kafka guide"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4MDYyOTcx", "url": "https://github.com/quarkusio/quarkus/pull/6387#pullrequestreview-338062971", "createdAt": "2020-01-03T12:40:36Z", "commit": {"oid": "400475b22bd9e783faa7f4a788779ecf1e3dd96d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxMjo0MDozN1rOFZ_S9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxMjo0MDozN1rOFZ_S9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc5NTc2NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you want Resteasy to send JSON Server-Sent Events, you need to use the `@SseElementType` annotation to define the content type of the events,\n          \n          \n            \n            If you want RESTEasy to send JSON Server-Sent Events, you need to use the `@SseElementType` annotation to define the content type of the events,", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362795765", "createdAt": "2020-01-03T12:40:37Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,197 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deal with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as follows:\n+\n+[source,java]\n+----\n+public class Fruit {\n+\n+    public String name;\n+    public int price;\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, int price) {\n+        this.name = name;\n+        this.price = price;\n+    }\n+}\n+----\n+\n+And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.\n+\n+[source,java]\n+----\n+import io.smallrye.reactive.messaging.annotations.Broadcast;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+/**\n+* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n+* The result is pushed to the \"fruit-out\" stream.\n+*/\n+@ApplicationScoped\n+public class FruitProcessor {\n+\n+    private static final double CONVERSION_RATE = 0.88;\n+\n+    @Incoming(\"fruit-in\")\n+    @Outgoing(\"fruit-out\")\n+    @Broadcast\n+    public double process(Fruit fruit) {\n+        fruit.price = fruit.price * CONVERSION_RATE;\n+        return fruit;\n+    }\n+\n+}\n+----\n+\n+To do this, we will need to setup JSON serialization with JSON-B or Jackson.\n+\n+NOTE: With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`.\n+\n+=== Serializing via JSON-B\n+\n+First, you need to include the `quarkus-jsonb` extension (if you already use the `quarkus-resteasy-jsonb` extension, this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jsonb</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jsonb;\n+\n+import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n+\n+public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+NOTE: If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer`\n+that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.\n+\n+Finally, configure your streams to use the JSON-B serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n+----\n+\n+Now, your Kafka messages will contain a JSON-B serialized representation of your Fruit pojo.\n+\n+=== Serializing via Jackson\n+\n+First, you need to include the `quarkus-jackson` extension (if you already use the `quarkus-jackson-jsonb` extension, this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jackson</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `ObjectMapperSerializer` that can be used to serialize all pojos via Jackson,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jackson;\n+\n+import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n+\n+public class FruitDeserializer extends ObjectMapperDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+Finally, configure your streams to use the Jackson serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer\n+----\n+\n+Now, your Kafka messages will contain a Jackson serialized representation of your Fruit pojo.\n+\n+=== Sending JSON Server-Sent Events (SSE)\n+\n+If you want Resteasy to send JSON Server-Sent Events, you need to use the `@SseElementType` annotation to define the content type of the events,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "400475b22bd9e783faa7f4a788779ecf1e3dd96d"}, "originalPosition": 162}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c90d46af2eb26883e393a40a5c06fa1f3784e2b2", "author": {"user": {"login": "loicmathieu", "name": "Lo\u00efc Mathieu"}}, "url": "https://github.com/quarkusio/quarkus/commit/c90d46af2eb26883e393a40a5c06fa1f3784e2b2", "committedDate": "2020-01-03T12:55:25Z", "message": "Add JSON-B and Jackson serialization to the Kafka guide"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ab695b1cb2cde3c0ba48156a582ceeb42f8a8469", "author": {"user": {"login": "loicmathieu", "name": "Lo\u00efc Mathieu"}}, "url": "https://github.com/quarkusio/quarkus/commit/ab695b1cb2cde3c0ba48156a582ceeb42f8a8469", "committedDate": "2020-01-03T12:55:00Z", "message": "Update docs/src/main/asciidoc/kafka.adoc\n\nCo-Authored-By: Guillaume Smet <guillaume.smet@gmail.com>"}, "afterCommit": {"oid": "c90d46af2eb26883e393a40a5c06fa1f3784e2b2", "author": {"user": {"login": "loicmathieu", "name": "Lo\u00efc Mathieu"}}, "url": "https://github.com/quarkusio/quarkus/commit/c90d46af2eb26883e393a40a5c06fa1f3784e2b2", "committedDate": "2020-01-03T12:55:25Z", "message": "Add JSON-B and Jackson serialization to the Kafka guide"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4MDY5NDEz", "url": "https://github.com/quarkusio/quarkus/pull/6387#pullrequestreview-338069413", "createdAt": "2020-01-03T13:02:41Z", "commit": {"oid": "c90d46af2eb26883e393a40a5c06fa1f3784e2b2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4NDkzMTIy", "url": "https://github.com/quarkusio/quarkus/pull/6387#pullrequestreview-338493122", "createdAt": "2020-01-06T07:05:11Z", "commit": {"oid": "c90d46af2eb26883e393a40a5c06fa1f3784e2b2"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 286, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}