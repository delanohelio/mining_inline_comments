{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzMTI5OTcy", "number": 8563, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDozOTo0MVrODyGmEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMzoyMzozMVrODzuYlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzODYzNDQxOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDozOTo0MVrOGF887g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDozOTo0MVrOGF887g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg5NDcwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This is also called **dynamics instanciation** or **constructor expression**, more info can be found on the Hibernate guide:\n          \n          \n            \n            This is also called **dynamic instantiation** or **constructor expression**, more info can be found on the Hibernate guide:", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r408894702", "createdAt": "2020-04-15T14:39:41Z", "author": {"login": "FroMage"}, "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -577,6 +577,58 @@ Person.find(\"name = :name and status = :status\",\n \n Every query operation accepts passing parameters by index (`Object...`), or by name (`Map<String,Object>` or `Parameters`).\n \n+=== Query projection\n+\n+Query projection can be done with the `project(Class)` method on the `PanacheQuery` object that is returned by the `find()` methods.\n+\n+You can use it to restrict which fields will be returned by the database.\n+\n+Hibernate will use **DTO projection** and generate a SELECT clause with the attributes from the projection class.\n+This is also called **dynamics instanciation** or **constructor expression**, more info can be found on the Hibernate guide:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7541fd10219fec97939b4f35ffae3c6dc558e18f"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzODYzNTc1OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDo0MDowMFrOGF893g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMjo0MTo0OVrOGGjWPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg5NDk0Mg==", "bodyText": "Why? What happens if there are more?", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r408894942", "createdAt": "2020-04-15T14:40:00Z", "author": {"login": "FroMage"}, "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -577,6 +577,58 @@ Person.find(\"name = :name and status = :status\",\n \n Every query operation accepts passing parameters by index (`Object...`), or by name (`Map<String,Object>` or `Parameters`).\n \n+=== Query projection\n+\n+Query projection can be done with the `project(Class)` method on the `PanacheQuery` object that is returned by the `find()` methods.\n+\n+You can use it to restrict which fields will be returned by the database.\n+\n+Hibernate will use **DTO projection** and generate a SELECT clause with the attributes from the projection class.\n+This is also called **dynamics instanciation** or **constructor expression**, more info can be found on the Hibernate guide:\n+link:https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#hql-select-clause[hql select clause]\n+\n+The projection class needs to be a valid Java Bean and have a constructor that contains all its attributes, this constructor will be used to\n+instantiate the projection DTO instead of using the entity class. This must be the only constructor of the class.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7541fd10219fec97939b4f35ffae3c6dc558e18f"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMzMDA2MQ==", "bodyText": "I took the first one.\nIf there are more, we will need a way to know which one to choose to build the select clause.\nWe can do it by adding an annotation to denote the correct constructor, but I prefere to keep it simple for the moment and only allow one constructor.\nI can add a check in the code and fail if there is more than one constructor\nWe can revisit this later if needed.", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r409330061", "createdAt": "2020-04-16T07:11:37Z", "author": {"login": "loicmathieu"}, "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -577,6 +577,58 @@ Person.find(\"name = :name and status = :status\",\n \n Every query operation accepts passing parameters by index (`Object...`), or by name (`Map<String,Object>` or `Parameters`).\n \n+=== Query projection\n+\n+Query projection can be done with the `project(Class)` method on the `PanacheQuery` object that is returned by the `find()` methods.\n+\n+You can use it to restrict which fields will be returned by the database.\n+\n+Hibernate will use **DTO projection** and generate a SELECT clause with the attributes from the projection class.\n+This is also called **dynamics instanciation** or **constructor expression**, more info can be found on the Hibernate guide:\n+link:https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#hql-select-clause[hql select clause]\n+\n+The projection class needs to be a valid Java Bean and have a constructor that contains all its attributes, this constructor will be used to\n+instantiate the projection DTO instead of using the entity class. This must be the only constructor of the class.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg5NDk0Mg=="}, "originalCommit": {"oid": "7541fd10219fec97939b4f35ffae3c6dc558e18f"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUyMzc3NA==", "bodyText": "OK fine.", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r409523774", "createdAt": "2020-04-16T12:41:49Z", "author": {"login": "FroMage"}, "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -577,6 +577,58 @@ Person.find(\"name = :name and status = :status\",\n \n Every query operation accepts passing parameters by index (`Object...`), or by name (`Map<String,Object>` or `Parameters`).\n \n+=== Query projection\n+\n+Query projection can be done with the `project(Class)` method on the `PanacheQuery` object that is returned by the `find()` methods.\n+\n+You can use it to restrict which fields will be returned by the database.\n+\n+Hibernate will use **DTO projection** and generate a SELECT clause with the attributes from the projection class.\n+This is also called **dynamics instanciation** or **constructor expression**, more info can be found on the Hibernate guide:\n+link:https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#hql-select-clause[hql select clause]\n+\n+The projection class needs to be a valid Java Bean and have a constructor that contains all its attributes, this constructor will be used to\n+instantiate the projection DTO instead of using the entity class. This must be the only constructor of the class.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg5NDk0Mg=="}, "originalCommit": {"oid": "7541fd10219fec97939b4f35ffae3c6dc558e18f"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzODYzNjk3OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDo0MDoyMFrOGF8-zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMjo0MTo0MlrOGGjWAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg5NTE4Mw==", "bodyText": "Can't we turn this into a public final field?", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r408895183", "createdAt": "2020-04-15T14:40:20Z", "author": {"login": "FroMage"}, "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -577,6 +577,58 @@ Person.find(\"name = :name and status = :status\",\n \n Every query operation accepts passing parameters by index (`Object...`), or by name (`Map<String,Object>` or `Parameters`).\n \n+=== Query projection\n+\n+Query projection can be done with the `project(Class)` method on the `PanacheQuery` object that is returned by the `find()` methods.\n+\n+You can use it to restrict which fields will be returned by the database.\n+\n+Hibernate will use **DTO projection** and generate a SELECT clause with the attributes from the projection class.\n+This is also called **dynamics instanciation** or **constructor expression**, more info can be found on the Hibernate guide:\n+link:https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#hql-select-clause[hql select clause]\n+\n+The projection class needs to be a valid Java Bean and have a constructor that contains all its attributes, this constructor will be used to\n+instantiate the projection DTO instead of using the entity class. This must be the only constructor of the class.\n+\n+[source,java]\n+----\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+\n+@RegisterForReflection // <1>\n+public class PersonName {\n+    private String name;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7541fd10219fec97939b4f35ffae3c6dc558e18f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM0Mjc1MA==", "bodyText": "Hibernate documentation said that the class must be a Java Bean.\nI just tested it and it can be a POJO with public fields.\nI'll update the documentation as this is more consistent with what we do in other areas.", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r409342750", "createdAt": "2020-04-16T07:35:12Z", "author": {"login": "loicmathieu"}, "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -577,6 +577,58 @@ Person.find(\"name = :name and status = :status\",\n \n Every query operation accepts passing parameters by index (`Object...`), or by name (`Map<String,Object>` or `Parameters`).\n \n+=== Query projection\n+\n+Query projection can be done with the `project(Class)` method on the `PanacheQuery` object that is returned by the `find()` methods.\n+\n+You can use it to restrict which fields will be returned by the database.\n+\n+Hibernate will use **DTO projection** and generate a SELECT clause with the attributes from the projection class.\n+This is also called **dynamics instanciation** or **constructor expression**, more info can be found on the Hibernate guide:\n+link:https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#hql-select-clause[hql select clause]\n+\n+The projection class needs to be a valid Java Bean and have a constructor that contains all its attributes, this constructor will be used to\n+instantiate the projection DTO instead of using the entity class. This must be the only constructor of the class.\n+\n+[source,java]\n+----\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+\n+@RegisterForReflection // <1>\n+public class PersonName {\n+    private String name;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg5NTE4Mw=="}, "originalCommit": {"oid": "7541fd10219fec97939b4f35ffae3c6dc558e18f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUyMzcxNQ==", "bodyText": "Cool", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r409523715", "createdAt": "2020-04-16T12:41:42Z", "author": {"login": "FroMage"}, "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -577,6 +577,58 @@ Person.find(\"name = :name and status = :status\",\n \n Every query operation accepts passing parameters by index (`Object...`), or by name (`Map<String,Object>` or `Parameters`).\n \n+=== Query projection\n+\n+Query projection can be done with the `project(Class)` method on the `PanacheQuery` object that is returned by the `find()` methods.\n+\n+You can use it to restrict which fields will be returned by the database.\n+\n+Hibernate will use **DTO projection** and generate a SELECT clause with the attributes from the projection class.\n+This is also called **dynamics instanciation** or **constructor expression**, more info can be found on the Hibernate guide:\n+link:https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#hql-select-clause[hql select clause]\n+\n+The projection class needs to be a valid Java Bean and have a constructor that contains all its attributes, this constructor will be used to\n+instantiate the projection DTO instead of using the entity class. This must be the only constructor of the class.\n+\n+[source,java]\n+----\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+\n+@RegisterForReflection // <1>\n+public class PersonName {\n+    private String name;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg5NTE4Mw=="}, "originalCommit": {"oid": "7541fd10219fec97939b4f35ffae3c6dc558e18f"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzODY0MTQxOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDo0MToyMlrOGF9Bsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDo0MToyMlrOGF9Bsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg5NTkyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The implementation of the `project(Class)` method use constructor parameter names to build the select clause of the query,\n          \n          \n            \n            The implementation of the `project(Class)` method uses the constructor's parameter names to build the select clause of the query,", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r408895922", "createdAt": "2020-04-15T14:41:22Z", "author": {"login": "FroMage"}, "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -577,6 +577,58 @@ Person.find(\"name = :name and status = :status\",\n \n Every query operation accepts passing parameters by index (`Object...`), or by name (`Map<String,Object>` or `Parameters`).\n \n+=== Query projection\n+\n+Query projection can be done with the `project(Class)` method on the `PanacheQuery` object that is returned by the `find()` methods.\n+\n+You can use it to restrict which fields will be returned by the database.\n+\n+Hibernate will use **DTO projection** and generate a SELECT clause with the attributes from the projection class.\n+This is also called **dynamics instanciation** or **constructor expression**, more info can be found on the Hibernate guide:\n+link:https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#hql-select-clause[hql select clause]\n+\n+The projection class needs to be a valid Java Bean and have a constructor that contains all its attributes, this constructor will be used to\n+instantiate the projection DTO instead of using the entity class. This must be the only constructor of the class.\n+\n+[source,java]\n+----\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+\n+@RegisterForReflection // <1>\n+public class PersonName {\n+    private String name;\n+\n+    public PersonName(String name){ // <2>\n+        this.name = name;\n+    }\n+\n+    public String getName(){\n+        return name;\n+    }\n+\n+    public void setName(String name){\n+        this.name = name;\n+    }\n+}\n+\n+// only 'name' will be loaded from the database\n+PanacheQuery<PersonName> query = Person.find(\"status\", Status.Alive).project(PersonName.class);\n+----\n+\n+1. If you plan to deploy your application as a native executable, you must register manually the projection class for reflection.\n+2. This constructor will be used by Hibernate, it must be the only constructor in your class and have all the class attributes as parameters.\n+\n+[WARNING]\n+====\n+The implementation of the `project(Class)` method use constructor parameter names to build the select clause of the query,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7541fd10219fec97939b4f35ffae3c6dc558e18f"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzODY0Mzc0OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDo0MTo1MlrOGF9DRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDo0MTo1MlrOGF9DRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg5NjMyNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This is enabled by default if you are using the Quarkus Maven archetype, if not add the property `<maven.compiler.parameters>true</maven.compiler.parameters>` to your pom.xml.\n          \n          \n            \n            This is enabled by default if you are using the Quarkus Maven archetype. If you are not using it, add the property `<maven.compiler.parameters>true</maven.compiler.parameters>` to your pom.xml.", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r408896326", "createdAt": "2020-04-15T14:41:52Z", "author": {"login": "FroMage"}, "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -577,6 +577,58 @@ Person.find(\"name = :name and status = :status\",\n \n Every query operation accepts passing parameters by index (`Object...`), or by name (`Map<String,Object>` or `Parameters`).\n \n+=== Query projection\n+\n+Query projection can be done with the `project(Class)` method on the `PanacheQuery` object that is returned by the `find()` methods.\n+\n+You can use it to restrict which fields will be returned by the database.\n+\n+Hibernate will use **DTO projection** and generate a SELECT clause with the attributes from the projection class.\n+This is also called **dynamics instanciation** or **constructor expression**, more info can be found on the Hibernate guide:\n+link:https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#hql-select-clause[hql select clause]\n+\n+The projection class needs to be a valid Java Bean and have a constructor that contains all its attributes, this constructor will be used to\n+instantiate the projection DTO instead of using the entity class. This must be the only constructor of the class.\n+\n+[source,java]\n+----\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+\n+@RegisterForReflection // <1>\n+public class PersonName {\n+    private String name;\n+\n+    public PersonName(String name){ // <2>\n+        this.name = name;\n+    }\n+\n+    public String getName(){\n+        return name;\n+    }\n+\n+    public void setName(String name){\n+        this.name = name;\n+    }\n+}\n+\n+// only 'name' will be loaded from the database\n+PanacheQuery<PersonName> query = Person.find(\"status\", Status.Alive).project(PersonName.class);\n+----\n+\n+1. If you plan to deploy your application as a native executable, you must register manually the projection class for reflection.\n+2. This constructor will be used by Hibernate, it must be the only constructor in your class and have all the class attributes as parameters.\n+\n+[WARNING]\n+====\n+The implementation of the `project(Class)` method use constructor parameter names to build the select clause of the query,\n+so the compiler must be configured to store parameter names inside the compiled class.\n+This is enabled by default if you are using the Quarkus Maven archetype, if not add the property `<maven.compiler.parameters>true</maven.compiler.parameters>` to your pom.xml.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7541fd10219fec97939b4f35ffae3c6dc558e18f"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzODY1MDU0OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDo0MzoxOFrOGF9H1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNzo0MTowN1rOGGYgCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg5NzQ5Mw==", "bodyText": "If it updates the query (mutate) then order doesn't matter. I think what you mean is that it will create a new query. In either case order should not matter because the query copy can use settings from the original query, no?", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r408897493", "createdAt": "2020-04-15T14:43:18Z", "author": {"login": "FroMage"}, "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -577,6 +577,58 @@ Person.find(\"name = :name and status = :status\",\n \n Every query operation accepts passing parameters by index (`Object...`), or by name (`Map<String,Object>` or `Parameters`).\n \n+=== Query projection\n+\n+Query projection can be done with the `project(Class)` method on the `PanacheQuery` object that is returned by the `find()` methods.\n+\n+You can use it to restrict which fields will be returned by the database.\n+\n+Hibernate will use **DTO projection** and generate a SELECT clause with the attributes from the projection class.\n+This is also called **dynamics instanciation** or **constructor expression**, more info can be found on the Hibernate guide:\n+link:https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#hql-select-clause[hql select clause]\n+\n+The projection class needs to be a valid Java Bean and have a constructor that contains all its attributes, this constructor will be used to\n+instantiate the projection DTO instead of using the entity class. This must be the only constructor of the class.\n+\n+[source,java]\n+----\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+\n+@RegisterForReflection // <1>\n+public class PersonName {\n+    private String name;\n+\n+    public PersonName(String name){ // <2>\n+        this.name = name;\n+    }\n+\n+    public String getName(){\n+        return name;\n+    }\n+\n+    public void setName(String name){\n+        this.name = name;\n+    }\n+}\n+\n+// only 'name' will be loaded from the database\n+PanacheQuery<PersonName> query = Person.find(\"status\", Status.Alive).project(PersonName.class);\n+----\n+\n+1. If you plan to deploy your application as a native executable, you must register manually the projection class for reflection.\n+2. This constructor will be used by Hibernate, it must be the only constructor in your class and have all the class attributes as parameters.\n+\n+[WARNING]\n+====\n+The implementation of the `project(Class)` method use constructor parameter names to build the select clause of the query,\n+so the compiler must be configured to store parameter names inside the compiled class.\n+This is enabled by default if you are using the Quarkus Maven archetype, if not add the property `<maven.compiler.parameters>true</maven.compiler.parameters>` to your pom.xml.\n+====\n+\n+[WARNING]\n+====\n+Using `project(Class)` will update the JPA query, so you must use the other methods that update the query (like withLock, withHint, page, ...) after it.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7541fd10219fec97939b4f35ffae3c6dc558e18f"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM0NjA1OQ==", "bodyText": "See my next comment. I think some refactoring needs to be done to mitigate this.", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r409346059", "createdAt": "2020-04-16T07:41:07Z", "author": {"login": "loicmathieu"}, "path": "docs/src/main/asciidoc/hibernate-orm-panache.adoc", "diffHunk": "@@ -577,6 +577,58 @@ Person.find(\"name = :name and status = :status\",\n \n Every query operation accepts passing parameters by index (`Object...`), or by name (`Map<String,Object>` or `Parameters`).\n \n+=== Query projection\n+\n+Query projection can be done with the `project(Class)` method on the `PanacheQuery` object that is returned by the `find()` methods.\n+\n+You can use it to restrict which fields will be returned by the database.\n+\n+Hibernate will use **DTO projection** and generate a SELECT clause with the attributes from the projection class.\n+This is also called **dynamics instanciation** or **constructor expression**, more info can be found on the Hibernate guide:\n+link:https://docs.jboss.org/hibernate/orm/current/userguide/html_single/Hibernate_User_Guide.html#hql-select-clause[hql select clause]\n+\n+The projection class needs to be a valid Java Bean and have a constructor that contains all its attributes, this constructor will be used to\n+instantiate the projection DTO instead of using the entity class. This must be the only constructor of the class.\n+\n+[source,java]\n+----\n+import io.quarkus.runtime.annotations.RegisterForReflection;\n+\n+@RegisterForReflection // <1>\n+public class PersonName {\n+    private String name;\n+\n+    public PersonName(String name){ // <2>\n+        this.name = name;\n+    }\n+\n+    public String getName(){\n+        return name;\n+    }\n+\n+    public void setName(String name){\n+        this.name = name;\n+    }\n+}\n+\n+// only 'name' will be loaded from the database\n+PanacheQuery<PersonName> query = Person.find(\"status\", Status.Alive).project(PersonName.class);\n+----\n+\n+1. If you plan to deploy your application as a native executable, you must register manually the projection class for reflection.\n+2. This constructor will be used by Hibernate, it must be the only constructor in your class and have all the class attributes as parameters.\n+\n+[WARNING]\n+====\n+The implementation of the `project(Class)` method use constructor parameter names to build the select clause of the query,\n+so the compiler must be configured to store parameter names inside the compiled class.\n+This is enabled by default if you are using the Quarkus Maven archetype, if not add the property `<maven.compiler.parameters>true</maven.compiler.parameters>` to your pom.xml.\n+====\n+\n+[WARNING]\n+====\n+Using `project(Class)` will update the JPA query, so you must use the other methods that update the query (like withLock, withHint, page, ...) after it.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg5NzQ5Mw=="}, "originalCommit": {"oid": "7541fd10219fec97939b4f35ffae3c6dc558e18f"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzODY3MzgyOnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-orm-panache/runtime/src/main/java/io/quarkus/hibernate/orm/panache/runtime/PanacheQueryImpl.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDo0ODowNlrOGF9XTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTowMDowOFrOGIKXxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwMTQ1Mw==", "bodyText": "Huh, this is a sneaky mutation that changes the type of this query. I'm not sure this is a great idea. Why not return a new query object?", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r408901453", "createdAt": "2020-04-15T14:48:06Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-orm-panache/runtime/src/main/java/io/quarkus/hibernate/orm/panache/runtime/PanacheQueryImpl.java", "diffHunk": "@@ -36,16 +41,66 @@\n \n     private Range range;\n \n-    PanacheQueryImpl(EntityManager em, javax.persistence.Query jpaQuery, String query, Object paramsArrayOrMap) {\n+    PanacheQueryImpl(EntityManager em, String query, String sort, Object paramsArrayOrMap) {\n         this.em = em;\n-        this.jpaQuery = jpaQuery;\n         this.query = query;\n+        this.sort = sort;\n         this.paramsArrayOrMap = paramsArrayOrMap;\n+\n+        if (JpaOperations.isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            this.jpaQuery = em.createNamedQuery(namedQuery);\n+        } else {\n+            this.jpaQuery = em.createQuery(sort != null ? query + sort : query);\n+        }\n+\n+        if (paramsArrayOrMap instanceof Map)\n+            JpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        else\n+            JpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+\n         page = new Page(0, Integer.MAX_VALUE);\n     }\n \n     // Builder\n \n+    @Override\n+    public <T> PanacheQuery<T> project(Class<T> type) {\n+        if (JpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        this.jpaQuery = em.createQuery(sort != null ? select.toString() + query + sort : select.toString() + query);\n+        if (paramsArrayOrMap instanceof Map)\n+            JpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        else\n+            JpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+        return (PanacheQuery<T>) this;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7541fd10219fec97939b4f35ffae3c6dc558e18f"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM0NTgxOQ==", "bodyText": "PanacheQuery is a statefull object where you can mutate the underlying JPA query object via multiple operations (lock, hint, pagination, ...).\nSo I stick to the same principle here, projection is just another way to mutate the query before firing it to the database by adding a SELECT clause.\nI start thinking that a refactoring should be needed to implements something closer to a builder, each operation on PanacheQuery prior to retrieving the list of result should just update PanacheQuery internal state then when we get the resultList we build the JPA query.\nWith this, the order of the operation done on the query (see your previous comment) has no importance.", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r409345819", "createdAt": "2020-04-16T07:40:42Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-orm-panache/runtime/src/main/java/io/quarkus/hibernate/orm/panache/runtime/PanacheQueryImpl.java", "diffHunk": "@@ -36,16 +41,66 @@\n \n     private Range range;\n \n-    PanacheQueryImpl(EntityManager em, javax.persistence.Query jpaQuery, String query, Object paramsArrayOrMap) {\n+    PanacheQueryImpl(EntityManager em, String query, String sort, Object paramsArrayOrMap) {\n         this.em = em;\n-        this.jpaQuery = jpaQuery;\n         this.query = query;\n+        this.sort = sort;\n         this.paramsArrayOrMap = paramsArrayOrMap;\n+\n+        if (JpaOperations.isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            this.jpaQuery = em.createNamedQuery(namedQuery);\n+        } else {\n+            this.jpaQuery = em.createQuery(sort != null ? query + sort : query);\n+        }\n+\n+        if (paramsArrayOrMap instanceof Map)\n+            JpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        else\n+            JpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+\n         page = new Page(0, Integer.MAX_VALUE);\n     }\n \n     // Builder\n \n+    @Override\n+    public <T> PanacheQuery<T> project(Class<T> type) {\n+        if (JpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        this.jpaQuery = em.createQuery(sort != null ? select.toString() + query + sort : select.toString() + query);\n+        if (paramsArrayOrMap instanceof Map)\n+            JpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        else\n+            JpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+        return (PanacheQuery<T>) this;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwMTQ1Mw=="}, "originalCommit": {"oid": "7541fd10219fec97939b4f35ffae3c6dc558e18f"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTM0ODU1Mg==", "bodyText": "And this is what we did for MongoDB with Panache: we create a projection document and change the type of the query. So it's consistent!\nhttps://github.com/quarkusio/quarkus/blob/master/extensions/panache/mongodb-panache/runtime/src/main/java/io/quarkus/mongodb/panache/runtime/PanacheQueryImpl.java#L45", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r409348552", "createdAt": "2020-04-16T07:45:25Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-orm-panache/runtime/src/main/java/io/quarkus/hibernate/orm/panache/runtime/PanacheQueryImpl.java", "diffHunk": "@@ -36,16 +41,66 @@\n \n     private Range range;\n \n-    PanacheQueryImpl(EntityManager em, javax.persistence.Query jpaQuery, String query, Object paramsArrayOrMap) {\n+    PanacheQueryImpl(EntityManager em, String query, String sort, Object paramsArrayOrMap) {\n         this.em = em;\n-        this.jpaQuery = jpaQuery;\n         this.query = query;\n+        this.sort = sort;\n         this.paramsArrayOrMap = paramsArrayOrMap;\n+\n+        if (JpaOperations.isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            this.jpaQuery = em.createNamedQuery(namedQuery);\n+        } else {\n+            this.jpaQuery = em.createQuery(sort != null ? query + sort : query);\n+        }\n+\n+        if (paramsArrayOrMap instanceof Map)\n+            JpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        else\n+            JpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+\n         page = new Page(0, Integer.MAX_VALUE);\n     }\n \n     // Builder\n \n+    @Override\n+    public <T> PanacheQuery<T> project(Class<T> type) {\n+        if (JpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        this.jpaQuery = em.createQuery(sort != null ? select.toString() + query + sort : select.toString() + query);\n+        if (paramsArrayOrMap instanceof Map)\n+            JpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        else\n+            JpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+        return (PanacheQuery<T>) this;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwMTQ1Mw=="}, "originalCommit": {"oid": "7541fd10219fec97939b4f35ffae3c6dc558e18f"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUyMzU2OA==", "bodyText": "Well let me show you the problem with changing the runtime type of an object:\nPanacheQuery<Order> query = Order.find(\"name\", \"Stef\");\nPanacheQuery<OrderName> otherQuery = query.project(OrderName.class);\nOrder order = query.firstResult(); // ClassCastException\nIt's fine to mutate the state of an object, but mutating its type is generally not done.", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r409523568", "createdAt": "2020-04-16T12:41:28Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-orm-panache/runtime/src/main/java/io/quarkus/hibernate/orm/panache/runtime/PanacheQueryImpl.java", "diffHunk": "@@ -36,16 +41,66 @@\n \n     private Range range;\n \n-    PanacheQueryImpl(EntityManager em, javax.persistence.Query jpaQuery, String query, Object paramsArrayOrMap) {\n+    PanacheQueryImpl(EntityManager em, String query, String sort, Object paramsArrayOrMap) {\n         this.em = em;\n-        this.jpaQuery = jpaQuery;\n         this.query = query;\n+        this.sort = sort;\n         this.paramsArrayOrMap = paramsArrayOrMap;\n+\n+        if (JpaOperations.isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            this.jpaQuery = em.createNamedQuery(namedQuery);\n+        } else {\n+            this.jpaQuery = em.createQuery(sort != null ? query + sort : query);\n+        }\n+\n+        if (paramsArrayOrMap instanceof Map)\n+            JpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        else\n+            JpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+\n         page = new Page(0, Integer.MAX_VALUE);\n     }\n \n     // Builder\n \n+    @Override\n+    public <T> PanacheQuery<T> project(Class<T> type) {\n+        if (JpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        this.jpaQuery = em.createQuery(sort != null ? select.toString() + query + sort : select.toString() + query);\n+        if (paramsArrayOrMap instanceof Map)\n+            JpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        else\n+            JpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+        return (PanacheQuery<T>) this;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwMTQ1Mw=="}, "originalCommit": {"oid": "7541fd10219fec97939b4f35ffae3c6dc558e18f"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA5MzA0NA==", "bodyText": "I agree this is not convenient but if we create a new PanacheQuery for projection it will complexify the implementation and adds maintenance burden in case we want to copy the state of the previous query to the next. Each time we update PanacheQuery state management we will need to take care of updating the project method ...\nThe parameter type of PanacheQuery is the return type of the query, this is a component of it's state but I agree this is not very elegant.\nI'll take some time to think about this ;)", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r410093044", "createdAt": "2020-04-17T09:07:24Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-orm-panache/runtime/src/main/java/io/quarkus/hibernate/orm/panache/runtime/PanacheQueryImpl.java", "diffHunk": "@@ -36,16 +41,66 @@\n \n     private Range range;\n \n-    PanacheQueryImpl(EntityManager em, javax.persistence.Query jpaQuery, String query, Object paramsArrayOrMap) {\n+    PanacheQueryImpl(EntityManager em, String query, String sort, Object paramsArrayOrMap) {\n         this.em = em;\n-        this.jpaQuery = jpaQuery;\n         this.query = query;\n+        this.sort = sort;\n         this.paramsArrayOrMap = paramsArrayOrMap;\n+\n+        if (JpaOperations.isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            this.jpaQuery = em.createNamedQuery(namedQuery);\n+        } else {\n+            this.jpaQuery = em.createQuery(sort != null ? query + sort : query);\n+        }\n+\n+        if (paramsArrayOrMap instanceof Map)\n+            JpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        else\n+            JpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+\n         page = new Page(0, Integer.MAX_VALUE);\n     }\n \n     // Builder\n \n+    @Override\n+    public <T> PanacheQuery<T> project(Class<T> type) {\n+        if (JpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        this.jpaQuery = em.createQuery(sort != null ? select.toString() + query + sort : select.toString() + query);\n+        if (paramsArrayOrMap instanceof Map)\n+            JpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        else\n+            JpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+        return (PanacheQuery<T>) this;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwMTQ1Mw=="}, "originalCommit": {"oid": "7541fd10219fec97939b4f35ffae3c6dc558e18f"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIyNjA0MA==", "bodyText": "Just make a constructor of PanacheQueryImpl(PanacheQueryImpl) which copies the setup and it's all in one place when we add new state. Don't do that in the project method.", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r410226040", "createdAt": "2020-04-17T13:35:01Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-orm-panache/runtime/src/main/java/io/quarkus/hibernate/orm/panache/runtime/PanacheQueryImpl.java", "diffHunk": "@@ -36,16 +41,66 @@\n \n     private Range range;\n \n-    PanacheQueryImpl(EntityManager em, javax.persistence.Query jpaQuery, String query, Object paramsArrayOrMap) {\n+    PanacheQueryImpl(EntityManager em, String query, String sort, Object paramsArrayOrMap) {\n         this.em = em;\n-        this.jpaQuery = jpaQuery;\n         this.query = query;\n+        this.sort = sort;\n         this.paramsArrayOrMap = paramsArrayOrMap;\n+\n+        if (JpaOperations.isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            this.jpaQuery = em.createNamedQuery(namedQuery);\n+        } else {\n+            this.jpaQuery = em.createQuery(sort != null ? query + sort : query);\n+        }\n+\n+        if (paramsArrayOrMap instanceof Map)\n+            JpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        else\n+            JpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+\n         page = new Page(0, Integer.MAX_VALUE);\n     }\n \n     // Builder\n \n+    @Override\n+    public <T> PanacheQuery<T> project(Class<T> type) {\n+        if (JpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        this.jpaQuery = em.createQuery(sort != null ? select.toString() + query + sort : select.toString() + query);\n+        if (paramsArrayOrMap instanceof Map)\n+            JpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        else\n+            JpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+        return (PanacheQuery<T>) this;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwMTQ1Mw=="}, "originalCommit": {"oid": "7541fd10219fec97939b4f35ffae3c6dc558e18f"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMTcxNw==", "bodyText": "Good idea, I implemented it", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r411211717", "createdAt": "2020-04-20T09:00:08Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-orm-panache/runtime/src/main/java/io/quarkus/hibernate/orm/panache/runtime/PanacheQueryImpl.java", "diffHunk": "@@ -36,16 +41,66 @@\n \n     private Range range;\n \n-    PanacheQueryImpl(EntityManager em, javax.persistence.Query jpaQuery, String query, Object paramsArrayOrMap) {\n+    PanacheQueryImpl(EntityManager em, String query, String sort, Object paramsArrayOrMap) {\n         this.em = em;\n-        this.jpaQuery = jpaQuery;\n         this.query = query;\n+        this.sort = sort;\n         this.paramsArrayOrMap = paramsArrayOrMap;\n+\n+        if (JpaOperations.isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            this.jpaQuery = em.createNamedQuery(namedQuery);\n+        } else {\n+            this.jpaQuery = em.createQuery(sort != null ? query + sort : query);\n+        }\n+\n+        if (paramsArrayOrMap instanceof Map)\n+            JpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        else\n+            JpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+\n         page = new Page(0, Integer.MAX_VALUE);\n     }\n \n     // Builder\n \n+    @Override\n+    public <T> PanacheQuery<T> project(Class<T> type) {\n+        if (JpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        this.jpaQuery = em.createQuery(sort != null ? select.toString() + query + sort : select.toString() + query);\n+        if (paramsArrayOrMap instanceof Map)\n+            JpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        else\n+            JpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+        return (PanacheQuery<T>) this;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwMTQ1Mw=="}, "originalCommit": {"oid": "7541fd10219fec97939b4f35ffae3c6dc558e18f"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTYyNTg1OnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-orm-panache/runtime/src/main/java/io/quarkus/hibernate/orm/panache/runtime/PanacheQueryImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMzoyMDo0NlrOGIUGjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0NDowN1rOGIYFpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM3MTE1MA==", "bodyText": "I think this method should be called createQueryNoPaging or something like that.", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r411371150", "createdAt": "2020-04-20T13:20:46Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-orm-panache/runtime/src/main/java/io/quarkus/hibernate/orm/panache/runtime/PanacheQueryImpl.java", "diffHunk": "@@ -243,5 +311,33 @@ private void manageOffsets(int maxResults) {\n             options.setFirstRow(null);\n         }\n         jpaQuery.setMaxResults(maxResults);\n+\n+        return jpaQuery;\n+    }\n+\n+    private Query innerCreateQuery() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab2b351280bff217e72959cc3a5d865f37c7989b"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNjQ1Mg==", "bodyText": "createBaseQuery reads better no ?", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r411436452", "createdAt": "2020-04-20T14:44:07Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-orm-panache/runtime/src/main/java/io/quarkus/hibernate/orm/panache/runtime/PanacheQueryImpl.java", "diffHunk": "@@ -243,5 +311,33 @@ private void manageOffsets(int maxResults) {\n             options.setFirstRow(null);\n         }\n         jpaQuery.setMaxResults(maxResults);\n+\n+        return jpaQuery;\n+    }\n+\n+    private Query innerCreateQuery() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM3MTE1MA=="}, "originalCommit": {"oid": "ab2b351280bff217e72959cc3a5d865f37c7989b"}, "originalPosition": 217}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTYzMTM5OnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-orm-panache/runtime/src/main/java/io/quarkus/hibernate/orm/panache/runtime/PanacheQueryImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMzoyMTo0OVrOGIUJuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0Mzo0MVrOGIYEPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM3MTk2Mw==", "bodyText": "this name feels wrong, isn't it an order-by clause? How about orderByPart?", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r411371963", "createdAt": "2020-04-20T13:21:49Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-orm-panache/runtime/src/main/java/io/quarkus/hibernate/orm/panache/runtime/PanacheQueryImpl.java", "diffHunk": "@@ -24,25 +27,74 @@\n     private static final Pattern SELECT_PATTERN = Pattern.compile(\"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?[^\\\\s]+)\\\\s+([^\\\\s]+.*)$\",\n             Pattern.CASE_INSENSITIVE);\n \n-    private Query jpaQuery;\n     private Object paramsArrayOrMap;\n     private String query;\n+    private String countQuery;\n+    private String sort;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab2b351280bff217e72959cc3a5d865f37c7989b"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNjA5NQ==", "bodyText": "Yes simply orderBy feels better", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r411436095", "createdAt": "2020-04-20T14:43:41Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-orm-panache/runtime/src/main/java/io/quarkus/hibernate/orm/panache/runtime/PanacheQueryImpl.java", "diffHunk": "@@ -24,25 +27,74 @@\n     private static final Pattern SELECT_PATTERN = Pattern.compile(\"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?[^\\\\s]+)\\\\s+([^\\\\s]+.*)$\",\n             Pattern.CASE_INSENSITIVE);\n \n-    private Query jpaQuery;\n     private Object paramsArrayOrMap;\n     private String query;\n+    private String countQuery;\n+    private String sort;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM3MTk2Mw=="}, "originalCommit": {"oid": "ab2b351280bff217e72959cc3a5d865f37c7989b"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTYzOTI3OnYy", "diffSide": "RIGHT", "path": "integration-tests/hibernate-orm-panache/src/main/java/io/quarkus/it/panache/TestEndpoint.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMzoyMzozMVrOGIUOVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDo0NTowN1rOGIYIVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM3MzE0MA==", "bodyText": "Can we add some tests with queries and parameters too please?", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r411373140", "createdAt": "2020-04-20T13:23:31Z", "author": {"login": "FroMage"}, "path": "integration-tests/hibernate-orm-panache/src/main/java/io/quarkus/it/panache/TestEndpoint.java", "diffHunk": "@@ -1077,6 +1077,20 @@ public String testModel2() {\n         return \"OK\";\n     }\n \n+    @GET\n+    @Path(\"projection\")\n+    @Transactional\n+    public String testProjection() {\n+        Assertions.assertEquals(1, Person.count());\n+\n+        PersonName person = Person.findAll().project(PersonName.class).firstResult();\n+        Assertions.assertEquals(\"2\", person.name);\n+\n+        Assertions.assertEquals(1, Person.findAll().project(PersonName.class).count());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab2b351280bff217e72959cc3a5d865f37c7989b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzNzE0MQ==", "bodyText": "I agree it misses some tests :)", "url": "https://github.com/quarkusio/quarkus/pull/8563#discussion_r411437141", "createdAt": "2020-04-20T14:45:07Z", "author": {"login": "loicmathieu"}, "path": "integration-tests/hibernate-orm-panache/src/main/java/io/quarkus/it/panache/TestEndpoint.java", "diffHunk": "@@ -1077,6 +1077,20 @@ public String testModel2() {\n         return \"OK\";\n     }\n \n+    @GET\n+    @Path(\"projection\")\n+    @Transactional\n+    public String testProjection() {\n+        Assertions.assertEquals(1, Person.count());\n+\n+        PersonName person = Person.findAll().project(PersonName.class).firstResult();\n+        Assertions.assertEquals(\"2\", person.name);\n+\n+        Assertions.assertEquals(1, Person.findAll().project(PersonName.class).count());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM3MzE0MA=="}, "originalCommit": {"oid": "ab2b351280bff217e72959cc3a5d865f37c7989b"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3492, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}