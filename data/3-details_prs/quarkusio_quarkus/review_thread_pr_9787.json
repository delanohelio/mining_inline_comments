{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3ODEyOTIx", "number": 9787, "reviewThreads": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMzoyNTozNVrOECju5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToyNzo1N1rOED8Iow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTE4MDU0OnYy", "diffSide": "RIGHT", "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionsManager.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMzoyNTozNVrOGfFlsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNDo0NTozN1rOGgh_Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI1MDYwOQ==", "bodyText": "Do they have to be Extension or the AppArtifactKey is enough? Also, perhaps it would be nice to use Collection instead", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r435250609", "createdAt": "2020-06-04T13:25:35Z", "author": {"login": "gastaldi"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionsManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.devtools.project.extensions;\n+\n+import static io.quarkus.devtools.project.extensions.Extensions.equalsIgnoringVersions;\n+\n+import io.quarkus.dependencies.Extension;\n+import io.quarkus.devtools.project.BuildTool;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * This interface defines a high level way of managing (read/write) extensions in any QuarkusProject\n+ */\n+public interface ExtensionsManager {\n+\n+    /**\n+     * @return the {@link BuildTool} of this extension manager\n+     */\n+    BuildTool getBuildTool();\n+\n+    /**\n+     * Read the build file(s) to get the list of extensions installed in this Quarkus project.\n+     *\n+     * @return The list of extensions installed in the project build file(s).\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    List<Extension> read() throws IOException;\n+\n+    /**\n+     * Read build file(s) to check if an extension is installed in this Quarkus project.\n+     *\n+     * @param e the extensions to check\n+     * @return true if it's installed\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    default boolean hasExtension(Extension e) throws IOException {\n+        return read().stream().anyMatch(i -> equalsIgnoringVersions(i, e));\n+    }\n+\n+    /**\n+     * Check that the Quarkus Platform bom is defined in the project.\n+     * The Quarkus Platform Bom role is to define version to use for Quarkus extensions.\n+     *\n+     * @return true if it's defined, false else\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    boolean hasQuarkusPlatformBom() throws IOException;\n+\n+    /**\n+     * This is going to add all the specified extensions to the project build file(s).\n+     *\n+     * Extensions which are already installed are ignored.\n+     *\n+     * @param extensions the list of extensions to add\n+     * @return the number of added extensions (excluding already installed)\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    int add(List<Extension> extensions) throws IOException;\n+\n+    /**\n+     * This is going to remove all the specified extensions from the project build file(s).\n+     *\n+     * This is ignoring the {@link Extension} version\n+     *\n+     * @param extensions the set of extensions to remove\n+     * @return the number of removed extensions (excluding already not installed)\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    int remove(Set<Extension> extensions) throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "256650b5f9fb70ea10c1088e6d37f29f722b0bdc"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI3MDY2NQ==", "bodyText": "Note that I renamed the different methods since your comment (install, getInstalled, uninstall..), I wanted to do it before to push, but I rushed a bit and forgot..\n@gastaldi this is a good question, TBH I am not sure, what I think is important is to make sure that the input is well formatted, and not just some random string (that are resolved) like we get it the commands. At the end, for install, we need either the GA or the GAV (if the extension is not managed) and for uninstall just the GA, for getInstalled the GAV\nRegarding Set or Collection, it's going to be converted to a Set anyway to remove duplicates..", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r435270665", "createdAt": "2020-06-04T13:48:29Z", "author": {"login": "ia3andy"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionsManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.devtools.project.extensions;\n+\n+import static io.quarkus.devtools.project.extensions.Extensions.equalsIgnoringVersions;\n+\n+import io.quarkus.dependencies.Extension;\n+import io.quarkus.devtools.project.BuildTool;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * This interface defines a high level way of managing (read/write) extensions in any QuarkusProject\n+ */\n+public interface ExtensionsManager {\n+\n+    /**\n+     * @return the {@link BuildTool} of this extension manager\n+     */\n+    BuildTool getBuildTool();\n+\n+    /**\n+     * Read the build file(s) to get the list of extensions installed in this Quarkus project.\n+     *\n+     * @return The list of extensions installed in the project build file(s).\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    List<Extension> read() throws IOException;\n+\n+    /**\n+     * Read build file(s) to check if an extension is installed in this Quarkus project.\n+     *\n+     * @param e the extensions to check\n+     * @return true if it's installed\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    default boolean hasExtension(Extension e) throws IOException {\n+        return read().stream().anyMatch(i -> equalsIgnoringVersions(i, e));\n+    }\n+\n+    /**\n+     * Check that the Quarkus Platform bom is defined in the project.\n+     * The Quarkus Platform Bom role is to define version to use for Quarkus extensions.\n+     *\n+     * @return true if it's defined, false else\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    boolean hasQuarkusPlatformBom() throws IOException;\n+\n+    /**\n+     * This is going to add all the specified extensions to the project build file(s).\n+     *\n+     * Extensions which are already installed are ignored.\n+     *\n+     * @param extensions the list of extensions to add\n+     * @return the number of added extensions (excluding already installed)\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    int add(List<Extension> extensions) throws IOException;\n+\n+    /**\n+     * This is going to remove all the specified extensions from the project build file(s).\n+     *\n+     * This is ignoring the {@link Extension} version\n+     *\n+     * @param extensions the set of extensions to remove\n+     * @return the number of removed extensions (excluding already not installed)\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    int remove(Set<Extension> extensions) throws IOException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI1MDYwOQ=="}, "originalCommit": {"oid": "256650b5f9fb70ea10c1088e6d37f29f722b0bdc"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI3NDA4MQ==", "bodyText": "BTW, even if the extension is present in the platform, a user should still be able to override its version.", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r435274081", "createdAt": "2020-06-04T13:51:50Z", "author": {"login": "aloubyansky"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionsManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.devtools.project.extensions;\n+\n+import static io.quarkus.devtools.project.extensions.Extensions.equalsIgnoringVersions;\n+\n+import io.quarkus.dependencies.Extension;\n+import io.quarkus.devtools.project.BuildTool;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * This interface defines a high level way of managing (read/write) extensions in any QuarkusProject\n+ */\n+public interface ExtensionsManager {\n+\n+    /**\n+     * @return the {@link BuildTool} of this extension manager\n+     */\n+    BuildTool getBuildTool();\n+\n+    /**\n+     * Read the build file(s) to get the list of extensions installed in this Quarkus project.\n+     *\n+     * @return The list of extensions installed in the project build file(s).\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    List<Extension> read() throws IOException;\n+\n+    /**\n+     * Read build file(s) to check if an extension is installed in this Quarkus project.\n+     *\n+     * @param e the extensions to check\n+     * @return true if it's installed\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    default boolean hasExtension(Extension e) throws IOException {\n+        return read().stream().anyMatch(i -> equalsIgnoringVersions(i, e));\n+    }\n+\n+    /**\n+     * Check that the Quarkus Platform bom is defined in the project.\n+     * The Quarkus Platform Bom role is to define version to use for Quarkus extensions.\n+     *\n+     * @return true if it's defined, false else\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    boolean hasQuarkusPlatformBom() throws IOException;\n+\n+    /**\n+     * This is going to add all the specified extensions to the project build file(s).\n+     *\n+     * Extensions which are already installed are ignored.\n+     *\n+     * @param extensions the list of extensions to add\n+     * @return the number of added extensions (excluding already installed)\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    int add(List<Extension> extensions) throws IOException;\n+\n+    /**\n+     * This is going to remove all the specified extensions from the project build file(s).\n+     *\n+     * This is ignoring the {@link Extension} version\n+     *\n+     * @param extensions the set of extensions to remove\n+     * @return the number of removed extensions (excluding already not installed)\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    int remove(Set<Extension> extensions) throws IOException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI1MDYwOQ=="}, "originalCommit": {"oid": "256650b5f9fb70ea10c1088e6d37f29f722b0bdc"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4MDIzOQ==", "bodyText": "@aloubyansky I am not 100% sure, but I think we said that since it's not a \"recommended\" action, we would advise the user to do it manually?\nA possible middle ground would be to when the specified version is different from the platform one, we add it, but show a warning?", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r435280239", "createdAt": "2020-06-04T13:59:55Z", "author": {"login": "ia3andy"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionsManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.devtools.project.extensions;\n+\n+import static io.quarkus.devtools.project.extensions.Extensions.equalsIgnoringVersions;\n+\n+import io.quarkus.dependencies.Extension;\n+import io.quarkus.devtools.project.BuildTool;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * This interface defines a high level way of managing (read/write) extensions in any QuarkusProject\n+ */\n+public interface ExtensionsManager {\n+\n+    /**\n+     * @return the {@link BuildTool} of this extension manager\n+     */\n+    BuildTool getBuildTool();\n+\n+    /**\n+     * Read the build file(s) to get the list of extensions installed in this Quarkus project.\n+     *\n+     * @return The list of extensions installed in the project build file(s).\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    List<Extension> read() throws IOException;\n+\n+    /**\n+     * Read build file(s) to check if an extension is installed in this Quarkus project.\n+     *\n+     * @param e the extensions to check\n+     * @return true if it's installed\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    default boolean hasExtension(Extension e) throws IOException {\n+        return read().stream().anyMatch(i -> equalsIgnoringVersions(i, e));\n+    }\n+\n+    /**\n+     * Check that the Quarkus Platform bom is defined in the project.\n+     * The Quarkus Platform Bom role is to define version to use for Quarkus extensions.\n+     *\n+     * @return true if it's defined, false else\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    boolean hasQuarkusPlatformBom() throws IOException;\n+\n+    /**\n+     * This is going to add all the specified extensions to the project build file(s).\n+     *\n+     * Extensions which are already installed are ignored.\n+     *\n+     * @param extensions the list of extensions to add\n+     * @return the number of added extensions (excluding already installed)\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    int add(List<Extension> extensions) throws IOException;\n+\n+    /**\n+     * This is going to remove all the specified extensions from the project build file(s).\n+     *\n+     * This is ignoring the {@link Extension} version\n+     *\n+     * @param extensions the set of extensions to remove\n+     * @return the number of removed extensions (excluding already not installed)\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    int remove(Set<Extension> extensions) throws IOException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI1MDYwOQ=="}, "originalCommit": {"oid": "256650b5f9fb70ea10c1088e6d37f29f722b0bdc"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMwMDE3Mg==", "bodyText": "I don't think it costs us anything to respect the version choice.", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r435300172", "createdAt": "2020-06-04T14:25:49Z", "author": {"login": "aloubyansky"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionsManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.devtools.project.extensions;\n+\n+import static io.quarkus.devtools.project.extensions.Extensions.equalsIgnoringVersions;\n+\n+import io.quarkus.dependencies.Extension;\n+import io.quarkus.devtools.project.BuildTool;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * This interface defines a high level way of managing (read/write) extensions in any QuarkusProject\n+ */\n+public interface ExtensionsManager {\n+\n+    /**\n+     * @return the {@link BuildTool} of this extension manager\n+     */\n+    BuildTool getBuildTool();\n+\n+    /**\n+     * Read the build file(s) to get the list of extensions installed in this Quarkus project.\n+     *\n+     * @return The list of extensions installed in the project build file(s).\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    List<Extension> read() throws IOException;\n+\n+    /**\n+     * Read build file(s) to check if an extension is installed in this Quarkus project.\n+     *\n+     * @param e the extensions to check\n+     * @return true if it's installed\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    default boolean hasExtension(Extension e) throws IOException {\n+        return read().stream().anyMatch(i -> equalsIgnoringVersions(i, e));\n+    }\n+\n+    /**\n+     * Check that the Quarkus Platform bom is defined in the project.\n+     * The Quarkus Platform Bom role is to define version to use for Quarkus extensions.\n+     *\n+     * @return true if it's defined, false else\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    boolean hasQuarkusPlatformBom() throws IOException;\n+\n+    /**\n+     * This is going to add all the specified extensions to the project build file(s).\n+     *\n+     * Extensions which are already installed are ignored.\n+     *\n+     * @param extensions the list of extensions to add\n+     * @return the number of added extensions (excluding already installed)\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    int add(List<Extension> extensions) throws IOException;\n+\n+    /**\n+     * This is going to remove all the specified extensions from the project build file(s).\n+     *\n+     * This is ignoring the {@link Extension} version\n+     *\n+     * @param extensions the set of extensions to remove\n+     * @return the number of removed extensions (excluding already not installed)\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    int remove(Set<Extension> extensions) throws IOException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI1MDYwOQ=="}, "originalCommit": {"oid": "256650b5f9fb70ea10c1088e6d37f29f722b0bdc"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MzgyNQ==", "bodyText": "it is recommended to use a specific version when that is what is needed for the users app.\nThus if user are being explicit we should carry that information through the system to honor it.", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r435763825", "createdAt": "2020-06-05T08:19:49Z", "author": {"login": "maxandersen"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionsManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.devtools.project.extensions;\n+\n+import static io.quarkus.devtools.project.extensions.Extensions.equalsIgnoringVersions;\n+\n+import io.quarkus.dependencies.Extension;\n+import io.quarkus.devtools.project.BuildTool;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * This interface defines a high level way of managing (read/write) extensions in any QuarkusProject\n+ */\n+public interface ExtensionsManager {\n+\n+    /**\n+     * @return the {@link BuildTool} of this extension manager\n+     */\n+    BuildTool getBuildTool();\n+\n+    /**\n+     * Read the build file(s) to get the list of extensions installed in this Quarkus project.\n+     *\n+     * @return The list of extensions installed in the project build file(s).\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    List<Extension> read() throws IOException;\n+\n+    /**\n+     * Read build file(s) to check if an extension is installed in this Quarkus project.\n+     *\n+     * @param e the extensions to check\n+     * @return true if it's installed\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    default boolean hasExtension(Extension e) throws IOException {\n+        return read().stream().anyMatch(i -> equalsIgnoringVersions(i, e));\n+    }\n+\n+    /**\n+     * Check that the Quarkus Platform bom is defined in the project.\n+     * The Quarkus Platform Bom role is to define version to use for Quarkus extensions.\n+     *\n+     * @return true if it's defined, false else\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    boolean hasQuarkusPlatformBom() throws IOException;\n+\n+    /**\n+     * This is going to add all the specified extensions to the project build file(s).\n+     *\n+     * Extensions which are already installed are ignored.\n+     *\n+     * @param extensions the list of extensions to add\n+     * @return the number of added extensions (excluding already installed)\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    int add(List<Extension> extensions) throws IOException;\n+\n+    /**\n+     * This is going to remove all the specified extensions from the project build file(s).\n+     *\n+     * This is ignoring the {@link Extension} version\n+     *\n+     * @param extensions the set of extensions to remove\n+     * @return the number of removed extensions (excluding already not installed)\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    int remove(Set<Extension> extensions) throws IOException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI1MDYwOQ=="}, "originalCommit": {"oid": "256650b5f9fb70ea10c1088e6d37f29f722b0bdc"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc2NDQ2Ng==", "bodyText": "ok user version is now taken into account and I used AppArtifactKey", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r436764466", "createdAt": "2020-06-08T14:45:37Z", "author": {"login": "ia3andy"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionsManager.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.devtools.project.extensions;\n+\n+import static io.quarkus.devtools.project.extensions.Extensions.equalsIgnoringVersions;\n+\n+import io.quarkus.dependencies.Extension;\n+import io.quarkus.devtools.project.BuildTool;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * This interface defines a high level way of managing (read/write) extensions in any QuarkusProject\n+ */\n+public interface ExtensionsManager {\n+\n+    /**\n+     * @return the {@link BuildTool} of this extension manager\n+     */\n+    BuildTool getBuildTool();\n+\n+    /**\n+     * Read the build file(s) to get the list of extensions installed in this Quarkus project.\n+     *\n+     * @return The list of extensions installed in the project build file(s).\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    List<Extension> read() throws IOException;\n+\n+    /**\n+     * Read build file(s) to check if an extension is installed in this Quarkus project.\n+     *\n+     * @param e the extensions to check\n+     * @return true if it's installed\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    default boolean hasExtension(Extension e) throws IOException {\n+        return read().stream().anyMatch(i -> equalsIgnoringVersions(i, e));\n+    }\n+\n+    /**\n+     * Check that the Quarkus Platform bom is defined in the project.\n+     * The Quarkus Platform Bom role is to define version to use for Quarkus extensions.\n+     *\n+     * @return true if it's defined, false else\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    boolean hasQuarkusPlatformBom() throws IOException;\n+\n+    /**\n+     * This is going to add all the specified extensions to the project build file(s).\n+     *\n+     * Extensions which are already installed are ignored.\n+     *\n+     * @param extensions the list of extensions to add\n+     * @return the number of added extensions (excluding already installed)\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    int add(List<Extension> extensions) throws IOException;\n+\n+    /**\n+     * This is going to remove all the specified extensions from the project build file(s).\n+     *\n+     * This is ignoring the {@link Extension} version\n+     *\n+     * @param extensions the set of extensions to remove\n+     * @return the number of removed extensions (excluding already not installed)\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    int remove(Set<Extension> extensions) throws IOException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI1MDYwOQ=="}, "originalCommit": {"oid": "256650b5f9fb70ea10c1088e6d37f29f722b0bdc"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTI5MzU1OnYy", "diffSide": "LEFT", "path": "devtools/maven/src/main/java/io/quarkus/maven/CreateProjectMojo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMzo0Njo0OVrOGfGtEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMzo1MDoxMVrOGfG65w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI2ODg4Mw==", "bodyText": "Why remove the ability to add extensions when you create a project?\nI find the feature quite useful.", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r435268883", "createdAt": "2020-06-04T13:46:49Z", "author": {"login": "stalep"}, "path": "devtools/maven/src/main/java/io/quarkus/maven/CreateProjectMojo.java", "diffHunk": "@@ -214,11 +212,6 @@ public void execute() throws MojoExecutionException {\n             success = createProject.execute().isSuccess();\n \n             File createdDependenciesBuildFile = new File(projectRoot, buildToolEnum.getDependenciesFile());\n-            if (success) {\n-                success = new AddExtensions(QuarkusProject.of(projectFolderPath, platform, buildToolEnum))\n-                        .extensions(extensions).execute()\n-                        .isSuccess();\n-            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d4b45514ef8b3b1fb8833f7a782870c28c9aa7a"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI3MjQyMw==", "bodyText": "@stalep it's done directly from the create command (no need to call two separate commands)", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r435272423", "createdAt": "2020-06-04T13:50:11Z", "author": {"login": "ia3andy"}, "path": "devtools/maven/src/main/java/io/quarkus/maven/CreateProjectMojo.java", "diffHunk": "@@ -214,11 +212,6 @@ public void execute() throws MojoExecutionException {\n             success = createProject.execute().isSuccess();\n \n             File createdDependenciesBuildFile = new File(projectRoot, buildToolEnum.getDependenciesFile());\n-            if (success) {\n-                success = new AddExtensions(QuarkusProject.of(projectFolderPath, platform, buildToolEnum))\n-                        .extensions(extensions).execute()\n-                        .isSuccess();\n-            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI2ODg4Mw=="}, "originalCommit": {"oid": "9d4b45514ef8b3b1fb8833f7a782870c28c9aa7a"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDM3MTE4OnYy", "diffSide": "RIGHT", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/GradleBuildFileFromConnector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwODoyMTo1MlrOGfk_EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxMjo1NDoxMFrOGgcNiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2NTAwOQ==", "bodyText": "remove if it should be ignored.", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r435765009", "createdAt": "2020-06-05T08:21:52Z", "author": {"login": "maxandersen"}, "path": "devtools/gradle/src/main/java/io/quarkus/gradle/GradleBuildFileFromConnector.java", "diffHunk": "@@ -13,33 +14,35 @@\n import org.gradle.tooling.model.eclipse.EclipseExternalDependency;\n import org.gradle.tooling.model.eclipse.EclipseProject;\n \n-import io.quarkus.devtools.buildfile.GradleBuildFile;\n-import io.quarkus.devtools.writer.ProjectWriter;\n+import io.quarkus.devtools.project.buildfile.AbstractGradleBuildFile;\n+import io.quarkus.platform.descriptor.QuarkusPlatformDescriptor;\n \n-public class GradleBuildFileFromConnector extends GradleBuildFile {\n+public class GradleBuildFileFromConnector extends AbstractGradleBuildFile {\n \n     private List<Dependency> dependencies = null;\n \n-    public GradleBuildFileFromConnector(ProjectWriter writer) {\n-        super(writer);\n-        // we need to initialize here since there is no other single point of entry\n+    public GradleBuildFileFromConnector(final Path projectFolderPath, final QuarkusPlatformDescriptor platformDescriptor) {\n+        super(projectFolderPath, platformDescriptor);\n+    }\n+\n+    public GradleBuildFileFromConnector(Path projectFolderPath, QuarkusPlatformDescriptor platformDescriptor,\n+            Path rootProjectPath) {\n+        super(projectFolderPath, platformDescriptor, rootProjectPath);\n     }\n \n     @Override\n     public List<Dependency> getDependencies() throws IOException {\n         if (dependencies == null) {\n             EclipseProject eclipseProject = null;\n             if (getBuildContent() != null) {\n-                if (getWriter().hasFile()) {\n-                    try {\n-                        ProjectConnection connection = GradleConnector.newConnector()\n-                                .forProjectDirectory(getWriter().getProjectFolder())\n-                                .connect();\n-                        eclipseProject = connection.getModel(EclipseProject.class);\n-                    } catch (BuildException e) {\n-                        // ignore this error.\n-                        e.printStackTrace();\n-                    }\n+                try {\n+                    ProjectConnection connection = GradleConnector.newConnector()\n+                            .forProjectDirectory(getProjectFolderPath().toFile())\n+                            .connect();\n+                    eclipseProject = connection.getModel(EclipseProject.class);\n+                } catch (BuildException e) {\n+                    // ignore this error.\n+                    e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81aca5ca6f82bb62b7ba94a472c081e3f170ccb1"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY2OTgzMw==", "bodyText": "@maxandersen this is actually existing code, because of too much diff, git won't detect that it's the same file.", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r436669833", "createdAt": "2020-06-08T12:54:10Z", "author": {"login": "ia3andy"}, "path": "devtools/gradle/src/main/java/io/quarkus/gradle/GradleBuildFileFromConnector.java", "diffHunk": "@@ -13,33 +14,35 @@\n import org.gradle.tooling.model.eclipse.EclipseExternalDependency;\n import org.gradle.tooling.model.eclipse.EclipseProject;\n \n-import io.quarkus.devtools.buildfile.GradleBuildFile;\n-import io.quarkus.devtools.writer.ProjectWriter;\n+import io.quarkus.devtools.project.buildfile.AbstractGradleBuildFile;\n+import io.quarkus.platform.descriptor.QuarkusPlatformDescriptor;\n \n-public class GradleBuildFileFromConnector extends GradleBuildFile {\n+public class GradleBuildFileFromConnector extends AbstractGradleBuildFile {\n \n     private List<Dependency> dependencies = null;\n \n-    public GradleBuildFileFromConnector(ProjectWriter writer) {\n-        super(writer);\n-        // we need to initialize here since there is no other single point of entry\n+    public GradleBuildFileFromConnector(final Path projectFolderPath, final QuarkusPlatformDescriptor platformDescriptor) {\n+        super(projectFolderPath, platformDescriptor);\n+    }\n+\n+    public GradleBuildFileFromConnector(Path projectFolderPath, QuarkusPlatformDescriptor platformDescriptor,\n+            Path rootProjectPath) {\n+        super(projectFolderPath, platformDescriptor, rootProjectPath);\n     }\n \n     @Override\n     public List<Dependency> getDependencies() throws IOException {\n         if (dependencies == null) {\n             EclipseProject eclipseProject = null;\n             if (getBuildContent() != null) {\n-                if (getWriter().hasFile()) {\n-                    try {\n-                        ProjectConnection connection = GradleConnector.newConnector()\n-                                .forProjectDirectory(getWriter().getProjectFolder())\n-                                .connect();\n-                        eclipseProject = connection.getModel(EclipseProject.class);\n-                    } catch (BuildException e) {\n-                        // ignore this error.\n-                        e.printStackTrace();\n-                    }\n+                try {\n+                    ProjectConnection connection = GradleConnector.newConnector()\n+                            .forProjectDirectory(getProjectFolderPath().toFile())\n+                            .connect();\n+                    eclipseProject = connection.getModel(EclipseProject.class);\n+                } catch (BuildException e) {\n+                    // ignore this error.\n+                    e.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2NTAwOQ=="}, "originalCommit": {"oid": "81aca5ca6f82bb62b7ba94a472c081e3f170ccb1"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDM4NjA3OnYy", "diffSide": "RIGHT", "path": "devtools/gradle/src/main/java/io/quarkus/gradle/tasks/QuarkusPlatformTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwODoyNjoxN1rOGflIWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxODoxMjo0M1rOGgqQCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2NzM4NA==", "bodyText": "this code could be more readable to put getProject().getRootProject().getProjectDir()  in var.", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r435767384", "createdAt": "2020-06-05T08:26:17Z", "author": {"login": "maxandersen"}, "path": "devtools/gradle/src/main/java/io/quarkus/gradle/tasks/QuarkusPlatformTask.java", "diffHunk": "@@ -66,12 +65,11 @@ protected QuarkusPlatformDescriptor platformDescriptor() {\n     }\n \n     @Internal\n-    protected GradleBuildFile getGradleBuildFile() {\n-        final ProjectWriter writer = new FileProjectWriter(getProject().getProjectDir());\n+    protected BuildFile getGradleBuildFile() {\n         return getProject().getParent() == null\n-                ? new GradleBuildFile(writer)\n-                : new GradleBuildFile(writer,\n-                        new FileProjectWriter(getProject().getRootProject().getProjectDir()));\n+                ? new GradleBuildFileFromConnector(getProject().getProjectDir().toPath(), platformDescriptor())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81aca5ca6f82bb62b7ba94a472c081e3f170ccb1"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg5OTg0OA==", "bodyText": "Yeah that's better indeed!", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r436899848", "createdAt": "2020-06-08T18:12:43Z", "author": {"login": "ia3andy"}, "path": "devtools/gradle/src/main/java/io/quarkus/gradle/tasks/QuarkusPlatformTask.java", "diffHunk": "@@ -66,12 +65,11 @@ protected QuarkusPlatformDescriptor platformDescriptor() {\n     }\n \n     @Internal\n-    protected GradleBuildFile getGradleBuildFile() {\n-        final ProjectWriter writer = new FileProjectWriter(getProject().getProjectDir());\n+    protected BuildFile getGradleBuildFile() {\n         return getProject().getParent() == null\n-                ? new GradleBuildFile(writer)\n-                : new GradleBuildFile(writer,\n-                        new FileProjectWriter(getProject().getRootProject().getProjectDir()));\n+                ? new GradleBuildFileFromConnector(getProject().getProjectDir().toPath(), platformDescriptor())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2NzM4NA=="}, "originalCommit": {"oid": "81aca5ca6f82bb62b7ba94a472c081e3f170ccb1"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDQwOTA1OnYy", "diffSide": "RIGHT", "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/commands/handlers/QuarkusCommandHandlers.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwODozMjo1NlrOGflW8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNDo0NTo1OVrOGgiAUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3MTEyMQ==", "bodyText": "why the change of order in the signature here ?", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r435771121", "createdAt": "2020-06-05T08:32:56Z", "author": {"login": "maxandersen"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/commands/handlers/QuarkusCommandHandlers.java", "diffHunk": "@@ -11,111 +16,86 @@\n import java.util.regex.PatternSyntaxException;\n import java.util.stream.Collectors;\n \n-/**\n- * This class is thread-safe. It extracts extensions to be added to the project from an instance of\n- * {@link QuarkusCommandInvocation}.\n- */\n-public class AddExtensionsCommandHandler implements QuarkusCommand {\n-\n-    final static Printer PRINTER = new Printer();\n-\n-    @Override\n-    public QuarkusCommandOutcome execute(QuarkusCommandInvocation invocation) throws QuarkusCommandException {\n-\n-        final Set<String> extensions = invocation.getValue(AddExtensions.EXTENSIONS, Collections.emptySet());\n-        if (extensions.isEmpty()) {\n-            return QuarkusCommandOutcome.success().setValue(AddExtensions.OUTCOME_UPDATED, false);\n-        }\n-\n-        boolean updated = false;\n-        boolean success = true;\n+final class QuarkusCommandHandlers {\n \n-        final List<Extension> registry = invocation.getPlatformDescriptor().getExtensions();\n+    private QuarkusCommandHandlers() {\n+    }\n \n-        final BuildFile buildFile = invocation.getBuildFile();\n-        try {\n-            for (String query : extensions) {\n-                if (query.contains(\":\")) {\n-                    // GAV case.\n-                    updated = buildFile.addExtensionAsGAV(query) || updated;\n-                } else {\n-                    SelectionResult result = select(query, registry, false);\n-                    if (!result.matches()) {\n-                        StringBuilder sb = new StringBuilder();\n-                        // We have 3 cases, we can still have a single candidate, but the match is on label\n-                        // or we have several candidates, or none\n-                        Set<Extension> candidates = result.getExtensions();\n-                        if (candidates.isEmpty()) {\n-                            // No matches at all.\n-                            PRINTER.nok(\" Cannot find a dependency matching '\" + query + \"', maybe a typo?\");\n-                            success = false;\n-                        } else {\n-                            sb.append(Printer.NOK).append(\" Multiple extensions matching '\").append(query).append(\"'\");\n-                            result.getExtensions()\n-                                    .forEach(extension -> sb.append(System.lineSeparator()).append(\"     * \")\n-                                            .append(extension.managementKey()));\n-                            sb.append(System.lineSeparator())\n-                                    .append(\"     Be more specific e.g using the exact name or the full GAV.\");\n-                            PRINTER.print(sb.toString());\n-                            success = false;\n-                        }\n-                    } else { // Matches.\n-                        for (Extension extension : result) {\n-                            // Don't set success to false even if the dependency is not added; as it's should be idempotent.\n-                            updated = buildFile.addDependency(invocation.getPlatformDescriptor(), extension) || updated;\n-                        }\n+    static List<Extension> computeExtensionsFromQuery(final QuarkusCommandInvocation invocation,\n+            final Set<String> extensionsQuery) {\n+        final ImmutableList.Builder<Extension> builder = ImmutableList.<Extension> builder();\n+        for (String query : extensionsQuery) {\n+            if (query.contains(\":\")) {\n+                builder.add(Extensions.parse(query));\n+            } else {\n+                SelectionResult result = select(invocation.getPlatformDescriptor().getExtensions(), query, false);\n+                if (!result.matches()) {\n+                    StringBuilder sb = new StringBuilder();\n+                    // We have 3 cases, we can still have a single candidate, but the match is on label\n+                    // or we have several candidates, or none\n+                    Set<Extension> candidates = result.getExtensions();\n+                    if (candidates.isEmpty()) {\n+                        // No matches at all.\n+                        invocation.log().info(nok(\" Cannot find a dependency matching '\" + query + \"', maybe a typo?\"));\n+                        return null;\n+                    } else {\n+                        sb.append(NOK).append(\" Multiple extensions matching '\").append(query).append(\"'\");\n+                        result.getExtensions()\n+                                .forEach(extension -> sb.append(System.lineSeparator()).append(\"     * \")\n+                                        .append(extension.managementKey()));\n+                        sb.append(System.lineSeparator())\n+                                .append(\"     Be more specific e.g using the exact name or the full GAV.\");\n+                        invocation.log().info(sb.toString());\n+                        return null;\n+                    }\n+                } else { // Matches.\n+                    for (Extension extension : result) {\n+                        // Don't set success to false even if the dependency is not added; as it's should be idempotent.\n+                        builder.add(extension);\n                     }\n                 }\n             }\n-        } catch (IOException e) {\n-            throw new QuarkusCommandException(\"Failed to add extensions\", e);\n-        }\n-\n-        if (buildFile != null && updated) {\n-            try {\n-                buildFile.close();\n-            } catch (IOException e) {\n-                throw new QuarkusCommandException(\"Failed to update the project\", e);\n-            }\n         }\n-\n-        return new QuarkusCommandOutcome(success).setValue(AddExtensions.OUTCOME_UPDATED, updated);\n+        return builder.build();\n     }\n \n     /**\n      * Selection algorithm.\n      *\n+     * @param allPlatformExtensions the list of all platform extensions\n      * @param query the query\n-     * @param extensions the extension list\n      * @param labelLookup whether or not the query must be tested against the labels of the extensions. Should\n      *        be {@code false} by default.\n      * @return the list of matching candidates and whether or not a match has been found.\n      */\n-    static SelectionResult select(String query, List<Extension> extensions, boolean labelLookup) {\n+    static SelectionResult select(final List<Extension> allPlatformExtensions, final String query, final boolean labelLookup) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81aca5ca6f82bb62b7ba94a472c081e3f170ccb1"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ2MTczNw==", "bodyText": "TBH I don't remember \ud83d\ude05 the name is clearer, but the order \ud83e\udd17, I'll switch the order back..", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r436461737", "createdAt": "2020-06-08T05:20:16Z", "author": {"login": "ia3andy"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/commands/handlers/QuarkusCommandHandlers.java", "diffHunk": "@@ -11,111 +16,86 @@\n import java.util.regex.PatternSyntaxException;\n import java.util.stream.Collectors;\n \n-/**\n- * This class is thread-safe. It extracts extensions to be added to the project from an instance of\n- * {@link QuarkusCommandInvocation}.\n- */\n-public class AddExtensionsCommandHandler implements QuarkusCommand {\n-\n-    final static Printer PRINTER = new Printer();\n-\n-    @Override\n-    public QuarkusCommandOutcome execute(QuarkusCommandInvocation invocation) throws QuarkusCommandException {\n-\n-        final Set<String> extensions = invocation.getValue(AddExtensions.EXTENSIONS, Collections.emptySet());\n-        if (extensions.isEmpty()) {\n-            return QuarkusCommandOutcome.success().setValue(AddExtensions.OUTCOME_UPDATED, false);\n-        }\n-\n-        boolean updated = false;\n-        boolean success = true;\n+final class QuarkusCommandHandlers {\n \n-        final List<Extension> registry = invocation.getPlatformDescriptor().getExtensions();\n+    private QuarkusCommandHandlers() {\n+    }\n \n-        final BuildFile buildFile = invocation.getBuildFile();\n-        try {\n-            for (String query : extensions) {\n-                if (query.contains(\":\")) {\n-                    // GAV case.\n-                    updated = buildFile.addExtensionAsGAV(query) || updated;\n-                } else {\n-                    SelectionResult result = select(query, registry, false);\n-                    if (!result.matches()) {\n-                        StringBuilder sb = new StringBuilder();\n-                        // We have 3 cases, we can still have a single candidate, but the match is on label\n-                        // or we have several candidates, or none\n-                        Set<Extension> candidates = result.getExtensions();\n-                        if (candidates.isEmpty()) {\n-                            // No matches at all.\n-                            PRINTER.nok(\" Cannot find a dependency matching '\" + query + \"', maybe a typo?\");\n-                            success = false;\n-                        } else {\n-                            sb.append(Printer.NOK).append(\" Multiple extensions matching '\").append(query).append(\"'\");\n-                            result.getExtensions()\n-                                    .forEach(extension -> sb.append(System.lineSeparator()).append(\"     * \")\n-                                            .append(extension.managementKey()));\n-                            sb.append(System.lineSeparator())\n-                                    .append(\"     Be more specific e.g using the exact name or the full GAV.\");\n-                            PRINTER.print(sb.toString());\n-                            success = false;\n-                        }\n-                    } else { // Matches.\n-                        for (Extension extension : result) {\n-                            // Don't set success to false even if the dependency is not added; as it's should be idempotent.\n-                            updated = buildFile.addDependency(invocation.getPlatformDescriptor(), extension) || updated;\n-                        }\n+    static List<Extension> computeExtensionsFromQuery(final QuarkusCommandInvocation invocation,\n+            final Set<String> extensionsQuery) {\n+        final ImmutableList.Builder<Extension> builder = ImmutableList.<Extension> builder();\n+        for (String query : extensionsQuery) {\n+            if (query.contains(\":\")) {\n+                builder.add(Extensions.parse(query));\n+            } else {\n+                SelectionResult result = select(invocation.getPlatformDescriptor().getExtensions(), query, false);\n+                if (!result.matches()) {\n+                    StringBuilder sb = new StringBuilder();\n+                    // We have 3 cases, we can still have a single candidate, but the match is on label\n+                    // or we have several candidates, or none\n+                    Set<Extension> candidates = result.getExtensions();\n+                    if (candidates.isEmpty()) {\n+                        // No matches at all.\n+                        invocation.log().info(nok(\" Cannot find a dependency matching '\" + query + \"', maybe a typo?\"));\n+                        return null;\n+                    } else {\n+                        sb.append(NOK).append(\" Multiple extensions matching '\").append(query).append(\"'\");\n+                        result.getExtensions()\n+                                .forEach(extension -> sb.append(System.lineSeparator()).append(\"     * \")\n+                                        .append(extension.managementKey()));\n+                        sb.append(System.lineSeparator())\n+                                .append(\"     Be more specific e.g using the exact name or the full GAV.\");\n+                        invocation.log().info(sb.toString());\n+                        return null;\n+                    }\n+                } else { // Matches.\n+                    for (Extension extension : result) {\n+                        // Don't set success to false even if the dependency is not added; as it's should be idempotent.\n+                        builder.add(extension);\n                     }\n                 }\n             }\n-        } catch (IOException e) {\n-            throw new QuarkusCommandException(\"Failed to add extensions\", e);\n-        }\n-\n-        if (buildFile != null && updated) {\n-            try {\n-                buildFile.close();\n-            } catch (IOException e) {\n-                throw new QuarkusCommandException(\"Failed to update the project\", e);\n-            }\n         }\n-\n-        return new QuarkusCommandOutcome(success).setValue(AddExtensions.OUTCOME_UPDATED, updated);\n+        return builder.build();\n     }\n \n     /**\n      * Selection algorithm.\n      *\n+     * @param allPlatformExtensions the list of all platform extensions\n      * @param query the query\n-     * @param extensions the extension list\n      * @param labelLookup whether or not the query must be tested against the labels of the extensions. Should\n      *        be {@code false} by default.\n      * @return the list of matching candidates and whether or not a match has been found.\n      */\n-    static SelectionResult select(String query, List<Extension> extensions, boolean labelLookup) {\n+    static SelectionResult select(final List<Extension> allPlatformExtensions, final String query, final boolean labelLookup) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3MTEyMQ=="}, "originalCommit": {"oid": "81aca5ca6f82bb62b7ba94a472c081e3f170ccb1"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc2NDc1NQ==", "bodyText": "fixed", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r436764755", "createdAt": "2020-06-08T14:45:59Z", "author": {"login": "ia3andy"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/commands/handlers/QuarkusCommandHandlers.java", "diffHunk": "@@ -11,111 +16,86 @@\n import java.util.regex.PatternSyntaxException;\n import java.util.stream.Collectors;\n \n-/**\n- * This class is thread-safe. It extracts extensions to be added to the project from an instance of\n- * {@link QuarkusCommandInvocation}.\n- */\n-public class AddExtensionsCommandHandler implements QuarkusCommand {\n-\n-    final static Printer PRINTER = new Printer();\n-\n-    @Override\n-    public QuarkusCommandOutcome execute(QuarkusCommandInvocation invocation) throws QuarkusCommandException {\n-\n-        final Set<String> extensions = invocation.getValue(AddExtensions.EXTENSIONS, Collections.emptySet());\n-        if (extensions.isEmpty()) {\n-            return QuarkusCommandOutcome.success().setValue(AddExtensions.OUTCOME_UPDATED, false);\n-        }\n-\n-        boolean updated = false;\n-        boolean success = true;\n+final class QuarkusCommandHandlers {\n \n-        final List<Extension> registry = invocation.getPlatformDescriptor().getExtensions();\n+    private QuarkusCommandHandlers() {\n+    }\n \n-        final BuildFile buildFile = invocation.getBuildFile();\n-        try {\n-            for (String query : extensions) {\n-                if (query.contains(\":\")) {\n-                    // GAV case.\n-                    updated = buildFile.addExtensionAsGAV(query) || updated;\n-                } else {\n-                    SelectionResult result = select(query, registry, false);\n-                    if (!result.matches()) {\n-                        StringBuilder sb = new StringBuilder();\n-                        // We have 3 cases, we can still have a single candidate, but the match is on label\n-                        // or we have several candidates, or none\n-                        Set<Extension> candidates = result.getExtensions();\n-                        if (candidates.isEmpty()) {\n-                            // No matches at all.\n-                            PRINTER.nok(\" Cannot find a dependency matching '\" + query + \"', maybe a typo?\");\n-                            success = false;\n-                        } else {\n-                            sb.append(Printer.NOK).append(\" Multiple extensions matching '\").append(query).append(\"'\");\n-                            result.getExtensions()\n-                                    .forEach(extension -> sb.append(System.lineSeparator()).append(\"     * \")\n-                                            .append(extension.managementKey()));\n-                            sb.append(System.lineSeparator())\n-                                    .append(\"     Be more specific e.g using the exact name or the full GAV.\");\n-                            PRINTER.print(sb.toString());\n-                            success = false;\n-                        }\n-                    } else { // Matches.\n-                        for (Extension extension : result) {\n-                            // Don't set success to false even if the dependency is not added; as it's should be idempotent.\n-                            updated = buildFile.addDependency(invocation.getPlatformDescriptor(), extension) || updated;\n-                        }\n+    static List<Extension> computeExtensionsFromQuery(final QuarkusCommandInvocation invocation,\n+            final Set<String> extensionsQuery) {\n+        final ImmutableList.Builder<Extension> builder = ImmutableList.<Extension> builder();\n+        for (String query : extensionsQuery) {\n+            if (query.contains(\":\")) {\n+                builder.add(Extensions.parse(query));\n+            } else {\n+                SelectionResult result = select(invocation.getPlatformDescriptor().getExtensions(), query, false);\n+                if (!result.matches()) {\n+                    StringBuilder sb = new StringBuilder();\n+                    // We have 3 cases, we can still have a single candidate, but the match is on label\n+                    // or we have several candidates, or none\n+                    Set<Extension> candidates = result.getExtensions();\n+                    if (candidates.isEmpty()) {\n+                        // No matches at all.\n+                        invocation.log().info(nok(\" Cannot find a dependency matching '\" + query + \"', maybe a typo?\"));\n+                        return null;\n+                    } else {\n+                        sb.append(NOK).append(\" Multiple extensions matching '\").append(query).append(\"'\");\n+                        result.getExtensions()\n+                                .forEach(extension -> sb.append(System.lineSeparator()).append(\"     * \")\n+                                        .append(extension.managementKey()));\n+                        sb.append(System.lineSeparator())\n+                                .append(\"     Be more specific e.g using the exact name or the full GAV.\");\n+                        invocation.log().info(sb.toString());\n+                        return null;\n+                    }\n+                } else { // Matches.\n+                    for (Extension extension : result) {\n+                        // Don't set success to false even if the dependency is not added; as it's should be idempotent.\n+                        builder.add(extension);\n                     }\n                 }\n             }\n-        } catch (IOException e) {\n-            throw new QuarkusCommandException(\"Failed to add extensions\", e);\n-        }\n-\n-        if (buildFile != null && updated) {\n-            try {\n-                buildFile.close();\n-            } catch (IOException e) {\n-                throw new QuarkusCommandException(\"Failed to update the project\", e);\n-            }\n         }\n-\n-        return new QuarkusCommandOutcome(success).setValue(AddExtensions.OUTCOME_UPDATED, updated);\n+        return builder.build();\n     }\n \n     /**\n      * Selection algorithm.\n      *\n+     * @param allPlatformExtensions the list of all platform extensions\n      * @param query the query\n-     * @param extensions the extension list\n      * @param labelLookup whether or not the query must be tested against the labels of the extensions. Should\n      *        be {@code false} by default.\n      * @return the list of matching candidates and whether or not a match has been found.\n      */\n-    static SelectionResult select(String query, List<Extension> extensions, boolean labelLookup) {\n+    static SelectionResult select(final List<Extension> allPlatformExtensions, final String query, final boolean labelLookup) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3MTEyMQ=="}, "originalCommit": {"oid": "81aca5ca6f82bb62b7ba94a472c081e3f170ccb1"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMTExNTQ2OnYy", "diffSide": "RIGHT", "path": "independent-projects/tools/platform-descriptor-api/src/main/java/io/quarkus/dependencies/Extension.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNTozMDo1MlrOGgkAEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNTozMDo1MlrOGgkAEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5NzQ1Ng==", "bodyText": "@aloubyansky as we discussed \u2b06\ufe0f", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r436797456", "createdAt": "2020-06-08T15:30:52Z", "author": {"login": "ia3andy"}, "path": "independent-projects/tools/platform-descriptor-api/src/main/java/io/quarkus/dependencies/Extension.java", "diffHunk": "@@ -195,6 +195,9 @@ public Dependency toDependency(boolean stripVersion) {\n         if (version != null && !version.isEmpty() && !stripVersion) {\n             dependency.setVersion(version);\n         }\n+        if (type != null && !type.isEmpty()) {\n+            dependency.setType(type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e18527211b20cf83d4649de38a53d151818494a8"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMTExNzI0OnYy", "diffSide": "RIGHT", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/model/AppArtifactKey.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNTozMToxNlrOGgkBLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNTozMToxNlrOGgkBLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5Nzc0MA==", "bodyText": "@aloubyansky as we discussed \u2b06\ufe0f", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r436797740", "createdAt": "2020-06-08T15:31:16Z", "author": {"login": "ia3andy"}, "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/model/AppArtifactKey.java", "diffHunk": "@@ -73,12 +73,12 @@ public static AppArtifactKey fromString(String str) {\n     protected AppArtifactKey(String[] parts) {\n         this.groupId = parts[0];\n         this.artifactId = parts[1];\n-        if (parts.length == 2) {\n+        if (parts.length == 2 || parts[2] == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e18527211b20cf83d4649de38a53d151818494a8"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMzY5OTE4OnYy", "diffSide": "RIGHT", "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/buildfile/MavenBuildFile.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwNzo1Mjo0MFrOGg8-3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzo0NTo0OFrOGhKpuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIwNjc0OQ==", "bodyText": "@aloubyansky maybe we should change the AppArtifactKey/Coords instead, having empty string classifier seems not working with the maven api?", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437206749", "createdAt": "2020-06-09T07:52:40Z", "author": {"login": "ia3andy"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/buildfile/MavenBuildFile.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package io.quarkus.devtools.project.buildfile;\n+\n+import static io.quarkus.devtools.project.extensions.Extensions.toKey;\n+\n+import io.quarkus.bootstrap.model.AppArtifactCoords;\n+import io.quarkus.bootstrap.model.AppArtifactKey;\n+import io.quarkus.devtools.project.BuildTool;\n+import io.quarkus.maven.utilities.MojoUtils;\n+import io.quarkus.platform.descriptor.QuarkusPlatformDescriptor;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.model.Model;\n+\n+public class MavenBuildFile extends BuildFile {\n+\n+    private AtomicReference<Model> modelRef = new AtomicReference<>();\n+\n+    public MavenBuildFile(final Path projectFolderPath, final QuarkusPlatformDescriptor platformDescriptor) {\n+        super(projectFolderPath, platformDescriptor);\n+    }\n+\n+    @Override\n+    public void writeToDisk() throws IOException {\n+        if (getModel() == null) {\n+            return;\n+        }\n+        try (ByteArrayOutputStream pomOutputStream = new ByteArrayOutputStream()) {\n+            MojoUtils.write(getModel(), pomOutputStream);\n+            writeToProjectFile(BuildTool.MAVEN.getDependenciesFile(), pomOutputStream.toByteArray());\n+        }\n+    }\n+\n+    @Override\n+    protected void addDependencyInBuildFile(AppArtifactCoords coords) throws IOException {\n+        if (getModel() != null) {\n+            final Dependency d = new Dependency();\n+            d.setGroupId(coords.getGroupId());\n+            d.setArtifactId(coords.getArtifactId());\n+            d.setVersion(coords.getVersion());\n+            // When classifier is empty, you get  <classifier></classifier> in the pom.xml\n+            if (coords.getClassifier() != null && !coords.getClassifier().isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f217cc71e4201f349c8b55fc2231e4c7bdf312"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIxMzU2NQ==", "bodyText": "What do you mean? The only reason we use an empty classifier is because this is how Maven does it.", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437213565", "createdAt": "2020-06-09T08:04:10Z", "author": {"login": "aloubyansky"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/buildfile/MavenBuildFile.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package io.quarkus.devtools.project.buildfile;\n+\n+import static io.quarkus.devtools.project.extensions.Extensions.toKey;\n+\n+import io.quarkus.bootstrap.model.AppArtifactCoords;\n+import io.quarkus.bootstrap.model.AppArtifactKey;\n+import io.quarkus.devtools.project.BuildTool;\n+import io.quarkus.maven.utilities.MojoUtils;\n+import io.quarkus.platform.descriptor.QuarkusPlatformDescriptor;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.model.Model;\n+\n+public class MavenBuildFile extends BuildFile {\n+\n+    private AtomicReference<Model> modelRef = new AtomicReference<>();\n+\n+    public MavenBuildFile(final Path projectFolderPath, final QuarkusPlatformDescriptor platformDescriptor) {\n+        super(projectFolderPath, platformDescriptor);\n+    }\n+\n+    @Override\n+    public void writeToDisk() throws IOException {\n+        if (getModel() == null) {\n+            return;\n+        }\n+        try (ByteArrayOutputStream pomOutputStream = new ByteArrayOutputStream()) {\n+            MojoUtils.write(getModel(), pomOutputStream);\n+            writeToProjectFile(BuildTool.MAVEN.getDependenciesFile(), pomOutputStream.toByteArray());\n+        }\n+    }\n+\n+    @Override\n+    protected void addDependencyInBuildFile(AppArtifactCoords coords) throws IOException {\n+        if (getModel() != null) {\n+            final Dependency d = new Dependency();\n+            d.setGroupId(coords.getGroupId());\n+            d.setArtifactId(coords.getArtifactId());\n+            d.setVersion(coords.getVersion());\n+            // When classifier is empty, you get  <classifier></classifier> in the pom.xml\n+            if (coords.getClassifier() != null && !coords.getClassifier().isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIwNjc0OQ=="}, "originalCommit": {"oid": "34f217cc71e4201f349c8b55fc2231e4c7bdf312"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzMDcxMw==", "bodyText": "We discussed on zulip and concluded that maven api is behavior differently for resolving artifact and dependencies. Making sure we don't put an empty classifier in the dependency prevent from having <classifier></classifier> in the pom.xml.", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437430713", "createdAt": "2020-06-09T13:45:48Z", "author": {"login": "ia3andy"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/buildfile/MavenBuildFile.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package io.quarkus.devtools.project.buildfile;\n+\n+import static io.quarkus.devtools.project.extensions.Extensions.toKey;\n+\n+import io.quarkus.bootstrap.model.AppArtifactCoords;\n+import io.quarkus.bootstrap.model.AppArtifactKey;\n+import io.quarkus.devtools.project.BuildTool;\n+import io.quarkus.maven.utilities.MojoUtils;\n+import io.quarkus.platform.descriptor.QuarkusPlatformDescriptor;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.maven.model.Dependency;\n+import org.apache.maven.model.Model;\n+\n+public class MavenBuildFile extends BuildFile {\n+\n+    private AtomicReference<Model> modelRef = new AtomicReference<>();\n+\n+    public MavenBuildFile(final Path projectFolderPath, final QuarkusPlatformDescriptor platformDescriptor) {\n+        super(projectFolderPath, platformDescriptor);\n+    }\n+\n+    @Override\n+    public void writeToDisk() throws IOException {\n+        if (getModel() == null) {\n+            return;\n+        }\n+        try (ByteArrayOutputStream pomOutputStream = new ByteArrayOutputStream()) {\n+            MojoUtils.write(getModel(), pomOutputStream);\n+            writeToProjectFile(BuildTool.MAVEN.getDependenciesFile(), pomOutputStream.toByteArray());\n+        }\n+    }\n+\n+    @Override\n+    protected void addDependencyInBuildFile(AppArtifactCoords coords) throws IOException {\n+        if (getModel() != null) {\n+            final Dependency d = new Dependency();\n+            d.setGroupId(coords.getGroupId());\n+            d.setArtifactId(coords.getArtifactId());\n+            d.setVersion(coords.getVersion());\n+            // When classifier is empty, you get  <classifier></classifier> in the pom.xml\n+            if (coords.getClassifier() != null && !coords.getClassifier().isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIwNjc0OQ=="}, "originalCommit": {"oid": "34f217cc71e4201f349c8b55fc2231e4c7bdf312"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTEzODUwOnYy", "diffSide": "RIGHT", "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionsManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzo1MDozOVrOGhK9qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzo1MToyMVrOGhLAvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNTgxNg==", "bodyText": "Better use the singular form here: ExtensionManager. eg. https://github.com/quarkusio/quarkus-registry-descriptor/blob/master/src/main/java/io/quarkus/registry/ExtensionRegistry.java", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437435816", "createdAt": "2020-06-09T13:50:39Z", "author": {"login": "gastaldi"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionsManager.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package io.quarkus.devtools.project.extensions;\n+\n+import io.quarkus.bootstrap.model.AppArtifactCoords;\n+import io.quarkus.bootstrap.model.AppArtifactKey;\n+import io.quarkus.dependencies.Extension;\n+import io.quarkus.devtools.project.BuildTool;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * This interface defines a high level way of managing (read/write) extensions in any QuarkusProject\n+ */\n+public interface ExtensionsManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f217cc71e4201f349c8b55fc2231e4c7bdf312"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNjYwNw==", "bodyText": "ok I'll change", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437436607", "createdAt": "2020-06-09T13:51:21Z", "author": {"login": "ia3andy"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionsManager.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package io.quarkus.devtools.project.extensions;\n+\n+import io.quarkus.bootstrap.model.AppArtifactCoords;\n+import io.quarkus.bootstrap.model.AppArtifactKey;\n+import io.quarkus.dependencies.Extension;\n+import io.quarkus.devtools.project.BuildTool;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * This interface defines a high level way of managing (read/write) extensions in any QuarkusProject\n+ */\n+public interface ExtensionsManager {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNTgxNg=="}, "originalCommit": {"oid": "34f217cc71e4201f349c8b55fc2231e4c7bdf312"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTE4MTU4OnYy", "diffSide": "RIGHT", "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/commands/handlers/QuarkusCommandHandlers.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzo1NzoyMlrOGhLY3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzo1NzoyMlrOGhLY3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0Mjc4Mg==", "bodyText": "Since you're refactoring Printer into ConsoleMessageFormat, try to not expose the NOK attribute there otherwise the methods in that class are meaningless", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437442782", "createdAt": "2020-06-09T13:57:22Z", "author": {"login": "gastaldi"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/commands/handlers/QuarkusCommandHandlers.java", "diffHunk": "@@ -11,111 +17,86 @@\n import java.util.regex.PatternSyntaxException;\n import java.util.stream.Collectors;\n \n-/**\n- * This class is thread-safe. It extracts extensions to be added to the project from an instance of\n- * {@link QuarkusCommandInvocation}.\n- */\n-public class AddExtensionsCommandHandler implements QuarkusCommand {\n-\n-    final static Printer PRINTER = new Printer();\n+final class QuarkusCommandHandlers {\n \n-    @Override\n-    public QuarkusCommandOutcome execute(QuarkusCommandInvocation invocation) throws QuarkusCommandException {\n-\n-        final Set<String> extensions = invocation.getValue(AddExtensions.EXTENSIONS, Collections.emptySet());\n-        if (extensions.isEmpty()) {\n-            return QuarkusCommandOutcome.success().setValue(AddExtensions.OUTCOME_UPDATED, false);\n-        }\n-\n-        boolean updated = false;\n-        boolean success = true;\n-\n-        final List<Extension> registry = invocation.getPlatformDescriptor().getExtensions();\n+    private QuarkusCommandHandlers() {\n+    }\n \n-        final BuildFile buildFile = invocation.getBuildFile();\n-        try {\n-            for (String query : extensions) {\n-                if (query.contains(\":\")) {\n-                    // GAV case.\n-                    updated = buildFile.addExtensionAsGAV(query) || updated;\n+    static List<AppArtifactCoords> computeCoordsFromQuery(final QuarkusCommandInvocation invocation,\n+            final Set<String> extensionsQuery) {\n+        final ImmutableList.Builder<AppArtifactCoords> builder = ImmutableList.builder();\n+        for (String query : extensionsQuery) {\n+            if (query.contains(\":\")) {\n+                builder.add(AppArtifactCoords.fromString(query));\n+            } else {\n+                SelectionResult result = select(query, invocation.getPlatformDescriptor().getExtensions(), false);\n+                if (result.matches()) {\n+                    final Set<AppArtifactCoords> withStrippedVersion = result.getExtensions().stream().map(Extensions::toCoords)\n+                            .map(Extensions::stripVersion).collect(Collectors.toSet());\n+                    // We strip the version because those extensions are managed\n+                    builder.addAll(withStrippedVersion);\n                 } else {\n-                    SelectionResult result = select(query, registry, false);\n-                    if (!result.matches()) {\n-                        StringBuilder sb = new StringBuilder();\n-                        // We have 3 cases, we can still have a single candidate, but the match is on label\n-                        // or we have several candidates, or none\n-                        Set<Extension> candidates = result.getExtensions();\n-                        if (candidates.isEmpty()) {\n-                            // No matches at all.\n-                            PRINTER.nok(\" Cannot find a dependency matching '\" + query + \"', maybe a typo?\");\n-                            success = false;\n-                        } else {\n-                            sb.append(Printer.NOK).append(\" Multiple extensions matching '\").append(query).append(\"'\");\n-                            result.getExtensions()\n-                                    .forEach(extension -> sb.append(System.lineSeparator()).append(\"     * \")\n-                                            .append(extension.managementKey()));\n-                            sb.append(System.lineSeparator())\n-                                    .append(\"     Be more specific e.g using the exact name or the full GAV.\");\n-                            PRINTER.print(sb.toString());\n-                            success = false;\n-                        }\n-                    } else { // Matches.\n-                        for (Extension extension : result) {\n-                            // Don't set success to false even if the dependency is not added; as it's should be idempotent.\n-                            updated = buildFile.addDependency(invocation.getPlatformDescriptor(), extension) || updated;\n-                        }\n+                    StringBuilder sb = new StringBuilder();\n+                    // We have 3 cases, we can still have a single candidate, but the match is on label\n+                    // or we have several candidates, or none\n+                    Set<Extension> candidates = result.getExtensions();\n+                    if (candidates.isEmpty()) {\n+                        // No matches at all.\n+                        invocation.log().info(nok(\" Cannot find a dependency matching '\" + query + \"', maybe a typo?\"));\n+                        return null;\n+                    } else {\n+                        sb.append(NOK).append(\" Multiple extensions matching '\").append(query).append(\"'\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f217cc71e4201f349c8b55fc2231e4c7bdf312"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTE4NzIxOnYy", "diffSide": "RIGHT", "path": "independent-projects/tools/platform-descriptor-api/src/main/java/io/quarkus/platform/tools/ConsoleMessageFormat.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzo1ODoxM1rOGhLcew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzo1ODoxM1rOGhLcew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0MzcwNw==", "bodyText": "Better make these attributes private otherwise any methods in this class are meaningless", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437443707", "createdAt": "2020-06-09T13:58:13Z", "author": {"login": "gastaldi"}, "path": "independent-projects/tools/platform-descriptor-api/src/main/java/io/quarkus/platform/tools/ConsoleMessageFormat.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package io.quarkus.platform.tools;\n+\n+public final class ConsoleMessageFormat {\n+\n+    public static final String OK = \"\\u2705\";\n+    public static final String NOK = \"\\u274c\";\n+    public static final String NOOP = \"\\uD83D\\uDC4D\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f217cc71e4201f349c8b55fc2231e4c7bdf312"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTE5NTI3OnYy", "diffSide": "LEFT", "path": "integration-tests/maven/src/test/java/io/quarkus/maven/it/CreateProjectMojoIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzo1OTo1OFrOGhLiJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDowNToyNVrOGhLymA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NTE1Nw==", "bodyText": "Why was this test removed?", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437445157", "createdAt": "2020-06-09T13:59:58Z", "author": {"login": "gastaldi"}, "path": "integration-tests/maven/src/test/java/io/quarkus/maven/it/CreateProjectMojoIT.java", "diffHunk": "@@ -351,23 +304,6 @@ public void testThatDefaultPackageAreReplaced() throws Exception {\n                 \"package org.acme.quarkus.sample;\");\n     }\n \n-    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f217cc71e4201f349c8b55fc2231e4c7bdf312"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0OTM2OA==", "bodyText": "same as the previous", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437449368", "createdAt": "2020-06-09T14:05:25Z", "author": {"login": "ia3andy"}, "path": "integration-tests/maven/src/test/java/io/quarkus/maven/it/CreateProjectMojoIT.java", "diffHunk": "@@ -351,23 +304,6 @@ public void testThatDefaultPackageAreReplaced() throws Exception {\n                 \"package org.acme.quarkus.sample;\");\n     }\n \n-    /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NTE1Nw=="}, "originalCommit": {"oid": "34f217cc71e4201f349c8b55fc2231e4c7bdf312"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTE5OTM3OnYy", "diffSide": "LEFT", "path": "integration-tests/maven/src/test/java/io/quarkus/maven/it/CreateProjectMojoIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDowMDo1MFrOGhLkxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDowNDozNlrOGhLwJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NTgyOA==", "bodyText": "It looks like those asserts are important, why remove them?", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437445828", "createdAt": "2020-06-09T14:00:50Z", "author": {"login": "gastaldi"}, "path": "integration-tests/maven/src/test/java/io/quarkus/maven/it/CreateProjectMojoIT.java", "diffHunk": "@@ -111,40 +111,13 @@ public void testProjectGenerationFromScratch() throws MavenInvocationException,\n     }\n \n     @Test\n-    public void testProjectGenerationFromEmptyPom() throws Exception {\n+    public void testProjectGenerationWithExistingPomShouldFail() throws Exception {\n         testDir = initProject(\"projects/simple-pom-it\", \"projects/project-generation-from-empty-pom\");\n         assertThat(testDir).isDirectory();\n         invoker = initInvoker(testDir);\n         InvocationResult result = setup(new Properties());\n \n-        assertThat(result.getExitCode()).isZero();\n-\n-        assertThat(new File(testDir, \"pom.xml\")).isFile();\n-        assertThat(new File(testDir, \"src/main/java\")).isDirectory();\n-\n-        assertThat(new File(testDir, \"src/main/resources/application.properties\")).exists();\n-        assertThat(new File(testDir, \"src/main/resources/META-INF/resources/index.html\")).exists();\n-\n-        assertThat(FileUtils.readFileToString(new File(testDir, \"pom.xml\"), \"UTF-8\"))\n-                .contains(getPluginArtifactId(), MojoUtils.TEMPLATE_PROPERTY_QUARKUS_PLUGIN_VERSION_VALUE,\n-                        getPluginGroupId());\n-\n-        final Model model = loadPom(testDir);\n-        assertThat(model.getProperties().getProperty(MojoUtils.TEMPLATE_PROPERTY_QUARKUS_PLUGIN_VERSION_NAME))\n-                .isEqualTo(getPluginVersion());\n-        assertThat(model.getProperties().getProperty(MojoUtils.TEMPLATE_PROPERTY_QUARKUS_PLATFORM_ARTIFACT_ID_NAME))\n-                .isEqualTo(getBomArtifactId());\n-\n-        assertThat(model.getDependencyManagement().getDependencies().stream()\n-                .anyMatch(d -> d.getArtifactId().equals(MojoUtils.TEMPLATE_PROPERTY_QUARKUS_PLATFORM_ARTIFACT_ID_VALUE)\n-                        && d.getVersion().equals(MojoUtils.TEMPLATE_PROPERTY_QUARKUS_PLATFORM_VERSION_VALUE)\n-                        && d.getScope().equals(\"import\")\n-                        && d.getType().equals(\"pom\"))).isTrue();\n-\n-        assertThat(model.getDependencies()).isEmpty();\n-\n-        assertThat(model.getProfiles()).hasSize(1);\n-        assertThat(model.getProfiles().get(0).getId()).isEqualTo(\"native\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34f217cc71e4201f349c8b55fc2231e4c7bdf312"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0ODc0MA==", "bodyText": "Migrating project has been removed from the \"create\" command, those asserts were for it. I am now testing that it fails. Note that the same asserts are already in the other \"fromScratch\" test.", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437448740", "createdAt": "2020-06-09T14:04:36Z", "author": {"login": "ia3andy"}, "path": "integration-tests/maven/src/test/java/io/quarkus/maven/it/CreateProjectMojoIT.java", "diffHunk": "@@ -111,40 +111,13 @@ public void testProjectGenerationFromScratch() throws MavenInvocationException,\n     }\n \n     @Test\n-    public void testProjectGenerationFromEmptyPom() throws Exception {\n+    public void testProjectGenerationWithExistingPomShouldFail() throws Exception {\n         testDir = initProject(\"projects/simple-pom-it\", \"projects/project-generation-from-empty-pom\");\n         assertThat(testDir).isDirectory();\n         invoker = initInvoker(testDir);\n         InvocationResult result = setup(new Properties());\n \n-        assertThat(result.getExitCode()).isZero();\n-\n-        assertThat(new File(testDir, \"pom.xml\")).isFile();\n-        assertThat(new File(testDir, \"src/main/java\")).isDirectory();\n-\n-        assertThat(new File(testDir, \"src/main/resources/application.properties\")).exists();\n-        assertThat(new File(testDir, \"src/main/resources/META-INF/resources/index.html\")).exists();\n-\n-        assertThat(FileUtils.readFileToString(new File(testDir, \"pom.xml\"), \"UTF-8\"))\n-                .contains(getPluginArtifactId(), MojoUtils.TEMPLATE_PROPERTY_QUARKUS_PLUGIN_VERSION_VALUE,\n-                        getPluginGroupId());\n-\n-        final Model model = loadPom(testDir);\n-        assertThat(model.getProperties().getProperty(MojoUtils.TEMPLATE_PROPERTY_QUARKUS_PLUGIN_VERSION_NAME))\n-                .isEqualTo(getPluginVersion());\n-        assertThat(model.getProperties().getProperty(MojoUtils.TEMPLATE_PROPERTY_QUARKUS_PLATFORM_ARTIFACT_ID_NAME))\n-                .isEqualTo(getBomArtifactId());\n-\n-        assertThat(model.getDependencyManagement().getDependencies().stream()\n-                .anyMatch(d -> d.getArtifactId().equals(MojoUtils.TEMPLATE_PROPERTY_QUARKUS_PLATFORM_ARTIFACT_ID_VALUE)\n-                        && d.getVersion().equals(MojoUtils.TEMPLATE_PROPERTY_QUARKUS_PLATFORM_VERSION_VALUE)\n-                        && d.getScope().equals(\"import\")\n-                        && d.getType().equals(\"pom\"))).isTrue();\n-\n-        assertThat(model.getDependencies()).isEmpty();\n-\n-        assertThat(model.getProfiles()).hasSize(1);\n-        assertThat(model.getProfiles().get(0).getId()).isEqualTo(\"native\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NTgyOA=="}, "originalCommit": {"oid": "34f217cc71e4201f349c8b55fc2231e4c7bdf312"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTMzODE4OnYy", "diffSide": "RIGHT", "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDozMDozM1rOGhM-Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDozMjowN1rOGhNCuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ2ODY4Nw==", "bodyText": "I'd prefer to use Collection instead. That would prevent cases where the caller has a different Collection implementation and need to convert to List to call this method", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437468687", "createdAt": "2020-06-09T14:30:33Z", "author": {"login": "gastaldi"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionManager.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package io.quarkus.devtools.project.extensions;\n+\n+import io.quarkus.bootstrap.model.AppArtifactCoords;\n+import io.quarkus.bootstrap.model.AppArtifactKey;\n+import io.quarkus.dependencies.Extension;\n+import io.quarkus.devtools.project.BuildTool;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * This interface defines a high level way of managing (read/write) extensions in any QuarkusProject\n+ */\n+public interface ExtensionManager {\n+\n+    /**\n+     * @return the {@link BuildTool} of this extension manager\n+     */\n+    BuildTool getBuildTool();\n+\n+    /**\n+     * Read the build file(s) to get the list of installed extensions in this Quarkus project.\n+     *\n+     * @return The list of {@link AppArtifactCoords} installed in the project build file(s).\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    List<AppArtifactCoords> getInstalled() throws IOException;\n+\n+    /**\n+     * Read build file(s) to check if an extension is installed in this Quarkus project.\n+     *\n+     * @param key the {@link AppArtifactKey} of the extension to check\n+     * @return true if it's installed\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    default boolean isInstalled(AppArtifactKey key) throws IOException {\n+        return getInstalled().stream().anyMatch(i -> Objects.equals(i.getKey(), key));\n+    }\n+\n+    /**\n+     * Check that the Quarkus Platform bom is defined in the project.\n+     * The Quarkus Platform Bom role is to define version to use for Quarkus extensions.\n+     *\n+     * @return true if it's defined, false else\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    boolean hasQuarkusPlatformBom() throws IOException;\n+\n+    /**\n+     * This is going to install/add all the specified extensions to the project build file(s).\n+     *\n+     * <pre>\n+     *   - If the project Quarkus platform bom is not defined, an {@link IllegalStateException} will be thrown\n+     *   - Extensions which are already installed will ALWAYS be skipped whatever the specified version\n+     *   - The provided version will be used wasn't already installed\n+     * </pre>\n+     *\n+     * @param coords the list of {@link AppArtifactCoords} for the extensions to install\n+     * @return the {@link InstallResult}\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    InstallResult install(List<AppArtifactCoords> coords) throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4315ce7b40fd2d6549394658a96c3f73173c305a"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ2OTg4Mw==", "bodyText": "For this one I would really like to have a List since it's ordered and you may want to add them in a specific order..", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437469883", "createdAt": "2020-06-09T14:32:07Z", "author": {"login": "ia3andy"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionManager.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package io.quarkus.devtools.project.extensions;\n+\n+import io.quarkus.bootstrap.model.AppArtifactCoords;\n+import io.quarkus.bootstrap.model.AppArtifactKey;\n+import io.quarkus.dependencies.Extension;\n+import io.quarkus.devtools.project.BuildTool;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * This interface defines a high level way of managing (read/write) extensions in any QuarkusProject\n+ */\n+public interface ExtensionManager {\n+\n+    /**\n+     * @return the {@link BuildTool} of this extension manager\n+     */\n+    BuildTool getBuildTool();\n+\n+    /**\n+     * Read the build file(s) to get the list of installed extensions in this Quarkus project.\n+     *\n+     * @return The list of {@link AppArtifactCoords} installed in the project build file(s).\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    List<AppArtifactCoords> getInstalled() throws IOException;\n+\n+    /**\n+     * Read build file(s) to check if an extension is installed in this Quarkus project.\n+     *\n+     * @param key the {@link AppArtifactKey} of the extension to check\n+     * @return true if it's installed\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    default boolean isInstalled(AppArtifactKey key) throws IOException {\n+        return getInstalled().stream().anyMatch(i -> Objects.equals(i.getKey(), key));\n+    }\n+\n+    /**\n+     * Check that the Quarkus Platform bom is defined in the project.\n+     * The Quarkus Platform Bom role is to define version to use for Quarkus extensions.\n+     *\n+     * @return true if it's defined, false else\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    boolean hasQuarkusPlatformBom() throws IOException;\n+\n+    /**\n+     * This is going to install/add all the specified extensions to the project build file(s).\n+     *\n+     * <pre>\n+     *   - If the project Quarkus platform bom is not defined, an {@link IllegalStateException} will be thrown\n+     *   - Extensions which are already installed will ALWAYS be skipped whatever the specified version\n+     *   - The provided version will be used wasn't already installed\n+     * </pre>\n+     *\n+     * @param coords the list of {@link AppArtifactCoords} for the extensions to install\n+     * @return the {@link InstallResult}\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    InstallResult install(List<AppArtifactCoords> coords) throws IOException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ2ODY4Nw=="}, "originalCommit": {"oid": "4315ce7b40fd2d6549394658a96c3f73173c305a"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTMzOTk5OnYy", "diffSide": "RIGHT", "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDozMDo1NVrOGhM_PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNTozNjoyNFrOGhQivQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ2ODk4OA==", "bodyText": "Same as above", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437468988", "createdAt": "2020-06-09T14:30:55Z", "author": {"login": "gastaldi"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionManager.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package io.quarkus.devtools.project.extensions;\n+\n+import io.quarkus.bootstrap.model.AppArtifactCoords;\n+import io.quarkus.bootstrap.model.AppArtifactKey;\n+import io.quarkus.dependencies.Extension;\n+import io.quarkus.devtools.project.BuildTool;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * This interface defines a high level way of managing (read/write) extensions in any QuarkusProject\n+ */\n+public interface ExtensionManager {\n+\n+    /**\n+     * @return the {@link BuildTool} of this extension manager\n+     */\n+    BuildTool getBuildTool();\n+\n+    /**\n+     * Read the build file(s) to get the list of installed extensions in this Quarkus project.\n+     *\n+     * @return The list of {@link AppArtifactCoords} installed in the project build file(s).\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    List<AppArtifactCoords> getInstalled() throws IOException;\n+\n+    /**\n+     * Read build file(s) to check if an extension is installed in this Quarkus project.\n+     *\n+     * @param key the {@link AppArtifactKey} of the extension to check\n+     * @return true if it's installed\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    default boolean isInstalled(AppArtifactKey key) throws IOException {\n+        return getInstalled().stream().anyMatch(i -> Objects.equals(i.getKey(), key));\n+    }\n+\n+    /**\n+     * Check that the Quarkus Platform bom is defined in the project.\n+     * The Quarkus Platform Bom role is to define version to use for Quarkus extensions.\n+     *\n+     * @return true if it's defined, false else\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    boolean hasQuarkusPlatformBom() throws IOException;\n+\n+    /**\n+     * This is going to install/add all the specified extensions to the project build file(s).\n+     *\n+     * <pre>\n+     *   - If the project Quarkus platform bom is not defined, an {@link IllegalStateException} will be thrown\n+     *   - Extensions which are already installed will ALWAYS be skipped whatever the specified version\n+     *   - The provided version will be used wasn't already installed\n+     * </pre>\n+     *\n+     * @param coords the list of {@link AppArtifactCoords} for the extensions to install\n+     * @return the {@link InstallResult}\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    InstallResult install(List<AppArtifactCoords> coords) throws IOException;\n+\n+    /**\n+     * This is going to uninstall/remove all the specified extensions from the project build file(s).\n+     *\n+     * This is ignoring the {@link Extension} version\n+     *\n+     * @param keys the set of {@link AppArtifactKey} for the extensions to uninstall\n+     * @return the {@link InstallResult}\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    UninstallResult uninstall(Set<AppArtifactKey> keys) throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4315ce7b40fd2d6549394658a96c3f73173c305a"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ3MDc0Ng==", "bodyText": "I already answered for this, the Set already takes care of deduplicating, I would convert it to a Set just after if that's was not the case. I think it's ok this way.. @aloubyansky any thoughts?", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437470746", "createdAt": "2020-06-09T14:33:11Z", "author": {"login": "ia3andy"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionManager.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package io.quarkus.devtools.project.extensions;\n+\n+import io.quarkus.bootstrap.model.AppArtifactCoords;\n+import io.quarkus.bootstrap.model.AppArtifactKey;\n+import io.quarkus.dependencies.Extension;\n+import io.quarkus.devtools.project.BuildTool;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * This interface defines a high level way of managing (read/write) extensions in any QuarkusProject\n+ */\n+public interface ExtensionManager {\n+\n+    /**\n+     * @return the {@link BuildTool} of this extension manager\n+     */\n+    BuildTool getBuildTool();\n+\n+    /**\n+     * Read the build file(s) to get the list of installed extensions in this Quarkus project.\n+     *\n+     * @return The list of {@link AppArtifactCoords} installed in the project build file(s).\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    List<AppArtifactCoords> getInstalled() throws IOException;\n+\n+    /**\n+     * Read build file(s) to check if an extension is installed in this Quarkus project.\n+     *\n+     * @param key the {@link AppArtifactKey} of the extension to check\n+     * @return true if it's installed\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    default boolean isInstalled(AppArtifactKey key) throws IOException {\n+        return getInstalled().stream().anyMatch(i -> Objects.equals(i.getKey(), key));\n+    }\n+\n+    /**\n+     * Check that the Quarkus Platform bom is defined in the project.\n+     * The Quarkus Platform Bom role is to define version to use for Quarkus extensions.\n+     *\n+     * @return true if it's defined, false else\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    boolean hasQuarkusPlatformBom() throws IOException;\n+\n+    /**\n+     * This is going to install/add all the specified extensions to the project build file(s).\n+     *\n+     * <pre>\n+     *   - If the project Quarkus platform bom is not defined, an {@link IllegalStateException} will be thrown\n+     *   - Extensions which are already installed will ALWAYS be skipped whatever the specified version\n+     *   - The provided version will be used wasn't already installed\n+     * </pre>\n+     *\n+     * @param coords the list of {@link AppArtifactCoords} for the extensions to install\n+     * @return the {@link InstallResult}\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    InstallResult install(List<AppArtifactCoords> coords) throws IOException;\n+\n+    /**\n+     * This is going to uninstall/remove all the specified extensions from the project build file(s).\n+     *\n+     * This is ignoring the {@link Extension} version\n+     *\n+     * @param keys the set of {@link AppArtifactKey} for the extensions to uninstall\n+     * @return the {@link InstallResult}\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    UninstallResult uninstall(Set<AppArtifactKey> keys) throws IOException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ2ODk4OA=="}, "originalCommit": {"oid": "4315ce7b40fd2d6549394658a96c3f73173c305a"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUyNzIyOQ==", "bodyText": "The use of Set might be because of making sure the items are unique? - if not I'm also for unifying on either List/Set/Collection.", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437527229", "createdAt": "2020-06-09T15:36:24Z", "author": {"login": "stalep"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionManager.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package io.quarkus.devtools.project.extensions;\n+\n+import io.quarkus.bootstrap.model.AppArtifactCoords;\n+import io.quarkus.bootstrap.model.AppArtifactKey;\n+import io.quarkus.dependencies.Extension;\n+import io.quarkus.devtools.project.BuildTool;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * This interface defines a high level way of managing (read/write) extensions in any QuarkusProject\n+ */\n+public interface ExtensionManager {\n+\n+    /**\n+     * @return the {@link BuildTool} of this extension manager\n+     */\n+    BuildTool getBuildTool();\n+\n+    /**\n+     * Read the build file(s) to get the list of installed extensions in this Quarkus project.\n+     *\n+     * @return The list of {@link AppArtifactCoords} installed in the project build file(s).\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    List<AppArtifactCoords> getInstalled() throws IOException;\n+\n+    /**\n+     * Read build file(s) to check if an extension is installed in this Quarkus project.\n+     *\n+     * @param key the {@link AppArtifactKey} of the extension to check\n+     * @return true if it's installed\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    default boolean isInstalled(AppArtifactKey key) throws IOException {\n+        return getInstalled().stream().anyMatch(i -> Objects.equals(i.getKey(), key));\n+    }\n+\n+    /**\n+     * Check that the Quarkus Platform bom is defined in the project.\n+     * The Quarkus Platform Bom role is to define version to use for Quarkus extensions.\n+     *\n+     * @return true if it's defined, false else\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    boolean hasQuarkusPlatformBom() throws IOException;\n+\n+    /**\n+     * This is going to install/add all the specified extensions to the project build file(s).\n+     *\n+     * <pre>\n+     *   - If the project Quarkus platform bom is not defined, an {@link IllegalStateException} will be thrown\n+     *   - Extensions which are already installed will ALWAYS be skipped whatever the specified version\n+     *   - The provided version will be used wasn't already installed\n+     * </pre>\n+     *\n+     * @param coords the list of {@link AppArtifactCoords} for the extensions to install\n+     * @return the {@link InstallResult}\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    InstallResult install(List<AppArtifactCoords> coords) throws IOException;\n+\n+    /**\n+     * This is going to uninstall/remove all the specified extensions from the project build file(s).\n+     *\n+     * This is ignoring the {@link Extension} version\n+     *\n+     * @param keys the set of {@link AppArtifactKey} for the extensions to uninstall\n+     * @return the {@link InstallResult}\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    UninstallResult uninstall(Set<AppArtifactKey> keys) throws IOException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ2ODk4OA=="}, "originalCommit": {"oid": "4315ce7b40fd2d6549394658a96c3f73173c305a"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTM0MzAxOnYy", "diffSide": "RIGHT", "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDozMTozNVrOGhNBLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDozNDozMFrOGhNJuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ2OTQ4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                List<AppArtifactCoords> getInstalled() throws IOException;\n          \n          \n            \n                Collection<AppArtifactCoords> getInstalled() throws IOException;", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437469487", "createdAt": "2020-06-09T14:31:35Z", "author": {"login": "gastaldi"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionManager.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package io.quarkus.devtools.project.extensions;\n+\n+import io.quarkus.bootstrap.model.AppArtifactCoords;\n+import io.quarkus.bootstrap.model.AppArtifactKey;\n+import io.quarkus.dependencies.Extension;\n+import io.quarkus.devtools.project.BuildTool;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * This interface defines a high level way of managing (read/write) extensions in any QuarkusProject\n+ */\n+public interface ExtensionManager {\n+\n+    /**\n+     * @return the {@link BuildTool} of this extension manager\n+     */\n+    BuildTool getBuildTool();\n+\n+    /**\n+     * Read the build file(s) to get the list of installed extensions in this Quarkus project.\n+     *\n+     * @return The list of {@link AppArtifactCoords} installed in the project build file(s).\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    List<AppArtifactCoords> getInstalled() throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4315ce7b40fd2d6549394658a96c3f73173c305a"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ3MTY3NQ==", "bodyText": "Same here you have the notion of order..", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437471675", "createdAt": "2020-06-09T14:34:30Z", "author": {"login": "ia3andy"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionManager.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package io.quarkus.devtools.project.extensions;\n+\n+import io.quarkus.bootstrap.model.AppArtifactCoords;\n+import io.quarkus.bootstrap.model.AppArtifactKey;\n+import io.quarkus.dependencies.Extension;\n+import io.quarkus.devtools.project.BuildTool;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * This interface defines a high level way of managing (read/write) extensions in any QuarkusProject\n+ */\n+public interface ExtensionManager {\n+\n+    /**\n+     * @return the {@link BuildTool} of this extension manager\n+     */\n+    BuildTool getBuildTool();\n+\n+    /**\n+     * Read the build file(s) to get the list of installed extensions in this Quarkus project.\n+     *\n+     * @return The list of {@link AppArtifactCoords} installed in the project build file(s).\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    List<AppArtifactCoords> getInstalled() throws IOException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ2OTQ4Nw=="}, "originalCommit": {"oid": "4315ce7b40fd2d6549394658a96c3f73173c305a"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTQwNjk4OnYy", "diffSide": "RIGHT", "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDo0NDo1NFrOGhNp2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDo1MzoyN1rOGhOEhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ3OTg5Ng==", "bodyText": "Instead of returning how many extensions were installed/uninstalled wouldn't be better to return which extensions were installed/uninstalled (the collection size would return the total of installed/uninstalled items)?", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437479896", "createdAt": "2020-06-09T14:44:54Z", "author": {"login": "gastaldi"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionManager.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package io.quarkus.devtools.project.extensions;\n+\n+import io.quarkus.bootstrap.model.AppArtifactCoords;\n+import io.quarkus.bootstrap.model.AppArtifactKey;\n+import io.quarkus.dependencies.Extension;\n+import io.quarkus.devtools.project.BuildTool;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * This interface defines a high level way of managing (read/write) extensions in any QuarkusProject\n+ */\n+public interface ExtensionManager {\n+\n+    /**\n+     * @return the {@link BuildTool} of this extension manager\n+     */\n+    BuildTool getBuildTool();\n+\n+    /**\n+     * Read the build file(s) to get the list of installed extensions in this Quarkus project.\n+     *\n+     * @return The list of {@link AppArtifactCoords} installed in the project build file(s).\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    List<AppArtifactCoords> getInstalled() throws IOException;\n+\n+    /**\n+     * Read build file(s) to check if an extension is installed in this Quarkus project.\n+     *\n+     * @param key the {@link AppArtifactKey} of the extension to check\n+     * @return true if it's installed\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    default boolean isInstalled(AppArtifactKey key) throws IOException {\n+        return getInstalled().stream().anyMatch(i -> Objects.equals(i.getKey(), key));\n+    }\n+\n+    /**\n+     * Check that the Quarkus Platform bom is defined in the project.\n+     * The Quarkus Platform Bom role is to define version to use for Quarkus extensions.\n+     *\n+     * @return true if it's defined, false else\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    boolean hasQuarkusPlatformBom() throws IOException;\n+\n+    /**\n+     * This is going to install/add all the specified extensions to the project build file(s).\n+     *\n+     * <pre>\n+     *   - If the project Quarkus platform bom is not defined, an {@link IllegalStateException} will be thrown\n+     *   - Extensions which are already installed will ALWAYS be skipped whatever the specified version\n+     *   - The provided version will be used wasn't already installed\n+     * </pre>\n+     *\n+     * @param coords the list of {@link AppArtifactCoords} for the extensions to install\n+     * @return the {@link InstallResult}\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    InstallResult install(List<AppArtifactCoords> coords) throws IOException;\n+\n+    /**\n+     * This is going to uninstall/remove all the specified extensions from the project build file(s).\n+     *\n+     * This is ignoring the {@link Extension} version\n+     *\n+     * @param keys the set of {@link AppArtifactKey} for the extensions to uninstall\n+     * @return the {@link InstallResult}\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    UninstallResult uninstall(Set<AppArtifactKey> keys) throws IOException;\n+\n+    class InstallResult {\n+        private final int installed;\n+\n+        public InstallResult(int installed) {\n+            this.installed = installed;\n+        }\n+\n+        public int getInstalled() {\n+            return installed;\n+        }\n+\n+        public boolean isSourceUpdated() {\n+            return installed > 0;\n+        }\n+    }\n+\n+    class UninstallResult {\n+        private final int uninstalled;\n+\n+        public UninstallResult(int uninstalled) {\n+            this.uninstalled = uninstalled;\n+        }\n+\n+        public int getUninstalled() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4315ce7b40fd2d6549394658a96c3f73173c305a"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ4MDgyNQ==", "bodyText": "@gastaldi that's a good idea! and it could be done without changing the contract. Let's do it in another PR.", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437480825", "createdAt": "2020-06-09T14:45:57Z", "author": {"login": "ia3andy"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionManager.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package io.quarkus.devtools.project.extensions;\n+\n+import io.quarkus.bootstrap.model.AppArtifactCoords;\n+import io.quarkus.bootstrap.model.AppArtifactKey;\n+import io.quarkus.dependencies.Extension;\n+import io.quarkus.devtools.project.BuildTool;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * This interface defines a high level way of managing (read/write) extensions in any QuarkusProject\n+ */\n+public interface ExtensionManager {\n+\n+    /**\n+     * @return the {@link BuildTool} of this extension manager\n+     */\n+    BuildTool getBuildTool();\n+\n+    /**\n+     * Read the build file(s) to get the list of installed extensions in this Quarkus project.\n+     *\n+     * @return The list of {@link AppArtifactCoords} installed in the project build file(s).\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    List<AppArtifactCoords> getInstalled() throws IOException;\n+\n+    /**\n+     * Read build file(s) to check if an extension is installed in this Quarkus project.\n+     *\n+     * @param key the {@link AppArtifactKey} of the extension to check\n+     * @return true if it's installed\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    default boolean isInstalled(AppArtifactKey key) throws IOException {\n+        return getInstalled().stream().anyMatch(i -> Objects.equals(i.getKey(), key));\n+    }\n+\n+    /**\n+     * Check that the Quarkus Platform bom is defined in the project.\n+     * The Quarkus Platform Bom role is to define version to use for Quarkus extensions.\n+     *\n+     * @return true if it's defined, false else\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    boolean hasQuarkusPlatformBom() throws IOException;\n+\n+    /**\n+     * This is going to install/add all the specified extensions to the project build file(s).\n+     *\n+     * <pre>\n+     *   - If the project Quarkus platform bom is not defined, an {@link IllegalStateException} will be thrown\n+     *   - Extensions which are already installed will ALWAYS be skipped whatever the specified version\n+     *   - The provided version will be used wasn't already installed\n+     * </pre>\n+     *\n+     * @param coords the list of {@link AppArtifactCoords} for the extensions to install\n+     * @return the {@link InstallResult}\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    InstallResult install(List<AppArtifactCoords> coords) throws IOException;\n+\n+    /**\n+     * This is going to uninstall/remove all the specified extensions from the project build file(s).\n+     *\n+     * This is ignoring the {@link Extension} version\n+     *\n+     * @param keys the set of {@link AppArtifactKey} for the extensions to uninstall\n+     * @return the {@link InstallResult}\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    UninstallResult uninstall(Set<AppArtifactKey> keys) throws IOException;\n+\n+    class InstallResult {\n+        private final int installed;\n+\n+        public InstallResult(int installed) {\n+            this.installed = installed;\n+        }\n+\n+        public int getInstalled() {\n+            return installed;\n+        }\n+\n+        public boolean isSourceUpdated() {\n+            return installed > 0;\n+        }\n+    }\n+\n+    class UninstallResult {\n+        private final int uninstalled;\n+\n+        public UninstallResult(int uninstalled) {\n+            this.uninstalled = uninstalled;\n+        }\n+\n+        public int getUninstalled() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ3OTg5Ng=="}, "originalCommit": {"oid": "4315ce7b40fd2d6549394658a96c3f73173c305a"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ4NjcyNQ==", "bodyText": "yeah and I need to print it too, it's not printed anymore when installing/uninstalling.. i'll create an issue as soon as we merge that one.", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437486725", "createdAt": "2020-06-09T14:53:27Z", "author": {"login": "ia3andy"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/extensions/ExtensionManager.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package io.quarkus.devtools.project.extensions;\n+\n+import io.quarkus.bootstrap.model.AppArtifactCoords;\n+import io.quarkus.bootstrap.model.AppArtifactKey;\n+import io.quarkus.dependencies.Extension;\n+import io.quarkus.devtools.project.BuildTool;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * This interface defines a high level way of managing (read/write) extensions in any QuarkusProject\n+ */\n+public interface ExtensionManager {\n+\n+    /**\n+     * @return the {@link BuildTool} of this extension manager\n+     */\n+    BuildTool getBuildTool();\n+\n+    /**\n+     * Read the build file(s) to get the list of installed extensions in this Quarkus project.\n+     *\n+     * @return The list of {@link AppArtifactCoords} installed in the project build file(s).\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    List<AppArtifactCoords> getInstalled() throws IOException;\n+\n+    /**\n+     * Read build file(s) to check if an extension is installed in this Quarkus project.\n+     *\n+     * @param key the {@link AppArtifactKey} of the extension to check\n+     * @return true if it's installed\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    default boolean isInstalled(AppArtifactKey key) throws IOException {\n+        return getInstalled().stream().anyMatch(i -> Objects.equals(i.getKey(), key));\n+    }\n+\n+    /**\n+     * Check that the Quarkus Platform bom is defined in the project.\n+     * The Quarkus Platform Bom role is to define version to use for Quarkus extensions.\n+     *\n+     * @return true if it's defined, false else\n+     * @throws IOException if a problem occurs while reading the project build file(s)\n+     */\n+    boolean hasQuarkusPlatformBom() throws IOException;\n+\n+    /**\n+     * This is going to install/add all the specified extensions to the project build file(s).\n+     *\n+     * <pre>\n+     *   - If the project Quarkus platform bom is not defined, an {@link IllegalStateException} will be thrown\n+     *   - Extensions which are already installed will ALWAYS be skipped whatever the specified version\n+     *   - The provided version will be used wasn't already installed\n+     * </pre>\n+     *\n+     * @param coords the list of {@link AppArtifactCoords} for the extensions to install\n+     * @return the {@link InstallResult}\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    InstallResult install(List<AppArtifactCoords> coords) throws IOException;\n+\n+    /**\n+     * This is going to uninstall/remove all the specified extensions from the project build file(s).\n+     *\n+     * This is ignoring the {@link Extension} version\n+     *\n+     * @param keys the set of {@link AppArtifactKey} for the extensions to uninstall\n+     * @return the {@link InstallResult}\n+     * @throws IOException if a problem occurs while reading/writing the project build file(s)\n+     */\n+    UninstallResult uninstall(Set<AppArtifactKey> keys) throws IOException;\n+\n+    class InstallResult {\n+        private final int installed;\n+\n+        public InstallResult(int installed) {\n+            this.installed = installed;\n+        }\n+\n+        public int getInstalled() {\n+            return installed;\n+        }\n+\n+        public boolean isSourceUpdated() {\n+            return installed > 0;\n+        }\n+    }\n+\n+    class UninstallResult {\n+        private final int uninstalled;\n+\n+        public UninstallResult(int uninstalled) {\n+            this.uninstalled = uninstalled;\n+        }\n+\n+        public int getUninstalled() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ3OTg5Ng=="}, "originalCommit": {"oid": "4315ce7b40fd2d6549394658a96c3f73173c305a"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTUzODc5OnYy", "diffSide": "RIGHT", "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/commands/AddExtensions.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToxMTozOVrOGhO_wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToxMTozOVrOGhO_wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUwMTg5MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String EXTENSIONS_MANAGER = ToolsUtils.dotJoin(ToolsConstants.QUARKUS, NAME, \"extensions-manager\");\n          \n          \n            \n                public static final String EXTENSION_MANAGER = ToolsUtils.dotJoin(ToolsConstants.QUARKUS, NAME, \"extension-manager\");", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437501890", "createdAt": "2020-06-09T15:11:39Z", "author": {"login": "gastaldi"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/commands/AddExtensions.java", "diffHunk": "@@ -13,19 +20,26 @@\n     public static final String NAME = \"add-extensions\";\n     public static final String EXTENSIONS = ToolsUtils.dotJoin(ToolsConstants.QUARKUS, NAME, \"extensions\");\n     public static final String OUTCOME_UPDATED = ToolsUtils.dotJoin(ToolsConstants.QUARKUS, NAME, \"outcome\", \"updated\");\n+    public static final String EXTENSIONS_MANAGER = ToolsUtils.dotJoin(ToolsConstants.QUARKUS, NAME, \"extensions-manager\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4315ce7b40fd2d6549394658a96c3f73173c305a"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTU1ODI3OnYy", "diffSide": "RIGHT", "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/buildfile/BuildFile.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToxMzo0N1rOGhPLKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToxMzo0N1rOGhPLKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUwNDgxMQ==", "bodyText": "Don't expose this method, because the Registry won't be treated as a List of Extensions in the future", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437504811", "createdAt": "2020-06-09T15:13:47Z", "author": {"login": "gastaldi"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/buildfile/BuildFile.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package io.quarkus.devtools.project.buildfile;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.quarkus.devtools.project.extensions.Extensions.findInRegistry;\n+import static io.quarkus.devtools.project.extensions.Extensions.toCoords;\n+import static io.quarkus.devtools.project.extensions.Extensions.toKey;\n+import static java.util.stream.Collectors.toList;\n+\n+import io.quarkus.bootstrap.model.AppArtifactCoords;\n+import io.quarkus.bootstrap.model.AppArtifactKey;\n+import io.quarkus.dependencies.Extension;\n+import io.quarkus.devtools.project.extensions.ExtensionManager;\n+import io.quarkus.devtools.project.extensions.Extensions;\n+import io.quarkus.platform.descriptor.QuarkusPlatformDescriptor;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.LongAdder;\n+import java.util.stream.Collectors;\n+import org.apache.maven.model.Dependency;\n+\n+public abstract class BuildFile<T> implements ExtensionManager {\n+\n+    private final Path projectFolderPath;\n+    private final QuarkusPlatformDescriptor platformDescriptor;\n+\n+    public BuildFile(final Path projectFolderPath, final QuarkusPlatformDescriptor platformDescriptor) {\n+        this.projectFolderPath = checkNotNull(projectFolderPath, \"projectPath is required\");\n+        this.platformDescriptor = checkNotNull(platformDescriptor, \"platformDescriptor is required\");\n+    }\n+\n+    @Override\n+    public final boolean hasQuarkusPlatformBom() throws IOException {\n+        return containsBOM(platformDescriptor.getBomGroupId(), platformDescriptor.getBomArtifactId());\n+    }\n+\n+    @Override\n+    public final InstallResult install(List<AppArtifactCoords> coords) throws IOException {\n+        if (!hasQuarkusPlatformBom()) {\n+            throw new IllegalStateException(\"The Quarkus BOM is required to add a Quarkus extension\");\n+        }\n+        this.refreshData();\n+        final Set<AppArtifactKey> existingKeys = getDependenciesKeys();\n+        final LongAdder counter = new LongAdder();\n+        coords.stream()\n+                .filter(a -> !existingKeys.contains(a.getKey()))\n+                .forEach(e -> {\n+                    try {\n+                        addDependencyInBuildFile(e);\n+                        counter.increment();\n+                    } catch (IOException ex) {\n+                        throw new UncheckedIOException(ex);\n+                    }\n+                });\n+        this.writeToDisk();\n+        return new InstallResult(counter.intValue());\n+    }\n+\n+    @Override\n+    public final List<AppArtifactCoords> getInstalled() throws IOException {\n+        this.refreshData();\n+        return this.getDependencies().stream()\n+                .filter(d -> this.isQuarkusExtension(toKey(d)))\n+                .map(d -> toCoords(d, extractVersion(d)))\n+                .collect(toList());\n+    }\n+\n+    @Override\n+    public final UninstallResult uninstall(Set<AppArtifactKey> keys) throws IOException {\n+        this.refreshData();\n+        final Set<AppArtifactKey> existingKeys = getDependenciesKeys();\n+        final LongAdder counter = new LongAdder();\n+        keys.stream()\n+                .filter(existingKeys::contains)\n+                .forEach(k -> {\n+                    try {\n+                        removeDependencyFromBuildFile(k);\n+                        counter.increment();\n+                    } catch (IOException ex) {\n+                        throw new UncheckedIOException(ex);\n+                    }\n+                });\n+        this.writeToDisk();\n+        return new UninstallResult(counter.intValue());\n+    }\n+\n+    protected abstract void addDependencyInBuildFile(AppArtifactCoords coords) throws IOException;\n+\n+    protected abstract void removeDependencyFromBuildFile(AppArtifactKey key) throws IOException;\n+\n+    protected abstract List<Dependency> getDependencies() throws IOException;\n+\n+    protected abstract void writeToDisk() throws IOException;\n+\n+    protected abstract String getProperty(String propertyName) throws IOException;\n+\n+    protected abstract boolean containsBOM(String groupId, String artifactId) throws IOException;\n+\n+    protected abstract void refreshData();\n+\n+    protected Path getProjectFolderPath() {\n+        return projectFolderPath;\n+    }\n+\n+    protected boolean hasProjectFile(final String fileName) throws IOException {\n+        final Path filePath = projectFolderPath.resolve(fileName);\n+        return Files.exists(filePath);\n+    }\n+\n+    protected byte[] readProjectFile(final String fileName) throws IOException {\n+        final Path filePath = projectFolderPath.resolve(fileName);\n+        return Files.readAllBytes(filePath);\n+    }\n+\n+    protected void writeToProjectFile(final String fileName, final byte[] content) throws IOException {\n+        Files.write(projectFolderPath.resolve(fileName), content);\n+    }\n+\n+    private boolean isQuarkusExtension(final AppArtifactKey key) {\n+        // This will not always be true as the platform descriptor does not contain the list of all available extensions\n+        return isDefinedInRegistry(platformDescriptor.getExtensions(), key);\n+    }\n+\n+    private Set<AppArtifactKey> getDependenciesKeys() throws IOException {\n+        return getDependencies().stream().map(Extensions::toKey).collect(Collectors.toSet());\n+    }\n+\n+    private String extractVersion(final Dependency d) {\n+        String version = d != null ? d.getVersion() : null;\n+        if (version != null && version.startsWith(\"$\")) {\n+            String value = null;\n+            try {\n+                value = (String) this.getProperty(propertyName(version));\n+                if (value != null) {\n+                    return value;\n+                }\n+            } catch (IOException e) {\n+                // ignore this error.\n+            }\n+        }\n+        if (version != null) {\n+            return version;\n+        }\n+        return null;\n+    }\n+\n+    private String propertyName(final String variable) {\n+        return variable.substring(2, variable.length() - 1);\n+    }\n+\n+    public static boolean isDefinedInRegistry(List<Extension> registry, final AppArtifactKey key) {\n+        return findInRegistry(registry, key).isPresent();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4315ce7b40fd2d6549394658a96c3f73173c305a"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTY2MDg0OnYy", "diffSide": "RIGHT", "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/codegen/writer/FileProjectWriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToyNzowOFrOGhQIxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToyNzowOFrOGhQIxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUyMDU4Mg==", "bodyText": "Nice!", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437520582", "createdAt": "2020-06-09T15:27:08Z", "author": {"login": "gastaldi"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/codegen/writer/FileProjectWriter.java", "diffHunk": "@@ -19,21 +19,21 @@ public FileProjectWriter(final File file) {\n     }\n \n     @Override\n-    public boolean init() {\n-        if (root.exists() && !root.isDirectory()) {\n-            System.out.println(\"Project root needs to either not exist or be a directory\");\n-            return false;\n-        } else if (!root.exists()) {\n+    public void init() throws IOException {\n+        if (!root.exists()) {\n             boolean mkdirStatus = root.mkdirs();\n             if (!mkdirStatus) {\n-                System.out.println(\"Failed to create root directory\");\n-                return false;\n+                throw new IOException(\"Failed to create root directory\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4315ce7b40fd2d6549394658a96c3f73173c305a"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTY2NDM1OnYy", "diffSide": "RIGHT", "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/codegen/writer/FileProjectWriter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToyNzo1N1rOGhQLCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToyNzo1N1rOGhQLCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUyMTE2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IOException(\"Project root needs to either not exist or be a directory\");\n          \n          \n            \n                        throw new IOException(\"Project root needs to be a directory\");", "url": "https://github.com/quarkusio/quarkus/pull/9787#discussion_r437521162", "createdAt": "2020-06-09T15:27:57Z", "author": {"login": "gastaldi"}, "path": "independent-projects/tools/common/src/main/java/io/quarkus/devtools/project/codegen/writer/FileProjectWriter.java", "diffHunk": "@@ -19,21 +19,21 @@ public FileProjectWriter(final File file) {\n     }\n \n     @Override\n-    public boolean init() {\n-        if (root.exists() && !root.isDirectory()) {\n-            System.out.println(\"Project root needs to either not exist or be a directory\");\n-            return false;\n-        } else if (!root.exists()) {\n+    public void init() throws IOException {\n+        if (!root.exists()) {\n             boolean mkdirStatus = root.mkdirs();\n             if (!mkdirStatus) {\n-                System.out.println(\"Failed to create root directory\");\n-                return false;\n+                throw new IOException(\"Failed to create root directory\");\n             }\n+            return;\n+        }\n+        if (!root.isDirectory()) {\n+            throw new IOException(\"Project root needs to either not exist or be a directory\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4315ce7b40fd2d6549394658a96c3f73173c305a"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2945, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}