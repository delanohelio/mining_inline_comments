{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyOTE1NTEy", "number": 7109, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMDo1NjozN1rODgLVAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMDozNzo1MFrODlXx9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDY2NjI2OnYy", "diffSide": "RIGHT", "path": "extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/filters/GracefulShutdownFilter.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMDo1NjozN1rOFqQi9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMDo0MzowMFrOFyOm7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NTYwNg==", "bodyText": "@vietj is there a better way to handle this?\nBasically I need a reliable way to know when a request is done so I know how many requests are running (that can't be overridden in a downstream handler), and wrapping the request and response like this was the only way I could figure out to do it.", "url": "https://github.com/quarkusio/quarkus/pull/7109#discussion_r379855606", "createdAt": "2020-02-15T20:56:37Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/filters/GracefulShutdownFilter.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package io.quarkus.vertx.http.runtime.filters;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.quarkus.runtime.shutdown.ShutdownListener;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpServerRequest;\n+\n+public class GracefulShutdownFilter implements ShutdownListener, Handler<HttpServerRequest> {\n+\n+    private static Logger log = Logger.getLogger(GracefulShutdownFilter.class);\n+\n+    private volatile Handler<HttpServerRequest> next;\n+    private volatile boolean running = true;\n+    private final AtomicInteger currentRequestCount = new AtomicInteger();\n+    private final AtomicReference<ShutdownNotification> notification = new AtomicReference<>();\n+\n+    private final Handler<Void> requestDoneHandler = new Handler<Void>() {\n+        @Override\n+        public void handle(Void event) {\n+            int count = currentRequestCount.decrementAndGet();\n+            if (!running) {\n+                if (count == 0) {\n+                    ShutdownNotification n = notification.get();\n+                    if (n != null) {\n+                        if (notification.compareAndSet(n, null)) {\n+                            n.done();\n+                            log.info(\"All HTTP requests complete\");\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    };\n+\n+    @Override\n+    public void handle(HttpServerRequest event) {\n+        if (!running) {\n+            event.response().setStatusCode(HttpResponseStatus.SERVICE_UNAVAILABLE.code()).end();\n+            return;\n+        }\n+        currentRequestCount.incrementAndGet();\n+        //todo: some way to do this without a wrapper solution\n+        next.handle(new ShutdownRequestWrapper(event, requestDoneHandler));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0688ab38451b4432ba91222a67d986f1a82b5d4e"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIxMTkzOA==", "bodyText": "on the HTTP Server Response, you can attach a https://vertx.io/docs/apidocs/io/vertx/core/http/HttpServerResponse.html#endHandler-io.vertx.core.Handler- to be notified when the response has been written.", "url": "https://github.com/quarkusio/quarkus/pull/7109#discussion_r388211938", "createdAt": "2020-03-05T10:42:04Z", "author": {"login": "cescoffier"}, "path": "extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/filters/GracefulShutdownFilter.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package io.quarkus.vertx.http.runtime.filters;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.quarkus.runtime.shutdown.ShutdownListener;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpServerRequest;\n+\n+public class GracefulShutdownFilter implements ShutdownListener, Handler<HttpServerRequest> {\n+\n+    private static Logger log = Logger.getLogger(GracefulShutdownFilter.class);\n+\n+    private volatile Handler<HttpServerRequest> next;\n+    private volatile boolean running = true;\n+    private final AtomicInteger currentRequestCount = new AtomicInteger();\n+    private final AtomicReference<ShutdownNotification> notification = new AtomicReference<>();\n+\n+    private final Handler<Void> requestDoneHandler = new Handler<Void>() {\n+        @Override\n+        public void handle(Void event) {\n+            int count = currentRequestCount.decrementAndGet();\n+            if (!running) {\n+                if (count == 0) {\n+                    ShutdownNotification n = notification.get();\n+                    if (n != null) {\n+                        if (notification.compareAndSet(n, null)) {\n+                            n.done();\n+                            log.info(\"All HTTP requests complete\");\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    };\n+\n+    @Override\n+    public void handle(HttpServerRequest event) {\n+        if (!running) {\n+            event.response().setStatusCode(HttpResponseStatus.SERVICE_UNAVAILABLE.code()).end();\n+            return;\n+        }\n+        currentRequestCount.incrementAndGet();\n+        //todo: some way to do this without a wrapper solution\n+        next.handle(new ShutdownRequestWrapper(event, requestDoneHandler));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NTYwNg=="}, "originalCommit": {"oid": "0688ab38451b4432ba91222a67d986f1a82b5d4e"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIxMjQ2MQ==", "bodyText": "It would need to be coupled with the closeHandler when the connection is closed (abruptly).", "url": "https://github.com/quarkusio/quarkus/pull/7109#discussion_r388212461", "createdAt": "2020-03-05T10:43:00Z", "author": {"login": "cescoffier"}, "path": "extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/filters/GracefulShutdownFilter.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package io.quarkus.vertx.http.runtime.filters;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.quarkus.runtime.shutdown.ShutdownListener;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpServerRequest;\n+\n+public class GracefulShutdownFilter implements ShutdownListener, Handler<HttpServerRequest> {\n+\n+    private static Logger log = Logger.getLogger(GracefulShutdownFilter.class);\n+\n+    private volatile Handler<HttpServerRequest> next;\n+    private volatile boolean running = true;\n+    private final AtomicInteger currentRequestCount = new AtomicInteger();\n+    private final AtomicReference<ShutdownNotification> notification = new AtomicReference<>();\n+\n+    private final Handler<Void> requestDoneHandler = new Handler<Void>() {\n+        @Override\n+        public void handle(Void event) {\n+            int count = currentRequestCount.decrementAndGet();\n+            if (!running) {\n+                if (count == 0) {\n+                    ShutdownNotification n = notification.get();\n+                    if (n != null) {\n+                        if (notification.compareAndSet(n, null)) {\n+                            n.done();\n+                            log.info(\"All HTTP requests complete\");\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    };\n+\n+    @Override\n+    public void handle(HttpServerRequest event) {\n+        if (!running) {\n+            event.response().setStatusCode(HttpResponseStatus.SERVICE_UNAVAILABLE.code()).end();\n+            return;\n+        }\n+        currentRequestCount.incrementAndGet();\n+        //todo: some way to do this without a wrapper solution\n+        next.handle(new ShutdownRequestWrapper(event, requestDoneHandler));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NTYwNg=="}, "originalCommit": {"oid": "0688ab38451b4432ba91222a67d986f1a82b5d4e"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5Njg4NzQxOnYy", "diffSide": "RIGHT", "path": "core/runtime/src/main/java/io/quarkus/runtime/shutdown/ShutdownConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMDowMzo1MFrOFw_Uhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMDowMzo1MFrOFw_Uhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjkxMzQxNA==", "bodyText": "Maybe add a runtime config phase so that it is runtime overridable?", "url": "https://github.com/quarkusio/quarkus/pull/7109#discussion_r386913414", "createdAt": "2020-03-03T10:03:50Z", "author": {"login": "machi1990"}, "path": "core/runtime/src/main/java/io/quarkus/runtime/shutdown/ShutdownConfig.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package io.quarkus.runtime.shutdown;\n+\n+import java.time.Duration;\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0688ab38451b4432ba91222a67d986f1a82b5d4e"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NjkxNjA4OnYy", "diffSide": "RIGHT", "path": "extensions/vertx-http/deployment/src/test/java/io/quarkus/vertx/http/shutdown/ShutdownTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMDoxMjoyM1rOFw_miQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMDoxMjoyM1rOFw_miQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjkxODAyNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Tests that shutddown will wait for current requests to finish.\n          \n          \n            \n             * Tests that shutdown will wait for current requests to finish.", "url": "https://github.com/quarkusio/quarkus/pull/7109#discussion_r386918025", "createdAt": "2020-03-03T10:12:23Z", "author": {"login": "machi1990"}, "path": "extensions/vertx-http/deployment/src/test/java/io/quarkus/vertx/http/shutdown/ShutdownTest.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package io.quarkus.vertx.http.shutdown;\n+\n+import java.io.IOException;\n+import java.net.Socket;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.function.Supplier;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.asset.StringAsset;\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import io.quarkus.test.QuarkusUnitTest;\n+import io.quarkus.test.common.http.TestHTTPResource;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.Router;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Tests that shutddown will wait for current requests to finish.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0688ab38451b4432ba91222a67d986f1a82b5d4e"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NjkyMDM5OnYy", "diffSide": "RIGHT", "path": "extensions/vertx-http/deployment/src/test/java/io/quarkus/vertx/http/shutdown/ShutdownTimeoutTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMDoxMzozNFrOFw_pHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMDoxMzozNFrOFw_pHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjkxODY4NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Tests that shutddown will wait for current requests to finish, up to the timeout specified.\n          \n          \n            \n             * Tests that shutdown will wait for current requests to finish, up to the timeout specified.", "url": "https://github.com/quarkusio/quarkus/pull/7109#discussion_r386918685", "createdAt": "2020-03-03T10:13:34Z", "author": {"login": "machi1990"}, "path": "extensions/vertx-http/deployment/src/test/java/io/quarkus/vertx/http/shutdown/ShutdownTimeoutTest.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package io.quarkus.vertx.http.shutdown;\n+\n+import java.io.IOException;\n+import java.net.Socket;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.function.Supplier;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.asset.StringAsset;\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import io.quarkus.test.QuarkusUnitTest;\n+import io.quarkus.test.common.http.TestHTTPResource;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.Router;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Tests that shutddown will wait for current requests to finish, up to the timeout specified.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0688ab38451b4432ba91222a67d986f1a82b5d4e"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTEyNjM0OnYy", "diffSide": "RIGHT", "path": "core/runtime/src/main/java/io/quarkus/runtime/shutdown/ShutdownListener.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMDozNTozNVrOFyOWsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMDo1ODo0M1rOFyPHqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwODMwNA==", "bodyText": "in terms of API, any reason to not return a CompletionStage?", "url": "https://github.com/quarkusio/quarkus/pull/7109#discussion_r388208304", "createdAt": "2020-03-05T10:35:35Z", "author": {"login": "cescoffier"}, "path": "core/runtime/src/main/java/io/quarkus/runtime/shutdown/ShutdownListener.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package io.quarkus.runtime.shutdown;\n+\n+/**\n+ * A listener that can be registered to control the shutdown process and implement\n+ * graceful shutdown.\n+ *\n+ * Shutdown happens in two phases. In the pre shutdown phase the application should\n+ * function normally, but should notify external systems that it is about to go away.\n+ *\n+ * In the shutdown phase the app should disallow new external requests, however\n+ * allow existing requests to complete normally.\n+ */\n+public interface ShutdownListener {\n+\n+    /**\n+     * Pre shutdown notification, the listener can use this to notify external\n+     * systems this application is about to shut down.\n+     * \n+     * @param notification The notification event\n+     */\n+    default void preShutdown(ShutdownNotification notification) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4239c357540c0d19d96095ff0ebc98affe950ace"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwODQ1OQ==", "bodyText": "Typically how are failures reported?", "url": "https://github.com/quarkusio/quarkus/pull/7109#discussion_r388208459", "createdAt": "2020-03-05T10:35:52Z", "author": {"login": "cescoffier"}, "path": "core/runtime/src/main/java/io/quarkus/runtime/shutdown/ShutdownListener.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package io.quarkus.runtime.shutdown;\n+\n+/**\n+ * A listener that can be registered to control the shutdown process and implement\n+ * graceful shutdown.\n+ *\n+ * Shutdown happens in two phases. In the pre shutdown phase the application should\n+ * function normally, but should notify external systems that it is about to go away.\n+ *\n+ * In the shutdown phase the app should disallow new external requests, however\n+ * allow existing requests to complete normally.\n+ */\n+public interface ShutdownListener {\n+\n+    /**\n+     * Pre shutdown notification, the listener can use this to notify external\n+     * systems this application is about to shut down.\n+     * \n+     * @param notification The notification event\n+     */\n+    default void preShutdown(ShutdownNotification notification) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwODMwNA=="}, "originalCommit": {"oid": "4239c357540c0d19d96095ff0ebc98affe950ace"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyMDg0Mw==", "bodyText": "Failures don't really matter, we are shutting down anyway, if a stage has failed then it needs to log and notify, so I am not sure if completion stage works here.", "url": "https://github.com/quarkusio/quarkus/pull/7109#discussion_r388220843", "createdAt": "2020-03-05T10:58:43Z", "author": {"login": "stuartwdouglas"}, "path": "core/runtime/src/main/java/io/quarkus/runtime/shutdown/ShutdownListener.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package io.quarkus.runtime.shutdown;\n+\n+/**\n+ * A listener that can be registered to control the shutdown process and implement\n+ * graceful shutdown.\n+ *\n+ * Shutdown happens in two phases. In the pre shutdown phase the application should\n+ * function normally, but should notify external systems that it is about to go away.\n+ *\n+ * In the shutdown phase the app should disallow new external requests, however\n+ * allow existing requests to complete normally.\n+ */\n+public interface ShutdownListener {\n+\n+    /**\n+     * Pre shutdown notification, the listener can use this to notify external\n+     * systems this application is about to shut down.\n+     * \n+     * @param notification The notification event\n+     */\n+    default void preShutdown(ShutdownNotification notification) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwODMwNA=="}, "originalCommit": {"oid": "4239c357540c0d19d96095ff0ebc98affe950ace"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNTEzNTI0OnYy", "diffSide": "RIGHT", "path": "extensions/smallrye-health/runtime/src/main/java/io/quarkus/smallrye/health/runtime/ShutdownReadinessCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMDozNzo1MFrOFyOb5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMDo1OTo0MlrOFyPJrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwOTYzNw==", "bodyText": "One day I would understand why sometimes we use @ApplicationScoped, and sometimes @singleton (I know it's not coming from the same spec, but still puzzled by when use which).", "url": "https://github.com/quarkusio/quarkus/pull/7109#discussion_r388209637", "createdAt": "2020-03-05T10:37:50Z", "author": {"login": "cescoffier"}, "path": "extensions/smallrye-health/runtime/src/main/java/io/quarkus/smallrye/health/runtime/ShutdownReadinessCheck.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package io.quarkus.smallrye.health.runtime;\n+\n+import javax.inject.Singleton;\n+\n+import org.eclipse.microprofile.health.HealthCheck;\n+import org.eclipse.microprofile.health.HealthCheckResponse;\n+import org.eclipse.microprofile.health.Readiness;\n+\n+@Singleton", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4239c357540c0d19d96095ff0ebc98affe950ace"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyMTM1Ng==", "bodyText": "ApplicationScoped requires a proxy to comply with the spec, Singleton is usually better, but because it is not actually in the CDI spec a lot of people just default to application scoped.", "url": "https://github.com/quarkusio/quarkus/pull/7109#discussion_r388221356", "createdAt": "2020-03-05T10:59:42Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/smallrye-health/runtime/src/main/java/io/quarkus/smallrye/health/runtime/ShutdownReadinessCheck.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package io.quarkus.smallrye.health.runtime;\n+\n+import javax.inject.Singleton;\n+\n+import org.eclipse.microprofile.health.HealthCheck;\n+import org.eclipse.microprofile.health.HealthCheckResponse;\n+import org.eclipse.microprofile.health.Readiness;\n+\n+@Singleton", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwOTYzNw=="}, "originalCommit": {"oid": "4239c357540c0d19d96095ff0ebc98affe950ace"}, "originalPosition": 9}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 950, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}