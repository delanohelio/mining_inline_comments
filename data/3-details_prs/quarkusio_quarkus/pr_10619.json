{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3MDY3NzY1", "number": 10619, "title": "Fix Spring Data JPA Query Methods for big hierarchy", "bodyText": "Fix Spring Data JPA Query Methods for big hierarchy.\nFixes #10581", "createdAt": "2020-07-09T20:07:08Z", "url": "https://github.com/quarkusio/quarkus/pull/10619", "merged": true, "mergeCommit": {"oid": "d7fa26d4cd7beababd8f7b93125dd02ac754dbd2"}, "closed": true, "closedAt": "2020-07-13T15:30:38Z", "author": {"login": "nebrass"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc0a31sAFqTQ0Njk5NDQ0MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc0heHFAFqTQ0NzI1MTA1OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTk0NDQw", "url": "https://github.com/quarkusio/quarkus/pull/10619#pullrequestreview-446994440", "createdAt": "2020-07-13T05:44:55Z", "commit": {"oid": "a28a523ed5f19d28b4c6280f9f21504348c77aec"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNTo0NDo1NlrOGwcLIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QwNTo0ODowNlrOGwcOrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ0NjQzMg==", "bodyText": "I think the entire contents of this if could be moved to a dedicated method.", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453446432", "createdAt": "2020-07-13T05:44:56Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -253,6 +255,74 @@ public Result parse(MethodInfo methodInfo) {\n \n             String upperPrefix = (ignoreCase || allIgnoreCase) ? \"UPPER(\" : \"\";\n             String upperSuffix = (ignoreCase || allIgnoreCase) ? \")\" : \"\";\n+\n+            // If the fieldName is not a field in the class and in camelcase format,\n+            // then split it as hierarchy of fields\n+            if (entityClass.field(fieldName) == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a28a523ed5f19d28b4c6280f9f21504348c77aec"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ0Njg1Mg==", "bodyText": "As it seems that indexView.getClassByName((entityClass.superClassType().name()) and indexView.getClassByName((fieldInfo.type().name()) are used a few times, best move them to a variable with a proper name", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453446852", "createdAt": "2020-07-13T05:46:13Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -253,6 +255,74 @@ public Result parse(MethodInfo methodInfo) {\n \n             String upperPrefix = (ignoreCase || allIgnoreCase) ? \"UPPER(\" : \"\";\n             String upperSuffix = (ignoreCase || allIgnoreCase) ? \")\" : \"\";\n+\n+            // If the fieldName is not a field in the class and in camelcase format,\n+            // then split it as hierarchy of fields\n+            if (entityClass.field(fieldName) == null) {\n+                StringBuilder finalName = new StringBuilder(fieldName);\n+\n+                Set<String> childFields = new HashSet<>();\n+\n+                childFields.addAll(entityClass.fields().stream()\n+                        .map(FieldInfo::name)\n+                        .collect(Collectors.toList()));\n+\n+                // Collecting the current class fields\n+                if (indexView.getClassByName(fieldInfo.type().name()) != null) {\n+                    childFields.addAll(\n+                            indexView.getClassByName(fieldInfo.type().name()).fields()\n+                                    .stream()\n+                                    .map(FieldInfo::name)\n+                                    .collect(Collectors.toList()));\n+                }\n+\n+                // Collecting the inherited fields from the superclass of the actual class\n+                if (entityClass.superClassType().name() != null &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a28a523ed5f19d28b4c6280f9f21504348c77aec"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ0NzI1Mg==", "bodyText": "Can we have a comment explaining this please?", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453447252", "createdAt": "2020-07-13T05:47:47Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -253,6 +255,74 @@ public Result parse(MethodInfo methodInfo) {\n \n             String upperPrefix = (ignoreCase || allIgnoreCase) ? \"UPPER(\" : \"\";\n             String upperSuffix = (ignoreCase || allIgnoreCase) ? \")\" : \"\";\n+\n+            // If the fieldName is not a field in the class and in camelcase format,\n+            // then split it as hierarchy of fields\n+            if (entityClass.field(fieldName) == null) {\n+                StringBuilder finalName = new StringBuilder(fieldName);\n+\n+                Set<String> childFields = new HashSet<>();\n+\n+                childFields.addAll(entityClass.fields().stream()\n+                        .map(FieldInfo::name)\n+                        .collect(Collectors.toList()));\n+\n+                // Collecting the current class fields\n+                if (indexView.getClassByName(fieldInfo.type().name()) != null) {\n+                    childFields.addAll(\n+                            indexView.getClassByName(fieldInfo.type().name()).fields()\n+                                    .stream()\n+                                    .map(FieldInfo::name)\n+                                    .collect(Collectors.toList()));\n+                }\n+\n+                // Collecting the inherited fields from the superclass of the actual class\n+                if (entityClass.superClassType().name() != null &&\n+                        indexView.getClassByName(entityClass.superClassType().name()) != null &&\n+                        indexView.getClassByName(fieldInfo.type().name()) != null &&\n+                        indexView.getClassByName(fieldInfo.type().name()).superClassType() != null) {\n+\n+                    childFields.addAll(indexView.getClassByName(entityClass.superClassType().name()).fields()\n+                            .stream()\n+                            .map(FieldInfo::name).collect(Collectors.toList()));\n+\n+                    childFields.addAll(indexView.getClassByName(\n+                            indexView.getClassByName(fieldInfo.type().name()).superClassType().name()).fields()\n+                            .stream()\n+                            .map(FieldInfo::name).collect(Collectors.toList()));\n+                }\n+\n+                // Collecting the inherited fields from the superclasses of the attributes\n+                if (indexView.getClassByName(fieldInfo.type().name()) != null &&\n+                        indexView.getClassByName(fieldInfo.type().name()).superClassType() != null &&\n+                        indexView.getClassByName(\n+                                indexView.getClassByName(fieldInfo.type().name()).superClassType().name()) != null) {\n+\n+                    childFields.addAll(\n+                            indexView.getClassByName(indexView.getClassByName(fieldInfo.type().name())\n+                                    .superClassType()\n+                                    .name())\n+                                    .fields()\n+                                    .stream()\n+                                    .map(FieldInfo::name).collect(Collectors.toList()));\n+                }\n+\n+                for (String fieldInf : childFields) {\n+                    if (StringUtils.containsIgnoreCase(fieldName, fieldInf)) {\n+                        String newValue = finalName.toString()\n+                                .replaceAll(\"(?i)\" + fieldInf, lowerFirstLetter(fieldInf) + \".\");\n+                        finalName.delete(0, finalName.length());\n+                        finalName.append(newValue);\n+                    }\n+                }\n+\n+                if (finalName.toString().charAt(finalName.length() - 1) == '.') {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a28a523ed5f19d28b4c6280f9f21504348c77aec"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ0NzM0Mg==", "bodyText": "A comment on what this section does would be nice", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453447342", "createdAt": "2020-07-13T05:48:06Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -253,6 +255,74 @@ public Result parse(MethodInfo methodInfo) {\n \n             String upperPrefix = (ignoreCase || allIgnoreCase) ? \"UPPER(\" : \"\";\n             String upperSuffix = (ignoreCase || allIgnoreCase) ? \")\" : \"\";\n+\n+            // If the fieldName is not a field in the class and in camelcase format,\n+            // then split it as hierarchy of fields\n+            if (entityClass.field(fieldName) == null) {\n+                StringBuilder finalName = new StringBuilder(fieldName);\n+\n+                Set<String> childFields = new HashSet<>();\n+\n+                childFields.addAll(entityClass.fields().stream()\n+                        .map(FieldInfo::name)\n+                        .collect(Collectors.toList()));\n+\n+                // Collecting the current class fields\n+                if (indexView.getClassByName(fieldInfo.type().name()) != null) {\n+                    childFields.addAll(\n+                            indexView.getClassByName(fieldInfo.type().name()).fields()\n+                                    .stream()\n+                                    .map(FieldInfo::name)\n+                                    .collect(Collectors.toList()));\n+                }\n+\n+                // Collecting the inherited fields from the superclass of the actual class\n+                if (entityClass.superClassType().name() != null &&\n+                        indexView.getClassByName(entityClass.superClassType().name()) != null &&\n+                        indexView.getClassByName(fieldInfo.type().name()) != null &&\n+                        indexView.getClassByName(fieldInfo.type().name()).superClassType() != null) {\n+\n+                    childFields.addAll(indexView.getClassByName(entityClass.superClassType().name()).fields()\n+                            .stream()\n+                            .map(FieldInfo::name).collect(Collectors.toList()));\n+\n+                    childFields.addAll(indexView.getClassByName(\n+                            indexView.getClassByName(fieldInfo.type().name()).superClassType().name()).fields()\n+                            .stream()\n+                            .map(FieldInfo::name).collect(Collectors.toList()));\n+                }\n+\n+                // Collecting the inherited fields from the superclasses of the attributes\n+                if (indexView.getClassByName(fieldInfo.type().name()) != null &&\n+                        indexView.getClassByName(fieldInfo.type().name()).superClassType() != null &&\n+                        indexView.getClassByName(\n+                                indexView.getClassByName(fieldInfo.type().name()).superClassType().name()) != null) {\n+\n+                    childFields.addAll(\n+                            indexView.getClassByName(indexView.getClassByName(fieldInfo.type().name())\n+                                    .superClassType()\n+                                    .name())\n+                                    .fields()\n+                                    .stream()\n+                                    .map(FieldInfo::name).collect(Collectors.toList()));\n+                }\n+\n+                for (String fieldInf : childFields) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a28a523ed5f19d28b4c6280f9f21504348c77aec"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MTcxNDk3", "url": "https://github.com/quarkusio/quarkus/pull/10619#pullrequestreview-447171497", "createdAt": "2020-07-13T11:38:13Z", "commit": {"oid": "e309f711d078fc641c975bb84d2cb5922b8a614f"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMTozODoxM1rOGwk0jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMTozOToyMlrOGwk2pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODExMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // In some cases; the built hierarchy is ending by a joining point. so we need to remove it\n          \n          \n            \n                    // In some cases, the built hierarchy is ending by a joining point. so we need to remove it", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453588111", "createdAt": "2020-07-13T11:38:13Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -366,6 +375,74 @@ public Result parse(MethodInfo methodInfo) {\n                 topCount);\n     }\n \n+    private String handleFieldsHierarchy(String fieldName, FieldInfo currentField) {\n+        StringBuilder finalName = new StringBuilder(fieldName);\n+\n+        Set<String> childFields = new HashSet<>();\n+\n+        childFields.addAll(entityClass.fields().stream()\n+                .map(FieldInfo::name)\n+                .collect(Collectors.toList()));\n+\n+        // Collecting the current class fields\n+        ClassInfo currentClassInfo = indexView.getClassByName(currentField.type().name());\n+\n+        if (currentClassInfo != null) {\n+            childFields.addAll(\n+                    currentClassInfo.fields()\n+                            .stream()\n+                            .map(FieldInfo::name)\n+                            .collect(Collectors.toList()));\n+        }\n+\n+        // Collecting the inherited fields from the superclass of the actual class\n+        DotName superClassName = entityClass.superClassType().name();\n+        ClassInfo superClassInfo = indexView.getClassByName(superClassName);\n+\n+        ClassInfo classByName;\n+\n+        if (superClassName != null && superClassInfo != null && currentClassInfo != null &&\n+                currentClassInfo.superClassType() != null &&\n+                (classByName = indexView.getClassByName(currentClassInfo.superClassType().name())) != null) {\n+\n+            childFields.addAll(superClassInfo.fields()\n+                    .stream()\n+                    .map(FieldInfo::name).collect(Collectors.toList()));\n+\n+            childFields.addAll(classByName.fields()\n+                    .stream()\n+                    .map(FieldInfo::name).collect(Collectors.toList()));\n+        }\n+\n+        // Collecting the inherited fields from the superclasses of the attributes\n+        if (currentClassInfo != null && currentClassInfo.superClassType() != null\n+                && (classByName = indexView.getClassByName(currentClassInfo.superClassType().name())) != null) {\n+\n+            childFields.addAll(\n+                    classByName.fields()\n+                            .stream()\n+                            .map(FieldInfo::name).collect(Collectors.toList()));\n+        }\n+\n+        // Building the fieldName from the members classes and their superclasses\n+        for (String fieldInf : childFields) {\n+            if (StringUtils.containsIgnoreCase(fieldName, fieldInf)) {\n+                String newValue = finalName.toString()\n+                        .replaceAll(\"(?i)\" + fieldInf, lowerFirstLetter(fieldInf) + \".\");\n+                finalName.delete(0, finalName.length());\n+                finalName.append(newValue);\n+            }\n+        }\n+\n+        // In some cases; the built hierarchy is ending by a joining point. so we need to remove it", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e309f711d078fc641c975bb84d2cb5922b8a614f"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODIxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // we need to split the camelcase format and grap the first item\n          \n          \n            \n                    // we need to split the camelcase format and grab the first item", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453588219", "createdAt": "2020-07-13T11:38:28Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -488,7 +565,13 @@ private boolean entityContainsField(String fieldName) {\n     }\n \n     private FieldInfo getField(String fieldName) {\n+        // Before validating the fieldInfo,\n+        // we need to split the camelcase format and grap the first item", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e309f711d078fc641c975bb84d2cb5922b8a614f"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4ODY0NQ==", "bodyText": "Perhaps add comment about how this works? Regex can be daunting when coming back to them after not having seen them for a while :)", "url": "https://github.com/quarkusio/quarkus/pull/10619#discussion_r453588645", "createdAt": "2020-07-13T11:39:22Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/MethodNameParser.java", "diffHunk": "@@ -516,10 +599,13 @@ private FieldInfo getField(String fieldName) {\n                 superClassType = parameterizedType.owner();\n             }\n         }\n-        if (mappedSuperClassInfos.size() > 0) {\n-            return mappedSuperClassInfos;\n-        }\n-        return Collections.emptyList();\n+        return mappedSuperClassInfoElements;\n+    }\n+\n+    private static List<String> splitCamelCaseString(String s) {\n+        List<String> result = new ArrayList<>();\n+        Collections.addAll(result, s.split(\"(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e309f711d078fc641c975bb84d2cb5922b8a614f"}, "originalPosition": 141}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55e397830dda63913b87fe0110f7e57cce7ec10c", "author": {"user": null}, "url": "https://github.com/quarkusio/quarkus/commit/55e397830dda63913b87fe0110f7e57cce7ec10c", "committedDate": "2020-07-13T13:05:46Z", "message": "Fix Spring Data JPA Query Methods for big hierarchy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MjUxMDU4", "url": "https://github.com/quarkusio/quarkus/pull/10619#pullrequestreview-447251058", "createdAt": "2020-07-13T13:29:54Z", "commit": {"oid": "55e397830dda63913b87fe0110f7e57cce7ec10c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3477, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}