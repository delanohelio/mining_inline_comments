{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQwMjA4NDM5", "number": 13896, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQxMzoxMjowMVrOFUgPZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQxMzozOToyM1rOFUg5uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU3MDQ0MDY5OnYy", "diffSide": "RIGHT", "path": "independent-projects/tools/devtools-testing/src/main/java/io/quarkus/devtools/testing/SnapshotTesting.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQxMzoxMjowMVrOIcjYtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQxMzoxNTo0NlrOIcjgoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgxMDgwNA==", "bodyText": "Is this System.out necessary or can it use a logger instead?", "url": "https://github.com/quarkusio/quarkus/pull/13896#discussion_r566810804", "createdAt": "2021-01-29T13:12:01Z", "author": {"login": "gastaldi"}, "path": "independent-projects/tools/devtools-testing/src/main/java/io/quarkus/devtools/testing/SnapshotTesting.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package io.quarkus.devtools.testing;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import org.apache.commons.io.FileUtils;\n+import org.assertj.core.api.AbstractPathAssert;\n+import org.assertj.core.api.ListAssert;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.TestInfo;\n+\n+/**\n+ * Test file content and directory tree to make sure they are valid by comparing them to their snapshots.\n+ * The snapshots can easily be updated when necessary and reviewed to confirm they are consistent with the changes.\n+ * <br />\n+ * <br />\n+ * Snapshots are automatically generated on first run or can be manually updated using <code>-Dsnap</code> or\n+ * <code>-Dupdate-snapshots</code>\n+ * <br />\n+ * Snapshots are created in {@link #SNAPSHOTS_DIR}\n+ */\n+public class SnapshotTesting {\n+\n+    public static final Path SNAPSHOTS_DIR = Paths.get(\"src/test/resources/__snapshots__/\");\n+    public static final String UPDATE_SNAPSHOTS_PROPERTY = \"update-snapshots\";\n+    public static final String UPDATE_SNAPSHOTS_PROPERTY_SHORTCUT = \"snap\";\n+\n+    /**\n+     * Test file content to make sure it is valid by comparing it to its snapshots.\n+     * <br />\n+     * The snapshot can easily be updated when necessary and reviewed to confirm it is consistent with the changes.\n+     * <br />\n+     * <br />\n+     * The snapshot is automatically generated on first run or can be manually updated using <code>-Dsnap</code> or\n+     * <code>-Dupdate-snapshots</code>\n+     * <br />\n+     * <br />\n+     * Even if the content is checked as a whole, it's always better to also manually check that specific content snippets\n+     * contains what's expected\n+     * <br />\n+     * <br />\n+     * example:\n+     *\n+     * <pre>\n+     * assertThatMatchSnapshot(testInfo, projectDir, \"src/main/java/org/acme/GreetingResource.java\")\n+     *         .satisfies(checkContains(\"@Path(\\\"/hello\\\")\"))\n+     * </pre>\n+     *\n+     * @param testInfo the {@link TestInfo} from the {@Link Test} parameter (used to get the current test class & method to\n+     *        compute the snapshot location)\n+     * @param parentDir the parent directory containing the generated files for this test (makes it nicer when checking multiple\n+     *        snapshots)\n+     * @param fileRelativePath the relative path from the directory (used to name the snapshot)\n+     * @return an {@link AbstractPathAssert} giving a direct way to check specific content snippets contains what's expected\n+     * @throws Throwable\n+     */\n+    public static AbstractPathAssert<?> assertThatMatchSnapshot(TestInfo testInfo, Path parentDir, String fileRelativePath)\n+            throws Throwable {\n+        final String snapshotDirName = getSnapshotDirName(testInfo);\n+        final String normalizedFileName = snapshotDirName + \"/\" + fileRelativePath.replace(\"/\", \"_\");\n+        return assertThatMatchSnapshot(parentDir.resolve(fileRelativePath), normalizedFileName);\n+    }\n+\n+    /**\n+     * Test file content to make sure it is valid by comparing it to a snapshot.\n+     * <br />\n+     * The snapshot can easily be updated when necessary and reviewed to confirm it is consistent with the changes.\n+     * <br />\n+     * <br />\n+     * The snapshot is automatically generated on first run or can be manually updated using <code>-Dsnap</code> or\n+     * <code>-Dupdate-snapshots</code>\n+     * <br />\n+     * <br />\n+     * Even if the content is checked as a whole, it's always better to also manually check that specific content snippets\n+     * contains what's expected using {@link #checkContains(String)} or {@link #checkMatches(String)}\n+     *\n+     * @param fileToCheck the {@link Path} of the file to check\n+     * @param snapshotIdentifier the snapshotIdentifier of the snapshot (used as a relative path from the {@link #SNAPSHOTS_DIR}\n+     * @return an {@link AbstractPathAssert} giving a direct way to check specific content snippets contains what's expected\n+     * @throws Throwable\n+     */\n+    public static AbstractPathAssert<?> assertThatMatchSnapshot(Path fileToCheck, String snapshotIdentifier) throws Throwable {\n+        final Path snapshotFile = SNAPSHOTS_DIR.resolve(snapshotIdentifier);\n+        assertThat(fileToCheck).isRegularFile();\n+\n+        final boolean updateSnapshot = shouldUpdateSnapshot(snapshotIdentifier);\n+\n+        if (updateSnapshot && Files.isRegularFile(snapshotFile)) {\n+            deleteExistingSnapshots(snapshotIdentifier, snapshotFile);\n+        }\n+\n+        if (!Files.isRegularFile(snapshotFile) || updateSnapshot) {\n+            FileUtils.copyFile(fileToCheck.toFile(), snapshotFile.toFile());\n+        }\n+\n+        final String snapshotNotFoundDescription = \"corresponding snapshot not found for \" + snapshotIdentifier;\n+        if (isUTF8File(fileToCheck)) {\n+            final String description = \"check snapshot for: \" + snapshotIdentifier;\n+            assertThat(snapshotFile).as(snapshotNotFoundDescription).exists();\n+            assertThat(fileToCheck).as(description).exists().usingCharset(StandardCharsets.UTF_8)\n+                    .hasContent(getContent(snapshotFile));\n+        } else {\n+            final String description = \"check binary snapshot for: \" + snapshotIdentifier;\n+            assertThat(snapshotFile).as(snapshotNotFoundDescription).exists();\n+            assertThat(fileToCheck).as(description).hasBinaryContent(getBinaryContent(snapshotFile));\n+        }\n+        return assertThat(fileToCheck);\n+    }\n+\n+    /**\n+     * Test directory tree to make sure it is valid by comparing it to a snapshot.\n+     * <br />\n+     * The snapshot can easily be updated when necessary and reviewed to confirm it is consistent with the changes.\n+     * <br />\n+     * <br />\n+     * The snapshot is automatically generated on first run or can be manually updated using <code>-Dsnap</code> or\n+     * <code>-Dupdate-snapshots</code>\n+     *\n+     * @param testInfo the {@link TestInfo} from the {@Link Test} parameter (used to get the current test class & method to\n+     *        compute the snapshot location)\n+     * @param dir the {@link Path} of the directory to test\n+     * @return a {@link ListAssert} with the directory tree as a list\n+     * @throws Throwable\n+     */\n+    public static ListAssert<String> assertThatDirectoryTreeMatchSnapshots(TestInfo testInfo, Path dir) throws Throwable {\n+        final String snapshotName = getSnapshotDirName(testInfo) + \"/dir-tree.snapshot\";\n+        final Path snapshotFile = SNAPSHOTS_DIR.resolve(snapshotName);\n+\n+        assertThat(dir).isDirectory();\n+\n+        final List<String> tree = Files.walk(dir)\n+                .map(p -> {\n+                    final String r = dir.relativize(p).toString().replace('\\\\', '/');\n+                    if (Files.isDirectory(p)) {\n+                        return r + \"/\";\n+                    }\n+                    return r;\n+                })\n+                .collect(toList());\n+\n+        final boolean updateSnapshot = shouldUpdateSnapshot(snapshotName);\n+\n+        if (updateSnapshot && Files.isRegularFile(snapshotFile)) {\n+            deleteExistingSnapshots(snapshotName, snapshotFile);\n+        }\n+\n+        if (!Files.isRegularFile(snapshotFile) || updateSnapshot) {\n+            Files.createDirectories(snapshotFile.getParent());\n+            Files.write(snapshotFile, String.join(\"\\n\", tree).getBytes(StandardCharsets.UTF_8));\n+        }\n+\n+        assertThat(snapshotFile).isRegularFile();\n+\n+        final List<String> content = Arrays.stream(getContent(snapshotFile).split(\"\\\\v\"))\n+                .filter(s -> !s.isEmpty())\n+                .collect(toList());\n+\n+        return assertThat(tree).containsExactlyInAnyOrderElementsOf(content);\n+    }\n+\n+    public static byte[] getBinaryContent(Path file) {\n+        try {\n+            return Files.readAllBytes(file);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(\"Unable to read \" + file.toString(), e);\n+        }\n+    }\n+\n+    public static String getContent(Path file) {\n+        try {\n+            return new String(Files.readAllBytes(file), StandardCharsets.UTF_8);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(\"Unable to read \" + file.toString(), e);\n+        }\n+    }\n+\n+    public static void deleteTestDirectory(final File file) throws IOException {\n+        FileUtils.deleteDirectory(file);\n+\n+        Assertions.assertFalse(\n+                Files.exists(file.toPath()), \"Directory still exists\");\n+    }\n+\n+    /**\n+     * To use with {@link AbstractPathAssert} in order to check the file content contains a specific string.\n+     *\n+     * @param s the string which should be in the file content\n+     * @return a {@link Consumer<Path>} to use with {@link AbstractPathAssert#satisfies(Consumer)}\n+     */\n+    public static Consumer<Path> checkContains(String s) {\n+        return (p) -> assertThat(getContent(p)).contains(s);\n+    }\n+\n+    public static Consumer<Path> checkMatches(String regex) {\n+        return (p) -> assertThat(getContent(p)).matches(regex);\n+    }\n+\n+    private static boolean shouldUpdateSnapshot(String identifier) {\n+        return getUpdateSnapshotsProp().filter(u -> u.isEmpty() || \"true\".equalsIgnoreCase(u) || u.contains(identifier))\n+                .isPresent();\n+    }\n+\n+    private static boolean isUTF8File(final Path file) {\n+        try {\n+            final byte[] inputBytes = Files.readAllBytes(file);\n+            final String converted = new String(inputBytes, StandardCharsets.UTF_8);\n+            final byte[] outputBytes = converted.getBytes(StandardCharsets.UTF_8);\n+            return Arrays.equals(inputBytes, outputBytes);\n+        } catch (IOException e) {\n+            return false;\n+        }\n+    }\n+\n+    private static void deleteExistingSnapshots(String name, Path snapshots) {\n+        System.out.println(\"\\n>>>>>> DELETING EXISTING TEST SNAPSHOTS FOR:\\n>>>>>> \" + name + \"\\n\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73578ff5e8a092e886c85996565a8de97685e098"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgxMjQ5MA==", "bodyText": "It's used only in the tests, goal is to make it really obvious, logs are not always displayed..", "url": "https://github.com/quarkusio/quarkus/pull/13896#discussion_r566812490", "createdAt": "2021-01-29T13:15:14Z", "author": {"login": "ia3andy"}, "path": "independent-projects/tools/devtools-testing/src/main/java/io/quarkus/devtools/testing/SnapshotTesting.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package io.quarkus.devtools.testing;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import org.apache.commons.io.FileUtils;\n+import org.assertj.core.api.AbstractPathAssert;\n+import org.assertj.core.api.ListAssert;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.TestInfo;\n+\n+/**\n+ * Test file content and directory tree to make sure they are valid by comparing them to their snapshots.\n+ * The snapshots can easily be updated when necessary and reviewed to confirm they are consistent with the changes.\n+ * <br />\n+ * <br />\n+ * Snapshots are automatically generated on first run or can be manually updated using <code>-Dsnap</code> or\n+ * <code>-Dupdate-snapshots</code>\n+ * <br />\n+ * Snapshots are created in {@link #SNAPSHOTS_DIR}\n+ */\n+public class SnapshotTesting {\n+\n+    public static final Path SNAPSHOTS_DIR = Paths.get(\"src/test/resources/__snapshots__/\");\n+    public static final String UPDATE_SNAPSHOTS_PROPERTY = \"update-snapshots\";\n+    public static final String UPDATE_SNAPSHOTS_PROPERTY_SHORTCUT = \"snap\";\n+\n+    /**\n+     * Test file content to make sure it is valid by comparing it to its snapshots.\n+     * <br />\n+     * The snapshot can easily be updated when necessary and reviewed to confirm it is consistent with the changes.\n+     * <br />\n+     * <br />\n+     * The snapshot is automatically generated on first run or can be manually updated using <code>-Dsnap</code> or\n+     * <code>-Dupdate-snapshots</code>\n+     * <br />\n+     * <br />\n+     * Even if the content is checked as a whole, it's always better to also manually check that specific content snippets\n+     * contains what's expected\n+     * <br />\n+     * <br />\n+     * example:\n+     *\n+     * <pre>\n+     * assertThatMatchSnapshot(testInfo, projectDir, \"src/main/java/org/acme/GreetingResource.java\")\n+     *         .satisfies(checkContains(\"@Path(\\\"/hello\\\")\"))\n+     * </pre>\n+     *\n+     * @param testInfo the {@link TestInfo} from the {@Link Test} parameter (used to get the current test class & method to\n+     *        compute the snapshot location)\n+     * @param parentDir the parent directory containing the generated files for this test (makes it nicer when checking multiple\n+     *        snapshots)\n+     * @param fileRelativePath the relative path from the directory (used to name the snapshot)\n+     * @return an {@link AbstractPathAssert} giving a direct way to check specific content snippets contains what's expected\n+     * @throws Throwable\n+     */\n+    public static AbstractPathAssert<?> assertThatMatchSnapshot(TestInfo testInfo, Path parentDir, String fileRelativePath)\n+            throws Throwable {\n+        final String snapshotDirName = getSnapshotDirName(testInfo);\n+        final String normalizedFileName = snapshotDirName + \"/\" + fileRelativePath.replace(\"/\", \"_\");\n+        return assertThatMatchSnapshot(parentDir.resolve(fileRelativePath), normalizedFileName);\n+    }\n+\n+    /**\n+     * Test file content to make sure it is valid by comparing it to a snapshot.\n+     * <br />\n+     * The snapshot can easily be updated when necessary and reviewed to confirm it is consistent with the changes.\n+     * <br />\n+     * <br />\n+     * The snapshot is automatically generated on first run or can be manually updated using <code>-Dsnap</code> or\n+     * <code>-Dupdate-snapshots</code>\n+     * <br />\n+     * <br />\n+     * Even if the content is checked as a whole, it's always better to also manually check that specific content snippets\n+     * contains what's expected using {@link #checkContains(String)} or {@link #checkMatches(String)}\n+     *\n+     * @param fileToCheck the {@link Path} of the file to check\n+     * @param snapshotIdentifier the snapshotIdentifier of the snapshot (used as a relative path from the {@link #SNAPSHOTS_DIR}\n+     * @return an {@link AbstractPathAssert} giving a direct way to check specific content snippets contains what's expected\n+     * @throws Throwable\n+     */\n+    public static AbstractPathAssert<?> assertThatMatchSnapshot(Path fileToCheck, String snapshotIdentifier) throws Throwable {\n+        final Path snapshotFile = SNAPSHOTS_DIR.resolve(snapshotIdentifier);\n+        assertThat(fileToCheck).isRegularFile();\n+\n+        final boolean updateSnapshot = shouldUpdateSnapshot(snapshotIdentifier);\n+\n+        if (updateSnapshot && Files.isRegularFile(snapshotFile)) {\n+            deleteExistingSnapshots(snapshotIdentifier, snapshotFile);\n+        }\n+\n+        if (!Files.isRegularFile(snapshotFile) || updateSnapshot) {\n+            FileUtils.copyFile(fileToCheck.toFile(), snapshotFile.toFile());\n+        }\n+\n+        final String snapshotNotFoundDescription = \"corresponding snapshot not found for \" + snapshotIdentifier;\n+        if (isUTF8File(fileToCheck)) {\n+            final String description = \"check snapshot for: \" + snapshotIdentifier;\n+            assertThat(snapshotFile).as(snapshotNotFoundDescription).exists();\n+            assertThat(fileToCheck).as(description).exists().usingCharset(StandardCharsets.UTF_8)\n+                    .hasContent(getContent(snapshotFile));\n+        } else {\n+            final String description = \"check binary snapshot for: \" + snapshotIdentifier;\n+            assertThat(snapshotFile).as(snapshotNotFoundDescription).exists();\n+            assertThat(fileToCheck).as(description).hasBinaryContent(getBinaryContent(snapshotFile));\n+        }\n+        return assertThat(fileToCheck);\n+    }\n+\n+    /**\n+     * Test directory tree to make sure it is valid by comparing it to a snapshot.\n+     * <br />\n+     * The snapshot can easily be updated when necessary and reviewed to confirm it is consistent with the changes.\n+     * <br />\n+     * <br />\n+     * The snapshot is automatically generated on first run or can be manually updated using <code>-Dsnap</code> or\n+     * <code>-Dupdate-snapshots</code>\n+     *\n+     * @param testInfo the {@link TestInfo} from the {@Link Test} parameter (used to get the current test class & method to\n+     *        compute the snapshot location)\n+     * @param dir the {@link Path} of the directory to test\n+     * @return a {@link ListAssert} with the directory tree as a list\n+     * @throws Throwable\n+     */\n+    public static ListAssert<String> assertThatDirectoryTreeMatchSnapshots(TestInfo testInfo, Path dir) throws Throwable {\n+        final String snapshotName = getSnapshotDirName(testInfo) + \"/dir-tree.snapshot\";\n+        final Path snapshotFile = SNAPSHOTS_DIR.resolve(snapshotName);\n+\n+        assertThat(dir).isDirectory();\n+\n+        final List<String> tree = Files.walk(dir)\n+                .map(p -> {\n+                    final String r = dir.relativize(p).toString().replace('\\\\', '/');\n+                    if (Files.isDirectory(p)) {\n+                        return r + \"/\";\n+                    }\n+                    return r;\n+                })\n+                .collect(toList());\n+\n+        final boolean updateSnapshot = shouldUpdateSnapshot(snapshotName);\n+\n+        if (updateSnapshot && Files.isRegularFile(snapshotFile)) {\n+            deleteExistingSnapshots(snapshotName, snapshotFile);\n+        }\n+\n+        if (!Files.isRegularFile(snapshotFile) || updateSnapshot) {\n+            Files.createDirectories(snapshotFile.getParent());\n+            Files.write(snapshotFile, String.join(\"\\n\", tree).getBytes(StandardCharsets.UTF_8));\n+        }\n+\n+        assertThat(snapshotFile).isRegularFile();\n+\n+        final List<String> content = Arrays.stream(getContent(snapshotFile).split(\"\\\\v\"))\n+                .filter(s -> !s.isEmpty())\n+                .collect(toList());\n+\n+        return assertThat(tree).containsExactlyInAnyOrderElementsOf(content);\n+    }\n+\n+    public static byte[] getBinaryContent(Path file) {\n+        try {\n+            return Files.readAllBytes(file);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(\"Unable to read \" + file.toString(), e);\n+        }\n+    }\n+\n+    public static String getContent(Path file) {\n+        try {\n+            return new String(Files.readAllBytes(file), StandardCharsets.UTF_8);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(\"Unable to read \" + file.toString(), e);\n+        }\n+    }\n+\n+    public static void deleteTestDirectory(final File file) throws IOException {\n+        FileUtils.deleteDirectory(file);\n+\n+        Assertions.assertFalse(\n+                Files.exists(file.toPath()), \"Directory still exists\");\n+    }\n+\n+    /**\n+     * To use with {@link AbstractPathAssert} in order to check the file content contains a specific string.\n+     *\n+     * @param s the string which should be in the file content\n+     * @return a {@link Consumer<Path>} to use with {@link AbstractPathAssert#satisfies(Consumer)}\n+     */\n+    public static Consumer<Path> checkContains(String s) {\n+        return (p) -> assertThat(getContent(p)).contains(s);\n+    }\n+\n+    public static Consumer<Path> checkMatches(String regex) {\n+        return (p) -> assertThat(getContent(p)).matches(regex);\n+    }\n+\n+    private static boolean shouldUpdateSnapshot(String identifier) {\n+        return getUpdateSnapshotsProp().filter(u -> u.isEmpty() || \"true\".equalsIgnoreCase(u) || u.contains(identifier))\n+                .isPresent();\n+    }\n+\n+    private static boolean isUTF8File(final Path file) {\n+        try {\n+            final byte[] inputBytes = Files.readAllBytes(file);\n+            final String converted = new String(inputBytes, StandardCharsets.UTF_8);\n+            final byte[] outputBytes = converted.getBytes(StandardCharsets.UTF_8);\n+            return Arrays.equals(inputBytes, outputBytes);\n+        } catch (IOException e) {\n+            return false;\n+        }\n+    }\n+\n+    private static void deleteExistingSnapshots(String name, Path snapshots) {\n+        System.out.println(\"\\n>>>>>> DELETING EXISTING TEST SNAPSHOTS FOR:\\n>>>>>> \" + name + \"\\n\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgxMDgwNA=="}, "originalCommit": {"oid": "73578ff5e8a092e886c85996565a8de97685e098"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgxMjgzMw==", "bodyText": "You only see it when using -Dsnap", "url": "https://github.com/quarkusio/quarkus/pull/13896#discussion_r566812833", "createdAt": "2021-01-29T13:15:46Z", "author": {"login": "ia3andy"}, "path": "independent-projects/tools/devtools-testing/src/main/java/io/quarkus/devtools/testing/SnapshotTesting.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package io.quarkus.devtools.testing;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import org.apache.commons.io.FileUtils;\n+import org.assertj.core.api.AbstractPathAssert;\n+import org.assertj.core.api.ListAssert;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.TestInfo;\n+\n+/**\n+ * Test file content and directory tree to make sure they are valid by comparing them to their snapshots.\n+ * The snapshots can easily be updated when necessary and reviewed to confirm they are consistent with the changes.\n+ * <br />\n+ * <br />\n+ * Snapshots are automatically generated on first run or can be manually updated using <code>-Dsnap</code> or\n+ * <code>-Dupdate-snapshots</code>\n+ * <br />\n+ * Snapshots are created in {@link #SNAPSHOTS_DIR}\n+ */\n+public class SnapshotTesting {\n+\n+    public static final Path SNAPSHOTS_DIR = Paths.get(\"src/test/resources/__snapshots__/\");\n+    public static final String UPDATE_SNAPSHOTS_PROPERTY = \"update-snapshots\";\n+    public static final String UPDATE_SNAPSHOTS_PROPERTY_SHORTCUT = \"snap\";\n+\n+    /**\n+     * Test file content to make sure it is valid by comparing it to its snapshots.\n+     * <br />\n+     * The snapshot can easily be updated when necessary and reviewed to confirm it is consistent with the changes.\n+     * <br />\n+     * <br />\n+     * The snapshot is automatically generated on first run or can be manually updated using <code>-Dsnap</code> or\n+     * <code>-Dupdate-snapshots</code>\n+     * <br />\n+     * <br />\n+     * Even if the content is checked as a whole, it's always better to also manually check that specific content snippets\n+     * contains what's expected\n+     * <br />\n+     * <br />\n+     * example:\n+     *\n+     * <pre>\n+     * assertThatMatchSnapshot(testInfo, projectDir, \"src/main/java/org/acme/GreetingResource.java\")\n+     *         .satisfies(checkContains(\"@Path(\\\"/hello\\\")\"))\n+     * </pre>\n+     *\n+     * @param testInfo the {@link TestInfo} from the {@Link Test} parameter (used to get the current test class & method to\n+     *        compute the snapshot location)\n+     * @param parentDir the parent directory containing the generated files for this test (makes it nicer when checking multiple\n+     *        snapshots)\n+     * @param fileRelativePath the relative path from the directory (used to name the snapshot)\n+     * @return an {@link AbstractPathAssert} giving a direct way to check specific content snippets contains what's expected\n+     * @throws Throwable\n+     */\n+    public static AbstractPathAssert<?> assertThatMatchSnapshot(TestInfo testInfo, Path parentDir, String fileRelativePath)\n+            throws Throwable {\n+        final String snapshotDirName = getSnapshotDirName(testInfo);\n+        final String normalizedFileName = snapshotDirName + \"/\" + fileRelativePath.replace(\"/\", \"_\");\n+        return assertThatMatchSnapshot(parentDir.resolve(fileRelativePath), normalizedFileName);\n+    }\n+\n+    /**\n+     * Test file content to make sure it is valid by comparing it to a snapshot.\n+     * <br />\n+     * The snapshot can easily be updated when necessary and reviewed to confirm it is consistent with the changes.\n+     * <br />\n+     * <br />\n+     * The snapshot is automatically generated on first run or can be manually updated using <code>-Dsnap</code> or\n+     * <code>-Dupdate-snapshots</code>\n+     * <br />\n+     * <br />\n+     * Even if the content is checked as a whole, it's always better to also manually check that specific content snippets\n+     * contains what's expected using {@link #checkContains(String)} or {@link #checkMatches(String)}\n+     *\n+     * @param fileToCheck the {@link Path} of the file to check\n+     * @param snapshotIdentifier the snapshotIdentifier of the snapshot (used as a relative path from the {@link #SNAPSHOTS_DIR}\n+     * @return an {@link AbstractPathAssert} giving a direct way to check specific content snippets contains what's expected\n+     * @throws Throwable\n+     */\n+    public static AbstractPathAssert<?> assertThatMatchSnapshot(Path fileToCheck, String snapshotIdentifier) throws Throwable {\n+        final Path snapshotFile = SNAPSHOTS_DIR.resolve(snapshotIdentifier);\n+        assertThat(fileToCheck).isRegularFile();\n+\n+        final boolean updateSnapshot = shouldUpdateSnapshot(snapshotIdentifier);\n+\n+        if (updateSnapshot && Files.isRegularFile(snapshotFile)) {\n+            deleteExistingSnapshots(snapshotIdentifier, snapshotFile);\n+        }\n+\n+        if (!Files.isRegularFile(snapshotFile) || updateSnapshot) {\n+            FileUtils.copyFile(fileToCheck.toFile(), snapshotFile.toFile());\n+        }\n+\n+        final String snapshotNotFoundDescription = \"corresponding snapshot not found for \" + snapshotIdentifier;\n+        if (isUTF8File(fileToCheck)) {\n+            final String description = \"check snapshot for: \" + snapshotIdentifier;\n+            assertThat(snapshotFile).as(snapshotNotFoundDescription).exists();\n+            assertThat(fileToCheck).as(description).exists().usingCharset(StandardCharsets.UTF_8)\n+                    .hasContent(getContent(snapshotFile));\n+        } else {\n+            final String description = \"check binary snapshot for: \" + snapshotIdentifier;\n+            assertThat(snapshotFile).as(snapshotNotFoundDescription).exists();\n+            assertThat(fileToCheck).as(description).hasBinaryContent(getBinaryContent(snapshotFile));\n+        }\n+        return assertThat(fileToCheck);\n+    }\n+\n+    /**\n+     * Test directory tree to make sure it is valid by comparing it to a snapshot.\n+     * <br />\n+     * The snapshot can easily be updated when necessary and reviewed to confirm it is consistent with the changes.\n+     * <br />\n+     * <br />\n+     * The snapshot is automatically generated on first run or can be manually updated using <code>-Dsnap</code> or\n+     * <code>-Dupdate-snapshots</code>\n+     *\n+     * @param testInfo the {@link TestInfo} from the {@Link Test} parameter (used to get the current test class & method to\n+     *        compute the snapshot location)\n+     * @param dir the {@link Path} of the directory to test\n+     * @return a {@link ListAssert} with the directory tree as a list\n+     * @throws Throwable\n+     */\n+    public static ListAssert<String> assertThatDirectoryTreeMatchSnapshots(TestInfo testInfo, Path dir) throws Throwable {\n+        final String snapshotName = getSnapshotDirName(testInfo) + \"/dir-tree.snapshot\";\n+        final Path snapshotFile = SNAPSHOTS_DIR.resolve(snapshotName);\n+\n+        assertThat(dir).isDirectory();\n+\n+        final List<String> tree = Files.walk(dir)\n+                .map(p -> {\n+                    final String r = dir.relativize(p).toString().replace('\\\\', '/');\n+                    if (Files.isDirectory(p)) {\n+                        return r + \"/\";\n+                    }\n+                    return r;\n+                })\n+                .collect(toList());\n+\n+        final boolean updateSnapshot = shouldUpdateSnapshot(snapshotName);\n+\n+        if (updateSnapshot && Files.isRegularFile(snapshotFile)) {\n+            deleteExistingSnapshots(snapshotName, snapshotFile);\n+        }\n+\n+        if (!Files.isRegularFile(snapshotFile) || updateSnapshot) {\n+            Files.createDirectories(snapshotFile.getParent());\n+            Files.write(snapshotFile, String.join(\"\\n\", tree).getBytes(StandardCharsets.UTF_8));\n+        }\n+\n+        assertThat(snapshotFile).isRegularFile();\n+\n+        final List<String> content = Arrays.stream(getContent(snapshotFile).split(\"\\\\v\"))\n+                .filter(s -> !s.isEmpty())\n+                .collect(toList());\n+\n+        return assertThat(tree).containsExactlyInAnyOrderElementsOf(content);\n+    }\n+\n+    public static byte[] getBinaryContent(Path file) {\n+        try {\n+            return Files.readAllBytes(file);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(\"Unable to read \" + file.toString(), e);\n+        }\n+    }\n+\n+    public static String getContent(Path file) {\n+        try {\n+            return new String(Files.readAllBytes(file), StandardCharsets.UTF_8);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(\"Unable to read \" + file.toString(), e);\n+        }\n+    }\n+\n+    public static void deleteTestDirectory(final File file) throws IOException {\n+        FileUtils.deleteDirectory(file);\n+\n+        Assertions.assertFalse(\n+                Files.exists(file.toPath()), \"Directory still exists\");\n+    }\n+\n+    /**\n+     * To use with {@link AbstractPathAssert} in order to check the file content contains a specific string.\n+     *\n+     * @param s the string which should be in the file content\n+     * @return a {@link Consumer<Path>} to use with {@link AbstractPathAssert#satisfies(Consumer)}\n+     */\n+    public static Consumer<Path> checkContains(String s) {\n+        return (p) -> assertThat(getContent(p)).contains(s);\n+    }\n+\n+    public static Consumer<Path> checkMatches(String regex) {\n+        return (p) -> assertThat(getContent(p)).matches(regex);\n+    }\n+\n+    private static boolean shouldUpdateSnapshot(String identifier) {\n+        return getUpdateSnapshotsProp().filter(u -> u.isEmpty() || \"true\".equalsIgnoreCase(u) || u.contains(identifier))\n+                .isPresent();\n+    }\n+\n+    private static boolean isUTF8File(final Path file) {\n+        try {\n+            final byte[] inputBytes = Files.readAllBytes(file);\n+            final String converted = new String(inputBytes, StandardCharsets.UTF_8);\n+            final byte[] outputBytes = converted.getBytes(StandardCharsets.UTF_8);\n+            return Arrays.equals(inputBytes, outputBytes);\n+        } catch (IOException e) {\n+            return false;\n+        }\n+    }\n+\n+    private static void deleteExistingSnapshots(String name, Path snapshots) {\n+        System.out.println(\"\\n>>>>>> DELETING EXISTING TEST SNAPSHOTS FOR:\\n>>>>>> \" + name + \"\\n\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgxMDgwNA=="}, "originalCommit": {"oid": "73578ff5e8a092e886c85996565a8de97685e098"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU3MDQ2ODQyOnYy", "diffSide": "RIGHT", "path": "independent-projects/tools/devtools-common/src/main/resources/codestarts/quarkus-extension/code/quarkiverse/java/LICENCE", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQxMzoxOToyMlrOIcjpFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQxMzoyMTo0M1rOIcjuJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgxNDk5Ng==", "bodyText": "Rename this file to LICENSE (with an S) - because that's the file GitHub creates when you choose to add a LICENSE (yeah, not British English :))", "url": "https://github.com/quarkusio/quarkus/pull/13896#discussion_r566814996", "createdAt": "2021-01-29T13:19:22Z", "author": {"login": "gastaldi"}, "path": "independent-projects/tools/devtools-common/src/main/resources/codestarts/quarkus-extension/code/quarkiverse/java/LICENCE", "diffHunk": "@@ -0,0 +1,201 @@\n+                                 Apache License", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73578ff5e8a092e886c85996565a8de97685e098"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgxNTgyMA==", "bodyText": "Oupsy :)", "url": "https://github.com/quarkusio/quarkus/pull/13896#discussion_r566815820", "createdAt": "2021-01-29T13:20:50Z", "author": {"login": "ia3andy"}, "path": "independent-projects/tools/devtools-common/src/main/resources/codestarts/quarkus-extension/code/quarkiverse/java/LICENCE", "diffHunk": "@@ -0,0 +1,201 @@\n+                                 Apache License", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgxNDk5Ng=="}, "originalCommit": {"oid": "73578ff5e8a092e886c85996565a8de97685e098"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgxNjI5NQ==", "bodyText": "licence is french \ud83d\ude05 I always mix them up", "url": "https://github.com/quarkusio/quarkus/pull/13896#discussion_r566816295", "createdAt": "2021-01-29T13:21:43Z", "author": {"login": "ia3andy"}, "path": "independent-projects/tools/devtools-common/src/main/resources/codestarts/quarkus-extension/code/quarkiverse/java/LICENCE", "diffHunk": "@@ -0,0 +1,201 @@\n+                                 Apache License", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgxNDk5Ng=="}, "originalCommit": {"oid": "73578ff5e8a092e886c85996565a8de97685e098"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU3MDQ4NjU3OnYy", "diffSide": "RIGHT", "path": "independent-projects/tools/devtools-common/src/main/resources/codestarts/quarkus-extension/code/integration-test/java/integration-test/pom.tpl.qute.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQxMzoyNDoyNVrOIcj0YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQxMzoyOTowNVrOIckEBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgxNzg4OA==", "bodyText": "The Quarkiverse extension is not generating a name for the integration-test module.", "url": "https://github.com/quarkusio/quarkus/pull/13896#discussion_r566817888", "createdAt": "2021-01-29T13:24:25Z", "author": {"login": "gastaldi"}, "path": "independent-projects/tools/devtools-common/src/main/resources/codestarts/quarkus-extension/code/integration-test/java/integration-test/pom.tpl.qute.xml", "diffHunk": "@@ -0,0 +1,127 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+{#if it-parent}\n+    <parent>\n+        <groupId>{it-parent.group-id}</groupId>\n+        <artifactId>{it-parent.artifact-id}</artifactId>\n+        <version>{it-parent.version}</version>\n+        {#if it-parent.relative-path}\n+        <relativePath>{it-parent.relative-path}</relativePath>\n+        {/if}\n+    </parent>\n+{/if}\n+    <artifactId>{namespace.id}{extension.id}-integration-test</artifactId>\n+{#if name.base && name.prefix}\n+    <name>{name.prefix}{name.base}{name.segment-delimiter}Integration Test</name>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73578ff5e8a092e886c85996565a8de97685e098"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgyMTc3MA==", "bodyText": "ok this is a bug :) thanks", "url": "https://github.com/quarkusio/quarkus/pull/13896#discussion_r566821770", "createdAt": "2021-01-29T13:28:53Z", "author": {"login": "ia3andy"}, "path": "independent-projects/tools/devtools-common/src/main/resources/codestarts/quarkus-extension/code/integration-test/java/integration-test/pom.tpl.qute.xml", "diffHunk": "@@ -0,0 +1,127 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+{#if it-parent}\n+    <parent>\n+        <groupId>{it-parent.group-id}</groupId>\n+        <artifactId>{it-parent.artifact-id}</artifactId>\n+        <version>{it-parent.version}</version>\n+        {#if it-parent.relative-path}\n+        <relativePath>{it-parent.relative-path}</relativePath>\n+        {/if}\n+    </parent>\n+{/if}\n+    <artifactId>{namespace.id}{extension.id}-integration-test</artifactId>\n+{#if name.base && name.prefix}\n+    <name>{name.prefix}{name.base}{name.segment-delimiter}Integration Test</name>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgxNzg4OA=="}, "originalCommit": {"oid": "73578ff5e8a092e886c85996565a8de97685e098"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgyMTg5Mg==", "bodyText": "good catch !", "url": "https://github.com/quarkusio/quarkus/pull/13896#discussion_r566821892", "createdAt": "2021-01-29T13:29:05Z", "author": {"login": "ia3andy"}, "path": "independent-projects/tools/devtools-common/src/main/resources/codestarts/quarkus-extension/code/integration-test/java/integration-test/pom.tpl.qute.xml", "diffHunk": "@@ -0,0 +1,127 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+{#if it-parent}\n+    <parent>\n+        <groupId>{it-parent.group-id}</groupId>\n+        <artifactId>{it-parent.artifact-id}</artifactId>\n+        <version>{it-parent.version}</version>\n+        {#if it-parent.relative-path}\n+        <relativePath>{it-parent.relative-path}</relativePath>\n+        {/if}\n+    </parent>\n+{/if}\n+    <artifactId>{namespace.id}{extension.id}-integration-test</artifactId>\n+{#if name.base && name.prefix}\n+    <name>{name.prefix}{name.base}{name.segment-delimiter}Integration Test</name>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgxNzg4OA=="}, "originalCommit": {"oid": "73578ff5e8a092e886c85996565a8de97685e098"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU3MDU0OTA1OnYy", "diffSide": "RIGHT", "path": "independent-projects/tools/devtools-common/src/main/java/io/quarkus/devtools/commands/CreateExtension.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQxMzozOToyM1rOIckbZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yOVQxMzo0MDozNVrOIckeZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgyNzg3Ng==", "bodyText": "Hint: these properties can be moved as getters inside the LayoutType enum above", "url": "https://github.com/quarkusio/quarkus/pull/13896#discussion_r566827876", "createdAt": "2021-01-29T13:39:23Z", "author": {"login": "gastaldi"}, "path": "independent-projects/tools/devtools-common/src/main/java/io/quarkus/devtools/commands/CreateExtension.java", "diffHunk": "@@ -0,0 +1,455 @@\n+package io.quarkus.devtools.commands;\n+\n+import static io.quarkus.devtools.codestarts.extension.QuarkusExtensionCodestartCatalog.QuarkusExtensionData.*;\n+import static io.quarkus.devtools.commands.handlers.CreateExtensionCommandHandler.readPom;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+import io.quarkus.devtools.codestarts.extension.QuarkusExtensionCodestartCatalog;\n+import io.quarkus.devtools.codestarts.extension.QuarkusExtensionCodestartCatalog.QuarkusExtensionData;\n+import io.quarkus.devtools.codestarts.extension.QuarkusExtensionCodestartProjectInput;\n+import io.quarkus.devtools.codestarts.extension.QuarkusExtensionCodestartProjectInputBuilder;\n+import io.quarkus.devtools.commands.data.QuarkusCommandException;\n+import io.quarkus.devtools.commands.data.QuarkusCommandOutcome;\n+import io.quarkus.devtools.commands.handlers.CreateExtensionCommandHandler;\n+import io.quarkus.devtools.messagewriter.MessageWriter;\n+import io.quarkus.maven.utilities.MojoUtils;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+import javax.lang.model.SourceVersion;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.maven.model.Model;\n+\n+/**\n+ * Instances of this class are not thread-safe. They are created per invocation.\n+ */\n+public class CreateExtension {\n+\n+    public enum LayoutType {\n+        OTHER_PLATFORM,\n+        QUARKUS_CORE,\n+        QUARKIVERSE,\n+        STANDALONE\n+    }\n+\n+    public static final String DEFAULT_BOM_GROUP_ID = \"io.quarkus\";\n+    public static final String DEFAULT_BOM_ARTIFACT_ID = \"quarkus-bom\";\n+    public static final String DEFAULT_BOM_VERSION = \"${quarkus.version}\";\n+    public static final String DEFAULT_VERSION = \"0.0.1-SNAPSHOT\";\n+\n+    public static final String DEFAULT_CORE_NAMESPACE_ID = \"quarkus-\";\n+\n+    public static final String DEFAULT_EXTERNAL_NAMESPACE_ID = \"\";\n+\n+    public static final String DEFAULT_QUARKIVERSE_PARENT_GROUP_ID = \"io.quarkiverse\";\n+    public static final String DEFAULT_QUARKIVERSE_PARENT_ARTIFACT_ID = \"quarkiverse-parent\";\n+    public static final String DEFAULT_QUARKIVERSE_PARENT_VERSION = \"5\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73578ff5e8a092e886c85996565a8de97685e098"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgyODY0Ng==", "bodyText": "Good hint \ud83d\ude07", "url": "https://github.com/quarkusio/quarkus/pull/13896#discussion_r566828646", "createdAt": "2021-01-29T13:40:35Z", "author": {"login": "ia3andy"}, "path": "independent-projects/tools/devtools-common/src/main/java/io/quarkus/devtools/commands/CreateExtension.java", "diffHunk": "@@ -0,0 +1,455 @@\n+package io.quarkus.devtools.commands;\n+\n+import static io.quarkus.devtools.codestarts.extension.QuarkusExtensionCodestartCatalog.QuarkusExtensionData.*;\n+import static io.quarkus.devtools.commands.handlers.CreateExtensionCommandHandler.readPom;\n+import static java.util.Objects.requireNonNull;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+import io.quarkus.devtools.codestarts.extension.QuarkusExtensionCodestartCatalog;\n+import io.quarkus.devtools.codestarts.extension.QuarkusExtensionCodestartCatalog.QuarkusExtensionData;\n+import io.quarkus.devtools.codestarts.extension.QuarkusExtensionCodestartProjectInput;\n+import io.quarkus.devtools.codestarts.extension.QuarkusExtensionCodestartProjectInputBuilder;\n+import io.quarkus.devtools.commands.data.QuarkusCommandException;\n+import io.quarkus.devtools.commands.data.QuarkusCommandOutcome;\n+import io.quarkus.devtools.commands.handlers.CreateExtensionCommandHandler;\n+import io.quarkus.devtools.messagewriter.MessageWriter;\n+import io.quarkus.maven.utilities.MojoUtils;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+import javax.lang.model.SourceVersion;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.maven.model.Model;\n+\n+/**\n+ * Instances of this class are not thread-safe. They are created per invocation.\n+ */\n+public class CreateExtension {\n+\n+    public enum LayoutType {\n+        OTHER_PLATFORM,\n+        QUARKUS_CORE,\n+        QUARKIVERSE,\n+        STANDALONE\n+    }\n+\n+    public static final String DEFAULT_BOM_GROUP_ID = \"io.quarkus\";\n+    public static final String DEFAULT_BOM_ARTIFACT_ID = \"quarkus-bom\";\n+    public static final String DEFAULT_BOM_VERSION = \"${quarkus.version}\";\n+    public static final String DEFAULT_VERSION = \"0.0.1-SNAPSHOT\";\n+\n+    public static final String DEFAULT_CORE_NAMESPACE_ID = \"quarkus-\";\n+\n+    public static final String DEFAULT_EXTERNAL_NAMESPACE_ID = \"\";\n+\n+    public static final String DEFAULT_QUARKIVERSE_PARENT_GROUP_ID = \"io.quarkiverse\";\n+    public static final String DEFAULT_QUARKIVERSE_PARENT_ARTIFACT_ID = \"quarkiverse-parent\";\n+    public static final String DEFAULT_QUARKIVERSE_PARENT_VERSION = \"5\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgyNzg3Ng=="}, "originalCommit": {"oid": "73578ff5e8a092e886c85996565a8de97685e098"}, "originalPosition": 52}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4545, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}