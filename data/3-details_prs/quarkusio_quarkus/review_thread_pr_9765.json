{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3NTIzMjE1", "number": 9765, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwODoxNzozNFrOECdF_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNFQwMzowODoyNFrOFd4GOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDA5Mjc3OnYy", "diffSide": "RIGHT", "path": "devtools/maven/src/main/java/io/quarkus/maven/BuildMojo.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwODoxNzozNFrOGe62vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwODoxNzozNFrOGe62vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA3NDc1MQ==", "bodyText": "Instead of assuming it's a jar you should probably use project.getArtifact().getArtifactHandler().getExtension().", "url": "https://github.com/quarkusio/quarkus/pull/9765#discussion_r435074751", "createdAt": "2020-06-04T08:17:34Z", "author": {"login": "aloubyansky"}, "path": "devtools/maven/src/main/java/io/quarkus/maven/BuildMojo.java", "diffHunk": "@@ -173,13 +174,21 @@ public void execute() throws MojoExecutionException {\n                     projectArtifact.getVersion());\n             appArtifact.setPaths(PathsCollection.of(projectArtifact.getFile().toPath()));\n \n-            CuratedApplication curatedApplication = QuarkusBootstrap.builder()\n+            QuarkusBootstrap.Builder builder = QuarkusBootstrap.builder()\n                     .setAppArtifact(appArtifact)\n                     .setMavenArtifactResolver(resolver)\n                     .setBaseClassLoader(BuildMojo.class.getClassLoader())\n                     .setBuildSystemProperties(realProperties)\n+                    .setLocalProjectDiscovery(false)\n+                    .setProjectRoot(project.getBasedir().toPath())\n                     .setBaseName(finalName)\n-                    .setTargetDirectory(buildDir.toPath())\n+                    .setTargetDirectory(buildDir.toPath());\n+\n+            for (MavenProject project : project.getCollectedProjects()) {\n+                builder.addLocalArtifact(new AppArtifactKey(project.getGroupId(), project.getArtifactId(), null, \"jar\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1ac693b8146ea095c266d253c414c7b5250628"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDE0Mzk3OnYy", "diffSide": "RIGHT", "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/BootstrapAppModelFactory.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwODozMToxN1rOGe7XdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMToyMjo1N1rOGkW38g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4MzEyNQ==", "bodyText": "I think the app model resolver should be providing the local artifacts instead of the other way around. It resolves them from the workspace anyway.", "url": "https://github.com/quarkusio/quarkus/pull/9765#discussion_r435083125", "createdAt": "2020-06-04T08:31:17Z", "author": {"login": "aloubyansky"}, "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/BootstrapAppModelFactory.java", "diffHunk": "@@ -284,7 +296,7 @@ public CurationResult resolveAppModel() throws BootstrapException {\n                 }\n             }\n             CurationResult curationResult = new CurationResult(getAppModelResolver()\n-                    .resolveManagedModel(appArtifact, forcedDependencies, managingProject));\n+                    .resolveManagedModel(appArtifact, forcedDependencies, managingProject, localArtifacts));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc1ac693b8146ea095c266d253c414c7b5250628"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3MTI4Nw==", "bodyText": "Not every path in the resolver loads the workspace, in particular re-augmentation does not have a workspace available, and if we end up supporting upgrades it won't have it either.", "url": "https://github.com/quarkusio/quarkus/pull/9765#discussion_r440571287", "createdAt": "2020-06-16T03:53:55Z", "author": {"login": "stuartwdouglas"}, "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/BootstrapAppModelFactory.java", "diffHunk": "@@ -284,7 +296,7 @@ public CurationResult resolveAppModel() throws BootstrapException {\n                 }\n             }\n             CurationResult curationResult = new CurationResult(getAppModelResolver()\n-                    .resolveManagedModel(appArtifact, forcedDependencies, managingProject));\n+                    .resolveManagedModel(appArtifact, forcedDependencies, managingProject, localArtifacts));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4MzEyNQ=="}, "originalCommit": {"oid": "fc1ac693b8146ea095c266d253c414c7b5250628"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3NDQyMg==", "bodyText": "Why do we need to treat dependencies from the same workspace as the app root artifact differently than others? Dev and test (given that the jars might not be available yet) modes are obvious. Otherwise, it's all jars. If we do need to unpack certain jars for processing, it'd be cleaner to create a workspace impl for that, imo.", "url": "https://github.com/quarkusio/quarkus/pull/9765#discussion_r440674422", "createdAt": "2020-06-16T08:24:52Z", "author": {"login": "aloubyansky"}, "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/BootstrapAppModelFactory.java", "diffHunk": "@@ -284,7 +296,7 @@ public CurationResult resolveAppModel() throws BootstrapException {\n                 }\n             }\n             CurationResult curationResult = new CurationResult(getAppModelResolver()\n-                    .resolveManagedModel(appArtifact, forcedDependencies, managingProject));\n+                    .resolveManagedModel(appArtifact, forcedDependencies, managingProject, localArtifacts));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4MzEyNQ=="}, "originalCommit": {"oid": "fc1ac693b8146ea095c266d253c414c7b5250628"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc3NjY5MA==", "bodyText": "They are candidates to be updated in remote dev mode, and so need to be treated differently when running in remote dev.\nThinking about it though as these are part of the app if we package them in the lib dir with the rest of the dependencies then when they are updated the full lib layer of the docker image will be invalidated. These should also go in their own directory and have their own layer.", "url": "https://github.com/quarkusio/quarkus/pull/9765#discussion_r440776690", "createdAt": "2020-06-16T11:22:57Z", "author": {"login": "stuartwdouglas"}, "path": "independent-projects/bootstrap/core/src/main/java/io/quarkus/bootstrap/BootstrapAppModelFactory.java", "diffHunk": "@@ -284,7 +296,7 @@ public CurationResult resolveAppModel() throws BootstrapException {\n                 }\n             }\n             CurationResult curationResult = new CurationResult(getAppModelResolver()\n-                    .resolveManagedModel(appArtifact, forcedDependencies, managingProject));\n+                    .resolveManagedModel(appArtifact, forcedDependencies, managingProject, localArtifacts));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4MzEyNQ=="}, "originalCommit": {"oid": "fc1ac693b8146ea095c266d253c414c7b5250628"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0OTU0MzcxOnYy", "diffSide": "RIGHT", "path": "core/deployment/src/main/java/io/quarkus/deployment/dev/RuntimeUpdatesProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNjo1Mjo1OVrOGk3_SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNjo1Mjo1OVrOGk3_SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMxOTI0MA==", "bodyText": "Did you forget to remove this or switch to log?", "url": "https://github.com/quarkusio/quarkus/pull/9765#discussion_r441319240", "createdAt": "2020-06-17T06:52:59Z", "author": {"login": "aloubyansky"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/dev/RuntimeUpdatesProcessor.java", "diffHunk": "@@ -163,6 +195,27 @@ public void consumeNoRestartChanges(Consumer<Set<String>> consumer) {\n         noRestartChangesConsumers.add(consumer);\n     }\n \n+    @Override\n+    public Set<String> syncState(Map<String, String> fileHashes) {\n+        Set<String> ret = new HashSet<>();\n+        try {\n+            Map<String, String> ourHashes = new HashMap<>(IsolatedRemoteDevModeMain.createHashes(applicationRoot));\n+            for (Map.Entry<String, String> i : fileHashes.entrySet()) {\n+                String ours = ourHashes.remove(i.getKey());\n+                if (!Objects.equals(ours, i.getValue())) {\n+                    ret.add(i.getKey());\n+                }\n+            }\n+            for (Map.Entry<String, String> remaining : ourHashes.entrySet()) {\n+                System.out.println(\"Deleting removed file \" + remaining.getKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c6ebff06abc42ede833cdbd30c81214bf1b30a3"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0OTU4NDU4OnYy", "diffSide": "RIGHT", "path": "devtools/maven/src/main/java/io/quarkus/maven/RemoteDevMojo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNzowNjoyMFrOGk4Ypg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMjowOTo0NVrOGlZGyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNTczNA==", "bodyText": "Could you please clarify why you set PROD here?", "url": "https://github.com/quarkusio/quarkus/pull/9765#discussion_r441325734", "createdAt": "2020-06-17T07:06:20Z", "author": {"login": "aloubyansky"}, "path": "devtools/maven/src/main/java/io/quarkus/maven/RemoteDevMojo.java", "diffHunk": "@@ -1,132 +1,21 @@\n package io.quarkus.maven;\n \n-import java.io.File;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Optional;\n-\n-import org.apache.maven.execution.MavenSession;\n-import org.apache.maven.model.Plugin;\n-import org.apache.maven.model.Resource;\n-import org.apache.maven.plugin.AbstractMojo;\n-import org.apache.maven.plugin.MojoExecutionException;\n-import org.apache.maven.plugin.MojoFailureException;\n-import org.apache.maven.plugins.annotations.Component;\n import org.apache.maven.plugins.annotations.LifecyclePhase;\n import org.apache.maven.plugins.annotations.Mojo;\n-import org.apache.maven.plugins.annotations.Parameter;\n import org.apache.maven.plugins.annotations.ResolutionScope;\n-import org.apache.maven.project.MavenProject;\n-import org.eclipse.microprofile.config.Config;\n-import org.eclipse.microprofile.config.ConfigProvider;\n-import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n \n-import io.quarkus.maven.components.MavenVersionEnforcer;\n-import io.quarkus.maven.utilities.MojoUtils;\n-import io.quarkus.remotedev.AgentRunner;\n-import io.quarkus.runtime.configuration.ConfigUtils;\n-import io.quarkus.runtime.configuration.QuarkusConfigFactory;\n-import io.smallrye.config.PropertiesConfigSource;\n-import io.smallrye.config.SmallRyeConfig;\n+import io.quarkus.bootstrap.app.QuarkusBootstrap;\n+import io.quarkus.deployment.dev.DevModeContext;\n+import io.quarkus.deployment.dev.IsolatedRemoteDevModeMain;\n \n /**\n  * The dev mojo, that connects to a remote host.\n  */\n @Mojo(name = \"remote-dev\", defaultPhase = LifecyclePhase.PREPARE_PACKAGE, requiresDependencyResolution = ResolutionScope.COMPILE_PLUS_RUNTIME)\n-public class RemoteDevMojo extends AbstractMojo {\n-\n-    /**\n-     * The directory for compiled classes.\n-     */\n-    @Parameter(readonly = true, required = true, defaultValue = \"${project.build.outputDirectory}\")\n-    private File outputDirectory;\n-\n-    @Parameter(defaultValue = \"${project}\", readonly = true, required = true)\n-    protected MavenProject project;\n-\n-    @Parameter(defaultValue = \"${project.build.sourceDirectory}\")\n-    private File sourceDir;\n-\n-    @Parameter(defaultValue = \"${session}\")\n-    private MavenSession session;\n-\n-    @Component\n-    private MavenVersionEnforcer mavenVersionEnforcer;\n-\n+public class RemoteDevMojo extends DevMojo {\n     @Override\n-    public void execute() throws MojoFailureException, MojoExecutionException {\n-        mavenVersionEnforcer.ensureMavenVersion(getLog(), session);\n-        Plugin found = MojoUtils.checkProjectForMavenBuildPlugin(project);\n-\n-        if (found == null) {\n-            getLog().warn(\"The quarkus-maven-plugin build goal was not configured for this project, \" +\n-                    \"skipping quarkus:remote-dev as this is assumed to be a support library. If you want to run Quarkus remote-dev\"\n-                    +\n-                    \" on this project make sure the quarkus-maven-plugin is configured with a build goal.\");\n-            return;\n-        }\n-\n-        if (!sourceDir.isDirectory()) {\n-            throw new MojoFailureException(\"The `src/main/java` directory is required, please create it.\");\n-        }\n-\n-        String resources = null;\n-        for (Resource i : project.getBuild().getResources()) {\n-            //todo: support multiple resources dirs for config hot deployment\n-            resources = i.getDirectory();\n-            break;\n-        }\n-\n-        String classes = outputDirectory.getAbsolutePath();\n-        String sources = sourceDir.getAbsolutePath();\n-\n-        //first lets look for some config, as it is not on the current class path\n-        //and we need to load it to run the build process\n-        if (resources != null) {\n-            Path config = Paths.get(resources).resolve(\"application.properties\");\n-            if (Files.exists(config)) {\n-                try {\n-                    SmallRyeConfig built = ConfigUtils.configBuilder(false)\n-                            .withSources(new PropertiesConfigSource(config.toUri().toURL())).build();\n-                    QuarkusConfigFactory.setConfig(built);\n-                    final ConfigProviderResolver cpr = ConfigProviderResolver.instance();\n-                    final Config existing = cpr.getConfig();\n-                    if (existing != built) {\n-                        cpr.releaseConfig(existing);\n-                        // subsequent calls will get the new config\n-                    }\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n-            }\n-        }\n-\n-        Optional<String> url = ConfigProvider.getConfig().getOptionalValue(\"quarkus.live-reload.url\", String.class);\n-        Optional<String> password = ConfigProvider.getConfig().getOptionalValue(\"quarkus.live-reload.password\",\n-                String.class);\n-        if (!url.isPresent()) {\n-            throw new MojoFailureException(\"To use remote-dev you must specify quarkus.live-reload.url\");\n-        }\n-        if (!password.isPresent()) {\n-            throw new MojoFailureException(\"To use remote-dev you must specify quarkus.live-reload.password\");\n-        }\n-        System.out.println(sources);\n-        String remotePath = url.get();\n-        if (remotePath.endsWith(\"/\")) {\n-            remotePath = remotePath.substring(0, remotePath.length() - 1);\n-        }\n-        AgentRunner runner = new AgentRunner(resources, sources, classes, remotePath + \"/quarkus/live-reload\",\n-                password.get());\n-\n-        runner.run();\n-        for (;;) {\n-            try {\n-                Thread.sleep(10000);\n-            } catch (InterruptedException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n+    protected void modifyDevModeContext(DevModeContext devModeContext) {\n+        devModeContext.setMode(QuarkusBootstrap.Mode.PROD);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c6ebff06abc42ede833cdbd30c81214bf1b30a3"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg2MTgzMw==", "bodyText": "The first step is to synchronize the local output with the server. We set prod mode to generate a production application to sync. I will add a comment.", "url": "https://github.com/quarkusio/quarkus/pull/9765#discussion_r441861833", "createdAt": "2020-06-17T22:09:45Z", "author": {"login": "stuartwdouglas"}, "path": "devtools/maven/src/main/java/io/quarkus/maven/RemoteDevMojo.java", "diffHunk": "@@ -1,132 +1,21 @@\n package io.quarkus.maven;\n \n-import java.io.File;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Optional;\n-\n-import org.apache.maven.execution.MavenSession;\n-import org.apache.maven.model.Plugin;\n-import org.apache.maven.model.Resource;\n-import org.apache.maven.plugin.AbstractMojo;\n-import org.apache.maven.plugin.MojoExecutionException;\n-import org.apache.maven.plugin.MojoFailureException;\n-import org.apache.maven.plugins.annotations.Component;\n import org.apache.maven.plugins.annotations.LifecyclePhase;\n import org.apache.maven.plugins.annotations.Mojo;\n-import org.apache.maven.plugins.annotations.Parameter;\n import org.apache.maven.plugins.annotations.ResolutionScope;\n-import org.apache.maven.project.MavenProject;\n-import org.eclipse.microprofile.config.Config;\n-import org.eclipse.microprofile.config.ConfigProvider;\n-import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n \n-import io.quarkus.maven.components.MavenVersionEnforcer;\n-import io.quarkus.maven.utilities.MojoUtils;\n-import io.quarkus.remotedev.AgentRunner;\n-import io.quarkus.runtime.configuration.ConfigUtils;\n-import io.quarkus.runtime.configuration.QuarkusConfigFactory;\n-import io.smallrye.config.PropertiesConfigSource;\n-import io.smallrye.config.SmallRyeConfig;\n+import io.quarkus.bootstrap.app.QuarkusBootstrap;\n+import io.quarkus.deployment.dev.DevModeContext;\n+import io.quarkus.deployment.dev.IsolatedRemoteDevModeMain;\n \n /**\n  * The dev mojo, that connects to a remote host.\n  */\n @Mojo(name = \"remote-dev\", defaultPhase = LifecyclePhase.PREPARE_PACKAGE, requiresDependencyResolution = ResolutionScope.COMPILE_PLUS_RUNTIME)\n-public class RemoteDevMojo extends AbstractMojo {\n-\n-    /**\n-     * The directory for compiled classes.\n-     */\n-    @Parameter(readonly = true, required = true, defaultValue = \"${project.build.outputDirectory}\")\n-    private File outputDirectory;\n-\n-    @Parameter(defaultValue = \"${project}\", readonly = true, required = true)\n-    protected MavenProject project;\n-\n-    @Parameter(defaultValue = \"${project.build.sourceDirectory}\")\n-    private File sourceDir;\n-\n-    @Parameter(defaultValue = \"${session}\")\n-    private MavenSession session;\n-\n-    @Component\n-    private MavenVersionEnforcer mavenVersionEnforcer;\n-\n+public class RemoteDevMojo extends DevMojo {\n     @Override\n-    public void execute() throws MojoFailureException, MojoExecutionException {\n-        mavenVersionEnforcer.ensureMavenVersion(getLog(), session);\n-        Plugin found = MojoUtils.checkProjectForMavenBuildPlugin(project);\n-\n-        if (found == null) {\n-            getLog().warn(\"The quarkus-maven-plugin build goal was not configured for this project, \" +\n-                    \"skipping quarkus:remote-dev as this is assumed to be a support library. If you want to run Quarkus remote-dev\"\n-                    +\n-                    \" on this project make sure the quarkus-maven-plugin is configured with a build goal.\");\n-            return;\n-        }\n-\n-        if (!sourceDir.isDirectory()) {\n-            throw new MojoFailureException(\"The `src/main/java` directory is required, please create it.\");\n-        }\n-\n-        String resources = null;\n-        for (Resource i : project.getBuild().getResources()) {\n-            //todo: support multiple resources dirs for config hot deployment\n-            resources = i.getDirectory();\n-            break;\n-        }\n-\n-        String classes = outputDirectory.getAbsolutePath();\n-        String sources = sourceDir.getAbsolutePath();\n-\n-        //first lets look for some config, as it is not on the current class path\n-        //and we need to load it to run the build process\n-        if (resources != null) {\n-            Path config = Paths.get(resources).resolve(\"application.properties\");\n-            if (Files.exists(config)) {\n-                try {\n-                    SmallRyeConfig built = ConfigUtils.configBuilder(false)\n-                            .withSources(new PropertiesConfigSource(config.toUri().toURL())).build();\n-                    QuarkusConfigFactory.setConfig(built);\n-                    final ConfigProviderResolver cpr = ConfigProviderResolver.instance();\n-                    final Config existing = cpr.getConfig();\n-                    if (existing != built) {\n-                        cpr.releaseConfig(existing);\n-                        // subsequent calls will get the new config\n-                    }\n-                } catch (Exception e) {\n-                    throw new RuntimeException(e);\n-                }\n-            }\n-        }\n-\n-        Optional<String> url = ConfigProvider.getConfig().getOptionalValue(\"quarkus.live-reload.url\", String.class);\n-        Optional<String> password = ConfigProvider.getConfig().getOptionalValue(\"quarkus.live-reload.password\",\n-                String.class);\n-        if (!url.isPresent()) {\n-            throw new MojoFailureException(\"To use remote-dev you must specify quarkus.live-reload.url\");\n-        }\n-        if (!password.isPresent()) {\n-            throw new MojoFailureException(\"To use remote-dev you must specify quarkus.live-reload.password\");\n-        }\n-        System.out.println(sources);\n-        String remotePath = url.get();\n-        if (remotePath.endsWith(\"/\")) {\n-            remotePath = remotePath.substring(0, remotePath.length() - 1);\n-        }\n-        AgentRunner runner = new AgentRunner(resources, sources, classes, remotePath + \"/quarkus/live-reload\",\n-                password.get());\n-\n-        runner.run();\n-        for (;;) {\n-            try {\n-                Thread.sleep(10000);\n-            } catch (InterruptedException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n+    protected void modifyDevModeContext(DevModeContext devModeContext) {\n+        devModeContext.setMode(QuarkusBootstrap.Mode.PROD);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNTczNA=="}, "originalCommit": {"oid": "8c6ebff06abc42ede833cdbd30c81214bf1b30a3"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0OTU5NjM4OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/maven-tooling.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNzoxMDowOFrOGk4f_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMjoxMjoyMVrOGlZKUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNzYxNA==", "bodyText": "How about if mutable-application=true we simply use the fast-jar and don't ask users to explicitly pick the type? At some point, I guess, we'll switch to the \"fast jar\" as the default anyway. At which point it'll be better to not bother with the legacy config option values.", "url": "https://github.com/quarkusio/quarkus/pull/9765#discussion_r441327614", "createdAt": "2020-06-17T07:10:08Z", "author": {"login": "aloubyansky"}, "path": "docs/src/main/asciidoc/maven-tooling.adoc", "diffHunk": "@@ -158,30 +158,42 @@ This allows you to develop in the same environment you will actually run your ap\n \n WARNING: Do not use this in production. This should only be used in a development environment. You should not run production application in dev mode.\n \n-To do this you must have the `quarkus-undertow-websockets` extension installed:\n+To do this you must build a 'mutable application', using the `fast-jar` format. Set the following properties in `application.xml`:\n \n-[source,shell]\n+[source,properties]\n ----\n-./mvnw quarkus:add-extension -Dextensions=\"undertow-websockets\"\n+quarkus.package.type=fast-jar <1>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c6ebff06abc42ede833cdbd30c81214bf1b30a3"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg2MjczNw==", "bodyText": "That's kinda problematic, as there is too much code that looks at the packaging type, and then all this code would also need to look at this additional property. I will just add a mutable-jar type to the packaging type.", "url": "https://github.com/quarkusio/quarkus/pull/9765#discussion_r441862737", "createdAt": "2020-06-17T22:12:21Z", "author": {"login": "stuartwdouglas"}, "path": "docs/src/main/asciidoc/maven-tooling.adoc", "diffHunk": "@@ -158,30 +158,42 @@ This allows you to develop in the same environment you will actually run your ap\n \n WARNING: Do not use this in production. This should only be used in a development environment. You should not run production application in dev mode.\n \n-To do this you must have the `quarkus-undertow-websockets` extension installed:\n+To do this you must build a 'mutable application', using the `fast-jar` format. Set the following properties in `application.xml`:\n \n-[source,shell]\n+[source,properties]\n ----\n-./mvnw quarkus:add-extension -Dextensions=\"undertow-websockets\"\n+quarkus.package.type=fast-jar <1>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNzYxNA=="}, "originalCommit": {"oid": "8c6ebff06abc42ede833cdbd30c81214bf1b30a3"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0OTYxMjE4OnYy", "diffSide": "RIGHT", "path": "extensions/vertx-http/deployment/src/main/java/io/quarkus/vertx/http/deployment/devmode/HttpRemoteDevClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNzoxNToxNlrOGk4p6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNzoxNToxNlrOGk4p6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMzMDE1NQ==", "bodyText": "This should either be removed or logged using the log.", "url": "https://github.com/quarkusio/quarkus/pull/9765#discussion_r441330155", "createdAt": "2020-06-17T07:15:16Z", "author": {"login": "aloubyansky"}, "path": "extensions/vertx-http/deployment/src/main/java/io/quarkus/vertx/http/deployment/devmode/HttpRemoteDevClient.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package io.quarkus.vertx.http.deployment.devmode;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.bootstrap.runner.QuarkusEntryPoint;\n+import io.quarkus.deployment.dev.remote.RemoteDevClient;\n+import io.quarkus.deployment.util.IoUtil;\n+import io.quarkus.dev.spi.RemoteDevState;\n+import io.quarkus.vertx.http.runtime.devmode.RemoteSyncHandler;\n+import io.vertx.core.http.HttpHeaders;\n+\n+public class HttpRemoteDevClient implements RemoteDevClient {\n+\n+    private final Logger log = Logger.getLogger(HttpRemoteDevClient.class);\n+\n+    private final String url;\n+    private final String password;\n+\n+    public HttpRemoteDevClient(String url, String password) {\n+        this.url = url.endsWith(\"/\") ? url.substring(0, url.length() - 1) : url;\n+        this.password = password;\n+    }\n+\n+    @Override\n+    public Closeable sendConnectRequest(RemoteDevState initialState,\n+            Function<Set<String>, Map<String, byte[]>> initialConnectFunction, Supplier<SyncResult> changeRequestFunction) {\n+        //so when we connect we send the current state\n+        //the server will respond with a list of files it needs, one per line as a standard UTF-8 document\n+        try {\n+            //we are now good to go\n+            //the server is now up to date\n+            return new Session(initialState, initialConnectFunction, changeRequestFunction);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+    }\n+\n+    private String doConnect(RemoteDevState initialState, Function<Set<String>, Map<String, byte[]>> initialConnectFunction)\n+            throws IOException {\n+        HttpURLConnection connection = (HttpURLConnection) new URL(url + RemoteSyncHandler.CONNECT).openConnection();\n+        connection.addRequestProperty(HttpHeaders.CONTENT_TYPE.toString(), RemoteSyncHandler.APPLICATION_QUARKUS);\n+        connection.addRequestProperty(RemoteSyncHandler.QUARKUS_PASSWORD, password);\n+        connection.setDoOutput(true);\n+        ObjectOutputStream out = new ObjectOutputStream(connection.getOutputStream());\n+        out.writeObject(initialState);\n+        out.close();\n+        String session = connection.getHeaderField(RemoteSyncHandler.QUARKUS_SESSION);\n+        if (session == null) {\n+            throw new IOException(\"Server did not start a remote dev session\");\n+        }\n+        String result = new String(IoUtil.readBytes(connection.getInputStream()), StandardCharsets.UTF_8);\n+        Set<String> changed = new HashSet<>();\n+        changed.addAll(Arrays.asList(result.split(\";\")));\n+        Map<String, byte[]> data = new LinkedHashMap<>(initialConnectFunction.apply(changed));\n+        //this file needs to be sent last\n+        //if it is modified it will trigger a reload\n+        //and we need the rest of the app to be present\n+        byte[] lastFile = data.remove(QuarkusEntryPoint.QUARKUS_APPLICATION_DAT);\n+        if (lastFile != null) {\n+            data.put(QuarkusEntryPoint.QUARKUS_APPLICATION_DAT, lastFile);\n+        }\n+\n+        for (Map.Entry<String, byte[]> entry : data.entrySet()) {\n+            sendData(entry, session);\n+        }\n+        if (lastFile != null) {\n+            //bit of a hack, but if we sent this the app is going to restart\n+            //if we attempt to connect too soon it won't be ready\n+            session = waitForRestart(initialState, initialConnectFunction);\n+        } else {\n+            log.info(\"Connected to remote server\");\n+        }\n+        return session;\n+    }\n+\n+    private String waitForRestart(RemoteDevState initialState,\n+            Function<Set<String>, Map<String, byte[]>> initialConnectFunction) {\n+\n+        long timeout = System.currentTimeMillis() + 30000;\n+        try {\n+            Thread.sleep(1000);\n+        } catch (InterruptedException e) {\n+\n+        }\n+        while (System.currentTimeMillis() < timeout) {\n+            try {\n+                HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n+                IoUtil.readBytes(connection.getInputStream());\n+                return doConnect(initialState, initialConnectFunction);\n+            } catch (IOException e) {\n+\n+            }\n+        }\n+        throw new RuntimeException(\"Could not connect to remote side after restart\");\n+    }\n+\n+    private void sendData(Map.Entry<String, byte[]> entry, String session) throws IOException {\n+        HttpURLConnection connection;\n+        System.out.println(\"Sending \" + entry.getKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c6ebff06abc42ede833cdbd30c81214bf1b30a3"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0OTYzMTE1OnYy", "diffSide": "RIGHT", "path": "extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/devmode/RemoteSyncHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNzoyMDo1OFrOGk41YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMjoxNDowNFrOGlZMnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMzMzA4OA==", "bodyText": "Shouldn't it be remoteProblem instead of the problem which is null here?\nAlso at line 129 you are assigning remoteProblem to problem but in this block you are setting remoteProblem to null. Is that how it is supposed to be? Looks confusing.", "url": "https://github.com/quarkusio/quarkus/pull/9765#discussion_r441333088", "createdAt": "2020-06-17T07:20:58Z", "author": {"login": "aloubyansky"}, "path": "extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/devmode/RemoteSyncHandler.java", "diffHunk": "@@ -0,0 +1,235 @@\n+package io.quarkus.vertx.http.runtime.devmode;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectInputStream;\n+import java.security.SecureRandom;\n+import java.util.Base64;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.quarkus.dev.spi.HotReplacementContext;\n+import io.quarkus.dev.spi.RemoteDevState;\n+import io.quarkus.runtime.ExecutorRecorder;\n+import io.vertx.core.Handler;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpServerRequest;\n+\n+public class RemoteSyncHandler implements Handler<HttpServerRequest> {\n+\n+    public static final String QUARKUS_PASSWORD = \"X-Quarkus-Password\";\n+    private static final Logger log = Logger.getLogger(RemoteSyncHandler.class);\n+\n+    public static final String APPLICATION_QUARKUS = \"application/quarkus-live-reload\";\n+    public static final String QUARKUS_SESSION = \"X-Quarkus-Session\";\n+    public static final String CONNECT = \"/connect\";\n+    public static final String DEV = \"/dev\";\n+\n+    final String password;\n+    final Handler<HttpServerRequest> next;\n+    final HotReplacementContext hotReplacementContext;\n+\n+    //all these are static to allow the handler to be recreated on hot reload\n+    //which makes lifecycle management a lot easier\n+    static volatile String currentSession;\n+    static volatile long currentSessionTimeout;\n+    static volatile Throwable remoteProblem;\n+    static boolean checkForChanges;\n+\n+    public RemoteSyncHandler(String password, Handler<HttpServerRequest> next, HotReplacementContext hotReplacementContext) {\n+        this.password = password;\n+        this.next = next;\n+        this.hotReplacementContext = hotReplacementContext;\n+        hotReplacementContext.addPreScanStep(new Runnable() {\n+            @Override\n+            public void run() {\n+                if (currentSession == null) {\n+                    return;\n+                }\n+                doPreScan();\n+            }\n+        });\n+    }\n+\n+    private void doPreScan() {\n+\n+        synchronized (RemoteSyncHandler.class) {\n+            checkForChanges = true;\n+            //if there is a current dev request this will unblock it\n+            RemoteSyncHandler.class.notifyAll();\n+            try {\n+                RemoteSyncHandler.class.wait(30000);\n+            } catch (InterruptedException e) {\n+                log.error(\"interrupted\", e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handle(HttpServerRequest event) {\n+        long time = System.currentTimeMillis();\n+        if (time > currentSessionTimeout) {\n+            currentSession = null;\n+        }\n+        final String type = event.headers().get(HttpHeaderNames.CONTENT_TYPE);\n+        if (APPLICATION_QUARKUS.equals(type)) {\n+            String rp = event.headers().get(QUARKUS_PASSWORD);\n+            if (!password.equals(rp)) {\n+                log.error(\"Incorrect password\");\n+                event.response().setStatusCode(401).end();\n+                return;\n+            }\n+            currentSessionTimeout = time + 60000;\n+            ExecutorRecorder.getCurrent().execute(new Runnable() {\n+                @Override\n+                public void run() {\n+                    handleRequest(event);\n+                }\n+            });\n+            return;\n+        }\n+        next.handle(event);\n+    }\n+\n+    private void handleRequest(HttpServerRequest event) {\n+        if (event.method().equals(HttpMethod.PUT)) {\n+            handlePut(event);\n+        } else if (event.method().equals(HttpMethod.DELETE)) {\n+            handleDelete(event);\n+        } else if (event.method().equals(HttpMethod.POST)) {\n+            if (event.path().equals(DEV)) {\n+                handleDev(event);\n+            } else if (event.path().equals(CONNECT)) {\n+                handleConnect(event);\n+            } else {\n+                event.response().setStatusCode(404).end();\n+            }\n+        } else {\n+            event.response().setStatusCode(404).end();\n+        }\n+\n+    }\n+\n+    private void handleDev(HttpServerRequest event) {\n+        if (checkSession(event))\n+            return;\n+        event.bodyHandler(new Handler<Buffer>() {\n+            @Override\n+            public void handle(Buffer b) {\n+                ExecutorRecorder.getCurrent().execute(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        try {\n+                            Throwable problem = (Throwable) new ObjectInputStream(new ByteArrayInputStream(b.getBytes()))\n+                                    .readObject();\n+                            if (problem != null) {\n+                                remoteProblem = problem;\n+                                hotReplacementContext.setRemoteProblem(problem);\n+                            } else if (remoteProblem != null) {\n+                                remoteProblem = null;\n+                                hotReplacementContext.setRemoteProblem(problem);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c6ebff06abc42ede833cdbd30c81214bf1b30a3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg2MzMyNQ==", "bodyText": "It should be an explicit null.", "url": "https://github.com/quarkusio/quarkus/pull/9765#discussion_r441863325", "createdAt": "2020-06-17T22:14:04Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/devmode/RemoteSyncHandler.java", "diffHunk": "@@ -0,0 +1,235 @@\n+package io.quarkus.vertx.http.runtime.devmode;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectInputStream;\n+import java.security.SecureRandom;\n+import java.util.Base64;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import io.quarkus.dev.spi.HotReplacementContext;\n+import io.quarkus.dev.spi.RemoteDevState;\n+import io.quarkus.runtime.ExecutorRecorder;\n+import io.vertx.core.Handler;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpServerRequest;\n+\n+public class RemoteSyncHandler implements Handler<HttpServerRequest> {\n+\n+    public static final String QUARKUS_PASSWORD = \"X-Quarkus-Password\";\n+    private static final Logger log = Logger.getLogger(RemoteSyncHandler.class);\n+\n+    public static final String APPLICATION_QUARKUS = \"application/quarkus-live-reload\";\n+    public static final String QUARKUS_SESSION = \"X-Quarkus-Session\";\n+    public static final String CONNECT = \"/connect\";\n+    public static final String DEV = \"/dev\";\n+\n+    final String password;\n+    final Handler<HttpServerRequest> next;\n+    final HotReplacementContext hotReplacementContext;\n+\n+    //all these are static to allow the handler to be recreated on hot reload\n+    //which makes lifecycle management a lot easier\n+    static volatile String currentSession;\n+    static volatile long currentSessionTimeout;\n+    static volatile Throwable remoteProblem;\n+    static boolean checkForChanges;\n+\n+    public RemoteSyncHandler(String password, Handler<HttpServerRequest> next, HotReplacementContext hotReplacementContext) {\n+        this.password = password;\n+        this.next = next;\n+        this.hotReplacementContext = hotReplacementContext;\n+        hotReplacementContext.addPreScanStep(new Runnable() {\n+            @Override\n+            public void run() {\n+                if (currentSession == null) {\n+                    return;\n+                }\n+                doPreScan();\n+            }\n+        });\n+    }\n+\n+    private void doPreScan() {\n+\n+        synchronized (RemoteSyncHandler.class) {\n+            checkForChanges = true;\n+            //if there is a current dev request this will unblock it\n+            RemoteSyncHandler.class.notifyAll();\n+            try {\n+                RemoteSyncHandler.class.wait(30000);\n+            } catch (InterruptedException e) {\n+                log.error(\"interrupted\", e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handle(HttpServerRequest event) {\n+        long time = System.currentTimeMillis();\n+        if (time > currentSessionTimeout) {\n+            currentSession = null;\n+        }\n+        final String type = event.headers().get(HttpHeaderNames.CONTENT_TYPE);\n+        if (APPLICATION_QUARKUS.equals(type)) {\n+            String rp = event.headers().get(QUARKUS_PASSWORD);\n+            if (!password.equals(rp)) {\n+                log.error(\"Incorrect password\");\n+                event.response().setStatusCode(401).end();\n+                return;\n+            }\n+            currentSessionTimeout = time + 60000;\n+            ExecutorRecorder.getCurrent().execute(new Runnable() {\n+                @Override\n+                public void run() {\n+                    handleRequest(event);\n+                }\n+            });\n+            return;\n+        }\n+        next.handle(event);\n+    }\n+\n+    private void handleRequest(HttpServerRequest event) {\n+        if (event.method().equals(HttpMethod.PUT)) {\n+            handlePut(event);\n+        } else if (event.method().equals(HttpMethod.DELETE)) {\n+            handleDelete(event);\n+        } else if (event.method().equals(HttpMethod.POST)) {\n+            if (event.path().equals(DEV)) {\n+                handleDev(event);\n+            } else if (event.path().equals(CONNECT)) {\n+                handleConnect(event);\n+            } else {\n+                event.response().setStatusCode(404).end();\n+            }\n+        } else {\n+            event.response().setStatusCode(404).end();\n+        }\n+\n+    }\n+\n+    private void handleDev(HttpServerRequest event) {\n+        if (checkSession(event))\n+            return;\n+        event.bodyHandler(new Handler<Buffer>() {\n+            @Override\n+            public void handle(Buffer b) {\n+                ExecutorRecorder.getCurrent().execute(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        try {\n+                            Throwable problem = (Throwable) new ObjectInputStream(new ByteArrayInputStream(b.getBytes()))\n+                                    .readObject();\n+                            if (problem != null) {\n+                                remoteProblem = problem;\n+                                hotReplacementContext.setRemoteProblem(problem);\n+                            } else if (remoteProblem != null) {\n+                                remoteProblem = null;\n+                                hotReplacementContext.setRemoteProblem(problem);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMzMzA4OA=="}, "originalCommit": {"oid": "8c6ebff06abc42ede833cdbd30c81214bf1b30a3"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0OTY1MTE3OnYy", "diffSide": "RIGHT", "path": "independent-projects/bootstrap/maven-resolver/src/main/java/io/quarkus/bootstrap/resolver/BootstrapAppModelResolver.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNzoyNzowN1rOGk5CMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwNzoyNzowN1rOGk5CMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMzNjM2OQ==", "bodyText": "Ideally, we should at least match this localProjects to the resolved user dependencies: first, to make sure they are actually present among the resolved deps; second, we can get the actual artifact classifier and types from them.", "url": "https://github.com/quarkusio/quarkus/pull/9765#discussion_r441336369", "createdAt": "2020-06-17T07:27:07Z", "author": {"login": "aloubyansky"}, "path": "independent-projects/bootstrap/maven-resolver/src/main/java/io/quarkus/bootstrap/resolver/BootstrapAppModelResolver.java", "diffHunk": "@@ -264,6 +266,11 @@ public boolean visitLeave(DependencyNode node) {\n \n         List<AppDependency> fullDeploymentDeps = new ArrayList<>(userDeps);\n         fullDeploymentDeps.addAll(deploymentDeps);\n+        //we need these to have a type of 'jar'\n+        //type is blank when loaded\n+        for (AppArtifactKey i : localProjects) {\n+            appBuilder.addLocalProjectArtifact(new AppArtifactKey(i.getGroupId(), i.getArtifactId(), null, \"jar\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c6ebff06abc42ede833cdbd30c81214bf1b30a3"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY2ODcyMTIyOnYy", "diffSide": "RIGHT", "path": "core/deployment/src/main/java/io/quarkus/deployment/dev/RuntimeUpdatesProcessor.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNFQwMzowODoyNFrOIqpHtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNFQxNDoyMzozOFrOIrCcbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTU4NDgyMg==", "bodyText": "@stuartwdouglas I'm thinking if checking the output path first is more adequate. On applications with filtered resources the handler for static resources provides the original and non-filtered files instead the filtered ones in output path. I've asked on Zulip about that issue with filtered resources but no one replied yet.\nI'll appreciate if you have a solution for that situation when proving filtered resources with static handler.", "url": "https://github.com/quarkusio/quarkus/pull/9765#discussion_r581584822", "createdAt": "2021-02-24T03:08:24Z", "author": {"login": "brunolmfg"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/dev/RuntimeUpdatesProcessor.java", "diffHunk": "@@ -94,6 +105,8 @@ public Path getClassesDir() {\n         for (DevModeContext.ModuleInfo i : context.getAllModules()) {\n             if (i.getResourcePath() != null) {\n                 ret.add(Paths.get(i.getResourcePath()));\n+            } else if (i.getResourcesOutputPath() != null) {\n+                ret.add(Paths.get(i.getResourcesOutputPath()));\n             }\n         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b39620b6c6f88475f55e831ff51649ed430cb1a9"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTY2Mzc5OA==", "bodyText": "I've answered on zulip too but just for completeness - open issue with reproducer of the problem is almost always to be preferred.\nSo please go ahead and link to those places you found related to it.", "url": "https://github.com/quarkusio/quarkus/pull/9765#discussion_r581663798", "createdAt": "2021-02-24T06:29:12Z", "author": {"login": "maxandersen"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/dev/RuntimeUpdatesProcessor.java", "diffHunk": "@@ -94,6 +105,8 @@ public Path getClassesDir() {\n         for (DevModeContext.ModuleInfo i : context.getAllModules()) {\n             if (i.getResourcePath() != null) {\n                 ret.add(Paths.get(i.getResourcePath()));\n+            } else if (i.getResourcesOutputPath() != null) {\n+                ret.add(Paths.get(i.getResourcesOutputPath()));\n             }\n         }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTU4NDgyMg=="}, "originalCommit": {"oid": "b39620b6c6f88475f55e831ff51649ed430cb1a9"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTk5OTcyNw==", "bodyText": "Thanks @maxandersen. I've created the issue #15303.", "url": "https://github.com/quarkusio/quarkus/pull/9765#discussion_r581999727", "createdAt": "2021-02-24T14:23:38Z", "author": {"login": "brunolmfg"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/dev/RuntimeUpdatesProcessor.java", "diffHunk": "@@ -94,6 +105,8 @@ public Path getClassesDir() {\n         for (DevModeContext.ModuleInfo i : context.getAllModules()) {\n             if (i.getResourcePath() != null) {\n                 ret.add(Paths.get(i.getResourcePath()));\n+            } else if (i.getResourcesOutputPath() != null) {\n+                ret.add(Paths.get(i.getResourcesOutputPath()));\n             }\n         }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTU4NDgyMg=="}, "originalCommit": {"oid": "b39620b6c6f88475f55e831ff51649ed430cb1a9"}, "originalPosition": 62}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2923, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}