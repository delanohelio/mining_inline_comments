{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk4MDExNzY3", "number": 12531, "title": "Kafka metrics", "bodyText": "Add support for the Kafka MeterBinder if/when the Kafka API is present (and the meter binder is enabled).", "createdAt": "2020-10-05T17:40:11Z", "url": "https://github.com/quarkusio/quarkus/pull/12531", "merged": true, "mergeCommit": {"oid": "1487ea9d4b533405cd66b6857ffd0d6b82afc69c"}, "closed": true, "closedAt": "2020-10-06T16:49:05Z", "author": {"login": "ebullient"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdPpJfBABqjM4NDIxMzQ5MjQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdP5GlmgFqTUwMzAxNDg0Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0e1060d83bc29330585adfe657bec6f5e0ed7056", "author": {"user": {"login": "ebullient", "name": "Erin Schnabel"}}, "url": "https://github.com/quarkusio/quarkus/commit/0e1060d83bc29330585adfe657bec6f5e0ed7056", "committedDate": "2020-10-05T17:38:51Z", "message": "Kafka + Micrometer metrics"}, "afterCommit": {"oid": "d4598f00a4a2c02e88de354d65d321ced3912fde", "author": {"user": {"login": "ebullient", "name": "Erin Schnabel"}}, "url": "https://github.com/quarkusio/quarkus/commit/d4598f00a4a2c02e88de354d65d321ced3912fde", "committedDate": "2020-10-05T19:42:12Z", "message": "Kafka + Micrometer metrics"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d4598f00a4a2c02e88de354d65d321ced3912fde", "author": {"user": {"login": "ebullient", "name": "Erin Schnabel"}}, "url": "https://github.com/quarkusio/quarkus/commit/d4598f00a4a2c02e88de354d65d321ced3912fde", "committedDate": "2020-10-05T19:42:12Z", "message": "Kafka + Micrometer metrics"}, "afterCommit": {"oid": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b", "author": {"user": {"login": "ebullient", "name": "Erin Schnabel"}}, "url": "https://github.com/quarkusio/quarkus/commit/ab7f77eee84cb5f2d80d13737f9e327409e0e26b", "committedDate": "2020-10-06T02:30:03Z", "message": "Kafka + Micrometer metrics"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyNjA3NzU5", "url": "https://github.com/quarkusio/quarkus/pull/12531#pullrequestreview-502607759", "createdAt": "2020-10-06T06:07:27Z", "commit": {"oid": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwNjowNzoyN1rOHc3I5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwNjoxMDo0NVrOHc3M_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNTU3Mw==", "bodyText": "Why is Vert.x mentioned here?", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500025573", "createdAt": "2020-10-06T06:07:27Z", "author": {"login": "cescoffier"}, "path": "extensions/micrometer/deployment/src/main/java/io/quarkus/micrometer/deployment/binder/KafkaBinderProcessor.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package io.quarkus.micrometer.deployment.binder;\n+\n+import java.util.function.BooleanSupplier;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.micrometer.runtime.MicrometerRecorder;\n+import io.quarkus.micrometer.runtime.config.MicrometerConfig;\n+\n+/**\n+ * Add support for Kafka Producer and Consumer instrumentation. Note that\n+ * various bits of support may not be present at deploy time. Avoid referencing\n+ * classes that in turn import optional dependencies.\n+ */\n+public class KafkaBinderProcessor {\n+    static final String KAFKA_CONSUMER_CLASS_NAME = \"org.apache.kafka.clients.consumer.Consumer\";\n+    static final Class<?> KAFKA_CONSUMER_CLASS_CLASS = MicrometerRecorder.getClassForName(KAFKA_CONSUMER_CLASS_NAME);\n+\n+    static final String KAFKA_EVENT_CONSUMER_CLASS_NAME = \"io.quarkus.micrometer.runtime.binder.kafka.KafkaEventObserver\";\n+\n+    static class KafkaSupportEnabled implements BooleanSupplier {\n+        MicrometerConfig mConfig;\n+\n+        public boolean getAsBoolean() {\n+            return KAFKA_CONSUMER_CLASS_CLASS != null && mConfig.checkBinderEnabledWithDefault(mConfig.binder.kafka);\n+        }\n+    }\n+\n+    @BuildStep(onlyIf = KafkaSupportEnabled.class)\n+    AdditionalBeanBuildItem createCDIEventConsumer() {\n+        // Add Vertx meter adapters", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNTg1MQ==", "bodyText": "Should this be logged instead?", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500025851", "createdAt": "2020-10-06T06:08:27Z", "author": {"login": "cescoffier"}, "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.micrometer.runtime.binder.kafka;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.producer.Producer;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Metrics;\n+import io.micrometer.core.instrument.binder.kafka.KafkaClientMetrics;\n+\n+@ApplicationScoped\n+public class KafkaEventObserver {\n+    MeterRegistry registry = Metrics.globalRegistry;\n+    ConcurrentHashMap<Object, KafkaClientMetrics> clientMetrics = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Manage bind/close of KafkaClientMetrics for the specified Consumer.\n+     * If the consumer has not been seen before, it will be bound to the\n+     * Micrometer registry and instrumented using a Kafka MeterBinder.\n+     * If the consumer has been seen before, the MeterBinder will be closed.\n+     * \n+     * @param consumer Observed Kafka Consumer\n+     */\n+    public void consumerCreated(@Observes Consumer<?, ?> consumer) {\n+        KafkaClientMetrics prev = clientMetrics.remove(consumer);\n+        if (prev == null) {\n+            clientMetrics.computeIfAbsent(consumer, x -> {\n+                try {\n+                    KafkaClientMetrics metrics = new KafkaClientMetrics(consumer);\n+                    metrics.bindTo(registry);\n+                    return metrics;\n+                } catch (Throwable t) {\n+                    t.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNjM3Nw==", "bodyText": "Why do you remove it and then computeIfAbsent? Do you expect concurrent access? If I'm not sure it works.", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500026377", "createdAt": "2020-10-06T06:10:03Z", "author": {"login": "cescoffier"}, "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.micrometer.runtime.binder.kafka;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.producer.Producer;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Metrics;\n+import io.micrometer.core.instrument.binder.kafka.KafkaClientMetrics;\n+\n+@ApplicationScoped\n+public class KafkaEventObserver {\n+    MeterRegistry registry = Metrics.globalRegistry;\n+    ConcurrentHashMap<Object, KafkaClientMetrics> clientMetrics = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Manage bind/close of KafkaClientMetrics for the specified Consumer.\n+     * If the consumer has not been seen before, it will be bound to the\n+     * Micrometer registry and instrumented using a Kafka MeterBinder.\n+     * If the consumer has been seen before, the MeterBinder will be closed.\n+     * \n+     * @param consumer Observed Kafka Consumer\n+     */\n+    public void consumerCreated(@Observes Consumer<?, ?> consumer) {\n+        KafkaClientMetrics prev = clientMetrics.remove(consumer);\n+        if (prev == null) {\n+            clientMetrics.computeIfAbsent(consumer, x -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNjUyMw==", "bodyText": "it might be safer to just synchronized the whole method.", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500026523", "createdAt": "2020-10-06T06:10:30Z", "author": {"login": "cescoffier"}, "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.micrometer.runtime.binder.kafka;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.producer.Producer;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Metrics;\n+import io.micrometer.core.instrument.binder.kafka.KafkaClientMetrics;\n+\n+@ApplicationScoped\n+public class KafkaEventObserver {\n+    MeterRegistry registry = Metrics.globalRegistry;\n+    ConcurrentHashMap<Object, KafkaClientMetrics> clientMetrics = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Manage bind/close of KafkaClientMetrics for the specified Consumer.\n+     * If the consumer has not been seen before, it will be bound to the\n+     * Micrometer registry and instrumented using a Kafka MeterBinder.\n+     * If the consumer has been seen before, the MeterBinder will be closed.\n+     * \n+     * @param consumer Observed Kafka Consumer\n+     */\n+    public void consumerCreated(@Observes Consumer<?, ?> consumer) {\n+        KafkaClientMetrics prev = clientMetrics.remove(consumer);\n+        if (prev == null) {\n+            clientMetrics.computeIfAbsent(consumer, x -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNjM3Nw=="}, "originalCommit": {"oid": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNjYyMA==", "bodyText": "Same comment", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500026620", "createdAt": "2020-10-06T06:10:45Z", "author": {"login": "cescoffier"}, "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.micrometer.runtime.binder.kafka;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.producer.Producer;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Metrics;\n+import io.micrometer.core.instrument.binder.kafka.KafkaClientMetrics;\n+\n+@ApplicationScoped\n+public class KafkaEventObserver {\n+    MeterRegistry registry = Metrics.globalRegistry;\n+    ConcurrentHashMap<Object, KafkaClientMetrics> clientMetrics = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Manage bind/close of KafkaClientMetrics for the specified Consumer.\n+     * If the consumer has not been seen before, it will be bound to the\n+     * Micrometer registry and instrumented using a Kafka MeterBinder.\n+     * If the consumer has been seen before, the MeterBinder will be closed.\n+     * \n+     * @param consumer Observed Kafka Consumer\n+     */\n+    public void consumerCreated(@Observes Consumer<?, ?> consumer) {\n+        KafkaClientMetrics prev = clientMetrics.remove(consumer);\n+        if (prev == null) {\n+            clientMetrics.computeIfAbsent(consumer, x -> {\n+                try {\n+                    KafkaClientMetrics metrics = new KafkaClientMetrics(consumer);\n+                    metrics.bindTo(registry);\n+                    return metrics;\n+                } catch (Throwable t) {\n+                    t.printStackTrace();\n+                    return null;\n+                }\n+            });\n+        } else {\n+            prev.close();\n+        }\n+    }\n+\n+    /**\n+     * Manage bind/close of KafkaClientMetrics for the specified Producer.\n+     * If the producer has not been seen before, it will be bound to the\n+     * Micrometer registry and instrumented using a Kafka MeterBinder.\n+     * If the producer has been seen before, the MeterBinder will be closed.\n+     * \n+     * @param producer Observed Kafka Producer\n+     */\n+    public void producerCreated(@Observes Producer<?, ?> producer) {\n+        KafkaClientMetrics prev = clientMetrics.remove(producer);\n+        if (prev == null) {\n+            clientMetrics.computeIfAbsent(producer, x -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b"}, "originalPosition": 57}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70b007ee99452e8a992b9a190a05aa14f80a6e29", "author": {"user": {"login": "ebullient", "name": "Erin Schnabel"}}, "url": "https://github.com/quarkusio/quarkus/commit/70b007ee99452e8a992b9a190a05aa14f80a6e29", "committedDate": "2020-10-06T13:01:20Z", "message": "Warning message for deprecated property"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41f29547c223eab20bc4b8bce6f91ba1aa02c61a", "author": {"user": {"login": "ebullient", "name": "Erin Schnabel"}}, "url": "https://github.com/quarkusio/quarkus/commit/41f29547c223eab20bc4b8bce6f91ba1aa02c61a", "committedDate": "2020-10-06T13:01:20Z", "message": "Kafka + Micrometer metrics"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b", "author": {"user": {"login": "ebullient", "name": "Erin Schnabel"}}, "url": "https://github.com/quarkusio/quarkus/commit/ab7f77eee84cb5f2d80d13737f9e327409e0e26b", "committedDate": "2020-10-06T02:30:03Z", "message": "Kafka + Micrometer metrics"}, "afterCommit": {"oid": "41f29547c223eab20bc4b8bce6f91ba1aa02c61a", "author": {"user": {"login": "ebullient", "name": "Erin Schnabel"}}, "url": "https://github.com/quarkusio/quarkus/commit/41f29547c223eab20bc4b8bce6f91ba1aa02c61a", "committedDate": "2020-10-06T13:01:20Z", "message": "Kafka + Micrometer metrics"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyOTgxMjAz", "url": "https://github.com/quarkusio/quarkus/pull/12531#pullrequestreview-502981203", "createdAt": "2020-10-06T13:47:20Z", "commit": {"oid": "41f29547c223eab20bc4b8bce6f91ba1aa02c61a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzMDE0ODQz", "url": "https://github.com/quarkusio/quarkus/pull/12531#pullrequestreview-503014843", "createdAt": "2020-10-06T14:17:53Z", "commit": {"oid": "41f29547c223eab20bc4b8bce6f91ba1aa02c61a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1866, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}