{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM1ODQxMTM5", "number": 13802, "title": "Resteasy reactive docs", "bodyText": "Still missing an intro and links to our API, but ready for review for the rest.\nI've put the jaxrs spec in the quarkus website for now, until we get confirmation we are allowed to. I think it'd be useful if we can.\nI took the editorial choice of making this a guide for people who don't necessarily know JAX-RS or even REST well. As a result I explain a lot of the day to day REST stuff, and clear up some confusion introduced by JAX-RS using the wrong terms in many places.\nI organised it with basic/common stuff first, and advanced stuff in a later section.\nI don't explain the client at all, but I believe this should be done in a separate documentation anyway.\nLet me know if I'm missing use-cases.", "createdAt": "2020-12-10T10:45:41Z", "url": "https://github.com/quarkusio/quarkus/pull/13802", "merged": true, "mergeCommit": {"oid": "1ac613e2a09a3c3e74e201f4a91373375ad0e037"}, "closed": true, "closedAt": "2020-12-16T16:01:46Z", "author": {"login": "FroMage"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdk0y9ZAFqTU0OTI5MzAzMw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmw0MygBqjQxMjAzNjQ2OTY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5MjkzMDMz", "url": "https://github.com/quarkusio/quarkus/pull/13802#pullrequestreview-549293033", "createdAt": "2020-12-10T15:09:14Z", "commit": {"oid": "5cde4943aec547bfcd64b41b939f2b5d2c3a0b77"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNTowOToxNFrOIDN81Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNTowOToxNFrOIDN81Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI0NTIwNQ==", "bodyText": "Good catch!", "url": "https://github.com/quarkusio/quarkus/pull/13802#discussion_r540245205", "createdAt": "2020-12-10T15:09:14Z", "author": {"login": "geoand"}, "path": "independent-projects/resteasy-reactive/server/runtime/src/main/java/org/jboss/resteasy/reactive/server/core/ServerSerialisers.java", "diffHunk": "@@ -185,10 +185,10 @@ public static boolean invokeWriter(ResteasyReactiveRequestContext context, Objec\n                     context.setResponseContentType(mediaType);\n                 }\n                 if (writerInterceptors == null) {\n+                    ServerSerialisers.encodeResponseHeaders(context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cde4943aec547bfcd64b41b939f2b5d2c3a0b77"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5Mjk1MzEx", "url": "https://github.com/quarkusio/quarkus/pull/13802#pullrequestreview-549295311", "createdAt": "2020-12-10T15:11:26Z", "commit": {"oid": "5cde4943aec547bfcd64b41b939f2b5d2c3a0b77"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNToxMToyNlrOIDOD4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjowMDo1OVrOIDQlAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI0NzAwOQ==", "bodyText": "Maybe this should be before the Getting Started?", "url": "https://github.com/quarkusio/quarkus/pull/13802#discussion_r540247009", "createdAt": "2020-12-10T15:11:26Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/rest-reactive.adoc", "diffHunk": "@@ -0,0 +1,1553 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Writing REST Services with RESTEasy Reactive\n+\n+include::./attributes.adoc[]\n+:jaxrsapi: https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1\n+:jaxrsspec: /specs/jaxrs/2.1/index.html\n+:jdkapi: https://docs.oracle.com/en/java/javase/11/docs/api/java.base\n+:mutinyapi: https://smallrye.io/smallrye-mutiny/apidocs\n+:httpspec: https://tools.ietf.org/html/rfc7231\n+:jsonpapi: https://javadoc.io/doc/javax.json/javax.json-api/1.1.4\n+:vertxapi: https://javadoc.io/static/io.vertx/vertx-core/3.9.4\n+\n+This guide explains how to write REST Services with RESTEasy Reactive\n+\n+TODO: buff this\n+\n+TODO: links to our javadoc\n+\n+== What is RESTEasy Reactive?\n+\n+RESTEasy Reactive is a new link:{jaxrsspec}[JAX-RS]\n+implementation written from the ground up to work on our\n+common https://vertx.io/[Vert.x] layer and is thus fully reactive, while also being very tightly integrated with\n+Quarkus and consequently moving a lot of work to build time.\n+\n+You should be able to use it in place of any JAX-RS implementation, but on top of that it has\n+great performance for both blocking and non-blocking endpoints, and a lot of new features on top\n+of what JAX-RS provides.\n+\n+== Writing endpoints\n+\n+=== Getting started\n+\n+Add the following import to your `pom.xml` file:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-resteasy-reactive</artifactId>\n+</dependency>\n+----\n+\n+You can now write your first endpoint in the `org.acme.rest.Endpoint` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+=== Terminology", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cde4943aec547bfcd64b41b939f2b5d2c3a0b77"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI2Mzc1MQ==", "bodyText": "Although it's definitely useful information, I think mentioning idempotent in a doc design for people that doen't have much REST experience might be a little much", "url": "https://github.com/quarkusio/quarkus/pull/13802#discussion_r540263751", "createdAt": "2020-12-10T15:31:11Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/rest-reactive.adoc", "diffHunk": "@@ -0,0 +1,1553 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Writing REST Services with RESTEasy Reactive\n+\n+include::./attributes.adoc[]\n+:jaxrsapi: https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1\n+:jaxrsspec: /specs/jaxrs/2.1/index.html\n+:jdkapi: https://docs.oracle.com/en/java/javase/11/docs/api/java.base\n+:mutinyapi: https://smallrye.io/smallrye-mutiny/apidocs\n+:httpspec: https://tools.ietf.org/html/rfc7231\n+:jsonpapi: https://javadoc.io/doc/javax.json/javax.json-api/1.1.4\n+:vertxapi: https://javadoc.io/static/io.vertx/vertx-core/3.9.4\n+\n+This guide explains how to write REST Services with RESTEasy Reactive\n+\n+TODO: buff this\n+\n+TODO: links to our javadoc\n+\n+== What is RESTEasy Reactive?\n+\n+RESTEasy Reactive is a new link:{jaxrsspec}[JAX-RS]\n+implementation written from the ground up to work on our\n+common https://vertx.io/[Vert.x] layer and is thus fully reactive, while also being very tightly integrated with\n+Quarkus and consequently moving a lot of work to build time.\n+\n+You should be able to use it in place of any JAX-RS implementation, but on top of that it has\n+great performance for both blocking and non-blocking endpoints, and a lot of new features on top\n+of what JAX-RS provides.\n+\n+== Writing endpoints\n+\n+=== Getting started\n+\n+Add the following import to your `pom.xml` file:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-resteasy-reactive</artifactId>\n+</dependency>\n+----\n+\n+You can now write your first endpoint in the `org.acme.rest.Endpoint` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+=== Terminology\n+\n+REST:: https://en.wikipedia.org/wiki/Representational_state_transfer[REpresentational State Transfer]\n+Endpoint:: Java method which is called to serve a REST call\n+URL / URI (Uniform Resource Locator / Identifier):: Used to identify the location of REST resources (https://tools.ietf.org/html/rfc7230#section-2.7[specification])\n+Resource:: Represents your domain object. This is what your API serves and modifies. Also called an `entity` in JAX-RS.\n+Representation:: How your resource is represented on the wire, can vary depending on content types\n+Content type:: Designates a particular representation (also called a media type), for example `text/plain` or `application/json`\n+HTTP:: Underlying wire protocol for routing REST calls (see https://tools.ietf.org/html/rfc7230[HTTP specifications])\n+HTTP request:: the request part of the HTTP call, consisting of an HTTP method, a target URI, headers and an optional message body\n+HTTP response:: the response part of the HTTP call, consisting of an HTTP response status, headers and an optional message body\n+\n+=== Declaring endpoints: URI mapping\n+\n+Any class annotated with a link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation can have its methods exposed as REST endpoints,\n+provided they have an HTTP method annotation (see below).\n+\n+That link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation defines the URI prefix under which those methods will be exposed. It can\n+be empty, or contain a prefix such as `rest` or `rest/V1`.\n+\n+Each exposed endpoint method can in turn have another link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation which adds to its containing\n+class annotation. For example, this defines a `rest/hello` endpoint:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"rest\")\n+public class Endpoint {\n+\n+    @Path(\"hello\")\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+See <<uri-parameters,URI parameters>> for more information about URI mapping.\n+\n+=== Declaring endpoints: HTTP methods\n+\n+Each endpoint method must be annotated with one of the following annotations, which defines which HTTP\n+method will be mapped to the method:\n+\n+.Table HTTP method annotations\n+|===\n+|Annotation|Usage \n+\n+|link:{jaxrsapi}/javax/ws/rs/GET.html[`@GET`]\n+|Obtain a resource representation, should not modify state, idempotent (link:{httpspec}#section-4.3.1[HTTP docs])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cde4943aec547bfcd64b41b939f2b5d2c3a0b77"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI2OTM4NA==", "bodyText": "This isn't rendering properly", "url": "https://github.com/quarkusio/quarkus/pull/13802#discussion_r540269384", "createdAt": "2020-12-10T15:37:46Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/rest-reactive.adoc", "diffHunk": "@@ -0,0 +1,1553 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Writing REST Services with RESTEasy Reactive\n+\n+include::./attributes.adoc[]\n+:jaxrsapi: https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1\n+:jaxrsspec: /specs/jaxrs/2.1/index.html\n+:jdkapi: https://docs.oracle.com/en/java/javase/11/docs/api/java.base\n+:mutinyapi: https://smallrye.io/smallrye-mutiny/apidocs\n+:httpspec: https://tools.ietf.org/html/rfc7231\n+:jsonpapi: https://javadoc.io/doc/javax.json/javax.json-api/1.1.4\n+:vertxapi: https://javadoc.io/static/io.vertx/vertx-core/3.9.4\n+\n+This guide explains how to write REST Services with RESTEasy Reactive\n+\n+TODO: buff this\n+\n+TODO: links to our javadoc\n+\n+== What is RESTEasy Reactive?\n+\n+RESTEasy Reactive is a new link:{jaxrsspec}[JAX-RS]\n+implementation written from the ground up to work on our\n+common https://vertx.io/[Vert.x] layer and is thus fully reactive, while also being very tightly integrated with\n+Quarkus and consequently moving a lot of work to build time.\n+\n+You should be able to use it in place of any JAX-RS implementation, but on top of that it has\n+great performance for both blocking and non-blocking endpoints, and a lot of new features on top\n+of what JAX-RS provides.\n+\n+== Writing endpoints\n+\n+=== Getting started\n+\n+Add the following import to your `pom.xml` file:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-resteasy-reactive</artifactId>\n+</dependency>\n+----\n+\n+You can now write your first endpoint in the `org.acme.rest.Endpoint` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+=== Terminology\n+\n+REST:: https://en.wikipedia.org/wiki/Representational_state_transfer[REpresentational State Transfer]\n+Endpoint:: Java method which is called to serve a REST call\n+URL / URI (Uniform Resource Locator / Identifier):: Used to identify the location of REST resources (https://tools.ietf.org/html/rfc7230#section-2.7[specification])\n+Resource:: Represents your domain object. This is what your API serves and modifies. Also called an `entity` in JAX-RS.\n+Representation:: How your resource is represented on the wire, can vary depending on content types\n+Content type:: Designates a particular representation (also called a media type), for example `text/plain` or `application/json`\n+HTTP:: Underlying wire protocol for routing REST calls (see https://tools.ietf.org/html/rfc7230[HTTP specifications])\n+HTTP request:: the request part of the HTTP call, consisting of an HTTP method, a target URI, headers and an optional message body\n+HTTP response:: the response part of the HTTP call, consisting of an HTTP response status, headers and an optional message body\n+\n+=== Declaring endpoints: URI mapping\n+\n+Any class annotated with a link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation can have its methods exposed as REST endpoints,\n+provided they have an HTTP method annotation (see below).\n+\n+That link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation defines the URI prefix under which those methods will be exposed. It can\n+be empty, or contain a prefix such as `rest` or `rest/V1`.\n+\n+Each exposed endpoint method can in turn have another link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation which adds to its containing\n+class annotation. For example, this defines a `rest/hello` endpoint:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"rest\")\n+public class Endpoint {\n+\n+    @Path(\"hello\")\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+See <<uri-parameters,URI parameters>> for more information about URI mapping.\n+\n+=== Declaring endpoints: HTTP methods\n+\n+Each endpoint method must be annotated with one of the following annotations, which defines which HTTP\n+method will be mapped to the method:\n+\n+.Table HTTP method annotations\n+|===\n+|Annotation|Usage \n+\n+|link:{jaxrsapi}/javax/ws/rs/GET.html[`@GET`]\n+|Obtain a resource representation, should not modify state, idempotent (link:{httpspec}#section-4.3.1[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/HEAD.html[`@HEAD`]\n+|Obtain metadata about a resource, similar to `GET` with no body (link:{httpspec}#section-4.3.2[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/POST.html[`@POST`]\n+|Create a resource and obtain a link to it (link:{httpspec}#section-4.3.3[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PUT.html[`@PUT`]\n+|Replace a resource or create one, should be idempotent (link:{httpspec}#section-4.3.4[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/DELETE.html[`@DELETE`]\n+|Delete an existing resource, idempotent  (link:{httpspec}#section-4.3.5[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/OPTIONS.html[`@OPTIONS`]\n+|Obtain information about a resource, idempotent (link:{httpspec}#section-4.3.7[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PATCH.html[`@PATCH`]\n+|Update a resource, or create one, not idempotent (https://tools.ietf.org/html/rfc5789#section-2[HTTP docs])\n+\n+|===\n+\n+You can also declare other HTTP methods by declaring them as an annotation with the\n+link:{jaxrsapi}/javax/ws/rs/HttpMethod.html[`@HttpMethod`] annotation:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+import javax.ws.rs.HttpMethod;\n+import javax.ws.rs.Path;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@HttpMethod(\"FROMAGE\")\n+@interface FROMAGE {\n+}\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @FROMAGE\n+    public String hello(){\n+        return \"Hello, Cheese World!\";\n+    }\n+}\n+----\n+\n+=== Declaring endpoints: representation / content types\n+\n+Each endpoint method may consume or produce specific resource representations, which are indicated by\n+the HTTP link:{httpspec}#section-3.1.1.5[`Content-Type`] header, which in turn contains \n+link:{httpspec}#section-3.1.1.1[MIME (Media Type)] values, such as the following:\n+\n+- `text/plain` which is the default for any endpoint returning a `String`.\n+- `text/html` for HTML (such as with link:qute[Qute templating])\n+- `application/json` for a <<json,JSON REST endpoint>>\n+- `text/*` which is a sub-type wildcard for any text media type\n+- `*/*` which is a wildcard for any media type", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cde4943aec547bfcd64b41b939f2b5d2c3a0b77"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI3MTU4Mg==", "bodyText": "You could ditch this and just annotate the other constructor with @JsonCreator", "url": "https://github.com/quarkusio/quarkus/pull/13802#discussion_r540271582", "createdAt": "2020-12-10T15:40:28Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/rest-reactive.adoc", "diffHunk": "@@ -0,0 +1,1553 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Writing REST Services with RESTEasy Reactive\n+\n+include::./attributes.adoc[]\n+:jaxrsapi: https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1\n+:jaxrsspec: /specs/jaxrs/2.1/index.html\n+:jdkapi: https://docs.oracle.com/en/java/javase/11/docs/api/java.base\n+:mutinyapi: https://smallrye.io/smallrye-mutiny/apidocs\n+:httpspec: https://tools.ietf.org/html/rfc7231\n+:jsonpapi: https://javadoc.io/doc/javax.json/javax.json-api/1.1.4\n+:vertxapi: https://javadoc.io/static/io.vertx/vertx-core/3.9.4\n+\n+This guide explains how to write REST Services with RESTEasy Reactive\n+\n+TODO: buff this\n+\n+TODO: links to our javadoc\n+\n+== What is RESTEasy Reactive?\n+\n+RESTEasy Reactive is a new link:{jaxrsspec}[JAX-RS]\n+implementation written from the ground up to work on our\n+common https://vertx.io/[Vert.x] layer and is thus fully reactive, while also being very tightly integrated with\n+Quarkus and consequently moving a lot of work to build time.\n+\n+You should be able to use it in place of any JAX-RS implementation, but on top of that it has\n+great performance for both blocking and non-blocking endpoints, and a lot of new features on top\n+of what JAX-RS provides.\n+\n+== Writing endpoints\n+\n+=== Getting started\n+\n+Add the following import to your `pom.xml` file:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-resteasy-reactive</artifactId>\n+</dependency>\n+----\n+\n+You can now write your first endpoint in the `org.acme.rest.Endpoint` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+=== Terminology\n+\n+REST:: https://en.wikipedia.org/wiki/Representational_state_transfer[REpresentational State Transfer]\n+Endpoint:: Java method which is called to serve a REST call\n+URL / URI (Uniform Resource Locator / Identifier):: Used to identify the location of REST resources (https://tools.ietf.org/html/rfc7230#section-2.7[specification])\n+Resource:: Represents your domain object. This is what your API serves and modifies. Also called an `entity` in JAX-RS.\n+Representation:: How your resource is represented on the wire, can vary depending on content types\n+Content type:: Designates a particular representation (also called a media type), for example `text/plain` or `application/json`\n+HTTP:: Underlying wire protocol for routing REST calls (see https://tools.ietf.org/html/rfc7230[HTTP specifications])\n+HTTP request:: the request part of the HTTP call, consisting of an HTTP method, a target URI, headers and an optional message body\n+HTTP response:: the response part of the HTTP call, consisting of an HTTP response status, headers and an optional message body\n+\n+=== Declaring endpoints: URI mapping\n+\n+Any class annotated with a link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation can have its methods exposed as REST endpoints,\n+provided they have an HTTP method annotation (see below).\n+\n+That link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation defines the URI prefix under which those methods will be exposed. It can\n+be empty, or contain a prefix such as `rest` or `rest/V1`.\n+\n+Each exposed endpoint method can in turn have another link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation which adds to its containing\n+class annotation. For example, this defines a `rest/hello` endpoint:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"rest\")\n+public class Endpoint {\n+\n+    @Path(\"hello\")\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+See <<uri-parameters,URI parameters>> for more information about URI mapping.\n+\n+=== Declaring endpoints: HTTP methods\n+\n+Each endpoint method must be annotated with one of the following annotations, which defines which HTTP\n+method will be mapped to the method:\n+\n+.Table HTTP method annotations\n+|===\n+|Annotation|Usage \n+\n+|link:{jaxrsapi}/javax/ws/rs/GET.html[`@GET`]\n+|Obtain a resource representation, should not modify state, idempotent (link:{httpspec}#section-4.3.1[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/HEAD.html[`@HEAD`]\n+|Obtain metadata about a resource, similar to `GET` with no body (link:{httpspec}#section-4.3.2[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/POST.html[`@POST`]\n+|Create a resource and obtain a link to it (link:{httpspec}#section-4.3.3[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PUT.html[`@PUT`]\n+|Replace a resource or create one, should be idempotent (link:{httpspec}#section-4.3.4[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/DELETE.html[`@DELETE`]\n+|Delete an existing resource, idempotent  (link:{httpspec}#section-4.3.5[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/OPTIONS.html[`@OPTIONS`]\n+|Obtain information about a resource, idempotent (link:{httpspec}#section-4.3.7[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PATCH.html[`@PATCH`]\n+|Update a resource, or create one, not idempotent (https://tools.ietf.org/html/rfc5789#section-2[HTTP docs])\n+\n+|===\n+\n+You can also declare other HTTP methods by declaring them as an annotation with the\n+link:{jaxrsapi}/javax/ws/rs/HttpMethod.html[`@HttpMethod`] annotation:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+import javax.ws.rs.HttpMethod;\n+import javax.ws.rs.Path;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@HttpMethod(\"FROMAGE\")\n+@interface FROMAGE {\n+}\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @FROMAGE\n+    public String hello(){\n+        return \"Hello, Cheese World!\";\n+    }\n+}\n+----\n+\n+=== Declaring endpoints: representation / content types\n+\n+Each endpoint method may consume or produce specific resource representations, which are indicated by\n+the HTTP link:{httpspec}#section-3.1.1.5[`Content-Type`] header, which in turn contains \n+link:{httpspec}#section-3.1.1.1[MIME (Media Type)] values, such as the following:\n+\n+- `text/plain` which is the default for any endpoint returning a `String`.\n+- `text/html` for HTML (such as with link:qute[Qute templating])\n+- `application/json` for a <<json,JSON REST endpoint>>\n+- `text/*` which is a sub-type wildcard for any text media type\n+- `*/*` which is a wildcard for any media type\n+\n+You may annotate your endpoint class with the link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces`] \n+or link:{jaxrsapi}/javax/ws/rs/Consumes.html[`@Consumes`] annotations, which\n+allow you to specify one or more media types that your endpoint may accept as HTTP request body\n+or produce as HTTP response body. Those class annotations apply to each method.\n+\n+Any method may also be annotated with the link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces`] \n+or link:{jaxrsapi}/javax/ws/rs/Consumes.html[`@Consumes`] annotations, in which\n+case they override any eventual class annotation.\n+\n+The link:{jaxrsapi}/javax/ws/rs/core/MediaType.html[`MediaType`] class has many constants you\n+can use to point to specific pre-defined media types.\n+\n+See <<negotiation>> for more information.\n+\n+=== Accessing request parameters\n+\n+[[request-parameters]]\n+\n+NOTE: don't forget to configure your compiler to generate parameter name information with `-parameters` (javac)\n+or `<parameters>` or `<maven.compiler.parameters>` (https://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#parameters[Maven]).\n+\n+The following HTTP request elements may be obtained by your endpoint method:\n+\n+.Table HTTP request parameter annotations\n+|===\n+|HTTP element|Annotation|Usage \n+\n+|[[path-parameter]]Path parameter\n+|`@RestPath` (or nothing)\n+|URI template parameter (simplified version of the https://tools.ietf.org/html/rfc6570[URI Template specification]), \n+see <<uri-parameters,URI parameters>> for more information.\n+\n+|Query parameter\n+|`@RestQuery`\n+|The value of an https://tools.ietf.org/html/rfc3986#section-3.4[URI query parameter]\n+\n+|Header\n+|`@RestHeader`\n+|The value of an https://tools.ietf.org/html/rfc7230#section-3.2[HTTP header]\n+\n+|Cookie\n+|`@RestCookie`\n+|The value of an https://tools.ietf.org/html/rfc6265#section-4.2[HTTP cookie]\n+\n+|Form parameter\n+|`@RestForm`\n+|The value of an https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST[HTTP URL-encoded FORM]\n+\n+|Matrix parameter\n+|`@RestMatrix`\n+|The value of an https://tools.ietf.org/html/rfc3986#section-3.3[URI path segment parameter]\n+\n+|===\n+\n+For each of those annotations, you may specify the name of the element they refer to, otherwise\n+they will use the name of the annotated method parameter.\n+\n+If a client made the following HTTP call:\n+\n+[source,http]\n+----\n+POST /cheeses;variant=goat/tomme?age=matured HTTP/1.1\n+Content-Type: application/x-www-form-urlencoded\n+Cookie: level=hardcore\n+X-Cheese-Secret-Handshake: fist-bump\n+\n+smell=strong\n+----\n+\n+Then you could obtain all the various parameters with this endpoint method:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+\n+import org.jboss.resteasy.reactive.RestCookie;\n+import org.jboss.resteasy.reactive.RestForm;\n+import org.jboss.resteasy.reactive.RestHeader;\n+import org.jboss.resteasy.reactive.RestMatrix;\n+import org.jboss.resteasy.reactive.RestPath;\n+import org.jboss.resteasy.reactive.RestQuery;\n+\n+@Path(\"/cheeses/{type}\")\n+public class Endpoint {\n+\n+    @POST\n+    public String allParams(@RestPath String type,\n+                            @RestMatrix String variant,\n+                            @RestQuery String age,\n+                            @RestCookie String level,\n+                            @RestHeader(\"X-Cheese-Secret-Handshake\")\n+                            String secretHandshake,\n+                            @RestForm String smell){\n+        return type + \"/\" + variant + \"/\" + age + \"/\" + level + \"/\" + secretHandshake + \"/\" + smell;\n+    }\n+}\n+----\n+\n+NOTE: the `@RestPath` annotation is optional: any parameter whose name matches an existing URI\n+template variable will be automatically assumed to have `@RestPath`.\n+\n+Naturally you can also use any of the JAX-RS annotations link:{jaxrsapi}/javax/ws/rs/PathParam.html[`@PathParam`],\n+link:{jaxrsapi}/javax/ws/rs/QueryParam.html[`@QueryParam`],\n+link:{jaxrsapi}/javax/ws/rs/HeaderParam.html[`@HeaderParam`],\n+link:{jaxrsapi}/javax/ws/rs/CookieParam.html[`@CookieParam`],\n+link:{jaxrsapi}/javax/ws/rs/FormParam.html[`@FormParam`] or\n+link:{jaxrsapi}/javax/ws/rs/MatrixParam.html[`@MatrixParam`] for this,\n+but they require you to specify the parameter name.\n+\n+See <<parameter-mapping>> for more advanced use-cases.\n+\n+=== Declaring URI parameters\n+\n+[[uri-parameters]]\n+\n+You can declare URI parameters and use regular expressions in your path, so for instance\n+the following endpoint will serve requests for `/hello/stef/23` and `/hello` but not\n+`/hello/stef/0x23`:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"hello\")\n+public class Endpoint {\n+\n+    @Path(\"{name}/{age:\\\\d+}\")\n+    @GET\n+    public String personalisedHello(String name, int age){\n+        return \"Hello \" + name + \" is your age really \" + age + \"?\";\n+    }\n+\n+    @GET\n+    public String genericHello(){\n+        return \"Hello stranger\";\n+    }\n+}\n+----\n+\n+\n+=== Accessing the request body\n+\n+Any method parameter with no annotation will receive the method body.footnote:[Unless it is a\n+<<path-parameter,URI template parameter>> or a <<context-objects,context object>>.], after it has been mapped from\n+its HTTP representation to the Java type of the parameter.\n+\n+The following parameter types will be supported out of the box:\n+\n+[[resource-types]]\n+\n+.Table Request body parameter type\n+|===\n+|Type|Usage\n+\n+|link:{jdkapi}/java/io/File.html[`File`]\n+|The entire request body in a temporary file\n+\n+|`byte[]`\n+|The entire request body, not decoded\n+\n+|`char[]`\n+|The entire request body, decoded\n+\n+|link:{jdkapi}/java/lang/String.html[`String`]\n+|The entire request body, decoded\n+\n+|link:{jdkapi}/java/io/InputStream.html[`InputStream`]\n+|The request body in a blocking stream\n+\n+|link:{jdkapi}/java/io/Reader.html[`Reader`]\n+|The request body in a blocking stream\n+\n+|All Java primitives and their wrapper classes\n+|Java primitive types\n+\n+|link:{jdkapi}/java/math/BigDecimal.html[`BigDecimal`], link:{jdkapi}/java/math/BigInteger.html[`BigInteger`]\n+|Large integers and decimals.\n+\n+|link:{jsonpapi}/javax/json/JsonArray.html[`JsonArray`], link:{jsonpapi}/javax/json/JsonArray.html[`JsonObject`],\n+link:{jsonpapi}/javax/json/JsonArray.html[`JsonStructure`], link:{jsonpapi}/javax/json/JsonArray.html[`JsonValue`]\n+|JSON value types  \n+\n+|link:{vertxapi}io/vertx/core/buffer/Buffer.html[`Buffer`]\n+|Vert.x Buffer \n+\n+|any other type\n+|Will be <<json,mapped from JSON to that type>>\n+\n+|===\n+\n+NOTE: You can add support for more <<readers-writers,body parameter types>>.\n+\n+=== Returning a response body\n+\n+In order to return an HTTP response, simply return the resource you want from your method. The method\n+return type and its optional content type will be used to decide how to serialise it to the HTTP\n+response (see <<negotiation>> for more advanced information).\n+\n+You can return any of the pre-defined types that you can read from the <<resource-types,HTTP response>>,\n+and any other type will be mapped <<json,from that type to JSON>>.\n+\n+Alternately, you can also return a <<reactive,reactive type>> such as link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`], \n+link:{mutinyapi}/io/smallrye/mutiny/Multi.html[`Multi`] or \n+link:{jdkapi}/java/util/concurrent/CompletionStage.html[`CompletionStage`]\n+that resolve to one of the mentioned return types.\n+\n+=== Setting other response properties\n+\n+If you need to set more properties on the HTTP response than just the body, such as the status code\n+or headers, you can make your method return the link:{jaxrsapi}/javax/ws/rs/core/Response.html[`Response`]\n+type:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.NewCookie;\n+import javax.ws.rs.core.Response;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public Response hello() {\n+        // HTTP OK status with text/plain content type\n+        return Response.ok(\"Hello, World!\", MediaType.TEXT_PLAIN_TYPE)\n+         // set a response header\n+         .header(\"X-FroMage\", \"Camembert\")\n+         // set the Expires response header to two days from now\n+         .expires(Date.from(Instant.now().plus(Duration.ofDays(2))))\n+         // send a new cookie\n+         .cookie(new NewCookie(\"Flavour\", \"pralin\u00e9\"))\n+         // end of builder API\n+         .build();\n+    }\n+}\n+----\n+\n+=== Async/reactive support\n+\n+[[reactive]]\n+\n+If your endpoint method needs to accomplish an asynchronous or reactive task before\n+being able to answer, you can declare your method to return the \n+link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`] type (from https://smallrye.io/smallrye-mutiny/[Mutiny]), in which\n+case the current HTTP request will be automatically suspended after your method, until\n+the returned link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`] instance resolves to a value,\n+which will be mapped to a response exactly according to the previously described rules:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"escoffier\")\n+public class Endpoint {\n+\n+    @GET\n+    public Uni<Book> culinaryGuide(){\n+        return Book.findByIsbn(\"978-2081229297\");\n+    }\n+}\n+----\n+\n+This allows you to not block the IO thread while the book is being fetched from the\n+database, and allows Quarkus to serve more requests until your book is ready to\n+be sent to the client and terminate this request. Check out our \n+<<execution-model,Execution Model documentation>> for more information.\n+\n+The link:{jdkapi}/java/util/concurrent/CompletionStage.html[`CompletionStage`] return\n+type is also supported.\n+\n+=== Streaming support\n+\n+If you want to stream your response element by element, you can make your endpoint method return a \n+link:{mutinyapi}/io/smallrye/mutiny/Multi.html[`Multi`] type (from https://smallrye.io/smallrye-mutiny/[Mutiny]).\n+This is especially useful for streaming text or binary data.\n+\n+This example, using link:reactive-messaging-http.html[Reactive Messaging] shows how to stream\n+text data:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import org.eclipse.microprofile.reactive.messaging.Channel;\n+\n+import io.smallrye.mutiny.Multi;\n+\n+@Path(\"logs\")\n+public class Endpoint {\n+\n+    @Inject\n+    @Channel(\"log-out\")\n+    Multi<String> logs;\n+\n+    @GET\n+    public Multi<String> streamLogs() {\n+        return logs;\n+    }\n+}\n+----\n+\n+=== Server-Sent Event (SSE) support\n+\n+If you want to stream JSON objects in your response, you can use \n+https://html.spec.whatwg.org/multipage/server-sent-events.html[Server-Sent Events]\n+by just annotating your endpoint method with \n+link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces(MediaType.SERVER_SENT_EVENTS)`]\n+and specifying that each element should be <<json,serialised to JSON>> with \n+`@RestSseElementType(MediaType.APPLICATION_JSON)`.\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.jboss.resteasy.reactive.RestSseElementType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import io.smallrye.reactive.messaging.annotations.Channel;\n+\n+@Path(\"escoffier\")\n+public class Endpoint {\n+\n+    // Inject our Book channel\n+    @Inject\n+    @Channel(\"book-out\")\n+    Multi<Book> books;\n+\n+    @GET\n+    // Send the stream over SSE\n+    @Produces(MediaType.SERVER_SENT_EVENTS)\n+    // Each element will be sent as JSON\n+    @RestSseElementType(MediaType.APPLICATION_JSON)\n+    public Multi<Book> stream() {\n+        return books;\n+    }\n+}\n+----\n+\n+=== Accessing context objects\n+\n+[[context-objects]]\n+\n+There are a number of contextual objects that the framework will give you, if your endpoint\n+method takes parameters of the following type:\n+\n+.Table Context object\n+|===\n+|Type|Usage\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/HttpHeaders.html[`HttpHeaders`]\n+|All the request headers\n+\n+|link:{jaxrsapi}/javax/ws/rs/container/ResourceInfo.html[`ResourceInfo`]\n+|Information about the current endpoint method and class (requires reflection)\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/SecurityContext.html[`SecurityContext`]\n+|Access to the current user and roles\n+\n+|`SimpleResourceInfo`\n+|Information about the current endpoint method and class (no reflection required)\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/UriInfo.html[`UriInfo`]\n+|Provides information about the current endpoint and application URI\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Application.html[`Application`]\n+|Advanced: Current JAX-RS application class\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Configuration.html[`Configuration`]\n+|Advanced: Configuration about the deployed JAX-RS application\n+\n+|link:{jaxrsapi}/javax/ws/rs/ext/Providers.html[`Providers`]\n+|Advanced: Runtime access to JAX-RS providers\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Request.html[`Request`]\n+|Advanced: Access to the current HTTP method and <<preconditions>>\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/ResourceContext.html[`ResourceContext`]\n+|Advanced: access to instances of endpoints\n+\n+|`ServerRequestContext`\n+|Advanced: RESTEasy Reactive access to the current request/response\n+\n+|link:{jaxrsapi}/javax/ws/rs/sse/Sse.html[`Sse`]\n+|Advanced: Complex SSE use-cases\n+\n+|===\n+\n+For example, here is how you can return the name of the currently logged-in user:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.security.Principal;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.SecurityContext;\n+\n+@Path(\"user\")\n+public class Endpoint {\n+\n+    @GET\n+    public String userName(SecurityContext security) {\n+        Principal user = security.getUserPrincipal();\n+        return user != null ? user.getName() : \"<NOT LOGGED IN>\";\n+    }\n+}\n+----\n+\n+You can also inject those context objects using \n+https://javadoc.io/static/javax.inject/javax.inject/1/javax/inject/Inject.html[`@Inject`] on fields of the same\n+type.\n+\n+=== JSON serialisation\n+\n+[[json]]\n+\n+You can import either of the following modules to get support for JSON:\n+\n+.Table Context object\n+|===\n+|GAV|Usage\n+\n+|`io.quarkus:quarkus-resteasy-jackson`\n+|https://github.com/FasterXML/jackson[Jackson support]\n+\n+|`io.quarkus:quarkus-resteasy-jsonb`\n+|http://json-b.net/[JSONB support]\n+\n+|===\n+\n+In both cases, importing those modules will allow HTTP message bodies to be read from JSON\n+and serialised to JSON, for <<resource-types,all the types not already registered with a more specific\n+serialisation>>.\n+\n+== More advanced usage\n+\n+Here are some more advanced topics that you may not need to know about initially, but\n+could prove useful for more complex use-cases.\n+\n+=== Execution model, blocking, non-blocking\n+\n+[[execution-model]]\n+\n+RESTEasy Reactive is implemented using two main thread types:\n+\n+- IO threads: which are responsible for reading bytes from the HTTP request and\n+ writing bytes back to the HTTP response\n+- Worker threads: they are pooled and can be used to offload long-running operations\n+\n+The IO threads (often called the \"event loop\") are responsible for actually performing all the IO\n+operations in an asynchronous way, and to trigger any listener interested in the completion of those\n+IO operations.\n+\n+By default, RESTEasy Reactive will run endpoint methods on the IO threads, on the assumption that\n+they are going to be fast and only invoke non-blocking operations.\n+\n+This is the model of execution that leads to best performance if your endpoints do not do any blocking\n+operation (such as blocking IO, blocking on an asynchronous operation, or sleeping).\n+\n+If your endpoint method needs to do any of those blocking operations, you should add the \n+https://javadoc.io/doc/io.smallrye.common/smallrye-common-annotation/1.5.0/io/smallrye/common/annotation/Blocking.html[`@Blocking`]\n+annotation on your endpoint and it will instead be invoked on a worker thread. Your endpoint method\n+code can remain exactly the same, and it will be allowed to block:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.common.annotation.Blocking;\n+\n+@Path(\"yawn\")\n+public class Endpoint {\n+\n+    @Blocking\n+    @GET\n+    public String blockingHello() throws InterruptedException {\n+        // do a blocking operation\n+        Thread.sleep(1000);\n+        return \"Yaaaawwwwnnnnnn\u2026\";\n+    }\n+}\n+----\n+\n+Most of the time, there are ways to achieve the same blocking operations in an asynchronous/reactive\n+way, using https://smallrye.io/smallrye-mutiny/[Mutiny], http://hibernate.org/reactive/[Hibernate Reactive] \n+or any of the link:getting-started-reactive[Quarkus Reactive extensions] for example:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.time.Duration;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"yawn\")\n+public class Endpoint {\n+\n+    @GET\n+    public Uni<String> blockingHello() throws InterruptedException {\n+        return Uni.createFrom().item(\"Yaaaawwwwnnnnnn\u2026\")\n+                // do a non-blocking sleep\n+                .onItem().delayIt().by(Duration.ofSeconds(2));\n+    }\n+}\n+----\n+\n+=== Exception mapping\n+\n+If your application needs to return non-nominal HTTP codes in error cases, the best is\n+to throw exceptions that will result in the proper HTTP response being sent by the\n+framework using link:{jaxrsapi}/javax/ws/rs/WebApplicationException.html[`WebApplicationException`] or any of its subtypes:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.BadRequestException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.Path;\n+\n+@Path(\"fromages/{fromage}\")\n+public class Endpoint {\n+\n+    @GET\n+    public String findFromage(String fromage) {\n+        if(fromage == null)\n+            // send a 400\n+            throw new BadRequestException();\n+        if(!fromage.equals(\"camembert\"))\n+            // send a 404\n+            throw new NotFoundException(\"Unknown cheese: \" + fromage);\n+        return \"Camembert is a very nice cheese\";\n+    }\n+}\n+----\n+\n+If your endpoint method is delegating calls to another service layer which\n+does not know of JAX-RS, you need a way to turn service exceptions to an\n+HTTP response, and you can do that using the `@ServerExceptionMapper` annotation\n+on a method, with one parameter of the exception type you want to handle, and turning\n+that exception into a link:{jaxrsapi}/javax/ws/rs/core/Response.html[`Response`] (or a \n+link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni<Response>`]):\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.util.Map;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.ws.rs.BadRequestException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.resteasy.reactive.server.ServerExceptionMapper;\n+\n+class UnknownCheeseException extends RuntimeException {\n+    public final String name;\n+    \n+    public UnknownCheeseException(String name) {\n+        this.name = name;\n+    }\n+}\n+\n+@ApplicationScoped\n+class CheeseService {\n+    private static final Map<String, String> cheeses = \n+            Map.of(\"camembert\", \"Camembert is a very nice cheese\",\n+                   \"gouda\", \"Gouda is acceptable too, especially with cumin\");\n+\n+    public String findCheese(String name) {\n+        String ret = cheeses.get(name);\n+        if(ret != null)\n+            return ret;\n+        throw new UnknownCheeseException(name);\n+    }\n+}\n+\n+@Path(\"fromages/{fromage}\")\n+public class Endpoint {\n+\n+    @Inject\n+    CheeseService cheeses;\n+    \n+    @ServerExceptionMapper\n+    public Response mapException(UnknownCheeseException x) {\n+        return Response.status(Response.Status.NOT_FOUND)\n+                       .entity(\"Unknown cheese: \" + x.name)\n+                       .build();\n+    }\n+    \n+    @GET\n+    public String findFromage(String fromage) {\n+        if(fromage == null)\n+            // send a 400\n+            throw new BadRequestException();\n+        return cheeses.findCheese(fromage);\n+    }\n+} \n+----\n+\n+NOTE: exception mappers defined in REST endpoint classes will only be called if the\n+exception is thrown in the same class. If you want to define global exception mappers,\n+simply define them outside a REST endpoint class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.resteasy.reactive.server.ServerExceptionMapper;\n+\n+class ExceptionMappers {\n+    @ServerExceptionMapper\n+    public Response mapException(UnknownCheeseException x) {\n+        return Response.status(Response.Status.NOT_FOUND)\n+                       .entity(\"Unknown cheese: \" + x.name)\n+                       .build();\n+    }\n+}\n+----\n+\n+Naturally, you can also declare link:{jaxrsspec}#exceptionmapper[exception mappers in the JAX-RS way].\n+\n+Your exception mapper may declare any of the following parameter types:\n+\n+.Table Exception mapper parameters\n+|===\n+|Type|Usage\n+\n+|An exception type\n+|Defines the exception type you want to handle\n+\n+|Any of the <<context-objects,Context objects>>\n+|\n+\n+|link:{jaxrsapi}/javax/ws/rs/container/ContainerRequestContext.html[`ContainerRequestContext`]\n+|A context object to access the current request\n+\n+|===\n+\n+It may declare any of the following return types:\n+\n+.Table Exception mapper return types\n+|===\n+|Type|Usage\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Response.html[`Response`]\n+|The response to send to the client when the exception occurs\n+\n+|link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni<Response>`]\n+|An asynchronous response to send to the client when the exception occurs\n+\n+|===\n+\n+=== Request or response filters\n+\n+You can declare functions which are invoked in the following phases of the request processing:\n+\n+- Before the endpoint method is identified: pre-routing request filter\n+- After routing, but before the endpoint method is called: normal request filter\n+- After the endpoint method is called: response filter\n+\n+These filters allow you to do various things such as examine the request URI,\n+HTTP method, influence routing, look or change request headers, abort the request,\n+or modify the response.\n+\n+// TODO: link\n+Request filters can be declared with the `@ServerRequestFilter` annotation:\n+\n+[source,java]\n+----\n+class Filters {\n+    \n+    @ServerRequestFilter(preMatching = true)\n+    public void preMatchingFilter(ContainerRequestContext requestContext) {\n+        // make sure we don't lose cheese lovers\n+        if(\"yes\".equals(requestContext.getHeaderString(\"Cheese\"))) {\n+            requestContext.setRequestUri(URI.create(\"/cheese\"));\n+        }\n+    }\n+    \n+    @ServerRequestFilter\n+    public void getFilter(ContainerRequestContext ctx) {\n+        // only allow GET methods for now\n+        if(ctx.getMethod().equals(HttpMethod.GET)) {\n+            ctx.abortWith(Response.status(Response.Status.METHOD_NOT_ALLOWED).build());\n+        }\n+    }\n+}\n+----\n+\n+// TODO: link\n+Similarly, response filters can be declared with the `@ServerResponseFilter` annotation:\n+\n+[source,java]\n+----\n+class Filters {\n+    @ServerResponseFilter\n+    public void getFilter(ContainerResponseContext responseContext) {\n+        Object entity = responseContext.getEntity();\n+        if(entity instanceof String) {\n+            // make it shout\n+            responseContext.setEntity(((String)entity).toUpperCase());\n+        }\n+    }\n+}\n+----\n+\n+Naturally, you can also link:{jaxrsspec}#filters[declare request and response filters in the JAX-RS way].\n+\n+Your filters may declare any of the following parameter types:\n+\n+.Table Filter parameters\n+|===\n+|Type|Usage\n+\n+|Any of the <<context-objects,Context objects>>\n+|\n+\n+|link:{jaxrsapi}/javax/ws/rs/container/ContainerRequestContext.html[`ContainerRequestContext`]\n+|A context object to access the current request\n+\n+|link:{jaxrsapi}/javax/ws/rs/container/ContainerResponseContext.html[`ContainerResponseContext`]\n+|A context object to access the current response\n+\n+|link:{jdkapi}/java/lang/Throwable.html[`Throwable`]\n+|Any thrown exception, or `null` (only for response filters)\n+\n+|===\n+\n+It may declare any of the following return types:\n+\n+.Table Filter return types\n+|===\n+|Type|Usage\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Response.html[`Response`]\n+|The response to send to the client instead of continuing the filter chain, or `null` if the filter chain should proceed\n+\n+|link:{jdkapi}/java/util/Optional.html[`Optional<Response>`]\n+|An optional response to send to the client instead of continuing the filter chain, or an empty value if the filter chain should proceed\n+\n+|link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni<Response>`]\n+|An asynchronous response to send to the client instead of continuing the filter chain, or `null` if the filter chain should proceed\n+\n+|===\n+\n+=== Readers and Writers: mapping entities and HTTP bodies\n+\n+[[readers-writers]]\n+\n+Whenever your endpoint methods return a object (of when they return a \n+link:{jaxrsapi}/javax/ws/rs/core/Response.html[`Response`] with\n+an entity), RESTEasy Reactive will look for a way to map that into an HTTP response body.\n+\n+Similarly, whenever your endpoint method takes an object as parameter, we will look for\n+a way to map the HTTP request body into that object.\n+\n+This is done via a pluggable system of link:{jaxrsapi}/javax/ws/rs/ext/MessageBodyReader.html[`MessageBodyReader`]\n+and link:{jaxrsapi}/javax/ws/rs/ext/MessageBodyWriter.html[`MessageBodyWriter`] interfaces,\n+which are responsible for defining which Java type they map from/to, for which media types,\n+and how they turn HTTP bodies to/from Java instances of that type.\n+\n+For example, if we have our own `FroMage` type on our endpoint:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+\n+class FroMage {\n+    public String name;\n+    \n+    public FroMage(String name) {\n+        this.name = name;\n+    }\n+}\n+\n+@Path(\"cheese\")\n+public class Endpoint {\n+\n+    @GET\n+    public FroMage sayCheese() {\n+        return new FroMage(\"Cheeeeeese\");\n+    }\n+\n+    @PUT\n+    public void addCheese(FroMage fromage) {\n+        System.err.println(\"Received a new cheese: \" + fromage.name);\n+    }\n+}\n+----\n+\n+Then we can define how to read and write it with our body reader/writers, annotated\n+with link:{jaxrsapi}/javax/ws/rs/ext/Provider.html[`@Provider`]:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+\n+import javax.ws.rs.WebApplicationException;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.ext.MessageBodyReader;\n+import javax.ws.rs.ext.MessageBodyWriter;\n+import javax.ws.rs.ext.Provider;\n+\n+@Provider\n+public class FroMageBodyHandler implements MessageBodyReader<FroMage>, \n+                                           MessageBodyWriter<FroMage> {\n+\n+    @Override\n+    public boolean isWriteable(Class<?> type, Type genericType, \n+                               Annotation[] annotations, MediaType mediaType) {\n+        return type == FroMage.class;\n+    }\n+\n+    @Override\n+    public void writeTo(FroMage t, Class<?> type, Type genericType, \n+                        Annotation[] annotations, MediaType mediaType,\n+                        MultivaluedMap<String, Object> httpHeaders, \n+                        OutputStream entityStream)\n+            throws IOException, WebApplicationException {\n+        entityStream.write((\"[FroMageV1]\" + t.name)\n+                           .getBytes(StandardCharsets.UTF_8));\n+    }\n+\n+    @Override\n+    public boolean isReadable(Class<?> type, Type genericType, \n+                              Annotation[] annotations, MediaType mediaType) {\n+        return type == FroMage.class;\n+    }\n+\n+    @Override\n+    public FroMage readFrom(Class<FroMage> type, Type genericType, \n+                            Annotation[] annotations, MediaType mediaType,\n+                            MultivaluedMap<String, String> httpHeaders,\n+                            InputStream entityStream)\n+            throws IOException, WebApplicationException {\n+        String body = new String(entityStream.readAllBytes(), StandardCharsets.UTF_8);\n+        if(body.startsWith(\"[FroMageV1]\"))\n+            return new FroMage(body.substring(11));\n+        throw new IOException(\"Invalid fromage: \" + body);\n+    }\n+\n+}\n+----\n+\n+If you want to get the most performance our of your writer, you can extend `ServerMessageBodyWriter` instead\n+of link:{jaxrsapi}/javax/ws/rs/ext/MessageBodyWriter.html[`MessageBodyWriter`]\n+where you will be able to use less reflection and bypass the blocking IO layer:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+\n+import javax.ws.rs.WebApplicationException;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.ext.MessageBodyReader;\n+import javax.ws.rs.ext.Provider;\n+\n+import org.jboss.resteasy.reactive.server.spi.ResteasyReactiveResourceInfo;\n+import org.jboss.resteasy.reactive.server.spi.ServerMessageBodyWriter;\n+import org.jboss.resteasy.reactive.server.spi.ServerRequestContext;\n+\n+@Provider\n+public class FroMageBodyHandler implements MessageBodyReader<FroMage>, \n+                                           ServerMessageBodyWriter<FroMage> {\n+\n+    // \u2026\n+\n+    @Override\n+    public boolean isWriteable(Class<?> type, ResteasyReactiveResourceInfo target, \n+                               MediaType mediaType) {\n+        return type == FroMage.class;\n+    }\n+\n+    @Override\n+    public void writeResponse(FroMage t, ServerRequestContext context) \n+      throws WebApplicationException, IOException {\n+        context.serverResponse().end(\"[FroMageV1]\" + t.name);\n+    }\n+}\n+----\n+\n+NOTE: You can restrict which content-types your reader/writer apply to by adding \n+link:{jaxrsapi}/javax/ws/rs/Consumes.html[`Consumes`]/link:{jaxrsapi}/javax/ws/rs/Produces.html[`Produces`] annotations\n+on your provider class.\n+\n+=== Reader and Writer interceptors\n+\n+Just as you can intercept requests and responses, you can also intercept readers and writers, by\n+extending the link:{jaxrsapi}/javax/ws/rs/ext/ReaderInterceptor.html[`ReaderInterceptor`] or \n+link:{jaxrsapi}/javax/ws/rs/ext/WriterInterceptor.html[`WriterInterceptor`] on a class annotated with \n+link:{jaxrsapi}/javax/ws/rs/ext/Provider.html[`@Provider`].\n+\n+If we look at this endpoint:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+\n+@Path(\"cheese\")\n+public class Endpoint {\n+\n+    @GET\n+    public String sayCheese() {\n+        return \"Cheeeeeese\";\n+    }\n+\n+    @PUT\n+    public void addCheese(String fromage) {\n+        System.err.println(\"Received a new cheese: \" + fromage);\n+    }\n+}\n+----\n+\n+We can add reader and writer interceptors like this:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.io.IOException;\n+\n+import javax.ws.rs.WebApplicationException;\n+import javax.ws.rs.ext.Provider;\n+import javax.ws.rs.ext.ReaderInterceptor;\n+import javax.ws.rs.ext.ReaderInterceptorContext;\n+import javax.ws.rs.ext.WriterInterceptor;\n+import javax.ws.rs.ext.WriterInterceptorContext;\n+\n+@Provider\n+public class FroMageIOInterceptor implements ReaderInterceptor, WriterInterceptor {\n+\n+    @Override\n+    public void aroundWriteTo(WriterInterceptorContext context)\n+      throws IOException, WebApplicationException {\n+        System.err.println(\"Before writing \" + context.getEntity());\n+        context.proceed();\n+        System.err.println(\"After writing \" + context.getEntity());\n+    }\n+\n+    @Override\n+    public Object aroundReadFrom(ReaderInterceptorContext context)\n+      throws IOException, WebApplicationException {\n+        System.err.println(\"Before reading \" + context.getGenericType());\n+        Object entity = context.proceed();\n+        System.err.println(\"After reading \" + entity);\n+        return entity;\n+    }\n+}\n+----\n+\n+=== Parameter mapping\n+\n+All <<request-parameters,Request Parameters>> can be declared as link:{jdkapi}/java/lang/String.html[`String`], but also\n+any of the following types:\n+\n+- Types for which a link:{jaxrsapi}/javax/ws/rs/ext/ParamConverter.html[`ParamConverter`] is available via a registered \n+link:{jaxrsapi}/javax/ws/rs/ext/ParamConverterProvider.html[`ParamConverterProvider`].\n+- Primitive types.\n+- Types that have a constructor that accepts a single link:{jdkapi}/java/lang/String.html[`String`] argument.\n+- Types that have a static method named `valueOf` or `fromString` with a single link:{jdkapi}/java/lang/String.html[`String`] argument\n+that return an instance of the type. If both methods are present then `valueOf` will be used unless\n+the type is an `enum` in which case `fromString` will be used.\n+- link:{jdkapi}/java/util/List.html[`List<T>`], link:{jdkapi}/java/util/Set.html[`Set<T>`], or \n+link:{jdkapi}/java/util/SortedSet.html[`SortedSet<T>`], where `T` satisfies any above criterion.\n+\n+The following example illustrates all those possibilities:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Type;\n+import java.util.List;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.ext.ParamConverter;\n+import javax.ws.rs.ext.ParamConverterProvider;\n+import javax.ws.rs.ext.Provider;\n+\n+import org.jboss.resteasy.reactive.RestQuery;\n+\n+@Provider\n+class MyConverterProvider implements ParamConverterProvider {\n+\n+    @Override\n+    public <T> ParamConverter<T> getConverter(Class<T> rawType, Type genericType,\n+                                              Annotation[] annotations) {\n+        // declare a converter for this type\n+        if(rawType == Converter.class) {\n+            return (ParamConverter<T>) new MyConverter();\n+        }\n+        return null;\n+    }\n+    \n+}\n+\n+// this is my custom converter\n+class MyConverter implements ParamConverter<Converter> {\n+\n+    @Override\n+    public Converter fromString(String value) {\n+        return new Converter(value);\n+    }\n+\n+    @Override\n+    public String toString(Converter value) {\n+        return value.value;\n+    }\n+    \n+}\n+\n+// this uses a converter\n+class Converter {\n+    String value;\n+    Converter(String value) {\n+        this.value = value;\n+    }\n+}\n+\n+class Constructor {\n+    String value;\n+    // this will use the constructor\n+    public Constructor(String value) {\n+        this.value = value;\n+    }\n+}\n+\n+class ValueOf {\n+    String value;\n+    private ValueOf(String value) {\n+        this.value = value;\n+    }\n+    // this will use the valueOf method\n+    public ValueOf valueOf(String value) {\n+        return new ValueOf(value);\n+    }\n+}\n+\n+@Path(\"hello\")\n+public class Endpoint {\n+\n+    @Path(\"{converter}/{constructor}/{primitive}/{valueOf}\")\n+    @GET\n+    public String convertions(Converter converter, Constructor constructor,\n+                              int primitive, ValueOf valueOf, \n+                              @RestQuery List<Constructor> list){\n+        return converter + \"/\" + constructor + \"/\" + primitive \n+               + \"/\" + valueOf + \"/\" + list;\n+    }\n+}\n+----\n+\n+=== Preconditions\n+\n+https://tools.ietf.org/html/rfc7232[HTTP allows requests to be conditional], based on a number of\n+conditions, such as:\n+\n+- Date of last resource modification\n+- A resource tag, similar to a hash code of the resource to designate its state or version\n+\n+Let's see how you can do conditional request validation using the\n+link:{jaxrsapi}/javax/ws/rs/core/Request.html[`Request`] context object:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.TemporalUnit;\n+import java.util.Date;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.EntityTag;\n+import javax.ws.rs.core.Request;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.ResponseBuilder;\n+\n+@Path(\"conditional\")\n+public class Endpoint {\n+\n+    // It's important to keep our date on seconds because that's how it's sent to the\n+    // user in the Last-Modified header\n+    private Date date = Date.from(Instant.now().truncatedTo(ChronoUnit.SECONDS));\n+    private int version = 1;\n+    private EntityTag tag = new EntityTag(\"v1\");\n+    private String resource = \"Some resource\";\n+    \n+    @GET\n+    public Response get(Request request){\n+        // first evaluate preconditions\n+        ResponseBuilder conditionalResponse = request.evaluatePreconditions(date, tag);\n+        if(conditionalResponse != null)\n+            return conditionalResponse.build();\n+        // preconditions are OK\n+        return Response.ok(resource)\n+                .lastModified(date)\n+                .tag(tag)\n+                .build();\n+    }\n+\n+    @PUT\n+    public Response put(Request request, String body){\n+        // first evaluate preconditions\n+        ResponseBuilder conditionalResponse = request.evaluatePreconditions(date, tag);\n+        if(conditionalResponse != null)\n+            return conditionalResponse.build();\n+        // preconditions are OK, we can update our resource\n+        resource = body;\n+        date = Date.from(Instant.now().truncatedTo(ChronoUnit.SECONDS));\n+        version++;\n+        tag = new EntityTag(\"v\" + version);\n+        return Response.ok(resource)\n+                .lastModified(date)\n+                .tag(tag)\n+                .build();\n+    }\n+}\n+----\n+\n+When we call `GET /conditional` the first time, we will get this response:\n+\n+```\n+HTTP/1.1 200 OK\n+Content-Type: text/plain;charset=UTF-8\n+ETag: \"v1\"\n+Last-Modified: Wed, 09 Dec 2020 16:10:19 GMT\n+Content-Length: 13\n+\n+Some resource\n+```\n+\n+So now if we want to check if we need to fetch a new version, we can make the following request:\n+\n+```\n+GET /conditional HTTP/1.1\n+Host: localhost:8080\n+If-Modified-Since: Wed, 09 Dec 2020 16:10:19 GMT\n+```\n+\n+And we would get the following response:\n+\n+```\n+HTTP/1.1 304 Not Modified\n+```\n+\n+Because the resource has not been modified since that date. This saves on sending the resource,\n+but can also help your users detect concurrent modification, for example, let's suppose that one\n+client wants to update the resource, but another user has modified it since. You can follow the\n+previous `GET` request with this update:\n+\n+```\n+PUT /conditional HTTP/1.1\n+Host: localhost:8080\n+If-Unmodified-Since: Wed, 09 Dec 2020 16:25:43 GMT\n+If-Match: v1\n+Content-Length: 8\n+Content-Type: text/plain\n+\n+newstuff\n+```\n+\n+And if some other user has modified the resource between your `GET` and your `PUT` you would\n+get this answer back:\n+\n+```\n+HTTP/1.1 412 Precondition Failed\n+ETag: \"v2\"\n+Content-Length: 0\n+```\n+\n+=== Negotiation\n+\n+One of the main ideas of REST (https://tools.ietf.org/html/rfc7231#section-3.4[and HTTP]) is that\n+your resource is independent from its representation, and\n+that both the client and server are free to represent their resources in as many media types as\n+they want. This allows the server to declare support for multiple representations and let the\n+client declare which ones it supports and get served something appropriate.\n+\n+The following endpoint supports serving cheese in plain text or JSON:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.PUT;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+class FroMage {\n+    public String name;\n+    // required for Jackson\n+    public FroMage() {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cde4943aec547bfcd64b41b939f2b5d2c3a0b77"}, "originalPosition": 1452}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI3NTA1Mw==", "bodyText": "I would drop Naturally as the doc aims developers you may not have prior JAX-RS knowledge", "url": "https://github.com/quarkusio/quarkus/pull/13802#discussion_r540275053", "createdAt": "2020-12-10T15:44:43Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/rest-reactive.adoc", "diffHunk": "@@ -0,0 +1,1553 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Writing REST Services with RESTEasy Reactive\n+\n+include::./attributes.adoc[]\n+:jaxrsapi: https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1\n+:jaxrsspec: /specs/jaxrs/2.1/index.html\n+:jdkapi: https://docs.oracle.com/en/java/javase/11/docs/api/java.base\n+:mutinyapi: https://smallrye.io/smallrye-mutiny/apidocs\n+:httpspec: https://tools.ietf.org/html/rfc7231\n+:jsonpapi: https://javadoc.io/doc/javax.json/javax.json-api/1.1.4\n+:vertxapi: https://javadoc.io/static/io.vertx/vertx-core/3.9.4\n+\n+This guide explains how to write REST Services with RESTEasy Reactive\n+\n+TODO: buff this\n+\n+TODO: links to our javadoc\n+\n+== What is RESTEasy Reactive?\n+\n+RESTEasy Reactive is a new link:{jaxrsspec}[JAX-RS]\n+implementation written from the ground up to work on our\n+common https://vertx.io/[Vert.x] layer and is thus fully reactive, while also being very tightly integrated with\n+Quarkus and consequently moving a lot of work to build time.\n+\n+You should be able to use it in place of any JAX-RS implementation, but on top of that it has\n+great performance for both blocking and non-blocking endpoints, and a lot of new features on top\n+of what JAX-RS provides.\n+\n+== Writing endpoints\n+\n+=== Getting started\n+\n+Add the following import to your `pom.xml` file:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-resteasy-reactive</artifactId>\n+</dependency>\n+----\n+\n+You can now write your first endpoint in the `org.acme.rest.Endpoint` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+=== Terminology\n+\n+REST:: https://en.wikipedia.org/wiki/Representational_state_transfer[REpresentational State Transfer]\n+Endpoint:: Java method which is called to serve a REST call\n+URL / URI (Uniform Resource Locator / Identifier):: Used to identify the location of REST resources (https://tools.ietf.org/html/rfc7230#section-2.7[specification])\n+Resource:: Represents your domain object. This is what your API serves and modifies. Also called an `entity` in JAX-RS.\n+Representation:: How your resource is represented on the wire, can vary depending on content types\n+Content type:: Designates a particular representation (also called a media type), for example `text/plain` or `application/json`\n+HTTP:: Underlying wire protocol for routing REST calls (see https://tools.ietf.org/html/rfc7230[HTTP specifications])\n+HTTP request:: the request part of the HTTP call, consisting of an HTTP method, a target URI, headers and an optional message body\n+HTTP response:: the response part of the HTTP call, consisting of an HTTP response status, headers and an optional message body\n+\n+=== Declaring endpoints: URI mapping\n+\n+Any class annotated with a link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation can have its methods exposed as REST endpoints,\n+provided they have an HTTP method annotation (see below).\n+\n+That link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation defines the URI prefix under which those methods will be exposed. It can\n+be empty, or contain a prefix such as `rest` or `rest/V1`.\n+\n+Each exposed endpoint method can in turn have another link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation which adds to its containing\n+class annotation. For example, this defines a `rest/hello` endpoint:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"rest\")\n+public class Endpoint {\n+\n+    @Path(\"hello\")\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+See <<uri-parameters,URI parameters>> for more information about URI mapping.\n+\n+=== Declaring endpoints: HTTP methods\n+\n+Each endpoint method must be annotated with one of the following annotations, which defines which HTTP\n+method will be mapped to the method:\n+\n+.Table HTTP method annotations\n+|===\n+|Annotation|Usage \n+\n+|link:{jaxrsapi}/javax/ws/rs/GET.html[`@GET`]\n+|Obtain a resource representation, should not modify state, idempotent (link:{httpspec}#section-4.3.1[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/HEAD.html[`@HEAD`]\n+|Obtain metadata about a resource, similar to `GET` with no body (link:{httpspec}#section-4.3.2[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/POST.html[`@POST`]\n+|Create a resource and obtain a link to it (link:{httpspec}#section-4.3.3[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PUT.html[`@PUT`]\n+|Replace a resource or create one, should be idempotent (link:{httpspec}#section-4.3.4[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/DELETE.html[`@DELETE`]\n+|Delete an existing resource, idempotent  (link:{httpspec}#section-4.3.5[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/OPTIONS.html[`@OPTIONS`]\n+|Obtain information about a resource, idempotent (link:{httpspec}#section-4.3.7[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PATCH.html[`@PATCH`]\n+|Update a resource, or create one, not idempotent (https://tools.ietf.org/html/rfc5789#section-2[HTTP docs])\n+\n+|===\n+\n+You can also declare other HTTP methods by declaring them as an annotation with the\n+link:{jaxrsapi}/javax/ws/rs/HttpMethod.html[`@HttpMethod`] annotation:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+import javax.ws.rs.HttpMethod;\n+import javax.ws.rs.Path;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@HttpMethod(\"FROMAGE\")\n+@interface FROMAGE {\n+}\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @FROMAGE\n+    public String hello(){\n+        return \"Hello, Cheese World!\";\n+    }\n+}\n+----\n+\n+=== Declaring endpoints: representation / content types\n+\n+Each endpoint method may consume or produce specific resource representations, which are indicated by\n+the HTTP link:{httpspec}#section-3.1.1.5[`Content-Type`] header, which in turn contains \n+link:{httpspec}#section-3.1.1.1[MIME (Media Type)] values, such as the following:\n+\n+- `text/plain` which is the default for any endpoint returning a `String`.\n+- `text/html` for HTML (such as with link:qute[Qute templating])\n+- `application/json` for a <<json,JSON REST endpoint>>\n+- `text/*` which is a sub-type wildcard for any text media type\n+- `*/*` which is a wildcard for any media type\n+\n+You may annotate your endpoint class with the link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces`] \n+or link:{jaxrsapi}/javax/ws/rs/Consumes.html[`@Consumes`] annotations, which\n+allow you to specify one or more media types that your endpoint may accept as HTTP request body\n+or produce as HTTP response body. Those class annotations apply to each method.\n+\n+Any method may also be annotated with the link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces`] \n+or link:{jaxrsapi}/javax/ws/rs/Consumes.html[`@Consumes`] annotations, in which\n+case they override any eventual class annotation.\n+\n+The link:{jaxrsapi}/javax/ws/rs/core/MediaType.html[`MediaType`] class has many constants you\n+can use to point to specific pre-defined media types.\n+\n+See <<negotiation>> for more information.\n+\n+=== Accessing request parameters\n+\n+[[request-parameters]]\n+\n+NOTE: don't forget to configure your compiler to generate parameter name information with `-parameters` (javac)\n+or `<parameters>` or `<maven.compiler.parameters>` (https://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#parameters[Maven]).\n+\n+The following HTTP request elements may be obtained by your endpoint method:\n+\n+.Table HTTP request parameter annotations\n+|===\n+|HTTP element|Annotation|Usage \n+\n+|[[path-parameter]]Path parameter\n+|`@RestPath` (or nothing)\n+|URI template parameter (simplified version of the https://tools.ietf.org/html/rfc6570[URI Template specification]), \n+see <<uri-parameters,URI parameters>> for more information.\n+\n+|Query parameter\n+|`@RestQuery`\n+|The value of an https://tools.ietf.org/html/rfc3986#section-3.4[URI query parameter]\n+\n+|Header\n+|`@RestHeader`\n+|The value of an https://tools.ietf.org/html/rfc7230#section-3.2[HTTP header]\n+\n+|Cookie\n+|`@RestCookie`\n+|The value of an https://tools.ietf.org/html/rfc6265#section-4.2[HTTP cookie]\n+\n+|Form parameter\n+|`@RestForm`\n+|The value of an https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST[HTTP URL-encoded FORM]\n+\n+|Matrix parameter\n+|`@RestMatrix`\n+|The value of an https://tools.ietf.org/html/rfc3986#section-3.3[URI path segment parameter]\n+\n+|===\n+\n+For each of those annotations, you may specify the name of the element they refer to, otherwise\n+they will use the name of the annotated method parameter.\n+\n+If a client made the following HTTP call:\n+\n+[source,http]\n+----\n+POST /cheeses;variant=goat/tomme?age=matured HTTP/1.1\n+Content-Type: application/x-www-form-urlencoded\n+Cookie: level=hardcore\n+X-Cheese-Secret-Handshake: fist-bump\n+\n+smell=strong\n+----\n+\n+Then you could obtain all the various parameters with this endpoint method:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+\n+import org.jboss.resteasy.reactive.RestCookie;\n+import org.jboss.resteasy.reactive.RestForm;\n+import org.jboss.resteasy.reactive.RestHeader;\n+import org.jboss.resteasy.reactive.RestMatrix;\n+import org.jboss.resteasy.reactive.RestPath;\n+import org.jboss.resteasy.reactive.RestQuery;\n+\n+@Path(\"/cheeses/{type}\")\n+public class Endpoint {\n+\n+    @POST\n+    public String allParams(@RestPath String type,\n+                            @RestMatrix String variant,\n+                            @RestQuery String age,\n+                            @RestCookie String level,\n+                            @RestHeader(\"X-Cheese-Secret-Handshake\")\n+                            String secretHandshake,\n+                            @RestForm String smell){\n+        return type + \"/\" + variant + \"/\" + age + \"/\" + level + \"/\" + secretHandshake + \"/\" + smell;\n+    }\n+}\n+----\n+\n+NOTE: the `@RestPath` annotation is optional: any parameter whose name matches an existing URI\n+template variable will be automatically assumed to have `@RestPath`.\n+\n+Naturally you can also use any of the JAX-RS annotations link:{jaxrsapi}/javax/ws/rs/PathParam.html[`@PathParam`],", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cde4943aec547bfcd64b41b939f2b5d2c3a0b77"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI3ODk2OQ==", "bodyText": "Can we replace IO thread with event-loop thread? The former term is very overloaded IMHO", "url": "https://github.com/quarkusio/quarkus/pull/13802#discussion_r540278969", "createdAt": "2020-12-10T15:49:31Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/rest-reactive.adoc", "diffHunk": "@@ -0,0 +1,1553 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Writing REST Services with RESTEasy Reactive\n+\n+include::./attributes.adoc[]\n+:jaxrsapi: https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1\n+:jaxrsspec: /specs/jaxrs/2.1/index.html\n+:jdkapi: https://docs.oracle.com/en/java/javase/11/docs/api/java.base\n+:mutinyapi: https://smallrye.io/smallrye-mutiny/apidocs\n+:httpspec: https://tools.ietf.org/html/rfc7231\n+:jsonpapi: https://javadoc.io/doc/javax.json/javax.json-api/1.1.4\n+:vertxapi: https://javadoc.io/static/io.vertx/vertx-core/3.9.4\n+\n+This guide explains how to write REST Services with RESTEasy Reactive\n+\n+TODO: buff this\n+\n+TODO: links to our javadoc\n+\n+== What is RESTEasy Reactive?\n+\n+RESTEasy Reactive is a new link:{jaxrsspec}[JAX-RS]\n+implementation written from the ground up to work on our\n+common https://vertx.io/[Vert.x] layer and is thus fully reactive, while also being very tightly integrated with\n+Quarkus and consequently moving a lot of work to build time.\n+\n+You should be able to use it in place of any JAX-RS implementation, but on top of that it has\n+great performance for both blocking and non-blocking endpoints, and a lot of new features on top\n+of what JAX-RS provides.\n+\n+== Writing endpoints\n+\n+=== Getting started\n+\n+Add the following import to your `pom.xml` file:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-resteasy-reactive</artifactId>\n+</dependency>\n+----\n+\n+You can now write your first endpoint in the `org.acme.rest.Endpoint` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+=== Terminology\n+\n+REST:: https://en.wikipedia.org/wiki/Representational_state_transfer[REpresentational State Transfer]\n+Endpoint:: Java method which is called to serve a REST call\n+URL / URI (Uniform Resource Locator / Identifier):: Used to identify the location of REST resources (https://tools.ietf.org/html/rfc7230#section-2.7[specification])\n+Resource:: Represents your domain object. This is what your API serves and modifies. Also called an `entity` in JAX-RS.\n+Representation:: How your resource is represented on the wire, can vary depending on content types\n+Content type:: Designates a particular representation (also called a media type), for example `text/plain` or `application/json`\n+HTTP:: Underlying wire protocol for routing REST calls (see https://tools.ietf.org/html/rfc7230[HTTP specifications])\n+HTTP request:: the request part of the HTTP call, consisting of an HTTP method, a target URI, headers and an optional message body\n+HTTP response:: the response part of the HTTP call, consisting of an HTTP response status, headers and an optional message body\n+\n+=== Declaring endpoints: URI mapping\n+\n+Any class annotated with a link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation can have its methods exposed as REST endpoints,\n+provided they have an HTTP method annotation (see below).\n+\n+That link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation defines the URI prefix under which those methods will be exposed. It can\n+be empty, or contain a prefix such as `rest` or `rest/V1`.\n+\n+Each exposed endpoint method can in turn have another link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation which adds to its containing\n+class annotation. For example, this defines a `rest/hello` endpoint:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"rest\")\n+public class Endpoint {\n+\n+    @Path(\"hello\")\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+See <<uri-parameters,URI parameters>> for more information about URI mapping.\n+\n+=== Declaring endpoints: HTTP methods\n+\n+Each endpoint method must be annotated with one of the following annotations, which defines which HTTP\n+method will be mapped to the method:\n+\n+.Table HTTP method annotations\n+|===\n+|Annotation|Usage \n+\n+|link:{jaxrsapi}/javax/ws/rs/GET.html[`@GET`]\n+|Obtain a resource representation, should not modify state, idempotent (link:{httpspec}#section-4.3.1[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/HEAD.html[`@HEAD`]\n+|Obtain metadata about a resource, similar to `GET` with no body (link:{httpspec}#section-4.3.2[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/POST.html[`@POST`]\n+|Create a resource and obtain a link to it (link:{httpspec}#section-4.3.3[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PUT.html[`@PUT`]\n+|Replace a resource or create one, should be idempotent (link:{httpspec}#section-4.3.4[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/DELETE.html[`@DELETE`]\n+|Delete an existing resource, idempotent  (link:{httpspec}#section-4.3.5[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/OPTIONS.html[`@OPTIONS`]\n+|Obtain information about a resource, idempotent (link:{httpspec}#section-4.3.7[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PATCH.html[`@PATCH`]\n+|Update a resource, or create one, not idempotent (https://tools.ietf.org/html/rfc5789#section-2[HTTP docs])\n+\n+|===\n+\n+You can also declare other HTTP methods by declaring them as an annotation with the\n+link:{jaxrsapi}/javax/ws/rs/HttpMethod.html[`@HttpMethod`] annotation:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+import javax.ws.rs.HttpMethod;\n+import javax.ws.rs.Path;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@HttpMethod(\"FROMAGE\")\n+@interface FROMAGE {\n+}\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @FROMAGE\n+    public String hello(){\n+        return \"Hello, Cheese World!\";\n+    }\n+}\n+----\n+\n+=== Declaring endpoints: representation / content types\n+\n+Each endpoint method may consume or produce specific resource representations, which are indicated by\n+the HTTP link:{httpspec}#section-3.1.1.5[`Content-Type`] header, which in turn contains \n+link:{httpspec}#section-3.1.1.1[MIME (Media Type)] values, such as the following:\n+\n+- `text/plain` which is the default for any endpoint returning a `String`.\n+- `text/html` for HTML (such as with link:qute[Qute templating])\n+- `application/json` for a <<json,JSON REST endpoint>>\n+- `text/*` which is a sub-type wildcard for any text media type\n+- `*/*` which is a wildcard for any media type\n+\n+You may annotate your endpoint class with the link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces`] \n+or link:{jaxrsapi}/javax/ws/rs/Consumes.html[`@Consumes`] annotations, which\n+allow you to specify one or more media types that your endpoint may accept as HTTP request body\n+or produce as HTTP response body. Those class annotations apply to each method.\n+\n+Any method may also be annotated with the link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces`] \n+or link:{jaxrsapi}/javax/ws/rs/Consumes.html[`@Consumes`] annotations, in which\n+case they override any eventual class annotation.\n+\n+The link:{jaxrsapi}/javax/ws/rs/core/MediaType.html[`MediaType`] class has many constants you\n+can use to point to specific pre-defined media types.\n+\n+See <<negotiation>> for more information.\n+\n+=== Accessing request parameters\n+\n+[[request-parameters]]\n+\n+NOTE: don't forget to configure your compiler to generate parameter name information with `-parameters` (javac)\n+or `<parameters>` or `<maven.compiler.parameters>` (https://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#parameters[Maven]).\n+\n+The following HTTP request elements may be obtained by your endpoint method:\n+\n+.Table HTTP request parameter annotations\n+|===\n+|HTTP element|Annotation|Usage \n+\n+|[[path-parameter]]Path parameter\n+|`@RestPath` (or nothing)\n+|URI template parameter (simplified version of the https://tools.ietf.org/html/rfc6570[URI Template specification]), \n+see <<uri-parameters,URI parameters>> for more information.\n+\n+|Query parameter\n+|`@RestQuery`\n+|The value of an https://tools.ietf.org/html/rfc3986#section-3.4[URI query parameter]\n+\n+|Header\n+|`@RestHeader`\n+|The value of an https://tools.ietf.org/html/rfc7230#section-3.2[HTTP header]\n+\n+|Cookie\n+|`@RestCookie`\n+|The value of an https://tools.ietf.org/html/rfc6265#section-4.2[HTTP cookie]\n+\n+|Form parameter\n+|`@RestForm`\n+|The value of an https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST[HTTP URL-encoded FORM]\n+\n+|Matrix parameter\n+|`@RestMatrix`\n+|The value of an https://tools.ietf.org/html/rfc3986#section-3.3[URI path segment parameter]\n+\n+|===\n+\n+For each of those annotations, you may specify the name of the element they refer to, otherwise\n+they will use the name of the annotated method parameter.\n+\n+If a client made the following HTTP call:\n+\n+[source,http]\n+----\n+POST /cheeses;variant=goat/tomme?age=matured HTTP/1.1\n+Content-Type: application/x-www-form-urlencoded\n+Cookie: level=hardcore\n+X-Cheese-Secret-Handshake: fist-bump\n+\n+smell=strong\n+----\n+\n+Then you could obtain all the various parameters with this endpoint method:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+\n+import org.jboss.resteasy.reactive.RestCookie;\n+import org.jboss.resteasy.reactive.RestForm;\n+import org.jboss.resteasy.reactive.RestHeader;\n+import org.jboss.resteasy.reactive.RestMatrix;\n+import org.jboss.resteasy.reactive.RestPath;\n+import org.jboss.resteasy.reactive.RestQuery;\n+\n+@Path(\"/cheeses/{type}\")\n+public class Endpoint {\n+\n+    @POST\n+    public String allParams(@RestPath String type,\n+                            @RestMatrix String variant,\n+                            @RestQuery String age,\n+                            @RestCookie String level,\n+                            @RestHeader(\"X-Cheese-Secret-Handshake\")\n+                            String secretHandshake,\n+                            @RestForm String smell){\n+        return type + \"/\" + variant + \"/\" + age + \"/\" + level + \"/\" + secretHandshake + \"/\" + smell;\n+    }\n+}\n+----\n+\n+NOTE: the `@RestPath` annotation is optional: any parameter whose name matches an existing URI\n+template variable will be automatically assumed to have `@RestPath`.\n+\n+Naturally you can also use any of the JAX-RS annotations link:{jaxrsapi}/javax/ws/rs/PathParam.html[`@PathParam`],\n+link:{jaxrsapi}/javax/ws/rs/QueryParam.html[`@QueryParam`],\n+link:{jaxrsapi}/javax/ws/rs/HeaderParam.html[`@HeaderParam`],\n+link:{jaxrsapi}/javax/ws/rs/CookieParam.html[`@CookieParam`],\n+link:{jaxrsapi}/javax/ws/rs/FormParam.html[`@FormParam`] or\n+link:{jaxrsapi}/javax/ws/rs/MatrixParam.html[`@MatrixParam`] for this,\n+but they require you to specify the parameter name.\n+\n+See <<parameter-mapping>> for more advanced use-cases.\n+\n+=== Declaring URI parameters\n+\n+[[uri-parameters]]\n+\n+You can declare URI parameters and use regular expressions in your path, so for instance\n+the following endpoint will serve requests for `/hello/stef/23` and `/hello` but not\n+`/hello/stef/0x23`:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"hello\")\n+public class Endpoint {\n+\n+    @Path(\"{name}/{age:\\\\d+}\")\n+    @GET\n+    public String personalisedHello(String name, int age){\n+        return \"Hello \" + name + \" is your age really \" + age + \"?\";\n+    }\n+\n+    @GET\n+    public String genericHello(){\n+        return \"Hello stranger\";\n+    }\n+}\n+----\n+\n+\n+=== Accessing the request body\n+\n+Any method parameter with no annotation will receive the method body.footnote:[Unless it is a\n+<<path-parameter,URI template parameter>> or a <<context-objects,context object>>.], after it has been mapped from\n+its HTTP representation to the Java type of the parameter.\n+\n+The following parameter types will be supported out of the box:\n+\n+[[resource-types]]\n+\n+.Table Request body parameter type\n+|===\n+|Type|Usage\n+\n+|link:{jdkapi}/java/io/File.html[`File`]\n+|The entire request body in a temporary file\n+\n+|`byte[]`\n+|The entire request body, not decoded\n+\n+|`char[]`\n+|The entire request body, decoded\n+\n+|link:{jdkapi}/java/lang/String.html[`String`]\n+|The entire request body, decoded\n+\n+|link:{jdkapi}/java/io/InputStream.html[`InputStream`]\n+|The request body in a blocking stream\n+\n+|link:{jdkapi}/java/io/Reader.html[`Reader`]\n+|The request body in a blocking stream\n+\n+|All Java primitives and their wrapper classes\n+|Java primitive types\n+\n+|link:{jdkapi}/java/math/BigDecimal.html[`BigDecimal`], link:{jdkapi}/java/math/BigInteger.html[`BigInteger`]\n+|Large integers and decimals.\n+\n+|link:{jsonpapi}/javax/json/JsonArray.html[`JsonArray`], link:{jsonpapi}/javax/json/JsonArray.html[`JsonObject`],\n+link:{jsonpapi}/javax/json/JsonArray.html[`JsonStructure`], link:{jsonpapi}/javax/json/JsonArray.html[`JsonValue`]\n+|JSON value types  \n+\n+|link:{vertxapi}io/vertx/core/buffer/Buffer.html[`Buffer`]\n+|Vert.x Buffer \n+\n+|any other type\n+|Will be <<json,mapped from JSON to that type>>\n+\n+|===\n+\n+NOTE: You can add support for more <<readers-writers,body parameter types>>.\n+\n+=== Returning a response body\n+\n+In order to return an HTTP response, simply return the resource you want from your method. The method\n+return type and its optional content type will be used to decide how to serialise it to the HTTP\n+response (see <<negotiation>> for more advanced information).\n+\n+You can return any of the pre-defined types that you can read from the <<resource-types,HTTP response>>,\n+and any other type will be mapped <<json,from that type to JSON>>.\n+\n+Alternately, you can also return a <<reactive,reactive type>> such as link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`], \n+link:{mutinyapi}/io/smallrye/mutiny/Multi.html[`Multi`] or \n+link:{jdkapi}/java/util/concurrent/CompletionStage.html[`CompletionStage`]\n+that resolve to one of the mentioned return types.\n+\n+=== Setting other response properties\n+\n+If you need to set more properties on the HTTP response than just the body, such as the status code\n+or headers, you can make your method return the link:{jaxrsapi}/javax/ws/rs/core/Response.html[`Response`]\n+type:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.NewCookie;\n+import javax.ws.rs.core.Response;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public Response hello() {\n+        // HTTP OK status with text/plain content type\n+        return Response.ok(\"Hello, World!\", MediaType.TEXT_PLAIN_TYPE)\n+         // set a response header\n+         .header(\"X-FroMage\", \"Camembert\")\n+         // set the Expires response header to two days from now\n+         .expires(Date.from(Instant.now().plus(Duration.ofDays(2))))\n+         // send a new cookie\n+         .cookie(new NewCookie(\"Flavour\", \"pralin\u00e9\"))\n+         // end of builder API\n+         .build();\n+    }\n+}\n+----\n+\n+=== Async/reactive support\n+\n+[[reactive]]\n+\n+If your endpoint method needs to accomplish an asynchronous or reactive task before\n+being able to answer, you can declare your method to return the \n+link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`] type (from https://smallrye.io/smallrye-mutiny/[Mutiny]), in which\n+case the current HTTP request will be automatically suspended after your method, until\n+the returned link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`] instance resolves to a value,\n+which will be mapped to a response exactly according to the previously described rules:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"escoffier\")\n+public class Endpoint {\n+\n+    @GET\n+    public Uni<Book> culinaryGuide(){\n+        return Book.findByIsbn(\"978-2081229297\");\n+    }\n+}\n+----\n+\n+This allows you to not block the IO thread while the book is being fetched from the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cde4943aec547bfcd64b41b939f2b5d2c3a0b77"}, "originalPosition": 463}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI4NDUyMQ==", "bodyText": "The class should probably be public", "url": "https://github.com/quarkusio/quarkus/pull/13802#discussion_r540284521", "createdAt": "2020-12-10T15:56:20Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/rest-reactive.adoc", "diffHunk": "@@ -0,0 +1,1553 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Writing REST Services with RESTEasy Reactive\n+\n+include::./attributes.adoc[]\n+:jaxrsapi: https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1\n+:jaxrsspec: /specs/jaxrs/2.1/index.html\n+:jdkapi: https://docs.oracle.com/en/java/javase/11/docs/api/java.base\n+:mutinyapi: https://smallrye.io/smallrye-mutiny/apidocs\n+:httpspec: https://tools.ietf.org/html/rfc7231\n+:jsonpapi: https://javadoc.io/doc/javax.json/javax.json-api/1.1.4\n+:vertxapi: https://javadoc.io/static/io.vertx/vertx-core/3.9.4\n+\n+This guide explains how to write REST Services with RESTEasy Reactive\n+\n+TODO: buff this\n+\n+TODO: links to our javadoc\n+\n+== What is RESTEasy Reactive?\n+\n+RESTEasy Reactive is a new link:{jaxrsspec}[JAX-RS]\n+implementation written from the ground up to work on our\n+common https://vertx.io/[Vert.x] layer and is thus fully reactive, while also being very tightly integrated with\n+Quarkus and consequently moving a lot of work to build time.\n+\n+You should be able to use it in place of any JAX-RS implementation, but on top of that it has\n+great performance for both blocking and non-blocking endpoints, and a lot of new features on top\n+of what JAX-RS provides.\n+\n+== Writing endpoints\n+\n+=== Getting started\n+\n+Add the following import to your `pom.xml` file:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-resteasy-reactive</artifactId>\n+</dependency>\n+----\n+\n+You can now write your first endpoint in the `org.acme.rest.Endpoint` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+=== Terminology\n+\n+REST:: https://en.wikipedia.org/wiki/Representational_state_transfer[REpresentational State Transfer]\n+Endpoint:: Java method which is called to serve a REST call\n+URL / URI (Uniform Resource Locator / Identifier):: Used to identify the location of REST resources (https://tools.ietf.org/html/rfc7230#section-2.7[specification])\n+Resource:: Represents your domain object. This is what your API serves and modifies. Also called an `entity` in JAX-RS.\n+Representation:: How your resource is represented on the wire, can vary depending on content types\n+Content type:: Designates a particular representation (also called a media type), for example `text/plain` or `application/json`\n+HTTP:: Underlying wire protocol for routing REST calls (see https://tools.ietf.org/html/rfc7230[HTTP specifications])\n+HTTP request:: the request part of the HTTP call, consisting of an HTTP method, a target URI, headers and an optional message body\n+HTTP response:: the response part of the HTTP call, consisting of an HTTP response status, headers and an optional message body\n+\n+=== Declaring endpoints: URI mapping\n+\n+Any class annotated with a link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation can have its methods exposed as REST endpoints,\n+provided they have an HTTP method annotation (see below).\n+\n+That link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation defines the URI prefix under which those methods will be exposed. It can\n+be empty, or contain a prefix such as `rest` or `rest/V1`.\n+\n+Each exposed endpoint method can in turn have another link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation which adds to its containing\n+class annotation. For example, this defines a `rest/hello` endpoint:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"rest\")\n+public class Endpoint {\n+\n+    @Path(\"hello\")\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+See <<uri-parameters,URI parameters>> for more information about URI mapping.\n+\n+=== Declaring endpoints: HTTP methods\n+\n+Each endpoint method must be annotated with one of the following annotations, which defines which HTTP\n+method will be mapped to the method:\n+\n+.Table HTTP method annotations\n+|===\n+|Annotation|Usage \n+\n+|link:{jaxrsapi}/javax/ws/rs/GET.html[`@GET`]\n+|Obtain a resource representation, should not modify state, idempotent (link:{httpspec}#section-4.3.1[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/HEAD.html[`@HEAD`]\n+|Obtain metadata about a resource, similar to `GET` with no body (link:{httpspec}#section-4.3.2[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/POST.html[`@POST`]\n+|Create a resource and obtain a link to it (link:{httpspec}#section-4.3.3[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PUT.html[`@PUT`]\n+|Replace a resource or create one, should be idempotent (link:{httpspec}#section-4.3.4[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/DELETE.html[`@DELETE`]\n+|Delete an existing resource, idempotent  (link:{httpspec}#section-4.3.5[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/OPTIONS.html[`@OPTIONS`]\n+|Obtain information about a resource, idempotent (link:{httpspec}#section-4.3.7[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PATCH.html[`@PATCH`]\n+|Update a resource, or create one, not idempotent (https://tools.ietf.org/html/rfc5789#section-2[HTTP docs])\n+\n+|===\n+\n+You can also declare other HTTP methods by declaring them as an annotation with the\n+link:{jaxrsapi}/javax/ws/rs/HttpMethod.html[`@HttpMethod`] annotation:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+import javax.ws.rs.HttpMethod;\n+import javax.ws.rs.Path;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@HttpMethod(\"FROMAGE\")\n+@interface FROMAGE {\n+}\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @FROMAGE\n+    public String hello(){\n+        return \"Hello, Cheese World!\";\n+    }\n+}\n+----\n+\n+=== Declaring endpoints: representation / content types\n+\n+Each endpoint method may consume or produce specific resource representations, which are indicated by\n+the HTTP link:{httpspec}#section-3.1.1.5[`Content-Type`] header, which in turn contains \n+link:{httpspec}#section-3.1.1.1[MIME (Media Type)] values, such as the following:\n+\n+- `text/plain` which is the default for any endpoint returning a `String`.\n+- `text/html` for HTML (such as with link:qute[Qute templating])\n+- `application/json` for a <<json,JSON REST endpoint>>\n+- `text/*` which is a sub-type wildcard for any text media type\n+- `*/*` which is a wildcard for any media type\n+\n+You may annotate your endpoint class with the link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces`] \n+or link:{jaxrsapi}/javax/ws/rs/Consumes.html[`@Consumes`] annotations, which\n+allow you to specify one or more media types that your endpoint may accept as HTTP request body\n+or produce as HTTP response body. Those class annotations apply to each method.\n+\n+Any method may also be annotated with the link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces`] \n+or link:{jaxrsapi}/javax/ws/rs/Consumes.html[`@Consumes`] annotations, in which\n+case they override any eventual class annotation.\n+\n+The link:{jaxrsapi}/javax/ws/rs/core/MediaType.html[`MediaType`] class has many constants you\n+can use to point to specific pre-defined media types.\n+\n+See <<negotiation>> for more information.\n+\n+=== Accessing request parameters\n+\n+[[request-parameters]]\n+\n+NOTE: don't forget to configure your compiler to generate parameter name information with `-parameters` (javac)\n+or `<parameters>` or `<maven.compiler.parameters>` (https://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#parameters[Maven]).\n+\n+The following HTTP request elements may be obtained by your endpoint method:\n+\n+.Table HTTP request parameter annotations\n+|===\n+|HTTP element|Annotation|Usage \n+\n+|[[path-parameter]]Path parameter\n+|`@RestPath` (or nothing)\n+|URI template parameter (simplified version of the https://tools.ietf.org/html/rfc6570[URI Template specification]), \n+see <<uri-parameters,URI parameters>> for more information.\n+\n+|Query parameter\n+|`@RestQuery`\n+|The value of an https://tools.ietf.org/html/rfc3986#section-3.4[URI query parameter]\n+\n+|Header\n+|`@RestHeader`\n+|The value of an https://tools.ietf.org/html/rfc7230#section-3.2[HTTP header]\n+\n+|Cookie\n+|`@RestCookie`\n+|The value of an https://tools.ietf.org/html/rfc6265#section-4.2[HTTP cookie]\n+\n+|Form parameter\n+|`@RestForm`\n+|The value of an https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST[HTTP URL-encoded FORM]\n+\n+|Matrix parameter\n+|`@RestMatrix`\n+|The value of an https://tools.ietf.org/html/rfc3986#section-3.3[URI path segment parameter]\n+\n+|===\n+\n+For each of those annotations, you may specify the name of the element they refer to, otherwise\n+they will use the name of the annotated method parameter.\n+\n+If a client made the following HTTP call:\n+\n+[source,http]\n+----\n+POST /cheeses;variant=goat/tomme?age=matured HTTP/1.1\n+Content-Type: application/x-www-form-urlencoded\n+Cookie: level=hardcore\n+X-Cheese-Secret-Handshake: fist-bump\n+\n+smell=strong\n+----\n+\n+Then you could obtain all the various parameters with this endpoint method:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+\n+import org.jboss.resteasy.reactive.RestCookie;\n+import org.jboss.resteasy.reactive.RestForm;\n+import org.jboss.resteasy.reactive.RestHeader;\n+import org.jboss.resteasy.reactive.RestMatrix;\n+import org.jboss.resteasy.reactive.RestPath;\n+import org.jboss.resteasy.reactive.RestQuery;\n+\n+@Path(\"/cheeses/{type}\")\n+public class Endpoint {\n+\n+    @POST\n+    public String allParams(@RestPath String type,\n+                            @RestMatrix String variant,\n+                            @RestQuery String age,\n+                            @RestCookie String level,\n+                            @RestHeader(\"X-Cheese-Secret-Handshake\")\n+                            String secretHandshake,\n+                            @RestForm String smell){\n+        return type + \"/\" + variant + \"/\" + age + \"/\" + level + \"/\" + secretHandshake + \"/\" + smell;\n+    }\n+}\n+----\n+\n+NOTE: the `@RestPath` annotation is optional: any parameter whose name matches an existing URI\n+template variable will be automatically assumed to have `@RestPath`.\n+\n+Naturally you can also use any of the JAX-RS annotations link:{jaxrsapi}/javax/ws/rs/PathParam.html[`@PathParam`],\n+link:{jaxrsapi}/javax/ws/rs/QueryParam.html[`@QueryParam`],\n+link:{jaxrsapi}/javax/ws/rs/HeaderParam.html[`@HeaderParam`],\n+link:{jaxrsapi}/javax/ws/rs/CookieParam.html[`@CookieParam`],\n+link:{jaxrsapi}/javax/ws/rs/FormParam.html[`@FormParam`] or\n+link:{jaxrsapi}/javax/ws/rs/MatrixParam.html[`@MatrixParam`] for this,\n+but they require you to specify the parameter name.\n+\n+See <<parameter-mapping>> for more advanced use-cases.\n+\n+=== Declaring URI parameters\n+\n+[[uri-parameters]]\n+\n+You can declare URI parameters and use regular expressions in your path, so for instance\n+the following endpoint will serve requests for `/hello/stef/23` and `/hello` but not\n+`/hello/stef/0x23`:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"hello\")\n+public class Endpoint {\n+\n+    @Path(\"{name}/{age:\\\\d+}\")\n+    @GET\n+    public String personalisedHello(String name, int age){\n+        return \"Hello \" + name + \" is your age really \" + age + \"?\";\n+    }\n+\n+    @GET\n+    public String genericHello(){\n+        return \"Hello stranger\";\n+    }\n+}\n+----\n+\n+\n+=== Accessing the request body\n+\n+Any method parameter with no annotation will receive the method body.footnote:[Unless it is a\n+<<path-parameter,URI template parameter>> or a <<context-objects,context object>>.], after it has been mapped from\n+its HTTP representation to the Java type of the parameter.\n+\n+The following parameter types will be supported out of the box:\n+\n+[[resource-types]]\n+\n+.Table Request body parameter type\n+|===\n+|Type|Usage\n+\n+|link:{jdkapi}/java/io/File.html[`File`]\n+|The entire request body in a temporary file\n+\n+|`byte[]`\n+|The entire request body, not decoded\n+\n+|`char[]`\n+|The entire request body, decoded\n+\n+|link:{jdkapi}/java/lang/String.html[`String`]\n+|The entire request body, decoded\n+\n+|link:{jdkapi}/java/io/InputStream.html[`InputStream`]\n+|The request body in a blocking stream\n+\n+|link:{jdkapi}/java/io/Reader.html[`Reader`]\n+|The request body in a blocking stream\n+\n+|All Java primitives and their wrapper classes\n+|Java primitive types\n+\n+|link:{jdkapi}/java/math/BigDecimal.html[`BigDecimal`], link:{jdkapi}/java/math/BigInteger.html[`BigInteger`]\n+|Large integers and decimals.\n+\n+|link:{jsonpapi}/javax/json/JsonArray.html[`JsonArray`], link:{jsonpapi}/javax/json/JsonArray.html[`JsonObject`],\n+link:{jsonpapi}/javax/json/JsonArray.html[`JsonStructure`], link:{jsonpapi}/javax/json/JsonArray.html[`JsonValue`]\n+|JSON value types  \n+\n+|link:{vertxapi}io/vertx/core/buffer/Buffer.html[`Buffer`]\n+|Vert.x Buffer \n+\n+|any other type\n+|Will be <<json,mapped from JSON to that type>>\n+\n+|===\n+\n+NOTE: You can add support for more <<readers-writers,body parameter types>>.\n+\n+=== Returning a response body\n+\n+In order to return an HTTP response, simply return the resource you want from your method. The method\n+return type and its optional content type will be used to decide how to serialise it to the HTTP\n+response (see <<negotiation>> for more advanced information).\n+\n+You can return any of the pre-defined types that you can read from the <<resource-types,HTTP response>>,\n+and any other type will be mapped <<json,from that type to JSON>>.\n+\n+Alternately, you can also return a <<reactive,reactive type>> such as link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`], \n+link:{mutinyapi}/io/smallrye/mutiny/Multi.html[`Multi`] or \n+link:{jdkapi}/java/util/concurrent/CompletionStage.html[`CompletionStage`]\n+that resolve to one of the mentioned return types.\n+\n+=== Setting other response properties\n+\n+If you need to set more properties on the HTTP response than just the body, such as the status code\n+or headers, you can make your method return the link:{jaxrsapi}/javax/ws/rs/core/Response.html[`Response`]\n+type:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.NewCookie;\n+import javax.ws.rs.core.Response;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public Response hello() {\n+        // HTTP OK status with text/plain content type\n+        return Response.ok(\"Hello, World!\", MediaType.TEXT_PLAIN_TYPE)\n+         // set a response header\n+         .header(\"X-FroMage\", \"Camembert\")\n+         // set the Expires response header to two days from now\n+         .expires(Date.from(Instant.now().plus(Duration.ofDays(2))))\n+         // send a new cookie\n+         .cookie(new NewCookie(\"Flavour\", \"pralin\u00e9\"))\n+         // end of builder API\n+         .build();\n+    }\n+}\n+----\n+\n+=== Async/reactive support\n+\n+[[reactive]]\n+\n+If your endpoint method needs to accomplish an asynchronous or reactive task before\n+being able to answer, you can declare your method to return the \n+link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`] type (from https://smallrye.io/smallrye-mutiny/[Mutiny]), in which\n+case the current HTTP request will be automatically suspended after your method, until\n+the returned link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`] instance resolves to a value,\n+which will be mapped to a response exactly according to the previously described rules:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"escoffier\")\n+public class Endpoint {\n+\n+    @GET\n+    public Uni<Book> culinaryGuide(){\n+        return Book.findByIsbn(\"978-2081229297\");\n+    }\n+}\n+----\n+\n+This allows you to not block the IO thread while the book is being fetched from the\n+database, and allows Quarkus to serve more requests until your book is ready to\n+be sent to the client and terminate this request. Check out our \n+<<execution-model,Execution Model documentation>> for more information.\n+\n+The link:{jdkapi}/java/util/concurrent/CompletionStage.html[`CompletionStage`] return\n+type is also supported.\n+\n+=== Streaming support\n+\n+If you want to stream your response element by element, you can make your endpoint method return a \n+link:{mutinyapi}/io/smallrye/mutiny/Multi.html[`Multi`] type (from https://smallrye.io/smallrye-mutiny/[Mutiny]).\n+This is especially useful for streaming text or binary data.\n+\n+This example, using link:reactive-messaging-http.html[Reactive Messaging] shows how to stream\n+text data:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import org.eclipse.microprofile.reactive.messaging.Channel;\n+\n+import io.smallrye.mutiny.Multi;\n+\n+@Path(\"logs\")\n+public class Endpoint {\n+\n+    @Inject\n+    @Channel(\"log-out\")\n+    Multi<String> logs;\n+\n+    @GET\n+    public Multi<String> streamLogs() {\n+        return logs;\n+    }\n+}\n+----\n+\n+=== Server-Sent Event (SSE) support\n+\n+If you want to stream JSON objects in your response, you can use \n+https://html.spec.whatwg.org/multipage/server-sent-events.html[Server-Sent Events]\n+by just annotating your endpoint method with \n+link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces(MediaType.SERVER_SENT_EVENTS)`]\n+and specifying that each element should be <<json,serialised to JSON>> with \n+`@RestSseElementType(MediaType.APPLICATION_JSON)`.\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.jboss.resteasy.reactive.RestSseElementType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import io.smallrye.reactive.messaging.annotations.Channel;\n+\n+@Path(\"escoffier\")\n+public class Endpoint {\n+\n+    // Inject our Book channel\n+    @Inject\n+    @Channel(\"book-out\")\n+    Multi<Book> books;\n+\n+    @GET\n+    // Send the stream over SSE\n+    @Produces(MediaType.SERVER_SENT_EVENTS)\n+    // Each element will be sent as JSON\n+    @RestSseElementType(MediaType.APPLICATION_JSON)\n+    public Multi<Book> stream() {\n+        return books;\n+    }\n+}\n+----\n+\n+=== Accessing context objects\n+\n+[[context-objects]]\n+\n+There are a number of contextual objects that the framework will give you, if your endpoint\n+method takes parameters of the following type:\n+\n+.Table Context object\n+|===\n+|Type|Usage\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/HttpHeaders.html[`HttpHeaders`]\n+|All the request headers\n+\n+|link:{jaxrsapi}/javax/ws/rs/container/ResourceInfo.html[`ResourceInfo`]\n+|Information about the current endpoint method and class (requires reflection)\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/SecurityContext.html[`SecurityContext`]\n+|Access to the current user and roles\n+\n+|`SimpleResourceInfo`\n+|Information about the current endpoint method and class (no reflection required)\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/UriInfo.html[`UriInfo`]\n+|Provides information about the current endpoint and application URI\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Application.html[`Application`]\n+|Advanced: Current JAX-RS application class\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Configuration.html[`Configuration`]\n+|Advanced: Configuration about the deployed JAX-RS application\n+\n+|link:{jaxrsapi}/javax/ws/rs/ext/Providers.html[`Providers`]\n+|Advanced: Runtime access to JAX-RS providers\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Request.html[`Request`]\n+|Advanced: Access to the current HTTP method and <<preconditions>>\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/ResourceContext.html[`ResourceContext`]\n+|Advanced: access to instances of endpoints\n+\n+|`ServerRequestContext`\n+|Advanced: RESTEasy Reactive access to the current request/response\n+\n+|link:{jaxrsapi}/javax/ws/rs/sse/Sse.html[`Sse`]\n+|Advanced: Complex SSE use-cases\n+\n+|===\n+\n+For example, here is how you can return the name of the currently logged-in user:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.security.Principal;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.SecurityContext;\n+\n+@Path(\"user\")\n+public class Endpoint {\n+\n+    @GET\n+    public String userName(SecurityContext security) {\n+        Principal user = security.getUserPrincipal();\n+        return user != null ? user.getName() : \"<NOT LOGGED IN>\";\n+    }\n+}\n+----\n+\n+You can also inject those context objects using \n+https://javadoc.io/static/javax.inject/javax.inject/1/javax/inject/Inject.html[`@Inject`] on fields of the same\n+type.\n+\n+=== JSON serialisation\n+\n+[[json]]\n+\n+You can import either of the following modules to get support for JSON:\n+\n+.Table Context object\n+|===\n+|GAV|Usage\n+\n+|`io.quarkus:quarkus-resteasy-jackson`\n+|https://github.com/FasterXML/jackson[Jackson support]\n+\n+|`io.quarkus:quarkus-resteasy-jsonb`\n+|http://json-b.net/[JSONB support]\n+\n+|===\n+\n+In both cases, importing those modules will allow HTTP message bodies to be read from JSON\n+and serialised to JSON, for <<resource-types,all the types not already registered with a more specific\n+serialisation>>.\n+\n+== More advanced usage\n+\n+Here are some more advanced topics that you may not need to know about initially, but\n+could prove useful for more complex use-cases.\n+\n+=== Execution model, blocking, non-blocking\n+\n+[[execution-model]]\n+\n+RESTEasy Reactive is implemented using two main thread types:\n+\n+- IO threads: which are responsible for reading bytes from the HTTP request and\n+ writing bytes back to the HTTP response\n+- Worker threads: they are pooled and can be used to offload long-running operations\n+\n+The IO threads (often called the \"event loop\") are responsible for actually performing all the IO\n+operations in an asynchronous way, and to trigger any listener interested in the completion of those\n+IO operations.\n+\n+By default, RESTEasy Reactive will run endpoint methods on the IO threads, on the assumption that\n+they are going to be fast and only invoke non-blocking operations.\n+\n+This is the model of execution that leads to best performance if your endpoints do not do any blocking\n+operation (such as blocking IO, blocking on an asynchronous operation, or sleeping).\n+\n+If your endpoint method needs to do any of those blocking operations, you should add the \n+https://javadoc.io/doc/io.smallrye.common/smallrye-common-annotation/1.5.0/io/smallrye/common/annotation/Blocking.html[`@Blocking`]\n+annotation on your endpoint and it will instead be invoked on a worker thread. Your endpoint method\n+code can remain exactly the same, and it will be allowed to block:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.common.annotation.Blocking;\n+\n+@Path(\"yawn\")\n+public class Endpoint {\n+\n+    @Blocking\n+    @GET\n+    public String blockingHello() throws InterruptedException {\n+        // do a blocking operation\n+        Thread.sleep(1000);\n+        return \"Yaaaawwwwnnnnnn\u2026\";\n+    }\n+}\n+----\n+\n+Most of the time, there are ways to achieve the same blocking operations in an asynchronous/reactive\n+way, using https://smallrye.io/smallrye-mutiny/[Mutiny], http://hibernate.org/reactive/[Hibernate Reactive] \n+or any of the link:getting-started-reactive[Quarkus Reactive extensions] for example:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.time.Duration;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"yawn\")\n+public class Endpoint {\n+\n+    @GET\n+    public Uni<String> blockingHello() throws InterruptedException {\n+        return Uni.createFrom().item(\"Yaaaawwwwnnnnnn\u2026\")\n+                // do a non-blocking sleep\n+                .onItem().delayIt().by(Duration.ofSeconds(2));\n+    }\n+}\n+----\n+\n+=== Exception mapping\n+\n+If your application needs to return non-nominal HTTP codes in error cases, the best is\n+to throw exceptions that will result in the proper HTTP response being sent by the\n+framework using link:{jaxrsapi}/javax/ws/rs/WebApplicationException.html[`WebApplicationException`] or any of its subtypes:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.BadRequestException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.Path;\n+\n+@Path(\"fromages/{fromage}\")\n+public class Endpoint {\n+\n+    @GET\n+    public String findFromage(String fromage) {\n+        if(fromage == null)\n+            // send a 400\n+            throw new BadRequestException();\n+        if(!fromage.equals(\"camembert\"))\n+            // send a 404\n+            throw new NotFoundException(\"Unknown cheese: \" + fromage);\n+        return \"Camembert is a very nice cheese\";\n+    }\n+}\n+----\n+\n+If your endpoint method is delegating calls to another service layer which\n+does not know of JAX-RS, you need a way to turn service exceptions to an\n+HTTP response, and you can do that using the `@ServerExceptionMapper` annotation\n+on a method, with one parameter of the exception type you want to handle, and turning\n+that exception into a link:{jaxrsapi}/javax/ws/rs/core/Response.html[`Response`] (or a \n+link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni<Response>`]):\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.util.Map;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.ws.rs.BadRequestException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.resteasy.reactive.server.ServerExceptionMapper;\n+\n+class UnknownCheeseException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cde4943aec547bfcd64b41b939f2b5d2c3a0b77"}, "originalPosition": 781}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI4NDYyOQ==", "bodyText": "Same here", "url": "https://github.com/quarkusio/quarkus/pull/13802#discussion_r540284629", "createdAt": "2020-12-10T15:56:29Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/rest-reactive.adoc", "diffHunk": "@@ -0,0 +1,1553 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Writing REST Services with RESTEasy Reactive\n+\n+include::./attributes.adoc[]\n+:jaxrsapi: https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1\n+:jaxrsspec: /specs/jaxrs/2.1/index.html\n+:jdkapi: https://docs.oracle.com/en/java/javase/11/docs/api/java.base\n+:mutinyapi: https://smallrye.io/smallrye-mutiny/apidocs\n+:httpspec: https://tools.ietf.org/html/rfc7231\n+:jsonpapi: https://javadoc.io/doc/javax.json/javax.json-api/1.1.4\n+:vertxapi: https://javadoc.io/static/io.vertx/vertx-core/3.9.4\n+\n+This guide explains how to write REST Services with RESTEasy Reactive\n+\n+TODO: buff this\n+\n+TODO: links to our javadoc\n+\n+== What is RESTEasy Reactive?\n+\n+RESTEasy Reactive is a new link:{jaxrsspec}[JAX-RS]\n+implementation written from the ground up to work on our\n+common https://vertx.io/[Vert.x] layer and is thus fully reactive, while also being very tightly integrated with\n+Quarkus and consequently moving a lot of work to build time.\n+\n+You should be able to use it in place of any JAX-RS implementation, but on top of that it has\n+great performance for both blocking and non-blocking endpoints, and a lot of new features on top\n+of what JAX-RS provides.\n+\n+== Writing endpoints\n+\n+=== Getting started\n+\n+Add the following import to your `pom.xml` file:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-resteasy-reactive</artifactId>\n+</dependency>\n+----\n+\n+You can now write your first endpoint in the `org.acme.rest.Endpoint` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+=== Terminology\n+\n+REST:: https://en.wikipedia.org/wiki/Representational_state_transfer[REpresentational State Transfer]\n+Endpoint:: Java method which is called to serve a REST call\n+URL / URI (Uniform Resource Locator / Identifier):: Used to identify the location of REST resources (https://tools.ietf.org/html/rfc7230#section-2.7[specification])\n+Resource:: Represents your domain object. This is what your API serves and modifies. Also called an `entity` in JAX-RS.\n+Representation:: How your resource is represented on the wire, can vary depending on content types\n+Content type:: Designates a particular representation (also called a media type), for example `text/plain` or `application/json`\n+HTTP:: Underlying wire protocol for routing REST calls (see https://tools.ietf.org/html/rfc7230[HTTP specifications])\n+HTTP request:: the request part of the HTTP call, consisting of an HTTP method, a target URI, headers and an optional message body\n+HTTP response:: the response part of the HTTP call, consisting of an HTTP response status, headers and an optional message body\n+\n+=== Declaring endpoints: URI mapping\n+\n+Any class annotated with a link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation can have its methods exposed as REST endpoints,\n+provided they have an HTTP method annotation (see below).\n+\n+That link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation defines the URI prefix under which those methods will be exposed. It can\n+be empty, or contain a prefix such as `rest` or `rest/V1`.\n+\n+Each exposed endpoint method can in turn have another link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation which adds to its containing\n+class annotation. For example, this defines a `rest/hello` endpoint:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"rest\")\n+public class Endpoint {\n+\n+    @Path(\"hello\")\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+See <<uri-parameters,URI parameters>> for more information about URI mapping.\n+\n+=== Declaring endpoints: HTTP methods\n+\n+Each endpoint method must be annotated with one of the following annotations, which defines which HTTP\n+method will be mapped to the method:\n+\n+.Table HTTP method annotations\n+|===\n+|Annotation|Usage \n+\n+|link:{jaxrsapi}/javax/ws/rs/GET.html[`@GET`]\n+|Obtain a resource representation, should not modify state, idempotent (link:{httpspec}#section-4.3.1[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/HEAD.html[`@HEAD`]\n+|Obtain metadata about a resource, similar to `GET` with no body (link:{httpspec}#section-4.3.2[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/POST.html[`@POST`]\n+|Create a resource and obtain a link to it (link:{httpspec}#section-4.3.3[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PUT.html[`@PUT`]\n+|Replace a resource or create one, should be idempotent (link:{httpspec}#section-4.3.4[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/DELETE.html[`@DELETE`]\n+|Delete an existing resource, idempotent  (link:{httpspec}#section-4.3.5[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/OPTIONS.html[`@OPTIONS`]\n+|Obtain information about a resource, idempotent (link:{httpspec}#section-4.3.7[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PATCH.html[`@PATCH`]\n+|Update a resource, or create one, not idempotent (https://tools.ietf.org/html/rfc5789#section-2[HTTP docs])\n+\n+|===\n+\n+You can also declare other HTTP methods by declaring them as an annotation with the\n+link:{jaxrsapi}/javax/ws/rs/HttpMethod.html[`@HttpMethod`] annotation:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+import javax.ws.rs.HttpMethod;\n+import javax.ws.rs.Path;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@HttpMethod(\"FROMAGE\")\n+@interface FROMAGE {\n+}\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @FROMAGE\n+    public String hello(){\n+        return \"Hello, Cheese World!\";\n+    }\n+}\n+----\n+\n+=== Declaring endpoints: representation / content types\n+\n+Each endpoint method may consume or produce specific resource representations, which are indicated by\n+the HTTP link:{httpspec}#section-3.1.1.5[`Content-Type`] header, which in turn contains \n+link:{httpspec}#section-3.1.1.1[MIME (Media Type)] values, such as the following:\n+\n+- `text/plain` which is the default for any endpoint returning a `String`.\n+- `text/html` for HTML (such as with link:qute[Qute templating])\n+- `application/json` for a <<json,JSON REST endpoint>>\n+- `text/*` which is a sub-type wildcard for any text media type\n+- `*/*` which is a wildcard for any media type\n+\n+You may annotate your endpoint class with the link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces`] \n+or link:{jaxrsapi}/javax/ws/rs/Consumes.html[`@Consumes`] annotations, which\n+allow you to specify one or more media types that your endpoint may accept as HTTP request body\n+or produce as HTTP response body. Those class annotations apply to each method.\n+\n+Any method may also be annotated with the link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces`] \n+or link:{jaxrsapi}/javax/ws/rs/Consumes.html[`@Consumes`] annotations, in which\n+case they override any eventual class annotation.\n+\n+The link:{jaxrsapi}/javax/ws/rs/core/MediaType.html[`MediaType`] class has many constants you\n+can use to point to specific pre-defined media types.\n+\n+See <<negotiation>> for more information.\n+\n+=== Accessing request parameters\n+\n+[[request-parameters]]\n+\n+NOTE: don't forget to configure your compiler to generate parameter name information with `-parameters` (javac)\n+or `<parameters>` or `<maven.compiler.parameters>` (https://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#parameters[Maven]).\n+\n+The following HTTP request elements may be obtained by your endpoint method:\n+\n+.Table HTTP request parameter annotations\n+|===\n+|HTTP element|Annotation|Usage \n+\n+|[[path-parameter]]Path parameter\n+|`@RestPath` (or nothing)\n+|URI template parameter (simplified version of the https://tools.ietf.org/html/rfc6570[URI Template specification]), \n+see <<uri-parameters,URI parameters>> for more information.\n+\n+|Query parameter\n+|`@RestQuery`\n+|The value of an https://tools.ietf.org/html/rfc3986#section-3.4[URI query parameter]\n+\n+|Header\n+|`@RestHeader`\n+|The value of an https://tools.ietf.org/html/rfc7230#section-3.2[HTTP header]\n+\n+|Cookie\n+|`@RestCookie`\n+|The value of an https://tools.ietf.org/html/rfc6265#section-4.2[HTTP cookie]\n+\n+|Form parameter\n+|`@RestForm`\n+|The value of an https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST[HTTP URL-encoded FORM]\n+\n+|Matrix parameter\n+|`@RestMatrix`\n+|The value of an https://tools.ietf.org/html/rfc3986#section-3.3[URI path segment parameter]\n+\n+|===\n+\n+For each of those annotations, you may specify the name of the element they refer to, otherwise\n+they will use the name of the annotated method parameter.\n+\n+If a client made the following HTTP call:\n+\n+[source,http]\n+----\n+POST /cheeses;variant=goat/tomme?age=matured HTTP/1.1\n+Content-Type: application/x-www-form-urlencoded\n+Cookie: level=hardcore\n+X-Cheese-Secret-Handshake: fist-bump\n+\n+smell=strong\n+----\n+\n+Then you could obtain all the various parameters with this endpoint method:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+\n+import org.jboss.resteasy.reactive.RestCookie;\n+import org.jboss.resteasy.reactive.RestForm;\n+import org.jboss.resteasy.reactive.RestHeader;\n+import org.jboss.resteasy.reactive.RestMatrix;\n+import org.jboss.resteasy.reactive.RestPath;\n+import org.jboss.resteasy.reactive.RestQuery;\n+\n+@Path(\"/cheeses/{type}\")\n+public class Endpoint {\n+\n+    @POST\n+    public String allParams(@RestPath String type,\n+                            @RestMatrix String variant,\n+                            @RestQuery String age,\n+                            @RestCookie String level,\n+                            @RestHeader(\"X-Cheese-Secret-Handshake\")\n+                            String secretHandshake,\n+                            @RestForm String smell){\n+        return type + \"/\" + variant + \"/\" + age + \"/\" + level + \"/\" + secretHandshake + \"/\" + smell;\n+    }\n+}\n+----\n+\n+NOTE: the `@RestPath` annotation is optional: any parameter whose name matches an existing URI\n+template variable will be automatically assumed to have `@RestPath`.\n+\n+Naturally you can also use any of the JAX-RS annotations link:{jaxrsapi}/javax/ws/rs/PathParam.html[`@PathParam`],\n+link:{jaxrsapi}/javax/ws/rs/QueryParam.html[`@QueryParam`],\n+link:{jaxrsapi}/javax/ws/rs/HeaderParam.html[`@HeaderParam`],\n+link:{jaxrsapi}/javax/ws/rs/CookieParam.html[`@CookieParam`],\n+link:{jaxrsapi}/javax/ws/rs/FormParam.html[`@FormParam`] or\n+link:{jaxrsapi}/javax/ws/rs/MatrixParam.html[`@MatrixParam`] for this,\n+but they require you to specify the parameter name.\n+\n+See <<parameter-mapping>> for more advanced use-cases.\n+\n+=== Declaring URI parameters\n+\n+[[uri-parameters]]\n+\n+You can declare URI parameters and use regular expressions in your path, so for instance\n+the following endpoint will serve requests for `/hello/stef/23` and `/hello` but not\n+`/hello/stef/0x23`:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"hello\")\n+public class Endpoint {\n+\n+    @Path(\"{name}/{age:\\\\d+}\")\n+    @GET\n+    public String personalisedHello(String name, int age){\n+        return \"Hello \" + name + \" is your age really \" + age + \"?\";\n+    }\n+\n+    @GET\n+    public String genericHello(){\n+        return \"Hello stranger\";\n+    }\n+}\n+----\n+\n+\n+=== Accessing the request body\n+\n+Any method parameter with no annotation will receive the method body.footnote:[Unless it is a\n+<<path-parameter,URI template parameter>> or a <<context-objects,context object>>.], after it has been mapped from\n+its HTTP representation to the Java type of the parameter.\n+\n+The following parameter types will be supported out of the box:\n+\n+[[resource-types]]\n+\n+.Table Request body parameter type\n+|===\n+|Type|Usage\n+\n+|link:{jdkapi}/java/io/File.html[`File`]\n+|The entire request body in a temporary file\n+\n+|`byte[]`\n+|The entire request body, not decoded\n+\n+|`char[]`\n+|The entire request body, decoded\n+\n+|link:{jdkapi}/java/lang/String.html[`String`]\n+|The entire request body, decoded\n+\n+|link:{jdkapi}/java/io/InputStream.html[`InputStream`]\n+|The request body in a blocking stream\n+\n+|link:{jdkapi}/java/io/Reader.html[`Reader`]\n+|The request body in a blocking stream\n+\n+|All Java primitives and their wrapper classes\n+|Java primitive types\n+\n+|link:{jdkapi}/java/math/BigDecimal.html[`BigDecimal`], link:{jdkapi}/java/math/BigInteger.html[`BigInteger`]\n+|Large integers and decimals.\n+\n+|link:{jsonpapi}/javax/json/JsonArray.html[`JsonArray`], link:{jsonpapi}/javax/json/JsonArray.html[`JsonObject`],\n+link:{jsonpapi}/javax/json/JsonArray.html[`JsonStructure`], link:{jsonpapi}/javax/json/JsonArray.html[`JsonValue`]\n+|JSON value types  \n+\n+|link:{vertxapi}io/vertx/core/buffer/Buffer.html[`Buffer`]\n+|Vert.x Buffer \n+\n+|any other type\n+|Will be <<json,mapped from JSON to that type>>\n+\n+|===\n+\n+NOTE: You can add support for more <<readers-writers,body parameter types>>.\n+\n+=== Returning a response body\n+\n+In order to return an HTTP response, simply return the resource you want from your method. The method\n+return type and its optional content type will be used to decide how to serialise it to the HTTP\n+response (see <<negotiation>> for more advanced information).\n+\n+You can return any of the pre-defined types that you can read from the <<resource-types,HTTP response>>,\n+and any other type will be mapped <<json,from that type to JSON>>.\n+\n+Alternately, you can also return a <<reactive,reactive type>> such as link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`], \n+link:{mutinyapi}/io/smallrye/mutiny/Multi.html[`Multi`] or \n+link:{jdkapi}/java/util/concurrent/CompletionStage.html[`CompletionStage`]\n+that resolve to one of the mentioned return types.\n+\n+=== Setting other response properties\n+\n+If you need to set more properties on the HTTP response than just the body, such as the status code\n+or headers, you can make your method return the link:{jaxrsapi}/javax/ws/rs/core/Response.html[`Response`]\n+type:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.NewCookie;\n+import javax.ws.rs.core.Response;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public Response hello() {\n+        // HTTP OK status with text/plain content type\n+        return Response.ok(\"Hello, World!\", MediaType.TEXT_PLAIN_TYPE)\n+         // set a response header\n+         .header(\"X-FroMage\", \"Camembert\")\n+         // set the Expires response header to two days from now\n+         .expires(Date.from(Instant.now().plus(Duration.ofDays(2))))\n+         // send a new cookie\n+         .cookie(new NewCookie(\"Flavour\", \"pralin\u00e9\"))\n+         // end of builder API\n+         .build();\n+    }\n+}\n+----\n+\n+=== Async/reactive support\n+\n+[[reactive]]\n+\n+If your endpoint method needs to accomplish an asynchronous or reactive task before\n+being able to answer, you can declare your method to return the \n+link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`] type (from https://smallrye.io/smallrye-mutiny/[Mutiny]), in which\n+case the current HTTP request will be automatically suspended after your method, until\n+the returned link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`] instance resolves to a value,\n+which will be mapped to a response exactly according to the previously described rules:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"escoffier\")\n+public class Endpoint {\n+\n+    @GET\n+    public Uni<Book> culinaryGuide(){\n+        return Book.findByIsbn(\"978-2081229297\");\n+    }\n+}\n+----\n+\n+This allows you to not block the IO thread while the book is being fetched from the\n+database, and allows Quarkus to serve more requests until your book is ready to\n+be sent to the client and terminate this request. Check out our \n+<<execution-model,Execution Model documentation>> for more information.\n+\n+The link:{jdkapi}/java/util/concurrent/CompletionStage.html[`CompletionStage`] return\n+type is also supported.\n+\n+=== Streaming support\n+\n+If you want to stream your response element by element, you can make your endpoint method return a \n+link:{mutinyapi}/io/smallrye/mutiny/Multi.html[`Multi`] type (from https://smallrye.io/smallrye-mutiny/[Mutiny]).\n+This is especially useful for streaming text or binary data.\n+\n+This example, using link:reactive-messaging-http.html[Reactive Messaging] shows how to stream\n+text data:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import org.eclipse.microprofile.reactive.messaging.Channel;\n+\n+import io.smallrye.mutiny.Multi;\n+\n+@Path(\"logs\")\n+public class Endpoint {\n+\n+    @Inject\n+    @Channel(\"log-out\")\n+    Multi<String> logs;\n+\n+    @GET\n+    public Multi<String> streamLogs() {\n+        return logs;\n+    }\n+}\n+----\n+\n+=== Server-Sent Event (SSE) support\n+\n+If you want to stream JSON objects in your response, you can use \n+https://html.spec.whatwg.org/multipage/server-sent-events.html[Server-Sent Events]\n+by just annotating your endpoint method with \n+link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces(MediaType.SERVER_SENT_EVENTS)`]\n+and specifying that each element should be <<json,serialised to JSON>> with \n+`@RestSseElementType(MediaType.APPLICATION_JSON)`.\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.jboss.resteasy.reactive.RestSseElementType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import io.smallrye.reactive.messaging.annotations.Channel;\n+\n+@Path(\"escoffier\")\n+public class Endpoint {\n+\n+    // Inject our Book channel\n+    @Inject\n+    @Channel(\"book-out\")\n+    Multi<Book> books;\n+\n+    @GET\n+    // Send the stream over SSE\n+    @Produces(MediaType.SERVER_SENT_EVENTS)\n+    // Each element will be sent as JSON\n+    @RestSseElementType(MediaType.APPLICATION_JSON)\n+    public Multi<Book> stream() {\n+        return books;\n+    }\n+}\n+----\n+\n+=== Accessing context objects\n+\n+[[context-objects]]\n+\n+There are a number of contextual objects that the framework will give you, if your endpoint\n+method takes parameters of the following type:\n+\n+.Table Context object\n+|===\n+|Type|Usage\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/HttpHeaders.html[`HttpHeaders`]\n+|All the request headers\n+\n+|link:{jaxrsapi}/javax/ws/rs/container/ResourceInfo.html[`ResourceInfo`]\n+|Information about the current endpoint method and class (requires reflection)\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/SecurityContext.html[`SecurityContext`]\n+|Access to the current user and roles\n+\n+|`SimpleResourceInfo`\n+|Information about the current endpoint method and class (no reflection required)\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/UriInfo.html[`UriInfo`]\n+|Provides information about the current endpoint and application URI\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Application.html[`Application`]\n+|Advanced: Current JAX-RS application class\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Configuration.html[`Configuration`]\n+|Advanced: Configuration about the deployed JAX-RS application\n+\n+|link:{jaxrsapi}/javax/ws/rs/ext/Providers.html[`Providers`]\n+|Advanced: Runtime access to JAX-RS providers\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Request.html[`Request`]\n+|Advanced: Access to the current HTTP method and <<preconditions>>\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/ResourceContext.html[`ResourceContext`]\n+|Advanced: access to instances of endpoints\n+\n+|`ServerRequestContext`\n+|Advanced: RESTEasy Reactive access to the current request/response\n+\n+|link:{jaxrsapi}/javax/ws/rs/sse/Sse.html[`Sse`]\n+|Advanced: Complex SSE use-cases\n+\n+|===\n+\n+For example, here is how you can return the name of the currently logged-in user:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.security.Principal;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.SecurityContext;\n+\n+@Path(\"user\")\n+public class Endpoint {\n+\n+    @GET\n+    public String userName(SecurityContext security) {\n+        Principal user = security.getUserPrincipal();\n+        return user != null ? user.getName() : \"<NOT LOGGED IN>\";\n+    }\n+}\n+----\n+\n+You can also inject those context objects using \n+https://javadoc.io/static/javax.inject/javax.inject/1/javax/inject/Inject.html[`@Inject`] on fields of the same\n+type.\n+\n+=== JSON serialisation\n+\n+[[json]]\n+\n+You can import either of the following modules to get support for JSON:\n+\n+.Table Context object\n+|===\n+|GAV|Usage\n+\n+|`io.quarkus:quarkus-resteasy-jackson`\n+|https://github.com/FasterXML/jackson[Jackson support]\n+\n+|`io.quarkus:quarkus-resteasy-jsonb`\n+|http://json-b.net/[JSONB support]\n+\n+|===\n+\n+In both cases, importing those modules will allow HTTP message bodies to be read from JSON\n+and serialised to JSON, for <<resource-types,all the types not already registered with a more specific\n+serialisation>>.\n+\n+== More advanced usage\n+\n+Here are some more advanced topics that you may not need to know about initially, but\n+could prove useful for more complex use-cases.\n+\n+=== Execution model, blocking, non-blocking\n+\n+[[execution-model]]\n+\n+RESTEasy Reactive is implemented using two main thread types:\n+\n+- IO threads: which are responsible for reading bytes from the HTTP request and\n+ writing bytes back to the HTTP response\n+- Worker threads: they are pooled and can be used to offload long-running operations\n+\n+The IO threads (often called the \"event loop\") are responsible for actually performing all the IO\n+operations in an asynchronous way, and to trigger any listener interested in the completion of those\n+IO operations.\n+\n+By default, RESTEasy Reactive will run endpoint methods on the IO threads, on the assumption that\n+they are going to be fast and only invoke non-blocking operations.\n+\n+This is the model of execution that leads to best performance if your endpoints do not do any blocking\n+operation (such as blocking IO, blocking on an asynchronous operation, or sleeping).\n+\n+If your endpoint method needs to do any of those blocking operations, you should add the \n+https://javadoc.io/doc/io.smallrye.common/smallrye-common-annotation/1.5.0/io/smallrye/common/annotation/Blocking.html[`@Blocking`]\n+annotation on your endpoint and it will instead be invoked on a worker thread. Your endpoint method\n+code can remain exactly the same, and it will be allowed to block:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.common.annotation.Blocking;\n+\n+@Path(\"yawn\")\n+public class Endpoint {\n+\n+    @Blocking\n+    @GET\n+    public String blockingHello() throws InterruptedException {\n+        // do a blocking operation\n+        Thread.sleep(1000);\n+        return \"Yaaaawwwwnnnnnn\u2026\";\n+    }\n+}\n+----\n+\n+Most of the time, there are ways to achieve the same blocking operations in an asynchronous/reactive\n+way, using https://smallrye.io/smallrye-mutiny/[Mutiny], http://hibernate.org/reactive/[Hibernate Reactive] \n+or any of the link:getting-started-reactive[Quarkus Reactive extensions] for example:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.time.Duration;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"yawn\")\n+public class Endpoint {\n+\n+    @GET\n+    public Uni<String> blockingHello() throws InterruptedException {\n+        return Uni.createFrom().item(\"Yaaaawwwwnnnnnn\u2026\")\n+                // do a non-blocking sleep\n+                .onItem().delayIt().by(Duration.ofSeconds(2));\n+    }\n+}\n+----\n+\n+=== Exception mapping\n+\n+If your application needs to return non-nominal HTTP codes in error cases, the best is\n+to throw exceptions that will result in the proper HTTP response being sent by the\n+framework using link:{jaxrsapi}/javax/ws/rs/WebApplicationException.html[`WebApplicationException`] or any of its subtypes:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.BadRequestException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.Path;\n+\n+@Path(\"fromages/{fromage}\")\n+public class Endpoint {\n+\n+    @GET\n+    public String findFromage(String fromage) {\n+        if(fromage == null)\n+            // send a 400\n+            throw new BadRequestException();\n+        if(!fromage.equals(\"camembert\"))\n+            // send a 404\n+            throw new NotFoundException(\"Unknown cheese: \" + fromage);\n+        return \"Camembert is a very nice cheese\";\n+    }\n+}\n+----\n+\n+If your endpoint method is delegating calls to another service layer which\n+does not know of JAX-RS, you need a way to turn service exceptions to an\n+HTTP response, and you can do that using the `@ServerExceptionMapper` annotation\n+on a method, with one parameter of the exception type you want to handle, and turning\n+that exception into a link:{jaxrsapi}/javax/ws/rs/core/Response.html[`Response`] (or a \n+link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni<Response>`]):\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.util.Map;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.ws.rs.BadRequestException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.resteasy.reactive.server.ServerExceptionMapper;\n+\n+class UnknownCheeseException extends RuntimeException {\n+    public final String name;\n+    \n+    public UnknownCheeseException(String name) {\n+        this.name = name;\n+    }\n+}\n+\n+@ApplicationScoped\n+class CheeseService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cde4943aec547bfcd64b41b939f2b5d2c3a0b77"}, "originalPosition": 790}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI4NDc2MA==", "bodyText": "Public here too", "url": "https://github.com/quarkusio/quarkus/pull/13802#discussion_r540284760", "createdAt": "2020-12-10T15:56:37Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/rest-reactive.adoc", "diffHunk": "@@ -0,0 +1,1553 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Writing REST Services with RESTEasy Reactive\n+\n+include::./attributes.adoc[]\n+:jaxrsapi: https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1\n+:jaxrsspec: /specs/jaxrs/2.1/index.html\n+:jdkapi: https://docs.oracle.com/en/java/javase/11/docs/api/java.base\n+:mutinyapi: https://smallrye.io/smallrye-mutiny/apidocs\n+:httpspec: https://tools.ietf.org/html/rfc7231\n+:jsonpapi: https://javadoc.io/doc/javax.json/javax.json-api/1.1.4\n+:vertxapi: https://javadoc.io/static/io.vertx/vertx-core/3.9.4\n+\n+This guide explains how to write REST Services with RESTEasy Reactive\n+\n+TODO: buff this\n+\n+TODO: links to our javadoc\n+\n+== What is RESTEasy Reactive?\n+\n+RESTEasy Reactive is a new link:{jaxrsspec}[JAX-RS]\n+implementation written from the ground up to work on our\n+common https://vertx.io/[Vert.x] layer and is thus fully reactive, while also being very tightly integrated with\n+Quarkus and consequently moving a lot of work to build time.\n+\n+You should be able to use it in place of any JAX-RS implementation, but on top of that it has\n+great performance for both blocking and non-blocking endpoints, and a lot of new features on top\n+of what JAX-RS provides.\n+\n+== Writing endpoints\n+\n+=== Getting started\n+\n+Add the following import to your `pom.xml` file:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-resteasy-reactive</artifactId>\n+</dependency>\n+----\n+\n+You can now write your first endpoint in the `org.acme.rest.Endpoint` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+=== Terminology\n+\n+REST:: https://en.wikipedia.org/wiki/Representational_state_transfer[REpresentational State Transfer]\n+Endpoint:: Java method which is called to serve a REST call\n+URL / URI (Uniform Resource Locator / Identifier):: Used to identify the location of REST resources (https://tools.ietf.org/html/rfc7230#section-2.7[specification])\n+Resource:: Represents your domain object. This is what your API serves and modifies. Also called an `entity` in JAX-RS.\n+Representation:: How your resource is represented on the wire, can vary depending on content types\n+Content type:: Designates a particular representation (also called a media type), for example `text/plain` or `application/json`\n+HTTP:: Underlying wire protocol for routing REST calls (see https://tools.ietf.org/html/rfc7230[HTTP specifications])\n+HTTP request:: the request part of the HTTP call, consisting of an HTTP method, a target URI, headers and an optional message body\n+HTTP response:: the response part of the HTTP call, consisting of an HTTP response status, headers and an optional message body\n+\n+=== Declaring endpoints: URI mapping\n+\n+Any class annotated with a link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation can have its methods exposed as REST endpoints,\n+provided they have an HTTP method annotation (see below).\n+\n+That link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation defines the URI prefix under which those methods will be exposed. It can\n+be empty, or contain a prefix such as `rest` or `rest/V1`.\n+\n+Each exposed endpoint method can in turn have another link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation which adds to its containing\n+class annotation. For example, this defines a `rest/hello` endpoint:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"rest\")\n+public class Endpoint {\n+\n+    @Path(\"hello\")\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+See <<uri-parameters,URI parameters>> for more information about URI mapping.\n+\n+=== Declaring endpoints: HTTP methods\n+\n+Each endpoint method must be annotated with one of the following annotations, which defines which HTTP\n+method will be mapped to the method:\n+\n+.Table HTTP method annotations\n+|===\n+|Annotation|Usage \n+\n+|link:{jaxrsapi}/javax/ws/rs/GET.html[`@GET`]\n+|Obtain a resource representation, should not modify state, idempotent (link:{httpspec}#section-4.3.1[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/HEAD.html[`@HEAD`]\n+|Obtain metadata about a resource, similar to `GET` with no body (link:{httpspec}#section-4.3.2[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/POST.html[`@POST`]\n+|Create a resource and obtain a link to it (link:{httpspec}#section-4.3.3[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PUT.html[`@PUT`]\n+|Replace a resource or create one, should be idempotent (link:{httpspec}#section-4.3.4[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/DELETE.html[`@DELETE`]\n+|Delete an existing resource, idempotent  (link:{httpspec}#section-4.3.5[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/OPTIONS.html[`@OPTIONS`]\n+|Obtain information about a resource, idempotent (link:{httpspec}#section-4.3.7[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PATCH.html[`@PATCH`]\n+|Update a resource, or create one, not idempotent (https://tools.ietf.org/html/rfc5789#section-2[HTTP docs])\n+\n+|===\n+\n+You can also declare other HTTP methods by declaring them as an annotation with the\n+link:{jaxrsapi}/javax/ws/rs/HttpMethod.html[`@HttpMethod`] annotation:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+import javax.ws.rs.HttpMethod;\n+import javax.ws.rs.Path;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@HttpMethod(\"FROMAGE\")\n+@interface FROMAGE {\n+}\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @FROMAGE\n+    public String hello(){\n+        return \"Hello, Cheese World!\";\n+    }\n+}\n+----\n+\n+=== Declaring endpoints: representation / content types\n+\n+Each endpoint method may consume or produce specific resource representations, which are indicated by\n+the HTTP link:{httpspec}#section-3.1.1.5[`Content-Type`] header, which in turn contains \n+link:{httpspec}#section-3.1.1.1[MIME (Media Type)] values, such as the following:\n+\n+- `text/plain` which is the default for any endpoint returning a `String`.\n+- `text/html` for HTML (such as with link:qute[Qute templating])\n+- `application/json` for a <<json,JSON REST endpoint>>\n+- `text/*` which is a sub-type wildcard for any text media type\n+- `*/*` which is a wildcard for any media type\n+\n+You may annotate your endpoint class with the link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces`] \n+or link:{jaxrsapi}/javax/ws/rs/Consumes.html[`@Consumes`] annotations, which\n+allow you to specify one or more media types that your endpoint may accept as HTTP request body\n+or produce as HTTP response body. Those class annotations apply to each method.\n+\n+Any method may also be annotated with the link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces`] \n+or link:{jaxrsapi}/javax/ws/rs/Consumes.html[`@Consumes`] annotations, in which\n+case they override any eventual class annotation.\n+\n+The link:{jaxrsapi}/javax/ws/rs/core/MediaType.html[`MediaType`] class has many constants you\n+can use to point to specific pre-defined media types.\n+\n+See <<negotiation>> for more information.\n+\n+=== Accessing request parameters\n+\n+[[request-parameters]]\n+\n+NOTE: don't forget to configure your compiler to generate parameter name information with `-parameters` (javac)\n+or `<parameters>` or `<maven.compiler.parameters>` (https://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#parameters[Maven]).\n+\n+The following HTTP request elements may be obtained by your endpoint method:\n+\n+.Table HTTP request parameter annotations\n+|===\n+|HTTP element|Annotation|Usage \n+\n+|[[path-parameter]]Path parameter\n+|`@RestPath` (or nothing)\n+|URI template parameter (simplified version of the https://tools.ietf.org/html/rfc6570[URI Template specification]), \n+see <<uri-parameters,URI parameters>> for more information.\n+\n+|Query parameter\n+|`@RestQuery`\n+|The value of an https://tools.ietf.org/html/rfc3986#section-3.4[URI query parameter]\n+\n+|Header\n+|`@RestHeader`\n+|The value of an https://tools.ietf.org/html/rfc7230#section-3.2[HTTP header]\n+\n+|Cookie\n+|`@RestCookie`\n+|The value of an https://tools.ietf.org/html/rfc6265#section-4.2[HTTP cookie]\n+\n+|Form parameter\n+|`@RestForm`\n+|The value of an https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST[HTTP URL-encoded FORM]\n+\n+|Matrix parameter\n+|`@RestMatrix`\n+|The value of an https://tools.ietf.org/html/rfc3986#section-3.3[URI path segment parameter]\n+\n+|===\n+\n+For each of those annotations, you may specify the name of the element they refer to, otherwise\n+they will use the name of the annotated method parameter.\n+\n+If a client made the following HTTP call:\n+\n+[source,http]\n+----\n+POST /cheeses;variant=goat/tomme?age=matured HTTP/1.1\n+Content-Type: application/x-www-form-urlencoded\n+Cookie: level=hardcore\n+X-Cheese-Secret-Handshake: fist-bump\n+\n+smell=strong\n+----\n+\n+Then you could obtain all the various parameters with this endpoint method:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+\n+import org.jboss.resteasy.reactive.RestCookie;\n+import org.jboss.resteasy.reactive.RestForm;\n+import org.jboss.resteasy.reactive.RestHeader;\n+import org.jboss.resteasy.reactive.RestMatrix;\n+import org.jboss.resteasy.reactive.RestPath;\n+import org.jboss.resteasy.reactive.RestQuery;\n+\n+@Path(\"/cheeses/{type}\")\n+public class Endpoint {\n+\n+    @POST\n+    public String allParams(@RestPath String type,\n+                            @RestMatrix String variant,\n+                            @RestQuery String age,\n+                            @RestCookie String level,\n+                            @RestHeader(\"X-Cheese-Secret-Handshake\")\n+                            String secretHandshake,\n+                            @RestForm String smell){\n+        return type + \"/\" + variant + \"/\" + age + \"/\" + level + \"/\" + secretHandshake + \"/\" + smell;\n+    }\n+}\n+----\n+\n+NOTE: the `@RestPath` annotation is optional: any parameter whose name matches an existing URI\n+template variable will be automatically assumed to have `@RestPath`.\n+\n+Naturally you can also use any of the JAX-RS annotations link:{jaxrsapi}/javax/ws/rs/PathParam.html[`@PathParam`],\n+link:{jaxrsapi}/javax/ws/rs/QueryParam.html[`@QueryParam`],\n+link:{jaxrsapi}/javax/ws/rs/HeaderParam.html[`@HeaderParam`],\n+link:{jaxrsapi}/javax/ws/rs/CookieParam.html[`@CookieParam`],\n+link:{jaxrsapi}/javax/ws/rs/FormParam.html[`@FormParam`] or\n+link:{jaxrsapi}/javax/ws/rs/MatrixParam.html[`@MatrixParam`] for this,\n+but they require you to specify the parameter name.\n+\n+See <<parameter-mapping>> for more advanced use-cases.\n+\n+=== Declaring URI parameters\n+\n+[[uri-parameters]]\n+\n+You can declare URI parameters and use regular expressions in your path, so for instance\n+the following endpoint will serve requests for `/hello/stef/23` and `/hello` but not\n+`/hello/stef/0x23`:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"hello\")\n+public class Endpoint {\n+\n+    @Path(\"{name}/{age:\\\\d+}\")\n+    @GET\n+    public String personalisedHello(String name, int age){\n+        return \"Hello \" + name + \" is your age really \" + age + \"?\";\n+    }\n+\n+    @GET\n+    public String genericHello(){\n+        return \"Hello stranger\";\n+    }\n+}\n+----\n+\n+\n+=== Accessing the request body\n+\n+Any method parameter with no annotation will receive the method body.footnote:[Unless it is a\n+<<path-parameter,URI template parameter>> or a <<context-objects,context object>>.], after it has been mapped from\n+its HTTP representation to the Java type of the parameter.\n+\n+The following parameter types will be supported out of the box:\n+\n+[[resource-types]]\n+\n+.Table Request body parameter type\n+|===\n+|Type|Usage\n+\n+|link:{jdkapi}/java/io/File.html[`File`]\n+|The entire request body in a temporary file\n+\n+|`byte[]`\n+|The entire request body, not decoded\n+\n+|`char[]`\n+|The entire request body, decoded\n+\n+|link:{jdkapi}/java/lang/String.html[`String`]\n+|The entire request body, decoded\n+\n+|link:{jdkapi}/java/io/InputStream.html[`InputStream`]\n+|The request body in a blocking stream\n+\n+|link:{jdkapi}/java/io/Reader.html[`Reader`]\n+|The request body in a blocking stream\n+\n+|All Java primitives and their wrapper classes\n+|Java primitive types\n+\n+|link:{jdkapi}/java/math/BigDecimal.html[`BigDecimal`], link:{jdkapi}/java/math/BigInteger.html[`BigInteger`]\n+|Large integers and decimals.\n+\n+|link:{jsonpapi}/javax/json/JsonArray.html[`JsonArray`], link:{jsonpapi}/javax/json/JsonArray.html[`JsonObject`],\n+link:{jsonpapi}/javax/json/JsonArray.html[`JsonStructure`], link:{jsonpapi}/javax/json/JsonArray.html[`JsonValue`]\n+|JSON value types  \n+\n+|link:{vertxapi}io/vertx/core/buffer/Buffer.html[`Buffer`]\n+|Vert.x Buffer \n+\n+|any other type\n+|Will be <<json,mapped from JSON to that type>>\n+\n+|===\n+\n+NOTE: You can add support for more <<readers-writers,body parameter types>>.\n+\n+=== Returning a response body\n+\n+In order to return an HTTP response, simply return the resource you want from your method. The method\n+return type and its optional content type will be used to decide how to serialise it to the HTTP\n+response (see <<negotiation>> for more advanced information).\n+\n+You can return any of the pre-defined types that you can read from the <<resource-types,HTTP response>>,\n+and any other type will be mapped <<json,from that type to JSON>>.\n+\n+Alternately, you can also return a <<reactive,reactive type>> such as link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`], \n+link:{mutinyapi}/io/smallrye/mutiny/Multi.html[`Multi`] or \n+link:{jdkapi}/java/util/concurrent/CompletionStage.html[`CompletionStage`]\n+that resolve to one of the mentioned return types.\n+\n+=== Setting other response properties\n+\n+If you need to set more properties on the HTTP response than just the body, such as the status code\n+or headers, you can make your method return the link:{jaxrsapi}/javax/ws/rs/core/Response.html[`Response`]\n+type:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.NewCookie;\n+import javax.ws.rs.core.Response;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public Response hello() {\n+        // HTTP OK status with text/plain content type\n+        return Response.ok(\"Hello, World!\", MediaType.TEXT_PLAIN_TYPE)\n+         // set a response header\n+         .header(\"X-FroMage\", \"Camembert\")\n+         // set the Expires response header to two days from now\n+         .expires(Date.from(Instant.now().plus(Duration.ofDays(2))))\n+         // send a new cookie\n+         .cookie(new NewCookie(\"Flavour\", \"pralin\u00e9\"))\n+         // end of builder API\n+         .build();\n+    }\n+}\n+----\n+\n+=== Async/reactive support\n+\n+[[reactive]]\n+\n+If your endpoint method needs to accomplish an asynchronous or reactive task before\n+being able to answer, you can declare your method to return the \n+link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`] type (from https://smallrye.io/smallrye-mutiny/[Mutiny]), in which\n+case the current HTTP request will be automatically suspended after your method, until\n+the returned link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`] instance resolves to a value,\n+which will be mapped to a response exactly according to the previously described rules:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"escoffier\")\n+public class Endpoint {\n+\n+    @GET\n+    public Uni<Book> culinaryGuide(){\n+        return Book.findByIsbn(\"978-2081229297\");\n+    }\n+}\n+----\n+\n+This allows you to not block the IO thread while the book is being fetched from the\n+database, and allows Quarkus to serve more requests until your book is ready to\n+be sent to the client and terminate this request. Check out our \n+<<execution-model,Execution Model documentation>> for more information.\n+\n+The link:{jdkapi}/java/util/concurrent/CompletionStage.html[`CompletionStage`] return\n+type is also supported.\n+\n+=== Streaming support\n+\n+If you want to stream your response element by element, you can make your endpoint method return a \n+link:{mutinyapi}/io/smallrye/mutiny/Multi.html[`Multi`] type (from https://smallrye.io/smallrye-mutiny/[Mutiny]).\n+This is especially useful for streaming text or binary data.\n+\n+This example, using link:reactive-messaging-http.html[Reactive Messaging] shows how to stream\n+text data:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import org.eclipse.microprofile.reactive.messaging.Channel;\n+\n+import io.smallrye.mutiny.Multi;\n+\n+@Path(\"logs\")\n+public class Endpoint {\n+\n+    @Inject\n+    @Channel(\"log-out\")\n+    Multi<String> logs;\n+\n+    @GET\n+    public Multi<String> streamLogs() {\n+        return logs;\n+    }\n+}\n+----\n+\n+=== Server-Sent Event (SSE) support\n+\n+If you want to stream JSON objects in your response, you can use \n+https://html.spec.whatwg.org/multipage/server-sent-events.html[Server-Sent Events]\n+by just annotating your endpoint method with \n+link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces(MediaType.SERVER_SENT_EVENTS)`]\n+and specifying that each element should be <<json,serialised to JSON>> with \n+`@RestSseElementType(MediaType.APPLICATION_JSON)`.\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.jboss.resteasy.reactive.RestSseElementType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import io.smallrye.reactive.messaging.annotations.Channel;\n+\n+@Path(\"escoffier\")\n+public class Endpoint {\n+\n+    // Inject our Book channel\n+    @Inject\n+    @Channel(\"book-out\")\n+    Multi<Book> books;\n+\n+    @GET\n+    // Send the stream over SSE\n+    @Produces(MediaType.SERVER_SENT_EVENTS)\n+    // Each element will be sent as JSON\n+    @RestSseElementType(MediaType.APPLICATION_JSON)\n+    public Multi<Book> stream() {\n+        return books;\n+    }\n+}\n+----\n+\n+=== Accessing context objects\n+\n+[[context-objects]]\n+\n+There are a number of contextual objects that the framework will give you, if your endpoint\n+method takes parameters of the following type:\n+\n+.Table Context object\n+|===\n+|Type|Usage\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/HttpHeaders.html[`HttpHeaders`]\n+|All the request headers\n+\n+|link:{jaxrsapi}/javax/ws/rs/container/ResourceInfo.html[`ResourceInfo`]\n+|Information about the current endpoint method and class (requires reflection)\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/SecurityContext.html[`SecurityContext`]\n+|Access to the current user and roles\n+\n+|`SimpleResourceInfo`\n+|Information about the current endpoint method and class (no reflection required)\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/UriInfo.html[`UriInfo`]\n+|Provides information about the current endpoint and application URI\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Application.html[`Application`]\n+|Advanced: Current JAX-RS application class\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Configuration.html[`Configuration`]\n+|Advanced: Configuration about the deployed JAX-RS application\n+\n+|link:{jaxrsapi}/javax/ws/rs/ext/Providers.html[`Providers`]\n+|Advanced: Runtime access to JAX-RS providers\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Request.html[`Request`]\n+|Advanced: Access to the current HTTP method and <<preconditions>>\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/ResourceContext.html[`ResourceContext`]\n+|Advanced: access to instances of endpoints\n+\n+|`ServerRequestContext`\n+|Advanced: RESTEasy Reactive access to the current request/response\n+\n+|link:{jaxrsapi}/javax/ws/rs/sse/Sse.html[`Sse`]\n+|Advanced: Complex SSE use-cases\n+\n+|===\n+\n+For example, here is how you can return the name of the currently logged-in user:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.security.Principal;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.SecurityContext;\n+\n+@Path(\"user\")\n+public class Endpoint {\n+\n+    @GET\n+    public String userName(SecurityContext security) {\n+        Principal user = security.getUserPrincipal();\n+        return user != null ? user.getName() : \"<NOT LOGGED IN>\";\n+    }\n+}\n+----\n+\n+You can also inject those context objects using \n+https://javadoc.io/static/javax.inject/javax.inject/1/javax/inject/Inject.html[`@Inject`] on fields of the same\n+type.\n+\n+=== JSON serialisation\n+\n+[[json]]\n+\n+You can import either of the following modules to get support for JSON:\n+\n+.Table Context object\n+|===\n+|GAV|Usage\n+\n+|`io.quarkus:quarkus-resteasy-jackson`\n+|https://github.com/FasterXML/jackson[Jackson support]\n+\n+|`io.quarkus:quarkus-resteasy-jsonb`\n+|http://json-b.net/[JSONB support]\n+\n+|===\n+\n+In both cases, importing those modules will allow HTTP message bodies to be read from JSON\n+and serialised to JSON, for <<resource-types,all the types not already registered with a more specific\n+serialisation>>.\n+\n+== More advanced usage\n+\n+Here are some more advanced topics that you may not need to know about initially, but\n+could prove useful for more complex use-cases.\n+\n+=== Execution model, blocking, non-blocking\n+\n+[[execution-model]]\n+\n+RESTEasy Reactive is implemented using two main thread types:\n+\n+- IO threads: which are responsible for reading bytes from the HTTP request and\n+ writing bytes back to the HTTP response\n+- Worker threads: they are pooled and can be used to offload long-running operations\n+\n+The IO threads (often called the \"event loop\") are responsible for actually performing all the IO\n+operations in an asynchronous way, and to trigger any listener interested in the completion of those\n+IO operations.\n+\n+By default, RESTEasy Reactive will run endpoint methods on the IO threads, on the assumption that\n+they are going to be fast and only invoke non-blocking operations.\n+\n+This is the model of execution that leads to best performance if your endpoints do not do any blocking\n+operation (such as blocking IO, blocking on an asynchronous operation, or sleeping).\n+\n+If your endpoint method needs to do any of those blocking operations, you should add the \n+https://javadoc.io/doc/io.smallrye.common/smallrye-common-annotation/1.5.0/io/smallrye/common/annotation/Blocking.html[`@Blocking`]\n+annotation on your endpoint and it will instead be invoked on a worker thread. Your endpoint method\n+code can remain exactly the same, and it will be allowed to block:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.common.annotation.Blocking;\n+\n+@Path(\"yawn\")\n+public class Endpoint {\n+\n+    @Blocking\n+    @GET\n+    public String blockingHello() throws InterruptedException {\n+        // do a blocking operation\n+        Thread.sleep(1000);\n+        return \"Yaaaawwwwnnnnnn\u2026\";\n+    }\n+}\n+----\n+\n+Most of the time, there are ways to achieve the same blocking operations in an asynchronous/reactive\n+way, using https://smallrye.io/smallrye-mutiny/[Mutiny], http://hibernate.org/reactive/[Hibernate Reactive] \n+or any of the link:getting-started-reactive[Quarkus Reactive extensions] for example:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.time.Duration;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"yawn\")\n+public class Endpoint {\n+\n+    @GET\n+    public Uni<String> blockingHello() throws InterruptedException {\n+        return Uni.createFrom().item(\"Yaaaawwwwnnnnnn\u2026\")\n+                // do a non-blocking sleep\n+                .onItem().delayIt().by(Duration.ofSeconds(2));\n+    }\n+}\n+----\n+\n+=== Exception mapping\n+\n+If your application needs to return non-nominal HTTP codes in error cases, the best is\n+to throw exceptions that will result in the proper HTTP response being sent by the\n+framework using link:{jaxrsapi}/javax/ws/rs/WebApplicationException.html[`WebApplicationException`] or any of its subtypes:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.BadRequestException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.Path;\n+\n+@Path(\"fromages/{fromage}\")\n+public class Endpoint {\n+\n+    @GET\n+    public String findFromage(String fromage) {\n+        if(fromage == null)\n+            // send a 400\n+            throw new BadRequestException();\n+        if(!fromage.equals(\"camembert\"))\n+            // send a 404\n+            throw new NotFoundException(\"Unknown cheese: \" + fromage);\n+        return \"Camembert is a very nice cheese\";\n+    }\n+}\n+----\n+\n+If your endpoint method is delegating calls to another service layer which\n+does not know of JAX-RS, you need a way to turn service exceptions to an\n+HTTP response, and you can do that using the `@ServerExceptionMapper` annotation\n+on a method, with one parameter of the exception type you want to handle, and turning\n+that exception into a link:{jaxrsapi}/javax/ws/rs/core/Response.html[`Response`] (or a \n+link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni<Response>`]):\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.util.Map;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.ws.rs.BadRequestException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.resteasy.reactive.server.ServerExceptionMapper;\n+\n+class UnknownCheeseException extends RuntimeException {\n+    public final String name;\n+    \n+    public UnknownCheeseException(String name) {\n+        this.name = name;\n+    }\n+}\n+\n+@ApplicationScoped\n+class CheeseService {\n+    private static final Map<String, String> cheeses = \n+            Map.of(\"camembert\", \"Camembert is a very nice cheese\",\n+                   \"gouda\", \"Gouda is acceptable too, especially with cumin\");\n+\n+    public String findCheese(String name) {\n+        String ret = cheeses.get(name);\n+        if(ret != null)\n+            return ret;\n+        throw new UnknownCheeseException(name);\n+    }\n+}\n+\n+@Path(\"fromages/{fromage}\")\n+public class Endpoint {\n+\n+    @Inject\n+    CheeseService cheeses;\n+    \n+    @ServerExceptionMapper\n+    public Response mapException(UnknownCheeseException x) {\n+        return Response.status(Response.Status.NOT_FOUND)\n+                       .entity(\"Unknown cheese: \" + x.name)\n+                       .build();\n+    }\n+    \n+    @GET\n+    public String findFromage(String fromage) {\n+        if(fromage == null)\n+            // send a 400\n+            throw new BadRequestException();\n+        return cheeses.findCheese(fromage);\n+    }\n+} \n+----\n+\n+NOTE: exception mappers defined in REST endpoint classes will only be called if the\n+exception is thrown in the same class. If you want to define global exception mappers,\n+simply define them outside a REST endpoint class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.resteasy.reactive.server.ServerExceptionMapper;\n+\n+class ExceptionMappers {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cde4943aec547bfcd64b41b939f2b5d2c3a0b77"}, "originalPosition": 838}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI4NTc5Ng==", "bodyText": "How about we convert this to constructor injection? We haven't really shown that:\n// no @Inject needed\npublic Endpoint(CheeseService cheeseService) {\n\n}", "url": "https://github.com/quarkusio/quarkus/pull/13802#discussion_r540285796", "createdAt": "2020-12-10T15:57:55Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/rest-reactive.adoc", "diffHunk": "@@ -0,0 +1,1553 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Writing REST Services with RESTEasy Reactive\n+\n+include::./attributes.adoc[]\n+:jaxrsapi: https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1\n+:jaxrsspec: /specs/jaxrs/2.1/index.html\n+:jdkapi: https://docs.oracle.com/en/java/javase/11/docs/api/java.base\n+:mutinyapi: https://smallrye.io/smallrye-mutiny/apidocs\n+:httpspec: https://tools.ietf.org/html/rfc7231\n+:jsonpapi: https://javadoc.io/doc/javax.json/javax.json-api/1.1.4\n+:vertxapi: https://javadoc.io/static/io.vertx/vertx-core/3.9.4\n+\n+This guide explains how to write REST Services with RESTEasy Reactive\n+\n+TODO: buff this\n+\n+TODO: links to our javadoc\n+\n+== What is RESTEasy Reactive?\n+\n+RESTEasy Reactive is a new link:{jaxrsspec}[JAX-RS]\n+implementation written from the ground up to work on our\n+common https://vertx.io/[Vert.x] layer and is thus fully reactive, while also being very tightly integrated with\n+Quarkus and consequently moving a lot of work to build time.\n+\n+You should be able to use it in place of any JAX-RS implementation, but on top of that it has\n+great performance for both blocking and non-blocking endpoints, and a lot of new features on top\n+of what JAX-RS provides.\n+\n+== Writing endpoints\n+\n+=== Getting started\n+\n+Add the following import to your `pom.xml` file:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-resteasy-reactive</artifactId>\n+</dependency>\n+----\n+\n+You can now write your first endpoint in the `org.acme.rest.Endpoint` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+=== Terminology\n+\n+REST:: https://en.wikipedia.org/wiki/Representational_state_transfer[REpresentational State Transfer]\n+Endpoint:: Java method which is called to serve a REST call\n+URL / URI (Uniform Resource Locator / Identifier):: Used to identify the location of REST resources (https://tools.ietf.org/html/rfc7230#section-2.7[specification])\n+Resource:: Represents your domain object. This is what your API serves and modifies. Also called an `entity` in JAX-RS.\n+Representation:: How your resource is represented on the wire, can vary depending on content types\n+Content type:: Designates a particular representation (also called a media type), for example `text/plain` or `application/json`\n+HTTP:: Underlying wire protocol for routing REST calls (see https://tools.ietf.org/html/rfc7230[HTTP specifications])\n+HTTP request:: the request part of the HTTP call, consisting of an HTTP method, a target URI, headers and an optional message body\n+HTTP response:: the response part of the HTTP call, consisting of an HTTP response status, headers and an optional message body\n+\n+=== Declaring endpoints: URI mapping\n+\n+Any class annotated with a link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation can have its methods exposed as REST endpoints,\n+provided they have an HTTP method annotation (see below).\n+\n+That link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation defines the URI prefix under which those methods will be exposed. It can\n+be empty, or contain a prefix such as `rest` or `rest/V1`.\n+\n+Each exposed endpoint method can in turn have another link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation which adds to its containing\n+class annotation. For example, this defines a `rest/hello` endpoint:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"rest\")\n+public class Endpoint {\n+\n+    @Path(\"hello\")\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+See <<uri-parameters,URI parameters>> for more information about URI mapping.\n+\n+=== Declaring endpoints: HTTP methods\n+\n+Each endpoint method must be annotated with one of the following annotations, which defines which HTTP\n+method will be mapped to the method:\n+\n+.Table HTTP method annotations\n+|===\n+|Annotation|Usage \n+\n+|link:{jaxrsapi}/javax/ws/rs/GET.html[`@GET`]\n+|Obtain a resource representation, should not modify state, idempotent (link:{httpspec}#section-4.3.1[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/HEAD.html[`@HEAD`]\n+|Obtain metadata about a resource, similar to `GET` with no body (link:{httpspec}#section-4.3.2[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/POST.html[`@POST`]\n+|Create a resource and obtain a link to it (link:{httpspec}#section-4.3.3[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PUT.html[`@PUT`]\n+|Replace a resource or create one, should be idempotent (link:{httpspec}#section-4.3.4[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/DELETE.html[`@DELETE`]\n+|Delete an existing resource, idempotent  (link:{httpspec}#section-4.3.5[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/OPTIONS.html[`@OPTIONS`]\n+|Obtain information about a resource, idempotent (link:{httpspec}#section-4.3.7[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PATCH.html[`@PATCH`]\n+|Update a resource, or create one, not idempotent (https://tools.ietf.org/html/rfc5789#section-2[HTTP docs])\n+\n+|===\n+\n+You can also declare other HTTP methods by declaring them as an annotation with the\n+link:{jaxrsapi}/javax/ws/rs/HttpMethod.html[`@HttpMethod`] annotation:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+import javax.ws.rs.HttpMethod;\n+import javax.ws.rs.Path;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@HttpMethod(\"FROMAGE\")\n+@interface FROMAGE {\n+}\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @FROMAGE\n+    public String hello(){\n+        return \"Hello, Cheese World!\";\n+    }\n+}\n+----\n+\n+=== Declaring endpoints: representation / content types\n+\n+Each endpoint method may consume or produce specific resource representations, which are indicated by\n+the HTTP link:{httpspec}#section-3.1.1.5[`Content-Type`] header, which in turn contains \n+link:{httpspec}#section-3.1.1.1[MIME (Media Type)] values, such as the following:\n+\n+- `text/plain` which is the default for any endpoint returning a `String`.\n+- `text/html` for HTML (such as with link:qute[Qute templating])\n+- `application/json` for a <<json,JSON REST endpoint>>\n+- `text/*` which is a sub-type wildcard for any text media type\n+- `*/*` which is a wildcard for any media type\n+\n+You may annotate your endpoint class with the link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces`] \n+or link:{jaxrsapi}/javax/ws/rs/Consumes.html[`@Consumes`] annotations, which\n+allow you to specify one or more media types that your endpoint may accept as HTTP request body\n+or produce as HTTP response body. Those class annotations apply to each method.\n+\n+Any method may also be annotated with the link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces`] \n+or link:{jaxrsapi}/javax/ws/rs/Consumes.html[`@Consumes`] annotations, in which\n+case they override any eventual class annotation.\n+\n+The link:{jaxrsapi}/javax/ws/rs/core/MediaType.html[`MediaType`] class has many constants you\n+can use to point to specific pre-defined media types.\n+\n+See <<negotiation>> for more information.\n+\n+=== Accessing request parameters\n+\n+[[request-parameters]]\n+\n+NOTE: don't forget to configure your compiler to generate parameter name information with `-parameters` (javac)\n+or `<parameters>` or `<maven.compiler.parameters>` (https://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#parameters[Maven]).\n+\n+The following HTTP request elements may be obtained by your endpoint method:\n+\n+.Table HTTP request parameter annotations\n+|===\n+|HTTP element|Annotation|Usage \n+\n+|[[path-parameter]]Path parameter\n+|`@RestPath` (or nothing)\n+|URI template parameter (simplified version of the https://tools.ietf.org/html/rfc6570[URI Template specification]), \n+see <<uri-parameters,URI parameters>> for more information.\n+\n+|Query parameter\n+|`@RestQuery`\n+|The value of an https://tools.ietf.org/html/rfc3986#section-3.4[URI query parameter]\n+\n+|Header\n+|`@RestHeader`\n+|The value of an https://tools.ietf.org/html/rfc7230#section-3.2[HTTP header]\n+\n+|Cookie\n+|`@RestCookie`\n+|The value of an https://tools.ietf.org/html/rfc6265#section-4.2[HTTP cookie]\n+\n+|Form parameter\n+|`@RestForm`\n+|The value of an https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST[HTTP URL-encoded FORM]\n+\n+|Matrix parameter\n+|`@RestMatrix`\n+|The value of an https://tools.ietf.org/html/rfc3986#section-3.3[URI path segment parameter]\n+\n+|===\n+\n+For each of those annotations, you may specify the name of the element they refer to, otherwise\n+they will use the name of the annotated method parameter.\n+\n+If a client made the following HTTP call:\n+\n+[source,http]\n+----\n+POST /cheeses;variant=goat/tomme?age=matured HTTP/1.1\n+Content-Type: application/x-www-form-urlencoded\n+Cookie: level=hardcore\n+X-Cheese-Secret-Handshake: fist-bump\n+\n+smell=strong\n+----\n+\n+Then you could obtain all the various parameters with this endpoint method:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+\n+import org.jboss.resteasy.reactive.RestCookie;\n+import org.jboss.resteasy.reactive.RestForm;\n+import org.jboss.resteasy.reactive.RestHeader;\n+import org.jboss.resteasy.reactive.RestMatrix;\n+import org.jboss.resteasy.reactive.RestPath;\n+import org.jboss.resteasy.reactive.RestQuery;\n+\n+@Path(\"/cheeses/{type}\")\n+public class Endpoint {\n+\n+    @POST\n+    public String allParams(@RestPath String type,\n+                            @RestMatrix String variant,\n+                            @RestQuery String age,\n+                            @RestCookie String level,\n+                            @RestHeader(\"X-Cheese-Secret-Handshake\")\n+                            String secretHandshake,\n+                            @RestForm String smell){\n+        return type + \"/\" + variant + \"/\" + age + \"/\" + level + \"/\" + secretHandshake + \"/\" + smell;\n+    }\n+}\n+----\n+\n+NOTE: the `@RestPath` annotation is optional: any parameter whose name matches an existing URI\n+template variable will be automatically assumed to have `@RestPath`.\n+\n+Naturally you can also use any of the JAX-RS annotations link:{jaxrsapi}/javax/ws/rs/PathParam.html[`@PathParam`],\n+link:{jaxrsapi}/javax/ws/rs/QueryParam.html[`@QueryParam`],\n+link:{jaxrsapi}/javax/ws/rs/HeaderParam.html[`@HeaderParam`],\n+link:{jaxrsapi}/javax/ws/rs/CookieParam.html[`@CookieParam`],\n+link:{jaxrsapi}/javax/ws/rs/FormParam.html[`@FormParam`] or\n+link:{jaxrsapi}/javax/ws/rs/MatrixParam.html[`@MatrixParam`] for this,\n+but they require you to specify the parameter name.\n+\n+See <<parameter-mapping>> for more advanced use-cases.\n+\n+=== Declaring URI parameters\n+\n+[[uri-parameters]]\n+\n+You can declare URI parameters and use regular expressions in your path, so for instance\n+the following endpoint will serve requests for `/hello/stef/23` and `/hello` but not\n+`/hello/stef/0x23`:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"hello\")\n+public class Endpoint {\n+\n+    @Path(\"{name}/{age:\\\\d+}\")\n+    @GET\n+    public String personalisedHello(String name, int age){\n+        return \"Hello \" + name + \" is your age really \" + age + \"?\";\n+    }\n+\n+    @GET\n+    public String genericHello(){\n+        return \"Hello stranger\";\n+    }\n+}\n+----\n+\n+\n+=== Accessing the request body\n+\n+Any method parameter with no annotation will receive the method body.footnote:[Unless it is a\n+<<path-parameter,URI template parameter>> or a <<context-objects,context object>>.], after it has been mapped from\n+its HTTP representation to the Java type of the parameter.\n+\n+The following parameter types will be supported out of the box:\n+\n+[[resource-types]]\n+\n+.Table Request body parameter type\n+|===\n+|Type|Usage\n+\n+|link:{jdkapi}/java/io/File.html[`File`]\n+|The entire request body in a temporary file\n+\n+|`byte[]`\n+|The entire request body, not decoded\n+\n+|`char[]`\n+|The entire request body, decoded\n+\n+|link:{jdkapi}/java/lang/String.html[`String`]\n+|The entire request body, decoded\n+\n+|link:{jdkapi}/java/io/InputStream.html[`InputStream`]\n+|The request body in a blocking stream\n+\n+|link:{jdkapi}/java/io/Reader.html[`Reader`]\n+|The request body in a blocking stream\n+\n+|All Java primitives and their wrapper classes\n+|Java primitive types\n+\n+|link:{jdkapi}/java/math/BigDecimal.html[`BigDecimal`], link:{jdkapi}/java/math/BigInteger.html[`BigInteger`]\n+|Large integers and decimals.\n+\n+|link:{jsonpapi}/javax/json/JsonArray.html[`JsonArray`], link:{jsonpapi}/javax/json/JsonArray.html[`JsonObject`],\n+link:{jsonpapi}/javax/json/JsonArray.html[`JsonStructure`], link:{jsonpapi}/javax/json/JsonArray.html[`JsonValue`]\n+|JSON value types  \n+\n+|link:{vertxapi}io/vertx/core/buffer/Buffer.html[`Buffer`]\n+|Vert.x Buffer \n+\n+|any other type\n+|Will be <<json,mapped from JSON to that type>>\n+\n+|===\n+\n+NOTE: You can add support for more <<readers-writers,body parameter types>>.\n+\n+=== Returning a response body\n+\n+In order to return an HTTP response, simply return the resource you want from your method. The method\n+return type and its optional content type will be used to decide how to serialise it to the HTTP\n+response (see <<negotiation>> for more advanced information).\n+\n+You can return any of the pre-defined types that you can read from the <<resource-types,HTTP response>>,\n+and any other type will be mapped <<json,from that type to JSON>>.\n+\n+Alternately, you can also return a <<reactive,reactive type>> such as link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`], \n+link:{mutinyapi}/io/smallrye/mutiny/Multi.html[`Multi`] or \n+link:{jdkapi}/java/util/concurrent/CompletionStage.html[`CompletionStage`]\n+that resolve to one of the mentioned return types.\n+\n+=== Setting other response properties\n+\n+If you need to set more properties on the HTTP response than just the body, such as the status code\n+or headers, you can make your method return the link:{jaxrsapi}/javax/ws/rs/core/Response.html[`Response`]\n+type:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.NewCookie;\n+import javax.ws.rs.core.Response;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public Response hello() {\n+        // HTTP OK status with text/plain content type\n+        return Response.ok(\"Hello, World!\", MediaType.TEXT_PLAIN_TYPE)\n+         // set a response header\n+         .header(\"X-FroMage\", \"Camembert\")\n+         // set the Expires response header to two days from now\n+         .expires(Date.from(Instant.now().plus(Duration.ofDays(2))))\n+         // send a new cookie\n+         .cookie(new NewCookie(\"Flavour\", \"pralin\u00e9\"))\n+         // end of builder API\n+         .build();\n+    }\n+}\n+----\n+\n+=== Async/reactive support\n+\n+[[reactive]]\n+\n+If your endpoint method needs to accomplish an asynchronous or reactive task before\n+being able to answer, you can declare your method to return the \n+link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`] type (from https://smallrye.io/smallrye-mutiny/[Mutiny]), in which\n+case the current HTTP request will be automatically suspended after your method, until\n+the returned link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`] instance resolves to a value,\n+which will be mapped to a response exactly according to the previously described rules:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"escoffier\")\n+public class Endpoint {\n+\n+    @GET\n+    public Uni<Book> culinaryGuide(){\n+        return Book.findByIsbn(\"978-2081229297\");\n+    }\n+}\n+----\n+\n+This allows you to not block the IO thread while the book is being fetched from the\n+database, and allows Quarkus to serve more requests until your book is ready to\n+be sent to the client and terminate this request. Check out our \n+<<execution-model,Execution Model documentation>> for more information.\n+\n+The link:{jdkapi}/java/util/concurrent/CompletionStage.html[`CompletionStage`] return\n+type is also supported.\n+\n+=== Streaming support\n+\n+If you want to stream your response element by element, you can make your endpoint method return a \n+link:{mutinyapi}/io/smallrye/mutiny/Multi.html[`Multi`] type (from https://smallrye.io/smallrye-mutiny/[Mutiny]).\n+This is especially useful for streaming text or binary data.\n+\n+This example, using link:reactive-messaging-http.html[Reactive Messaging] shows how to stream\n+text data:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import org.eclipse.microprofile.reactive.messaging.Channel;\n+\n+import io.smallrye.mutiny.Multi;\n+\n+@Path(\"logs\")\n+public class Endpoint {\n+\n+    @Inject\n+    @Channel(\"log-out\")\n+    Multi<String> logs;\n+\n+    @GET\n+    public Multi<String> streamLogs() {\n+        return logs;\n+    }\n+}\n+----\n+\n+=== Server-Sent Event (SSE) support\n+\n+If you want to stream JSON objects in your response, you can use \n+https://html.spec.whatwg.org/multipage/server-sent-events.html[Server-Sent Events]\n+by just annotating your endpoint method with \n+link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces(MediaType.SERVER_SENT_EVENTS)`]\n+and specifying that each element should be <<json,serialised to JSON>> with \n+`@RestSseElementType(MediaType.APPLICATION_JSON)`.\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.jboss.resteasy.reactive.RestSseElementType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import io.smallrye.reactive.messaging.annotations.Channel;\n+\n+@Path(\"escoffier\")\n+public class Endpoint {\n+\n+    // Inject our Book channel\n+    @Inject\n+    @Channel(\"book-out\")\n+    Multi<Book> books;\n+\n+    @GET\n+    // Send the stream over SSE\n+    @Produces(MediaType.SERVER_SENT_EVENTS)\n+    // Each element will be sent as JSON\n+    @RestSseElementType(MediaType.APPLICATION_JSON)\n+    public Multi<Book> stream() {\n+        return books;\n+    }\n+}\n+----\n+\n+=== Accessing context objects\n+\n+[[context-objects]]\n+\n+There are a number of contextual objects that the framework will give you, if your endpoint\n+method takes parameters of the following type:\n+\n+.Table Context object\n+|===\n+|Type|Usage\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/HttpHeaders.html[`HttpHeaders`]\n+|All the request headers\n+\n+|link:{jaxrsapi}/javax/ws/rs/container/ResourceInfo.html[`ResourceInfo`]\n+|Information about the current endpoint method and class (requires reflection)\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/SecurityContext.html[`SecurityContext`]\n+|Access to the current user and roles\n+\n+|`SimpleResourceInfo`\n+|Information about the current endpoint method and class (no reflection required)\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/UriInfo.html[`UriInfo`]\n+|Provides information about the current endpoint and application URI\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Application.html[`Application`]\n+|Advanced: Current JAX-RS application class\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Configuration.html[`Configuration`]\n+|Advanced: Configuration about the deployed JAX-RS application\n+\n+|link:{jaxrsapi}/javax/ws/rs/ext/Providers.html[`Providers`]\n+|Advanced: Runtime access to JAX-RS providers\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Request.html[`Request`]\n+|Advanced: Access to the current HTTP method and <<preconditions>>\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/ResourceContext.html[`ResourceContext`]\n+|Advanced: access to instances of endpoints\n+\n+|`ServerRequestContext`\n+|Advanced: RESTEasy Reactive access to the current request/response\n+\n+|link:{jaxrsapi}/javax/ws/rs/sse/Sse.html[`Sse`]\n+|Advanced: Complex SSE use-cases\n+\n+|===\n+\n+For example, here is how you can return the name of the currently logged-in user:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.security.Principal;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.SecurityContext;\n+\n+@Path(\"user\")\n+public class Endpoint {\n+\n+    @GET\n+    public String userName(SecurityContext security) {\n+        Principal user = security.getUserPrincipal();\n+        return user != null ? user.getName() : \"<NOT LOGGED IN>\";\n+    }\n+}\n+----\n+\n+You can also inject those context objects using \n+https://javadoc.io/static/javax.inject/javax.inject/1/javax/inject/Inject.html[`@Inject`] on fields of the same\n+type.\n+\n+=== JSON serialisation\n+\n+[[json]]\n+\n+You can import either of the following modules to get support for JSON:\n+\n+.Table Context object\n+|===\n+|GAV|Usage\n+\n+|`io.quarkus:quarkus-resteasy-jackson`\n+|https://github.com/FasterXML/jackson[Jackson support]\n+\n+|`io.quarkus:quarkus-resteasy-jsonb`\n+|http://json-b.net/[JSONB support]\n+\n+|===\n+\n+In both cases, importing those modules will allow HTTP message bodies to be read from JSON\n+and serialised to JSON, for <<resource-types,all the types not already registered with a more specific\n+serialisation>>.\n+\n+== More advanced usage\n+\n+Here are some more advanced topics that you may not need to know about initially, but\n+could prove useful for more complex use-cases.\n+\n+=== Execution model, blocking, non-blocking\n+\n+[[execution-model]]\n+\n+RESTEasy Reactive is implemented using two main thread types:\n+\n+- IO threads: which are responsible for reading bytes from the HTTP request and\n+ writing bytes back to the HTTP response\n+- Worker threads: they are pooled and can be used to offload long-running operations\n+\n+The IO threads (often called the \"event loop\") are responsible for actually performing all the IO\n+operations in an asynchronous way, and to trigger any listener interested in the completion of those\n+IO operations.\n+\n+By default, RESTEasy Reactive will run endpoint methods on the IO threads, on the assumption that\n+they are going to be fast and only invoke non-blocking operations.\n+\n+This is the model of execution that leads to best performance if your endpoints do not do any blocking\n+operation (such as blocking IO, blocking on an asynchronous operation, or sleeping).\n+\n+If your endpoint method needs to do any of those blocking operations, you should add the \n+https://javadoc.io/doc/io.smallrye.common/smallrye-common-annotation/1.5.0/io/smallrye/common/annotation/Blocking.html[`@Blocking`]\n+annotation on your endpoint and it will instead be invoked on a worker thread. Your endpoint method\n+code can remain exactly the same, and it will be allowed to block:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.common.annotation.Blocking;\n+\n+@Path(\"yawn\")\n+public class Endpoint {\n+\n+    @Blocking\n+    @GET\n+    public String blockingHello() throws InterruptedException {\n+        // do a blocking operation\n+        Thread.sleep(1000);\n+        return \"Yaaaawwwwnnnnnn\u2026\";\n+    }\n+}\n+----\n+\n+Most of the time, there are ways to achieve the same blocking operations in an asynchronous/reactive\n+way, using https://smallrye.io/smallrye-mutiny/[Mutiny], http://hibernate.org/reactive/[Hibernate Reactive] \n+or any of the link:getting-started-reactive[Quarkus Reactive extensions] for example:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.time.Duration;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"yawn\")\n+public class Endpoint {\n+\n+    @GET\n+    public Uni<String> blockingHello() throws InterruptedException {\n+        return Uni.createFrom().item(\"Yaaaawwwwnnnnnn\u2026\")\n+                // do a non-blocking sleep\n+                .onItem().delayIt().by(Duration.ofSeconds(2));\n+    }\n+}\n+----\n+\n+=== Exception mapping\n+\n+If your application needs to return non-nominal HTTP codes in error cases, the best is\n+to throw exceptions that will result in the proper HTTP response being sent by the\n+framework using link:{jaxrsapi}/javax/ws/rs/WebApplicationException.html[`WebApplicationException`] or any of its subtypes:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.BadRequestException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.Path;\n+\n+@Path(\"fromages/{fromage}\")\n+public class Endpoint {\n+\n+    @GET\n+    public String findFromage(String fromage) {\n+        if(fromage == null)\n+            // send a 400\n+            throw new BadRequestException();\n+        if(!fromage.equals(\"camembert\"))\n+            // send a 404\n+            throw new NotFoundException(\"Unknown cheese: \" + fromage);\n+        return \"Camembert is a very nice cheese\";\n+    }\n+}\n+----\n+\n+If your endpoint method is delegating calls to another service layer which\n+does not know of JAX-RS, you need a way to turn service exceptions to an\n+HTTP response, and you can do that using the `@ServerExceptionMapper` annotation\n+on a method, with one parameter of the exception type you want to handle, and turning\n+that exception into a link:{jaxrsapi}/javax/ws/rs/core/Response.html[`Response`] (or a \n+link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni<Response>`]):\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.util.Map;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.ws.rs.BadRequestException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.resteasy.reactive.server.ServerExceptionMapper;\n+\n+class UnknownCheeseException extends RuntimeException {\n+    public final String name;\n+    \n+    public UnknownCheeseException(String name) {\n+        this.name = name;\n+    }\n+}\n+\n+@ApplicationScoped\n+class CheeseService {\n+    private static final Map<String, String> cheeses = \n+            Map.of(\"camembert\", \"Camembert is a very nice cheese\",\n+                   \"gouda\", \"Gouda is acceptable too, especially with cumin\");\n+\n+    public String findCheese(String name) {\n+        String ret = cheeses.get(name);\n+        if(ret != null)\n+            return ret;\n+        throw new UnknownCheeseException(name);\n+    }\n+}\n+\n+@Path(\"fromages/{fromage}\")\n+public class Endpoint {\n+\n+    @Inject\n+    CheeseService cheeses;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cde4943aec547bfcd64b41b939f2b5d2c3a0b77"}, "originalPosition": 807}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI4Nzk3NA==", "bodyText": "Public here too", "url": "https://github.com/quarkusio/quarkus/pull/13802#discussion_r540287974", "createdAt": "2020-12-10T16:00:38Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/rest-reactive.adoc", "diffHunk": "@@ -0,0 +1,1553 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Writing REST Services with RESTEasy Reactive\n+\n+include::./attributes.adoc[]\n+:jaxrsapi: https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1\n+:jaxrsspec: /specs/jaxrs/2.1/index.html\n+:jdkapi: https://docs.oracle.com/en/java/javase/11/docs/api/java.base\n+:mutinyapi: https://smallrye.io/smallrye-mutiny/apidocs\n+:httpspec: https://tools.ietf.org/html/rfc7231\n+:jsonpapi: https://javadoc.io/doc/javax.json/javax.json-api/1.1.4\n+:vertxapi: https://javadoc.io/static/io.vertx/vertx-core/3.9.4\n+\n+This guide explains how to write REST Services with RESTEasy Reactive\n+\n+TODO: buff this\n+\n+TODO: links to our javadoc\n+\n+== What is RESTEasy Reactive?\n+\n+RESTEasy Reactive is a new link:{jaxrsspec}[JAX-RS]\n+implementation written from the ground up to work on our\n+common https://vertx.io/[Vert.x] layer and is thus fully reactive, while also being very tightly integrated with\n+Quarkus and consequently moving a lot of work to build time.\n+\n+You should be able to use it in place of any JAX-RS implementation, but on top of that it has\n+great performance for both blocking and non-blocking endpoints, and a lot of new features on top\n+of what JAX-RS provides.\n+\n+== Writing endpoints\n+\n+=== Getting started\n+\n+Add the following import to your `pom.xml` file:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-resteasy-reactive</artifactId>\n+</dependency>\n+----\n+\n+You can now write your first endpoint in the `org.acme.rest.Endpoint` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+=== Terminology\n+\n+REST:: https://en.wikipedia.org/wiki/Representational_state_transfer[REpresentational State Transfer]\n+Endpoint:: Java method which is called to serve a REST call\n+URL / URI (Uniform Resource Locator / Identifier):: Used to identify the location of REST resources (https://tools.ietf.org/html/rfc7230#section-2.7[specification])\n+Resource:: Represents your domain object. This is what your API serves and modifies. Also called an `entity` in JAX-RS.\n+Representation:: How your resource is represented on the wire, can vary depending on content types\n+Content type:: Designates a particular representation (also called a media type), for example `text/plain` or `application/json`\n+HTTP:: Underlying wire protocol for routing REST calls (see https://tools.ietf.org/html/rfc7230[HTTP specifications])\n+HTTP request:: the request part of the HTTP call, consisting of an HTTP method, a target URI, headers and an optional message body\n+HTTP response:: the response part of the HTTP call, consisting of an HTTP response status, headers and an optional message body\n+\n+=== Declaring endpoints: URI mapping\n+\n+Any class annotated with a link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation can have its methods exposed as REST endpoints,\n+provided they have an HTTP method annotation (see below).\n+\n+That link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation defines the URI prefix under which those methods will be exposed. It can\n+be empty, or contain a prefix such as `rest` or `rest/V1`.\n+\n+Each exposed endpoint method can in turn have another link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation which adds to its containing\n+class annotation. For example, this defines a `rest/hello` endpoint:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"rest\")\n+public class Endpoint {\n+\n+    @Path(\"hello\")\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+See <<uri-parameters,URI parameters>> for more information about URI mapping.\n+\n+=== Declaring endpoints: HTTP methods\n+\n+Each endpoint method must be annotated with one of the following annotations, which defines which HTTP\n+method will be mapped to the method:\n+\n+.Table HTTP method annotations\n+|===\n+|Annotation|Usage \n+\n+|link:{jaxrsapi}/javax/ws/rs/GET.html[`@GET`]\n+|Obtain a resource representation, should not modify state, idempotent (link:{httpspec}#section-4.3.1[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/HEAD.html[`@HEAD`]\n+|Obtain metadata about a resource, similar to `GET` with no body (link:{httpspec}#section-4.3.2[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/POST.html[`@POST`]\n+|Create a resource and obtain a link to it (link:{httpspec}#section-4.3.3[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PUT.html[`@PUT`]\n+|Replace a resource or create one, should be idempotent (link:{httpspec}#section-4.3.4[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/DELETE.html[`@DELETE`]\n+|Delete an existing resource, idempotent  (link:{httpspec}#section-4.3.5[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/OPTIONS.html[`@OPTIONS`]\n+|Obtain information about a resource, idempotent (link:{httpspec}#section-4.3.7[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PATCH.html[`@PATCH`]\n+|Update a resource, or create one, not idempotent (https://tools.ietf.org/html/rfc5789#section-2[HTTP docs])\n+\n+|===\n+\n+You can also declare other HTTP methods by declaring them as an annotation with the\n+link:{jaxrsapi}/javax/ws/rs/HttpMethod.html[`@HttpMethod`] annotation:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+import javax.ws.rs.HttpMethod;\n+import javax.ws.rs.Path;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@HttpMethod(\"FROMAGE\")\n+@interface FROMAGE {\n+}\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @FROMAGE\n+    public String hello(){\n+        return \"Hello, Cheese World!\";\n+    }\n+}\n+----\n+\n+=== Declaring endpoints: representation / content types\n+\n+Each endpoint method may consume or produce specific resource representations, which are indicated by\n+the HTTP link:{httpspec}#section-3.1.1.5[`Content-Type`] header, which in turn contains \n+link:{httpspec}#section-3.1.1.1[MIME (Media Type)] values, such as the following:\n+\n+- `text/plain` which is the default for any endpoint returning a `String`.\n+- `text/html` for HTML (such as with link:qute[Qute templating])\n+- `application/json` for a <<json,JSON REST endpoint>>\n+- `text/*` which is a sub-type wildcard for any text media type\n+- `*/*` which is a wildcard for any media type\n+\n+You may annotate your endpoint class with the link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces`] \n+or link:{jaxrsapi}/javax/ws/rs/Consumes.html[`@Consumes`] annotations, which\n+allow you to specify one or more media types that your endpoint may accept as HTTP request body\n+or produce as HTTP response body. Those class annotations apply to each method.\n+\n+Any method may also be annotated with the link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces`] \n+or link:{jaxrsapi}/javax/ws/rs/Consumes.html[`@Consumes`] annotations, in which\n+case they override any eventual class annotation.\n+\n+The link:{jaxrsapi}/javax/ws/rs/core/MediaType.html[`MediaType`] class has many constants you\n+can use to point to specific pre-defined media types.\n+\n+See <<negotiation>> for more information.\n+\n+=== Accessing request parameters\n+\n+[[request-parameters]]\n+\n+NOTE: don't forget to configure your compiler to generate parameter name information with `-parameters` (javac)\n+or `<parameters>` or `<maven.compiler.parameters>` (https://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#parameters[Maven]).\n+\n+The following HTTP request elements may be obtained by your endpoint method:\n+\n+.Table HTTP request parameter annotations\n+|===\n+|HTTP element|Annotation|Usage \n+\n+|[[path-parameter]]Path parameter\n+|`@RestPath` (or nothing)\n+|URI template parameter (simplified version of the https://tools.ietf.org/html/rfc6570[URI Template specification]), \n+see <<uri-parameters,URI parameters>> for more information.\n+\n+|Query parameter\n+|`@RestQuery`\n+|The value of an https://tools.ietf.org/html/rfc3986#section-3.4[URI query parameter]\n+\n+|Header\n+|`@RestHeader`\n+|The value of an https://tools.ietf.org/html/rfc7230#section-3.2[HTTP header]\n+\n+|Cookie\n+|`@RestCookie`\n+|The value of an https://tools.ietf.org/html/rfc6265#section-4.2[HTTP cookie]\n+\n+|Form parameter\n+|`@RestForm`\n+|The value of an https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST[HTTP URL-encoded FORM]\n+\n+|Matrix parameter\n+|`@RestMatrix`\n+|The value of an https://tools.ietf.org/html/rfc3986#section-3.3[URI path segment parameter]\n+\n+|===\n+\n+For each of those annotations, you may specify the name of the element they refer to, otherwise\n+they will use the name of the annotated method parameter.\n+\n+If a client made the following HTTP call:\n+\n+[source,http]\n+----\n+POST /cheeses;variant=goat/tomme?age=matured HTTP/1.1\n+Content-Type: application/x-www-form-urlencoded\n+Cookie: level=hardcore\n+X-Cheese-Secret-Handshake: fist-bump\n+\n+smell=strong\n+----\n+\n+Then you could obtain all the various parameters with this endpoint method:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+\n+import org.jboss.resteasy.reactive.RestCookie;\n+import org.jboss.resteasy.reactive.RestForm;\n+import org.jboss.resteasy.reactive.RestHeader;\n+import org.jboss.resteasy.reactive.RestMatrix;\n+import org.jboss.resteasy.reactive.RestPath;\n+import org.jboss.resteasy.reactive.RestQuery;\n+\n+@Path(\"/cheeses/{type}\")\n+public class Endpoint {\n+\n+    @POST\n+    public String allParams(@RestPath String type,\n+                            @RestMatrix String variant,\n+                            @RestQuery String age,\n+                            @RestCookie String level,\n+                            @RestHeader(\"X-Cheese-Secret-Handshake\")\n+                            String secretHandshake,\n+                            @RestForm String smell){\n+        return type + \"/\" + variant + \"/\" + age + \"/\" + level + \"/\" + secretHandshake + \"/\" + smell;\n+    }\n+}\n+----\n+\n+NOTE: the `@RestPath` annotation is optional: any parameter whose name matches an existing URI\n+template variable will be automatically assumed to have `@RestPath`.\n+\n+Naturally you can also use any of the JAX-RS annotations link:{jaxrsapi}/javax/ws/rs/PathParam.html[`@PathParam`],\n+link:{jaxrsapi}/javax/ws/rs/QueryParam.html[`@QueryParam`],\n+link:{jaxrsapi}/javax/ws/rs/HeaderParam.html[`@HeaderParam`],\n+link:{jaxrsapi}/javax/ws/rs/CookieParam.html[`@CookieParam`],\n+link:{jaxrsapi}/javax/ws/rs/FormParam.html[`@FormParam`] or\n+link:{jaxrsapi}/javax/ws/rs/MatrixParam.html[`@MatrixParam`] for this,\n+but they require you to specify the parameter name.\n+\n+See <<parameter-mapping>> for more advanced use-cases.\n+\n+=== Declaring URI parameters\n+\n+[[uri-parameters]]\n+\n+You can declare URI parameters and use regular expressions in your path, so for instance\n+the following endpoint will serve requests for `/hello/stef/23` and `/hello` but not\n+`/hello/stef/0x23`:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"hello\")\n+public class Endpoint {\n+\n+    @Path(\"{name}/{age:\\\\d+}\")\n+    @GET\n+    public String personalisedHello(String name, int age){\n+        return \"Hello \" + name + \" is your age really \" + age + \"?\";\n+    }\n+\n+    @GET\n+    public String genericHello(){\n+        return \"Hello stranger\";\n+    }\n+}\n+----\n+\n+\n+=== Accessing the request body\n+\n+Any method parameter with no annotation will receive the method body.footnote:[Unless it is a\n+<<path-parameter,URI template parameter>> or a <<context-objects,context object>>.], after it has been mapped from\n+its HTTP representation to the Java type of the parameter.\n+\n+The following parameter types will be supported out of the box:\n+\n+[[resource-types]]\n+\n+.Table Request body parameter type\n+|===\n+|Type|Usage\n+\n+|link:{jdkapi}/java/io/File.html[`File`]\n+|The entire request body in a temporary file\n+\n+|`byte[]`\n+|The entire request body, not decoded\n+\n+|`char[]`\n+|The entire request body, decoded\n+\n+|link:{jdkapi}/java/lang/String.html[`String`]\n+|The entire request body, decoded\n+\n+|link:{jdkapi}/java/io/InputStream.html[`InputStream`]\n+|The request body in a blocking stream\n+\n+|link:{jdkapi}/java/io/Reader.html[`Reader`]\n+|The request body in a blocking stream\n+\n+|All Java primitives and their wrapper classes\n+|Java primitive types\n+\n+|link:{jdkapi}/java/math/BigDecimal.html[`BigDecimal`], link:{jdkapi}/java/math/BigInteger.html[`BigInteger`]\n+|Large integers and decimals.\n+\n+|link:{jsonpapi}/javax/json/JsonArray.html[`JsonArray`], link:{jsonpapi}/javax/json/JsonArray.html[`JsonObject`],\n+link:{jsonpapi}/javax/json/JsonArray.html[`JsonStructure`], link:{jsonpapi}/javax/json/JsonArray.html[`JsonValue`]\n+|JSON value types  \n+\n+|link:{vertxapi}io/vertx/core/buffer/Buffer.html[`Buffer`]\n+|Vert.x Buffer \n+\n+|any other type\n+|Will be <<json,mapped from JSON to that type>>\n+\n+|===\n+\n+NOTE: You can add support for more <<readers-writers,body parameter types>>.\n+\n+=== Returning a response body\n+\n+In order to return an HTTP response, simply return the resource you want from your method. The method\n+return type and its optional content type will be used to decide how to serialise it to the HTTP\n+response (see <<negotiation>> for more advanced information).\n+\n+You can return any of the pre-defined types that you can read from the <<resource-types,HTTP response>>,\n+and any other type will be mapped <<json,from that type to JSON>>.\n+\n+Alternately, you can also return a <<reactive,reactive type>> such as link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`], \n+link:{mutinyapi}/io/smallrye/mutiny/Multi.html[`Multi`] or \n+link:{jdkapi}/java/util/concurrent/CompletionStage.html[`CompletionStage`]\n+that resolve to one of the mentioned return types.\n+\n+=== Setting other response properties\n+\n+If you need to set more properties on the HTTP response than just the body, such as the status code\n+or headers, you can make your method return the link:{jaxrsapi}/javax/ws/rs/core/Response.html[`Response`]\n+type:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.NewCookie;\n+import javax.ws.rs.core.Response;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public Response hello() {\n+        // HTTP OK status with text/plain content type\n+        return Response.ok(\"Hello, World!\", MediaType.TEXT_PLAIN_TYPE)\n+         // set a response header\n+         .header(\"X-FroMage\", \"Camembert\")\n+         // set the Expires response header to two days from now\n+         .expires(Date.from(Instant.now().plus(Duration.ofDays(2))))\n+         // send a new cookie\n+         .cookie(new NewCookie(\"Flavour\", \"pralin\u00e9\"))\n+         // end of builder API\n+         .build();\n+    }\n+}\n+----\n+\n+=== Async/reactive support\n+\n+[[reactive]]\n+\n+If your endpoint method needs to accomplish an asynchronous or reactive task before\n+being able to answer, you can declare your method to return the \n+link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`] type (from https://smallrye.io/smallrye-mutiny/[Mutiny]), in which\n+case the current HTTP request will be automatically suspended after your method, until\n+the returned link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`] instance resolves to a value,\n+which will be mapped to a response exactly according to the previously described rules:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"escoffier\")\n+public class Endpoint {\n+\n+    @GET\n+    public Uni<Book> culinaryGuide(){\n+        return Book.findByIsbn(\"978-2081229297\");\n+    }\n+}\n+----\n+\n+This allows you to not block the IO thread while the book is being fetched from the\n+database, and allows Quarkus to serve more requests until your book is ready to\n+be sent to the client and terminate this request. Check out our \n+<<execution-model,Execution Model documentation>> for more information.\n+\n+The link:{jdkapi}/java/util/concurrent/CompletionStage.html[`CompletionStage`] return\n+type is also supported.\n+\n+=== Streaming support\n+\n+If you want to stream your response element by element, you can make your endpoint method return a \n+link:{mutinyapi}/io/smallrye/mutiny/Multi.html[`Multi`] type (from https://smallrye.io/smallrye-mutiny/[Mutiny]).\n+This is especially useful for streaming text or binary data.\n+\n+This example, using link:reactive-messaging-http.html[Reactive Messaging] shows how to stream\n+text data:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import org.eclipse.microprofile.reactive.messaging.Channel;\n+\n+import io.smallrye.mutiny.Multi;\n+\n+@Path(\"logs\")\n+public class Endpoint {\n+\n+    @Inject\n+    @Channel(\"log-out\")\n+    Multi<String> logs;\n+\n+    @GET\n+    public Multi<String> streamLogs() {\n+        return logs;\n+    }\n+}\n+----\n+\n+=== Server-Sent Event (SSE) support\n+\n+If you want to stream JSON objects in your response, you can use \n+https://html.spec.whatwg.org/multipage/server-sent-events.html[Server-Sent Events]\n+by just annotating your endpoint method with \n+link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces(MediaType.SERVER_SENT_EVENTS)`]\n+and specifying that each element should be <<json,serialised to JSON>> with \n+`@RestSseElementType(MediaType.APPLICATION_JSON)`.\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.jboss.resteasy.reactive.RestSseElementType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import io.smallrye.reactive.messaging.annotations.Channel;\n+\n+@Path(\"escoffier\")\n+public class Endpoint {\n+\n+    // Inject our Book channel\n+    @Inject\n+    @Channel(\"book-out\")\n+    Multi<Book> books;\n+\n+    @GET\n+    // Send the stream over SSE\n+    @Produces(MediaType.SERVER_SENT_EVENTS)\n+    // Each element will be sent as JSON\n+    @RestSseElementType(MediaType.APPLICATION_JSON)\n+    public Multi<Book> stream() {\n+        return books;\n+    }\n+}\n+----\n+\n+=== Accessing context objects\n+\n+[[context-objects]]\n+\n+There are a number of contextual objects that the framework will give you, if your endpoint\n+method takes parameters of the following type:\n+\n+.Table Context object\n+|===\n+|Type|Usage\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/HttpHeaders.html[`HttpHeaders`]\n+|All the request headers\n+\n+|link:{jaxrsapi}/javax/ws/rs/container/ResourceInfo.html[`ResourceInfo`]\n+|Information about the current endpoint method and class (requires reflection)\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/SecurityContext.html[`SecurityContext`]\n+|Access to the current user and roles\n+\n+|`SimpleResourceInfo`\n+|Information about the current endpoint method and class (no reflection required)\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/UriInfo.html[`UriInfo`]\n+|Provides information about the current endpoint and application URI\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Application.html[`Application`]\n+|Advanced: Current JAX-RS application class\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Configuration.html[`Configuration`]\n+|Advanced: Configuration about the deployed JAX-RS application\n+\n+|link:{jaxrsapi}/javax/ws/rs/ext/Providers.html[`Providers`]\n+|Advanced: Runtime access to JAX-RS providers\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Request.html[`Request`]\n+|Advanced: Access to the current HTTP method and <<preconditions>>\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/ResourceContext.html[`ResourceContext`]\n+|Advanced: access to instances of endpoints\n+\n+|`ServerRequestContext`\n+|Advanced: RESTEasy Reactive access to the current request/response\n+\n+|link:{jaxrsapi}/javax/ws/rs/sse/Sse.html[`Sse`]\n+|Advanced: Complex SSE use-cases\n+\n+|===\n+\n+For example, here is how you can return the name of the currently logged-in user:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.security.Principal;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.SecurityContext;\n+\n+@Path(\"user\")\n+public class Endpoint {\n+\n+    @GET\n+    public String userName(SecurityContext security) {\n+        Principal user = security.getUserPrincipal();\n+        return user != null ? user.getName() : \"<NOT LOGGED IN>\";\n+    }\n+}\n+----\n+\n+You can also inject those context objects using \n+https://javadoc.io/static/javax.inject/javax.inject/1/javax/inject/Inject.html[`@Inject`] on fields of the same\n+type.\n+\n+=== JSON serialisation\n+\n+[[json]]\n+\n+You can import either of the following modules to get support for JSON:\n+\n+.Table Context object\n+|===\n+|GAV|Usage\n+\n+|`io.quarkus:quarkus-resteasy-jackson`\n+|https://github.com/FasterXML/jackson[Jackson support]\n+\n+|`io.quarkus:quarkus-resteasy-jsonb`\n+|http://json-b.net/[JSONB support]\n+\n+|===\n+\n+In both cases, importing those modules will allow HTTP message bodies to be read from JSON\n+and serialised to JSON, for <<resource-types,all the types not already registered with a more specific\n+serialisation>>.\n+\n+== More advanced usage\n+\n+Here are some more advanced topics that you may not need to know about initially, but\n+could prove useful for more complex use-cases.\n+\n+=== Execution model, blocking, non-blocking\n+\n+[[execution-model]]\n+\n+RESTEasy Reactive is implemented using two main thread types:\n+\n+- IO threads: which are responsible for reading bytes from the HTTP request and\n+ writing bytes back to the HTTP response\n+- Worker threads: they are pooled and can be used to offload long-running operations\n+\n+The IO threads (often called the \"event loop\") are responsible for actually performing all the IO\n+operations in an asynchronous way, and to trigger any listener interested in the completion of those\n+IO operations.\n+\n+By default, RESTEasy Reactive will run endpoint methods on the IO threads, on the assumption that\n+they are going to be fast and only invoke non-blocking operations.\n+\n+This is the model of execution that leads to best performance if your endpoints do not do any blocking\n+operation (such as blocking IO, blocking on an asynchronous operation, or sleeping).\n+\n+If your endpoint method needs to do any of those blocking operations, you should add the \n+https://javadoc.io/doc/io.smallrye.common/smallrye-common-annotation/1.5.0/io/smallrye/common/annotation/Blocking.html[`@Blocking`]\n+annotation on your endpoint and it will instead be invoked on a worker thread. Your endpoint method\n+code can remain exactly the same, and it will be allowed to block:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.common.annotation.Blocking;\n+\n+@Path(\"yawn\")\n+public class Endpoint {\n+\n+    @Blocking\n+    @GET\n+    public String blockingHello() throws InterruptedException {\n+        // do a blocking operation\n+        Thread.sleep(1000);\n+        return \"Yaaaawwwwnnnnnn\u2026\";\n+    }\n+}\n+----\n+\n+Most of the time, there are ways to achieve the same blocking operations in an asynchronous/reactive\n+way, using https://smallrye.io/smallrye-mutiny/[Mutiny], http://hibernate.org/reactive/[Hibernate Reactive] \n+or any of the link:getting-started-reactive[Quarkus Reactive extensions] for example:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.time.Duration;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"yawn\")\n+public class Endpoint {\n+\n+    @GET\n+    public Uni<String> blockingHello() throws InterruptedException {\n+        return Uni.createFrom().item(\"Yaaaawwwwnnnnnn\u2026\")\n+                // do a non-blocking sleep\n+                .onItem().delayIt().by(Duration.ofSeconds(2));\n+    }\n+}\n+----\n+\n+=== Exception mapping\n+\n+If your application needs to return non-nominal HTTP codes in error cases, the best is\n+to throw exceptions that will result in the proper HTTP response being sent by the\n+framework using link:{jaxrsapi}/javax/ws/rs/WebApplicationException.html[`WebApplicationException`] or any of its subtypes:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.BadRequestException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.Path;\n+\n+@Path(\"fromages/{fromage}\")\n+public class Endpoint {\n+\n+    @GET\n+    public String findFromage(String fromage) {\n+        if(fromage == null)\n+            // send a 400\n+            throw new BadRequestException();\n+        if(!fromage.equals(\"camembert\"))\n+            // send a 404\n+            throw new NotFoundException(\"Unknown cheese: \" + fromage);\n+        return \"Camembert is a very nice cheese\";\n+    }\n+}\n+----\n+\n+If your endpoint method is delegating calls to another service layer which\n+does not know of JAX-RS, you need a way to turn service exceptions to an\n+HTTP response, and you can do that using the `@ServerExceptionMapper` annotation\n+on a method, with one parameter of the exception type you want to handle, and turning\n+that exception into a link:{jaxrsapi}/javax/ws/rs/core/Response.html[`Response`] (or a \n+link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni<Response>`]):\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.util.Map;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.ws.rs.BadRequestException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.resteasy.reactive.server.ServerExceptionMapper;\n+\n+class UnknownCheeseException extends RuntimeException {\n+    public final String name;\n+    \n+    public UnknownCheeseException(String name) {\n+        this.name = name;\n+    }\n+}\n+\n+@ApplicationScoped\n+class CheeseService {\n+    private static final Map<String, String> cheeses = \n+            Map.of(\"camembert\", \"Camembert is a very nice cheese\",\n+                   \"gouda\", \"Gouda is acceptable too, especially with cumin\");\n+\n+    public String findCheese(String name) {\n+        String ret = cheeses.get(name);\n+        if(ret != null)\n+            return ret;\n+        throw new UnknownCheeseException(name);\n+    }\n+}\n+\n+@Path(\"fromages/{fromage}\")\n+public class Endpoint {\n+\n+    @Inject\n+    CheeseService cheeses;\n+    \n+    @ServerExceptionMapper\n+    public Response mapException(UnknownCheeseException x) {\n+        return Response.status(Response.Status.NOT_FOUND)\n+                       .entity(\"Unknown cheese: \" + x.name)\n+                       .build();\n+    }\n+    \n+    @GET\n+    public String findFromage(String fromage) {\n+        if(fromage == null)\n+            // send a 400\n+            throw new BadRequestException();\n+        return cheeses.findCheese(fromage);\n+    }\n+} \n+----\n+\n+NOTE: exception mappers defined in REST endpoint classes will only be called if the\n+exception is thrown in the same class. If you want to define global exception mappers,\n+simply define them outside a REST endpoint class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.resteasy.reactive.server.ServerExceptionMapper;\n+\n+class ExceptionMappers {\n+    @ServerExceptionMapper\n+    public Response mapException(UnknownCheeseException x) {\n+        return Response.status(Response.Status.NOT_FOUND)\n+                       .entity(\"Unknown cheese: \" + x.name)\n+                       .build();\n+    }\n+}\n+----\n+\n+Naturally, you can also declare link:{jaxrsspec}#exceptionmapper[exception mappers in the JAX-RS way].\n+\n+Your exception mapper may declare any of the following parameter types:\n+\n+.Table Exception mapper parameters\n+|===\n+|Type|Usage\n+\n+|An exception type\n+|Defines the exception type you want to handle\n+\n+|Any of the <<context-objects,Context objects>>\n+|\n+\n+|link:{jaxrsapi}/javax/ws/rs/container/ContainerRequestContext.html[`ContainerRequestContext`]\n+|A context object to access the current request\n+\n+|===\n+\n+It may declare any of the following return types:\n+\n+.Table Exception mapper return types\n+|===\n+|Type|Usage\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Response.html[`Response`]\n+|The response to send to the client when the exception occurs\n+\n+|link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni<Response>`]\n+|An asynchronous response to send to the client when the exception occurs\n+\n+|===\n+\n+=== Request or response filters\n+\n+You can declare functions which are invoked in the following phases of the request processing:\n+\n+- Before the endpoint method is identified: pre-routing request filter\n+- After routing, but before the endpoint method is called: normal request filter\n+- After the endpoint method is called: response filter\n+\n+These filters allow you to do various things such as examine the request URI,\n+HTTP method, influence routing, look or change request headers, abort the request,\n+or modify the response.\n+\n+// TODO: link\n+Request filters can be declared with the `@ServerRequestFilter` annotation:\n+\n+[source,java]\n+----\n+class Filters {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cde4943aec547bfcd64b41b939f2b5d2c3a0b77"}, "originalPosition": 898}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI4ODI1Ng==", "bodyText": "And here", "url": "https://github.com/quarkusio/quarkus/pull/13802#discussion_r540288256", "createdAt": "2020-12-10T16:00:59Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/rest-reactive.adoc", "diffHunk": "@@ -0,0 +1,1553 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Writing REST Services with RESTEasy Reactive\n+\n+include::./attributes.adoc[]\n+:jaxrsapi: https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1\n+:jaxrsspec: /specs/jaxrs/2.1/index.html\n+:jdkapi: https://docs.oracle.com/en/java/javase/11/docs/api/java.base\n+:mutinyapi: https://smallrye.io/smallrye-mutiny/apidocs\n+:httpspec: https://tools.ietf.org/html/rfc7231\n+:jsonpapi: https://javadoc.io/doc/javax.json/javax.json-api/1.1.4\n+:vertxapi: https://javadoc.io/static/io.vertx/vertx-core/3.9.4\n+\n+This guide explains how to write REST Services with RESTEasy Reactive\n+\n+TODO: buff this\n+\n+TODO: links to our javadoc\n+\n+== What is RESTEasy Reactive?\n+\n+RESTEasy Reactive is a new link:{jaxrsspec}[JAX-RS]\n+implementation written from the ground up to work on our\n+common https://vertx.io/[Vert.x] layer and is thus fully reactive, while also being very tightly integrated with\n+Quarkus and consequently moving a lot of work to build time.\n+\n+You should be able to use it in place of any JAX-RS implementation, but on top of that it has\n+great performance for both blocking and non-blocking endpoints, and a lot of new features on top\n+of what JAX-RS provides.\n+\n+== Writing endpoints\n+\n+=== Getting started\n+\n+Add the following import to your `pom.xml` file:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-resteasy-reactive</artifactId>\n+</dependency>\n+----\n+\n+You can now write your first endpoint in the `org.acme.rest.Endpoint` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+=== Terminology\n+\n+REST:: https://en.wikipedia.org/wiki/Representational_state_transfer[REpresentational State Transfer]\n+Endpoint:: Java method which is called to serve a REST call\n+URL / URI (Uniform Resource Locator / Identifier):: Used to identify the location of REST resources (https://tools.ietf.org/html/rfc7230#section-2.7[specification])\n+Resource:: Represents your domain object. This is what your API serves and modifies. Also called an `entity` in JAX-RS.\n+Representation:: How your resource is represented on the wire, can vary depending on content types\n+Content type:: Designates a particular representation (also called a media type), for example `text/plain` or `application/json`\n+HTTP:: Underlying wire protocol for routing REST calls (see https://tools.ietf.org/html/rfc7230[HTTP specifications])\n+HTTP request:: the request part of the HTTP call, consisting of an HTTP method, a target URI, headers and an optional message body\n+HTTP response:: the response part of the HTTP call, consisting of an HTTP response status, headers and an optional message body\n+\n+=== Declaring endpoints: URI mapping\n+\n+Any class annotated with a link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation can have its methods exposed as REST endpoints,\n+provided they have an HTTP method annotation (see below).\n+\n+That link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation defines the URI prefix under which those methods will be exposed. It can\n+be empty, or contain a prefix such as `rest` or `rest/V1`.\n+\n+Each exposed endpoint method can in turn have another link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation which adds to its containing\n+class annotation. For example, this defines a `rest/hello` endpoint:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"rest\")\n+public class Endpoint {\n+\n+    @Path(\"hello\")\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+See <<uri-parameters,URI parameters>> for more information about URI mapping.\n+\n+=== Declaring endpoints: HTTP methods\n+\n+Each endpoint method must be annotated with one of the following annotations, which defines which HTTP\n+method will be mapped to the method:\n+\n+.Table HTTP method annotations\n+|===\n+|Annotation|Usage \n+\n+|link:{jaxrsapi}/javax/ws/rs/GET.html[`@GET`]\n+|Obtain a resource representation, should not modify state, idempotent (link:{httpspec}#section-4.3.1[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/HEAD.html[`@HEAD`]\n+|Obtain metadata about a resource, similar to `GET` with no body (link:{httpspec}#section-4.3.2[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/POST.html[`@POST`]\n+|Create a resource and obtain a link to it (link:{httpspec}#section-4.3.3[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PUT.html[`@PUT`]\n+|Replace a resource or create one, should be idempotent (link:{httpspec}#section-4.3.4[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/DELETE.html[`@DELETE`]\n+|Delete an existing resource, idempotent  (link:{httpspec}#section-4.3.5[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/OPTIONS.html[`@OPTIONS`]\n+|Obtain information about a resource, idempotent (link:{httpspec}#section-4.3.7[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PATCH.html[`@PATCH`]\n+|Update a resource, or create one, not idempotent (https://tools.ietf.org/html/rfc5789#section-2[HTTP docs])\n+\n+|===\n+\n+You can also declare other HTTP methods by declaring them as an annotation with the\n+link:{jaxrsapi}/javax/ws/rs/HttpMethod.html[`@HttpMethod`] annotation:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+import javax.ws.rs.HttpMethod;\n+import javax.ws.rs.Path;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@HttpMethod(\"FROMAGE\")\n+@interface FROMAGE {\n+}\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @FROMAGE\n+    public String hello(){\n+        return \"Hello, Cheese World!\";\n+    }\n+}\n+----\n+\n+=== Declaring endpoints: representation / content types\n+\n+Each endpoint method may consume or produce specific resource representations, which are indicated by\n+the HTTP link:{httpspec}#section-3.1.1.5[`Content-Type`] header, which in turn contains \n+link:{httpspec}#section-3.1.1.1[MIME (Media Type)] values, such as the following:\n+\n+- `text/plain` which is the default for any endpoint returning a `String`.\n+- `text/html` for HTML (such as with link:qute[Qute templating])\n+- `application/json` for a <<json,JSON REST endpoint>>\n+- `text/*` which is a sub-type wildcard for any text media type\n+- `*/*` which is a wildcard for any media type\n+\n+You may annotate your endpoint class with the link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces`] \n+or link:{jaxrsapi}/javax/ws/rs/Consumes.html[`@Consumes`] annotations, which\n+allow you to specify one or more media types that your endpoint may accept as HTTP request body\n+or produce as HTTP response body. Those class annotations apply to each method.\n+\n+Any method may also be annotated with the link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces`] \n+or link:{jaxrsapi}/javax/ws/rs/Consumes.html[`@Consumes`] annotations, in which\n+case they override any eventual class annotation.\n+\n+The link:{jaxrsapi}/javax/ws/rs/core/MediaType.html[`MediaType`] class has many constants you\n+can use to point to specific pre-defined media types.\n+\n+See <<negotiation>> for more information.\n+\n+=== Accessing request parameters\n+\n+[[request-parameters]]\n+\n+NOTE: don't forget to configure your compiler to generate parameter name information with `-parameters` (javac)\n+or `<parameters>` or `<maven.compiler.parameters>` (https://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#parameters[Maven]).\n+\n+The following HTTP request elements may be obtained by your endpoint method:\n+\n+.Table HTTP request parameter annotations\n+|===\n+|HTTP element|Annotation|Usage \n+\n+|[[path-parameter]]Path parameter\n+|`@RestPath` (or nothing)\n+|URI template parameter (simplified version of the https://tools.ietf.org/html/rfc6570[URI Template specification]), \n+see <<uri-parameters,URI parameters>> for more information.\n+\n+|Query parameter\n+|`@RestQuery`\n+|The value of an https://tools.ietf.org/html/rfc3986#section-3.4[URI query parameter]\n+\n+|Header\n+|`@RestHeader`\n+|The value of an https://tools.ietf.org/html/rfc7230#section-3.2[HTTP header]\n+\n+|Cookie\n+|`@RestCookie`\n+|The value of an https://tools.ietf.org/html/rfc6265#section-4.2[HTTP cookie]\n+\n+|Form parameter\n+|`@RestForm`\n+|The value of an https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST[HTTP URL-encoded FORM]\n+\n+|Matrix parameter\n+|`@RestMatrix`\n+|The value of an https://tools.ietf.org/html/rfc3986#section-3.3[URI path segment parameter]\n+\n+|===\n+\n+For each of those annotations, you may specify the name of the element they refer to, otherwise\n+they will use the name of the annotated method parameter.\n+\n+If a client made the following HTTP call:\n+\n+[source,http]\n+----\n+POST /cheeses;variant=goat/tomme?age=matured HTTP/1.1\n+Content-Type: application/x-www-form-urlencoded\n+Cookie: level=hardcore\n+X-Cheese-Secret-Handshake: fist-bump\n+\n+smell=strong\n+----\n+\n+Then you could obtain all the various parameters with this endpoint method:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+\n+import org.jboss.resteasy.reactive.RestCookie;\n+import org.jboss.resteasy.reactive.RestForm;\n+import org.jboss.resteasy.reactive.RestHeader;\n+import org.jboss.resteasy.reactive.RestMatrix;\n+import org.jboss.resteasy.reactive.RestPath;\n+import org.jboss.resteasy.reactive.RestQuery;\n+\n+@Path(\"/cheeses/{type}\")\n+public class Endpoint {\n+\n+    @POST\n+    public String allParams(@RestPath String type,\n+                            @RestMatrix String variant,\n+                            @RestQuery String age,\n+                            @RestCookie String level,\n+                            @RestHeader(\"X-Cheese-Secret-Handshake\")\n+                            String secretHandshake,\n+                            @RestForm String smell){\n+        return type + \"/\" + variant + \"/\" + age + \"/\" + level + \"/\" + secretHandshake + \"/\" + smell;\n+    }\n+}\n+----\n+\n+NOTE: the `@RestPath` annotation is optional: any parameter whose name matches an existing URI\n+template variable will be automatically assumed to have `@RestPath`.\n+\n+Naturally you can also use any of the JAX-RS annotations link:{jaxrsapi}/javax/ws/rs/PathParam.html[`@PathParam`],\n+link:{jaxrsapi}/javax/ws/rs/QueryParam.html[`@QueryParam`],\n+link:{jaxrsapi}/javax/ws/rs/HeaderParam.html[`@HeaderParam`],\n+link:{jaxrsapi}/javax/ws/rs/CookieParam.html[`@CookieParam`],\n+link:{jaxrsapi}/javax/ws/rs/FormParam.html[`@FormParam`] or\n+link:{jaxrsapi}/javax/ws/rs/MatrixParam.html[`@MatrixParam`] for this,\n+but they require you to specify the parameter name.\n+\n+See <<parameter-mapping>> for more advanced use-cases.\n+\n+=== Declaring URI parameters\n+\n+[[uri-parameters]]\n+\n+You can declare URI parameters and use regular expressions in your path, so for instance\n+the following endpoint will serve requests for `/hello/stef/23` and `/hello` but not\n+`/hello/stef/0x23`:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"hello\")\n+public class Endpoint {\n+\n+    @Path(\"{name}/{age:\\\\d+}\")\n+    @GET\n+    public String personalisedHello(String name, int age){\n+        return \"Hello \" + name + \" is your age really \" + age + \"?\";\n+    }\n+\n+    @GET\n+    public String genericHello(){\n+        return \"Hello stranger\";\n+    }\n+}\n+----\n+\n+\n+=== Accessing the request body\n+\n+Any method parameter with no annotation will receive the method body.footnote:[Unless it is a\n+<<path-parameter,URI template parameter>> or a <<context-objects,context object>>.], after it has been mapped from\n+its HTTP representation to the Java type of the parameter.\n+\n+The following parameter types will be supported out of the box:\n+\n+[[resource-types]]\n+\n+.Table Request body parameter type\n+|===\n+|Type|Usage\n+\n+|link:{jdkapi}/java/io/File.html[`File`]\n+|The entire request body in a temporary file\n+\n+|`byte[]`\n+|The entire request body, not decoded\n+\n+|`char[]`\n+|The entire request body, decoded\n+\n+|link:{jdkapi}/java/lang/String.html[`String`]\n+|The entire request body, decoded\n+\n+|link:{jdkapi}/java/io/InputStream.html[`InputStream`]\n+|The request body in a blocking stream\n+\n+|link:{jdkapi}/java/io/Reader.html[`Reader`]\n+|The request body in a blocking stream\n+\n+|All Java primitives and their wrapper classes\n+|Java primitive types\n+\n+|link:{jdkapi}/java/math/BigDecimal.html[`BigDecimal`], link:{jdkapi}/java/math/BigInteger.html[`BigInteger`]\n+|Large integers and decimals.\n+\n+|link:{jsonpapi}/javax/json/JsonArray.html[`JsonArray`], link:{jsonpapi}/javax/json/JsonArray.html[`JsonObject`],\n+link:{jsonpapi}/javax/json/JsonArray.html[`JsonStructure`], link:{jsonpapi}/javax/json/JsonArray.html[`JsonValue`]\n+|JSON value types  \n+\n+|link:{vertxapi}io/vertx/core/buffer/Buffer.html[`Buffer`]\n+|Vert.x Buffer \n+\n+|any other type\n+|Will be <<json,mapped from JSON to that type>>\n+\n+|===\n+\n+NOTE: You can add support for more <<readers-writers,body parameter types>>.\n+\n+=== Returning a response body\n+\n+In order to return an HTTP response, simply return the resource you want from your method. The method\n+return type and its optional content type will be used to decide how to serialise it to the HTTP\n+response (see <<negotiation>> for more advanced information).\n+\n+You can return any of the pre-defined types that you can read from the <<resource-types,HTTP response>>,\n+and any other type will be mapped <<json,from that type to JSON>>.\n+\n+Alternately, you can also return a <<reactive,reactive type>> such as link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`], \n+link:{mutinyapi}/io/smallrye/mutiny/Multi.html[`Multi`] or \n+link:{jdkapi}/java/util/concurrent/CompletionStage.html[`CompletionStage`]\n+that resolve to one of the mentioned return types.\n+\n+=== Setting other response properties\n+\n+If you need to set more properties on the HTTP response than just the body, such as the status code\n+or headers, you can make your method return the link:{jaxrsapi}/javax/ws/rs/core/Response.html[`Response`]\n+type:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.NewCookie;\n+import javax.ws.rs.core.Response;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public Response hello() {\n+        // HTTP OK status with text/plain content type\n+        return Response.ok(\"Hello, World!\", MediaType.TEXT_PLAIN_TYPE)\n+         // set a response header\n+         .header(\"X-FroMage\", \"Camembert\")\n+         // set the Expires response header to two days from now\n+         .expires(Date.from(Instant.now().plus(Duration.ofDays(2))))\n+         // send a new cookie\n+         .cookie(new NewCookie(\"Flavour\", \"pralin\u00e9\"))\n+         // end of builder API\n+         .build();\n+    }\n+}\n+----\n+\n+=== Async/reactive support\n+\n+[[reactive]]\n+\n+If your endpoint method needs to accomplish an asynchronous or reactive task before\n+being able to answer, you can declare your method to return the \n+link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`] type (from https://smallrye.io/smallrye-mutiny/[Mutiny]), in which\n+case the current HTTP request will be automatically suspended after your method, until\n+the returned link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`] instance resolves to a value,\n+which will be mapped to a response exactly according to the previously described rules:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"escoffier\")\n+public class Endpoint {\n+\n+    @GET\n+    public Uni<Book> culinaryGuide(){\n+        return Book.findByIsbn(\"978-2081229297\");\n+    }\n+}\n+----\n+\n+This allows you to not block the IO thread while the book is being fetched from the\n+database, and allows Quarkus to serve more requests until your book is ready to\n+be sent to the client and terminate this request. Check out our \n+<<execution-model,Execution Model documentation>> for more information.\n+\n+The link:{jdkapi}/java/util/concurrent/CompletionStage.html[`CompletionStage`] return\n+type is also supported.\n+\n+=== Streaming support\n+\n+If you want to stream your response element by element, you can make your endpoint method return a \n+link:{mutinyapi}/io/smallrye/mutiny/Multi.html[`Multi`] type (from https://smallrye.io/smallrye-mutiny/[Mutiny]).\n+This is especially useful for streaming text or binary data.\n+\n+This example, using link:reactive-messaging-http.html[Reactive Messaging] shows how to stream\n+text data:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import org.eclipse.microprofile.reactive.messaging.Channel;\n+\n+import io.smallrye.mutiny.Multi;\n+\n+@Path(\"logs\")\n+public class Endpoint {\n+\n+    @Inject\n+    @Channel(\"log-out\")\n+    Multi<String> logs;\n+\n+    @GET\n+    public Multi<String> streamLogs() {\n+        return logs;\n+    }\n+}\n+----\n+\n+=== Server-Sent Event (SSE) support\n+\n+If you want to stream JSON objects in your response, you can use \n+https://html.spec.whatwg.org/multipage/server-sent-events.html[Server-Sent Events]\n+by just annotating your endpoint method with \n+link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces(MediaType.SERVER_SENT_EVENTS)`]\n+and specifying that each element should be <<json,serialised to JSON>> with \n+`@RestSseElementType(MediaType.APPLICATION_JSON)`.\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.jboss.resteasy.reactive.RestSseElementType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import io.smallrye.reactive.messaging.annotations.Channel;\n+\n+@Path(\"escoffier\")\n+public class Endpoint {\n+\n+    // Inject our Book channel\n+    @Inject\n+    @Channel(\"book-out\")\n+    Multi<Book> books;\n+\n+    @GET\n+    // Send the stream over SSE\n+    @Produces(MediaType.SERVER_SENT_EVENTS)\n+    // Each element will be sent as JSON\n+    @RestSseElementType(MediaType.APPLICATION_JSON)\n+    public Multi<Book> stream() {\n+        return books;\n+    }\n+}\n+----\n+\n+=== Accessing context objects\n+\n+[[context-objects]]\n+\n+There are a number of contextual objects that the framework will give you, if your endpoint\n+method takes parameters of the following type:\n+\n+.Table Context object\n+|===\n+|Type|Usage\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/HttpHeaders.html[`HttpHeaders`]\n+|All the request headers\n+\n+|link:{jaxrsapi}/javax/ws/rs/container/ResourceInfo.html[`ResourceInfo`]\n+|Information about the current endpoint method and class (requires reflection)\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/SecurityContext.html[`SecurityContext`]\n+|Access to the current user and roles\n+\n+|`SimpleResourceInfo`\n+|Information about the current endpoint method and class (no reflection required)\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/UriInfo.html[`UriInfo`]\n+|Provides information about the current endpoint and application URI\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Application.html[`Application`]\n+|Advanced: Current JAX-RS application class\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Configuration.html[`Configuration`]\n+|Advanced: Configuration about the deployed JAX-RS application\n+\n+|link:{jaxrsapi}/javax/ws/rs/ext/Providers.html[`Providers`]\n+|Advanced: Runtime access to JAX-RS providers\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Request.html[`Request`]\n+|Advanced: Access to the current HTTP method and <<preconditions>>\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/ResourceContext.html[`ResourceContext`]\n+|Advanced: access to instances of endpoints\n+\n+|`ServerRequestContext`\n+|Advanced: RESTEasy Reactive access to the current request/response\n+\n+|link:{jaxrsapi}/javax/ws/rs/sse/Sse.html[`Sse`]\n+|Advanced: Complex SSE use-cases\n+\n+|===\n+\n+For example, here is how you can return the name of the currently logged-in user:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.security.Principal;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.SecurityContext;\n+\n+@Path(\"user\")\n+public class Endpoint {\n+\n+    @GET\n+    public String userName(SecurityContext security) {\n+        Principal user = security.getUserPrincipal();\n+        return user != null ? user.getName() : \"<NOT LOGGED IN>\";\n+    }\n+}\n+----\n+\n+You can also inject those context objects using \n+https://javadoc.io/static/javax.inject/javax.inject/1/javax/inject/Inject.html[`@Inject`] on fields of the same\n+type.\n+\n+=== JSON serialisation\n+\n+[[json]]\n+\n+You can import either of the following modules to get support for JSON:\n+\n+.Table Context object\n+|===\n+|GAV|Usage\n+\n+|`io.quarkus:quarkus-resteasy-jackson`\n+|https://github.com/FasterXML/jackson[Jackson support]\n+\n+|`io.quarkus:quarkus-resteasy-jsonb`\n+|http://json-b.net/[JSONB support]\n+\n+|===\n+\n+In both cases, importing those modules will allow HTTP message bodies to be read from JSON\n+and serialised to JSON, for <<resource-types,all the types not already registered with a more specific\n+serialisation>>.\n+\n+== More advanced usage\n+\n+Here are some more advanced topics that you may not need to know about initially, but\n+could prove useful for more complex use-cases.\n+\n+=== Execution model, blocking, non-blocking\n+\n+[[execution-model]]\n+\n+RESTEasy Reactive is implemented using two main thread types:\n+\n+- IO threads: which are responsible for reading bytes from the HTTP request and\n+ writing bytes back to the HTTP response\n+- Worker threads: they are pooled and can be used to offload long-running operations\n+\n+The IO threads (often called the \"event loop\") are responsible for actually performing all the IO\n+operations in an asynchronous way, and to trigger any listener interested in the completion of those\n+IO operations.\n+\n+By default, RESTEasy Reactive will run endpoint methods on the IO threads, on the assumption that\n+they are going to be fast and only invoke non-blocking operations.\n+\n+This is the model of execution that leads to best performance if your endpoints do not do any blocking\n+operation (such as blocking IO, blocking on an asynchronous operation, or sleeping).\n+\n+If your endpoint method needs to do any of those blocking operations, you should add the \n+https://javadoc.io/doc/io.smallrye.common/smallrye-common-annotation/1.5.0/io/smallrye/common/annotation/Blocking.html[`@Blocking`]\n+annotation on your endpoint and it will instead be invoked on a worker thread. Your endpoint method\n+code can remain exactly the same, and it will be allowed to block:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.common.annotation.Blocking;\n+\n+@Path(\"yawn\")\n+public class Endpoint {\n+\n+    @Blocking\n+    @GET\n+    public String blockingHello() throws InterruptedException {\n+        // do a blocking operation\n+        Thread.sleep(1000);\n+        return \"Yaaaawwwwnnnnnn\u2026\";\n+    }\n+}\n+----\n+\n+Most of the time, there are ways to achieve the same blocking operations in an asynchronous/reactive\n+way, using https://smallrye.io/smallrye-mutiny/[Mutiny], http://hibernate.org/reactive/[Hibernate Reactive] \n+or any of the link:getting-started-reactive[Quarkus Reactive extensions] for example:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.time.Duration;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"yawn\")\n+public class Endpoint {\n+\n+    @GET\n+    public Uni<String> blockingHello() throws InterruptedException {\n+        return Uni.createFrom().item(\"Yaaaawwwwnnnnnn\u2026\")\n+                // do a non-blocking sleep\n+                .onItem().delayIt().by(Duration.ofSeconds(2));\n+    }\n+}\n+----\n+\n+=== Exception mapping\n+\n+If your application needs to return non-nominal HTTP codes in error cases, the best is\n+to throw exceptions that will result in the proper HTTP response being sent by the\n+framework using link:{jaxrsapi}/javax/ws/rs/WebApplicationException.html[`WebApplicationException`] or any of its subtypes:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.BadRequestException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.NotFoundException;\n+import javax.ws.rs.Path;\n+\n+@Path(\"fromages/{fromage}\")\n+public class Endpoint {\n+\n+    @GET\n+    public String findFromage(String fromage) {\n+        if(fromage == null)\n+            // send a 400\n+            throw new BadRequestException();\n+        if(!fromage.equals(\"camembert\"))\n+            // send a 404\n+            throw new NotFoundException(\"Unknown cheese: \" + fromage);\n+        return \"Camembert is a very nice cheese\";\n+    }\n+}\n+----\n+\n+If your endpoint method is delegating calls to another service layer which\n+does not know of JAX-RS, you need a way to turn service exceptions to an\n+HTTP response, and you can do that using the `@ServerExceptionMapper` annotation\n+on a method, with one parameter of the exception type you want to handle, and turning\n+that exception into a link:{jaxrsapi}/javax/ws/rs/core/Response.html[`Response`] (or a \n+link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni<Response>`]):\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.util.Map;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.ws.rs.BadRequestException;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.resteasy.reactive.server.ServerExceptionMapper;\n+\n+class UnknownCheeseException extends RuntimeException {\n+    public final String name;\n+    \n+    public UnknownCheeseException(String name) {\n+        this.name = name;\n+    }\n+}\n+\n+@ApplicationScoped\n+class CheeseService {\n+    private static final Map<String, String> cheeses = \n+            Map.of(\"camembert\", \"Camembert is a very nice cheese\",\n+                   \"gouda\", \"Gouda is acceptable too, especially with cumin\");\n+\n+    public String findCheese(String name) {\n+        String ret = cheeses.get(name);\n+        if(ret != null)\n+            return ret;\n+        throw new UnknownCheeseException(name);\n+    }\n+}\n+\n+@Path(\"fromages/{fromage}\")\n+public class Endpoint {\n+\n+    @Inject\n+    CheeseService cheeses;\n+    \n+    @ServerExceptionMapper\n+    public Response mapException(UnknownCheeseException x) {\n+        return Response.status(Response.Status.NOT_FOUND)\n+                       .entity(\"Unknown cheese: \" + x.name)\n+                       .build();\n+    }\n+    \n+    @GET\n+    public String findFromage(String fromage) {\n+        if(fromage == null)\n+            // send a 400\n+            throw new BadRequestException();\n+        return cheeses.findCheese(fromage);\n+    }\n+} \n+----\n+\n+NOTE: exception mappers defined in REST endpoint classes will only be called if the\n+exception is thrown in the same class. If you want to define global exception mappers,\n+simply define them outside a REST endpoint class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.resteasy.reactive.server.ServerExceptionMapper;\n+\n+class ExceptionMappers {\n+    @ServerExceptionMapper\n+    public Response mapException(UnknownCheeseException x) {\n+        return Response.status(Response.Status.NOT_FOUND)\n+                       .entity(\"Unknown cheese: \" + x.name)\n+                       .build();\n+    }\n+}\n+----\n+\n+Naturally, you can also declare link:{jaxrsspec}#exceptionmapper[exception mappers in the JAX-RS way].\n+\n+Your exception mapper may declare any of the following parameter types:\n+\n+.Table Exception mapper parameters\n+|===\n+|Type|Usage\n+\n+|An exception type\n+|Defines the exception type you want to handle\n+\n+|Any of the <<context-objects,Context objects>>\n+|\n+\n+|link:{jaxrsapi}/javax/ws/rs/container/ContainerRequestContext.html[`ContainerRequestContext`]\n+|A context object to access the current request\n+\n+|===\n+\n+It may declare any of the following return types:\n+\n+.Table Exception mapper return types\n+|===\n+|Type|Usage\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Response.html[`Response`]\n+|The response to send to the client when the exception occurs\n+\n+|link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni<Response>`]\n+|An asynchronous response to send to the client when the exception occurs\n+\n+|===\n+\n+=== Request or response filters\n+\n+You can declare functions which are invoked in the following phases of the request processing:\n+\n+- Before the endpoint method is identified: pre-routing request filter\n+- After routing, but before the endpoint method is called: normal request filter\n+- After the endpoint method is called: response filter\n+\n+These filters allow you to do various things such as examine the request URI,\n+HTTP method, influence routing, look or change request headers, abort the request,\n+or modify the response.\n+\n+// TODO: link\n+Request filters can be declared with the `@ServerRequestFilter` annotation:\n+\n+[source,java]\n+----\n+class Filters {\n+    \n+    @ServerRequestFilter(preMatching = true)\n+    public void preMatchingFilter(ContainerRequestContext requestContext) {\n+        // make sure we don't lose cheese lovers\n+        if(\"yes\".equals(requestContext.getHeaderString(\"Cheese\"))) {\n+            requestContext.setRequestUri(URI.create(\"/cheese\"));\n+        }\n+    }\n+    \n+    @ServerRequestFilter\n+    public void getFilter(ContainerRequestContext ctx) {\n+        // only allow GET methods for now\n+        if(ctx.getMethod().equals(HttpMethod.GET)) {\n+            ctx.abortWith(Response.status(Response.Status.METHOD_NOT_ALLOWED).build());\n+        }\n+    }\n+}\n+----\n+\n+// TODO: link\n+Similarly, response filters can be declared with the `@ServerResponseFilter` annotation:\n+\n+[source,java]\n+----\n+class Filters {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cde4943aec547bfcd64b41b939f2b5d2c3a0b77"}, "originalPosition": 923}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NDA1MzAx", "url": "https://github.com/quarkusio/quarkus/pull/13802#pullrequestreview-549405301", "createdAt": "2020-12-10T16:55:08Z", "commit": {"oid": "fe7dc417e95f6cf3e053ad730420379545c2333e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjo1NTowOFrOIDTXqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjo1NTowOFrOIDTXqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMzMzk5Mg==", "bodyText": "@Inject is not necessary here", "url": "https://github.com/quarkusio/quarkus/pull/13802#discussion_r540333992", "createdAt": "2020-12-10T16:55:08Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/rest-reactive.adoc", "diffHunk": "@@ -0,0 +1,1610 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Writing REST Services with RESTEasy Reactive\n+\n+include::./attributes.adoc[]\n+:jaxrsapi: https://javadoc.io/doc/javax.ws.rs/javax.ws.rs-api/2.1.1\n+:jaxrsspec: /specs/jaxrs/2.1/index.html\n+:jdkapi: https://docs.oracle.com/en/java/javase/11/docs/api/java.base\n+:mutinyapi: https://smallrye.io/smallrye-mutiny/apidocs\n+:httpspec: https://tools.ietf.org/html/rfc7231\n+:jsonpapi: https://javadoc.io/doc/javax.json/javax.json-api/1.1.4\n+:vertxapi: https://javadoc.io/static/io.vertx/vertx-core/3.9.4\n+\n+This guide explains how to write REST Services with RESTEasy Reactive\n+\n+TODO: buff this\n+\n+TODO: links to our javadoc\n+\n+== What is RESTEasy Reactive?\n+\n+RESTEasy Reactive is a new link:{jaxrsspec}[JAX-RS]\n+implementation written from the ground up to work on our\n+common https://vertx.io/[Vert.x] layer and is thus fully reactive, while also being very tightly integrated with\n+Quarkus and consequently moving a lot of work to build time.\n+\n+You should be able to use it in place of any JAX-RS implementation, but on top of that it has\n+great performance for both blocking and non-blocking endpoints, and a lot of new features on top\n+of what JAX-RS provides.\n+\n+== Writing endpoints\n+\n+=== Getting started\n+\n+Add the following import to your `pom.xml` file:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-resteasy-reactive</artifactId>\n+</dependency>\n+----\n+\n+You can now write your first endpoint in the `org.acme.rest.Endpoint` class:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+=== Terminology\n+\n+REST:: https://en.wikipedia.org/wiki/Representational_state_transfer[REpresentational State Transfer]\n+Endpoint:: Java method which is called to serve a REST call\n+URL / URI (Uniform Resource Locator / Identifier):: Used to identify the location of REST resources (https://tools.ietf.org/html/rfc7230#section-2.7[specification])\n+Resource:: Represents your domain object. This is what your API serves and modifies. Also called an `entity` in JAX-RS.\n+Representation:: How your resource is represented on the wire, can vary depending on content types\n+Content type:: Designates a particular representation (also called a media type), for example `text/plain` or `application/json`\n+HTTP:: Underlying wire protocol for routing REST calls (see https://tools.ietf.org/html/rfc7230[HTTP specifications])\n+HTTP request:: the request part of the HTTP call, consisting of an HTTP method, a target URI, headers and an optional message body\n+HTTP response:: the response part of the HTTP call, consisting of an HTTP response status, headers and an optional message body\n+\n+=== Declaring endpoints: URI mapping\n+\n+Any class annotated with a link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation can have its methods exposed as REST endpoints,\n+provided they have an HTTP method annotation (see below).\n+\n+That link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation defines the URI prefix under which those methods will be exposed. It can\n+be empty, or contain a prefix such as `rest` or `rest/V1`.\n+\n+Each exposed endpoint method can in turn have another link:{jaxrsapi}/javax/ws/rs/Path.html[`@Path`] annotation which adds to its containing\n+class annotation. For example, this defines a `rest/hello` endpoint:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"rest\")\n+public class Endpoint {\n+\n+    @Path(\"hello\")\n+    @GET\n+    public String hello(){\n+        return \"Hello, World!\";\n+    }\n+}\n+----\n+\n+See <<uri-parameters,URI parameters>> for more information about URI mapping.\n+\n+=== Declaring endpoints: HTTP methods\n+\n+Each endpoint method must be annotated with one of the following annotations, which defines which HTTP\n+method will be mapped to the method:\n+\n+.Table HTTP method annotations\n+|===\n+|Annotation|Usage \n+\n+|link:{jaxrsapi}/javax/ws/rs/GET.html[`@GET`]\n+|Obtain a resource representation, should not modify state, link:{httpspec}#section-4.2.2[idempotent] (link:{httpspec}#section-4.3.1[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/HEAD.html[`@HEAD`]\n+|Obtain metadata about a resource, similar to `GET` with no body (link:{httpspec}#section-4.3.2[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/POST.html[`@POST`]\n+|Create a resource and obtain a link to it (link:{httpspec}#section-4.3.3[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PUT.html[`@PUT`]\n+|Replace a resource or create one, should be link:{httpspec}#section-4.2.2[idempotent] (link:{httpspec}#section-4.3.4[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/DELETE.html[`@DELETE`]\n+|Delete an existing resource, link:{httpspec}#section-4.2.2[idempotent]  (link:{httpspec}#section-4.3.5[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/OPTIONS.html[`@OPTIONS`]\n+|Obtain information about a resource, link:{httpspec}#section-4.2.2[idempotent] (link:{httpspec}#section-4.3.7[HTTP docs])\n+\n+|link:{jaxrsapi}/javax/ws/rs/PATCH.html[`@PATCH`]\n+|Update a resource, or create one, not link:{httpspec}#section-4.2.2[idempotent] (https://tools.ietf.org/html/rfc5789#section-2[HTTP docs])\n+\n+|===\n+\n+You can also declare other HTTP methods by declaring them as an annotation with the\n+link:{jaxrsapi}/javax/ws/rs/HttpMethod.html[`@HttpMethod`] annotation:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+import javax.ws.rs.HttpMethod;\n+import javax.ws.rs.Path;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@HttpMethod(\"FROMAGE\")\n+@interface FROMAGE {\n+}\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @FROMAGE\n+    public String hello(){\n+        return \"Hello, Cheese World!\";\n+    }\n+}\n+----\n+\n+=== Declaring endpoints: representation / content types\n+\n+Each endpoint method may consume or produce specific resource representations, which are indicated by\n+the HTTP link:{httpspec}#section-3.1.1.5[`Content-Type`] header, which in turn contains \n+link:{httpspec}#section-3.1.1.1[MIME (Media Type)] values, such as the following:\n+\n+- `text/plain` which is the default for any endpoint returning a `String`.\n+- `text/html` for HTML (such as with link:qute[Qute templating])\n+- `application/json` for a <<json,JSON REST endpoint>>\n+- `text/*` which is a sub-type wildcard for any text media type\n+- `\\*/*` which is a wildcard for any media type\n+\n+You may annotate your endpoint class with the link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces`] \n+or link:{jaxrsapi}/javax/ws/rs/Consumes.html[`@Consumes`] annotations, which\n+allow you to specify one or more media types that your endpoint may accept as HTTP request body\n+or produce as HTTP response body. Those class annotations apply to each method.\n+\n+Any method may also be annotated with the link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces`] \n+or link:{jaxrsapi}/javax/ws/rs/Consumes.html[`@Consumes`] annotations, in which\n+case they override any eventual class annotation.\n+\n+The link:{jaxrsapi}/javax/ws/rs/core/MediaType.html[`MediaType`] class has many constants you\n+can use to point to specific pre-defined media types.\n+\n+See <<negotiation>> for more information.\n+\n+=== Accessing request parameters\n+\n+[[request-parameters]]\n+\n+NOTE: don't forget to configure your compiler to generate parameter name information with `-parameters` (javac)\n+or `<parameters>` or `<maven.compiler.parameters>` (https://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html#parameters[Maven]).\n+\n+The following HTTP request elements may be obtained by your endpoint method:\n+\n+.Table HTTP request parameter annotations\n+|===\n+|HTTP element|Annotation|Usage \n+\n+|[[path-parameter]]Path parameter\n+|`@RestPath` (or nothing)\n+|URI template parameter (simplified version of the https://tools.ietf.org/html/rfc6570[URI Template specification]), \n+see <<uri-parameters,URI parameters>> for more information.\n+\n+|Query parameter\n+|`@RestQuery`\n+|The value of an https://tools.ietf.org/html/rfc3986#section-3.4[URI query parameter]\n+\n+|Header\n+|`@RestHeader`\n+|The value of an https://tools.ietf.org/html/rfc7230#section-3.2[HTTP header]\n+\n+|Cookie\n+|`@RestCookie`\n+|The value of an https://tools.ietf.org/html/rfc6265#section-4.2[HTTP cookie]\n+\n+|Form parameter\n+|`@RestForm`\n+|The value of an https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST[HTTP URL-encoded FORM]\n+\n+|Matrix parameter\n+|`@RestMatrix`\n+|The value of an https://tools.ietf.org/html/rfc3986#section-3.3[URI path segment parameter]\n+\n+|===\n+\n+For each of those annotations, you may specify the name of the element they refer to, otherwise\n+they will use the name of the annotated method parameter.\n+\n+If a client made the following HTTP call:\n+\n+[source,http]\n+----\n+POST /cheeses;variant=goat/tomme?age=matured HTTP/1.1\n+Content-Type: application/x-www-form-urlencoded\n+Cookie: level=hardcore\n+X-Cheese-Secret-Handshake: fist-bump\n+\n+smell=strong\n+----\n+\n+Then you could obtain all the various parameters with this endpoint method:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+\n+import org.jboss.resteasy.reactive.RestCookie;\n+import org.jboss.resteasy.reactive.RestForm;\n+import org.jboss.resteasy.reactive.RestHeader;\n+import org.jboss.resteasy.reactive.RestMatrix;\n+import org.jboss.resteasy.reactive.RestPath;\n+import org.jboss.resteasy.reactive.RestQuery;\n+\n+@Path(\"/cheeses/{type}\")\n+public class Endpoint {\n+\n+    @POST\n+    public String allParams(@RestPath String type,\n+                            @RestMatrix String variant,\n+                            @RestQuery String age,\n+                            @RestCookie String level,\n+                            @RestHeader(\"X-Cheese-Secret-Handshake\")\n+                            String secretHandshake,\n+                            @RestForm String smell){\n+        return type + \"/\" + variant + \"/\" + age + \"/\" + level + \"/\" + secretHandshake + \"/\" + smell;\n+    }\n+}\n+----\n+\n+NOTE: the `@RestPath` annotation is optional: any parameter whose name matches an existing URI\n+template variable will be automatically assumed to have `@RestPath`.\n+\n+You can also use any of the JAX-RS annotations link:{jaxrsapi}/javax/ws/rs/PathParam.html[`@PathParam`],\n+link:{jaxrsapi}/javax/ws/rs/QueryParam.html[`@QueryParam`],\n+link:{jaxrsapi}/javax/ws/rs/HeaderParam.html[`@HeaderParam`],\n+link:{jaxrsapi}/javax/ws/rs/CookieParam.html[`@CookieParam`],\n+link:{jaxrsapi}/javax/ws/rs/FormParam.html[`@FormParam`] or\n+link:{jaxrsapi}/javax/ws/rs/MatrixParam.html[`@MatrixParam`] for this,\n+but they require you to specify the parameter name.\n+\n+See <<parameter-mapping>> for more advanced use-cases.\n+\n+=== Declaring URI parameters\n+\n+[[uri-parameters]]\n+\n+You can declare URI parameters and use regular expressions in your path, so for instance\n+the following endpoint will serve requests for `/hello/stef/23` and `/hello` but not\n+`/hello/stef/0x23`:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+@Path(\"hello\")\n+public class Endpoint {\n+\n+    @Path(\"{name}/{age:\\\\d+}\")\n+    @GET\n+    public String personalisedHello(String name, int age){\n+        return \"Hello \" + name + \" is your age really \" + age + \"?\";\n+    }\n+\n+    @GET\n+    public String genericHello(){\n+        return \"Hello stranger\";\n+    }\n+}\n+----\n+\n+\n+=== Accessing the request body\n+\n+Any method parameter with no annotation will receive the method body.footnote:[Unless it is a\n+<<path-parameter,URI template parameter>> or a <<context-objects,context object>>.], after it has been mapped from\n+its HTTP representation to the Java type of the parameter.\n+\n+The following parameter types will be supported out of the box:\n+\n+[[resource-types]]\n+\n+.Table Request body parameter type\n+|===\n+|Type|Usage\n+\n+|link:{jdkapi}/java/io/File.html[`File`]\n+|The entire request body in a temporary file\n+\n+|`byte[]`\n+|The entire request body, not decoded\n+\n+|`char[]`\n+|The entire request body, decoded\n+\n+|link:{jdkapi}/java/lang/String.html[`String`]\n+|The entire request body, decoded\n+\n+|link:{jdkapi}/java/io/InputStream.html[`InputStream`]\n+|The request body in a blocking stream\n+\n+|link:{jdkapi}/java/io/Reader.html[`Reader`]\n+|The request body in a blocking stream\n+\n+|All Java primitives and their wrapper classes\n+|Java primitive types\n+\n+|link:{jdkapi}/java/math/BigDecimal.html[`BigDecimal`], link:{jdkapi}/java/math/BigInteger.html[`BigInteger`]\n+|Large integers and decimals.\n+\n+|link:{jsonpapi}/javax/json/JsonArray.html[`JsonArray`], link:{jsonpapi}/javax/json/JsonArray.html[`JsonObject`],\n+link:{jsonpapi}/javax/json/JsonArray.html[`JsonStructure`], link:{jsonpapi}/javax/json/JsonArray.html[`JsonValue`]\n+|JSON value types  \n+\n+|link:{vertxapi}io/vertx/core/buffer/Buffer.html[`Buffer`]\n+|Vert.x Buffer \n+\n+|any other type\n+|Will be <<json,mapped from JSON to that type>>\n+\n+|===\n+\n+NOTE: You can add support for more <<readers-writers,body parameter types>>.\n+\n+=== Returning a response body\n+\n+In order to return an HTTP response, simply return the resource you want from your method. The method\n+return type and its optional content type will be used to decide how to serialise it to the HTTP\n+response (see <<negotiation>> for more advanced information).\n+\n+You can return any of the pre-defined types that you can read from the <<resource-types,HTTP response>>,\n+and any other type will be mapped <<json,from that type to JSON>>.\n+\n+Alternately, you can also return a <<reactive,reactive type>> such as link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`], \n+link:{mutinyapi}/io/smallrye/mutiny/Multi.html[`Multi`] or \n+link:{jdkapi}/java/util/concurrent/CompletionStage.html[`CompletionStage`]\n+that resolve to one of the mentioned return types.\n+\n+=== Setting other response properties\n+\n+If you need to set more properties on the HTTP response than just the body, such as the status code\n+or headers, you can make your method return the link:{jaxrsapi}/javax/ws/rs/core/Response.html[`Response`]\n+type:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.NewCookie;\n+import javax.ws.rs.core.Response;\n+\n+@Path(\"\")\n+public class Endpoint {\n+\n+    @GET\n+    public Response hello() {\n+        // HTTP OK status with text/plain content type\n+        return Response.ok(\"Hello, World!\", MediaType.TEXT_PLAIN_TYPE)\n+         // set a response header\n+         .header(\"X-FroMage\", \"Camembert\")\n+         // set the Expires response header to two days from now\n+         .expires(Date.from(Instant.now().plus(Duration.ofDays(2))))\n+         // send a new cookie\n+         .cookie(new NewCookie(\"Flavour\", \"pralin\u00e9\"))\n+         // end of builder API\n+         .build();\n+    }\n+}\n+----\n+\n+=== Async/reactive support\n+\n+[[reactive]]\n+\n+If your endpoint method needs to accomplish an asynchronous or reactive task before\n+being able to answer, you can declare your method to return the \n+link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`] type (from https://smallrye.io/smallrye-mutiny/[Mutiny]), in which\n+case the current HTTP request will be automatically suspended after your method, until\n+the returned link:{mutinyapi}/io/smallrye/mutiny/Uni.html[`Uni`] instance resolves to a value,\n+which will be mapped to a response exactly according to the previously described rules:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"escoffier\")\n+public class Endpoint {\n+\n+    @GET\n+    public Uni<Book> culinaryGuide(){\n+        return Book.findByIsbn(\"978-2081229297\");\n+    }\n+}\n+----\n+\n+This allows you to not block the event-loop thread while the book is being fetched from the\n+database, and allows Quarkus to serve more requests until your book is ready to\n+be sent to the client and terminate this request. Check out our \n+<<execution-model,Execution Model documentation>> for more information.\n+\n+The link:{jdkapi}/java/util/concurrent/CompletionStage.html[`CompletionStage`] return\n+type is also supported.\n+\n+=== Streaming support\n+\n+If you want to stream your response element by element, you can make your endpoint method return a \n+link:{mutinyapi}/io/smallrye/mutiny/Multi.html[`Multi`] type (from https://smallrye.io/smallrye-mutiny/[Mutiny]).\n+This is especially useful for streaming text or binary data.\n+\n+This example, using link:reactive-messaging-http.html[Reactive Messaging] shows how to stream\n+text data:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import org.eclipse.microprofile.reactive.messaging.Channel;\n+\n+import io.smallrye.mutiny.Multi;\n+\n+@Path(\"logs\")\n+public class Endpoint {\n+\n+    @Inject\n+    @Channel(\"log-out\")\n+    Multi<String> logs;\n+\n+    @GET\n+    public Multi<String> streamLogs() {\n+        return logs;\n+    }\n+}\n+----\n+\n+=== Server-Sent Event (SSE) support\n+\n+If you want to stream JSON objects in your response, you can use \n+https://html.spec.whatwg.org/multipage/server-sent-events.html[Server-Sent Events]\n+by just annotating your endpoint method with \n+link:{jaxrsapi}/javax/ws/rs/Produces.html[`@Produces(MediaType.SERVER_SENT_EVENTS)`]\n+and specifying that each element should be <<json,serialised to JSON>> with \n+`@RestSseElementType(MediaType.APPLICATION_JSON)`.\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.jboss.resteasy.reactive.RestSseElementType;\n+\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+import io.smallrye.reactive.messaging.annotations.Channel;\n+\n+@Path(\"escoffier\")\n+public class Endpoint {\n+\n+    // Inject our Book channel\n+    @Inject\n+    @Channel(\"book-out\")\n+    Multi<Book> books;\n+\n+    @GET\n+    // Send the stream over SSE\n+    @Produces(MediaType.SERVER_SENT_EVENTS)\n+    // Each element will be sent as JSON\n+    @RestSseElementType(MediaType.APPLICATION_JSON)\n+    public Multi<Book> stream() {\n+        return books;\n+    }\n+}\n+----\n+\n+=== Accessing context objects\n+\n+[[context-objects]]\n+\n+There are a number of contextual objects that the framework will give you, if your endpoint\n+method takes parameters of the following type:\n+\n+.Table Context object\n+|===\n+|Type|Usage\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/HttpHeaders.html[`HttpHeaders`]\n+|All the request headers\n+\n+|link:{jaxrsapi}/javax/ws/rs/container/ResourceInfo.html[`ResourceInfo`]\n+|Information about the current endpoint method and class (requires reflection)\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/SecurityContext.html[`SecurityContext`]\n+|Access to the current user and roles\n+\n+|`SimpleResourceInfo`\n+|Information about the current endpoint method and class (no reflection required)\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/UriInfo.html[`UriInfo`]\n+|Provides information about the current endpoint and application URI\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Application.html[`Application`]\n+|Advanced: Current JAX-RS application class\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Configuration.html[`Configuration`]\n+|Advanced: Configuration about the deployed JAX-RS application\n+\n+|link:{jaxrsapi}/javax/ws/rs/ext/Providers.html[`Providers`]\n+|Advanced: Runtime access to JAX-RS providers\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/Request.html[`Request`]\n+|Advanced: Access to the current HTTP method and <<preconditions>>\n+\n+|link:{jaxrsapi}/javax/ws/rs/core/ResourceContext.html[`ResourceContext`]\n+|Advanced: access to instances of endpoints\n+\n+|`ServerRequestContext`\n+|Advanced: RESTEasy Reactive access to the current request/response\n+\n+|link:{jaxrsapi}/javax/ws/rs/sse/Sse.html[`Sse`]\n+|Advanced: Complex SSE use-cases\n+\n+|===\n+\n+For example, here is how you can return the name of the currently logged-in user:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.security.Principal;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.SecurityContext;\n+\n+@Path(\"user\")\n+public class Endpoint {\n+\n+    @GET\n+    public String userName(SecurityContext security) {\n+        Principal user = security.getUserPrincipal();\n+        return user != null ? user.getName() : \"<NOT LOGGED IN>\";\n+    }\n+}\n+----\n+\n+You can also inject those context objects using \n+https://javadoc.io/static/javax.inject/javax.inject/1/javax/inject/Inject.html[`@Inject`] on fields of the same\n+type:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.security.Principal;\n+\n+import javax.inject.Inject;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.SecurityContext;\n+\n+@Path(\"user\")\n+public class Endpoint {\n+\n+    @Inject\n+    SecurityContext security;\n+\n+    @GET\n+    public String userName() {\n+        Principal user = security.getUserPrincipal();\n+        return user != null ? user.getName() : \"<NOT LOGGED IN>\";\n+    }\n+}\n+----\n+\n+Or even on your endpoint constructor:\n+\n+[source,java]\n+----\n+package org.acme.rest;\n+\n+import java.security.Principal;\n+\n+import javax.inject.Inject;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.core.SecurityContext;\n+\n+@Path(\"user\")\n+public class Endpoint {\n+\n+    SecurityContext security;\n+\n+    @Inject", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe7dc417e95f6cf3e053ad730420379545c2333e"}, "originalPosition": 672}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NDI0ODI1", "url": "https://github.com/quarkusio/quarkus/pull/13802#pullrequestreview-549424825", "createdAt": "2020-12-10T17:16:27Z", "commit": {"oid": "a8f9fa1fa133aed771a139e70f004bc87e1ffd04"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "05bfec71bf9873a83b84484171f0ac07c6f7d5fb", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/05bfec71bf9873a83b84484171f0ac07c6f7d5fb", "committedDate": "2020-12-14T16:37:26Z", "message": "Moved to resteasy-reactive URI"}, "afterCommit": {"oid": "387a27a089b3718f622c95d5c3781d7c2a183809", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/387a27a089b3718f622c95d5c3781d7c2a183809", "committedDate": "2020-12-14T16:38:57Z", "message": "RESTEasy Reactive docs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "387a27a089b3718f622c95d5c3781d7c2a183809", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/387a27a089b3718f622c95d5c3781d7c2a183809", "committedDate": "2020-12-14T16:38:57Z", "message": "RESTEasy Reactive docs"}, "afterCommit": {"oid": "4e561c033b3a5c95ce032370838a245399ad25e5", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/4e561c033b3a5c95ce032370838a245399ad25e5", "committedDate": "2020-12-14T16:43:41Z", "message": "RESTEasy Reactive docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8cd022813ed66c71034cca6d075b16b56a3837c", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/b8cd022813ed66c71034cca6d075b16b56a3837c", "committedDate": "2020-12-16T15:38:40Z", "message": "RESTEasy Reactive docs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4e561c033b3a5c95ce032370838a245399ad25e5", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/4e561c033b3a5c95ce032370838a245399ad25e5", "committedDate": "2020-12-14T16:43:41Z", "message": "RESTEasy Reactive docs"}, "afterCommit": {"oid": "b8cd022813ed66c71034cca6d075b16b56a3837c", "author": {"user": {"login": "FroMage", "name": "St\u00e9phane \u00c9pardaud"}}, "url": "https://github.com/quarkusio/quarkus/commit/b8cd022813ed66c71034cca6d075b16b56a3837c", "committedDate": "2020-12-16T15:38:40Z", "message": "RESTEasy Reactive docs"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4271, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}