{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyMTE5NTI5", "number": 7049, "reviewThreads": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMToyODoyOVrODd1igg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNDo0Nzo1OVrODgalgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNjEyNDgyOnYy", "diffSide": "RIGHT", "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMToyODoyOVrOFmq0WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwODo1MTowNVrOFpvT9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA5MTczNw==", "bodyText": "We talked about removing this fail-fast in the previous PR, to follow hibernate-extension's approach, so I 'll do that in a next PR if that's ok, because of the open debate below.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r376091737", "createdAt": "2020-02-06T21:28:29Z", "author": {"login": "ge0ffrey"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.Capabilities;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerObjectMapperCustomizer;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerQuarkusConfig optaPlannerQuarkusConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerQuarkusConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerQuarkusConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML\n+                        + \"): that classpath resource does not exist.\");\n+            }\n+            solverConfig = SolverConfig.createFromXmlResource(solverConfigXML, classLoader);\n+        } else if (classLoader.getResource(OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL) != null) {\n+            solverConfig = SolverConfig.createFromXmlResource(\n+                    OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL, classLoader);\n+        } else {\n+            solverConfig = new SolverConfig(classLoader);\n+        }\n+        // The deployment classLoader must not escape to runtime\n+        solverConfig.setClassLoader(null);\n+\n+        IndexView indexView = combinedIndex.getIndex();\n+        applySolverProperties(recorder, recorderContext, indexView, solverConfig);\n+\n+        if (solverConfig.getSolutionClass() != null) {\n+            Type jandexType = Type.create(DotName.createSimple(solverConfig.getSolutionClass().getName()), Type.Kind.CLASS);\n+            reflectiveHierarchyClass.produce(new ReflectiveHierarchyBuildItem(jandexType));\n+        }\n+        List<Class<?>> reflectiveClassList = new ArrayList<>();\n+        ScoreDirectorFactoryConfig scoreDirectorFactoryConfig = solverConfig.getScoreDirectorFactoryConfig();\n+        if (scoreDirectorFactoryConfig != null) {\n+            if (scoreDirectorFactoryConfig.getEasyScoreCalculatorClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getEasyScoreCalculatorClass());\n+            }\n+            if (scoreDirectorFactoryConfig.getConstraintProviderClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getConstraintProviderClass());\n+            }\n+            if (scoreDirectorFactoryConfig.getIncrementalScoreCalculatorClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getIncrementalScoreCalculatorClass());\n+            }\n+        }\n+        // TODO Add Config classes to workaround for https://issues.redhat.com/browse/PLANNER-1848\n+        reflectiveClassList.add(ScoreDirectorFactoryConfig.class);\n+        reflectiveClassList.add(TerminationConfig.class);\n+        reflectiveClass.produce(\n+                new ReflectiveClassBuildItem(true, false, false,\n+                        reflectiveClassList.stream().map(Class::getName).toArray(String[]::new)));\n+\n+        SolverManagerConfig solverManagerConfig = new SolverManagerConfig();\n+        optaPlannerQuarkusConfig.solverManager.parallelSolverCount.ifPresent(solverManagerConfig::setParallelSolverCount);\n+        beanContainerListener\n+                .produce(new BeanContainerListenerBuildItem(\n+                        recorder.initialize(solverConfig, solverManagerConfig)));\n+    }\n+\n+    private void applySolverProperties(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            IndexView indexView, SolverConfig solverConfig) {\n+        if (solverConfig.getScanAnnotatedClassesConfig() != null) {\n+            throw new IllegalArgumentException(\"Do not use scanAnnotatedClasses with the Quarkus extension,\"\n+                    + \" because the Quarkus extension scans too.\\n\"\n+                    + \"Maybe delete the scanAnnotatedClasses element in the solver config.\");\n+        }\n+        if (solverConfig.getSolutionClass() == null) {\n+            solverConfig.setSolutionClass(findSolutionClass(recorderContext, indexView));\n+        }\n+        if (solverConfig.getEntityClassList() == null) {\n+            solverConfig.setEntityClassList(findEntityClassList(recorderContext, indexView));\n+        }\n+        if (solverConfig.getScoreDirectorFactoryConfig() == null) {\n+            ScoreDirectorFactoryConfig scoreDirectorFactoryConfig = new ScoreDirectorFactoryConfig();\n+            scoreDirectorFactoryConfig.setConstraintProviderClass(findConstraintProviderClass(recorderContext, indexView));\n+            solverConfig.setScoreDirectorFactoryConfig(scoreDirectorFactoryConfig);\n+        }\n+        optaPlannerQuarkusConfig.solver.environmentMode.ifPresent(solverConfig::setEnvironmentMode);\n+        optaPlannerQuarkusConfig.solver.moveThreadCount.ifPresent(solverConfig::setMoveThreadCount);\n+        applyTerminationProperties(solverConfig);\n+    }\n+\n+    private Class<?> findSolutionClass(RecorderContext recorderContext, IndexView indexView) {\n+        Collection<AnnotationInstance> annotationInstances = indexView.getAnnotations(DotNames.PLANNING_SOLUTION);\n+        if (annotationInstances.size() > 1) {\n+            throw new IllegalStateException(\"Multiple classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningSolution.class.getSimpleName() + \" annotation.\");\n+        }\n+        if (annotationInstances.isEmpty()) {\n+            throw new IllegalStateException(\"No classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningSolution.class.getSimpleName() + \" annotation.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4a6f97d8d9292fd7c73a187c9b70eb31befc661"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI4NTg3Nw==", "bodyText": "Open question, what is the behavior we want:\nA) When there is no @PlanningSolution class, fail fast (current implementation, differs from hibernate extension)\nB) When there is no @PlanningSolution class, only fail fast if there are any quarkus.optaplanner.* application.properties, otherwise do nothing\nC) When there is no @PlanningSolution class, even if there are any quarkus.optaplanner.* application.properties, always do nothing quietly\nDoes de hibernate extension do B) or C)?", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r376285877", "createdAt": "2020-02-07T09:15:02Z", "author": {"login": "ge0ffrey"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.Capabilities;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerObjectMapperCustomizer;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerQuarkusConfig optaPlannerQuarkusConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerQuarkusConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerQuarkusConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML\n+                        + \"): that classpath resource does not exist.\");\n+            }\n+            solverConfig = SolverConfig.createFromXmlResource(solverConfigXML, classLoader);\n+        } else if (classLoader.getResource(OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL) != null) {\n+            solverConfig = SolverConfig.createFromXmlResource(\n+                    OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL, classLoader);\n+        } else {\n+            solverConfig = new SolverConfig(classLoader);\n+        }\n+        // The deployment classLoader must not escape to runtime\n+        solverConfig.setClassLoader(null);\n+\n+        IndexView indexView = combinedIndex.getIndex();\n+        applySolverProperties(recorder, recorderContext, indexView, solverConfig);\n+\n+        if (solverConfig.getSolutionClass() != null) {\n+            Type jandexType = Type.create(DotName.createSimple(solverConfig.getSolutionClass().getName()), Type.Kind.CLASS);\n+            reflectiveHierarchyClass.produce(new ReflectiveHierarchyBuildItem(jandexType));\n+        }\n+        List<Class<?>> reflectiveClassList = new ArrayList<>();\n+        ScoreDirectorFactoryConfig scoreDirectorFactoryConfig = solverConfig.getScoreDirectorFactoryConfig();\n+        if (scoreDirectorFactoryConfig != null) {\n+            if (scoreDirectorFactoryConfig.getEasyScoreCalculatorClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getEasyScoreCalculatorClass());\n+            }\n+            if (scoreDirectorFactoryConfig.getConstraintProviderClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getConstraintProviderClass());\n+            }\n+            if (scoreDirectorFactoryConfig.getIncrementalScoreCalculatorClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getIncrementalScoreCalculatorClass());\n+            }\n+        }\n+        // TODO Add Config classes to workaround for https://issues.redhat.com/browse/PLANNER-1848\n+        reflectiveClassList.add(ScoreDirectorFactoryConfig.class);\n+        reflectiveClassList.add(TerminationConfig.class);\n+        reflectiveClass.produce(\n+                new ReflectiveClassBuildItem(true, false, false,\n+                        reflectiveClassList.stream().map(Class::getName).toArray(String[]::new)));\n+\n+        SolverManagerConfig solverManagerConfig = new SolverManagerConfig();\n+        optaPlannerQuarkusConfig.solverManager.parallelSolverCount.ifPresent(solverManagerConfig::setParallelSolverCount);\n+        beanContainerListener\n+                .produce(new BeanContainerListenerBuildItem(\n+                        recorder.initialize(solverConfig, solverManagerConfig)));\n+    }\n+\n+    private void applySolverProperties(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            IndexView indexView, SolverConfig solverConfig) {\n+        if (solverConfig.getScanAnnotatedClassesConfig() != null) {\n+            throw new IllegalArgumentException(\"Do not use scanAnnotatedClasses with the Quarkus extension,\"\n+                    + \" because the Quarkus extension scans too.\\n\"\n+                    + \"Maybe delete the scanAnnotatedClasses element in the solver config.\");\n+        }\n+        if (solverConfig.getSolutionClass() == null) {\n+            solverConfig.setSolutionClass(findSolutionClass(recorderContext, indexView));\n+        }\n+        if (solverConfig.getEntityClassList() == null) {\n+            solverConfig.setEntityClassList(findEntityClassList(recorderContext, indexView));\n+        }\n+        if (solverConfig.getScoreDirectorFactoryConfig() == null) {\n+            ScoreDirectorFactoryConfig scoreDirectorFactoryConfig = new ScoreDirectorFactoryConfig();\n+            scoreDirectorFactoryConfig.setConstraintProviderClass(findConstraintProviderClass(recorderContext, indexView));\n+            solverConfig.setScoreDirectorFactoryConfig(scoreDirectorFactoryConfig);\n+        }\n+        optaPlannerQuarkusConfig.solver.environmentMode.ifPresent(solverConfig::setEnvironmentMode);\n+        optaPlannerQuarkusConfig.solver.moveThreadCount.ifPresent(solverConfig::setMoveThreadCount);\n+        applyTerminationProperties(solverConfig);\n+    }\n+\n+    private Class<?> findSolutionClass(RecorderContext recorderContext, IndexView indexView) {\n+        Collection<AnnotationInstance> annotationInstances = indexView.getAnnotations(DotNames.PLANNING_SOLUTION);\n+        if (annotationInstances.size() > 1) {\n+            throw new IllegalStateException(\"Multiple classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningSolution.class.getSimpleName() + \" annotation.\");\n+        }\n+        if (annotationInstances.isEmpty()) {\n+            throw new IllegalStateException(\"No classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningSolution.class.getSimpleName() + \" annotation.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA5MTczNw=="}, "originalCommit": {"oid": "f4a6f97d8d9292fd7c73a187c9b70eb31befc661"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI4NjYxOQ==", "bodyText": "I presume A) is a PITA when doing demo's where you grab something from code.quarkus.io and it doesn't \"just run\"?", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r376286619", "createdAt": "2020-02-07T09:16:45Z", "author": {"login": "ge0ffrey"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.Capabilities;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerObjectMapperCustomizer;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerQuarkusConfig optaPlannerQuarkusConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerQuarkusConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerQuarkusConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML\n+                        + \"): that classpath resource does not exist.\");\n+            }\n+            solverConfig = SolverConfig.createFromXmlResource(solverConfigXML, classLoader);\n+        } else if (classLoader.getResource(OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL) != null) {\n+            solverConfig = SolverConfig.createFromXmlResource(\n+                    OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL, classLoader);\n+        } else {\n+            solverConfig = new SolverConfig(classLoader);\n+        }\n+        // The deployment classLoader must not escape to runtime\n+        solverConfig.setClassLoader(null);\n+\n+        IndexView indexView = combinedIndex.getIndex();\n+        applySolverProperties(recorder, recorderContext, indexView, solverConfig);\n+\n+        if (solverConfig.getSolutionClass() != null) {\n+            Type jandexType = Type.create(DotName.createSimple(solverConfig.getSolutionClass().getName()), Type.Kind.CLASS);\n+            reflectiveHierarchyClass.produce(new ReflectiveHierarchyBuildItem(jandexType));\n+        }\n+        List<Class<?>> reflectiveClassList = new ArrayList<>();\n+        ScoreDirectorFactoryConfig scoreDirectorFactoryConfig = solverConfig.getScoreDirectorFactoryConfig();\n+        if (scoreDirectorFactoryConfig != null) {\n+            if (scoreDirectorFactoryConfig.getEasyScoreCalculatorClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getEasyScoreCalculatorClass());\n+            }\n+            if (scoreDirectorFactoryConfig.getConstraintProviderClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getConstraintProviderClass());\n+            }\n+            if (scoreDirectorFactoryConfig.getIncrementalScoreCalculatorClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getIncrementalScoreCalculatorClass());\n+            }\n+        }\n+        // TODO Add Config classes to workaround for https://issues.redhat.com/browse/PLANNER-1848\n+        reflectiveClassList.add(ScoreDirectorFactoryConfig.class);\n+        reflectiveClassList.add(TerminationConfig.class);\n+        reflectiveClass.produce(\n+                new ReflectiveClassBuildItem(true, false, false,\n+                        reflectiveClassList.stream().map(Class::getName).toArray(String[]::new)));\n+\n+        SolverManagerConfig solverManagerConfig = new SolverManagerConfig();\n+        optaPlannerQuarkusConfig.solverManager.parallelSolverCount.ifPresent(solverManagerConfig::setParallelSolverCount);\n+        beanContainerListener\n+                .produce(new BeanContainerListenerBuildItem(\n+                        recorder.initialize(solverConfig, solverManagerConfig)));\n+    }\n+\n+    private void applySolverProperties(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            IndexView indexView, SolverConfig solverConfig) {\n+        if (solverConfig.getScanAnnotatedClassesConfig() != null) {\n+            throw new IllegalArgumentException(\"Do not use scanAnnotatedClasses with the Quarkus extension,\"\n+                    + \" because the Quarkus extension scans too.\\n\"\n+                    + \"Maybe delete the scanAnnotatedClasses element in the solver config.\");\n+        }\n+        if (solverConfig.getSolutionClass() == null) {\n+            solverConfig.setSolutionClass(findSolutionClass(recorderContext, indexView));\n+        }\n+        if (solverConfig.getEntityClassList() == null) {\n+            solverConfig.setEntityClassList(findEntityClassList(recorderContext, indexView));\n+        }\n+        if (solverConfig.getScoreDirectorFactoryConfig() == null) {\n+            ScoreDirectorFactoryConfig scoreDirectorFactoryConfig = new ScoreDirectorFactoryConfig();\n+            scoreDirectorFactoryConfig.setConstraintProviderClass(findConstraintProviderClass(recorderContext, indexView));\n+            solverConfig.setScoreDirectorFactoryConfig(scoreDirectorFactoryConfig);\n+        }\n+        optaPlannerQuarkusConfig.solver.environmentMode.ifPresent(solverConfig::setEnvironmentMode);\n+        optaPlannerQuarkusConfig.solver.moveThreadCount.ifPresent(solverConfig::setMoveThreadCount);\n+        applyTerminationProperties(solverConfig);\n+    }\n+\n+    private Class<?> findSolutionClass(RecorderContext recorderContext, IndexView indexView) {\n+        Collection<AnnotationInstance> annotationInstances = indexView.getAnnotations(DotNames.PLANNING_SOLUTION);\n+        if (annotationInstances.size() > 1) {\n+            throw new IllegalStateException(\"Multiple classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningSolution.class.getSimpleName() + \" annotation.\");\n+        }\n+        if (annotationInstances.isEmpty()) {\n+            throw new IllegalStateException(\"No classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningSolution.class.getSimpleName() + \" annotation.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA5MTczNw=="}, "originalCommit": {"oid": "f4a6f97d8d9292fd7c73a187c9b70eb31befc661"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMTA5NQ==", "bodyText": "Yeah. I would avoid A). I would do C with a warning instead of staying quiet if some configuration properties are defined.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379311095", "createdAt": "2020-02-14T08:51:05Z", "author": {"login": "gsmet"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.Capabilities;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerObjectMapperCustomizer;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerQuarkusConfig optaPlannerQuarkusConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerQuarkusConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerQuarkusConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML\n+                        + \"): that classpath resource does not exist.\");\n+            }\n+            solverConfig = SolverConfig.createFromXmlResource(solverConfigXML, classLoader);\n+        } else if (classLoader.getResource(OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL) != null) {\n+            solverConfig = SolverConfig.createFromXmlResource(\n+                    OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL, classLoader);\n+        } else {\n+            solverConfig = new SolverConfig(classLoader);\n+        }\n+        // The deployment classLoader must not escape to runtime\n+        solverConfig.setClassLoader(null);\n+\n+        IndexView indexView = combinedIndex.getIndex();\n+        applySolverProperties(recorder, recorderContext, indexView, solverConfig);\n+\n+        if (solverConfig.getSolutionClass() != null) {\n+            Type jandexType = Type.create(DotName.createSimple(solverConfig.getSolutionClass().getName()), Type.Kind.CLASS);\n+            reflectiveHierarchyClass.produce(new ReflectiveHierarchyBuildItem(jandexType));\n+        }\n+        List<Class<?>> reflectiveClassList = new ArrayList<>();\n+        ScoreDirectorFactoryConfig scoreDirectorFactoryConfig = solverConfig.getScoreDirectorFactoryConfig();\n+        if (scoreDirectorFactoryConfig != null) {\n+            if (scoreDirectorFactoryConfig.getEasyScoreCalculatorClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getEasyScoreCalculatorClass());\n+            }\n+            if (scoreDirectorFactoryConfig.getConstraintProviderClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getConstraintProviderClass());\n+            }\n+            if (scoreDirectorFactoryConfig.getIncrementalScoreCalculatorClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getIncrementalScoreCalculatorClass());\n+            }\n+        }\n+        // TODO Add Config classes to workaround for https://issues.redhat.com/browse/PLANNER-1848\n+        reflectiveClassList.add(ScoreDirectorFactoryConfig.class);\n+        reflectiveClassList.add(TerminationConfig.class);\n+        reflectiveClass.produce(\n+                new ReflectiveClassBuildItem(true, false, false,\n+                        reflectiveClassList.stream().map(Class::getName).toArray(String[]::new)));\n+\n+        SolverManagerConfig solverManagerConfig = new SolverManagerConfig();\n+        optaPlannerQuarkusConfig.solverManager.parallelSolverCount.ifPresent(solverManagerConfig::setParallelSolverCount);\n+        beanContainerListener\n+                .produce(new BeanContainerListenerBuildItem(\n+                        recorder.initialize(solverConfig, solverManagerConfig)));\n+    }\n+\n+    private void applySolverProperties(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            IndexView indexView, SolverConfig solverConfig) {\n+        if (solverConfig.getScanAnnotatedClassesConfig() != null) {\n+            throw new IllegalArgumentException(\"Do not use scanAnnotatedClasses with the Quarkus extension,\"\n+                    + \" because the Quarkus extension scans too.\\n\"\n+                    + \"Maybe delete the scanAnnotatedClasses element in the solver config.\");\n+        }\n+        if (solverConfig.getSolutionClass() == null) {\n+            solverConfig.setSolutionClass(findSolutionClass(recorderContext, indexView));\n+        }\n+        if (solverConfig.getEntityClassList() == null) {\n+            solverConfig.setEntityClassList(findEntityClassList(recorderContext, indexView));\n+        }\n+        if (solverConfig.getScoreDirectorFactoryConfig() == null) {\n+            ScoreDirectorFactoryConfig scoreDirectorFactoryConfig = new ScoreDirectorFactoryConfig();\n+            scoreDirectorFactoryConfig.setConstraintProviderClass(findConstraintProviderClass(recorderContext, indexView));\n+            solverConfig.setScoreDirectorFactoryConfig(scoreDirectorFactoryConfig);\n+        }\n+        optaPlannerQuarkusConfig.solver.environmentMode.ifPresent(solverConfig::setEnvironmentMode);\n+        optaPlannerQuarkusConfig.solver.moveThreadCount.ifPresent(solverConfig::setMoveThreadCount);\n+        applyTerminationProperties(solverConfig);\n+    }\n+\n+    private Class<?> findSolutionClass(RecorderContext recorderContext, IndexView indexView) {\n+        Collection<AnnotationInstance> annotationInstances = indexView.getAnnotations(DotNames.PLANNING_SOLUTION);\n+        if (annotationInstances.size() > 1) {\n+            throw new IllegalStateException(\"Multiple classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningSolution.class.getSimpleName() + \" annotation.\");\n+        }\n+        if (annotationInstances.isEmpty()) {\n+            throw new IllegalStateException(\"No classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningSolution.class.getSimpleName() + \" annotation.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA5MTczNw=="}, "originalCommit": {"oid": "f4a6f97d8d9292fd7c73a187c9b70eb31befc661"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MDEwODU3OnYy", "diffSide": "RIGHT", "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMzowODo0M1rOFot2_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMTo0NToyNVrOFp0Exw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIzODcxNw==", "bodyText": "Just out of curiosity, what CL will be used at runtime as a result of this?", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378238717", "createdAt": "2020-02-12T13:08:43Z", "author": {"login": "geoand"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.Capabilities;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerObjectMapperCustomizer;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerQuarkusConfig optaPlannerQuarkusConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerQuarkusConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerQuarkusConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML\n+                        + \"): that classpath resource does not exist.\");\n+            }\n+            solverConfig = SolverConfig.createFromXmlResource(solverConfigXML, classLoader);\n+        } else if (classLoader.getResource(OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL) != null) {\n+            solverConfig = SolverConfig.createFromXmlResource(\n+                    OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL, classLoader);\n+        } else {\n+            solverConfig = new SolverConfig(classLoader);\n+        }\n+        // The deployment classLoader must not escape to runtime\n+        solverConfig.setClassLoader(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI1OTk1MQ==", "bodyText": "Most of the time, it's not used, except if a scoreDRL is active.\nIf it's null in that case, ScoreDirectorFactoryConfig does this at runtime, during SolverFactory.buildSolver():\nClassLoader actualClassLoader = (classLoader != null) ? classLoader : getClass().getClassLoader();\n\nOnce we start doing more work during the static init, after we internalize the SolverConfig in the SolverFactory (currently impossible due to deprecated methods that will dissappear in 8.0), I 'll have to come back to this, as that code might become a problem then.\nGood question indeed. :)", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378259951", "createdAt": "2020-02-12T13:48:18Z", "author": {"login": "ge0ffrey"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.Capabilities;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerObjectMapperCustomizer;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerQuarkusConfig optaPlannerQuarkusConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerQuarkusConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerQuarkusConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML\n+                        + \"): that classpath resource does not exist.\");\n+            }\n+            solverConfig = SolverConfig.createFromXmlResource(solverConfigXML, classLoader);\n+        } else if (classLoader.getResource(OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL) != null) {\n+            solverConfig = SolverConfig.createFromXmlResource(\n+                    OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL, classLoader);\n+        } else {\n+            solverConfig = new SolverConfig(classLoader);\n+        }\n+        // The deployment classLoader must not escape to runtime\n+        solverConfig.setClassLoader(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIzODcxNw=="}, "originalCommit": {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI2MjY0MQ==", "bodyText": "What am I sort of worried about is the dev-mode. There are certain situations where getClass().getClassLoader() might not give you what you expect.\nPerhaps also adding QuarkusDevModeTest is a good idea to make sure things work properly?", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378262641", "createdAt": "2020-02-12T13:52:59Z", "author": {"login": "geoand"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.Capabilities;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerObjectMapperCustomizer;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerQuarkusConfig optaPlannerQuarkusConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerQuarkusConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerQuarkusConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML\n+                        + \"): that classpath resource does not exist.\");\n+            }\n+            solverConfig = SolverConfig.createFromXmlResource(solverConfigXML, classLoader);\n+        } else if (classLoader.getResource(OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL) != null) {\n+            solverConfig = SolverConfig.createFromXmlResource(\n+                    OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL, classLoader);\n+        } else {\n+            solverConfig = new SolverConfig(classLoader);\n+        }\n+        // The deployment classLoader must not escape to runtime\n+        solverConfig.setClassLoader(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIzODcxNw=="}, "originalCommit": {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI4NTUwNQ==", "bodyText": "I 've been trying to add in QuarkusDevModeTest, but I reluctant to add a test that doesn't work in IntelliJ (it hurts productivity). In IntelliJ I get the \"Undeclared build item class io.quarkus.deployment.builditem.ApplicationClassNameBuildItem\" exception, but on the command line, I don't.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379285505", "createdAt": "2020-02-14T07:35:38Z", "author": {"login": "ge0ffrey"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.Capabilities;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerObjectMapperCustomizer;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerQuarkusConfig optaPlannerQuarkusConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerQuarkusConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerQuarkusConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML\n+                        + \"): that classpath resource does not exist.\");\n+            }\n+            solverConfig = SolverConfig.createFromXmlResource(solverConfigXML, classLoader);\n+        } else if (classLoader.getResource(OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL) != null) {\n+            solverConfig = SolverConfig.createFromXmlResource(\n+                    OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL, classLoader);\n+        } else {\n+            solverConfig = new SolverConfig(classLoader);\n+        }\n+        // The deployment classLoader must not escape to runtime\n+        solverConfig.setClassLoader(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIzODcxNw=="}, "originalCommit": {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI5MjA3OQ==", "bodyText": "IntelliJ can mess up the classpath when running tests inside the Quarkus repo. I don't think it's something we need to worry about", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379292079", "createdAt": "2020-02-14T07:58:07Z", "author": {"login": "geoand"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.Capabilities;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerObjectMapperCustomizer;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerQuarkusConfig optaPlannerQuarkusConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerQuarkusConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerQuarkusConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML\n+                        + \"): that classpath resource does not exist.\");\n+            }\n+            solverConfig = SolverConfig.createFromXmlResource(solverConfigXML, classLoader);\n+        } else if (classLoader.getResource(OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL) != null) {\n+            solverConfig = SolverConfig.createFromXmlResource(\n+                    OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL, classLoader);\n+        } else {\n+            solverConfig = new SolverConfig(classLoader);\n+        }\n+        // The deployment classLoader must not escape to runtime\n+        solverConfig.setClassLoader(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIzODcxNw=="}, "originalCommit": {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMDA0Nw==", "bodyText": "Would it be possible to change that logic to use the TCCL if null?", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379310047", "createdAt": "2020-02-14T08:48:41Z", "author": {"login": "gsmet"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.Capabilities;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerObjectMapperCustomizer;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerQuarkusConfig optaPlannerQuarkusConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerQuarkusConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerQuarkusConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML\n+                        + \"): that classpath resource does not exist.\");\n+            }\n+            solverConfig = SolverConfig.createFromXmlResource(solverConfigXML, classLoader);\n+        } else if (classLoader.getResource(OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL) != null) {\n+            solverConfig = SolverConfig.createFromXmlResource(\n+                    OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL, classLoader);\n+        } else {\n+            solverConfig = new SolverConfig(classLoader);\n+        }\n+        // The deployment classLoader must not escape to runtime\n+        solverConfig.setClassLoader(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIzODcxNw=="}, "originalCommit": {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM0ODkwNA==", "bodyText": "The dev mode test should prove that things are OK with this change.\nTo be 100% Quarkus compliant, upstream here should provide a flag to use the TCCL (of the time of execution) when the classloader is null, but I don't think we need it now", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379348904", "createdAt": "2020-02-14T10:12:03Z", "author": {"login": "geoand"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.Capabilities;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerObjectMapperCustomizer;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerQuarkusConfig optaPlannerQuarkusConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerQuarkusConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerQuarkusConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML\n+                        + \"): that classpath resource does not exist.\");\n+            }\n+            solverConfig = SolverConfig.createFromXmlResource(solverConfigXML, classLoader);\n+        } else if (classLoader.getResource(OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL) != null) {\n+            solverConfig = SolverConfig.createFromXmlResource(\n+                    OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL, classLoader);\n+        } else {\n+            solverConfig = new SolverConfig(classLoader);\n+        }\n+        // The deployment classLoader must not escape to runtime\n+        solverConfig.setClassLoader(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIzODcxNw=="}, "originalCommit": {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM4OTEyNw==", "bodyText": "Using ThreadContextClassLoader is what it does by default if we don't set it to null.\nWhen I remove the solverConfig.setClassLoader(null); line, I get\nCaused by: java.lang.RuntimeException: Unable to serialize objects of type class io.quarkus.bootstrap.classloading.QuarkusClassLoader to bytecode as it has no default constructor\n        at io.quarkus.deployment.recording.BytecodeRecorderImpl$53.createValue(BytecodeRecorderImpl.java:1273)", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379389127", "createdAt": "2020-02-14T11:45:25Z", "author": {"login": "ge0ffrey"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.Capabilities;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerObjectMapperCustomizer;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerQuarkusConfig optaPlannerQuarkusConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerQuarkusConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerQuarkusConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML\n+                        + \"): that classpath resource does not exist.\");\n+            }\n+            solverConfig = SolverConfig.createFromXmlResource(solverConfigXML, classLoader);\n+        } else if (classLoader.getResource(OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL) != null) {\n+            solverConfig = SolverConfig.createFromXmlResource(\n+                    OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL, classLoader);\n+        } else {\n+            solverConfig = new SolverConfig(classLoader);\n+        }\n+        // The deployment classLoader must not escape to runtime\n+        solverConfig.setClassLoader(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIzODcxNw=="}, "originalCommit": {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MDE0MTg3OnYy", "diffSide": "RIGHT", "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMzoxOToyMlrOFouLyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwNzo0NTo0NVrOFpJvuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI0NDA0Mw==", "bodyText": "Maybe add a capacity, it looks like 5 is the max this can ever get, right?", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378244043", "createdAt": "2020-02-12T13:19:22Z", "author": {"login": "geoand"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.Capabilities;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerObjectMapperCustomizer;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerQuarkusConfig optaPlannerQuarkusConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerQuarkusConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerQuarkusConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML\n+                        + \"): that classpath resource does not exist.\");\n+            }\n+            solverConfig = SolverConfig.createFromXmlResource(solverConfigXML, classLoader);\n+        } else if (classLoader.getResource(OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL) != null) {\n+            solverConfig = SolverConfig.createFromXmlResource(\n+                    OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL, classLoader);\n+        } else {\n+            solverConfig = new SolverConfig(classLoader);\n+        }\n+        // The deployment classLoader must not escape to runtime\n+        solverConfig.setClassLoader(null);\n+\n+        IndexView indexView = combinedIndex.getIndex();\n+        applySolverProperties(recorder, recorderContext, indexView, solverConfig);\n+\n+        if (solverConfig.getSolutionClass() != null) {\n+            Type jandexType = Type.create(DotName.createSimple(solverConfig.getSolutionClass().getName()), Type.Kind.CLASS);\n+            reflectiveHierarchyClass.produce(new ReflectiveHierarchyBuildItem(jandexType));\n+        }\n+        List<Class<?>> reflectiveClassList = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY5NTYwOA==", "bodyText": "Fixed with new commit on this fork.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378695608", "createdAt": "2020-02-13T07:45:45Z", "author": {"login": "ge0ffrey"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.Capabilities;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerObjectMapperCustomizer;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerQuarkusConfig optaPlannerQuarkusConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerQuarkusConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerQuarkusConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML\n+                        + \"): that classpath resource does not exist.\");\n+            }\n+            solverConfig = SolverConfig.createFromXmlResource(solverConfigXML, classLoader);\n+        } else if (classLoader.getResource(OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL) != null) {\n+            solverConfig = SolverConfig.createFromXmlResource(\n+                    OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL, classLoader);\n+        } else {\n+            solverConfig = new SolverConfig(classLoader);\n+        }\n+        // The deployment classLoader must not escape to runtime\n+        solverConfig.setClassLoader(null);\n+\n+        IndexView indexView = combinedIndex.getIndex();\n+        applySolverProperties(recorder, recorderContext, indexView, solverConfig);\n+\n+        if (solverConfig.getSolutionClass() != null) {\n+            Type jandexType = Type.create(DotName.createSimple(solverConfig.getSolutionClass().getName()), Type.Kind.CLASS);\n+            reflectiveHierarchyClass.produce(new ReflectiveHierarchyBuildItem(jandexType));\n+        }\n+        List<Class<?>> reflectiveClassList = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI0NDA0Mw=="}, "originalCommit": {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MDE3NzkzOnYy", "diffSide": "RIGHT", "path": "extensions/optaplanner/runtime/pom.xml", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMzoyOTo1OFrOFouhvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMTo0NDozNFrOFp0Diw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI0OTY2Mw==", "bodyText": "Hm, have you tested to make sure this behaves the way you expect it to? And are you sure that OptaPlannerObjectMapperCustomizer is never loaded it the user doesn't add quarkus-jackson.\n@gsmet WDYT about this pattern? I know it's not the way we have been doing things so far, but I do remember @ge0ffrey had a UX issue in mind when doing this, but I don't remember what it was :)", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378249663", "createdAt": "2020-02-12T13:29:58Z", "author": {"login": "geoand"}, "path": "extensions/optaplanner/runtime/pom.xml", "diffHunk": "@@ -0,0 +1,113 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-optaplanner-parent</artifactId>\n+        <version>999-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>quarkus-optaplanner</artifactId>\n+    <name>Quarkus - OptaPlanner - Runtime</name>\n+    <description>Constraint solving AI for employee rostering, vehicle routing, maintenance scheduling, school timetabling, etc</description>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-core</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-arc</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-jackson</artifactId>\n+            <optional>true</optional>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI2Mzk1OQ==", "bodyText": "I'll check if that customizer is loaded or not. It shouldn't be, but I indeed need to verify.\nI am doing it this way, because:\n\nHaving an extra extension quarkus-optaplanner-jackson-extension (and jaxb, jpa, etc), means users must explicitly add it. That's another hoop to jump through. If they forget to do that, the json marshalling of Score etc defaults to reflection way, which is hard to detect for new users.\noptaplanner-spring-boot-starter does it this way, it's automagic configuration. No hoop to jump through.\n\nIf you guys insist, we can switch to the normal pattern - or leave out the jackson integration entirely for now into a separate PR so the rest can be merged already.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378263959", "createdAt": "2020-02-12T13:55:09Z", "author": {"login": "ge0ffrey"}, "path": "extensions/optaplanner/runtime/pom.xml", "diffHunk": "@@ -0,0 +1,113 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-optaplanner-parent</artifactId>\n+        <version>999-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>quarkus-optaplanner</artifactId>\n+    <name>Quarkus - OptaPlanner - Runtime</name>\n+    <description>Constraint solving AI for employee rostering, vehicle routing, maintenance scheduling, school timetabling, etc</description>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-core</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-arc</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-jackson</artifactId>\n+            <optional>true</optional>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI0OTY2Mw=="}, "originalCommit": {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxNDA2Mw==", "bodyText": "Well, they would have to add the optaplanner Jackson dependency anyway, no? That's not very different from adding an extension.\nI wouldn't make it a blocker to merge this PR if we are sure everything works when Jackson is not there.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379314063", "createdAt": "2020-02-14T08:57:55Z", "author": {"login": "gsmet"}, "path": "extensions/optaplanner/runtime/pom.xml", "diffHunk": "@@ -0,0 +1,113 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-optaplanner-parent</artifactId>\n+        <version>999-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>quarkus-optaplanner</artifactId>\n+    <name>Quarkus - OptaPlanner - Runtime</name>\n+    <description>Constraint solving AI for employee rostering, vehicle routing, maintenance scheduling, school timetabling, etc</description>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-core</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-arc</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-jackson</artifactId>\n+            <optional>true</optional>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI0OTY2Mw=="}, "originalCommit": {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM4ODgxMQ==", "bodyText": "Fixed by extracting new quarkus-optaplanner-jackson module", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379388811", "createdAt": "2020-02-14T11:44:34Z", "author": {"login": "ge0ffrey"}, "path": "extensions/optaplanner/runtime/pom.xml", "diffHunk": "@@ -0,0 +1,113 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-optaplanner-parent</artifactId>\n+        <version>999-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>quarkus-optaplanner</artifactId>\n+    <name>Quarkus - OptaPlanner - Runtime</name>\n+    <description>Constraint solving AI for employee rostering, vehicle routing, maintenance scheduling, school timetabling, etc</description>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-core</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-arc</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-jackson</artifactId>\n+            <optional>true</optional>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI0OTY2Mw=="}, "originalCommit": {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MDE4MzI5OnYy", "diffSide": "RIGHT", "path": "extensions/optaplanner/runtime/src/main/java/io/quarkus/optaplanner/OptaPlannerObjectMapperCustomizer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMzozMToyMFrOFouk6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwNzo0NTozNVrOFpJvgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI1MDQ3Mg==", "bodyText": "IIRC, this isn't picked up automatically because it's part of the module and therefore if the user doesn't have Jackson you don't register the bean.\nPerhaps this warrants a comment on this class as to how things have been done and why because I am sure we will forget about it in the future", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378250472", "createdAt": "2020-02-12T13:31:20Z", "author": {"login": "geoand"}, "path": "extensions/optaplanner/runtime/src/main/java/io/quarkus/optaplanner/OptaPlannerObjectMapperCustomizer.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package io.quarkus.optaplanner;\n+\n+import javax.inject.Singleton;\n+\n+import org.optaplanner.persistence.jackson.api.OptaPlannerJacksonModule;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import io.quarkus.jackson.ObjectMapperCustomizer;\n+\n+@Singleton\n+public class OptaPlannerObjectMapperCustomizer implements ObjectMapperCustomizer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMxNDY5OQ==", "bodyText": "Adding this javadoc\n/**\n * Only registered if the Jackson capability is active.\n * OptaPlanner doesn't use Jackson, but it does have optional Jackson support for {@link Score}, etc.\n */", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378314699", "createdAt": "2020-02-12T15:14:27Z", "author": {"login": "ge0ffrey"}, "path": "extensions/optaplanner/runtime/src/main/java/io/quarkus/optaplanner/OptaPlannerObjectMapperCustomizer.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package io.quarkus.optaplanner;\n+\n+import javax.inject.Singleton;\n+\n+import org.optaplanner.persistence.jackson.api.OptaPlannerJacksonModule;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import io.quarkus.jackson.ObjectMapperCustomizer;\n+\n+@Singleton\n+public class OptaPlannerObjectMapperCustomizer implements ObjectMapperCustomizer {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI1MDQ3Mg=="}, "originalCommit": {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY5NTU1Mg==", "bodyText": "Fixed with new commit on this fork.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378695552", "createdAt": "2020-02-13T07:45:35Z", "author": {"login": "ge0ffrey"}, "path": "extensions/optaplanner/runtime/src/main/java/io/quarkus/optaplanner/OptaPlannerObjectMapperCustomizer.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package io.quarkus.optaplanner;\n+\n+import javax.inject.Singleton;\n+\n+import org.optaplanner.persistence.jackson.api.OptaPlannerJacksonModule;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import io.quarkus.jackson.ObjectMapperCustomizer;\n+\n+@Singleton\n+public class OptaPlannerObjectMapperCustomizer implements ObjectMapperCustomizer {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI1MDQ3Mg=="}, "originalCommit": {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MDE5NTMxOnYy", "diffSide": "RIGHT", "path": "integration-tests/optaplanner/pom.xml", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMzozNDo0NVrOFousJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwNzo0NToyN1rOFpJvVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI1MjMyNA==", "bodyText": "Can you please update this profile to use what the spring-data-jpa integration test does please? Essentially most of the integration tests use the old way of configuing the native execution, but we want to move to the new way of doing things :)", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378252324", "createdAt": "2020-02-12T13:34:45Z", "author": {"login": "geoand"}, "path": "integration-tests/optaplanner/pom.xml", "diffHunk": "@@ -0,0 +1,142 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <parent>\n+        <artifactId>quarkus-integration-tests-parent</artifactId>\n+        <groupId>io.quarkus</groupId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../</relativePath>\n+    </parent>\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <artifactId>quarkus-integration-test-optaplanner</artifactId>\n+    <name>Quarkus - Integration Tests - OptaPlanner</name>\n+    <description>Module that contains OptaPlanner related tests</description>\n+\n+    <properties>\n+        <maven.compiler.parameters>true</maven.compiler.parameters>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-arc</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-resteasy</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-resteasy-jackson</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-optaplanner</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.optaplanner</groupId>\n+            <artifactId>optaplanner-persistence-jackson</artifactId>\n+        </dependency>\n+\n+        <!-- test dependencies -->\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-junit5</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.rest-assured</groupId>\n+            <artifactId>rest-assured</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <resources>\n+            <resource>\n+                <directory>src/main/resources</directory>\n+                <filtering>true</filtering>\n+            </resource>\n+        </resources>\n+        <plugins>\n+            <plugin>\n+                <groupId>io.quarkus</groupId>\n+                <artifactId>quarkus-maven-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <goals>\n+                            <goal>build</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <!-- force the locale as we want to explicitly test message interpolation -->\n+                    <argLine>-Duser.language=en</argLine>\n+                </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+\n+    <profiles>\n+        <profile>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI2NTY5Mw==", "bodyText": "The spring-data-jpa integration test? Do I have anything like that? I don't understand.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378265693", "createdAt": "2020-02-12T13:58:09Z", "author": {"login": "ge0ffrey"}, "path": "integration-tests/optaplanner/pom.xml", "diffHunk": "@@ -0,0 +1,142 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <parent>\n+        <artifactId>quarkus-integration-tests-parent</artifactId>\n+        <groupId>io.quarkus</groupId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../</relativePath>\n+    </parent>\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <artifactId>quarkus-integration-test-optaplanner</artifactId>\n+    <name>Quarkus - Integration Tests - OptaPlanner</name>\n+    <description>Module that contains OptaPlanner related tests</description>\n+\n+    <properties>\n+        <maven.compiler.parameters>true</maven.compiler.parameters>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-arc</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-resteasy</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-resteasy-jackson</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-optaplanner</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.optaplanner</groupId>\n+            <artifactId>optaplanner-persistence-jackson</artifactId>\n+        </dependency>\n+\n+        <!-- test dependencies -->\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-junit5</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.rest-assured</groupId>\n+            <artifactId>rest-assured</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <resources>\n+            <resource>\n+                <directory>src/main/resources</directory>\n+                <filtering>true</filtering>\n+            </resource>\n+        </resources>\n+        <plugins>\n+            <plugin>\n+                <groupId>io.quarkus</groupId>\n+                <artifactId>quarkus-maven-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <goals>\n+                            <goal>build</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <!-- force the locale as we want to explicitly test message interpolation -->\n+                    <argLine>-Duser.language=en</argLine>\n+                </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+\n+    <profiles>\n+        <profile>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI1MjMyNA=="}, "originalCommit": {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI2NTk1Ng==", "bodyText": "Ah, I get it. I need to follow the spring-data-jpa approach. I 'll do that.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378265956", "createdAt": "2020-02-12T13:58:34Z", "author": {"login": "ge0ffrey"}, "path": "integration-tests/optaplanner/pom.xml", "diffHunk": "@@ -0,0 +1,142 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <parent>\n+        <artifactId>quarkus-integration-tests-parent</artifactId>\n+        <groupId>io.quarkus</groupId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../</relativePath>\n+    </parent>\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <artifactId>quarkus-integration-test-optaplanner</artifactId>\n+    <name>Quarkus - Integration Tests - OptaPlanner</name>\n+    <description>Module that contains OptaPlanner related tests</description>\n+\n+    <properties>\n+        <maven.compiler.parameters>true</maven.compiler.parameters>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-arc</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-resteasy</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-resteasy-jackson</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-optaplanner</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.optaplanner</groupId>\n+            <artifactId>optaplanner-persistence-jackson</artifactId>\n+        </dependency>\n+\n+        <!-- test dependencies -->\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-junit5</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.rest-assured</groupId>\n+            <artifactId>rest-assured</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <resources>\n+            <resource>\n+                <directory>src/main/resources</directory>\n+                <filtering>true</filtering>\n+            </resource>\n+        </resources>\n+        <plugins>\n+            <plugin>\n+                <groupId>io.quarkus</groupId>\n+                <artifactId>quarkus-maven-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <goals>\n+                            <goal>build</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <!-- force the locale as we want to explicitly test message interpolation -->\n+                    <argLine>-Duser.language=en</argLine>\n+                </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+\n+    <profiles>\n+        <profile>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI1MjMyNA=="}, "originalCommit": {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY5NTUxMA==", "bodyText": "Fixed with new commit on this fork.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r378695510", "createdAt": "2020-02-13T07:45:27Z", "author": {"login": "ge0ffrey"}, "path": "integration-tests/optaplanner/pom.xml", "diffHunk": "@@ -0,0 +1,142 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <parent>\n+        <artifactId>quarkus-integration-tests-parent</artifactId>\n+        <groupId>io.quarkus</groupId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../</relativePath>\n+    </parent>\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <artifactId>quarkus-integration-test-optaplanner</artifactId>\n+    <name>Quarkus - Integration Tests - OptaPlanner</name>\n+    <description>Module that contains OptaPlanner related tests</description>\n+\n+    <properties>\n+        <maven.compiler.parameters>true</maven.compiler.parameters>\n+    </properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-arc</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-resteasy</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-resteasy-jackson</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-optaplanner</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.optaplanner</groupId>\n+            <artifactId>optaplanner-persistence-jackson</artifactId>\n+        </dependency>\n+\n+        <!-- test dependencies -->\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-junit5</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.rest-assured</groupId>\n+            <artifactId>rest-assured</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <resources>\n+            <resource>\n+                <directory>src/main/resources</directory>\n+                <filtering>true</filtering>\n+            </resource>\n+        </resources>\n+        <plugins>\n+            <plugin>\n+                <groupId>io.quarkus</groupId>\n+                <artifactId>quarkus-maven-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <goals>\n+                            <goal>build</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <!-- force the locale as we want to explicitly test message interpolation -->\n+                    <argLine>-Duser.language=en</argLine>\n+                </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+\n+    <profiles>\n+        <profile>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI1MjMyNA=="}, "originalCommit": {"oid": "987bdf58bbe525a9891bbd1f204e1ba556923a2e"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0Njg4OTQ1OnYy", "diffSide": "RIGHT", "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwODo1MzowMlrOFpvXNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMTowMDo1NVrOFpzAQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMTkyNw==", "bodyText": "What annoys me a bit here is that if you use Jackson for your REST services and OptaPlanner without Jackson persistence, you end up with this exception. Or did I misunderstand?", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379311927", "createdAt": "2020-02-14T08:53:02Z", "author": {"login": "gsmet"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.Capabilities;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerObjectMapperCustomizer;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerQuarkusConfig optaPlannerQuarkusConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerQuarkusConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerQuarkusConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML\n+                        + \"): that classpath resource does not exist.\");\n+            }\n+            solverConfig = SolverConfig.createFromXmlResource(solverConfigXML, classLoader);\n+        } else if (classLoader.getResource(OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL) != null) {\n+            solverConfig = SolverConfig.createFromXmlResource(\n+                    OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL, classLoader);\n+        } else {\n+            solverConfig = new SolverConfig(classLoader);\n+        }\n+        // The deployment classLoader must not escape to runtime\n+        solverConfig.setClassLoader(null);\n+\n+        IndexView indexView = combinedIndex.getIndex();\n+        applySolverProperties(recorder, recorderContext, indexView, solverConfig);\n+\n+        if (solverConfig.getSolutionClass() != null) {\n+            Type jandexType = Type.create(DotName.createSimple(solverConfig.getSolutionClass().getName()), Type.Kind.CLASS);\n+            reflectiveHierarchyClass.produce(new ReflectiveHierarchyBuildItem(jandexType));\n+        }\n+        List<Class<?>> reflectiveClassList = new ArrayList<>(5);\n+        ScoreDirectorFactoryConfig scoreDirectorFactoryConfig = solverConfig.getScoreDirectorFactoryConfig();\n+        if (scoreDirectorFactoryConfig != null) {\n+            if (scoreDirectorFactoryConfig.getEasyScoreCalculatorClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getEasyScoreCalculatorClass());\n+            }\n+            if (scoreDirectorFactoryConfig.getConstraintProviderClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getConstraintProviderClass());\n+            }\n+            if (scoreDirectorFactoryConfig.getIncrementalScoreCalculatorClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getIncrementalScoreCalculatorClass());\n+            }\n+        }\n+        // TODO Add Config classes to workaround for https://issues.redhat.com/browse/PLANNER-1848, fixed in optaplanner 7.33.0.Final\n+        reflectiveClassList.add(ScoreDirectorFactoryConfig.class);\n+        reflectiveClassList.add(TerminationConfig.class);\n+        reflectiveClass.produce(\n+                new ReflectiveClassBuildItem(true, false, false,\n+                        reflectiveClassList.stream().map(Class::getName).toArray(String[]::new)));\n+\n+        SolverManagerConfig solverManagerConfig = new SolverManagerConfig();\n+        optaPlannerQuarkusConfig.solverManager.parallelSolverCount.ifPresent(solverManagerConfig::setParallelSolverCount);\n+        beanContainerListener\n+                .produce(new BeanContainerListenerBuildItem(\n+                        recorder.initialize(solverConfig, solverManagerConfig)));\n+    }\n+\n+    private void applySolverProperties(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            IndexView indexView, SolverConfig solverConfig) {\n+        if (solverConfig.getScanAnnotatedClassesConfig() != null) {\n+            throw new IllegalArgumentException(\"Do not use scanAnnotatedClasses with the Quarkus extension,\"\n+                    + \" because the Quarkus extension scans too.\\n\"\n+                    + \"Maybe delete the scanAnnotatedClasses element in the solver config.\");\n+        }\n+        if (solverConfig.getSolutionClass() == null) {\n+            solverConfig.setSolutionClass(findSolutionClass(recorderContext, indexView));\n+        }\n+        if (solverConfig.getEntityClassList() == null) {\n+            solverConfig.setEntityClassList(findEntityClassList(recorderContext, indexView));\n+        }\n+        if (solverConfig.getScoreDirectorFactoryConfig() == null) {\n+            ScoreDirectorFactoryConfig scoreDirectorFactoryConfig = new ScoreDirectorFactoryConfig();\n+            scoreDirectorFactoryConfig.setConstraintProviderClass(findConstraintProviderClass(recorderContext, indexView));\n+            solverConfig.setScoreDirectorFactoryConfig(scoreDirectorFactoryConfig);\n+        }\n+        optaPlannerQuarkusConfig.solver.environmentMode.ifPresent(solverConfig::setEnvironmentMode);\n+        optaPlannerQuarkusConfig.solver.moveThreadCount.ifPresent(solverConfig::setMoveThreadCount);\n+        applyTerminationProperties(solverConfig);\n+    }\n+\n+    private Class<?> findSolutionClass(RecorderContext recorderContext, IndexView indexView) {\n+        Collection<AnnotationInstance> annotationInstances = indexView.getAnnotations(DotNames.PLANNING_SOLUTION);\n+        if (annotationInstances.size() > 1) {\n+            throw new IllegalStateException(\"Multiple classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningSolution.class.getSimpleName() + \" annotation.\");\n+        }\n+        if (annotationInstances.isEmpty()) {\n+            throw new IllegalStateException(\"No classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningSolution.class.getSimpleName() + \" annotation.\");\n+        }\n+        AnnotationTarget solutionTarget = annotationInstances.iterator().next().target();\n+        if (solutionTarget.kind() != AnnotationTarget.Kind.CLASS) {\n+            throw new IllegalStateException(\"A target (\" + solutionTarget\n+                    + \") with a @\" + PlanningSolution.class.getSimpleName() + \" must be a class.\");\n+        }\n+\n+        return recorderContext.classProxy(solutionTarget.asClass().name().toString());\n+    }\n+\n+    private List<Class<?>> findEntityClassList(RecorderContext recorderContext, IndexView indexView) {\n+        Collection<AnnotationInstance> annotationInstances = indexView.getAnnotations(DotNames.PLANNING_ENTITY);\n+        if (annotationInstances.isEmpty()) {\n+            throw new IllegalStateException(\"No classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningEntity.class.getSimpleName() + \" annotation.\");\n+        }\n+        List<AnnotationTarget> targetList = annotationInstances.stream()\n+                .map(AnnotationInstance::target)\n+                .collect(Collectors.toList());\n+        if (targetList.stream().anyMatch(target -> target.kind() != AnnotationTarget.Kind.CLASS)) {\n+            throw new IllegalStateException(\"All targets (\" + targetList\n+                    + \") with a @\" + PlanningEntity.class.getSimpleName() + \" must be a class.\");\n+        }\n+        return targetList.stream()\n+                .map(target -> recorderContext.classProxy(target.asClass().name().toString()))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Class<? extends ConstraintProvider> findConstraintProviderClass(RecorderContext recorderContext,\n+            IndexView indexView) {\n+        Collection<ClassInfo> classInfos = indexView.getAllKnownImplementors(\n+                DotName.createSimple(ConstraintProvider.class.getName()));\n+        if (classInfos.size() > 1) {\n+            throw new IllegalStateException(\"Multiple classes (\" + convertClassInfosToString(classInfos)\n+                    + \") found that implement the interface \" + ConstraintProvider.class.getSimpleName() + \".\");\n+        }\n+        if (classInfos.isEmpty()) {\n+            throw new IllegalStateException(\"No classes (\" + convertClassInfosToString(classInfos)\n+                    + \") found that implement the interface \" + ConstraintProvider.class.getSimpleName() + \".\");\n+        }\n+        String constraintProviderClassName = classInfos.iterator().next().name().toString();\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        try {\n+            // Don't use recorderContext.classProxy(constraintProviderClassName)\n+            // because ReflectiveClassBuildItem cannot cope with a class proxy\n+            return (Class<? extends ConstraintProvider>) classLoader.loadClass(constraintProviderClassName);\n+        } catch (ClassNotFoundException e) {\n+            throw new IllegalStateException(\"The constraintProviderClass (\" + constraintProviderClassName\n+                    + \") cannot be created during deployment.\", e);\n+        }\n+    }\n+\n+    private void applyTerminationProperties(SolverConfig solverConfig) {\n+        TerminationConfig terminationConfig = solverConfig.getTerminationConfig();\n+        if (terminationConfig == null) {\n+            terminationConfig = new TerminationConfig();\n+            solverConfig.setTerminationConfig(terminationConfig);\n+        }\n+        optaPlannerQuarkusConfig.solver.termination.spentLimit.ifPresent(terminationConfig::setSpentLimit);\n+        optaPlannerQuarkusConfig.solver.termination.unimprovedSpentLimit.ifPresent(terminationConfig::setUnimprovedSpentLimit);\n+        optaPlannerQuarkusConfig.solver.termination.bestScoreLimit.ifPresent(terminationConfig::setBestScoreLimit);\n+    }\n+\n+    private String convertAnnotationInstancesToString(Collection<AnnotationInstance> annotationInstances) {\n+        return \"[\" + annotationInstances.stream().map(instance -> instance.target().toString())\n+                .collect(Collectors.joining(\", \")) + \"]\";\n+    }\n+\n+    private String convertClassInfosToString(Collection<ClassInfo> classInfos) {\n+        return \"[\" + classInfos.stream().map(instance -> instance.name().toString())\n+                .collect(Collectors.joining(\", \")) + \"]\";\n+    }\n+\n+    @BuildStep\n+    public RuntimeInitializedClassBuildItem nativeImageDroolsTricks() {\n+        return new RuntimeInitializedClassBuildItem(ClassFieldAccessorFactory.class.getName());\n+    }\n+\n+    // TODO health check\n+\n+    @BuildStep\n+    void registerOptaPlannerJacksonModule(BuildProducer<AdditionalBeanBuildItem> additionalBeans,\n+            Capabilities capabilities) {\n+        if (!capabilities.isCapabilityPresent(Capabilities.JACKSON)) {\n+            return;\n+        }\n+        try {\n+            Class.forName(\"org.optaplanner.persistence.jackson.api.OptaPlannerJacksonModule\", false,\n+                    Thread.currentThread().getContextClassLoader());\n+        } catch (Exception e) {\n+            // Fail fast during build to avoid a certain runtime failure\n+            throw new IllegalStateException(\n+                    \"When using both Jackson and OptaPlanner,\"\n+                            + \" add a dependency on org.optaplanner:optaplanner-persistence-jackson too.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12d131b2ab6f9ead0462a8d9a555754444b21286"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM0MzM3Mw==", "bodyText": "Yea - the idea is that it would stick out like a soar thumb, fail-fast basically. While if you forgot to add quarkus-optaplanner-jackson, there is no fail fast: it's just hard to notice that score instances aren't being jacksoned correctly.\nAnyway, not worth the hassle - I am creating quarkus-optaplanner-jackson to align with the quarkus ecosystem spirit :)", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379343373", "createdAt": "2020-02-14T10:00:58Z", "author": {"login": "ge0ffrey"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.Capabilities;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerObjectMapperCustomizer;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerQuarkusConfig optaPlannerQuarkusConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerQuarkusConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerQuarkusConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML\n+                        + \"): that classpath resource does not exist.\");\n+            }\n+            solverConfig = SolverConfig.createFromXmlResource(solverConfigXML, classLoader);\n+        } else if (classLoader.getResource(OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL) != null) {\n+            solverConfig = SolverConfig.createFromXmlResource(\n+                    OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL, classLoader);\n+        } else {\n+            solverConfig = new SolverConfig(classLoader);\n+        }\n+        // The deployment classLoader must not escape to runtime\n+        solverConfig.setClassLoader(null);\n+\n+        IndexView indexView = combinedIndex.getIndex();\n+        applySolverProperties(recorder, recorderContext, indexView, solverConfig);\n+\n+        if (solverConfig.getSolutionClass() != null) {\n+            Type jandexType = Type.create(DotName.createSimple(solverConfig.getSolutionClass().getName()), Type.Kind.CLASS);\n+            reflectiveHierarchyClass.produce(new ReflectiveHierarchyBuildItem(jandexType));\n+        }\n+        List<Class<?>> reflectiveClassList = new ArrayList<>(5);\n+        ScoreDirectorFactoryConfig scoreDirectorFactoryConfig = solverConfig.getScoreDirectorFactoryConfig();\n+        if (scoreDirectorFactoryConfig != null) {\n+            if (scoreDirectorFactoryConfig.getEasyScoreCalculatorClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getEasyScoreCalculatorClass());\n+            }\n+            if (scoreDirectorFactoryConfig.getConstraintProviderClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getConstraintProviderClass());\n+            }\n+            if (scoreDirectorFactoryConfig.getIncrementalScoreCalculatorClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getIncrementalScoreCalculatorClass());\n+            }\n+        }\n+        // TODO Add Config classes to workaround for https://issues.redhat.com/browse/PLANNER-1848, fixed in optaplanner 7.33.0.Final\n+        reflectiveClassList.add(ScoreDirectorFactoryConfig.class);\n+        reflectiveClassList.add(TerminationConfig.class);\n+        reflectiveClass.produce(\n+                new ReflectiveClassBuildItem(true, false, false,\n+                        reflectiveClassList.stream().map(Class::getName).toArray(String[]::new)));\n+\n+        SolverManagerConfig solverManagerConfig = new SolverManagerConfig();\n+        optaPlannerQuarkusConfig.solverManager.parallelSolverCount.ifPresent(solverManagerConfig::setParallelSolverCount);\n+        beanContainerListener\n+                .produce(new BeanContainerListenerBuildItem(\n+                        recorder.initialize(solverConfig, solverManagerConfig)));\n+    }\n+\n+    private void applySolverProperties(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            IndexView indexView, SolverConfig solverConfig) {\n+        if (solverConfig.getScanAnnotatedClassesConfig() != null) {\n+            throw new IllegalArgumentException(\"Do not use scanAnnotatedClasses with the Quarkus extension,\"\n+                    + \" because the Quarkus extension scans too.\\n\"\n+                    + \"Maybe delete the scanAnnotatedClasses element in the solver config.\");\n+        }\n+        if (solverConfig.getSolutionClass() == null) {\n+            solverConfig.setSolutionClass(findSolutionClass(recorderContext, indexView));\n+        }\n+        if (solverConfig.getEntityClassList() == null) {\n+            solverConfig.setEntityClassList(findEntityClassList(recorderContext, indexView));\n+        }\n+        if (solverConfig.getScoreDirectorFactoryConfig() == null) {\n+            ScoreDirectorFactoryConfig scoreDirectorFactoryConfig = new ScoreDirectorFactoryConfig();\n+            scoreDirectorFactoryConfig.setConstraintProviderClass(findConstraintProviderClass(recorderContext, indexView));\n+            solverConfig.setScoreDirectorFactoryConfig(scoreDirectorFactoryConfig);\n+        }\n+        optaPlannerQuarkusConfig.solver.environmentMode.ifPresent(solverConfig::setEnvironmentMode);\n+        optaPlannerQuarkusConfig.solver.moveThreadCount.ifPresent(solverConfig::setMoveThreadCount);\n+        applyTerminationProperties(solverConfig);\n+    }\n+\n+    private Class<?> findSolutionClass(RecorderContext recorderContext, IndexView indexView) {\n+        Collection<AnnotationInstance> annotationInstances = indexView.getAnnotations(DotNames.PLANNING_SOLUTION);\n+        if (annotationInstances.size() > 1) {\n+            throw new IllegalStateException(\"Multiple classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningSolution.class.getSimpleName() + \" annotation.\");\n+        }\n+        if (annotationInstances.isEmpty()) {\n+            throw new IllegalStateException(\"No classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningSolution.class.getSimpleName() + \" annotation.\");\n+        }\n+        AnnotationTarget solutionTarget = annotationInstances.iterator().next().target();\n+        if (solutionTarget.kind() != AnnotationTarget.Kind.CLASS) {\n+            throw new IllegalStateException(\"A target (\" + solutionTarget\n+                    + \") with a @\" + PlanningSolution.class.getSimpleName() + \" must be a class.\");\n+        }\n+\n+        return recorderContext.classProxy(solutionTarget.asClass().name().toString());\n+    }\n+\n+    private List<Class<?>> findEntityClassList(RecorderContext recorderContext, IndexView indexView) {\n+        Collection<AnnotationInstance> annotationInstances = indexView.getAnnotations(DotNames.PLANNING_ENTITY);\n+        if (annotationInstances.isEmpty()) {\n+            throw new IllegalStateException(\"No classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningEntity.class.getSimpleName() + \" annotation.\");\n+        }\n+        List<AnnotationTarget> targetList = annotationInstances.stream()\n+                .map(AnnotationInstance::target)\n+                .collect(Collectors.toList());\n+        if (targetList.stream().anyMatch(target -> target.kind() != AnnotationTarget.Kind.CLASS)) {\n+            throw new IllegalStateException(\"All targets (\" + targetList\n+                    + \") with a @\" + PlanningEntity.class.getSimpleName() + \" must be a class.\");\n+        }\n+        return targetList.stream()\n+                .map(target -> recorderContext.classProxy(target.asClass().name().toString()))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Class<? extends ConstraintProvider> findConstraintProviderClass(RecorderContext recorderContext,\n+            IndexView indexView) {\n+        Collection<ClassInfo> classInfos = indexView.getAllKnownImplementors(\n+                DotName.createSimple(ConstraintProvider.class.getName()));\n+        if (classInfos.size() > 1) {\n+            throw new IllegalStateException(\"Multiple classes (\" + convertClassInfosToString(classInfos)\n+                    + \") found that implement the interface \" + ConstraintProvider.class.getSimpleName() + \".\");\n+        }\n+        if (classInfos.isEmpty()) {\n+            throw new IllegalStateException(\"No classes (\" + convertClassInfosToString(classInfos)\n+                    + \") found that implement the interface \" + ConstraintProvider.class.getSimpleName() + \".\");\n+        }\n+        String constraintProviderClassName = classInfos.iterator().next().name().toString();\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        try {\n+            // Don't use recorderContext.classProxy(constraintProviderClassName)\n+            // because ReflectiveClassBuildItem cannot cope with a class proxy\n+            return (Class<? extends ConstraintProvider>) classLoader.loadClass(constraintProviderClassName);\n+        } catch (ClassNotFoundException e) {\n+            throw new IllegalStateException(\"The constraintProviderClass (\" + constraintProviderClassName\n+                    + \") cannot be created during deployment.\", e);\n+        }\n+    }\n+\n+    private void applyTerminationProperties(SolverConfig solverConfig) {\n+        TerminationConfig terminationConfig = solverConfig.getTerminationConfig();\n+        if (terminationConfig == null) {\n+            terminationConfig = new TerminationConfig();\n+            solverConfig.setTerminationConfig(terminationConfig);\n+        }\n+        optaPlannerQuarkusConfig.solver.termination.spentLimit.ifPresent(terminationConfig::setSpentLimit);\n+        optaPlannerQuarkusConfig.solver.termination.unimprovedSpentLimit.ifPresent(terminationConfig::setUnimprovedSpentLimit);\n+        optaPlannerQuarkusConfig.solver.termination.bestScoreLimit.ifPresent(terminationConfig::setBestScoreLimit);\n+    }\n+\n+    private String convertAnnotationInstancesToString(Collection<AnnotationInstance> annotationInstances) {\n+        return \"[\" + annotationInstances.stream().map(instance -> instance.target().toString())\n+                .collect(Collectors.joining(\", \")) + \"]\";\n+    }\n+\n+    private String convertClassInfosToString(Collection<ClassInfo> classInfos) {\n+        return \"[\" + classInfos.stream().map(instance -> instance.name().toString())\n+                .collect(Collectors.joining(\", \")) + \"]\";\n+    }\n+\n+    @BuildStep\n+    public RuntimeInitializedClassBuildItem nativeImageDroolsTricks() {\n+        return new RuntimeInitializedClassBuildItem(ClassFieldAccessorFactory.class.getName());\n+    }\n+\n+    // TODO health check\n+\n+    @BuildStep\n+    void registerOptaPlannerJacksonModule(BuildProducer<AdditionalBeanBuildItem> additionalBeans,\n+            Capabilities capabilities) {\n+        if (!capabilities.isCapabilityPresent(Capabilities.JACKSON)) {\n+            return;\n+        }\n+        try {\n+            Class.forName(\"org.optaplanner.persistence.jackson.api.OptaPlannerJacksonModule\", false,\n+                    Thread.currentThread().getContextClassLoader());\n+        } catch (Exception e) {\n+            // Fail fast during build to avoid a certain runtime failure\n+            throw new IllegalStateException(\n+                    \"When using both Jackson and OptaPlanner,\"\n+                            + \" add a dependency on org.optaplanner:optaplanner-persistence-jackson too.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMTkyNw=="}, "originalCommit": {"oid": "12d131b2ab6f9ead0462a8d9a555754444b21286"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM3MTU4Ng==", "bodyText": "Done", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379371586", "createdAt": "2020-02-14T11:00:55Z", "author": {"login": "ge0ffrey"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.Capabilities;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerObjectMapperCustomizer;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerQuarkusConfig optaPlannerQuarkusConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerQuarkusConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerQuarkusConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML\n+                        + \"): that classpath resource does not exist.\");\n+            }\n+            solverConfig = SolverConfig.createFromXmlResource(solverConfigXML, classLoader);\n+        } else if (classLoader.getResource(OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL) != null) {\n+            solverConfig = SolverConfig.createFromXmlResource(\n+                    OptaPlannerQuarkusConfig.DEFAULT_SOLVER_CONFIG_URL, classLoader);\n+        } else {\n+            solverConfig = new SolverConfig(classLoader);\n+        }\n+        // The deployment classLoader must not escape to runtime\n+        solverConfig.setClassLoader(null);\n+\n+        IndexView indexView = combinedIndex.getIndex();\n+        applySolverProperties(recorder, recorderContext, indexView, solverConfig);\n+\n+        if (solverConfig.getSolutionClass() != null) {\n+            Type jandexType = Type.create(DotName.createSimple(solverConfig.getSolutionClass().getName()), Type.Kind.CLASS);\n+            reflectiveHierarchyClass.produce(new ReflectiveHierarchyBuildItem(jandexType));\n+        }\n+        List<Class<?>> reflectiveClassList = new ArrayList<>(5);\n+        ScoreDirectorFactoryConfig scoreDirectorFactoryConfig = solverConfig.getScoreDirectorFactoryConfig();\n+        if (scoreDirectorFactoryConfig != null) {\n+            if (scoreDirectorFactoryConfig.getEasyScoreCalculatorClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getEasyScoreCalculatorClass());\n+            }\n+            if (scoreDirectorFactoryConfig.getConstraintProviderClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getConstraintProviderClass());\n+            }\n+            if (scoreDirectorFactoryConfig.getIncrementalScoreCalculatorClass() != null) {\n+                reflectiveClassList.add(scoreDirectorFactoryConfig.getIncrementalScoreCalculatorClass());\n+            }\n+        }\n+        // TODO Add Config classes to workaround for https://issues.redhat.com/browse/PLANNER-1848, fixed in optaplanner 7.33.0.Final\n+        reflectiveClassList.add(ScoreDirectorFactoryConfig.class);\n+        reflectiveClassList.add(TerminationConfig.class);\n+        reflectiveClass.produce(\n+                new ReflectiveClassBuildItem(true, false, false,\n+                        reflectiveClassList.stream().map(Class::getName).toArray(String[]::new)));\n+\n+        SolverManagerConfig solverManagerConfig = new SolverManagerConfig();\n+        optaPlannerQuarkusConfig.solverManager.parallelSolverCount.ifPresent(solverManagerConfig::setParallelSolverCount);\n+        beanContainerListener\n+                .produce(new BeanContainerListenerBuildItem(\n+                        recorder.initialize(solverConfig, solverManagerConfig)));\n+    }\n+\n+    private void applySolverProperties(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            IndexView indexView, SolverConfig solverConfig) {\n+        if (solverConfig.getScanAnnotatedClassesConfig() != null) {\n+            throw new IllegalArgumentException(\"Do not use scanAnnotatedClasses with the Quarkus extension,\"\n+                    + \" because the Quarkus extension scans too.\\n\"\n+                    + \"Maybe delete the scanAnnotatedClasses element in the solver config.\");\n+        }\n+        if (solverConfig.getSolutionClass() == null) {\n+            solverConfig.setSolutionClass(findSolutionClass(recorderContext, indexView));\n+        }\n+        if (solverConfig.getEntityClassList() == null) {\n+            solverConfig.setEntityClassList(findEntityClassList(recorderContext, indexView));\n+        }\n+        if (solverConfig.getScoreDirectorFactoryConfig() == null) {\n+            ScoreDirectorFactoryConfig scoreDirectorFactoryConfig = new ScoreDirectorFactoryConfig();\n+            scoreDirectorFactoryConfig.setConstraintProviderClass(findConstraintProviderClass(recorderContext, indexView));\n+            solverConfig.setScoreDirectorFactoryConfig(scoreDirectorFactoryConfig);\n+        }\n+        optaPlannerQuarkusConfig.solver.environmentMode.ifPresent(solverConfig::setEnvironmentMode);\n+        optaPlannerQuarkusConfig.solver.moveThreadCount.ifPresent(solverConfig::setMoveThreadCount);\n+        applyTerminationProperties(solverConfig);\n+    }\n+\n+    private Class<?> findSolutionClass(RecorderContext recorderContext, IndexView indexView) {\n+        Collection<AnnotationInstance> annotationInstances = indexView.getAnnotations(DotNames.PLANNING_SOLUTION);\n+        if (annotationInstances.size() > 1) {\n+            throw new IllegalStateException(\"Multiple classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningSolution.class.getSimpleName() + \" annotation.\");\n+        }\n+        if (annotationInstances.isEmpty()) {\n+            throw new IllegalStateException(\"No classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningSolution.class.getSimpleName() + \" annotation.\");\n+        }\n+        AnnotationTarget solutionTarget = annotationInstances.iterator().next().target();\n+        if (solutionTarget.kind() != AnnotationTarget.Kind.CLASS) {\n+            throw new IllegalStateException(\"A target (\" + solutionTarget\n+                    + \") with a @\" + PlanningSolution.class.getSimpleName() + \" must be a class.\");\n+        }\n+\n+        return recorderContext.classProxy(solutionTarget.asClass().name().toString());\n+    }\n+\n+    private List<Class<?>> findEntityClassList(RecorderContext recorderContext, IndexView indexView) {\n+        Collection<AnnotationInstance> annotationInstances = indexView.getAnnotations(DotNames.PLANNING_ENTITY);\n+        if (annotationInstances.isEmpty()) {\n+            throw new IllegalStateException(\"No classes (\" + convertAnnotationInstancesToString(annotationInstances)\n+                    + \") found with a @\" + PlanningEntity.class.getSimpleName() + \" annotation.\");\n+        }\n+        List<AnnotationTarget> targetList = annotationInstances.stream()\n+                .map(AnnotationInstance::target)\n+                .collect(Collectors.toList());\n+        if (targetList.stream().anyMatch(target -> target.kind() != AnnotationTarget.Kind.CLASS)) {\n+            throw new IllegalStateException(\"All targets (\" + targetList\n+                    + \") with a @\" + PlanningEntity.class.getSimpleName() + \" must be a class.\");\n+        }\n+        return targetList.stream()\n+                .map(target -> recorderContext.classProxy(target.asClass().name().toString()))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Class<? extends ConstraintProvider> findConstraintProviderClass(RecorderContext recorderContext,\n+            IndexView indexView) {\n+        Collection<ClassInfo> classInfos = indexView.getAllKnownImplementors(\n+                DotName.createSimple(ConstraintProvider.class.getName()));\n+        if (classInfos.size() > 1) {\n+            throw new IllegalStateException(\"Multiple classes (\" + convertClassInfosToString(classInfos)\n+                    + \") found that implement the interface \" + ConstraintProvider.class.getSimpleName() + \".\");\n+        }\n+        if (classInfos.isEmpty()) {\n+            throw new IllegalStateException(\"No classes (\" + convertClassInfosToString(classInfos)\n+                    + \") found that implement the interface \" + ConstraintProvider.class.getSimpleName() + \".\");\n+        }\n+        String constraintProviderClassName = classInfos.iterator().next().name().toString();\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        try {\n+            // Don't use recorderContext.classProxy(constraintProviderClassName)\n+            // because ReflectiveClassBuildItem cannot cope with a class proxy\n+            return (Class<? extends ConstraintProvider>) classLoader.loadClass(constraintProviderClassName);\n+        } catch (ClassNotFoundException e) {\n+            throw new IllegalStateException(\"The constraintProviderClass (\" + constraintProviderClassName\n+                    + \") cannot be created during deployment.\", e);\n+        }\n+    }\n+\n+    private void applyTerminationProperties(SolverConfig solverConfig) {\n+        TerminationConfig terminationConfig = solverConfig.getTerminationConfig();\n+        if (terminationConfig == null) {\n+            terminationConfig = new TerminationConfig();\n+            solverConfig.setTerminationConfig(terminationConfig);\n+        }\n+        optaPlannerQuarkusConfig.solver.termination.spentLimit.ifPresent(terminationConfig::setSpentLimit);\n+        optaPlannerQuarkusConfig.solver.termination.unimprovedSpentLimit.ifPresent(terminationConfig::setUnimprovedSpentLimit);\n+        optaPlannerQuarkusConfig.solver.termination.bestScoreLimit.ifPresent(terminationConfig::setBestScoreLimit);\n+    }\n+\n+    private String convertAnnotationInstancesToString(Collection<AnnotationInstance> annotationInstances) {\n+        return \"[\" + annotationInstances.stream().map(instance -> instance.target().toString())\n+                .collect(Collectors.joining(\", \")) + \"]\";\n+    }\n+\n+    private String convertClassInfosToString(Collection<ClassInfo> classInfos) {\n+        return \"[\" + classInfos.stream().map(instance -> instance.name().toString())\n+                .collect(Collectors.joining(\", \")) + \"]\";\n+    }\n+\n+    @BuildStep\n+    public RuntimeInitializedClassBuildItem nativeImageDroolsTricks() {\n+        return new RuntimeInitializedClassBuildItem(ClassFieldAccessorFactory.class.getName());\n+    }\n+\n+    // TODO health check\n+\n+    @BuildStep\n+    void registerOptaPlannerJacksonModule(BuildProducer<AdditionalBeanBuildItem> additionalBeans,\n+            Capabilities capabilities) {\n+        if (!capabilities.isCapabilityPresent(Capabilities.JACKSON)) {\n+            return;\n+        }\n+        try {\n+            Class.forName(\"org.optaplanner.persistence.jackson.api.OptaPlannerJacksonModule\", false,\n+                    Thread.currentThread().getContextClassLoader());\n+        } catch (Exception e) {\n+            // Fail fast during build to avoid a certain runtime failure\n+            throw new IllegalStateException(\n+                    \"When using both Jackson and OptaPlanner,\"\n+                            + \" add a dependency on org.optaplanner:optaplanner-persistence-jackson too.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMTkyNw=="}, "originalCommit": {"oid": "12d131b2ab6f9ead0462a8d9a555754444b21286"}, "originalPosition": 240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0Njg5MTcxOnYy", "diffSide": "RIGHT", "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerQuarkusConfig.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwODo1Mzo0NFrOFpvYdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMTo0MDoxNFrOFpz9Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjI0Ng==", "bodyText": "Call it OptaPlannerBuildTimeConfig and get rid of the comment.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379312246", "createdAt": "2020-02-14T08:53:44Z", "author": {"login": "gsmet"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerQuarkusConfig.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import java.util.Optional;\n+\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+// Not named OptaPlannerConfig because classes ending with just \"Config\" collide with OptaPlanner's API\n+@ConfigRoot(name = \"optaplanner\")\n+public class OptaPlannerQuarkusConfig {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12d131b2ab6f9ead0462a8d9a555754444b21286"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM4NzE2Nw==", "bodyText": "Done, good point.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379387167", "createdAt": "2020-02-14T11:40:14Z", "author": {"login": "ge0ffrey"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerQuarkusConfig.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import java.util.Optional;\n+\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+// Not named OptaPlannerConfig because classes ending with just \"Config\" collide with OptaPlanner's API\n+@ConfigRoot(name = \"optaplanner\")\n+public class OptaPlannerQuarkusConfig {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjI0Ng=="}, "originalCommit": {"oid": "12d131b2ab6f9ead0462a8d9a555754444b21286"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0Njg5Mzk1OnYy", "diffSide": "RIGHT", "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/SolverManagerQuarkusConfig.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwODo1NDozMVrOFpvZ4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNjoxMjoyNFrOFqpvJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjYwOQ==", "bodyText": "That looks like a runtime property to me.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379312609", "createdAt": "2020-02-14T08:54:31Z", "author": {"login": "gsmet"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/SolverManagerQuarkusConfig.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import java.util.Optional;\n+\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+/**\n+ * Subset of OptaPlanner's {@link SolverManagerConfig}.\n+ */\n+@ConfigGroup\n+public class SolverManagerQuarkusConfig {\n+\n+    /**\n+     * The number of solvers that run in parallel. This directly influences CPU consumption.\n+     * Defaults to {@value SolverManagerConfig#PARALLEL_SOLVER_COUNT_AUTO}.\n+     * Other options include a number or formula based on the available processor count.\n+     */\n+    @ConfigItem\n+    Optional<String> parallelSolverCount;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12d131b2ab6f9ead0462a8d9a555754444b21286"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM4MDIyMw==", "bodyText": "It only affects SolverManager during build time - those get injected, but we don't need to read this property at runtime.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379380223", "createdAt": "2020-02-14T11:22:16Z", "author": {"login": "ge0ffrey"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/SolverManagerQuarkusConfig.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import java.util.Optional;\n+\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+/**\n+ * Subset of OptaPlanner's {@link SolverManagerConfig}.\n+ */\n+@ConfigGroup\n+public class SolverManagerQuarkusConfig {\n+\n+    /**\n+     * The number of solvers that run in parallel. This directly influences CPU consumption.\n+     * Defaults to {@value SolverManagerConfig#PARALLEL_SOLVER_COUNT_AUTO}.\n+     * Other options include a number or formula based on the available processor count.\n+     */\n+    @ConfigItem\n+    Optional<String> parallelSolverCount;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjYwOQ=="}, "originalCommit": {"oid": "12d131b2ab6f9ead0462a8d9a555754444b21286"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM4NzY2Ng==", "bodyText": "Discussed with Georgios. He agrees, these are build time properties (they get translated into optaplanner configuration during the build time, they aren't used at runtime). Renamed class to end with BuildTimeConfig instead of QuarkusConfig to signal that.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379387666", "createdAt": "2020-02-14T11:41:37Z", "author": {"login": "ge0ffrey"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/SolverManagerQuarkusConfig.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import java.util.Optional;\n+\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+/**\n+ * Subset of OptaPlanner's {@link SolverManagerConfig}.\n+ */\n+@ConfigGroup\n+public class SolverManagerQuarkusConfig {\n+\n+    /**\n+     * The number of solvers that run in parallel. This directly influences CPU consumption.\n+     * Defaults to {@value SolverManagerConfig#PARALLEL_SOLVER_COUNT_AUTO}.\n+     * Other options include a number or formula based on the available processor count.\n+     */\n+    @ConfigItem\n+    Optional<String> parallelSolverCount;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjYwOQ=="}, "originalCommit": {"oid": "12d131b2ab6f9ead0462a8d9a555754444b21286"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDIxODQ3OQ==", "bodyText": "Well, they might be build time for your code but I think it's typically values that you will want to change at runtime because it might depend on the hardware on which you deploy it.\nI don't have a problem merging that as is for now but I think it's probably something we should think about for a later version (but it might be totally impractical, I don't know OptaPlanner at all).", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r380218479", "createdAt": "2020-02-17T14:39:46Z", "author": {"login": "gsmet"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/SolverManagerQuarkusConfig.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import java.util.Optional;\n+\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+/**\n+ * Subset of OptaPlanner's {@link SolverManagerConfig}.\n+ */\n+@ConfigGroup\n+public class SolverManagerQuarkusConfig {\n+\n+    /**\n+     * The number of solvers that run in parallel. This directly influences CPU consumption.\n+     * Defaults to {@value SolverManagerConfig#PARALLEL_SOLVER_COUNT_AUTO}.\n+     * Other options include a number or formula based on the available processor count.\n+     */\n+    @ConfigItem\n+    Optional<String> parallelSolverCount;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjYwOQ=="}, "originalCommit": {"oid": "12d131b2ab6f9ead0462a8d9a555754444b21286"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI2ODMyNA==", "bodyText": "Agreed - or users wanting to override them with -D system properties?", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r380268324", "createdAt": "2020-02-17T16:12:24Z", "author": {"login": "ge0ffrey"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/SolverManagerQuarkusConfig.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import java.util.Optional;\n+\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+/**\n+ * Subset of OptaPlanner's {@link SolverManagerConfig}.\n+ */\n+@ConfigGroup\n+public class SolverManagerQuarkusConfig {\n+\n+    /**\n+     * The number of solvers that run in parallel. This directly influences CPU consumption.\n+     * Defaults to {@value SolverManagerConfig#PARALLEL_SOLVER_COUNT_AUTO}.\n+     * Other options include a number or formula based on the available processor count.\n+     */\n+    @ConfigItem\n+    Optional<String> parallelSolverCount;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjYwOQ=="}, "originalCommit": {"oid": "12d131b2ab6f9ead0462a8d9a555754444b21286"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0Njg5NDIzOnYy", "diffSide": "RIGHT", "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/SolverQuarkusConfig.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwODo1NDozN1rOFpvaDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMTo0Mzo0MFrOFp0CMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjY1NA==", "bodyText": "That looks like a runtime property to me.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379312654", "createdAt": "2020-02-14T08:54:37Z", "author": {"login": "gsmet"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/SolverQuarkusConfig.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import java.util.Optional;\n+\n+import org.optaplanner.core.config.solver.EnvironmentMode;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+/**\n+ * Subset of OptaPlanner's {@link SolverConfig}.\n+ */\n+@ConfigGroup\n+public class SolverQuarkusConfig {\n+\n+    /**\n+     * Enable runtime assertions to detect common bugs in your implementation during development.\n+     * Defaults to {@link EnvironmentMode#REPRODUCIBLE}.\n+     */\n+    @ConfigItem\n+    Optional<EnvironmentMode> environmentMode;\n+    /**\n+     * Enable multithreaded solving for a single problem, which increases CPU consumption.\n+     * Defaults to {@value SolverConfig#MOVE_THREAD_COUNT_NONE}.\n+     * Other options include {@value SolverConfig#MOVE_THREAD_COUNT_AUTO}, a number\n+     * or formula based on the available processor count.\n+     */\n+    @ConfigItem\n+    Optional<String> moveThreadCount;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12d131b2ab6f9ead0462a8d9a555754444b21286"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM4ODQ2NA==", "bodyText": "It's a build time property, see other comment.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379388464", "createdAt": "2020-02-14T11:43:40Z", "author": {"login": "ge0ffrey"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/SolverQuarkusConfig.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import java.util.Optional;\n+\n+import org.optaplanner.core.config.solver.EnvironmentMode;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+/**\n+ * Subset of OptaPlanner's {@link SolverConfig}.\n+ */\n+@ConfigGroup\n+public class SolverQuarkusConfig {\n+\n+    /**\n+     * Enable runtime assertions to detect common bugs in your implementation during development.\n+     * Defaults to {@link EnvironmentMode#REPRODUCIBLE}.\n+     */\n+    @ConfigItem\n+    Optional<EnvironmentMode> environmentMode;\n+    /**\n+     * Enable multithreaded solving for a single problem, which increases CPU consumption.\n+     * Defaults to {@value SolverConfig#MOVE_THREAD_COUNT_NONE}.\n+     * Other options include {@value SolverConfig#MOVE_THREAD_COUNT_AUTO}, a number\n+     * or formula based on the available processor count.\n+     */\n+    @ConfigItem\n+    Optional<String> moveThreadCount;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjY1NA=="}, "originalCommit": {"oid": "12d131b2ab6f9ead0462a8d9a555754444b21286"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0Njg5NTM1OnYy", "diffSide": "RIGHT", "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/TerminationQuarkusConfig.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwODo1NTowNVrOFpvasg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMTo0Mzo1MVrOFp0ChQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjgxOA==", "bodyText": "That looks like a runtime property to me.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379312818", "createdAt": "2020-02-14T08:55:05Z", "author": {"login": "gsmet"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/TerminationQuarkusConfig.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import java.time.Duration;\n+import java.util.Optional;\n+\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+/**\n+ * Subset of OptaPlanner's {@link TerminationConfig}.\n+ */\n+@ConfigGroup\n+public class TerminationQuarkusConfig {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12d131b2ab6f9ead0462a8d9a555754444b21286"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM4ODU0OQ==", "bodyText": "It's a build time property, see other comment. Adjusted class name to reflect that.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379388549", "createdAt": "2020-02-14T11:43:51Z", "author": {"login": "ge0ffrey"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/TerminationQuarkusConfig.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import java.time.Duration;\n+import java.util.Optional;\n+\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+/**\n+ * Subset of OptaPlanner's {@link TerminationConfig}.\n+ */\n+@ConfigGroup\n+public class TerminationQuarkusConfig {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjgxOA=="}, "originalCommit": {"oid": "12d131b2ab6f9ead0462a8d9a555754444b21286"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjkwNjEwOnYy", "diffSide": "RIGHT", "path": "extensions/optaplanner/runtime/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwODo1ODo0OFrOFpvhEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwOTo1NToxMVrOFpxGrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxNDQ1MQ==", "bodyText": "How do you expect Kogito to work in native mode if we don't depend on the Kogito extension?", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379314451", "createdAt": "2020-02-14T08:58:48Z", "author": {"login": "gsmet"}, "path": "extensions/optaplanner/runtime/pom.xml", "diffHunk": "@@ -0,0 +1,113 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-optaplanner-parent</artifactId>\n+        <version>999-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>quarkus-optaplanner</artifactId>\n+    <name>Quarkus - OptaPlanner - Runtime</name>\n+    <description>Constraint solving AI for employee rostering, vehicle routing, maintenance scheduling, school timetabling, etc</description>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-core</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-arc</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-jackson</artifactId>\n+            <optional>true</optional>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.optaplanner</groupId>\n+            <artifactId>optaplanner-core</artifactId>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>org.kie</groupId>\n+                    <artifactId>kie-api</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>org.kie</groupId>\n+                    <artifactId>kie-internal</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>org.drools</groupId>\n+                    <artifactId>drools-core</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>org.drools</groupId>\n+                    <artifactId>drools-compiler</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>org.drools</groupId>\n+                    <artifactId>drools-canonical-model</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>org.drools</groupId>\n+                    <artifactId>drools-model-compiler</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.kie.kogito</groupId>\n+            <artifactId>kogito-api</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.kie.kogito</groupId>\n+            <artifactId>kogito-drools</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12d131b2ab6f9ead0462a8d9a555754444b21286"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM0MDQ2Mw==", "bodyText": "We have it running in native mode (see the IT test), with a ConstraintProvider that ends up using (kogito)-drools, so it works.\nWe use drools's executable model, which doesn't need any of the kogito quarkus extension magic.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379340463", "createdAt": "2020-02-14T09:55:11Z", "author": {"login": "ge0ffrey"}, "path": "extensions/optaplanner/runtime/pom.xml", "diffHunk": "@@ -0,0 +1,113 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-optaplanner-parent</artifactId>\n+        <version>999-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>quarkus-optaplanner</artifactId>\n+    <name>Quarkus - OptaPlanner - Runtime</name>\n+    <description>Constraint solving AI for employee rostering, vehicle routing, maintenance scheduling, school timetabling, etc</description>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-core</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-arc</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-jackson</artifactId>\n+            <optional>true</optional>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.optaplanner</groupId>\n+            <artifactId>optaplanner-core</artifactId>\n+            <exclusions>\n+                <exclusion>\n+                    <groupId>org.kie</groupId>\n+                    <artifactId>kie-api</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>org.kie</groupId>\n+                    <artifactId>kie-internal</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>org.drools</groupId>\n+                    <artifactId>drools-core</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>org.drools</groupId>\n+                    <artifactId>drools-compiler</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>org.drools</groupId>\n+                    <artifactId>drools-canonical-model</artifactId>\n+                </exclusion>\n+                <exclusion>\n+                    <groupId>org.drools</groupId>\n+                    <artifactId>drools-model-compiler</artifactId>\n+                </exclusion>\n+            </exclusions>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.kie.kogito</groupId>\n+            <artifactId>kogito-api</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.kie.kogito</groupId>\n+            <artifactId>kogito-drools</artifactId>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxNDQ1MQ=="}, "originalCommit": {"oid": "12d131b2ab6f9ead0462a8d9a555754444b21286"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjkwODU5OnYy", "diffSide": "RIGHT", "path": "extensions/optaplanner/runtime/src/main/resources/META-INF/quarkus-extension.yaml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwODo1OTo0M1rOFpvirA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMDowNToxMVrOFpxaRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxNDg2MA==", "bodyText": "Let's add the guide URL when we have one.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379314860", "createdAt": "2020-02-14T08:59:43Z", "author": {"login": "gsmet"}, "path": "extensions/optaplanner/runtime/src/main/resources/META-INF/quarkus-extension.yaml", "diffHunk": "@@ -0,0 +1,16 @@\n+---\n+name: \"OptaPlanner constraint solver AI\"\n+metadata:\n+  keywords:\n+  - \"optaplanner\"\n+  - \"kogito\"\n+  - \"constraint-solver\"\n+  - \"artificial-intelligence\"\n+  - \"employee-rostering\"\n+  - \"vehicle-routing-problem\"\n+  - \"maintenance-scheduling\"\n+  - \"timetabling\"\n+  guide: \"https://quarkus.io/guides/optaplanner\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12d131b2ab6f9ead0462a8d9a555754444b21286"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM0NTQ3OA==", "bodyText": "Fixed by comment it it out", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379345478", "createdAt": "2020-02-14T10:05:11Z", "author": {"login": "ge0ffrey"}, "path": "extensions/optaplanner/runtime/src/main/resources/META-INF/quarkus-extension.yaml", "diffHunk": "@@ -0,0 +1,16 @@\n+---\n+name: \"OptaPlanner constraint solver AI\"\n+metadata:\n+  keywords:\n+  - \"optaplanner\"\n+  - \"kogito\"\n+  - \"constraint-solver\"\n+  - \"artificial-intelligence\"\n+  - \"employee-rostering\"\n+  - \"vehicle-routing-problem\"\n+  - \"maintenance-scheduling\"\n+  - \"timetabling\"\n+  guide: \"https://quarkus.io/guides/optaplanner\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxNDg2MA=="}, "originalCommit": {"oid": "12d131b2ab6f9ead0462a8d9a555754444b21286"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjkwOTgxOnYy", "diffSide": "RIGHT", "path": "integration-tests/optaplanner/src/main/java/io/quarkus/it/optaplanner/domain/ITestdataPlanningSolution.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwOTowMDoxNVrOFpvjdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwOTowMDoxNVrOFpvjdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxNTA2Mw==", "bodyText": "Please no license header.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379315063", "createdAt": "2020-02-14T09:00:15Z", "author": {"login": "gsmet"}, "path": "integration-tests/optaplanner/src/main/java/io/quarkus/it/optaplanner/domain/ITestdataPlanningSolution.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12d131b2ab6f9ead0462a8d9a555754444b21286"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjkxMDM5OnYy", "diffSide": "RIGHT", "path": "integration-tests/optaplanner/src/main/java/io/quarkus/it/optaplanner/solver/ITestdataPlanningConstraintProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwOTowMDoyN1rOFpvj0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMDowNToxN1rOFpxacg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxNTE1Mg==", "bodyText": "Same here, well, remove all of them :).", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379315152", "createdAt": "2020-02-14T09:00:27Z", "author": {"login": "gsmet"}, "path": "integration-tests/optaplanner/src/main/java/io/quarkus/it/optaplanner/solver/ITestdataPlanningConstraintProvider.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12d131b2ab6f9ead0462a8d9a555754444b21286"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM0NTUyMg==", "bodyText": "Fixed", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r379345522", "createdAt": "2020-02-14T10:05:17Z", "author": {"login": "ge0ffrey"}, "path": "integration-tests/optaplanner/src/main/java/io/quarkus/it/optaplanner/solver/ITestdataPlanningConstraintProvider.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxNTE1Mg=="}, "originalCommit": {"oid": "12d131b2ab6f9ead0462a8d9a555754444b21286"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MzEzODk0OnYy", "diffSide": "RIGHT", "path": "bom/runtime/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNDo0MDoxNFrOFqmtew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxODozOTo0NFrOFrN5Wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDIxODc0Nw==", "bodyText": "There is an indentation issue.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r380218747", "createdAt": "2020-02-17T14:40:14Z", "author": {"login": "gsmet"}, "path": "bom/runtime/pom.xml", "diffHunk": "@@ -166,6 +166,7 @@\n         <hibernate-quarkus-local-cache.version>0.1.0</hibernate-quarkus-local-cache.version>\n         <kogito.version>0.7.1</kogito.version>\n         <kubernetes-client.version>4.8.0</kubernetes-client.version>\n+      <optaplanner.version>7.32.0.Final</optaplanner.version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9d2fdb9388ecf94dc315ef363a0b2aa710d0cb8"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg2MDc2Mg==", "bodyText": "Embarrassed by this one - must have happened by the merge conflicts during one of the rebases to master. Fixing now.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r380860762", "createdAt": "2020-02-18T18:39:44Z", "author": {"login": "ge0ffrey"}, "path": "bom/runtime/pom.xml", "diffHunk": "@@ -166,6 +166,7 @@\n         <hibernate-quarkus-local-cache.version>0.1.0</hibernate-quarkus-local-cache.version>\n         <kogito.version>0.7.1</kogito.version>\n         <kubernetes-client.version>4.8.0</kubernetes-client.version>\n+      <optaplanner.version>7.32.0.Final</optaplanner.version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDIxODc0Nw=="}, "originalCommit": {"oid": "a9d2fdb9388ecf94dc315ef363a0b2aa710d0cb8"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MzE0MzY5OnYy", "diffSide": "RIGHT", "path": "extensions/optaplanner-jackson/runtime/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNDo0MTozN1rOFqmwag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNDo0MTozN1rOFqmwag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDIxOTQ5OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                <description>Make Score, etc look pretty in JSON.</description>\n          \n          \n            \n                <description>Make Score, etc look pretty in JSON</description>\n          \n      \n    \n    \n  \n\nNote that this is the description that will be on code.quarkus.io. I'm not sure the current description is very helpful.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r380219498", "createdAt": "2020-02-17T14:41:37Z", "author": {"login": "gsmet"}, "path": "extensions/optaplanner-jackson/runtime/pom.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-optaplanner-jackson-parent</artifactId>\n+        <version>999-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>quarkus-optaplanner-jackson</artifactId>\n+    <name>Quarkus - OptaPlanner Jackson - Runtime</name>\n+    <description>Make Score, etc look pretty in JSON.</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9d2fdb9388ecf94dc315ef363a0b2aa710d0cb8"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MzE0NTg1OnYy", "diffSide": "RIGHT", "path": "extensions/optaplanner-jackson/runtime/src/main/resources/quarkus-extension.yaml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNDo0MjoxNFrOFqmxwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNDo0MjoxNFrOFqmxwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDIxOTg0MQ==", "bodyText": "Could it be consistently indented?", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r380219841", "createdAt": "2020-02-17T14:42:14Z", "author": {"login": "gsmet"}, "path": "extensions/optaplanner-jackson/runtime/src/main/resources/quarkus-extension.yaml", "diffHunk": "@@ -0,0 +1,12 @@\n+---\n+name: \"OptaPlanner Jackson\"\n+metadata:\n+  keywords:\n+  - \"optaplanner\"\n+  - \"kogito\"\n+  - \"jackson\"\n+  categories:\n+    - \"business-automation\"\n+    - \"web\"\n+    - \"serialization\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9d2fdb9388ecf94dc315ef363a0b2aa710d0cb8"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MzE1MDE3OnYy", "diffSide": "RIGHT", "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNDo0MzoyM1rOFqm0SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNDo0MzoyM1rOFqm0SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDIyMDQ4OA==", "bodyText": "The name of the property should be the one used by the user. This is not the case here.\nAlso maybe a ConfigException would be better.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r380220488", "createdAt": "2020-02-17T14:43:23Z", "author": {"login": "gsmet"}, "path": "extensions/optaplanner/deployment/src/main/java/io/quarkus/optaplanner/deployment/OptaPlannerProcessor.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package io.quarkus.optaplanner.deployment;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.drools.core.base.ClassFieldAccessorFactory;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Type;\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.SolverManagerConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerListenerBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.HotDeploymentWatchedFileBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;\n+import io.quarkus.deployment.recording.RecorderContext;\n+import io.quarkus.optaplanner.OptaPlannerBeanProvider;\n+import io.quarkus.optaplanner.OptaPlannerRecorder;\n+\n+class OptaPlannerProcessor {\n+\n+    OptaPlannerBuildTimeConfig optaPlannerBuildTimeConfig;\n+\n+    @BuildStep\n+    FeatureBuildItem feature() {\n+        return new FeatureBuildItem(FeatureBuildItem.OPTAPLANNER);\n+    }\n+\n+    @BuildStep\n+    HotDeploymentWatchedFileBuildItem configFile() {\n+        String solverConfigXML;\n+        if (optaPlannerBuildTimeConfig.solverConfigXml.isPresent()) {\n+            solverConfigXML = optaPlannerBuildTimeConfig.solverConfigXml.get();\n+        } else {\n+            solverConfigXML = OptaPlannerBuildTimeConfig.DEFAULT_SOLVER_CONFIG_URL;\n+        }\n+        return new HotDeploymentWatchedFileBuildItem(solverConfigXML);\n+    }\n+\n+    @BuildStep\n+    void registerAdditionalBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        // The bean encapsulating the SolverFactory\n+        additionalBeans.produce(new AdditionalBeanBuildItem(OptaPlannerBeanProvider.class));\n+    }\n+\n+    @BuildStep(loadsApplicationClasses = true)\n+    @Record(STATIC_INIT)\n+    void recordSolverFactory(OptaPlannerRecorder recorder, RecorderContext recorderContext,\n+            CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<ReflectiveHierarchyBuildItem> reflectiveHierarchyClass,\n+            BuildProducer<ReflectiveClassBuildItem> reflectiveClass,\n+            BuildProducer<BeanContainerListenerBuildItem> beanContainerListener) {\n+        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+        SolverConfig solverConfig;\n+        if (optaPlannerBuildTimeConfig.solverConfigXml.isPresent()) {\n+            String solverConfigXML = optaPlannerBuildTimeConfig.solverConfigXml.get();\n+            if (classLoader.getResource(solverConfigXML) == null) {\n+                throw new IllegalStateException(\"Invalid optaplanner.solverConfigXML property (\" + solverConfigXML", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9d2fdb9388ecf94dc315ef363a0b2aa710d0cb8"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MzE1ODg1OnYy", "diffSide": "RIGHT", "path": "extensions/optaplanner/deployment/src/test/java/io/quarkus/optaplanner/rest/OptaPlannerProcessorHotReloadTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNDo0NTo1NlrOFqm5ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQwOTo0MDo1MVrOFq7ZCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDIyMTg1NA==", "bodyText": "I'm curious how this works without a LiveReloadBuildItem? I think we should probably have one to restart all the app in case of a change, similar to what we do elsewhere.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r380221854", "createdAt": "2020-02-17T14:45:56Z", "author": {"login": "gsmet"}, "path": "extensions/optaplanner/deployment/src/test/java/io/quarkus/optaplanner/rest/OptaPlannerProcessorHotReloadTest.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package io.quarkus.optaplanner.rest;\n+\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import io.quarkus.optaplanner.constraints.TestdataPlanningConstraintProvider;\n+import io.quarkus.optaplanner.domain.TestdataPlanningEntity;\n+import io.quarkus.optaplanner.domain.TestdataPlanningSolution;\n+import io.quarkus.test.QuarkusDevModeTest;\n+import io.restassured.RestAssured;\n+\n+public class OptaPlannerProcessorHotReloadTest {\n+\n+    // This fails in IntelliJ with \"Undeclared build item class\", but not in maven. That's normal in Quarkus for now.\n+    @RegisterExtension\n+    static final QuarkusDevModeTest test = new QuarkusDevModeTest()\n+            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n+                    .addClasses(TestdataPlanningEntity.class,\n+                            TestdataPlanningSolution.class, TestdataPlanningConstraintProvider.class,\n+                            SolverConfigTestResource.class)\n+                    .addAsResource(\"solverConfig.xml\"));\n+\n+    @Test\n+    public void solverConfigHotReload() {\n+        String resp = RestAssured.get(\"/solver-config/seconds-spent-limit\").asString();\n+        Assertions.assertEquals(\"secondsSpentLimit=2\", resp);\n+        test.modifyResourceFile(\"solverConfig.xml\", s -> s.replace(\"<secondsSpentLimit>2</secondsSpentLimit>\",\n+                \"<secondsSpentLimit>9</secondsSpentLimit>\"));\n+        resp = RestAssured.get(\"/solver-config/seconds-spent-limit\").asString();\n+        Assertions.assertEquals(\"secondsSpentLimit=9\", resp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9d2fdb9388ecf94dc315ef363a0b2aa710d0cb8"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU1NzU3Ng==", "bodyText": "A HotDeploymentWatchedFileBuildItem has been added to the PR that enables the config file for reload.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r380557576", "createdAt": "2020-02-18T09:40:51Z", "author": {"login": "geoand"}, "path": "extensions/optaplanner/deployment/src/test/java/io/quarkus/optaplanner/rest/OptaPlannerProcessorHotReloadTest.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package io.quarkus.optaplanner.rest;\n+\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import io.quarkus.optaplanner.constraints.TestdataPlanningConstraintProvider;\n+import io.quarkus.optaplanner.domain.TestdataPlanningEntity;\n+import io.quarkus.optaplanner.domain.TestdataPlanningSolution;\n+import io.quarkus.test.QuarkusDevModeTest;\n+import io.restassured.RestAssured;\n+\n+public class OptaPlannerProcessorHotReloadTest {\n+\n+    // This fails in IntelliJ with \"Undeclared build item class\", but not in maven. That's normal in Quarkus for now.\n+    @RegisterExtension\n+    static final QuarkusDevModeTest test = new QuarkusDevModeTest()\n+            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n+                    .addClasses(TestdataPlanningEntity.class,\n+                            TestdataPlanningSolution.class, TestdataPlanningConstraintProvider.class,\n+                            SolverConfigTestResource.class)\n+                    .addAsResource(\"solverConfig.xml\"));\n+\n+    @Test\n+    public void solverConfigHotReload() {\n+        String resp = RestAssured.get(\"/solver-config/seconds-spent-limit\").asString();\n+        Assertions.assertEquals(\"secondsSpentLimit=2\", resp);\n+        test.modifyResourceFile(\"solverConfig.xml\", s -> s.replace(\"<secondsSpentLimit>2</secondsSpentLimit>\",\n+                \"<secondsSpentLimit>9</secondsSpentLimit>\"));\n+        resp = RestAssured.get(\"/solver-config/seconds-spent-limit\").asString();\n+        Assertions.assertEquals(\"secondsSpentLimit=9\", resp);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDIyMTg1NA=="}, "originalCommit": {"oid": "a9d2fdb9388ecf94dc315ef363a0b2aa710d0cb8"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MzE2MTQ4OnYy", "diffSide": "RIGHT", "path": "extensions/optaplanner/runtime/src/main/resources/META-INF/quarkus-extension.yaml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNDo0Njo0MVrOFqm7Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNDo0Njo0MVrOFqm7Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDIyMjI2Mg==", "bodyText": "Same here, let's get the indentation consistent between keywords and categories.", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r380222262", "createdAt": "2020-02-17T14:46:41Z", "author": {"login": "gsmet"}, "path": "extensions/optaplanner/runtime/src/main/resources/META-INF/quarkus-extension.yaml", "diffHunk": "@@ -0,0 +1,16 @@\n+---\n+name: \"OptaPlanner constraint solver AI\"\n+metadata:\n+  keywords:\n+  - \"optaplanner\"\n+  - \"kogito\"\n+  - \"constraint-solver\"\n+  - \"artificial-intelligence\"\n+  - \"employee-rostering\"\n+  - \"vehicle-routing-problem\"\n+  - \"maintenance-scheduling\"\n+  - \"timetabling\"\n+  # guide: \"https://quarkus.io/guides/constraint-solving-ai-optaplanner\"\n+  categories:\n+    - \"business-automation\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9d2fdb9388ecf94dc315ef363a0b2aa710d0cb8"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MzE2NjEwOnYy", "diffSide": "RIGHT", "path": "ci-templates/stages.yml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNDo0Nzo1OVrOFqm9-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNDo0Nzo1OVrOFqm9-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDIyMjk3MQ==", "bodyText": "Isn't the IT module called optaplanner-jackson now?", "url": "https://github.com/quarkusio/quarkus/pull/7049#discussion_r380222971", "createdAt": "2020-02-17T14:47:59Z", "author": {"login": "gsmet"}, "path": "ci-templates/stages.yml", "diffHunk": "@@ -410,6 +410,7 @@ stages:\n           timeoutInMinutes: 35\n           modules:\n             - kogito\n+            - optaplanner", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9d2fdb9388ecf94dc315ef363a0b2aa710d0cb8"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1116, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}