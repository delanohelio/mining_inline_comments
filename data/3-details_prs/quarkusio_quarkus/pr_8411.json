{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk5NTM3OTM3", "number": 8411, "title": "Add Vault response wrapping support for client token auth and secret id in approle auth", "bodyText": "This PR provides the ability to use wrapping tokens instead of plain sensitive data in configuration for vault authentication: client token (the token itself), approle (the secret id)\ntypically instead of providing:\nquarkus.vault.authentication.client-token=s.XYZ\n\nyou could provide:\nquarkus.vault.authentication.client-token-wrapping-token=s.xSr3IHx9RXxpSSwCctTd6n02\n\nWhere s.xSr3IHx9RXxpSSwCctTd6n02 is obtained from:\n/ # vault token create -wrap-ttl=60s -policy=myapp\nKey                              Value\n---                              -----\nwrapping_token:                  s.xSr3IHx9RXxpSSwCctTd6n02\nwrapping_accessor:               8H0BUXHPFv6LVIrXa9H9XNWb\nwrapping_token_ttl:              1m\nwrapping_token_creation_time:    2020-03-31 16:26:49.0405113 +0000 UTC\nwrapping_token_creation_path:    auth/token/create\nwrapped_accessor:                xoFYP9EgPi9I3xa7cDB3bm5v\n\nSimilarly for approle, instead of providing:\nquarkus.vault.authentication.app-role.secret-id=ef8e1ebc-3be1-7bb7-3166-8b63b6289449\n\nYou could provide:\nquarkus.vault.authentication.app-role.secret-id-wrapping-token=s.QdjujN8PGGN8EICldXpFnSYO\n\nWhere s.QdjujN8PGGN8EICldXpFnSYO is obtained from:\n/ # vault write -wrap-ttl=60s -f auth/approle/role/myapp/secret-id\nKey                              Value\n---                              -----\nwrapping_token:                  s.QdjujN8PGGN8EICldXpFnSYO\nwrapping_accessor:               NCk8gkK90xLNzFMcnTq68nY8\nwrapping_token_ttl:              1m\nwrapping_token_creation_time:    2020-03-31 16:29:05.5958584 +0000 UTC\nwrapping_token_creation_path:    auth/approle/role/myapp/secret-id\n\nA wrapping token is a token that gives access to a secret information just once and has a small ttl. After the token has been unwrapped, the token is destroyed.\nThis approach is interesting when you want to start an application that needs to connect to vault, but you want to protect the sensitive data used to authenticate (e.g. secret id for approle). Instead of providing the sensitive data, you wrap it and include the wrapping token in the configuration of the application you are about to launch, then launch the application. This is done by a trusted entity that can connect to vault and generate wrapping tokens.\nIf the application cannot unwrap the wrapping token, it means it was either too slow, or most likely the wrapping token has been stolen, which can trigger an alarm.\nThis mechanism adds some security around not exposing sensitive auth information in application configuration. It comes with a major drawback where the application cannot be restarted after it has consumed the wrapping token. The trusted entity will have to re-provision a new wrapping token in the application configuration.\nThis is, in essence, what k8s is doing for free through the jwt token located in /var/run/secrets/kubernetes.io/serviceaccount.\nThere are several pieces of relevant documentation:\n\nhttps://www.vaultproject.io/docs/concepts/response-wrapping/\nhttps://learn.hashicorp.com/vault/secrets-management/sm-cubbyhole\n\nPlease see also #7900 and #8248 and for initial discussions.", "createdAt": "2020-04-06T10:20:12Z", "url": "https://github.com/quarkusio/quarkus/pull/8411", "merged": true, "mergeCommit": {"oid": "6b49644fb4406789c3e5e0ea42a921e02dae14d1"}, "closed": true, "closedAt": "2020-04-10T13:08:35Z", "author": {"login": "vsevel"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcU7q-_gH2gAyMzk5NTM3OTM3OjJjNWQ2YmY4NmNmMDVjMDllZTM3ZWUwMTI1NzIxOTRmM2QwYzcyOTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcWQzhDAFqTM5MTQzMjI3MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2c5d6bf86cf05c09ee37ee012572194f3d0c7293", "author": {"user": {"login": "vsevel", "name": "Vincent Sevel"}}, "url": "https://github.com/quarkusio/quarkus/commit/2c5d6bf86cf05c09ee37ee012572194f3d0c7293", "committedDate": "2020-04-06T09:55:55Z", "message": "Add Vault response wrapping support for client token auth and secret id in approle auth - Fixes #7900"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4ODI5NzUy", "url": "https://github.com/quarkusio/quarkus/pull/8411#pullrequestreview-388829752", "createdAt": "2020-04-07T06:53:34Z", "commit": {"oid": "2c5d6bf86cf05c09ee37ee012572194f3d0c7293"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNjo1MzozNFrOGB1UgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNjo1ODo0N1rOGB1d-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3NTM2MQ==", "bodyText": "Can you add more info regarding the exception, as this is not a unwrapping problem per-se, but a problem on Thread management.", "url": "https://github.com/quarkusio/quarkus/pull/8411#discussion_r404575361", "createdAt": "2020-04-07T06:53:34Z", "author": {"login": "lordofthejars"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/VaultAuthManager.java", "diffHunk": "@@ -118,6 +138,50 @@ private VaultToken login(VaultAuthenticationType type) {\n         return new VaultToken(auth.clientToken, auth.renewable, auth.leaseDurationSecs);\n     }\n \n+    private String getSecretId() {\n+\n+        Optional<String> secretIdOption = serverConfig.authentication.appRole.secretId;\n+        if (secretIdOption.isPresent()) {\n+            return secretIdOption.get();\n+        }\n+\n+        return unwrapWrappingTokenOnce(\"secret id\",\n+                serverConfig.authentication.appRole.secretIdWrappingToken.get(), unwrap -> unwrap.data.secretId,\n+                VaultAppRoleGenerateNewSecretID.class);\n+    }\n+\n+    private <T> String unwrapWrappingTokenOnce(String type, String wrappingToken,\n+            Function<T, String> f, Class<T> clazz) {\n+\n+        String wrappedValue = wrappedCache.get(wrappingToken);\n+        if (wrappedValue != null) {\n+            return wrappedValue;\n+        }\n+\n+        try {\n+            unwrapSem.acquire();\n+            try {\n+                // by the time we reach here, may be somebody has populated the cache\n+                wrappedValue = wrappedCache.get(wrappingToken);\n+                if (wrappedValue != null) {\n+                    return wrappedValue;\n+                }\n+\n+                T unwrap = vaultClient.unwrap(wrappingToken, clazz);\n+                wrappedValue = f.apply(unwrap);\n+                wrappedCache.put(wrappingToken, wrappedValue);\n+                String displayValue = serverConfig.logConfidentialityLevel.maskWithTolerance(wrappedValue, LOW);\n+                log.debug(\"unwrapped \" + type + \": \" + displayValue);\n+                return wrappedValue;\n+\n+            } finally {\n+                unwrapSem.release();\n+            }\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(\"unable to unwrap \" + type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c5d6bf86cf05c09ee37ee012572194f3d0c7293"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3NjIwNw==", "bodyText": "If there is this logic inside the semaphore.acquire, do we really need it here?", "url": "https://github.com/quarkusio/quarkus/pull/8411#discussion_r404576207", "createdAt": "2020-04-07T06:55:19Z", "author": {"login": "lordofthejars"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/VaultAuthManager.java", "diffHunk": "@@ -118,6 +138,50 @@ private VaultToken login(VaultAuthenticationType type) {\n         return new VaultToken(auth.clientToken, auth.renewable, auth.leaseDurationSecs);\n     }\n \n+    private String getSecretId() {\n+\n+        Optional<String> secretIdOption = serverConfig.authentication.appRole.secretId;\n+        if (secretIdOption.isPresent()) {\n+            return secretIdOption.get();\n+        }\n+\n+        return unwrapWrappingTokenOnce(\"secret id\",\n+                serverConfig.authentication.appRole.secretIdWrappingToken.get(), unwrap -> unwrap.data.secretId,\n+                VaultAppRoleGenerateNewSecretID.class);\n+    }\n+\n+    private <T> String unwrapWrappingTokenOnce(String type, String wrappingToken,\n+            Function<T, String> f, Class<T> clazz) {\n+\n+        String wrappedValue = wrappedCache.get(wrappingToken);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c5d6bf86cf05c09ee37ee012572194f3d0c7293"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3NzEwOA==", "bodyText": "If token has been already unwrapped (ie stolen) this method is going to throw an error, could we capture specifically the exception in this case and throw a specific RuntimeException and/or log as warning? Just to not provide the error a general error of Vault but something important that might affect the security of your app.", "url": "https://github.com/quarkusio/quarkus/pull/8411#discussion_r404577108", "createdAt": "2020-04-07T06:57:19Z", "author": {"login": "lordofthejars"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/VaultAuthManager.java", "diffHunk": "@@ -118,6 +138,50 @@ private VaultToken login(VaultAuthenticationType type) {\n         return new VaultToken(auth.clientToken, auth.renewable, auth.leaseDurationSecs);\n     }\n \n+    private String getSecretId() {\n+\n+        Optional<String> secretIdOption = serverConfig.authentication.appRole.secretId;\n+        if (secretIdOption.isPresent()) {\n+            return secretIdOption.get();\n+        }\n+\n+        return unwrapWrappingTokenOnce(\"secret id\",\n+                serverConfig.authentication.appRole.secretIdWrappingToken.get(), unwrap -> unwrap.data.secretId,\n+                VaultAppRoleGenerateNewSecretID.class);\n+    }\n+\n+    private <T> String unwrapWrappingTokenOnce(String type, String wrappingToken,\n+            Function<T, String> f, Class<T> clazz) {\n+\n+        String wrappedValue = wrappedCache.get(wrappingToken);\n+        if (wrappedValue != null) {\n+            return wrappedValue;\n+        }\n+\n+        try {\n+            unwrapSem.acquire();\n+            try {\n+                // by the time we reach here, may be somebody has populated the cache\n+                wrappedValue = wrappedCache.get(wrappingToken);\n+                if (wrappedValue != null) {\n+                    return wrappedValue;\n+                }\n+\n+                T unwrap = vaultClient.unwrap(wrappingToken, clazz);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c5d6bf86cf05c09ee37ee012572194f3d0c7293"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3Nzc4Nw==", "bodyText": "Generally speaking I don't like passing nulls to constructors, can we provide an empty constructor which it specifically do this?", "url": "https://github.com/quarkusio/quarkus/pull/8411#discussion_r404577787", "createdAt": "2020-04-07T06:58:47Z", "author": {"login": "lordofthejars"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/client/OkHttpVaultClient.java", "diffHunk": "@@ -252,6 +254,18 @@ public VaultInitResponse init(int secretShares, int secretThreshold) {\n         return put(\"sys/init\", body, VaultInitResponse.class);\n     }\n \n+    public VaultWrapResult wrap(String token, long ttl, Object object) {\n+        Map<String, String> headers = new HashMap<>();\n+        headers.put(\"X-Vault-Wrap-TTL\", \"\" + ttl);\n+        return post(\"sys/wrapping/wrap\", token, headers, object, VaultWrapResult.class);\n+    }\n+\n+    @Override\n+    public <T> T unwrap(String wrappingToken, Class<T> resultClass) {\n+        VaultUnwrapBody body = new VaultUnwrapBody(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c5d6bf86cf05c09ee37ee012572194f3d0c7293"}, "originalPosition": 43}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1a42c979bf3ac443532af6638e67f8e7e4c9760", "author": {"user": {"login": "vsevel", "name": "Vincent Sevel"}}, "url": "https://github.com/quarkusio/quarkus/commit/c1a42c979bf3ac443532af6638e67f8e7e4c9760", "committedDate": "2020-04-07T13:56:47Z", "message": "review @lordofthejars"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MTQ0MjQ2", "url": "https://github.com/quarkusio/quarkus/pull/8411#pullrequestreview-389144246", "createdAt": "2020-04-07T13:59:20Z", "commit": {"oid": "c1a42c979bf3ac443532af6638e67f8e7e4c9760"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "116f63d4017eed835072dd7ee580d5b946a0c53c", "author": {"user": {"login": "vsevel", "name": "Vincent Sevel"}}, "url": "https://github.com/quarkusio/quarkus/commit/116f63d4017eed835072dd7ee580d5b946a0c53c", "committedDate": "2020-04-09T08:49:17Z", "message": "support for userpass password-wrapping-token"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNDMyMjcx", "url": "https://github.com/quarkusio/quarkus/pull/8411#pullrequestreview-391432271", "createdAt": "2020-04-10T13:07:10Z", "commit": {"oid": "116f63d4017eed835072dd7ee580d5b946a0c53c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4738, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}