{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg4MDI0OTc5", "number": 7860, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwODoyNjowM1rODoOqJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMTo1NDoyOFrODy301w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNTA5Nzk2OnYy", "diffSide": "RIGHT", "path": "extensions/reactive-mysql-client/runtime/src/main/java/io/quarkus/reactive/mysql/client/runtime/health/ReactiveMySQLDataSourceHealthCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwODoyNjowM1rOF2prNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwODoyNjowM1rOF2prNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1MDIyOA==", "bodyText": "can't we get more than one?", "url": "https://github.com/quarkusio/quarkus/pull/7860#discussion_r392850228", "createdAt": "2020-03-16T08:26:03Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-mysql-client/runtime/src/main/java/io/quarkus/reactive/mysql/client/runtime/health/ReactiveMySQLDataSourceHealthCheck.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package io.quarkus.reactive.mysql.client.runtime.health;\n+\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.eclipse.microprofile.health.HealthCheck;\n+import org.eclipse.microprofile.health.HealthCheckResponse;\n+import org.eclipse.microprofile.health.HealthCheckResponseBuilder;\n+import org.eclipse.microprofile.health.Readiness;\n+\n+import io.quarkus.arc.Arc;\n+import io.vertx.mysqlclient.MySQLPool;\n+\n+@Readiness\n+@ApplicationScoped\n+public class ReactiveMySQLDataSourceHealthCheck implements HealthCheck {\n+\n+    private MySQLPool mySQLPool;\n+\n+    @PostConstruct\n+    protected void init() {\n+        mySQLPool = Arc.container().instance(MySQLPool.class).get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f546849399ae4434152d91f00ab69528d1c54201"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNTEwMTI5OnYy", "diffSide": "RIGHT", "path": "extensions/reactive-mysql-client/runtime/src/main/java/io/quarkus/reactive/mysql/client/runtime/health/ReactiveMySQLDataSourceHealthCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwODoyNzo0MFrOF2puRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwODoyNzo0MFrOF2puRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1MTAxMw==", "bodyText": "You need to check you are not on the IO Thread, because if so you cannot block.", "url": "https://github.com/quarkusio/quarkus/pull/7860#discussion_r392851013", "createdAt": "2020-03-16T08:27:40Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-mysql-client/runtime/src/main/java/io/quarkus/reactive/mysql/client/runtime/health/ReactiveMySQLDataSourceHealthCheck.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package io.quarkus.reactive.mysql.client.runtime.health;\n+\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.eclipse.microprofile.health.HealthCheck;\n+import org.eclipse.microprofile.health.HealthCheckResponse;\n+import org.eclipse.microprofile.health.HealthCheckResponseBuilder;\n+import org.eclipse.microprofile.health.Readiness;\n+\n+import io.quarkus.arc.Arc;\n+import io.vertx.mysqlclient.MySQLPool;\n+\n+@Readiness\n+@ApplicationScoped\n+public class ReactiveMySQLDataSourceHealthCheck implements HealthCheck {\n+\n+    private MySQLPool mySQLPool;\n+\n+    @PostConstruct\n+    protected void init() {\n+        mySQLPool = Arc.container().instance(MySQLPool.class).get();\n+    }\n+\n+    @Override\n+    public HealthCheckResponse call() {\n+        HealthCheckResponseBuilder builder = HealthCheckResponse.named(\"Reactive MySQL connection health check\").up();\n+\n+        try {\n+            CompletableFuture<Void> databaseConnectionAttempt = new CompletableFuture<>();\n+            mySQLPool.query(\"SELECT 1\", ar -> {\n+                if (ar.failed()) {\n+                    builder.down();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f546849399ae4434152d91f00ab69528d1c54201"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNTEwNzk3OnYy", "diffSide": "RIGHT", "path": "extensions/reactive-pg-client/runtime/src/main/java/io/quarkus/reactive/pg/client/runtime/health/ReactivePgDataSourceHealthCheck.java", "isResolved": true, "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwODoyOToyN1rOF2pxhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMTo0Nzo0MlrOGHK0rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1MTg0Nw==", "bodyText": "Same comments:\n\nhow to handle when there are several Pools\nyou need to be sure to not block the IO Thread.", "url": "https://github.com/quarkusio/quarkus/pull/7860#discussion_r392851847", "createdAt": "2020-03-16T08:29:27Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-pg-client/runtime/src/main/java/io/quarkus/reactive/pg/client/runtime/health/ReactivePgDataSourceHealthCheck.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.reactive.pg.client.runtime.health;\n+\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.eclipse.microprofile.health.HealthCheck;\n+import org.eclipse.microprofile.health.HealthCheckResponse;\n+import org.eclipse.microprofile.health.HealthCheckResponseBuilder;\n+import org.eclipse.microprofile.health.Readiness;\n+\n+import io.quarkus.arc.Arc;\n+import io.vertx.pgclient.PgPool;\n+\n+@Readiness\n+@ApplicationScoped\n+public class ReactivePgDataSourceHealthCheck implements HealthCheck {\n+    private PgPool pgPool;\n+\n+    @PostConstruct\n+    protected void init() {\n+        pgPool = Arc.container().instance(PgPool.class).get();\n+    }\n+\n+    @Override\n+    public HealthCheckResponse call() {\n+        HealthCheckResponseBuilder builder = HealthCheckResponse.named(\"Reactive PostgreSQL connection health check\").up();\n+\n+        try {\n+            CompletableFuture<Void> databaseConnectionAttempt = new CompletableFuture<>();\n+            pgPool.query(\"SELECT 1\", ar -> {\n+                if (ar.failed()) {\n+                    builder.down();\n+                }\n+                databaseConnectionAttempt.complete(null);\n+            });\n+            databaseConnectionAttempt.join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f546849399ae4434152d91f00ab69528d1c54201"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk3NDUxOA==", "bodyText": "@cescoffier thanks for the review.\n\nSame comments:\n\nhow to handle when there are several Pools\n\n\nIn the meantime multiple reactive datasources are not handled, once added we will for sure need to handle them the same way we have handled them for the Agroal connection healthcheck.\n\n\nyou need to be sure to not block the IO Thread.\n\n\nOkay,  are there constructs (a bean that I can inject ) that I can use to check if in IO Thread?\nAnd if in IO Thread case, what should be done?", "url": "https://github.com/quarkusio/quarkus/pull/7860#discussion_r392974518", "createdAt": "2020-03-16T12:16:28Z", "author": {"login": "machi1990"}, "path": "extensions/reactive-pg-client/runtime/src/main/java/io/quarkus/reactive/pg/client/runtime/health/ReactivePgDataSourceHealthCheck.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.reactive.pg.client.runtime.health;\n+\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.eclipse.microprofile.health.HealthCheck;\n+import org.eclipse.microprofile.health.HealthCheckResponse;\n+import org.eclipse.microprofile.health.HealthCheckResponseBuilder;\n+import org.eclipse.microprofile.health.Readiness;\n+\n+import io.quarkus.arc.Arc;\n+import io.vertx.pgclient.PgPool;\n+\n+@Readiness\n+@ApplicationScoped\n+public class ReactivePgDataSourceHealthCheck implements HealthCheck {\n+    private PgPool pgPool;\n+\n+    @PostConstruct\n+    protected void init() {\n+        pgPool = Arc.container().instance(PgPool.class).get();\n+    }\n+\n+    @Override\n+    public HealthCheckResponse call() {\n+        HealthCheckResponseBuilder builder = HealthCheckResponse.named(\"Reactive PostgreSQL connection health check\").up();\n+\n+        try {\n+            CompletableFuture<Void> databaseConnectionAttempt = new CompletableFuture<>();\n+            pgPool.query(\"SELECT 1\", ar -> {\n+                if (ar.failed()) {\n+                    builder.down();\n+                }\n+                databaseConnectionAttempt.complete(null);\n+            });\n+            databaseConnectionAttempt.join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1MTg0Nw=="}, "originalCommit": {"oid": "f546849399ae4434152d91f00ab69528d1c54201"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk5ODU0Ng==", "bodyText": "I think this will always be in the IO thread\nIs this still a problem even if we  mark the Health handler as blocking though? https://github.com/quarkusio/quarkus/blob/1.3.0.Final/extensions/smallrye-health/deployment/src/main/java/io/quarkus/smallrye/health/deployment/SmallRyeHealthProcessor.java#L106", "url": "https://github.com/quarkusio/quarkus/pull/7860#discussion_r392998546", "createdAt": "2020-03-16T12:47:29Z", "author": {"login": "jmartisk"}, "path": "extensions/reactive-pg-client/runtime/src/main/java/io/quarkus/reactive/pg/client/runtime/health/ReactivePgDataSourceHealthCheck.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.reactive.pg.client.runtime.health;\n+\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.eclipse.microprofile.health.HealthCheck;\n+import org.eclipse.microprofile.health.HealthCheckResponse;\n+import org.eclipse.microprofile.health.HealthCheckResponseBuilder;\n+import org.eclipse.microprofile.health.Readiness;\n+\n+import io.quarkus.arc.Arc;\n+import io.vertx.pgclient.PgPool;\n+\n+@Readiness\n+@ApplicationScoped\n+public class ReactivePgDataSourceHealthCheck implements HealthCheck {\n+    private PgPool pgPool;\n+\n+    @PostConstruct\n+    protected void init() {\n+        pgPool = Arc.container().instance(PgPool.class).get();\n+    }\n+\n+    @Override\n+    public HealthCheckResponse call() {\n+        HealthCheckResponseBuilder builder = HealthCheckResponse.named(\"Reactive PostgreSQL connection health check\").up();\n+\n+        try {\n+            CompletableFuture<Void> databaseConnectionAttempt = new CompletableFuture<>();\n+            pgPool.query(\"SELECT 1\", ar -> {\n+                if (ar.failed()) {\n+                    builder.down();\n+                }\n+                databaseConnectionAttempt.complete(null);\n+            });\n+            databaseConnectionAttempt.join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1MTg0Nw=="}, "originalCommit": {"oid": "f546849399ae4434152d91f00ab69528d1c54201"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzAwMTA1OA==", "bodyText": "If it's a problem then I suppose we would need a change to run the health checks (probably all, not just this one) in a different thread pool (which one?)", "url": "https://github.com/quarkusio/quarkus/pull/7860#discussion_r393001058", "createdAt": "2020-03-16T12:52:10Z", "author": {"login": "jmartisk"}, "path": "extensions/reactive-pg-client/runtime/src/main/java/io/quarkus/reactive/pg/client/runtime/health/ReactivePgDataSourceHealthCheck.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.reactive.pg.client.runtime.health;\n+\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.eclipse.microprofile.health.HealthCheck;\n+import org.eclipse.microprofile.health.HealthCheckResponse;\n+import org.eclipse.microprofile.health.HealthCheckResponseBuilder;\n+import org.eclipse.microprofile.health.Readiness;\n+\n+import io.quarkus.arc.Arc;\n+import io.vertx.pgclient.PgPool;\n+\n+@Readiness\n+@ApplicationScoped\n+public class ReactivePgDataSourceHealthCheck implements HealthCheck {\n+    private PgPool pgPool;\n+\n+    @PostConstruct\n+    protected void init() {\n+        pgPool = Arc.container().instance(PgPool.class).get();\n+    }\n+\n+    @Override\n+    public HealthCheckResponse call() {\n+        HealthCheckResponseBuilder builder = HealthCheckResponse.named(\"Reactive PostgreSQL connection health check\").up();\n+\n+        try {\n+            CompletableFuture<Void> databaseConnectionAttempt = new CompletableFuture<>();\n+            pgPool.query(\"SELECT 1\", ar -> {\n+                if (ar.failed()) {\n+                    builder.down();\n+                }\n+                databaseConnectionAttempt.complete(null);\n+            });\n+            databaseConnectionAttempt.join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1MTg0Nw=="}, "originalCommit": {"oid": "f546849399ae4434152d91f00ab69528d1c54201"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMxNTMwNw==", "bodyText": "I think this will always be in the IO thread\nIs this still a problem even if we mark the Health handler as blocking though? https://github.com/quarkusio/quarkus/blob/1.3.0.Final/extensions/smallrye-health/deployment/src/main/java/io/quarkus/smallrye/health/deployment/SmallRyeHealthProcessor.java#L106\n\nThanks @jmartisk for the clarifications and pointers.\n\nIf it's a problem then I suppose we would need a change to run the health checks (probably all, not just this one) in a different thread pool (which one?)\n\nYes, I think so too. @cescoffier WDYT? Preferably we should do it in another followup PR. I can take it if given enough inputs.", "url": "https://github.com/quarkusio/quarkus/pull/7860#discussion_r393315307", "createdAt": "2020-03-16T21:16:53Z", "author": {"login": "machi1990"}, "path": "extensions/reactive-pg-client/runtime/src/main/java/io/quarkus/reactive/pg/client/runtime/health/ReactivePgDataSourceHealthCheck.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.reactive.pg.client.runtime.health;\n+\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.eclipse.microprofile.health.HealthCheck;\n+import org.eclipse.microprofile.health.HealthCheckResponse;\n+import org.eclipse.microprofile.health.HealthCheckResponseBuilder;\n+import org.eclipse.microprofile.health.Readiness;\n+\n+import io.quarkus.arc.Arc;\n+import io.vertx.pgclient.PgPool;\n+\n+@Readiness\n+@ApplicationScoped\n+public class ReactivePgDataSourceHealthCheck implements HealthCheck {\n+    private PgPool pgPool;\n+\n+    @PostConstruct\n+    protected void init() {\n+        pgPool = Arc.container().instance(PgPool.class).get();\n+    }\n+\n+    @Override\n+    public HealthCheckResponse call() {\n+        HealthCheckResponseBuilder builder = HealthCheckResponse.named(\"Reactive PostgreSQL connection health check\").up();\n+\n+        try {\n+            CompletableFuture<Void> databaseConnectionAttempt = new CompletableFuture<>();\n+            pgPool.query(\"SELECT 1\", ar -> {\n+                if (ar.failed()) {\n+                    builder.down();\n+                }\n+                databaseConnectionAttempt.complete(null);\n+            });\n+            databaseConnectionAttempt.join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1MTg0Nw=="}, "originalCommit": {"oid": "f546849399ae4434152d91f00ab69528d1c54201"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA2ODU0MQ==", "bodyText": "+1 for moving this to another PR", "url": "https://github.com/quarkusio/quarkus/pull/7860#discussion_r397068541", "createdAt": "2020-03-24T11:04:10Z", "author": {"login": "jmartisk"}, "path": "extensions/reactive-pg-client/runtime/src/main/java/io/quarkus/reactive/pg/client/runtime/health/ReactivePgDataSourceHealthCheck.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.reactive.pg.client.runtime.health;\n+\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.eclipse.microprofile.health.HealthCheck;\n+import org.eclipse.microprofile.health.HealthCheckResponse;\n+import org.eclipse.microprofile.health.HealthCheckResponseBuilder;\n+import org.eclipse.microprofile.health.Readiness;\n+\n+import io.quarkus.arc.Arc;\n+import io.vertx.pgclient.PgPool;\n+\n+@Readiness\n+@ApplicationScoped\n+public class ReactivePgDataSourceHealthCheck implements HealthCheck {\n+    private PgPool pgPool;\n+\n+    @PostConstruct\n+    protected void init() {\n+        pgPool = Arc.container().instance(PgPool.class).get();\n+    }\n+\n+    @Override\n+    public HealthCheckResponse call() {\n+        HealthCheckResponseBuilder builder = HealthCheckResponse.named(\"Reactive PostgreSQL connection health check\").up();\n+\n+        try {\n+            CompletableFuture<Void> databaseConnectionAttempt = new CompletableFuture<>();\n+            pgPool.query(\"SELECT 1\", ar -> {\n+                if (ar.failed()) {\n+                    builder.down();\n+                }\n+                databaseConnectionAttempt.complete(null);\n+            });\n+            databaseConnectionAttempt.join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1MTg0Nw=="}, "originalCommit": {"oid": "f546849399ae4434152d91f00ab69528d1c54201"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3NDMyMA==", "bodyText": "@cescoffier ping", "url": "https://github.com/quarkusio/quarkus/pull/7860#discussion_r397074320", "createdAt": "2020-03-24T11:14:43Z", "author": {"login": "machi1990"}, "path": "extensions/reactive-pg-client/runtime/src/main/java/io/quarkus/reactive/pg/client/runtime/health/ReactivePgDataSourceHealthCheck.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.reactive.pg.client.runtime.health;\n+\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.eclipse.microprofile.health.HealthCheck;\n+import org.eclipse.microprofile.health.HealthCheckResponse;\n+import org.eclipse.microprofile.health.HealthCheckResponseBuilder;\n+import org.eclipse.microprofile.health.Readiness;\n+\n+import io.quarkus.arc.Arc;\n+import io.vertx.pgclient.PgPool;\n+\n+@Readiness\n+@ApplicationScoped\n+public class ReactivePgDataSourceHealthCheck implements HealthCheck {\n+    private PgPool pgPool;\n+\n+    @PostConstruct\n+    protected void init() {\n+        pgPool = Arc.container().instance(PgPool.class).get();\n+    }\n+\n+    @Override\n+    public HealthCheckResponse call() {\n+        HealthCheckResponseBuilder builder = HealthCheckResponse.named(\"Reactive PostgreSQL connection health check\").up();\n+\n+        try {\n+            CompletableFuture<Void> databaseConnectionAttempt = new CompletableFuture<>();\n+            pgPool.query(\"SELECT 1\", ar -> {\n+                if (ar.failed()) {\n+                    builder.down();\n+                }\n+                databaseConnectionAttempt.complete(null);\n+            });\n+            databaseConnectionAttempt.join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1MTg0Nw=="}, "originalCommit": {"oid": "f546849399ae4434152d91f00ab69528d1c54201"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEwMzE2Ng==", "bodyText": "yes, it's a blocking route. Still, a blocking route should not be blocked indefinitely.\nI would recommend adding a timeout (10 seconds) because we may not answer at all. The client (Kubernetes) would get an HTTP timeout, but we would consume and waste one of the threads of the worker thread pool.", "url": "https://github.com/quarkusio/quarkus/pull/7860#discussion_r397103166", "createdAt": "2020-03-24T12:07:59Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-pg-client/runtime/src/main/java/io/quarkus/reactive/pg/client/runtime/health/ReactivePgDataSourceHealthCheck.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.reactive.pg.client.runtime.health;\n+\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.eclipse.microprofile.health.HealthCheck;\n+import org.eclipse.microprofile.health.HealthCheckResponse;\n+import org.eclipse.microprofile.health.HealthCheckResponseBuilder;\n+import org.eclipse.microprofile.health.Readiness;\n+\n+import io.quarkus.arc.Arc;\n+import io.vertx.pgclient.PgPool;\n+\n+@Readiness\n+@ApplicationScoped\n+public class ReactivePgDataSourceHealthCheck implements HealthCheck {\n+    private PgPool pgPool;\n+\n+    @PostConstruct\n+    protected void init() {\n+        pgPool = Arc.container().instance(PgPool.class).get();\n+    }\n+\n+    @Override\n+    public HealthCheckResponse call() {\n+        HealthCheckResponseBuilder builder = HealthCheckResponse.named(\"Reactive PostgreSQL connection health check\").up();\n+\n+        try {\n+            CompletableFuture<Void> databaseConnectionAttempt = new CompletableFuture<>();\n+            pgPool.query(\"SELECT 1\", ar -> {\n+                if (ar.failed()) {\n+                    builder.down();\n+                }\n+                databaseConnectionAttempt.complete(null);\n+            });\n+            databaseConnectionAttempt.join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1MTg0Nw=="}, "originalCommit": {"oid": "f546849399ae4434152d91f00ab69528d1c54201"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNjcwNw==", "bodyText": "Where should we ideally process it though? Does the health extension need to maintain its own thread pool or is there a common thread pool that would be appropriate to use?", "url": "https://github.com/quarkusio/quarkus/pull/7860#discussion_r397126707", "createdAt": "2020-03-24T12:50:13Z", "author": {"login": "jmartisk"}, "path": "extensions/reactive-pg-client/runtime/src/main/java/io/quarkus/reactive/pg/client/runtime/health/ReactivePgDataSourceHealthCheck.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.reactive.pg.client.runtime.health;\n+\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.eclipse.microprofile.health.HealthCheck;\n+import org.eclipse.microprofile.health.HealthCheckResponse;\n+import org.eclipse.microprofile.health.HealthCheckResponseBuilder;\n+import org.eclipse.microprofile.health.Readiness;\n+\n+import io.quarkus.arc.Arc;\n+import io.vertx.pgclient.PgPool;\n+\n+@Readiness\n+@ApplicationScoped\n+public class ReactivePgDataSourceHealthCheck implements HealthCheck {\n+    private PgPool pgPool;\n+\n+    @PostConstruct\n+    protected void init() {\n+        pgPool = Arc.container().instance(PgPool.class).get();\n+    }\n+\n+    @Override\n+    public HealthCheckResponse call() {\n+        HealthCheckResponseBuilder builder = HealthCheckResponse.named(\"Reactive PostgreSQL connection health check\").up();\n+\n+        try {\n+            CompletableFuture<Void> databaseConnectionAttempt = new CompletableFuture<>();\n+            pgPool.query(\"SELECT 1\", ar -> {\n+                if (ar.failed()) {\n+                    builder.down();\n+                }\n+                databaseConnectionAttempt.complete(null);\n+            });\n+            databaseConnectionAttempt.join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1MTg0Nw=="}, "originalCommit": {"oid": "f546849399ae4434152d91f00ab69528d1c54201"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMzNjkxNg==", "bodyText": "@cescoffier I have added a 10s timeout.\n+1 with @jmartisk question up there. Should help with the next step.", "url": "https://github.com/quarkusio/quarkus/pull/7860#discussion_r397336916", "createdAt": "2020-03-24T17:32:19Z", "author": {"login": "machi1990"}, "path": "extensions/reactive-pg-client/runtime/src/main/java/io/quarkus/reactive/pg/client/runtime/health/ReactivePgDataSourceHealthCheck.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.reactive.pg.client.runtime.health;\n+\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.eclipse.microprofile.health.HealthCheck;\n+import org.eclipse.microprofile.health.HealthCheckResponse;\n+import org.eclipse.microprofile.health.HealthCheckResponseBuilder;\n+import org.eclipse.microprofile.health.Readiness;\n+\n+import io.quarkus.arc.Arc;\n+import io.vertx.pgclient.PgPool;\n+\n+@Readiness\n+@ApplicationScoped\n+public class ReactivePgDataSourceHealthCheck implements HealthCheck {\n+    private PgPool pgPool;\n+\n+    @PostConstruct\n+    protected void init() {\n+        pgPool = Arc.container().instance(PgPool.class).get();\n+    }\n+\n+    @Override\n+    public HealthCheckResponse call() {\n+        HealthCheckResponseBuilder builder = HealthCheckResponse.named(\"Reactive PostgreSQL connection health check\").up();\n+\n+        try {\n+            CompletableFuture<Void> databaseConnectionAttempt = new CompletableFuture<>();\n+            pgPool.query(\"SELECT 1\", ar -> {\n+                if (ar.failed()) {\n+                    builder.down();\n+                }\n+                databaseConnectionAttempt.complete(null);\n+            });\n+            databaseConnectionAttempt.join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1MTg0Nw=="}, "originalCommit": {"oid": "f546849399ae4434152d91f00ab69528d1c54201"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE3MDU0MA==", "bodyText": "@cescoffier do you have sometime to have another look and see if all comments have been addressed? Thanks.", "url": "https://github.com/quarkusio/quarkus/pull/7860#discussion_r410170540", "createdAt": "2020-04-17T11:47:42Z", "author": {"login": "machi1990"}, "path": "extensions/reactive-pg-client/runtime/src/main/java/io/quarkus/reactive/pg/client/runtime/health/ReactivePgDataSourceHealthCheck.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.reactive.pg.client.runtime.health;\n+\n+import java.util.concurrent.CompletableFuture;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.eclipse.microprofile.health.HealthCheck;\n+import org.eclipse.microprofile.health.HealthCheckResponse;\n+import org.eclipse.microprofile.health.HealthCheckResponseBuilder;\n+import org.eclipse.microprofile.health.Readiness;\n+\n+import io.quarkus.arc.Arc;\n+import io.vertx.pgclient.PgPool;\n+\n+@Readiness\n+@ApplicationScoped\n+public class ReactivePgDataSourceHealthCheck implements HealthCheck {\n+    private PgPool pgPool;\n+\n+    @PostConstruct\n+    protected void init() {\n+        pgPool = Arc.container().instance(PgPool.class).get();\n+    }\n+\n+    @Override\n+    public HealthCheckResponse call() {\n+        HealthCheckResponseBuilder builder = HealthCheckResponse.named(\"Reactive PostgreSQL connection health check\").up();\n+\n+        try {\n+            CompletableFuture<Void> databaseConnectionAttempt = new CompletableFuture<>();\n+            pgPool.query(\"SELECT 1\", ar -> {\n+                if (ar.failed()) {\n+                    builder.down();\n+                }\n+                databaseConnectionAttempt.complete(null);\n+            });\n+            databaseConnectionAttempt.join();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1MTg0Nw=="}, "originalCommit": {"oid": "f546849399ae4434152d91f00ab69528d1c54201"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjcwMDM5OnYy", "diffSide": "RIGHT", "path": "extensions/reactive-pg-client/runtime/src/main/java/io/quarkus/reactive/pg/client/runtime/health/ReactivePgDataSourceHealthCheck.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMTo1NDoyOFrOGHK_3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTowNjo1NlrOGO2m-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE3MzQwNw==", "bodyText": "Does \"SELECT 1\" trigger a roundtrip with the database?\nJust want to be sure.", "url": "https://github.com/quarkusio/quarkus/pull/7860#discussion_r410173407", "createdAt": "2020-04-17T11:54:28Z", "author": {"login": "cescoffier"}, "path": "extensions/reactive-pg-client/runtime/src/main/java/io/quarkus/reactive/pg/client/runtime/health/ReactivePgDataSourceHealthCheck.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package io.quarkus.reactive.pg.client.runtime.health;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.eclipse.microprofile.health.HealthCheck;\n+import org.eclipse.microprofile.health.HealthCheckResponse;\n+import org.eclipse.microprofile.health.HealthCheckResponseBuilder;\n+import org.eclipse.microprofile.health.Readiness;\n+\n+import io.quarkus.arc.Arc;\n+import io.vertx.pgclient.PgPool;\n+\n+@Readiness\n+@ApplicationScoped\n+public class ReactivePgDataSourceHealthCheck implements HealthCheck {\n+    private PgPool pgPool;\n+\n+    @PostConstruct\n+    protected void init() {\n+        pgPool = Arc.container().instance(PgPool.class).get();\n+    }\n+\n+    @Override\n+    public HealthCheckResponse call() {\n+        HealthCheckResponseBuilder builder = HealthCheckResponse.named(\"Reactive PostgreSQL connection health check\").up();\n+\n+        try {\n+            CompletableFuture<Void> databaseConnectionAttempt = new CompletableFuture<>();\n+            pgPool.query(\"SELECT 1\", ar -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e168564bf5a3a5d3e9dc3057462829420363705"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIyNzk2Mw==", "bodyText": "It should except if they do some weird magic in the driver but that would be surprising.", "url": "https://github.com/quarkusio/quarkus/pull/7860#discussion_r418227963", "createdAt": "2020-04-30T19:06:56Z", "author": {"login": "gsmet"}, "path": "extensions/reactive-pg-client/runtime/src/main/java/io/quarkus/reactive/pg/client/runtime/health/ReactivePgDataSourceHealthCheck.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package io.quarkus.reactive.pg.client.runtime.health;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.PostConstruct;\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.eclipse.microprofile.health.HealthCheck;\n+import org.eclipse.microprofile.health.HealthCheckResponse;\n+import org.eclipse.microprofile.health.HealthCheckResponseBuilder;\n+import org.eclipse.microprofile.health.Readiness;\n+\n+import io.quarkus.arc.Arc;\n+import io.vertx.pgclient.PgPool;\n+\n+@Readiness\n+@ApplicationScoped\n+public class ReactivePgDataSourceHealthCheck implements HealthCheck {\n+    private PgPool pgPool;\n+\n+    @PostConstruct\n+    protected void init() {\n+        pgPool = Arc.container().instance(PgPool.class).get();\n+    }\n+\n+    @Override\n+    public HealthCheckResponse call() {\n+        HealthCheckResponseBuilder builder = HealthCheckResponse.named(\"Reactive PostgreSQL connection health check\").up();\n+\n+        try {\n+            CompletableFuture<Void> databaseConnectionAttempt = new CompletableFuture<>();\n+            pgPool.query(\"SELECT 1\", ar -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE3MzQwNw=="}, "originalCommit": {"oid": "5e168564bf5a3a5d3e9dc3057462829420363705"}, "originalPosition": 33}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4875, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}