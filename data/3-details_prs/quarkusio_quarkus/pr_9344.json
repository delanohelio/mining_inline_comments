{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4NTY0MjA5", "number": 9344, "title": "Getting Funqy Ready for Release", "bodyText": "Polished up Knative Event, Lambda, Azure Function support\nCreated Funqy documentation.", "createdAt": "2020-05-15T12:29:49Z", "url": "https://github.com/quarkusio/quarkus/pull/9344", "merged": true, "mergeCommit": {"oid": "37df7e7e240c5471a5f6265cff15d80ddf0286e1"}, "closed": true, "closedAt": "2020-05-20T11:49:47Z", "author": {"login": "patriot1burke"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABchh8GrABqjMzNDA4ODM1MTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcjFEV7ABqjMzNTUzOTM5MTc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a8b72396c6fcfab4eb2f9824fc8c8d1ef878bb5a", "author": {"user": {"login": "patriot1burke", "name": "Bill Burke"}}, "url": "https://github.com/quarkusio/quarkus/commit/a8b72396c6fcfab4eb2f9824fc8c8d1ef878bb5a", "committedDate": "2020-05-15T12:19:02Z", "message": "funqy-knative rename to funqy-knative-events\n\nfunqy events finished\n\nlambda\n\nfunqy docs\n\nfunqy azure functions\n\ncleanup rootpath\n\ncontext injection of cloud event\n\nremove funqy azure maven archetype\n\nknative event docs\n\nreview funqy docs"}, "afterCommit": {"oid": "ee0753a81c92e5edeede8b72543180ee5076c155", "author": {"user": {"login": "patriot1burke", "name": "Bill Burke"}}, "url": "https://github.com/quarkusio/quarkus/commit/ee0753a81c92e5edeede8b72543180ee5076c155", "committedDate": "2020-05-15T13:17:57Z", "message": "funqy-knative rename to funqy-knative-events\n\nfunqy events finished\n\nlambda\n\nfunqy docs\n\nfunqy azure functions\n\ncleanup rootpath\n\ncontext injection of cloud event\n\nremove funqy azure maven archetype\n\nknative event docs\n\nreview funqy docs\n\nfunqy source formatting"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMzAxNTI5", "url": "https://github.com/quarkusio/quarkus/pull/9344#pullrequestreview-413301529", "createdAt": "2020-05-18T06:28:24Z", "commit": {"oid": "ee0753a81c92e5edeede8b72543180ee5076c155"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNjoyODoyNVrOGWpCkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNjo0MTo0NlrOGWpVIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5NDI1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            frameworks on Amazon Lambda.  Including Funqy.\n          \n          \n            \n            frameworks on Amazon Lambda, including Funqy.", "url": "https://github.com/quarkusio/quarkus/pull/9344#discussion_r426394256", "createdAt": "2020-05-18T06:28:25Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/funqy-amazon-lambda-http.adoc", "diffHunk": "@@ -0,0 +1,48 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Funqy HTTP with Amazon Lambda\u00a0\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+If you like link:funqy-http[Funqy HTTP], you can use it on AWS Lambda.  Quarkus allows you to expose multiple\n+Funqy functions through HTTP deployed as one AWS Lambda.\n+\n+include::./status-include.adoc[]\n+\n+Follow the link:amazon-lambda-http[Amazon Lambda Http Guide].  It walks through using a variety of HTTP\n+frameworks on Amazon Lambda.  Including Funqy.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee0753a81c92e5edeede8b72543180ee5076c155"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5NTc1OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The are times where you may have to add some additions to the `function.zip` lambda deployment that is generated\n          \n          \n            \n            The are times where you may have to add some addition entries to the `function.zip` lambda deployment that is generated", "url": "https://github.com/quarkusio/quarkus/pull/9344#discussion_r426395758", "createdAt": "2020-05-18T06:32:45Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/funqy-amazon-lambda.adoc", "diffHunk": "@@ -0,0 +1,312 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Funqy Amazon Lambda\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+The guide walks through quickstart code to show you how you can deploy Funqy functions to Amazon Lambda.\n+\n+Funqy functions can be deployed using the Amazon Java Runtime, or you can build a native executable and use\n+Amazon's Custom Runtime if you want a smaller memory footprint and faster cold boot startup time.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 30 minutes\n+* JDK 11 (AWS requires JDK 1.8 or 11)\n+* Apache Maven {maven-version}\n+* https://aws.amazon.com[An Amazon AWS account]\n+* https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html[AWS CLI]\n+* https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI], for local testing\n+\n+NOTE: Funqy Amazon Lambdas build off of our link:amazon-lambda[Quarkus Amazon Lambda support].\n+\n+== Installing AWS bits\n+\n+Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps\n+for installing AWS CLI.\n+\n+== The Quickstart\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `funqy-amazon-lambda-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-quickstart[directory].\n+\n+== The Code\n+\n+There is nothing special about the code and more importantly nothing AWS specific.  Funqy functions can be deployed to many different\n+environments and AWS Lambda is one of them.  The Java code is actually the same exact code as the {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[funqy-http-quickstart]\n+\n+[[choose]]\n+== Choose Your Function\n+\n+Only one Funqy function can be exported per Amazon Lambda deployment.  If you only have one method\n+annotated with `@Funq` in your project, then there is no worries.  If you have multiple functions defined\n+within your project, then you will need to choose the function within your Quarkus `application.properties`:\n+\n+[source, subs=attributes+]\n+----\n+quarkus.funqy.export=greet\n+----\n+\n+You can see how the quickstart has done it within its own {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-quickstart/src/main/resources/application.properties[application.properties]\n+\n+Alternatively, you can set the `QUARKUS_FUNQY_EXPORT` environment variable when you create the Amazon Lambda using the `aws` cli.\n+\n+== Deploy to AWS Lambda Java Runtime\n+\n+There are a few steps to get your Funqy function running on AWS Lambda.  The quickstart maven project generates a helpful script to\n+create, update, delete, and invoke your functions for pure Java and native deployments.  This script is generated\n+at build time.\n+\n+== Build and Deploy\n+\n+Build the project using maven.\n+\n+[source, subs=attributes+]\n+----\n+./mvnw clean package\n+----\n+\n+This will compile and package your code.\n+\n+== Create an Execution Role\n+\n+View the https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html[Getting Started Guide] for deploying\n+a lambda with AWS CLI.  Specifically, make sure you have created an `Execution Role`.  You will need to define\n+a `LAMBDA_ROLE_ARN` environment variable in your profile or console window,  Alternatively, you can edit\n+the `manage.sh` script that is generated by the build and put the role value directly there:\n+\n+[source]\n+----\n+LAMBDA_ROLE_ARN=\"arn:aws:iam::1234567890:role/lambda-role\"\n+----\n+\n+== Extra Build Generated Files\n+\n+After you run the build, there are a few extra files generated by the `quarkus-funqy-amazon-lambda` extension.  These files\n+are in the the build directory:  `target/` for maven, `build/` for gradle.\n+\n+* `function.zip` - lambda deployment file\n+* `manage.sh` - wrapper around aws lamba cli calls\n+* `bootstrap-example.sh` - example bootstrap script for native deployments\n+* `sam.jvm.yaml` - (optional) for use with sam cli and local testing\n+* `sam.native.yaml` - (optional) for use with sam cli and native local testing\n+\n+== Create the function\n+\n+The `target/manage.sh` script is for managing your Funqy function using the AWS Lambda Java runtime.  This script is provided only for\n+your convenience. Examine the output of the `manage.sh` script if you want to learn what aws commands are executed\n+to create, delete, and update your functions.\n+\n+`manage.sh` supports four operation:  `create`, `delete`, `update`, and `invoke`.\n+\n+NOTE: To verify your setup, that you have the AWS CLI installed, executed aws configure for the AWS access keys,\n+and setup the `LAMBDA_ROLE_ARN` environment variable (as described above), please execute `manage.sh` without any parameters.\n+A usage statement will be printed to guide you accordingly.\n+\n+To see the `usage` statement, and validate AWS configuration:\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh\n+----\n+\n+You can `create` your function using the following command:\n+\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh create\n+----\n+\n+or if you do not have `LAMBDA_ROLE_ARN` already defined in this shell:\n+\n+[source]\n+----\n+LAMBDA_ROLE_ARN=\"arn:aws:iam::1234567890:role/lambda-role\" sh target/manage.sh create\n+----\n+\n+WARNING: Do not change the handler switch.  This must be hardcoded to `io.quarkus.funqy.lambda.FunqyStreamHandler::handleRequest`.\n+This special handler is Funqy's integration point with AWS Lambda.\n+\n+If there are any problems creating the function, you must delete it with the `delete` function before re-running\n+the `create` command.\n+\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh delete\n+----\n+\n+Commands may also be stacked:\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh delete create\n+----\n+\n+== Invoke the function\n+\n+Use the `invoke` command to invoke your function.\n+\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh invoke\n+----\n+\n+The example function takes input passed in via the `--payload` switch which points to a json file\n+in the root directory of the project.\n+\n+The function can also be invoked locally with the SAM CLI like this:\n+\n+[source]\n+----\n+sam local invoke --template target/sam.jvm.yaml --event payload.json\n+----\n+\n+If you are working with your native image build, simply replace the template name with the native version:\n+\n+[source]\n+----\n+sam local invoke --template target/sam.native.yaml --event payload.json\n+----\n+\n+== Update the function\n+\n+You can update the Java code as you see fit.  Once you've rebuilt, you can redeploy your function by executing the\n+`update` command.\n+\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh update\n+----\n+\n+== Deploy to AWS Lambda Custom (native) Runtime\n+\n+If you want a lower memory footprint and faster initialization times for your Funqy function, you can compile your Java\n+code to a native executable.  Just make sure to rebuild your project with the `-Pnative` switch.\n+\n+For Linux hosts execute:\n+\n+[source, subs=attributes+]\n+----\n+mvn package -Pnative\n+----\n+\n+NOTE: If you are building on a non-Linux system, you will need to also pass in a property instructing quarkus to use a docker build as Amazon\n+Lambda requires linux binaries.  You can do this by passing this property to your Maven build:\n+`-Dnative-image.docker-build=true`, or for Gradle: `--docker-build=true`.  This requires you to have docker installed locally, however.\n+\n+[source, subs=attributes+]\n+----\n+./mvnw clean install -Pnative -Dnative-image.docker-build=true\n+----\n+\n+Either of these commands will compile and create a native executable image.  It also generates a zip file `target/function.zip`.\n+This zip file contains your native executable image renamed to `bootstrap`.  This is a requirement of the AWS Lambda\n+Custom (Provided) Runtime.\n+\n+The instructions here are exactly as above with one change:  you'll need to add `native` as the first parameter to the\n+`manage.sh` script:\n+\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh native create\n+----\n+\n+As above, commands can be stacked.  The only requirement is that `native` be the first parameter should you wish\n+to work with native image builds.  The script will take care of the rest of the details necessary to manage your native\n+image function deployments.\n+\n+Examine the output of the `manage.sh` script if you want to learn what aws commands are executed\n+to create, delete, and update your functions.\n+\n+One thing to note about the create command for native is that the `aws lambda create-function`\n+call must set a specific environment variable:\n+\n+[source, subs=attributes+]\n+----\n+--environment 'Variables={DISABLE_SIGNAL_HANDLERS=true}'\n+----\n+\n+== Examine the POM\n+\n+There is nothing special about the POM other than the inclusion of the `quarkus-funqy-amazon-lambda` and `quarkus-test-amazon-lambda` extensions\n+as a dependencies.  The extension automatically generates everything you might need for your lambda deployment.\n+\n+== Integration Testing\n+\n+Funqy Amazon Lambda support leverages the Quarkus AWS Lambda test framework so that you can unit tests your Funqy functions.\n+This is true for both JVM and native modes.\n+This test frameowrk provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+If you open up {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-quickstart/src/test/java/org/acme/funqy/FunqyTest.java[FunqyTest.java]\n+you'll see that the test replicates the AWS execution environment.\n+\n+[source,java]\n+----\n+package org.acme.funqy;\n+\n+import io.quarkus.amazon.lambda.test.LambdaClient;\n+import io.quarkus.test.junit.QuarkusTest;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+@QuarkusTest\n+public class FunqyTest {\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        Friend friend = new Friend(\"Bill\");\n+        Greeting out = LambdaClient.invoke(Greeting.class, friend);\n+        Assertions.assertEquals(\"Hello Bill\", out.getMessage());\n+    }\n+}\n+----\n+\n+== Testing with the SAM CLI\n+\n+The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]\n+allows you to run your functions locally on your laptop in a simulated Lambda environment.  This requires\n+https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose\n+to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.\n+\n+A starter template has been generated for both JVM and native execution modes.\n+\n+Run the following SAM CLI command to locally test your function, passing the appropriate SAM `template`.\n+The `event` parameter takes any JSON file, in this case the sample `payload.json`.\n+\n+[source]\n+----\n+sam local invoke --template target/sam.jvm.yaml --event payload.json\n+----\n+\n+The native image can also be locally tested using the `sam.native.yaml` template:\n+\n+[source]\n+----\n+sam local invoke --template target/sam.native.yaml --event payload.json\n+----\n+\n+== Modifying `function.zip`\n+\n+The are times where you may have to add some additions to the `function.zip` lambda deployment that is generated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee0753a81c92e5edeede8b72543180ee5076c155"}, "originalPosition": 296}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5NTkxOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            There are times you may want to set a specific system properties or other arguments when lambda invokes\n          \n          \n            \n            There are times you may want to set specific system properties or other arguments when lambda invokes", "url": "https://github.com/quarkusio/quarkus/pull/9344#discussion_r426395918", "createdAt": "2020-05-18T06:33:07Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/funqy-amazon-lambda.adoc", "diffHunk": "@@ -0,0 +1,312 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Funqy Amazon Lambda\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+The guide walks through quickstart code to show you how you can deploy Funqy functions to Amazon Lambda.\n+\n+Funqy functions can be deployed using the Amazon Java Runtime, or you can build a native executable and use\n+Amazon's Custom Runtime if you want a smaller memory footprint and faster cold boot startup time.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 30 minutes\n+* JDK 11 (AWS requires JDK 1.8 or 11)\n+* Apache Maven {maven-version}\n+* https://aws.amazon.com[An Amazon AWS account]\n+* https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html[AWS CLI]\n+* https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI], for local testing\n+\n+NOTE: Funqy Amazon Lambdas build off of our link:amazon-lambda[Quarkus Amazon Lambda support].\n+\n+== Installing AWS bits\n+\n+Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps\n+for installing AWS CLI.\n+\n+== The Quickstart\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `funqy-amazon-lambda-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-quickstart[directory].\n+\n+== The Code\n+\n+There is nothing special about the code and more importantly nothing AWS specific.  Funqy functions can be deployed to many different\n+environments and AWS Lambda is one of them.  The Java code is actually the same exact code as the {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[funqy-http-quickstart]\n+\n+[[choose]]\n+== Choose Your Function\n+\n+Only one Funqy function can be exported per Amazon Lambda deployment.  If you only have one method\n+annotated with `@Funq` in your project, then there is no worries.  If you have multiple functions defined\n+within your project, then you will need to choose the function within your Quarkus `application.properties`:\n+\n+[source, subs=attributes+]\n+----\n+quarkus.funqy.export=greet\n+----\n+\n+You can see how the quickstart has done it within its own {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-quickstart/src/main/resources/application.properties[application.properties]\n+\n+Alternatively, you can set the `QUARKUS_FUNQY_EXPORT` environment variable when you create the Amazon Lambda using the `aws` cli.\n+\n+== Deploy to AWS Lambda Java Runtime\n+\n+There are a few steps to get your Funqy function running on AWS Lambda.  The quickstart maven project generates a helpful script to\n+create, update, delete, and invoke your functions for pure Java and native deployments.  This script is generated\n+at build time.\n+\n+== Build and Deploy\n+\n+Build the project using maven.\n+\n+[source, subs=attributes+]\n+----\n+./mvnw clean package\n+----\n+\n+This will compile and package your code.\n+\n+== Create an Execution Role\n+\n+View the https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html[Getting Started Guide] for deploying\n+a lambda with AWS CLI.  Specifically, make sure you have created an `Execution Role`.  You will need to define\n+a `LAMBDA_ROLE_ARN` environment variable in your profile or console window,  Alternatively, you can edit\n+the `manage.sh` script that is generated by the build and put the role value directly there:\n+\n+[source]\n+----\n+LAMBDA_ROLE_ARN=\"arn:aws:iam::1234567890:role/lambda-role\"\n+----\n+\n+== Extra Build Generated Files\n+\n+After you run the build, there are a few extra files generated by the `quarkus-funqy-amazon-lambda` extension.  These files\n+are in the the build directory:  `target/` for maven, `build/` for gradle.\n+\n+* `function.zip` - lambda deployment file\n+* `manage.sh` - wrapper around aws lamba cli calls\n+* `bootstrap-example.sh` - example bootstrap script for native deployments\n+* `sam.jvm.yaml` - (optional) for use with sam cli and local testing\n+* `sam.native.yaml` - (optional) for use with sam cli and native local testing\n+\n+== Create the function\n+\n+The `target/manage.sh` script is for managing your Funqy function using the AWS Lambda Java runtime.  This script is provided only for\n+your convenience. Examine the output of the `manage.sh` script if you want to learn what aws commands are executed\n+to create, delete, and update your functions.\n+\n+`manage.sh` supports four operation:  `create`, `delete`, `update`, and `invoke`.\n+\n+NOTE: To verify your setup, that you have the AWS CLI installed, executed aws configure for the AWS access keys,\n+and setup the `LAMBDA_ROLE_ARN` environment variable (as described above), please execute `manage.sh` without any parameters.\n+A usage statement will be printed to guide you accordingly.\n+\n+To see the `usage` statement, and validate AWS configuration:\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh\n+----\n+\n+You can `create` your function using the following command:\n+\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh create\n+----\n+\n+or if you do not have `LAMBDA_ROLE_ARN` already defined in this shell:\n+\n+[source]\n+----\n+LAMBDA_ROLE_ARN=\"arn:aws:iam::1234567890:role/lambda-role\" sh target/manage.sh create\n+----\n+\n+WARNING: Do not change the handler switch.  This must be hardcoded to `io.quarkus.funqy.lambda.FunqyStreamHandler::handleRequest`.\n+This special handler is Funqy's integration point with AWS Lambda.\n+\n+If there are any problems creating the function, you must delete it with the `delete` function before re-running\n+the `create` command.\n+\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh delete\n+----\n+\n+Commands may also be stacked:\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh delete create\n+----\n+\n+== Invoke the function\n+\n+Use the `invoke` command to invoke your function.\n+\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh invoke\n+----\n+\n+The example function takes input passed in via the `--payload` switch which points to a json file\n+in the root directory of the project.\n+\n+The function can also be invoked locally with the SAM CLI like this:\n+\n+[source]\n+----\n+sam local invoke --template target/sam.jvm.yaml --event payload.json\n+----\n+\n+If you are working with your native image build, simply replace the template name with the native version:\n+\n+[source]\n+----\n+sam local invoke --template target/sam.native.yaml --event payload.json\n+----\n+\n+== Update the function\n+\n+You can update the Java code as you see fit.  Once you've rebuilt, you can redeploy your function by executing the\n+`update` command.\n+\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh update\n+----\n+\n+== Deploy to AWS Lambda Custom (native) Runtime\n+\n+If you want a lower memory footprint and faster initialization times for your Funqy function, you can compile your Java\n+code to a native executable.  Just make sure to rebuild your project with the `-Pnative` switch.\n+\n+For Linux hosts execute:\n+\n+[source, subs=attributes+]\n+----\n+mvn package -Pnative\n+----\n+\n+NOTE: If you are building on a non-Linux system, you will need to also pass in a property instructing quarkus to use a docker build as Amazon\n+Lambda requires linux binaries.  You can do this by passing this property to your Maven build:\n+`-Dnative-image.docker-build=true`, or for Gradle: `--docker-build=true`.  This requires you to have docker installed locally, however.\n+\n+[source, subs=attributes+]\n+----\n+./mvnw clean install -Pnative -Dnative-image.docker-build=true\n+----\n+\n+Either of these commands will compile and create a native executable image.  It also generates a zip file `target/function.zip`.\n+This zip file contains your native executable image renamed to `bootstrap`.  This is a requirement of the AWS Lambda\n+Custom (Provided) Runtime.\n+\n+The instructions here are exactly as above with one change:  you'll need to add `native` as the first parameter to the\n+`manage.sh` script:\n+\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh native create\n+----\n+\n+As above, commands can be stacked.  The only requirement is that `native` be the first parameter should you wish\n+to work with native image builds.  The script will take care of the rest of the details necessary to manage your native\n+image function deployments.\n+\n+Examine the output of the `manage.sh` script if you want to learn what aws commands are executed\n+to create, delete, and update your functions.\n+\n+One thing to note about the create command for native is that the `aws lambda create-function`\n+call must set a specific environment variable:\n+\n+[source, subs=attributes+]\n+----\n+--environment 'Variables={DISABLE_SIGNAL_HANDLERS=true}'\n+----\n+\n+== Examine the POM\n+\n+There is nothing special about the POM other than the inclusion of the `quarkus-funqy-amazon-lambda` and `quarkus-test-amazon-lambda` extensions\n+as a dependencies.  The extension automatically generates everything you might need for your lambda deployment.\n+\n+== Integration Testing\n+\n+Funqy Amazon Lambda support leverages the Quarkus AWS Lambda test framework so that you can unit tests your Funqy functions.\n+This is true for both JVM and native modes.\n+This test frameowrk provides similar functionality to the SAM CLI, without the overhead of Docker.\n+\n+If you open up {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-quickstart/src/test/java/org/acme/funqy/FunqyTest.java[FunqyTest.java]\n+you'll see that the test replicates the AWS execution environment.\n+\n+[source,java]\n+----\n+package org.acme.funqy;\n+\n+import io.quarkus.amazon.lambda.test.LambdaClient;\n+import io.quarkus.test.junit.QuarkusTest;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+@QuarkusTest\n+public class FunqyTest {\n+    @Test\n+    public void testSimpleLambdaSuccess() throws Exception {\n+        Friend friend = new Friend(\"Bill\");\n+        Greeting out = LambdaClient.invoke(Greeting.class, friend);\n+        Assertions.assertEquals(\"Hello Bill\", out.getMessage());\n+    }\n+}\n+----\n+\n+== Testing with the SAM CLI\n+\n+The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI]\n+allows you to run your functions locally on your laptop in a simulated Lambda environment.  This requires\n+https://www.docker.com/products/docker-desktop[docker] to be installed.  This is an optional approach should you choose\n+to take advantage of it.  Otherwise, the Quarkus JUnit integration should be sufficient for most of your needs.\n+\n+A starter template has been generated for both JVM and native execution modes.\n+\n+Run the following SAM CLI command to locally test your function, passing the appropriate SAM `template`.\n+The `event` parameter takes any JSON file, in this case the sample `payload.json`.\n+\n+[source]\n+----\n+sam local invoke --template target/sam.jvm.yaml --event payload.json\n+----\n+\n+The native image can also be locally tested using the `sam.native.yaml` template:\n+\n+[source]\n+----\n+sam local invoke --template target/sam.native.yaml --event payload.json\n+----\n+\n+== Modifying `function.zip`\n+\n+The are times where you may have to add some additions to the `function.zip` lambda deployment that is generated\n+by the build.  To do this create a `zip.jvm` or `zip.native` directory within `src/main`.\n+Create `zip.jvm/` if you are doing a pure Java.  `zip.native/` if you are doing a native deployment.\n+\n+Any you files and directories you create under your zip directory will be included within `function.zip`\n+\n+== Custom `bootstrap` script\n+\n+There are times you may want to set a specific system properties or other arguments when lambda invokes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee0753a81c92e5edeede8b72543180ee5076c155"}, "originalPosition": 304}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5NjMyNA==", "bodyText": "If we find a JSON parser that's better than Jackson we will use it sound a little vague, what does it mean in practice?", "url": "https://github.com/quarkusio/quarkus/pull/9344#discussion_r426396324", "createdAt": "2020-05-18T06:34:19Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/funqy-http.adoc", "diffHunk": "@@ -0,0 +1,106 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Funqy HTTP\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+\n+The guide walks through quickstart code to show you how you can deploy and invoke on Funqy functions in a pure HTTP environment.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* Read about link:funqy[Funqy Basics].  This is a short read!\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+\n+== The Quickstart\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `funqy-http-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[directory].\n+\n+== The Code\n+\n+If you look at the Java code, you'll see that there is no HTTP specific API.  Its just simple Java methods\n+annotated with `@Funq`.  Simple, easy, straightforward.\n+\n+== Build Project\n+\n+[source, shell]\n+----\n+mvn clean quarkus:dev\n+----\n+\n+This starts your functions in Quarkus dev mode.\n+\n+== Execute Funqy HTTP functions\n+\n+Funqy HTTP input and output is always JSON.  The Jackson JSON parser is used behind the scenes and you can\n+use Jackson annotations to fine tune your JSON mappings for your input and output objects.  We do not recommend\n+using Jackson annotations though.  If we find a JSON parser that's better than Jackson we will use it!  So try", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee0753a81c92e5edeede8b72543180ee5076c155"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5NjQ0Nw==", "bodyText": "Perhaps tone this down a bit?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            to write Java bean style input and output classes and avoid using Jackson annotations!\n          \n          \n            \n            to write Java bean style input and output classes and avoid using Jackson annotations", "url": "https://github.com/quarkusio/quarkus/pull/9344#discussion_r426396447", "createdAt": "2020-05-18T06:34:43Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/funqy-http.adoc", "diffHunk": "@@ -0,0 +1,106 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Funqy HTTP\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+\n+The guide walks through quickstart code to show you how you can deploy and invoke on Funqy functions in a pure HTTP environment.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* Read about link:funqy[Funqy Basics].  This is a short read!\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+\n+== The Quickstart\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `funqy-http-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[directory].\n+\n+== The Code\n+\n+If you look at the Java code, you'll see that there is no HTTP specific API.  Its just simple Java methods\n+annotated with `@Funq`.  Simple, easy, straightforward.\n+\n+== Build Project\n+\n+[source, shell]\n+----\n+mvn clean quarkus:dev\n+----\n+\n+This starts your functions in Quarkus dev mode.\n+\n+== Execute Funqy HTTP functions\n+\n+Funqy HTTP input and output is always JSON.  The Jackson JSON parser is used behind the scenes and you can\n+use Jackson annotations to fine tune your JSON mappings for your input and output objects.  We do not recommend\n+using Jackson annotations though.  If we find a JSON parser that's better than Jackson we will use it!  So try\n+to write Java bean style input and output classes and avoid using Jackson annotations!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee0753a81c92e5edeede8b72543180ee5076c155"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5NzEzMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Setting up Knative locally in a Minikube environment is beyond the scope of this guide.  You must\n          \n          \n            \n            walk through this link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html[Knative Tutorial]\n          \n          \n            \n            Setting up Knative locally in a Minikube environment is beyond the scope of this guide.  It is advised\n          \n          \n            \n            to follow  https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html[this] Knative Tutorial", "url": "https://github.com/quarkusio/quarkus/pull/9344#discussion_r426397130", "createdAt": "2020-05-18T06:36:35Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/funqy-knative-events.adoc", "diffHunk": "@@ -0,0 +1,363 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Funqy Knative Events\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+\n+Quarkus Funqy link:https://knative.dev/docs/eventing[Knative Events] builds off of the link:funqy-http[Funqy HTTP] extension to allow you to\n+route and process Knative Events within a Funqy function.\n+\n+The guide walks through quickstart code to show you how you can deploy and invoke on Funqy functions\n+with Knative Events.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* 60+ minutes\n+* Read about link:funqy[Funqy Basics].  This is a short read!\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Have gone through the link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html[Knative Tutorial], specifically link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial-eventing/eventing-trigger-broker.html[Brokers and Triggers]\n+\n+== Setting up Knative\n+\n+Setting up Knative locally in a Minikube environment is beyond the scope of this guide.  You must\n+walk through this link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html[Knative Tutorial]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee0753a81c92e5edeede8b72543180ee5076c155"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5ODA0NQ==", "bodyText": "In a subsequent revisions, we should see how we can integrate this with the Quarkus Kubernetes extensions that has some support for KNative", "url": "https://github.com/quarkusio/quarkus/pull/9344#discussion_r426398045", "createdAt": "2020-05-18T06:39:08Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/funqy-knative-events.adoc", "diffHunk": "@@ -0,0 +1,363 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Funqy Knative Events\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+\n+Quarkus Funqy link:https://knative.dev/docs/eventing[Knative Events] builds off of the link:funqy-http[Funqy HTTP] extension to allow you to\n+route and process Knative Events within a Funqy function.\n+\n+The guide walks through quickstart code to show you how you can deploy and invoke on Funqy functions\n+with Knative Events.\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* 60+ minutes\n+* Read about link:funqy[Funqy Basics].  This is a short read!\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Have gone through the link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html[Knative Tutorial], specifically link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial-eventing/eventing-trigger-broker.html[Brokers and Triggers]\n+\n+== Setting up Knative\n+\n+Setting up Knative locally in a Minikube environment is beyond the scope of this guide.  You must\n+walk through this link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html[Knative Tutorial]\n+put together by Red Hat.  It walks through how to set up Knative on Minikube or Openshift in a local environment.\n+\n+NOTE: Specifically you should run the link:https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial-eventing/eventing-trigger-broker.html[Brokers and Triggers]\n+tutorial as this guide requires that you can invoke on a Broker to trigger the quickstart code.\n+\n+== Read about Cloud Events\n+\n+The Cloud Event link:https://cloudevents.io/[specification] is a good read to give you an even greater understanding of Knative Events.\n+\n+== The Quickstart\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `funqy-knative-events-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart[directory].\n+\n+== The Quickstart Flow\n+\n+The quickstart works by manually sending an HTTP request containing a Cloud Event to the Knative Broker using `curl`.\n+The Knative Broker receives the request and triggers the startup of the Funqy container built by the quickstart.\n+The event triggers the invocation of a chain of Funqy functions.  The output of one function triggers the\n+invocation of another Funqy function.\n+\n+== Funqy and Cloud Events\n+\n+When living within a Knative Events environment, Funqy functions are triggered by a specific\n+Cloud Event type.  You can have multiple Funqy functions within a single application/deployment,\n+but they must be triggered by a specific Cloud Event Type.  The exception to this rule is if there is\n+only one Funqy function in the application.  In that case, the event is pushed to that function irregardless\n+of the Cloud Event type.\n+\n+Currently, Funqy can only consume JSON-based data.  It supports both Binary and Structured mode of execution,\n+but the data component of the Cloud Event message must be JSON.\n+\n+== The Code\n+\n+Let's start looking at our quickstart code so that you can understand how Knative Events map to Funqy.\n+Open up {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/java/org/acme/funqy/SimpleFunctionChain.java[SimpleFunctionChain.java]\n+\n+The first function we'll look at is `defaultChain`.\n+\n+[source, java]\n+----\n+import io.quarkus.funqy.Funq;\n+\n+public class SimpleFunctionChain {\n+    @Funq\n+    public String defaultChain(String input) {\n+        log.info(\"*** defaultChain ***\");\n+        return input + \"::\" + \"defaultChain\";\n+    }\n+----\n+\n+As is, a Funqy function has a default Cloud Event mapping.  By default, the Cloud Event type must match\n+the function name for the function to trigger.  If the function returns output,\n+the response is converted into a Cloud Event and returned to the Broker to be routed to other triggers.\n+The default Cloud Event type for this response is the function name + `.output`.  The default Cloud Event source is the function name.\n+\n+So, for the `defaultChain` function, the Cloud Event type that triggers the function is `defaultChain`.  It generates\n+a response that triggers a new Cloud Event whose type is `defaultChain.output` and the event source is `defaultChain`.\n+\n+While the default mapping is simple, it might not always be feasible.  You can change this default mapping\n+through configuration.  Let's look at the next function:\n+\n+[source, java]\n+----\n+import io.quarkus.funqy.Funq;\n+\n+public class SimpleFunctionChain {\n+    @Funq\n+    public String configChain(String input) {\n+        log.info(\"*** configChain ***\");\n+        return input + \"::\" + \"configChain\";\n+    }\n+----\n+\n+The `configChain` function has its Cloud Event mapping changed by configuration within {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/main/resources/application.properties[application.properties].\n+\n+\n+[source, subs=attributes+]\n+----\n+quarkus.funqy.knative-events.mapping.configChain.trigger=defaultChain.output\n+quarkus.funqy.knative-events.mapping.configChain.response-type=annotated\n+quarkus.funqy.knative-events.mapping.configChain.response-source=configChain\n+----\n+\n+In this case, the configuration maps the Cloud Event type `defaultChain.outout` to the `configChain` function.\n+The `configChain` function response Cloud Event type is mapped to annotated`annotated` and the Cloud Event source of the response event is `configChain`\n+\n+* `quarkus.funqy.knative-events.mapping.{function name}.trigger` sets the Cloud Event type that triggers a specific function\n+* `quarkus.funqy.knative-events.mapping.{function name}.response-type` sets the Cloud Event type of the response\n+* `quarkus.funqy.knative-events.mapping.{function name}.resource-source` sets the Cloud Event source of the response\n+\n+The Funqy Knative Events extension also has annotations to do this Cloud Event mapping to your functions.  Take a look at the\n+`annotatedChain` method\n+\n+[source, java]\n+----\n+import io.quarkus.funqy.Funq;\n+import io.quarkus.funqy.knative.events.CloudEvent;\n+\n+public class SimpleFunctionChain {\n+    @Funq\n+    @CloudEvent(trigger = \"annotated\", responseSource = \"annotated\", responseType = \"lastChainLink\")\n+    public String annotatedChain(String input) {\n+        log.info(\"*** annotatedChain ***\");\n+        return input + \"::\" + \"annotatedChain\";\n+    }\n+----\n+\n+If you use the `@CloudEvent` annotation on your function you can map the Cloud Event type trigger\n+and the Cloud Event response.  In this example the `annotatedChain` function will be triggered\n+by the `annotated` Cloud Event type and the response will be mapped to a `lastChainLink` type\n+and `annotated` Cloud Event source.\n+\n+So, if look at all the functions defined within `SimpleFunctionChain` you'll notice that one function triggers the next.\n+The last function that is triggered is `lastChainLink`.\n+\n+[source, java]\n+----\n+import io.quarkus.funqy.Context;\n+import io.quarkus.funqy.Funq;\n+\n+public class SimpleFunctionChain {\n+    @Funq\n+    public void lastChainLink(String input, @Context CloudEvent event) {\n+        log.info(\"*** lastChainLink ***\");\n+        log.info(input + \"::\" + \"lastChainLink\");\n+    }\n+}\n+----\n+\n+There are two things to notice about this function.  One, it has no output.  Your functions are not\n+required to return output.  Second, there is an additional `event` parameter to the function.\n+\n+If you want to know additional information about the incoming Cloud Event, you can inject the\n+`CloudEvent` interface using the Funqy `@Context` annotation.  The `CloudEvent` interface exposes information\n+about the triggering event.\n+\n+[source, java]\n+----\n+public interface CloudEvent {\n+    String id();\n+    String specVersion();\n+    String source();\n+    String subject();\n+    OffsetDateTime time();\n+}\n+----\n+\n+== Maven\n+\n+If you look at the {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/pom.xml[pom],\n+you'll see that it is a typical Quarkus pom that pulls in one funqy dependency\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-funqy-knative-events</artifactId>\n+</dependency>\n+----\n+\n+== Dev mode and Testing\n+\n+Funqy Knative Events support dev mode and unit testing using RestAssured.  You can invoke on Funqy Knative Events functions\n+using the same invocation model as\n+link:funqy-http[Funqy HTTP] using normal HTTP requests, or Cloud Event Binary mode, or Structured Mode.  All\n+invocation modes are supported at the same time.\n+\n+So, if you open up the unit test code in {quickstarts-tree-url}/funqy-quickstarts/funqy-knative-events-quickstart/src/test/java/org/acme/funqy/FunqyTest.java[FunqyTest.java]\n+you'll see that its simply using RestAssured to make HTTP invocations to test the functions.\n+\n+Funqy also works with Quarkus Dev mode!\n+\n+== Build the Project\n+\n+First build the Java artifacts:\n+\n+[source, shell]\n+----\n+mvn clean install\n+----\n+\n+Next, a docker image is required by Knative, so you'll need to build that next:\n+\n+[source, shell]\n+----\n+docker build -f src/main/docker/Dockerfile.jvm -t yourAccountName/funqy-knative-events-quickstart .\n+----\n+\n+Make sure to replace `yourAccountName` with your docker or quay account name when you run `docker build`.  The\n+Dockerfile is a standard Quarkus dockerfile.  No special Knative magic.\n+\n+Push your image to docker hub or quay\n+\n+[source, shell]\n+----\n+docker push yourAccountName/funqy-knative-events-quickstart\n+----\n+\n+Again, make sure to replace `yourAccountName` with your docker or quay account name when you run `docker push`.\n+\n+== Deploy to Kubernetes/Openshift", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee0753a81c92e5edeede8b72543180ee5076c155"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5ODU0MQ==", "bodyText": "Perhaps tone this down somehow?", "url": "https://github.com/quarkusio/quarkus/pull/9344#discussion_r426398541", "createdAt": "2020-05-18T06:40:32Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/funqy.adoc", "diffHunk": "@@ -0,0 +1,142 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Funqy\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+\n+Quarkus Funqy is part of Quarkus's serverless strategy and aims to provide a portable Java API to write functions\n+deployable to various FaaS environments like AWS Lambda, Azure Functions, Knative, and Knative events.  It is also\n+usable outside of FaaS in more traditional environments.\n+\n+Another goal of Funqy is to create a remoting, RPC framework that is as small and optimized as possible for the\n+Quarkus runtime.  This means sacrificing on flexibility to provide a runtime that has little to no overhead.  Funqy\n+should never become more complicated than you see in this initial doc.  If you see us adding too many features then\n+we've done something wrong!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee0753a81c92e5edeede8b72543180ee5076c155"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5OTAwOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            note: We do not recommend injecting contextual information specific to a runtime.  Keep your functions portable.\n          \n          \n            \n            NOTE: We do not recommend injecting contextual information specific to a runtime.  Keep your functions portable.", "url": "https://github.com/quarkusio/quarkus/pull/9344#discussion_r426399009", "createdAt": "2020-05-18T06:41:46Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/funqy.adoc", "diffHunk": "@@ -0,0 +1,142 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Funqy\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+\n+Quarkus Funqy is part of Quarkus's serverless strategy and aims to provide a portable Java API to write functions\n+deployable to various FaaS environments like AWS Lambda, Azure Functions, Knative, and Knative events.  It is also\n+usable outside of FaaS in more traditional environments.\n+\n+Another goal of Funqy is to create a remoting, RPC framework that is as small and optimized as possible for the\n+Quarkus runtime.  This means sacrificing on flexibility to provide a runtime that has little to no overhead.  Funqy\n+should never become more complicated than you see in this initial doc.  If you see us adding too many features then\n+we've done something wrong!\n+\n+== Funqy Basics\n+\n+The Funqy API is simple.  Annotate a method with `@Funq`.  This method may only have one optional input parameter\n+and may or may not return a response.\n+\n+[source, java]\n+----\n+import io.quarkus.funqy.Funq;\n+\n+public class GreetingFunction {\n+    @Funq\n+    public String greet(String name) {\n+       return \"Hello \" + name;\n+    }\n+}\n+----\n+\n+Java classes can also be used as input and output and must follow the Java bean convention and have\n+a default constructor.\n+\n+[source, java]\n+----\n+public class GreetingFunction {\n+    public static class Friend {\n+        String name;\n+\n+        public String getName() { return name; }\n+        public void setName(String name) { this.name = name; }\n+    }\n+\n+    public static class Greeting {\n+        String msg;\n+\n+        public Greeting() {}\n+        public Greeting(String msg) { this.msg = msg }\n+\n+        public String getMessage() { return msg; }\n+        public void setMessage(String msg) { this.msg = msg; }\n+    }\n+\n+    @Funq\n+    public Greeting greet(Friend friend) {\n+       return new Greeting(\"Hello \" + friend.getName());\n+    }\n+}\n+----\n+\n+== Function Names\n+\n+The function name defaults to the method name and is case sensitive.  If you want your function referenced by a different name,\n+parameterize the `@Funq` annotation as follows:\n+\n+[source, java]\n+----\n+import io.quarkus.funqy.Funq;\n+\n+public class GreetingFunction {\n+\n+    @Funq(\"HelloWorld\")\n+    public String greet(String name) {\n+       return \"Hello \" + name;\n+    }\n+}\n+----\n+\n+== Funqy DI\n+\n+Each Funqy Java class is a Quarkus Arc component and supports dependency injection through\n+CDI or Spring DI.  Spring DI requires including the `quarkus-spring-di` dependency in your build.\n+\n+The default object lifecycle for a Funqy class is `@Dependent`.\n+\n+[source, java]\n+----\n+import io.quarkus.funqy.Funq;\n+\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+\n+@ApplicationScoped\n+public class GreetingFunction {\n+\n+    @Inject\n+    GreetingService service;\n+\n+    @Funq\n+    public Greeting greet(Friend friend) {\n+        Greeting greeting = new Greeting();\n+        greeting.setMessage(service.greet(friend.getName()));\n+        return greeting;\n+    }\n+}\n+----\n+\n+== Context injection\n+\n+You can inject contextual information that is specific to the Funqy runtime (lambda, azure, etc.)\n+you are deploying.\n+\n+note: We do not recommend injecting contextual information specific to a runtime.  Keep your functions portable.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee0753a81c92e5edeede8b72543180ee5076c155"}, "originalPosition": 119}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ee0753a81c92e5edeede8b72543180ee5076c155", "author": {"user": {"login": "patriot1burke", "name": "Bill Burke"}}, "url": "https://github.com/quarkusio/quarkus/commit/ee0753a81c92e5edeede8b72543180ee5076c155", "committedDate": "2020-05-15T13:17:57Z", "message": "funqy-knative rename to funqy-knative-events\n\nfunqy events finished\n\nlambda\n\nfunqy docs\n\nfunqy azure functions\n\ncleanup rootpath\n\ncontext injection of cloud event\n\nremove funqy azure maven archetype\n\nknative event docs\n\nreview funqy docs\n\nfunqy source formatting"}, "afterCommit": {"oid": "8d55378d9f0d15262cb047134bcc8dd00990d780", "author": {"user": {"login": "patriot1burke", "name": "Bill Burke"}}, "url": "https://github.com/quarkusio/quarkus/commit/8d55378d9f0d15262cb047134bcc8dd00990d780", "committedDate": "2020-05-18T13:53:24Z", "message": "funqy-knative rename to funqy-knative-events\n\nfunqy events finished\n\nlambda\n\nfunqy docs\n\nfunqy azure functions\n\ncleanup rootpath\n\ncontext injection of cloud event\n\nremove funqy azure maven archetype\n\nknative event docs\n\nreview funqy docs\n\nfunqy source formatting"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9e38a4294a1f3637a9acf63903e5e3ef692f3b35", "author": {"user": {"login": "patriot1burke", "name": "Bill Burke"}}, "url": "https://github.com/quarkusio/quarkus/commit/9e38a4294a1f3637a9acf63903e5e3ef692f3b35", "committedDate": "2020-05-18T14:02:58Z", "message": "doc fix suggestions"}, "afterCommit": {"oid": "c9166e40bc76661733b274fdc77d915d2a6e9053", "author": {"user": {"login": "patriot1burke", "name": "Bill Burke"}}, "url": "https://github.com/quarkusio/quarkus/commit/c9166e40bc76661733b274fdc77d915d2a6e9053", "committedDate": "2020-05-18T16:05:13Z", "message": "funqy-knative rename to funqy-knative-events\n\nfunqy events finished\n\nlambda\n\nfunqy docs\n\nfunqy azure functions\n\ncleanup rootpath\n\ncontext injection of cloud event\n\nremove funqy azure maven archetype\n\nknative event docs\n\nreview funqy docs\n\nfunqy source formatting\n\nUpdate docs/src/main/asciidoc/funqy-amazon-lambda-http.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\nUpdate docs/src/main/asciidoc/funqy-amazon-lambda.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\nUpdate docs/src/main/asciidoc/funqy-http.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\nUpdate docs/src/main/asciidoc/funqy.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\nUpdate docs/src/main/asciidoc/funqy-knative-events.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\ndoc fix suggestions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c9166e40bc76661733b274fdc77d915d2a6e9053", "author": {"user": {"login": "patriot1burke", "name": "Bill Burke"}}, "url": "https://github.com/quarkusio/quarkus/commit/c9166e40bc76661733b274fdc77d915d2a6e9053", "committedDate": "2020-05-18T16:05:13Z", "message": "funqy-knative rename to funqy-knative-events\n\nfunqy events finished\n\nlambda\n\nfunqy docs\n\nfunqy azure functions\n\ncleanup rootpath\n\ncontext injection of cloud event\n\nremove funqy azure maven archetype\n\nknative event docs\n\nreview funqy docs\n\nfunqy source formatting\n\nUpdate docs/src/main/asciidoc/funqy-amazon-lambda-http.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\nUpdate docs/src/main/asciidoc/funqy-amazon-lambda.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\nUpdate docs/src/main/asciidoc/funqy-http.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\nUpdate docs/src/main/asciidoc/funqy.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\nUpdate docs/src/main/asciidoc/funqy-knative-events.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\ndoc fix suggestions"}, "afterCommit": {"oid": "eea863e4a966d4a0aa7f780a2e6e8edb166aa15b", "author": {"user": {"login": "patriot1burke", "name": "Bill Burke"}}, "url": "https://github.com/quarkusio/quarkus/commit/eea863e4a966d4a0aa7f780a2e6e8edb166aa15b", "committedDate": "2020-05-18T17:57:16Z", "message": "funqy-knative rename to funqy-knative-events\n\nfunqy events finished\n\nlambda\n\nfunqy docs\n\nfunqy azure functions\n\ncleanup rootpath\n\ncontext injection of cloud event\n\nremove funqy azure maven archetype\n\nknative event docs\n\nreview funqy docs\n\nfunqy source formatting\n\nUpdate docs/src/main/asciidoc/funqy-amazon-lambda-http.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\nUpdate docs/src/main/asciidoc/funqy-amazon-lambda.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\nUpdate docs/src/main/asciidoc/funqy-http.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\nUpdate docs/src/main/asciidoc/funqy.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\nUpdate docs/src/main/asciidoc/funqy-knative-events.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\ndoc fix suggestions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eea863e4a966d4a0aa7f780a2e6e8edb166aa15b", "author": {"user": {"login": "patriot1burke", "name": "Bill Burke"}}, "url": "https://github.com/quarkusio/quarkus/commit/eea863e4a966d4a0aa7f780a2e6e8edb166aa15b", "committedDate": "2020-05-18T17:57:16Z", "message": "funqy-knative rename to funqy-knative-events\n\nfunqy events finished\n\nlambda\n\nfunqy docs\n\nfunqy azure functions\n\ncleanup rootpath\n\ncontext injection of cloud event\n\nremove funqy azure maven archetype\n\nknative event docs\n\nreview funqy docs\n\nfunqy source formatting\n\nUpdate docs/src/main/asciidoc/funqy-amazon-lambda-http.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\nUpdate docs/src/main/asciidoc/funqy-amazon-lambda.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\nUpdate docs/src/main/asciidoc/funqy-http.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\nUpdate docs/src/main/asciidoc/funqy.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\nUpdate docs/src/main/asciidoc/funqy-knative-events.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\ndoc fix suggestions"}, "afterCommit": {"oid": "9a7aba3817182c0b07da430af34997760ca2cb10", "author": {"user": {"login": "patriot1burke", "name": "Bill Burke"}}, "url": "https://github.com/quarkusio/quarkus/commit/9a7aba3817182c0b07da430af34997760ca2cb10", "committedDate": "2020-05-19T15:58:10Z", "message": "funqy-knative rename to funqy-knative-events\n\nfunqy events finished\n\nlambda\n\nfunqy docs\n\nfunqy azure functions\n\ncleanup rootpath\n\ncontext injection of cloud event\n\nremove funqy azure maven archetype\n\nknative event docs\n\nreview funqy docs\n\nfunqy source formatting\n\nUpdate docs/src/main/asciidoc/funqy-amazon-lambda-http.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\nUpdate docs/src/main/asciidoc/funqy-amazon-lambda.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\nUpdate docs/src/main/asciidoc/funqy-http.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\nUpdate docs/src/main/asciidoc/funqy.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\nUpdate docs/src/main/asciidoc/funqy-knative-events.adoc\n\nCo-authored-by: Georgios Andrianakis <geoand@gmail.com>\n\ndoc fix suggestions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NzMzMzM5", "url": "https://github.com/quarkusio/quarkus/pull/9344#pullrequestreview-414733339", "createdAt": "2020-05-19T18:53:31Z", "commit": {"oid": "9a7aba3817182c0b07da430af34997760ca2cb10"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODo1MzozMVrOGXuNTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxOTowNToxMVrOGXunOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyNzUwMQ==", "bodyText": "Where is service coming from?", "url": "https://github.com/quarkusio/quarkus/pull/9344#discussion_r427527501", "createdAt": "2020-05-19T18:53:31Z", "author": {"login": "gunnarmorling"}, "path": "docs/src/main/asciidoc/funqy.adoc", "diffHunk": "@@ -0,0 +1,140 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Funqy\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+\n+Quarkus Funqy is part of Quarkus's serverless strategy and aims to provide a portable Java API to write functions\n+deployable to various FaaS environments like AWS Lambda, Azure Functions, Knative, and Knative events.  It is also\n+usable outside of FaaS in more traditional environments.\n+\n+Another goal of Funqy is to create a remoting, RPC framework that is as small and optimized as possible for the\n+Quarkus runtime.  This means sacrificing on flexibility to provide a runtime that has little to no overhead.  Funqy\n+should never become more complicated than you see in this initial doc.\n+\n+== Funqy Basics\n+\n+The Funqy API is simple.  Annotate a method with `@Funq`.  This method may only have one optional input parameter\n+and may or may not return a response.\n+\n+[source, java]\n+----\n+import io.quarkus.funqy.Funq;\n+\n+public class GreetingFunction {\n+    @Funq\n+    public String greet(String name) {\n+       return \"Hello \" + name;\n+    }\n+}\n+----\n+\n+Java classes can also be used as input and output and must follow the Java bean convention and have\n+a default constructor.\n+\n+[source, java]\n+----\n+public class GreetingFunction {\n+    public static class Friend {\n+        String name;\n+\n+        public String getName() { return name; }\n+        public void setName(String name) { this.name = name; }\n+    }\n+\n+    public static class Greeting {\n+        String msg;\n+\n+        public Greeting() {}\n+        public Greeting(String msg) { this.msg = msg }\n+\n+        public String getMessage() { return msg; }\n+        public void setMessage(String msg) { this.msg = msg; }\n+    }\n+\n+    @Funq\n+    public Greeting greet(Friend friend) {\n+       return new Greeting(\"Hello \" + friend.getName());\n+    }\n+}\n+----\n+\n+== Function Names\n+\n+The function name defaults to the method name and is case sensitive.  If you want your function referenced by a different name,\n+parameterize the `@Funq` annotation as follows:\n+\n+[source, java]\n+----\n+import io.quarkus.funqy.Funq;\n+\n+public class GreetingFunction {\n+\n+    @Funq(\"HelloWorld\")\n+    public String greet(String name) {\n+       return \"Hello \" + name;\n+    }\n+}\n+----\n+\n+== Funqy DI\n+\n+Each Funqy Java class is a Quarkus Arc component and supports dependency injection through\n+CDI or Spring DI.  Spring DI requires including the `quarkus-spring-di` dependency in your build.\n+\n+The default object lifecycle for a Funqy class is `@Dependent`.\n+\n+[source, java]\n+----\n+import io.quarkus.funqy.Funq;\n+\n+import javax.inject.Inject;\n+import javax.enterprise.context.ApplicationScoped;\n+\n+@ApplicationScoped\n+public class GreetingFunction {\n+\n+    @Inject\n+    GreetingService service;\n+\n+    @Funq\n+    public Greeting greet(Friend friend) {\n+        Greeting greeting = new Greeting();\n+        greeting.setMessage(service.greet(friend.getName()));\n+        return greeting;\n+    }\n+}\n+----\n+\n+== Context injection\n+\n+You can inject contextual information that is specific to the Funqy runtime (lambda, azure, etc.)\n+you are deploying.\n+\n+NOTE: We do not recommend injecting contextual information specific to a runtime.  Keep your functions portable.\n+\n+Contextual information is injected via the `@Context` annotation which can be used on a function parameter\n+or a class field.\n+\n+[source, java]\n+----\n+import io.quarkus.funqy.Funq;\n+import io.quarkus.funqy.Context;\n+\n+public class GreetingFunction {\n+\n+    @Funq\n+    public Greeting greet(Friend friend, @Context AwsContext ctx) {\n+        Greeting greeting = new Greeting();\n+        greeting.setMessage(service.greet(friend.getName()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a7aba3817182c0b07da430af34997760ca2cb10"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyODgxMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            environments and AWS Lambda is one of them.  The Java code is actually the same exact code as the {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[funqy-http-quickstart]\n          \n          \n            \n            environments and AWS Lambda is one of them.  The Java code is actually the same exact code as the {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[funqy-http-quickstart].", "url": "https://github.com/quarkusio/quarkus/pull/9344#discussion_r427528810", "createdAt": "2020-05-19T18:55:55Z", "author": {"login": "gunnarmorling"}, "path": "docs/src/main/asciidoc/funqy-amazon-lambda-http.adoc", "diffHunk": "@@ -0,0 +1,48 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Funqy HTTP with Amazon Lambda\u00a0\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+If you like link:funqy-http[Funqy HTTP], you can use it on AWS Lambda.  Quarkus allows you to expose multiple\n+Funqy functions through HTTP deployed as one AWS Lambda.\n+\n+include::./status-include.adoc[]\n+\n+Follow the link:amazon-lambda-http[Amazon Lambda Http Guide].  It walks through using a variety of HTTP\n+frameworks on Amazon Lambda, including Funqy.\n+\n+== An additional Quickstart\n+\n+Beyond generating an AWS project that is covered in the link:amazon-lambda-http[Amazon Lambda Http Guide],\n+there's also a quickstart for running Funqy HTTP on AWS Lambda.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `funqy-amazon-lambda-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-http-quickstart[directory].\n+\n+== The Code\n+\n+There is nothing special about the code and more importantly nothing AWS specific.  Funqy functions can be deployed to many different\n+environments and AWS Lambda is one of them.  The Java code is actually the same exact code as the {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[funqy-http-quickstart]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a7aba3817182c0b07da430af34997760ca2cb10"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzMDEyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            environments and AWS Lambda is one of them.  The Java code is actually the same exact code as the {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[funqy-http-quickstart]\n          \n          \n            \n            environments and AWS Lambda is one of them.  The Java code is actually the same exact code as the {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[funqy-http-quickstart].", "url": "https://github.com/quarkusio/quarkus/pull/9344#discussion_r427530120", "createdAt": "2020-05-19T18:57:49Z", "author": {"login": "gunnarmorling"}, "path": "docs/src/main/asciidoc/funqy-amazon-lambda.adoc", "diffHunk": "@@ -0,0 +1,311 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Funqy Amazon Lambda\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+The guide walks through quickstart code to show you how you can deploy Funqy functions to Amazon Lambda.\n+\n+Funqy functions can be deployed using the Amazon Java Runtime, or you can build a native executable and use\n+Amazon's Custom Runtime if you want a smaller memory footprint and faster cold boot startup time.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 30 minutes\n+* JDK 11 (AWS requires JDK 1.8 or 11)\n+* Apache Maven {maven-version}\n+* https://aws.amazon.com[An Amazon AWS account]\n+* https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html[AWS CLI]\n+* https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI], for local testing\n+\n+NOTE: Funqy Amazon Lambdas build off of our link:amazon-lambda[Quarkus Amazon Lambda support].\n+\n+== Installing AWS bits\n+\n+Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps\n+for installing AWS CLI.\n+\n+== The Quickstart\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `funqy-amazon-lambda-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-quickstart[directory].\n+\n+== The Code\n+\n+There is nothing special about the code and more importantly nothing AWS specific.  Funqy functions can be deployed to many different\n+environments and AWS Lambda is one of them.  The Java code is actually the same exact code as the {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[funqy-http-quickstart]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a7aba3817182c0b07da430af34997760ca2cb10"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzMDM2OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can see how the quickstart has done it within its own {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-quickstart/src/main/resources/application.properties[application.properties]\n          \n          \n            \n            You can see how the quickstart has done it within its own {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-quickstart/src/main/resources/application.properties[application.properties].", "url": "https://github.com/quarkusio/quarkus/pull/9344#discussion_r427530369", "createdAt": "2020-05-19T18:58:17Z", "author": {"login": "gunnarmorling"}, "path": "docs/src/main/asciidoc/funqy-amazon-lambda.adoc", "diffHunk": "@@ -0,0 +1,311 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Funqy Amazon Lambda\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+The guide walks through quickstart code to show you how you can deploy Funqy functions to Amazon Lambda.\n+\n+Funqy functions can be deployed using the Amazon Java Runtime, or you can build a native executable and use\n+Amazon's Custom Runtime if you want a smaller memory footprint and faster cold boot startup time.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 30 minutes\n+* JDK 11 (AWS requires JDK 1.8 or 11)\n+* Apache Maven {maven-version}\n+* https://aws.amazon.com[An Amazon AWS account]\n+* https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html[AWS CLI]\n+* https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI], for local testing\n+\n+NOTE: Funqy Amazon Lambdas build off of our link:amazon-lambda[Quarkus Amazon Lambda support].\n+\n+== Installing AWS bits\n+\n+Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps\n+for installing AWS CLI.\n+\n+== The Quickstart\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `funqy-amazon-lambda-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-quickstart[directory].\n+\n+== The Code\n+\n+There is nothing special about the code and more importantly nothing AWS specific.  Funqy functions can be deployed to many different\n+environments and AWS Lambda is one of them.  The Java code is actually the same exact code as the {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[funqy-http-quickstart]\n+\n+[[choose]]\n+== Choose Your Function\n+\n+Only one Funqy function can be exported per Amazon Lambda deployment.  If you only have one method\n+annotated with `@Funq` in your project, then there is no worries.  If you have multiple functions defined\n+within your project, then you will need to choose the function within your Quarkus `application.properties`:\n+\n+[source, subs=attributes+]\n+----\n+quarkus.funqy.export=greet\n+----\n+\n+You can see how the quickstart has done it within its own {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-quickstart/src/main/resources/application.properties[application.properties]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a7aba3817182c0b07da430af34997760ca2cb10"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzMDgyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * `manage.sh` - wrapper around aws lamba cli calls\n          \n          \n            \n            * `manage.sh` - wrapper around aws lambda cli calls", "url": "https://github.com/quarkusio/quarkus/pull/9344#discussion_r427530820", "createdAt": "2020-05-19T18:59:04Z", "author": {"login": "gunnarmorling"}, "path": "docs/src/main/asciidoc/funqy-amazon-lambda.adoc", "diffHunk": "@@ -0,0 +1,311 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Funqy Amazon Lambda\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+The guide walks through quickstart code to show you how you can deploy Funqy functions to Amazon Lambda.\n+\n+Funqy functions can be deployed using the Amazon Java Runtime, or you can build a native executable and use\n+Amazon's Custom Runtime if you want a smaller memory footprint and faster cold boot startup time.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 30 minutes\n+* JDK 11 (AWS requires JDK 1.8 or 11)\n+* Apache Maven {maven-version}\n+* https://aws.amazon.com[An Amazon AWS account]\n+* https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html[AWS CLI]\n+* https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI], for local testing\n+\n+NOTE: Funqy Amazon Lambdas build off of our link:amazon-lambda[Quarkus Amazon Lambda support].\n+\n+== Installing AWS bits\n+\n+Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps\n+for installing AWS CLI.\n+\n+== The Quickstart\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `funqy-amazon-lambda-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-quickstart[directory].\n+\n+== The Code\n+\n+There is nothing special about the code and more importantly nothing AWS specific.  Funqy functions can be deployed to many different\n+environments and AWS Lambda is one of them.  The Java code is actually the same exact code as the {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[funqy-http-quickstart]\n+\n+[[choose]]\n+== Choose Your Function\n+\n+Only one Funqy function can be exported per Amazon Lambda deployment.  If you only have one method\n+annotated with `@Funq` in your project, then there is no worries.  If you have multiple functions defined\n+within your project, then you will need to choose the function within your Quarkus `application.properties`:\n+\n+[source, subs=attributes+]\n+----\n+quarkus.funqy.export=greet\n+----\n+\n+You can see how the quickstart has done it within its own {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-quickstart/src/main/resources/application.properties[application.properties]\n+\n+Alternatively, you can set the `QUARKUS_FUNQY_EXPORT` environment variable when you create the Amazon Lambda using the `aws` cli.\n+\n+== Deploy to AWS Lambda Java Runtime\n+\n+There are a few steps to get your Funqy function running on AWS Lambda.  The quickstart maven project generates a helpful script to\n+create, update, delete, and invoke your functions for pure Java and native deployments.  This script is generated\n+at build time.\n+\n+== Build and Deploy\n+\n+Build the project using maven.\n+\n+[source, subs=attributes+]\n+----\n+./mvnw clean package\n+----\n+\n+This will compile and package your code.\n+\n+== Create an Execution Role\n+\n+View the https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html[Getting Started Guide] for deploying\n+a lambda with AWS CLI.  Specifically, make sure you have created an `Execution Role`.  You will need to define\n+a `LAMBDA_ROLE_ARN` environment variable in your profile or console window,  Alternatively, you can edit\n+the `manage.sh` script that is generated by the build and put the role value directly there:\n+\n+[source]\n+----\n+LAMBDA_ROLE_ARN=\"arn:aws:iam::1234567890:role/lambda-role\"\n+----\n+\n+== Extra Build Generated Files\n+\n+After you run the build, there are a few extra files generated by the `quarkus-funqy-amazon-lambda` extension.  These files\n+are in the the build directory:  `target/` for maven, `build/` for gradle.\n+\n+* `function.zip` - lambda deployment file\n+* `manage.sh` - wrapper around aws lamba cli calls", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a7aba3817182c0b07da430af34997760ca2cb10"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzMTkzNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            NOTE: If you are building on a non-Linux system, you will need to also pass in a property instructing quarkus to use a docker build as Amazon\n          \n          \n            \n            NOTE: If you are building on a non-Linux system, you will need to also pass in a property instructing Quarkus to use a docker build as Amazon", "url": "https://github.com/quarkusio/quarkus/pull/9344#discussion_r427531934", "createdAt": "2020-05-19T19:01:02Z", "author": {"login": "gunnarmorling"}, "path": "docs/src/main/asciidoc/funqy-amazon-lambda.adoc", "diffHunk": "@@ -0,0 +1,311 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Funqy Amazon Lambda\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+The guide walks through quickstart code to show you how you can deploy Funqy functions to Amazon Lambda.\n+\n+Funqy functions can be deployed using the Amazon Java Runtime, or you can build a native executable and use\n+Amazon's Custom Runtime if you want a smaller memory footprint and faster cold boot startup time.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 30 minutes\n+* JDK 11 (AWS requires JDK 1.8 or 11)\n+* Apache Maven {maven-version}\n+* https://aws.amazon.com[An Amazon AWS account]\n+* https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html[AWS CLI]\n+* https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI], for local testing\n+\n+NOTE: Funqy Amazon Lambdas build off of our link:amazon-lambda[Quarkus Amazon Lambda support].\n+\n+== Installing AWS bits\n+\n+Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps\n+for installing AWS CLI.\n+\n+== The Quickstart\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `funqy-amazon-lambda-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-quickstart[directory].\n+\n+== The Code\n+\n+There is nothing special about the code and more importantly nothing AWS specific.  Funqy functions can be deployed to many different\n+environments and AWS Lambda is one of them.  The Java code is actually the same exact code as the {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[funqy-http-quickstart]\n+\n+[[choose]]\n+== Choose Your Function\n+\n+Only one Funqy function can be exported per Amazon Lambda deployment.  If you only have one method\n+annotated with `@Funq` in your project, then there is no worries.  If you have multiple functions defined\n+within your project, then you will need to choose the function within your Quarkus `application.properties`:\n+\n+[source, subs=attributes+]\n+----\n+quarkus.funqy.export=greet\n+----\n+\n+You can see how the quickstart has done it within its own {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-quickstart/src/main/resources/application.properties[application.properties]\n+\n+Alternatively, you can set the `QUARKUS_FUNQY_EXPORT` environment variable when you create the Amazon Lambda using the `aws` cli.\n+\n+== Deploy to AWS Lambda Java Runtime\n+\n+There are a few steps to get your Funqy function running on AWS Lambda.  The quickstart maven project generates a helpful script to\n+create, update, delete, and invoke your functions for pure Java and native deployments.  This script is generated\n+at build time.\n+\n+== Build and Deploy\n+\n+Build the project using maven.\n+\n+[source, subs=attributes+]\n+----\n+./mvnw clean package\n+----\n+\n+This will compile and package your code.\n+\n+== Create an Execution Role\n+\n+View the https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html[Getting Started Guide] for deploying\n+a lambda with AWS CLI.  Specifically, make sure you have created an `Execution Role`.  You will need to define\n+a `LAMBDA_ROLE_ARN` environment variable in your profile or console window,  Alternatively, you can edit\n+the `manage.sh` script that is generated by the build and put the role value directly there:\n+\n+[source]\n+----\n+LAMBDA_ROLE_ARN=\"arn:aws:iam::1234567890:role/lambda-role\"\n+----\n+\n+== Extra Build Generated Files\n+\n+After you run the build, there are a few extra files generated by the `quarkus-funqy-amazon-lambda` extension.  These files\n+are in the the build directory:  `target/` for maven, `build/` for gradle.\n+\n+* `function.zip` - lambda deployment file\n+* `manage.sh` - wrapper around aws lamba cli calls\n+* `bootstrap-example.sh` - example bootstrap script for native deployments\n+* `sam.jvm.yaml` - (optional) for use with sam cli and local testing\n+* `sam.native.yaml` - (optional) for use with sam cli and native local testing\n+\n+== Create the function\n+\n+The `target/manage.sh` script is for managing your Funqy function using the AWS Lambda Java runtime.  This script is provided only for\n+your convenience. Examine the output of the `manage.sh` script if you want to learn what aws commands are executed\n+to create, delete, and update your functions.\n+\n+`manage.sh` supports four operation:  `create`, `delete`, `update`, and `invoke`.\n+\n+NOTE: To verify your setup, that you have the AWS CLI installed, executed aws configure for the AWS access keys,\n+and setup the `LAMBDA_ROLE_ARN` environment variable (as described above), please execute `manage.sh` without any parameters.\n+A usage statement will be printed to guide you accordingly.\n+\n+To see the `usage` statement, and validate AWS configuration:\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh\n+----\n+\n+You can `create` your function using the following command:\n+\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh create\n+----\n+\n+or if you do not have `LAMBDA_ROLE_ARN` already defined in this shell:\n+\n+[source]\n+----\n+LAMBDA_ROLE_ARN=\"arn:aws:iam::1234567890:role/lambda-role\" sh target/manage.sh create\n+----\n+\n+WARNING: Do not change the handler switch.  This must be hardcoded to `io.quarkus.funqy.lambda.FunqyStreamHandler::handleRequest`.\n+This special handler is Funqy's integration point with AWS Lambda.\n+\n+If there are any problems creating the function, you must delete it with the `delete` function before re-running\n+the `create` command.\n+\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh delete\n+----\n+\n+Commands may also be stacked:\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh delete create\n+----\n+\n+== Invoke the function\n+\n+Use the `invoke` command to invoke your function.\n+\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh invoke\n+----\n+\n+The example function takes input passed in via the `--payload` switch which points to a json file\n+in the root directory of the project.\n+\n+The function can also be invoked locally with the SAM CLI like this:\n+\n+[source]\n+----\n+sam local invoke --template target/sam.jvm.yaml --event payload.json\n+----\n+\n+If you are working with your native image build, simply replace the template name with the native version:\n+\n+[source]\n+----\n+sam local invoke --template target/sam.native.yaml --event payload.json\n+----\n+\n+== Update the function\n+\n+You can update the Java code as you see fit.  Once you've rebuilt, you can redeploy your function by executing the\n+`update` command.\n+\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh update\n+----\n+\n+== Deploy to AWS Lambda Custom (native) Runtime\n+\n+If you want a lower memory footprint and faster initialization times for your Funqy function, you can compile your Java\n+code to a native executable.  Just make sure to rebuild your project with the `-Pnative` switch.\n+\n+For Linux hosts execute:\n+\n+[source, subs=attributes+]\n+----\n+mvn package -Pnative\n+----\n+\n+NOTE: If you are building on a non-Linux system, you will need to also pass in a property instructing quarkus to use a docker build as Amazon", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a7aba3817182c0b07da430af34997760ca2cb10"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzMjE4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This test frameowrk provides similar functionality to the SAM CLI, without the overhead of Docker.\n          \n          \n            \n            This test framework provides similar functionality to the SAM CLI, without the overhead of Docker.", "url": "https://github.com/quarkusio/quarkus/pull/9344#discussion_r427532185", "createdAt": "2020-05-19T19:01:34Z", "author": {"login": "gunnarmorling"}, "path": "docs/src/main/asciidoc/funqy-amazon-lambda.adoc", "diffHunk": "@@ -0,0 +1,311 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Funqy Amazon Lambda\n+:extension-status: preview\n+\n+include::./attributes.adoc[]\n+\n+The guide walks through quickstart code to show you how you can deploy Funqy functions to Amazon Lambda.\n+\n+Funqy functions can be deployed using the Amazon Java Runtime, or you can build a native executable and use\n+Amazon's Custom Runtime if you want a smaller memory footprint and faster cold boot startup time.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 30 minutes\n+* JDK 11 (AWS requires JDK 1.8 or 11)\n+* Apache Maven {maven-version}\n+* https://aws.amazon.com[An Amazon AWS account]\n+* https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html[AWS CLI]\n+* https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI], for local testing\n+\n+NOTE: Funqy Amazon Lambdas build off of our link:amazon-lambda[Quarkus Amazon Lambda support].\n+\n+== Installing AWS bits\n+\n+Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps\n+for installing AWS CLI.\n+\n+== The Quickstart\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution is located in the `funqy-amazon-lambda-quickstart` {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-quickstart[directory].\n+\n+== The Code\n+\n+There is nothing special about the code and more importantly nothing AWS specific.  Funqy functions can be deployed to many different\n+environments and AWS Lambda is one of them.  The Java code is actually the same exact code as the {quickstarts-tree-url}/funqy-quickstarts/funqy-http-quickstart[funqy-http-quickstart]\n+\n+[[choose]]\n+== Choose Your Function\n+\n+Only one Funqy function can be exported per Amazon Lambda deployment.  If you only have one method\n+annotated with `@Funq` in your project, then there is no worries.  If you have multiple functions defined\n+within your project, then you will need to choose the function within your Quarkus `application.properties`:\n+\n+[source, subs=attributes+]\n+----\n+quarkus.funqy.export=greet\n+----\n+\n+You can see how the quickstart has done it within its own {quickstarts-tree-url}/funqy-quickstarts/funqy-amazon-lambda-quickstart/src/main/resources/application.properties[application.properties]\n+\n+Alternatively, you can set the `QUARKUS_FUNQY_EXPORT` environment variable when you create the Amazon Lambda using the `aws` cli.\n+\n+== Deploy to AWS Lambda Java Runtime\n+\n+There are a few steps to get your Funqy function running on AWS Lambda.  The quickstart maven project generates a helpful script to\n+create, update, delete, and invoke your functions for pure Java and native deployments.  This script is generated\n+at build time.\n+\n+== Build and Deploy\n+\n+Build the project using maven.\n+\n+[source, subs=attributes+]\n+----\n+./mvnw clean package\n+----\n+\n+This will compile and package your code.\n+\n+== Create an Execution Role\n+\n+View the https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html[Getting Started Guide] for deploying\n+a lambda with AWS CLI.  Specifically, make sure you have created an `Execution Role`.  You will need to define\n+a `LAMBDA_ROLE_ARN` environment variable in your profile or console window,  Alternatively, you can edit\n+the `manage.sh` script that is generated by the build and put the role value directly there:\n+\n+[source]\n+----\n+LAMBDA_ROLE_ARN=\"arn:aws:iam::1234567890:role/lambda-role\"\n+----\n+\n+== Extra Build Generated Files\n+\n+After you run the build, there are a few extra files generated by the `quarkus-funqy-amazon-lambda` extension.  These files\n+are in the the build directory:  `target/` for maven, `build/` for gradle.\n+\n+* `function.zip` - lambda deployment file\n+* `manage.sh` - wrapper around aws lamba cli calls\n+* `bootstrap-example.sh` - example bootstrap script for native deployments\n+* `sam.jvm.yaml` - (optional) for use with sam cli and local testing\n+* `sam.native.yaml` - (optional) for use with sam cli and native local testing\n+\n+== Create the function\n+\n+The `target/manage.sh` script is for managing your Funqy function using the AWS Lambda Java runtime.  This script is provided only for\n+your convenience. Examine the output of the `manage.sh` script if you want to learn what aws commands are executed\n+to create, delete, and update your functions.\n+\n+`manage.sh` supports four operation:  `create`, `delete`, `update`, and `invoke`.\n+\n+NOTE: To verify your setup, that you have the AWS CLI installed, executed aws configure for the AWS access keys,\n+and setup the `LAMBDA_ROLE_ARN` environment variable (as described above), please execute `manage.sh` without any parameters.\n+A usage statement will be printed to guide you accordingly.\n+\n+To see the `usage` statement, and validate AWS configuration:\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh\n+----\n+\n+You can `create` your function using the following command:\n+\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh create\n+----\n+\n+or if you do not have `LAMBDA_ROLE_ARN` already defined in this shell:\n+\n+[source]\n+----\n+LAMBDA_ROLE_ARN=\"arn:aws:iam::1234567890:role/lambda-role\" sh target/manage.sh create\n+----\n+\n+WARNING: Do not change the handler switch.  This must be hardcoded to `io.quarkus.funqy.lambda.FunqyStreamHandler::handleRequest`.\n+This special handler is Funqy's integration point with AWS Lambda.\n+\n+If there are any problems creating the function, you must delete it with the `delete` function before re-running\n+the `create` command.\n+\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh delete\n+----\n+\n+Commands may also be stacked:\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh delete create\n+----\n+\n+== Invoke the function\n+\n+Use the `invoke` command to invoke your function.\n+\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh invoke\n+----\n+\n+The example function takes input passed in via the `--payload` switch which points to a json file\n+in the root directory of the project.\n+\n+The function can also be invoked locally with the SAM CLI like this:\n+\n+[source]\n+----\n+sam local invoke --template target/sam.jvm.yaml --event payload.json\n+----\n+\n+If you are working with your native image build, simply replace the template name with the native version:\n+\n+[source]\n+----\n+sam local invoke --template target/sam.native.yaml --event payload.json\n+----\n+\n+== Update the function\n+\n+You can update the Java code as you see fit.  Once you've rebuilt, you can redeploy your function by executing the\n+`update` command.\n+\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh update\n+----\n+\n+== Deploy to AWS Lambda Custom (native) Runtime\n+\n+If you want a lower memory footprint and faster initialization times for your Funqy function, you can compile your Java\n+code to a native executable.  Just make sure to rebuild your project with the `-Pnative` switch.\n+\n+For Linux hosts execute:\n+\n+[source, subs=attributes+]\n+----\n+mvn package -Pnative\n+----\n+\n+NOTE: If you are building on a non-Linux system, you will need to also pass in a property instructing quarkus to use a docker build as Amazon\n+Lambda requires linux binaries.  You can do this by passing this property to your Maven build:\n+`-Dnative-image.docker-build=true`, or for Gradle: `--docker-build=true`.  This requires you to have docker installed locally, however.\n+\n+[source, subs=attributes+]\n+----\n+./mvnw clean install -Pnative -Dnative-image.docker-build=true\n+----\n+\n+Either of these commands will compile and create a native executable image.  It also generates a zip file `target/function.zip`.\n+This zip file contains your native executable image renamed to `bootstrap`.  This is a requirement of the AWS Lambda\n+Custom (Provided) Runtime.\n+\n+The instructions here are exactly as above with one change:  you'll need to add `native` as the first parameter to the\n+`manage.sh` script:\n+\n+[source, subs=attributes+]\n+----\n+sh target/manage.sh native create\n+----\n+\n+As above, commands can be stacked.  The only requirement is that `native` be the first parameter should you wish\n+to work with native image builds.  The script will take care of the rest of the details necessary to manage your native\n+image function deployments.\n+\n+Examine the output of the `manage.sh` script if you want to learn what aws commands are executed\n+to create, delete, and update your functions.\n+\n+One thing to note about the create command for native is that the `aws lambda create-function`\n+call must set a specific environment variable:\n+\n+[source, subs=attributes+]\n+----\n+--environment 'Variables={DISABLE_SIGNAL_HANDLERS=true}'\n+----\n+\n+== Examine the POM\n+\n+There is nothing special about the POM other than the inclusion of the `quarkus-funqy-amazon-lambda` and `quarkus-test-amazon-lambda` extensions\n+as a dependencies.  The extension automatically generates everything you might need for your lambda deployment.\n+\n+== Integration Testing\n+\n+Funqy Amazon Lambda support leverages the Quarkus AWS Lambda test framework so that you can unit tests your Funqy functions.\n+This is true for both JVM and native modes.\n+This test frameowrk provides similar functionality to the SAM CLI, without the overhead of Docker.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a7aba3817182c0b07da430af34997760ca2cb10"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzNDEzNw==", "bodyText": "With Java records around the corner (preview in 14), there might be some push-back on requiring JavaBeans convention. Would be nice to see supports for record types here eventually (immutable, foo() instead of getFoo(), constructor expecting all components).", "url": "https://github.com/quarkusio/quarkus/pull/9344#discussion_r427534137", "createdAt": "2020-05-19T19:05:11Z", "author": {"login": "gunnarmorling"}, "path": "docs/src/main/asciidoc/funqy.adoc", "diffHunk": "@@ -0,0 +1,140 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Funqy\n+\n+include::./attributes.adoc[]\n+:extension-status: preview\n+\n+Quarkus Funqy is part of Quarkus's serverless strategy and aims to provide a portable Java API to write functions\n+deployable to various FaaS environments like AWS Lambda, Azure Functions, Knative, and Knative events.  It is also\n+usable outside of FaaS in more traditional environments.\n+\n+Another goal of Funqy is to create a remoting, RPC framework that is as small and optimized as possible for the\n+Quarkus runtime.  This means sacrificing on flexibility to provide a runtime that has little to no overhead.  Funqy\n+should never become more complicated than you see in this initial doc.\n+\n+== Funqy Basics\n+\n+The Funqy API is simple.  Annotate a method with `@Funq`.  This method may only have one optional input parameter\n+and may or may not return a response.\n+\n+[source, java]\n+----\n+import io.quarkus.funqy.Funq;\n+\n+public class GreetingFunction {\n+    @Funq\n+    public String greet(String name) {\n+       return \"Hello \" + name;\n+    }\n+}\n+----\n+\n+Java classes can also be used as input and output and must follow the Java bean convention and have", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a7aba3817182c0b07da430af34997760ca2cb10"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f897f4b166db37b96e8e4a4997f5bb100acae20c", "author": {"user": {"login": "patriot1burke", "name": "Bill Burke"}}, "url": "https://github.com/quarkusio/quarkus/commit/f897f4b166db37b96e8e4a4997f5bb100acae20c", "committedDate": "2020-05-20T08:47:34Z", "message": "Getting Funqy Ready for Release"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d732558602585c209b6e5ddfe2484d777a61eab2", "author": {"user": {"login": "patriot1burke", "name": "Bill Burke"}}, "url": "https://github.com/quarkusio/quarkus/commit/d732558602585c209b6e5ddfe2484d777a61eab2", "committedDate": "2020-05-19T21:02:34Z", "message": "Update docs/src/main/asciidoc/funqy-amazon-lambda.adoc\n\nCo-authored-by: Gunnar Morling <gunnar.morling@googlemail.com>"}, "afterCommit": {"oid": "f897f4b166db37b96e8e4a4997f5bb100acae20c", "author": {"user": {"login": "patriot1burke", "name": "Bill Burke"}}, "url": "https://github.com/quarkusio/quarkus/commit/f897f4b166db37b96e8e4a4997f5bb100acae20c", "committedDate": "2020-05-20T08:47:34Z", "message": "Getting Funqy Ready for Release"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3473, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}