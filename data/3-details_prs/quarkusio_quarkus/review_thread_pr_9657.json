{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0NDU4ODc2", "number": 9657, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzoyMzoyMlrOEAgVDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDowODoyN1rOECK57g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4OTY1MTMzOnYy", "diffSide": "RIGHT", "path": "extensions/arc/deployment/src/test/java/io/quarkus/arc/test/interceptor/staticmethods/InterceptedStaticMethodTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzoyMzoyMlrOGb02aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzoyODo1NFrOGb1E_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgzMDYzMw==", "bodyText": "When I said to try double and long primitives that's not what I meant ;) I mean, your ASM code looks right, but this is not testing it ;)", "url": "https://github.com/quarkusio/quarkus/pull/9657#discussion_r431830633", "createdAt": "2020-05-28T13:23:22Z", "author": {"login": "FroMage"}, "path": "extensions/arc/deployment/src/test/java/io/quarkus/arc/test/interceptor/staticmethods/InterceptedStaticMethodTest.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package io.quarkus.arc.test.interceptor.staticmethods;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+import static java.lang.annotation.ElementType.TYPE;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.Target;\n+import java.lang.reflect.Modifier;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.annotation.Priority;\n+import javax.interceptor.AroundInvoke;\n+import javax.interceptor.Interceptor;\n+import javax.interceptor.InterceptorBinding;\n+import javax.interceptor.InvocationContext;\n+\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.opentest4j.AssertionFailedError;\n+\n+import io.quarkus.test.QuarkusUnitTest;\n+\n+public class InterceptedStaticMethodTest {\n+\n+    @RegisterExtension\n+    static final QuarkusUnitTest config = new QuarkusUnitTest()\n+            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n+                    .addClasses(InterceptMe.class, Simple.class, SimpleInterceptor.class));\n+\n+    @Test\n+    public void testInterceptor() {\n+        assertEquals(\"OK:PONG\", Simple.ping(\"pong\"));\n+        Simple.pong();\n+        assertEquals(42.0, Simple.testDouble(2.0));\n+        assertEquals(1, SimpleInterceptor.VOID_INTERCEPTIONS.get());\n+    }\n+\n+    public static class Simple {\n+\n+        @InterceptMe\n+        public static String ping(String val) {\n+            return val.toUpperCase();\n+        }\n+\n+        @InterceptMe\n+        static void pong() {\n+        }\n+\n+        @InterceptMe\n+        protected static Double testDouble(Double val) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c30d82960dd60e443778f134551f6d143c63947"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgzNDM2Ng==", "bodyText": "Ah, I'm boxing the params automatically in my head ;-)", "url": "https://github.com/quarkusio/quarkus/pull/9657#discussion_r431834366", "createdAt": "2020-05-28T13:28:54Z", "author": {"login": "mkouba"}, "path": "extensions/arc/deployment/src/test/java/io/quarkus/arc/test/interceptor/staticmethods/InterceptedStaticMethodTest.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package io.quarkus.arc.test.interceptor.staticmethods;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+import static java.lang.annotation.ElementType.TYPE;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.Target;\n+import java.lang.reflect.Modifier;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.annotation.Priority;\n+import javax.interceptor.AroundInvoke;\n+import javax.interceptor.Interceptor;\n+import javax.interceptor.InterceptorBinding;\n+import javax.interceptor.InvocationContext;\n+\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.opentest4j.AssertionFailedError;\n+\n+import io.quarkus.test.QuarkusUnitTest;\n+\n+public class InterceptedStaticMethodTest {\n+\n+    @RegisterExtension\n+    static final QuarkusUnitTest config = new QuarkusUnitTest()\n+            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n+                    .addClasses(InterceptMe.class, Simple.class, SimpleInterceptor.class));\n+\n+    @Test\n+    public void testInterceptor() {\n+        assertEquals(\"OK:PONG\", Simple.ping(\"pong\"));\n+        Simple.pong();\n+        assertEquals(42.0, Simple.testDouble(2.0));\n+        assertEquals(1, SimpleInterceptor.VOID_INTERCEPTIONS.get());\n+    }\n+\n+    public static class Simple {\n+\n+        @InterceptMe\n+        public static String ping(String val) {\n+            return val.toUpperCase();\n+        }\n+\n+        @InterceptMe\n+        static void pong() {\n+        }\n+\n+        @InterceptMe\n+        protected static Double testDouble(Double val) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgzMDYzMw=="}, "originalCommit": {"oid": "7c30d82960dd60e443778f134551f6d143c63947"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4OTY1NTE2OnYy", "diffSide": "RIGHT", "path": "extensions/narayana-jta/runtime/src/main/java/io/quarkus/narayana/jta/runtime/interceptor/TransactionalInterceptorBase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzoyNDoxNVrOGb04yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzozMDo0MFrOGb1J1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgzMTI0Mw==", "bodyText": "Shouldn't we use getMethod().containing-class... here then?", "url": "https://github.com/quarkusio/quarkus/pull/9657#discussion_r431831243", "createdAt": "2020-05-28T13:24:15Z", "author": {"login": "FroMage"}, "path": "extensions/narayana-jta/runtime/src/main/java/io/quarkus/narayana/jta/runtime/interceptor/TransactionalInterceptorBase.java", "diffHunk": "@@ -83,7 +83,11 @@ private Transactional getTransactional(InvocationContext ic) {\n     private TransactionConfiguration getTransactionConfiguration(InvocationContext ic) {\n         TransactionConfiguration configuration = ic.getMethod().getAnnotation(TransactionConfiguration.class);\n         if (configuration == null) {\n-            return ic.getTarget().getClass().getAnnotation(TransactionConfiguration.class);\n+            Object target = ic.getTarget();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c30d82960dd60e443778f134551f6d143c63947"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgzNTYwNw==", "bodyText": "Hm, yes you're right, it should work in this particular case.", "url": "https://github.com/quarkusio/quarkus/pull/9657#discussion_r431835607", "createdAt": "2020-05-28T13:30:40Z", "author": {"login": "mkouba"}, "path": "extensions/narayana-jta/runtime/src/main/java/io/quarkus/narayana/jta/runtime/interceptor/TransactionalInterceptorBase.java", "diffHunk": "@@ -83,7 +83,11 @@ private Transactional getTransactional(InvocationContext ic) {\n     private TransactionConfiguration getTransactionConfiguration(InvocationContext ic) {\n         TransactionConfiguration configuration = ic.getMethod().getAnnotation(TransactionConfiguration.class);\n         if (configuration == null) {\n-            return ic.getTarget().getClass().getAnnotation(TransactionConfiguration.class);\n+            Object target = ic.getTarget();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgzMTI0Mw=="}, "originalCommit": {"oid": "7c30d82960dd60e443778f134551f6d143c63947"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMTgxNDgzOnYy", "diffSide": "LEFT", "path": "extensions/panache/hibernate-orm-panache/deployment/src/main/java/io/quarkus/hibernate/orm/panache/deployment/PanacheHibernateResourceProcessor.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwOToyMzoyNlrOGdpZrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwMToyODozOFrOGeyv6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0MDIwNw==", "bodyText": "Looks like you ignored the first note, so I assume this limitation is no longer necessary?\nI think you should have kept the second note and FIXME comment.", "url": "https://github.com/quarkusio/quarkus/pull/9657#discussion_r433740207", "createdAt": "2020-06-02T09:23:26Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-orm-panache/deployment/src/main/java/io/quarkus/hibernate/orm/panache/deployment/PanacheHibernateResourceProcessor.java", "diffHunk": "@@ -106,27 +127,13 @@ void build(CombinedIndexBuildItem index,\n \n         PanacheJpaEntityEnhancer modelEnhancer = new PanacheJpaEntityEnhancer(index.getIndex(), methodCustomizers);\n         Set<String> modelClasses = new HashSet<>();\n-        // Note that we do this in two passes because for some reason Jandex does not give us subtypes\n-        // of PanacheEntity if we ask for subtypes of PanacheEntityBase\n-        // NOTE: we don't skip abstract/generic entities because they still need accessors\n-        for (ClassInfo classInfo : index.getIndex().getAllKnownSubclasses(DOTNAME_PANACHE_ENTITY_BASE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5165ac9f5cddb9875f3d111f558fc8f75d581bfe"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1OTk3OQ==", "bodyText": "The tests passed locally and TBH I've never observed such a limitation in jandex.\nThe FIXME was not present in the mongo version so I though it's no longer a problem.\nI can keep the second note and FIXME of couse ;-).", "url": "https://github.com/quarkusio/quarkus/pull/9657#discussion_r433759979", "createdAt": "2020-06-02T09:57:03Z", "author": {"login": "mkouba"}, "path": "extensions/panache/hibernate-orm-panache/deployment/src/main/java/io/quarkus/hibernate/orm/panache/deployment/PanacheHibernateResourceProcessor.java", "diffHunk": "@@ -106,27 +127,13 @@ void build(CombinedIndexBuildItem index,\n \n         PanacheJpaEntityEnhancer modelEnhancer = new PanacheJpaEntityEnhancer(index.getIndex(), methodCustomizers);\n         Set<String> modelClasses = new HashSet<>();\n-        // Note that we do this in two passes because for some reason Jandex does not give us subtypes\n-        // of PanacheEntity if we ask for subtypes of PanacheEntityBase\n-        // NOTE: we don't skip abstract/generic entities because they still need accessors\n-        for (ClassInfo classInfo : index.getIndex().getAllKnownSubclasses(DOTNAME_PANACHE_ENTITY_BASE)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0MDIwNw=="}, "originalCommit": {"oid": "5165ac9f5cddb9875f3d111f558fc8f75d581bfe"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc2MTcwOQ==", "bodyText": "Yes please. Glad to know the tests pass with this, then. I mean, that code was there initially for a reason, so something must have happened, but glad we can get rid of it.", "url": "https://github.com/quarkusio/quarkus/pull/9657#discussion_r433761709", "createdAt": "2020-06-02T10:00:08Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-orm-panache/deployment/src/main/java/io/quarkus/hibernate/orm/panache/deployment/PanacheHibernateResourceProcessor.java", "diffHunk": "@@ -106,27 +127,13 @@ void build(CombinedIndexBuildItem index,\n \n         PanacheJpaEntityEnhancer modelEnhancer = new PanacheJpaEntityEnhancer(index.getIndex(), methodCustomizers);\n         Set<String> modelClasses = new HashSet<>();\n-        // Note that we do this in two passes because for some reason Jandex does not give us subtypes\n-        // of PanacheEntity if we ask for subtypes of PanacheEntityBase\n-        // NOTE: we don't skip abstract/generic entities because they still need accessors\n-        for (ClassInfo classInfo : index.getIndex().getAllKnownSubclasses(DOTNAME_PANACHE_ENTITY_BASE)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0MDIwNw=="}, "originalCommit": {"oid": "5165ac9f5cddb9875f3d111f558fc8f75d581bfe"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc2MjQ3Ng==", "bodyText": "Hopefully the test coverage is good enough ;-)", "url": "https://github.com/quarkusio/quarkus/pull/9657#discussion_r433762476", "createdAt": "2020-06-02T10:01:31Z", "author": {"login": "mkouba"}, "path": "extensions/panache/hibernate-orm-panache/deployment/src/main/java/io/quarkus/hibernate/orm/panache/deployment/PanacheHibernateResourceProcessor.java", "diffHunk": "@@ -106,27 +127,13 @@ void build(CombinedIndexBuildItem index,\n \n         PanacheJpaEntityEnhancer modelEnhancer = new PanacheJpaEntityEnhancer(index.getIndex(), methodCustomizers);\n         Set<String> modelClasses = new HashSet<>();\n-        // Note that we do this in two passes because for some reason Jandex does not give us subtypes\n-        // of PanacheEntity if we ask for subtypes of PanacheEntityBase\n-        // NOTE: we don't skip abstract/generic entities because they still need accessors\n-        for (ClassInfo classInfo : index.getIndex().getAllKnownSubclasses(DOTNAME_PANACHE_ENTITY_BASE)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0MDIwNw=="}, "originalCommit": {"oid": "5165ac9f5cddb9875f3d111f558fc8f75d581bfe"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0MTkyOQ==", "bodyText": "This would have happened if the jar containing PanacheEntityBase was not indexed. I think originally this was the case which is why this would not have worked, but it is indexed now.", "url": "https://github.com/quarkusio/quarkus/pull/9657#discussion_r434941929", "createdAt": "2020-06-04T01:28:38Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/panache/hibernate-orm-panache/deployment/src/main/java/io/quarkus/hibernate/orm/panache/deployment/PanacheHibernateResourceProcessor.java", "diffHunk": "@@ -106,27 +127,13 @@ void build(CombinedIndexBuildItem index,\n \n         PanacheJpaEntityEnhancer modelEnhancer = new PanacheJpaEntityEnhancer(index.getIndex(), methodCustomizers);\n         Set<String> modelClasses = new HashSet<>();\n-        // Note that we do this in two passes because for some reason Jandex does not give us subtypes\n-        // of PanacheEntity if we ask for subtypes of PanacheEntityBase\n-        // NOTE: we don't skip abstract/generic entities because they still need accessors\n-        for (ClassInfo classInfo : index.getIndex().getAllKnownSubclasses(DOTNAME_PANACHE_ENTITY_BASE)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0MDIwNw=="}, "originalCommit": {"oid": "5165ac9f5cddb9875f3d111f558fc8f75d581bfe"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzExMjc4OnYy", "diffSide": "RIGHT", "path": "extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/staticmethods/InterceptedStaticMethodsProcessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDowODoyN1rOGedm1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNzozMzozMVrOGe5Wiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5NTU0Mw==", "bodyText": "Wouldn't it be more efficient to query the index for interceptor binding (annotation) uses instead of checking every known class and every known method?", "url": "https://github.com/quarkusio/quarkus/pull/9657#discussion_r434595543", "createdAt": "2020-06-03T14:08:27Z", "author": {"login": "manovotn"}, "path": "extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/staticmethods/InterceptedStaticMethodsProcessor.java", "diffHunk": "@@ -0,0 +1,495 @@\n+package io.quarkus.arc.deployment.staticmethods;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+import static org.objectweb.asm.Opcodes.ACC_FINAL;\n+import static org.objectweb.asm.Opcodes.ACC_PRIVATE;\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ACC_STATIC;\n+\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import javax.enterprise.context.spi.Contextual;\n+import javax.enterprise.inject.spi.InterceptionType;\n+import javax.interceptor.InvocationContext;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget.Kind;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.jandex.Type;\n+import org.jboss.logging.Logger;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+\n+import io.quarkus.arc.InjectableInterceptor;\n+import io.quarkus.arc.deployment.BeanArchiveIndexBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerBuildItem;\n+import io.quarkus.arc.deployment.BeanRegistrationPhaseBuildItem;\n+import io.quarkus.arc.deployment.InterceptorResolverBuildItem;\n+import io.quarkus.arc.impl.CreationalContextImpl;\n+import io.quarkus.arc.impl.InterceptedMethodMetadata;\n+import io.quarkus.arc.impl.InterceptedStaticMethods;\n+import io.quarkus.arc.impl.InterceptedStaticMethods.InterceptedStaticMethod;\n+import io.quarkus.arc.processor.AnnotationLiteralProcessor;\n+import io.quarkus.arc.processor.BeanProcessor;\n+import io.quarkus.arc.processor.DotNames;\n+import io.quarkus.arc.processor.InterceptorInfo;\n+import io.quarkus.arc.processor.MethodDescriptors;\n+import io.quarkus.arc.runtime.InterceptedStaticMethodsRecorder;\n+import io.quarkus.deployment.GeneratedClassGizmoAdaptor;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Produce;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveMethodBuildItem;\n+import io.quarkus.deployment.util.AsmUtil;\n+import io.quarkus.gizmo.BytecodeCreator;\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.DescriptorUtils;\n+import io.quarkus.gizmo.FunctionCreator;\n+import io.quarkus.gizmo.Gizmo;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+public class InterceptedStaticMethodsProcessor {\n+\n+    private static final Logger LOGGER = Logger.getLogger(InterceptedStaticMethodsProcessor.class);\n+\n+    static final MethodDescriptor INTERCEPTED_STATIC_METHODS_REGISTER = MethodDescriptor\n+            .ofMethod(InterceptedStaticMethods.class, \"register\", void.class, String.class, InterceptedStaticMethod.class);\n+    static final MethodDescriptor INTERCEPTED_STATIC_METHODS_AROUND_INVOKE = MethodDescriptor\n+            .ofMethod(InterceptedStaticMethods.class, \"aroundInvoke\", Object.class, String.class, Object[].class);\n+\n+    private static final String ORGINAL_METHOD_COPY_SUFFIX = \"_orig\";\n+    private static final String INITIALIZER_CLASS_SUFFIX = \"_InterceptorInitializer\";\n+\n+    @BuildStep\n+    void collectInterceptedStaticMethodsCandidates(BeanArchiveIndexBuildItem beanArchiveIndex,\n+            BuildProducer<InterceptedStaticMethodBuildItem> interceptedStaticMethods,\n+            InterceptorResolverBuildItem interceptorResolver) {\n+\n+        // In this step we collect all intercepted static methods, ie. static methods annotated with interceptor bindings  \n+        IndexView index = beanArchiveIndex.getIndex();\n+\n+        for (ClassInfo clazz : index.getKnownClasses()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48ca849841bdffb66a8005a4a3234a6661c0487d"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxOTM1Nw==", "bodyText": "+1\nI'll update the PR tomorrow!", "url": "https://github.com/quarkusio/quarkus/pull/9657#discussion_r434619357", "createdAt": "2020-06-03T14:39:45Z", "author": {"login": "mkouba"}, "path": "extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/staticmethods/InterceptedStaticMethodsProcessor.java", "diffHunk": "@@ -0,0 +1,495 @@\n+package io.quarkus.arc.deployment.staticmethods;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+import static org.objectweb.asm.Opcodes.ACC_FINAL;\n+import static org.objectweb.asm.Opcodes.ACC_PRIVATE;\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ACC_STATIC;\n+\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import javax.enterprise.context.spi.Contextual;\n+import javax.enterprise.inject.spi.InterceptionType;\n+import javax.interceptor.InvocationContext;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget.Kind;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.jandex.Type;\n+import org.jboss.logging.Logger;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+\n+import io.quarkus.arc.InjectableInterceptor;\n+import io.quarkus.arc.deployment.BeanArchiveIndexBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerBuildItem;\n+import io.quarkus.arc.deployment.BeanRegistrationPhaseBuildItem;\n+import io.quarkus.arc.deployment.InterceptorResolverBuildItem;\n+import io.quarkus.arc.impl.CreationalContextImpl;\n+import io.quarkus.arc.impl.InterceptedMethodMetadata;\n+import io.quarkus.arc.impl.InterceptedStaticMethods;\n+import io.quarkus.arc.impl.InterceptedStaticMethods.InterceptedStaticMethod;\n+import io.quarkus.arc.processor.AnnotationLiteralProcessor;\n+import io.quarkus.arc.processor.BeanProcessor;\n+import io.quarkus.arc.processor.DotNames;\n+import io.quarkus.arc.processor.InterceptorInfo;\n+import io.quarkus.arc.processor.MethodDescriptors;\n+import io.quarkus.arc.runtime.InterceptedStaticMethodsRecorder;\n+import io.quarkus.deployment.GeneratedClassGizmoAdaptor;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Produce;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveMethodBuildItem;\n+import io.quarkus.deployment.util.AsmUtil;\n+import io.quarkus.gizmo.BytecodeCreator;\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.DescriptorUtils;\n+import io.quarkus.gizmo.FunctionCreator;\n+import io.quarkus.gizmo.Gizmo;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+public class InterceptedStaticMethodsProcessor {\n+\n+    private static final Logger LOGGER = Logger.getLogger(InterceptedStaticMethodsProcessor.class);\n+\n+    static final MethodDescriptor INTERCEPTED_STATIC_METHODS_REGISTER = MethodDescriptor\n+            .ofMethod(InterceptedStaticMethods.class, \"register\", void.class, String.class, InterceptedStaticMethod.class);\n+    static final MethodDescriptor INTERCEPTED_STATIC_METHODS_AROUND_INVOKE = MethodDescriptor\n+            .ofMethod(InterceptedStaticMethods.class, \"aroundInvoke\", Object.class, String.class, Object[].class);\n+\n+    private static final String ORGINAL_METHOD_COPY_SUFFIX = \"_orig\";\n+    private static final String INITIALIZER_CLASS_SUFFIX = \"_InterceptorInitializer\";\n+\n+    @BuildStep\n+    void collectInterceptedStaticMethodsCandidates(BeanArchiveIndexBuildItem beanArchiveIndex,\n+            BuildProducer<InterceptedStaticMethodBuildItem> interceptedStaticMethods,\n+            InterceptorResolverBuildItem interceptorResolver) {\n+\n+        // In this step we collect all intercepted static methods, ie. static methods annotated with interceptor bindings  \n+        IndexView index = beanArchiveIndex.getIndex();\n+\n+        for (ClassInfo clazz : index.getKnownClasses()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5NTU0Mw=="}, "originalCommit": {"oid": "48ca849841bdffb66a8005a4a3234a6661c0487d"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1MDEyMw==", "bodyText": "@manovotn done...", "url": "https://github.com/quarkusio/quarkus/pull/9657#discussion_r435050123", "createdAt": "2020-06-04T07:33:31Z", "author": {"login": "mkouba"}, "path": "extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/staticmethods/InterceptedStaticMethodsProcessor.java", "diffHunk": "@@ -0,0 +1,495 @@\n+package io.quarkus.arc.deployment.staticmethods;\n+\n+import static io.quarkus.deployment.annotations.ExecutionTime.STATIC_INIT;\n+import static org.objectweb.asm.Opcodes.ACC_FINAL;\n+import static org.objectweb.asm.Opcodes.ACC_PRIVATE;\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ACC_STATIC;\n+\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import javax.enterprise.context.spi.Contextual;\n+import javax.enterprise.inject.spi.InterceptionType;\n+import javax.interceptor.InvocationContext;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget.Kind;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.jandex.Type;\n+import org.jboss.logging.Logger;\n+import org.objectweb.asm.ClassVisitor;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+\n+import io.quarkus.arc.InjectableInterceptor;\n+import io.quarkus.arc.deployment.BeanArchiveIndexBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerBuildItem;\n+import io.quarkus.arc.deployment.BeanRegistrationPhaseBuildItem;\n+import io.quarkus.arc.deployment.InterceptorResolverBuildItem;\n+import io.quarkus.arc.impl.CreationalContextImpl;\n+import io.quarkus.arc.impl.InterceptedMethodMetadata;\n+import io.quarkus.arc.impl.InterceptedStaticMethods;\n+import io.quarkus.arc.impl.InterceptedStaticMethods.InterceptedStaticMethod;\n+import io.quarkus.arc.processor.AnnotationLiteralProcessor;\n+import io.quarkus.arc.processor.BeanProcessor;\n+import io.quarkus.arc.processor.DotNames;\n+import io.quarkus.arc.processor.InterceptorInfo;\n+import io.quarkus.arc.processor.MethodDescriptors;\n+import io.quarkus.arc.runtime.InterceptedStaticMethodsRecorder;\n+import io.quarkus.deployment.GeneratedClassGizmoAdaptor;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.Produce;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveMethodBuildItem;\n+import io.quarkus.deployment.util.AsmUtil;\n+import io.quarkus.gizmo.BytecodeCreator;\n+import io.quarkus.gizmo.ClassCreator;\n+import io.quarkus.gizmo.ClassOutput;\n+import io.quarkus.gizmo.DescriptorUtils;\n+import io.quarkus.gizmo.FunctionCreator;\n+import io.quarkus.gizmo.Gizmo;\n+import io.quarkus.gizmo.MethodCreator;\n+import io.quarkus.gizmo.MethodDescriptor;\n+import io.quarkus.gizmo.ResultHandle;\n+\n+public class InterceptedStaticMethodsProcessor {\n+\n+    private static final Logger LOGGER = Logger.getLogger(InterceptedStaticMethodsProcessor.class);\n+\n+    static final MethodDescriptor INTERCEPTED_STATIC_METHODS_REGISTER = MethodDescriptor\n+            .ofMethod(InterceptedStaticMethods.class, \"register\", void.class, String.class, InterceptedStaticMethod.class);\n+    static final MethodDescriptor INTERCEPTED_STATIC_METHODS_AROUND_INVOKE = MethodDescriptor\n+            .ofMethod(InterceptedStaticMethods.class, \"aroundInvoke\", Object.class, String.class, Object[].class);\n+\n+    private static final String ORGINAL_METHOD_COPY_SUFFIX = \"_orig\";\n+    private static final String INITIALIZER_CLASS_SUFFIX = \"_InterceptorInitializer\";\n+\n+    @BuildStep\n+    void collectInterceptedStaticMethodsCandidates(BeanArchiveIndexBuildItem beanArchiveIndex,\n+            BuildProducer<InterceptedStaticMethodBuildItem> interceptedStaticMethods,\n+            InterceptorResolverBuildItem interceptorResolver) {\n+\n+        // In this step we collect all intercepted static methods, ie. static methods annotated with interceptor bindings  \n+        IndexView index = beanArchiveIndex.getIndex();\n+\n+        for (ClassInfo clazz : index.getKnownClasses()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5NTU0Mw=="}, "originalCommit": {"oid": "48ca849841bdffb66a8005a4a3234a6661c0487d"}, "originalPosition": 92}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3031, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}