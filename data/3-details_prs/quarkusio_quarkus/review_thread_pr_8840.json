{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4Nzg4OTM3", "number": 8840, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwODo1MTozMFrOD2kMqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwODoxOTowOVrOD5TMEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTQyNzYwOnYy", "diffSide": "RIGHT", "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/AddNodePortDecorator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwODo1MTozMFrOGMYFyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwODo1NDozMVrOGMYNzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMDc5NQ==", "bodyText": "This https://kubernetes.io/docs/concepts/services-networking/service/#nodeport says that the default range is 30000-32767, and apparently it's configurable.", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r415630795", "createdAt": "2020-04-27T08:51:30Z", "author": {"login": "Ladicek"}, "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/AddNodePortDecorator.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package io.quarkus.kubernetes.deployment;\n+\n+import io.dekorate.deps.kubernetes.api.model.ObjectMeta;\n+import io.dekorate.deps.kubernetes.api.model.ServiceSpecFluent;\n+import io.dekorate.kubernetes.decorator.Decorator;\n+import io.dekorate.kubernetes.decorator.NamedResourceDecorator;\n+\n+public class AddNodePortDecorator extends NamedResourceDecorator<ServiceSpecFluent> {\n+\n+    private static final int MIN_VALUE = 30000;\n+    private static final int MAX_VALUE = 31999;\n+\n+    private final int nodePort;\n+\n+    public AddNodePortDecorator(String name, int nodePort) {\n+        super(name);\n+        if (nodePort < MIN_VALUE || nodePort > MAX_VALUE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62540bc9f388b4ef28b2e30326a5abccd2e12f72"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMjg0Nw==", "bodyText": "Ah, nice find! I need to remove these checks then.", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r415632847", "createdAt": "2020-04-27T08:54:31Z", "author": {"login": "geoand"}, "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/AddNodePortDecorator.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package io.quarkus.kubernetes.deployment;\n+\n+import io.dekorate.deps.kubernetes.api.model.ObjectMeta;\n+import io.dekorate.deps.kubernetes.api.model.ServiceSpecFluent;\n+import io.dekorate.kubernetes.decorator.Decorator;\n+import io.dekorate.kubernetes.decorator.NamedResourceDecorator;\n+\n+public class AddNodePortDecorator extends NamedResourceDecorator<ServiceSpecFluent> {\n+\n+    private static final int MIN_VALUE = 30000;\n+    private static final int MAX_VALUE = 31999;\n+\n+    private final int nodePort;\n+\n+    public AddNodePortDecorator(String name, int nodePort) {\n+        super(name);\n+        if (nodePort < MIN_VALUE || nodePort > MAX_VALUE) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMDc5NQ=="}, "originalCommit": {"oid": "62540bc9f388b4ef28b2e30326a5abccd2e12f72"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NTQzNDAwOnYy", "diffSide": "RIGHT", "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesConfig.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwODo1MzowMVrOGMYJrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QwOTowODo0M1rOGMY1Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMTc5MQ==", "bodyText": "Is there a way to not specify the concrete nodePort and let Kubernetes assign a port automatically? Perhaps allow the 0 value, which typically means \"port should be auto-assigned\"?", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r415631791", "createdAt": "2020-04-27T08:53:01Z", "author": {"login": "Ladicek"}, "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesConfig.java", "diffHunk": "@@ -107,6 +107,12 @@\n     @ConfigItem(defaultValue = \"ClusterIP\")\n     ServiceType serviceType;\n \n+    /**\n+     * The nodePort to set when serviceType is set to nodePort\n+     */\n+    @ConfigItem(defaultValue = \"31987\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62540bc9f388b4ef28b2e30326a5abccd2e12f72"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMjY0OQ==", "bodyText": "When you don't set it, it gets assigned automatically. The problem is that it gets re-assigned to another value when you update the application and that's what I am trying to avoid.", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r415632649", "createdAt": "2020-04-27T08:54:14Z", "author": {"login": "geoand"}, "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesConfig.java", "diffHunk": "@@ -107,6 +107,12 @@\n     @ConfigItem(defaultValue = \"ClusterIP\")\n     ServiceType serviceType;\n \n+    /**\n+     * The nodePort to set when serviceType is set to nodePort\n+     */\n+    @ConfigItem(defaultValue = \"31987\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMTc5MQ=="}, "originalCommit": {"oid": "62540bc9f388b4ef28b2e30326a5abccd2e12f72"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzOTM0OQ==", "bodyText": "Sure. What I'm trying to say is: is there a way how to get back to the default behavior?", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r415639349", "createdAt": "2020-04-27T09:03:24Z", "author": {"login": "Ladicek"}, "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesConfig.java", "diffHunk": "@@ -107,6 +107,12 @@\n     @ConfigItem(defaultValue = \"ClusterIP\")\n     ServiceType serviceType;\n \n+    /**\n+     * The nodePort to set when serviceType is set to nodePort\n+     */\n+    @ConfigItem(defaultValue = \"31987\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMTc5MQ=="}, "originalCommit": {"oid": "62540bc9f388b4ef28b2e30326a5abccd2e12f72"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY0MjkwNg==", "bodyText": "Yeah, that essentially boils down to what @iocanel  is asking for :)", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r415642906", "createdAt": "2020-04-27T09:08:43Z", "author": {"login": "geoand"}, "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesConfig.java", "diffHunk": "@@ -107,6 +107,12 @@\n     @ConfigItem(defaultValue = \"ClusterIP\")\n     ServiceType serviceType;\n \n+    /**\n+     * The nodePort to set when serviceType is set to nodePort\n+     */\n+    @ConfigItem(defaultValue = \"31987\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMTc5MQ=="}, "originalCommit": {"oid": "62540bc9f388b4ef28b2e30326a5abccd2e12f72"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDM4MjE2OnYy", "diffSide": "RIGHT", "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesDeployer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMDo1MjowOVrOGOkDZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMDo1NDowNlrOGOkHQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyMzk0MA==", "bodyText": "Is it deployment-target or deploymentTarget?", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r417923940", "createdAt": "2020-04-30T10:52:09Z", "author": {"login": "Ladicek"}, "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesDeployer.java", "diffHunk": "@@ -65,23 +67,72 @@ public void deploy(KubernetesClientBuildItem kubernetesClient,\n                             + CONTAINER_IMAGE_EXTENSIONS_STR + \".\");\n         }\n \n-        boolean isContainerImageS2IPresent = Capabilities.CONTAINER_IMAGE_S2I.equals(activeContainerImageCapability.get());\n-        if (ContainerImageUtil.isRegistryMissingAndNotS2I(capabilities, containerImageInfo)) {\n+        final KubernetesDeploymentTargetBuildItem selectedKubernetesDeploymentTargetBuildItem = determineDeploymentTarget(\n+                containerImageInfo, kubernetesDeploymentTargets, activeContainerImageCapability.get());\n+\n+        final KubernetesClient client = Clients.fromConfig(kubernetesClient.getClient().getConfiguration());\n+        deploymentResult\n+                .produce(deploy(selectedKubernetesDeploymentTargetBuildItem, client, outputTarget.getOutputDirectory()));\n+    }\n+\n+    /**\n+     * Determine a single deployment target out of the possible options.\n+     *\n+     * When there is none selected, we choose vanilla kubernetes.\n+     * When multiple options exist, we choose openshift if it exists, then minikube if it exists.\n+     * If none of the above conditions match, we select the single option if there is only one, otherwise we thrown\n+     * an {@code IllegalStateException} if there are multiple options to choose from, as there is no way clear way to\n+     * pick one. This is better than picking one at random, which because the order in the list isn't fixed would lead\n+     * to non-deterministic behavior.\n+     */\n+    private KubernetesDeploymentTargetBuildItem determineDeploymentTarget(ContainerImageInfoBuildItem containerImageInfo,\n+            List<KubernetesDeploymentTargetBuildItem> kubernetesDeploymentTargets, String activeContainerImageCapability) {\n+        final KubernetesDeploymentTargetBuildItem selectedKubernetesDeploymentTargetBuildItem;\n+        if (kubernetesDeploymentTargets.isEmpty()) {\n+            log.debug(\"No Kubernetes Deployment target was explicitly set. Defaulting to 'kubernetes'.\");\n+            return new KubernetesDeploymentTargetBuildItem(KUBERNETES, DEPLOYMENT);\n+        }\n+\n+        Optional<KubernetesDeploymentTargetBuildItem> openshiftDeploymentTarget = getOptionalDeploymentTarget(\n+                kubernetesDeploymentTargets, OPENSHIFT);\n+        boolean checkForMissingRegistry = true;\n+        if (openshiftDeploymentTarget.isPresent()) {\n+            if (kubernetesDeploymentTargets.size() > 1) {\n+                log.info(\"Multiple Kubernetes deployment targets were set. 'openshift' will be selected.\");\n+            }\n+            selectedKubernetesDeploymentTargetBuildItem = openshiftDeploymentTarget.get();\n+            // If we are using s2i there is no need warn about the missing registry\n+            checkForMissingRegistry = Capabilities.CONTAINER_IMAGE_S2I.equals(activeContainerImageCapability);\n+        } else {\n+            Optional<KubernetesDeploymentTargetBuildItem> minikubeDeploymentTarget = getOptionalDeploymentTarget(\n+                    kubernetesDeploymentTargets, MINIKUBE);\n+            if (minikubeDeploymentTarget.isPresent()) {\n+                if (kubernetesDeploymentTargets.size() > 1) {\n+                    log.info(\"Multiple Kubernetes deployment targets were set. 'minikube' will be selected.\");\n+                }\n+                selectedKubernetesDeploymentTargetBuildItem = minikubeDeploymentTarget.get();\n+                // No need to check for a registry when using Minikube since Minikube can work with the local docker daemon\n+                // Futhermore, the 'ImagePullPolicy' has already been set to 'IfNotPresent' for Minikube\n+                checkForMissingRegistry = false;\n+            } else if (kubernetesDeploymentTargets.size() > 1) {\n+                throw new IllegalStateException(\n+                        \"Multiple Kubernetes deployment targets present with no known priorities. Please select a single deployment target using the \\\"quarkus.kubernetes.deploymentTarget\\\" property.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05e0c788cfe11ba8f63e412094a9d888fc1faa36"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNDkzMQ==", "bodyText": "It's obviously the latter :P", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r417924931", "createdAt": "2020-04-30T10:54:06Z", "author": {"login": "geoand"}, "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesDeployer.java", "diffHunk": "@@ -65,23 +67,72 @@ public void deploy(KubernetesClientBuildItem kubernetesClient,\n                             + CONTAINER_IMAGE_EXTENSIONS_STR + \".\");\n         }\n \n-        boolean isContainerImageS2IPresent = Capabilities.CONTAINER_IMAGE_S2I.equals(activeContainerImageCapability.get());\n-        if (ContainerImageUtil.isRegistryMissingAndNotS2I(capabilities, containerImageInfo)) {\n+        final KubernetesDeploymentTargetBuildItem selectedKubernetesDeploymentTargetBuildItem = determineDeploymentTarget(\n+                containerImageInfo, kubernetesDeploymentTargets, activeContainerImageCapability.get());\n+\n+        final KubernetesClient client = Clients.fromConfig(kubernetesClient.getClient().getConfiguration());\n+        deploymentResult\n+                .produce(deploy(selectedKubernetesDeploymentTargetBuildItem, client, outputTarget.getOutputDirectory()));\n+    }\n+\n+    /**\n+     * Determine a single deployment target out of the possible options.\n+     *\n+     * When there is none selected, we choose vanilla kubernetes.\n+     * When multiple options exist, we choose openshift if it exists, then minikube if it exists.\n+     * If none of the above conditions match, we select the single option if there is only one, otherwise we thrown\n+     * an {@code IllegalStateException} if there are multiple options to choose from, as there is no way clear way to\n+     * pick one. This is better than picking one at random, which because the order in the list isn't fixed would lead\n+     * to non-deterministic behavior.\n+     */\n+    private KubernetesDeploymentTargetBuildItem determineDeploymentTarget(ContainerImageInfoBuildItem containerImageInfo,\n+            List<KubernetesDeploymentTargetBuildItem> kubernetesDeploymentTargets, String activeContainerImageCapability) {\n+        final KubernetesDeploymentTargetBuildItem selectedKubernetesDeploymentTargetBuildItem;\n+        if (kubernetesDeploymentTargets.isEmpty()) {\n+            log.debug(\"No Kubernetes Deployment target was explicitly set. Defaulting to 'kubernetes'.\");\n+            return new KubernetesDeploymentTargetBuildItem(KUBERNETES, DEPLOYMENT);\n+        }\n+\n+        Optional<KubernetesDeploymentTargetBuildItem> openshiftDeploymentTarget = getOptionalDeploymentTarget(\n+                kubernetesDeploymentTargets, OPENSHIFT);\n+        boolean checkForMissingRegistry = true;\n+        if (openshiftDeploymentTarget.isPresent()) {\n+            if (kubernetesDeploymentTargets.size() > 1) {\n+                log.info(\"Multiple Kubernetes deployment targets were set. 'openshift' will be selected.\");\n+            }\n+            selectedKubernetesDeploymentTargetBuildItem = openshiftDeploymentTarget.get();\n+            // If we are using s2i there is no need warn about the missing registry\n+            checkForMissingRegistry = Capabilities.CONTAINER_IMAGE_S2I.equals(activeContainerImageCapability);\n+        } else {\n+            Optional<KubernetesDeploymentTargetBuildItem> minikubeDeploymentTarget = getOptionalDeploymentTarget(\n+                    kubernetesDeploymentTargets, MINIKUBE);\n+            if (minikubeDeploymentTarget.isPresent()) {\n+                if (kubernetesDeploymentTargets.size() > 1) {\n+                    log.info(\"Multiple Kubernetes deployment targets were set. 'minikube' will be selected.\");\n+                }\n+                selectedKubernetesDeploymentTargetBuildItem = minikubeDeploymentTarget.get();\n+                // No need to check for a registry when using Minikube since Minikube can work with the local docker daemon\n+                // Futhermore, the 'ImagePullPolicy' has already been set to 'IfNotPresent' for Minikube\n+                checkForMissingRegistry = false;\n+            } else if (kubernetesDeploymentTargets.size() > 1) {\n+                throw new IllegalStateException(\n+                        \"Multiple Kubernetes deployment targets present with no known priorities. Please select a single deployment target using the \\\"quarkus.kubernetes.deploymentTarget\\\" property.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyMzk0MA=="}, "originalCommit": {"oid": "05e0c788cfe11ba8f63e412094a9d888fc1faa36"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDM4NDU4OnYy", "diffSide": "RIGHT", "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMDo1MzowMlrOGOkFBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMDo1NDoyMFrOGOkHrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNDM1Ng==", "bodyText": "Minikube, not Minishift :-)", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r417924356", "createdAt": "2020-04-30T10:53:02Z", "author": {"login": "Ladicek"}, "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java", "diffHunk": "@@ -118,6 +125,13 @@ public void checkKubernetes(BuildProducer<KubernetesDeploymentTargetBuildItem> d\n         }\n     }\n \n+    @BuildStep\n+    public void checkMinishift(BuildProducer<KubernetesDeploymentTargetBuildItem> deploymentTargets) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05e0c788cfe11ba8f63e412094a9d888fc1faa36"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNTAzOA==", "bodyText": "Oh man.. I don't know how many times I made that mistake...", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r417925038", "createdAt": "2020-04-30T10:54:20Z", "author": {"login": "geoand"}, "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java", "diffHunk": "@@ -118,6 +125,13 @@ public void checkKubernetes(BuildProducer<KubernetesDeploymentTargetBuildItem> d\n         }\n     }\n \n+    @BuildStep\n+    public void checkMinishift(BuildProducer<KubernetesDeploymentTargetBuildItem> deploymentTargets) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNDM1Ng=="}, "originalCommit": {"oid": "05e0c788cfe11ba8f63e412094a9d888fc1faa36"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDM5MDgwOnYy", "diffSide": "RIGHT", "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMDo1NDo1MFrOGOkI1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMDo1NTo1MFrOGOkKqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNTMzMw==", "bodyText": "... && deploymentTargets.contains(MINIKUBE) should work", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r417925333", "createdAt": "2020-04-30T10:54:50Z", "author": {"login": "Ladicek"}, "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java", "diffHunk": "@@ -405,12 +422,19 @@ private void applyConfig(Session session, Project project, String target, String\n      * This case comes up when users want to deploy their application to a cluster like Minikube where no registry is used\n      * and instead they rely on the image being built directly into the docker daemon that the cluster uses.\n      */\n-    private boolean needToForceUpdateImagePullPolicy(Optional<ContainerImageInfoBuildItem> containerImage,\n+    private boolean needToForceUpdateImagePullPolicy(Collection<String> deploymentTargets,\n+            Optional<ContainerImageInfoBuildItem> containerImage,\n             Capabilities capabilities) {\n+\n+        // no need to change when we use Minikube only\n+        if ((deploymentTargets.size() == 1) && MINIKUBE.equals(deploymentTargets.iterator().next())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05e0c788cfe11ba8f63e412094a9d888fc1faa36"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNTgwMQ==", "bodyText": "Right, it's left over from what I was doing in an earlier iteration", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r417925801", "createdAt": "2020-04-30T10:55:50Z", "author": {"login": "geoand"}, "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java", "diffHunk": "@@ -405,12 +422,19 @@ private void applyConfig(Session session, Project project, String target, String\n      * This case comes up when users want to deploy their application to a cluster like Minikube where no registry is used\n      * and instead they rely on the image being built directly into the docker daemon that the cluster uses.\n      */\n-    private boolean needToForceUpdateImagePullPolicy(Optional<ContainerImageInfoBuildItem> containerImage,\n+    private boolean needToForceUpdateImagePullPolicy(Collection<String> deploymentTargets,\n+            Optional<ContainerImageInfoBuildItem> containerImage,\n             Capabilities capabilities) {\n+\n+        // no need to change when we use Minikube only\n+        if ((deploymentTargets.size() == 1) && MINIKUBE.equals(deploymentTargets.iterator().next())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyNTMzMw=="}, "originalCommit": {"oid": "05e0c788cfe11ba8f63e412094a9d888fc1faa36"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNDA5ODEwOnYy", "diffSide": "RIGHT", "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwODoxOTowOVrOGQfCZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwODozNzoxNlrOGQfo0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkzODkxOQ==", "bodyText": "I guess that Optional is introduced in order to be able to easily tell when this is a default value or a user provided one?", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r419938919", "createdAt": "2020-05-05T08:19:09Z", "author": {"login": "iocanel"}, "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesConfig.java", "diffHunk": "@@ -193,11 +199,12 @@\n \n     /**\n      * The target deployment platform.\n-     * Defaults to kubernetes. Can be kubernetes, openshift, knative etc, or any combination of the above as comma separated\n+     * Defaults to kubernetes. Can be kubernetes, openshift, knative, minikube etc, or any combination of the above as comma\n+     * separated\n      * list.\n      */\n-    @ConfigItem(defaultValue = \"kubernetes\")\n-    List<String> deploymentTarget;\n+    @ConfigItem\n+    Optional<List<String>> deploymentTarget;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01b1a3a239de3d09afac8e878d633ee9599832c2"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0ODc1Mg==", "bodyText": "Yes, exactly", "url": "https://github.com/quarkusio/quarkus/pull/8840#discussion_r419948752", "createdAt": "2020-05-05T08:37:16Z", "author": {"login": "geoand"}, "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesConfig.java", "diffHunk": "@@ -193,11 +199,12 @@\n \n     /**\n      * The target deployment platform.\n-     * Defaults to kubernetes. Can be kubernetes, openshift, knative etc, or any combination of the above as comma separated\n+     * Defaults to kubernetes. Can be kubernetes, openshift, knative, minikube etc, or any combination of the above as comma\n+     * separated\n      * list.\n      */\n-    @ConfigItem(defaultValue = \"kubernetes\")\n-    List<String> deploymentTarget;\n+    @ConfigItem\n+    Optional<List<String>> deploymentTarget;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkzODkxOQ=="}, "originalCommit": {"oid": "01b1a3a239de3d09afac8e878d633ee9599832c2"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3281, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}