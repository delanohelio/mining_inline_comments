{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUwMDAwMDkz", "number": 10769, "reviewThreads": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNzo1MzoyMFrOEQ7qKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMDo1OTo0MFrOETM-xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MTkwMTIzOnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/resources/META-INF/quarkus-extension.yaml", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNzo1MzoyMFrOG1W9Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwOTozNjozMVrOG9TVhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYwMzgzMA==", "bodyText": "You won't have a specific guide?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r458603830", "createdAt": "2020-07-22T07:53:20Z", "author": {"login": "gsmet"}, "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/resources/META-INF/quarkus-extension.yaml", "diffHunk": "@@ -0,0 +1,12 @@\n+---\n+name: \"Hibernate Reactive with Panache\"\n+metadata:\n+  keywords:\n+  - \"hibernate-reactive-panache\"\n+  - \"panache\"\n+  - \"hibernate\"\n+  - \"jpa\"\n+  guide: \"https://quarkus.io/guides/hibernate-orm-panache\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYzNTUxMg==", "bodyText": "We will, but there's no guide yet, as is the case for HR.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r458635512", "createdAt": "2020-07-22T08:46:37Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/resources/META-INF/quarkus-extension.yaml", "diffHunk": "@@ -0,0 +1,12 @@\n+---\n+name: \"Hibernate Reactive with Panache\"\n+metadata:\n+  keywords:\n+  - \"hibernate-reactive-panache\"\n+  - \"panache\"\n+  - \"hibernate\"\n+  - \"jpa\"\n+  guide: \"https://quarkus.io/guides/hibernate-orm-panache\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYwMzgzMA=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU4MzA0Mw==", "bodyText": "In that case, better remove the guide than pointing to an inappropriate one.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459583043", "createdAt": "2020-07-23T16:39:28Z", "author": {"login": "gsmet"}, "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/resources/META-INF/quarkus-extension.yaml", "diffHunk": "@@ -0,0 +1,12 @@\n+---\n+name: \"Hibernate Reactive with Panache\"\n+metadata:\n+  keywords:\n+  - \"hibernate-reactive-panache\"\n+  - \"panache\"\n+  - \"hibernate\"\n+  - \"jpa\"\n+  guide: \"https://quarkus.io/guides/hibernate-orm-panache\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYwMzgzMA=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzMzEyNw==", "bodyText": "OK.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r466933127", "createdAt": "2020-08-07T09:36:31Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/resources/META-INF/quarkus-extension.yaml", "diffHunk": "@@ -0,0 +1,12 @@\n+---\n+name: \"Hibernate Reactive with Panache\"\n+metadata:\n+  keywords:\n+  - \"hibernate-reactive-panache\"\n+  - \"panache\"\n+  - \"hibernate\"\n+  - \"jpa\"\n+  guide: \"https://quarkus.io/guides/hibernate-orm-panache\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYwMzgzMA=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MDYwMzkzOnYy", "diffSide": "RIGHT", "path": "extensions/panache/panache-mock/src/main/java/io/quarkus/panache/mock/PanacheMock.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwOTo0Mjo0N1rOG2pXKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTowNjowNFrOG9ddNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1Mzk2Mw==", "bodyText": "What if the settings don't match from a previously cached mock you might have created for the same klass?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459953963", "createdAt": "2020-07-24T09:42:47Z", "author": {"login": "Sanne"}, "path": "extensions/panache/panache-mock/src/main/java/io/quarkus/panache/mock/PanacheMock.java", "diffHunk": "@@ -40,6 +41,13 @@ public static void mock(Class<?>... classes) {\n         IsMockEnabled = !mocks.isEmpty();\n     }\n \n+    public static void mock(MockSettings settings, Class<?>... classes) {\n+        for (Class<?> klass : classes) {\n+            mocks.computeIfAbsent(klass, v -> Mockito.mock(klass, settings));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzMzM2MA==", "bodyText": "I guess it will override the mock, since they're keyed on class and not settings. That's fine.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r466933360", "createdAt": "2020-08-07T09:36:59Z", "author": {"login": "FroMage"}, "path": "extensions/panache/panache-mock/src/main/java/io/quarkus/panache/mock/PanacheMock.java", "diffHunk": "@@ -40,6 +41,13 @@ public static void mock(Class<?>... classes) {\n         IsMockEnabled = !mocks.isEmpty();\n     }\n \n+    public static void mock(MockSettings settings, Class<?>... classes) {\n+        for (Class<?> klass : classes) {\n+            mocks.computeIfAbsent(klass, v -> Mockito.mock(klass, settings));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1Mzk2Mw=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk0NTYxMw==", "bodyText": "and settings will not change?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r466945613", "createdAt": "2020-08-07T10:02:24Z", "author": {"login": "Sanne"}, "path": "extensions/panache/panache-mock/src/main/java/io/quarkus/panache/mock/PanacheMock.java", "diffHunk": "@@ -40,6 +41,13 @@ public static void mock(Class<?>... classes) {\n         IsMockEnabled = !mocks.isEmpty();\n     }\n \n+    public static void mock(MockSettings settings, Class<?>... classes) {\n+        for (Class<?> klass : classes) {\n+            mocks.computeIfAbsent(klass, v -> Mockito.mock(klass, settings));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1Mzk2Mw=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA5ODM1MA==", "bodyText": "Ah, you're right, OK.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467098350", "createdAt": "2020-08-07T15:05:00Z", "author": {"login": "FroMage"}, "path": "extensions/panache/panache-mock/src/main/java/io/quarkus/panache/mock/PanacheMock.java", "diffHunk": "@@ -40,6 +41,13 @@ public static void mock(Class<?>... classes) {\n         IsMockEnabled = !mocks.isEmpty();\n     }\n \n+    public static void mock(MockSettings settings, Class<?>... classes) {\n+        for (Class<?> klass : classes) {\n+            mocks.computeIfAbsent(klass, v -> Mockito.mock(klass, settings));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1Mzk2Mw=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA5ODkzMg==", "bodyText": "Pfff, I'll just remove this method.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467098932", "createdAt": "2020-08-07T15:06:04Z", "author": {"login": "FroMage"}, "path": "extensions/panache/panache-mock/src/main/java/io/quarkus/panache/mock/PanacheMock.java", "diffHunk": "@@ -40,6 +41,13 @@ public static void mock(Class<?>... classes) {\n         IsMockEnabled = !mocks.isEmpty();\n     }\n \n+    public static void mock(MockSettings settings, Class<?>... classes) {\n+        for (Class<?> klass : classes) {\n+            mocks.computeIfAbsent(klass, v -> Mockito.mock(klass, settings));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1Mzk2Mw=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MDYxMTc0OnYy", "diffSide": "RIGHT", "path": "extensions/panache/panache-mock/src/main/java/io/quarkus/panache/mock/PanacheMock.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwOTo0NToyMFrOG2pbrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwOTozNzowNFrOG9TWlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NTExNg==", "bodyText": "you have a race condition here; maybe it's not an issues as I don't expect many will invoke this method concurrecntly, but perhaps you'd still prefer to use a safer locking pattern?\nI don't think this needs to be \"high throughput\" or high performance, so just synchronize it all?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459955116", "createdAt": "2020-07-24T09:45:20Z", "author": {"login": "Sanne"}, "path": "extensions/panache/panache-mock/src/main/java/io/quarkus/panache/mock/PanacheMock.java", "diffHunk": "@@ -40,6 +41,13 @@ public static void mock(Class<?>... classes) {\n         IsMockEnabled = !mocks.isEmpty();\n     }\n \n+    public static void mock(MockSettings settings, Class<?>... classes) {\n+        for (Class<?> klass : classes) {\n+            mocks.computeIfAbsent(klass, v -> Mockito.mock(klass, settings));\n+        }\n+        IsMockEnabled = !mocks.isEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzMzM5Nw==", "bodyText": "OK", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r466933397", "createdAt": "2020-08-07T09:37:04Z", "author": {"login": "FroMage"}, "path": "extensions/panache/panache-mock/src/main/java/io/quarkus/panache/mock/PanacheMock.java", "diffHunk": "@@ -40,6 +41,13 @@ public static void mock(Class<?>... classes) {\n         IsMockEnabled = !mocks.isEmpty();\n     }\n \n+    public static void mock(MockSettings settings, Class<?>... classes) {\n+        for (Class<?> klass : classes) {\n+            mocks.computeIfAbsent(klass, v -> Mockito.mock(klass, settings));\n+        }\n+        IsMockEnabled = !mocks.isEmpty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NTExNg=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MDYyNDIyOnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwOTo0OTo0MlrOG2pjUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNTowNDozM1rOG9dZzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NzA3NQ==", "bodyText": "What is the purpose of this check? And why should it not be persisted otherwise?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459957075", "createdAt": "2020-07-24T09:49:42Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1Nzc1MQ==", "bodyText": "Also, why is this specific variation of the persist method having this check, but the other methods won't have the same semantics?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459957751", "createdAt": "2020-07-24T09:51:07Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NzA3NQ=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzMzc2NA==", "bodyText": "The purpose is to not call persist if it's already persisted. The ORM version has the same check. What happens if I call persist on an already persisted entity, otherwise?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r466933764", "createdAt": "2020-08-07T09:37:54Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NzA3NQ=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzNDQ0Nw==", "bodyText": "The other variations of persist ultimately call this, so it's fine.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r466934447", "createdAt": "2020-08-07T09:39:20Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NzA3NQ=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk0OTIwMg==", "bodyText": "What happens if I call persist on an already persisted entity, otherwise?\n\nNothing, but at least we have a chance to verify the transaction is alive, extend timeouts, and things like that.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r466949202", "createdAt": "2020-08-07T10:10:24Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NzA3NQ=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA5ODA2Mw==", "bodyText": "Well, the javadoc wasn't entirely clear about the semantics here.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467098063", "createdAt": "2020-08-07T15:04:33Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NzA3NQ=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MDY0MzQyOnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwOTo1NTo1MFrOG2pulw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMzozNzo0MlrOG9aMBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1OTk1OQ==", "bodyText": "why name this \"getEntityManager\" when it doesn't return one? :)\nAlso: why returning an Uni, when you could just get the Session right away? opening a Session is non-blocking.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459959959", "createdAt": "2020-07-24T09:55:50Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2MTU4Mg==", "bodyText": "I mean, ask ArC for a Mutiny.Session rather than a Uni<Mutiny.Session>", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459961582", "createdAt": "2020-07-24T09:59:31Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1OTk1OQ=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwNzExMg==", "bodyText": "+1 this would remove a lot of flatMap operations !", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462207112", "createdAt": "2020-07-29T10:43:26Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1OTk1OQ=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzNzA4Mg==", "bodyText": "I don't think there's any producer for Mutiny.Session since ArC doesn't do async injection, so not sure what you're talking about.\nOK, apparently this was added after I did my PR. Fine, let's switch to that :)", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r466937082", "createdAt": "2020-08-07T09:44:44Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1OTk1OQ=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0NTM4Mg==", "bodyText": "BTW, opening a Session isn't a blocking operation.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467045382", "createdAt": "2020-08-07T13:37:42Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1OTk1OQ=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MDY3ODY4OnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMDowODoyOFrOG2qDzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwOTo1NzowM1rOG9T8Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2NTM4OQ==", "bodyText": "Should we remove this for now?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459965389", "createdAt": "2020-07-24T10:08:28Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {\n+        @SuppressWarnings(\"serial\")\n+        Uni<Session> entityManager = Arc.container().instance(new TypeLiteral<Uni<Mutiny.Session>>() {\n+        }).get();\n+        // FIXME: handle null or exception?\n+        if (entityManager == null) {\n+            throw new PersistenceException(\"No Mutiny.Session found. Do you have any JPA entities defined?\");\n+        }\n+        return entityManager;\n+    }\n+\n+    public TransactionManager getTransactionManager() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk0MzA3NQ==", "bodyText": "Yes", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r466943075", "createdAt": "2020-08-07T09:57:03Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {\n+        @SuppressWarnings(\"serial\")\n+        Uni<Session> entityManager = Arc.container().instance(new TypeLiteral<Uni<Mutiny.Session>>() {\n+        }).get();\n+        // FIXME: handle null or exception?\n+        if (entityManager == null) {\n+            throw new PersistenceException(\"No Mutiny.Session found. Do you have any JPA entities defined?\");\n+        }\n+        return entityManager;\n+    }\n+\n+    public TransactionManager getTransactionManager() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2NTM4OQ=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MDY5MjQwOnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMDoxMzo1MlrOG2qMRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMzoyODo0NFrOG9Z3QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2NzU1Ng==", "bodyText": "All this stuff with string manipulation is extremely dodgy .. :)", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459967556", "createdAt": "2020-07-24T10:13:52Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here\n+                return applyFilters(em, () -> countQuery.getSingleResult());\n+            });\n+        }\n+        return count;\n+    }\n+\n+    private String countQuery() {\n+        if (countQuery != null) {\n+            return countQuery;\n+        }\n+\n+        // try to generate a good count query from the existing query", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2ODE3NQ==", "bodyText": "I suppose you have much of the same in the non-reactive version of Panache? Could we avoid some copy paste for all this code?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459968175", "createdAt": "2020-07-24T10:15:21Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here\n+                return applyFilters(em, () -> countQuery.getSingleResult());\n+            });\n+        }\n+        return count;\n+    }\n+\n+    private String countQuery() {\n+        if (countQuery != null) {\n+            return countQuery;\n+        }\n+\n+        // try to generate a good count query from the existing query", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2NzU1Ng=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0MDA2NQ==", "bodyText": "Yes, good idea.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467040065", "createdAt": "2020-08-07T13:28:44Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here\n+                return applyFilters(em, () -> countQuery.getSingleResult());\n+            });\n+        }\n+        return count;\n+    }\n+\n+    private String countQuery() {\n+        if (countQuery != null) {\n+            return countQuery;\n+        }\n+\n+        // try to generate a good count query from the existing query", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2NzU1Ng=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MDcwMjMwOnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache/deployment/pom.xml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMDoxNzo0MVrOG2qSQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMzozMTowNlrOG9Z8oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2OTA5MQ==", "bodyText": "Don't we normally have integration tests in the /integration-testsdirectory, in the root of the Quarkus source tree?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459969091", "createdAt": "2020-07-24T10:17:41Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache/deployment/pom.xml", "diffHunk": "@@ -0,0 +1,243 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <parent>\n+        <artifactId>quarkus-hibernate-reactive-panache-parent</artifactId>\n+        <groupId>io.quarkus</groupId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../</relativePath>\n+    </parent>\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <properties>\n+        <maven.compiler.parameters>true</maven.compiler.parameters>\n+        <postgres.image>postgres:10.5</postgres.image>\n+        <postgres.reactive.url>vertx-reactive:postgresql://localhost:5432/hibernate_orm_test</postgres.reactive.url>\n+    </properties>\n+\n+    <artifactId>quarkus-hibernate-reactive-panache-deployment</artifactId>\n+    <name>Quarkus - Hibernate Reactive with Panache - Deployment</name>\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-core-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-hibernate-reactive-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-hibernate-reactive-panache-common-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-panache-common-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-hibernate-reactive-panache</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.ow2.asm</groupId>\n+            <artifactId>asm</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.ow2.asm</groupId>\n+            <artifactId>asm-tree</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.ow2.asm</groupId>\n+            <artifactId>asm-analysis</artifactId>\n+        </dependency>\n+\n+        <!-- test dependencies -->\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-junit5-internal</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-reactive-pg-client</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-resteasy</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-resteasy-mutiny</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-resteasy-jsonb</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.rest-assured</groupId>\n+            <artifactId>rest-assured</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <testResources>\n+            <testResource>\n+                <directory>src/test/resources</directory>\n+                <filtering>true</filtering>\n+            </testResource>\n+        </testResources>\n+        <plugins>\n+            <plugin>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <skip>true</skip>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <artifactId>maven-failsafe-plugin</artifactId>\n+                <configuration>\n+                    <skip>true</skip>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>io.quarkus</groupId>\n+                <artifactId>quarkus-maven-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <goals>\n+                            <goal>build</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <annotationProcessorPaths>\n+                        <path>\n+                            <groupId>io.quarkus</groupId>\n+                            <artifactId>quarkus-extension-processor</artifactId>\n+                            <version>${project.version}</version>\n+                        </path>\n+                    </annotationProcessorPaths>\n+                </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+\n+    <profiles>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0MTQ0MA==", "bodyText": "Those are for the hot-reload. They mirror what we have for ORM with Panache, except that one could run without docker because H2, which we don't support ATM for reactive. I could move them to the existing IT, but that'd be less symmetrical and I still hope we will support H2 for reactive at some point and get rid of this docker requirement.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467041440", "createdAt": "2020-08-07T13:31:06Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache/deployment/pom.xml", "diffHunk": "@@ -0,0 +1,243 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <parent>\n+        <artifactId>quarkus-hibernate-reactive-panache-parent</artifactId>\n+        <groupId>io.quarkus</groupId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../</relativePath>\n+    </parent>\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <properties>\n+        <maven.compiler.parameters>true</maven.compiler.parameters>\n+        <postgres.image>postgres:10.5</postgres.image>\n+        <postgres.reactive.url>vertx-reactive:postgresql://localhost:5432/hibernate_orm_test</postgres.reactive.url>\n+    </properties>\n+\n+    <artifactId>quarkus-hibernate-reactive-panache-deployment</artifactId>\n+    <name>Quarkus - Hibernate Reactive with Panache - Deployment</name>\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-core-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-hibernate-reactive-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-hibernate-reactive-panache-common-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-panache-common-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-hibernate-reactive-panache</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.ow2.asm</groupId>\n+            <artifactId>asm</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.ow2.asm</groupId>\n+            <artifactId>asm-tree</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>org.ow2.asm</groupId>\n+            <artifactId>asm-analysis</artifactId>\n+        </dependency>\n+\n+        <!-- test dependencies -->\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-junit5-internal</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-reactive-pg-client</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-resteasy</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-resteasy-mutiny</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-resteasy-jsonb</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.rest-assured</groupId>\n+            <artifactId>rest-assured</artifactId>\n+            <scope>test</scope>\n+        </dependency>\n+    </dependencies>\n+\n+    <build>\n+        <testResources>\n+            <testResource>\n+                <directory>src/test/resources</directory>\n+                <filtering>true</filtering>\n+            </testResource>\n+        </testResources>\n+        <plugins>\n+            <plugin>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <skip>true</skip>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <artifactId>maven-failsafe-plugin</artifactId>\n+                <configuration>\n+                    <skip>true</skip>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>io.quarkus</groupId>\n+                <artifactId>quarkus-maven-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <goals>\n+                            <goal>build</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <artifactId>maven-compiler-plugin</artifactId>\n+                <configuration>\n+                    <annotationProcessorPaths>\n+                        <path>\n+                            <groupId>io.quarkus</groupId>\n+                            <artifactId>quarkus-extension-processor</artifactId>\n+                            <version>${project.version}</version>\n+                        </path>\n+                    </annotationProcessorPaths>\n+                </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+\n+    <profiles>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2OTA5MQ=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MDcwNjA0OnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache/deployment/src/main/java/io/quarkus/hibernate/reactive/panache/deployment/PanacheHibernateResourceProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMDoxOTowNlrOG2qUiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMzozMzowM1rOG9aBDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2OTY3Mw==", "bodyText": "Why using System.err here?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459969673", "createdAt": "2020-07-24T10:19:06Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache/deployment/src/main/java/io/quarkus/hibernate/reactive/panache/deployment/PanacheHibernateResourceProcessor.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package io.quarkus.hibernate.reactive.panache.deployment;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import javax.persistence.Id;\n+\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.ClassType;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.ParameterizedType;\n+import org.jboss.jandex.Type;\n+import org.jboss.jandex.Type.Kind;\n+\n+import io.quarkus.arc.deployment.UnremovableBeanBuildItem;\n+import io.quarkus.arc.deployment.ValidationPhaseBuildItem;\n+import io.quarkus.arc.processor.BeanInfo;\n+import io.quarkus.bootstrap.classloading.ClassPathElement;\n+import io.quarkus.bootstrap.classloading.QuarkusClassLoader;\n+import io.quarkus.builder.BuildException;\n+import io.quarkus.deployment.Feature;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.AdditionalApplicationArchiveMarkerBuildItem;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.util.JandexUtil;\n+import io.quarkus.hibernate.orm.deployment.AdditionalJpaModelBuildItem;\n+import io.quarkus.hibernate.orm.deployment.HibernateEnhancersRegisteredBuildItem;\n+import io.quarkus.hibernate.reactive.panache.PanacheEntity;\n+import io.quarkus.hibernate.reactive.panache.PanacheEntityBase;\n+import io.quarkus.hibernate.reactive.panache.PanacheRepository;\n+import io.quarkus.hibernate.reactive.panache.PanacheRepositoryBase;\n+import io.quarkus.panache.common.deployment.EntityField;\n+import io.quarkus.panache.common.deployment.EntityModel;\n+import io.quarkus.panache.common.deployment.MetamodelInfo;\n+import io.quarkus.panache.common.deployment.PanacheEntityClassesBuildItem;\n+import io.quarkus.panache.common.deployment.PanacheFieldAccessEnhancer;\n+import io.quarkus.panache.common.deployment.PanacheMethodCustomizer;\n+import io.quarkus.panache.common.deployment.PanacheMethodCustomizerBuildItem;\n+import io.quarkus.panache.common.deployment.PanacheRepositoryEnhancer;\n+import io.smallrye.mutiny.Uni;\n+\n+public final class PanacheHibernateResourceProcessor {\n+\n+    static final DotName DOTNAME_PANACHE_REPOSITORY_BASE = DotName.createSimple(PanacheRepositoryBase.class.getName());\n+    private static final DotName DOTNAME_PANACHE_REPOSITORY = DotName.createSimple(PanacheRepository.class.getName());\n+    static final DotName DOTNAME_PANACHE_ENTITY_BASE = DotName.createSimple(PanacheEntityBase.class.getName());\n+    private static final DotName DOTNAME_PANACHE_ENTITY = DotName.createSimple(PanacheEntity.class.getName());\n+\n+    private static final DotName DOTNAME_REACTIVE_SESSION = DotName.createSimple(Mutiny.Session.class.getName());\n+    private static final DotName DOTNAME_UNI = DotName.createSimple(Uni.class.getName());\n+\n+    private static final DotName DOTNAME_ID = DotName.createSimple(Id.class.getName());\n+    protected static final String META_INF_PANACHE_ARCHIVE_MARKER = \"META-INF/panache-archive.marker\";\n+\n+    protected static final ParameterizedType SESSION_TYPE = ParameterizedType.create(DOTNAME_UNI,\n+            new Type[] { ClassType.create(DOTNAME_REACTIVE_SESSION, Kind.CLASS) }, null);\n+\n+    @BuildStep\n+    FeatureBuildItem featureBuildItem() {\n+        // FIXME\n+        return new FeatureBuildItem(Feature.HIBERNATE_ORM_PANACHE.getName() + \"-reactive\");\n+    }\n+\n+    @BuildStep\n+    List<AdditionalJpaModelBuildItem> produceModel() {\n+        // only useful for the index resolution: hibernate will register it to be transformed, but BuildMojo\n+        // only transforms classes from the application jar, so we do our own transforming\n+        return Collections.singletonList(\n+                new AdditionalJpaModelBuildItem(PanacheEntity.class));\n+    }\n+\n+    @BuildStep\n+    UnremovableBeanBuildItem ensureBeanLookupAvailable() {\n+        //        [types=[io.smallrye.mutiny.Uni<org.hibernate.reactive.mutiny.Mutiny$Session>, java.lang.Object], \n+        //                qualifiers=[@Default, @Any], \n+        //                target=io.smallrye.mutiny.Uni<org.hibernate.reactive.mutiny.Mutiny$Session> mutinySession(), \n+        //                declaringBean=io.quarkus.hibernate.reactive.runtime.ReactiveSessionProducer]\n+\n+        return new UnremovableBeanBuildItem(new Predicate<BeanInfo>() {\n+            @Override\n+            public boolean test(BeanInfo t) {\n+                boolean m1 = t.hasType(DOTNAME_UNI);\n+                if (m1) {\n+                    boolean m2 = t.getTypes().contains(SESSION_TYPE);\n+                    System.err.println(\"REMOVE \" + t + \" m1: \" + m1 + \" m2: \" + m2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0MjU3NA==", "bodyText": "Ooops.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467042574", "createdAt": "2020-08-07T13:33:03Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache/deployment/src/main/java/io/quarkus/hibernate/reactive/panache/deployment/PanacheHibernateResourceProcessor.java", "diffHunk": "@@ -0,0 +1,196 @@\n+package io.quarkus.hibernate.reactive.panache.deployment;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import javax.persistence.Id;\n+\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.ClassType;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.ParameterizedType;\n+import org.jboss.jandex.Type;\n+import org.jboss.jandex.Type.Kind;\n+\n+import io.quarkus.arc.deployment.UnremovableBeanBuildItem;\n+import io.quarkus.arc.deployment.ValidationPhaseBuildItem;\n+import io.quarkus.arc.processor.BeanInfo;\n+import io.quarkus.bootstrap.classloading.ClassPathElement;\n+import io.quarkus.bootstrap.classloading.QuarkusClassLoader;\n+import io.quarkus.builder.BuildException;\n+import io.quarkus.deployment.Feature;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.AdditionalApplicationArchiveMarkerBuildItem;\n+import io.quarkus.deployment.builditem.BytecodeTransformerBuildItem;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.util.JandexUtil;\n+import io.quarkus.hibernate.orm.deployment.AdditionalJpaModelBuildItem;\n+import io.quarkus.hibernate.orm.deployment.HibernateEnhancersRegisteredBuildItem;\n+import io.quarkus.hibernate.reactive.panache.PanacheEntity;\n+import io.quarkus.hibernate.reactive.panache.PanacheEntityBase;\n+import io.quarkus.hibernate.reactive.panache.PanacheRepository;\n+import io.quarkus.hibernate.reactive.panache.PanacheRepositoryBase;\n+import io.quarkus.panache.common.deployment.EntityField;\n+import io.quarkus.panache.common.deployment.EntityModel;\n+import io.quarkus.panache.common.deployment.MetamodelInfo;\n+import io.quarkus.panache.common.deployment.PanacheEntityClassesBuildItem;\n+import io.quarkus.panache.common.deployment.PanacheFieldAccessEnhancer;\n+import io.quarkus.panache.common.deployment.PanacheMethodCustomizer;\n+import io.quarkus.panache.common.deployment.PanacheMethodCustomizerBuildItem;\n+import io.quarkus.panache.common.deployment.PanacheRepositoryEnhancer;\n+import io.smallrye.mutiny.Uni;\n+\n+public final class PanacheHibernateResourceProcessor {\n+\n+    static final DotName DOTNAME_PANACHE_REPOSITORY_BASE = DotName.createSimple(PanacheRepositoryBase.class.getName());\n+    private static final DotName DOTNAME_PANACHE_REPOSITORY = DotName.createSimple(PanacheRepository.class.getName());\n+    static final DotName DOTNAME_PANACHE_ENTITY_BASE = DotName.createSimple(PanacheEntityBase.class.getName());\n+    private static final DotName DOTNAME_PANACHE_ENTITY = DotName.createSimple(PanacheEntity.class.getName());\n+\n+    private static final DotName DOTNAME_REACTIVE_SESSION = DotName.createSimple(Mutiny.Session.class.getName());\n+    private static final DotName DOTNAME_UNI = DotName.createSimple(Uni.class.getName());\n+\n+    private static final DotName DOTNAME_ID = DotName.createSimple(Id.class.getName());\n+    protected static final String META_INF_PANACHE_ARCHIVE_MARKER = \"META-INF/panache-archive.marker\";\n+\n+    protected static final ParameterizedType SESSION_TYPE = ParameterizedType.create(DOTNAME_UNI,\n+            new Type[] { ClassType.create(DOTNAME_REACTIVE_SESSION, Kind.CLASS) }, null);\n+\n+    @BuildStep\n+    FeatureBuildItem featureBuildItem() {\n+        // FIXME\n+        return new FeatureBuildItem(Feature.HIBERNATE_ORM_PANACHE.getName() + \"-reactive\");\n+    }\n+\n+    @BuildStep\n+    List<AdditionalJpaModelBuildItem> produceModel() {\n+        // only useful for the index resolution: hibernate will register it to be transformed, but BuildMojo\n+        // only transforms classes from the application jar, so we do our own transforming\n+        return Collections.singletonList(\n+                new AdditionalJpaModelBuildItem(PanacheEntity.class));\n+    }\n+\n+    @BuildStep\n+    UnremovableBeanBuildItem ensureBeanLookupAvailable() {\n+        //        [types=[io.smallrye.mutiny.Uni<org.hibernate.reactive.mutiny.Mutiny$Session>, java.lang.Object], \n+        //                qualifiers=[@Default, @Any], \n+        //                target=io.smallrye.mutiny.Uni<org.hibernate.reactive.mutiny.Mutiny$Session> mutinySession(), \n+        //                declaringBean=io.quarkus.hibernate.reactive.runtime.ReactiveSessionProducer]\n+\n+        return new UnremovableBeanBuildItem(new Predicate<BeanInfo>() {\n+            @Override\n+            public boolean test(BeanInfo t) {\n+                boolean m1 = t.hasType(DOTNAME_UNI);\n+                if (m1) {\n+                    boolean m2 = t.getTypes().contains(SESSION_TYPE);\n+                    System.err.println(\"REMOVE \" + t + \" m1: \" + m1 + \" m2: \" + m2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2OTY3Mw=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MDcxODA0OnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache/deployment/src/test/java/io/quarkus/hibernate/reactive/panache/test/DuplicateIdEntityTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMDoyMzo1MVrOG2qb4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMzozNToxMFrOG9aGKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk3MTU1Mw==", "bodyText": "So Panache can't deal with composite IDs ?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459971553", "createdAt": "2020-07-24T10:23:51Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache/deployment/src/test/java/io/quarkus/hibernate/reactive/panache/test/DuplicateIdEntityTest.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package io.quarkus.hibernate.reactive.panache.test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import io.quarkus.builder.BuildException;\n+import io.quarkus.test.QuarkusUnitTest;\n+\n+public class DuplicateIdEntityTest {\n+\n+    @RegisterExtension\n+    static QuarkusUnitTest runner = new QuarkusUnitTest()\n+            .setExpectedException(BuildException.class)\n+            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n+                    .addClasses(DuplicateIdEntity.class));\n+\n+    @Test\n+    void shouldThrow() {\n+        fail(\"A BuildException should have been thrown due to duplicate entity ID\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0Mzg4MQ==", "bodyText": "IIRC this detects the case where you have multiple @Id annotations but no matching @IdClass which is always a blunder.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467043881", "createdAt": "2020-08-07T13:35:10Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache/deployment/src/test/java/io/quarkus/hibernate/reactive/panache/test/DuplicateIdEntityTest.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package io.quarkus.hibernate.reactive.panache.test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import io.quarkus.builder.BuildException;\n+import io.quarkus.test.QuarkusUnitTest;\n+\n+public class DuplicateIdEntityTest {\n+\n+    @RegisterExtension\n+    static QuarkusUnitTest runner = new QuarkusUnitTest()\n+            .setExpectedException(BuildException.class)\n+            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)\n+                    .addClasses(DuplicateIdEntity.class));\n+\n+    @Test\n+    void shouldThrow() {\n+        fail(\"A BuildException should have been thrown due to duplicate entity ID\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk3MTU1Mw=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MDcyMzcwOnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/Panache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMDoyNTo0OFrOG2qfNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMzozNjoyNFrOG9aJBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk3MjQwNg==", "bodyText": "It's not an EntityManager .. in this case since it's public API I'd definitely fix it.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r459972406", "createdAt": "2020-07-24T10:25:48Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/Panache.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package io.quarkus.hibernate.reactive.panache;\n+\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.persistence.EntityManager;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.hibernate.reactive.panache.runtime.JpaOperations;\n+import io.quarkus.panache.common.Parameters;\n+import io.smallrye.mutiny.Uni;\n+\n+/**\n+ * Utility class for Panache.\n+ *\n+ * @author St\u00e9phane \u00c9pardaud\n+ */\n+public class Panache {\n+\n+    /**\n+     * Returns the current {@link EntityManager}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0NDYxMg==", "bodyText": "Yes, I've fixed it.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467044612", "createdAt": "2020-08-07T13:36:24Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/Panache.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package io.quarkus.hibernate.reactive.panache;\n+\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import javax.persistence.EntityManager;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.hibernate.reactive.panache.runtime.JpaOperations;\n+import io.quarkus.panache.common.Parameters;\n+import io.smallrye.mutiny.Uni;\n+\n+/**\n+ * Utility class for Panache.\n+ *\n+ * @author St\u00e9phane \u00c9pardaud\n+ */\n+public class Panache {\n+\n+    /**\n+     * Returns the current {@link EntityManager}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk3MjQwNg=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MTY4MzAxOnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMzo0NToyMFrOG4NTgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwOTo0MDozMVrOHBho1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU5MTQyNg==", "bodyText": "Any  particular reason to use the collector?\nIt's possible to convert a Stream using Multi and return a Uni<Void> by using ignore().\nIt would look something like:\nreturn getEntityManager.flatMap( em -> \n    Multi.createFrom().items( entities )\n        .onItem().invoke( entity -> em.persist( entity ) )\n        .onItem().ignoreAsUni()\n);", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r461591426", "createdAt": "2020-07-28T13:45:20Z", "author": {"login": "DavideD"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a3f43141080ba1504c0dbcfaf069954d0a69d5"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYyOTI4Mg==", "bodyText": "Similar for delete and flush", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r461629282", "createdAt": "2020-07-28T14:33:08Z", "author": {"login": "DavideD"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU5MTQyNg=="}, "originalCommit": {"oid": "32a3f43141080ba1504c0dbcfaf069954d0a69d5"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0NzA1OQ==", "bodyText": "Oh I didn't know about this, I've used it, thanks. I really didn't expect onItem to lead me to an operation that worked on the completion of ALL items.\nI do not see what you mean about delete and flush though, which don't use streams?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467047059", "createdAt": "2020-08-07T13:40:33Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU5MTQyNg=="}, "originalCommit": {"oid": "32a3f43141080ba1504c0dbcfaf069954d0a69d5"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA5OTU5Nw==", "bodyText": "Except it doesn't work:\n// this works:\n        List<Uni<Void>> uniList = entities.map(entity -> persist(session, entity)).collect(Collectors.toList());\n        return Uni.combine().all().unis(uniList).discardItems();\n\n// this does nothing:\n        return Multi.createFrom().items(entities)\n                     .map(entity -> persist(session, entity))\n                     .onItem().ignoreAsUni();\n@cescoffier is this a bug?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467099597", "createdAt": "2020-08-07T15:07:14Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU5MTQyNg=="}, "originalCommit": {"oid": "32a3f43141080ba1504c0dbcfaf069954d0a69d5"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM0OTcwOQ==", "bodyText": "persist returns a Uni right? To you need to flatMap instead of map.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r471349709", "createdAt": "2020-08-17T09:18:31Z", "author": {"login": "cescoffier"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU5MTQyNg=="}, "originalCommit": {"oid": "32a3f43141080ba1504c0dbcfaf069954d0a69d5"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM2MTc1MA==", "bodyText": "Aha, yeah, makes a lot of sense.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r471361750", "createdAt": "2020-08-17T09:40:31Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU5MTQyNg=="}, "originalCommit": {"oid": "32a3f43141080ba1504c0dbcfaf069954d0a69d5"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MTg0NjU3OnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNDoxNzowOVrOG4O3Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMzo0MzoxNVrOG9aY-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYxNjkyNg==", "bodyText": "You could use ifNull and IfNotNull here:\nfindById(entityClass, id)\n    .onItem().ifNotNull().transformToUni( entity -> s.remove( entity ).onItem().transform( ignore -> Boolean.TRUE ))\n    .onItem().ifNull().continueWith( Boolean.FALSE );", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r461616926", "createdAt": "2020-07-28T14:17:09Z", "author": {"login": "DavideD"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {\n+        @SuppressWarnings(\"serial\")\n+        Uni<Session> entityManager = Arc.container().instance(new TypeLiteral<Uni<Mutiny.Session>>() {\n+        }).get();\n+        // FIXME: handle null or exception?\n+        if (entityManager == null) {\n+            throw new PersistenceException(\"No Mutiny.Session found. Do you have any JPA entities defined?\");\n+        }\n+        return entityManager;\n+    }\n+\n+    public TransactionManager getTransactionManager() {\n+        return Arc.container().instance(TransactionManager.class).get();\n+    }\n+\n+    public static Mutiny.Query<?> bindParameters(Mutiny.Query<?> query, Object[] params) {\n+        if (params == null || params.length == 0)\n+            return query;\n+        for (int i = 0; i < params.length; i++) {\n+            query.setParameter(i + 1, params[i]);\n+        }\n+        return query;\n+    }\n+\n+    public static Mutiny.Query<?> bindParameters(Mutiny.Query<?> query, Map<String, Object> params) {\n+        if (params == null || params.size() == 0)\n+            return query;\n+        for (Entry<String, Object> entry : params.entrySet()) {\n+            query.setParameter(entry.getKey(), entry.getValue());\n+        }\n+        return query;\n+    }\n+\n+    public int paramCount(Object[] params) {\n+        return params != null ? params.length : 0;\n+    }\n+\n+    public int paramCount(Map<String, Object> params) {\n+        return params != null ? params.size() : 0;\n+    }\n+\n+    private String getEntityName(Class<?> entityClass) {\n+        // FIXME: not true?\n+        return entityClass.getName();\n+    }\n+\n+    public String createFindQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null) {\n+            return \"FROM \" + getEntityName(entityClass);\n+        }\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty()) {\n+            return \"FROM \" + getEntityName(entityClass);\n+        }\n+\n+        if (isNamedQuery(query)) {\n+            // we return named query as is\n+            return query;\n+        }\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \") || trimmedLc.startsWith(\"select \")) {\n+            return query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            return \"FROM \" + getEntityName(entityClass) + \" \" + query;\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    static boolean isNamedQuery(String query) {\n+        if (query == null || query.isEmpty()) {\n+            return false;\n+        }\n+        return query.charAt(0) == '#';\n+    }\n+\n+    private String createCountQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null)\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty())\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"SELECT COUNT(*) \" + query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            // ignore it\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    private String createUpdateQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null) {\n+            throw new PanacheQueryException(\"Query string cannot be null\");\n+        }\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty()) {\n+            throw new PanacheQueryException(\"Query string cannot be empty\");\n+        }\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"update \")) {\n+            return query;\n+        }\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"UPDATE \" + query;\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        if (trimmedLc.startsWith(\"set \")) {\n+            return \"UPDATE FROM \" + getEntityName(entityClass) + \" \" + query;\n+        }\n+        return \"UPDATE FROM \" + getEntityName(entityClass) + \" SET \" + query;\n+    }\n+\n+    private String createDeleteQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null)\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty())\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"DELETE \" + query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            // ignore it\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"DELETE FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    public String toOrderBy(Sort sort) {\n+        if (sort == null) {\n+            return null;\n+        }\n+        if (sort.getColumns().size() == 0) {\n+            return \"\";\n+        }\n+        StringBuilder sb = new StringBuilder(\" ORDER BY \");\n+        for (int i = 0; i < sort.getColumns().size(); i++) {\n+            Sort.Column column = sort.getColumns().get(i);\n+            if (i > 0)\n+                sb.append(\" , \");\n+            sb.append(column.getName());\n+            if (column.getDirection() != Sort.Direction.Ascending)\n+                sb.append(\" DESC\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    //\n+    // Queries\n+\n+    public Uni<?> findById(Class<?> entityClass, Object id) {\n+        return getEntityManager().flatMap(em -> em.find(entityClass, id));\n+    }\n+\n+    public Uni<?> findById(Class<?> entityClass, Object id, LockModeType lockModeType) {\n+        return getEntityManager().flatMap(em -> em.find(entityClass, id, LockModeConverter.convertToLockMode(lockModeType)));\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Object... params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        String findQuery = createFindQuery(entityClass, query, paramCount(params));\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        // FIXME: check for duplicate ORDER BY clause?\n+        if (isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            NamedQueryUtil.checkNamedQuery(entityClass, namedQuery);\n+            return createPanacheQuery(em, query, toOrderBy(sort), params);\n+        }\n+        return createPanacheQuery(em, findQuery, toOrderBy(sort), params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        String findQuery = createFindQuery(entityClass, query, paramCount(params));\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        // FIXME: check for duplicate ORDER BY clause?\n+        if (isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            NamedQueryUtil.checkNamedQuery(entityClass, namedQuery);\n+            return createPanacheQuery(em, query, toOrderBy(sort), params);\n+        }\n+        return createPanacheQuery(em, findQuery, toOrderBy(sort), params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Parameters params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return find(entityClass, query, sort, params.map());\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Object... params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Parameters params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Object... params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Parameters params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public PanacheQueryType findAll(Class<?> entityClass) {\n+        String query = \"FROM \" + getEntityName(entityClass);\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        return createPanacheQuery(em, query, null, null);\n+    }\n+\n+    public PanacheQueryType findAll(Class<?> entityClass, Sort sort) {\n+        String query = \"FROM \" + getEntityName(entityClass);\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        return createPanacheQuery(em, query, toOrderBy(sort), null);\n+    }\n+\n+    public Uni<List<?>> listAll(Class<?> entityClass) {\n+        return list(findAll(entityClass));\n+    }\n+\n+    public Uni<List<?>> listAll(Class<?> entityClass, Sort sort) {\n+        return list(findAll(entityClass, sort));\n+    }\n+\n+    public Multi<?> streamAll(Class<?> entityClass) {\n+        return stream(findAll(entityClass));\n+    }\n+\n+    public Multi<?> streamAll(Class<?> entityClass, Sort sort) {\n+        return stream(findAll(entityClass, sort));\n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public Uni<Long> count(Class<?> entityClass) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) em.createQuery(\"SELECT COUNT(*) FROM \" + getEntityName(entityClass)).getSingleResult());\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public Uni<Long> count(Class<?> entityClass, String query, Object... params) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) bindParameters(em.createQuery(createCountQuery(entityClass, query, paramCount(params))),\n+                        params).getSingleResult());\n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public Uni<Long> count(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) bindParameters(em.createQuery(createCountQuery(entityClass, query, paramCount(params))),\n+                        params).getSingleResult());\n+    }\n+\n+    public Uni<Long> count(Class<?> entityClass, String query, Parameters params) {\n+        return count(entityClass, query, params.map());\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass) {\n+        return count(entityClass).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Object... params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Parameters params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Long> deleteAll(Class<?> entityClass) {\n+        return getEntityManager().flatMap(em -> em.createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate()\n+                .map(i -> i.longValue()));\n+    }\n+\n+    public Uni<Boolean> deleteById(Class<?> entityClass, Object id) {\n+        // Impl note : we load the entity then delete it because it's the only implementation generic enough for any model,\n+        // and correct in all cases (composite key, graph of entities, ...). HQL cannot be directly used for these reasons.\n+        return findById(entityClass, id)\n+                .flatMap(entity -> {\n+                    if (entity == null) {\n+                        return Uni.createFrom().item(false);\n+                    }\n+                    return getEntityManager().flatMap(em -> em.remove(entity).map(v -> true));\n+                });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a3f43141080ba1504c0dbcfaf069954d0a69d5"}, "originalPosition": 436}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0ODY5OA==", "bodyText": "I can, but it's not clear to me that it'll be more readable :)", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467048698", "createdAt": "2020-08-07T13:43:15Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {\n+        @SuppressWarnings(\"serial\")\n+        Uni<Session> entityManager = Arc.container().instance(new TypeLiteral<Uni<Mutiny.Session>>() {\n+        }).get();\n+        // FIXME: handle null or exception?\n+        if (entityManager == null) {\n+            throw new PersistenceException(\"No Mutiny.Session found. Do you have any JPA entities defined?\");\n+        }\n+        return entityManager;\n+    }\n+\n+    public TransactionManager getTransactionManager() {\n+        return Arc.container().instance(TransactionManager.class).get();\n+    }\n+\n+    public static Mutiny.Query<?> bindParameters(Mutiny.Query<?> query, Object[] params) {\n+        if (params == null || params.length == 0)\n+            return query;\n+        for (int i = 0; i < params.length; i++) {\n+            query.setParameter(i + 1, params[i]);\n+        }\n+        return query;\n+    }\n+\n+    public static Mutiny.Query<?> bindParameters(Mutiny.Query<?> query, Map<String, Object> params) {\n+        if (params == null || params.size() == 0)\n+            return query;\n+        for (Entry<String, Object> entry : params.entrySet()) {\n+            query.setParameter(entry.getKey(), entry.getValue());\n+        }\n+        return query;\n+    }\n+\n+    public int paramCount(Object[] params) {\n+        return params != null ? params.length : 0;\n+    }\n+\n+    public int paramCount(Map<String, Object> params) {\n+        return params != null ? params.size() : 0;\n+    }\n+\n+    private String getEntityName(Class<?> entityClass) {\n+        // FIXME: not true?\n+        return entityClass.getName();\n+    }\n+\n+    public String createFindQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null) {\n+            return \"FROM \" + getEntityName(entityClass);\n+        }\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty()) {\n+            return \"FROM \" + getEntityName(entityClass);\n+        }\n+\n+        if (isNamedQuery(query)) {\n+            // we return named query as is\n+            return query;\n+        }\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \") || trimmedLc.startsWith(\"select \")) {\n+            return query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            return \"FROM \" + getEntityName(entityClass) + \" \" + query;\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    static boolean isNamedQuery(String query) {\n+        if (query == null || query.isEmpty()) {\n+            return false;\n+        }\n+        return query.charAt(0) == '#';\n+    }\n+\n+    private String createCountQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null)\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty())\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"SELECT COUNT(*) \" + query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            // ignore it\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    private String createUpdateQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null) {\n+            throw new PanacheQueryException(\"Query string cannot be null\");\n+        }\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty()) {\n+            throw new PanacheQueryException(\"Query string cannot be empty\");\n+        }\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"update \")) {\n+            return query;\n+        }\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"UPDATE \" + query;\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        if (trimmedLc.startsWith(\"set \")) {\n+            return \"UPDATE FROM \" + getEntityName(entityClass) + \" \" + query;\n+        }\n+        return \"UPDATE FROM \" + getEntityName(entityClass) + \" SET \" + query;\n+    }\n+\n+    private String createDeleteQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null)\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty())\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"DELETE \" + query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            // ignore it\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"DELETE FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    public String toOrderBy(Sort sort) {\n+        if (sort == null) {\n+            return null;\n+        }\n+        if (sort.getColumns().size() == 0) {\n+            return \"\";\n+        }\n+        StringBuilder sb = new StringBuilder(\" ORDER BY \");\n+        for (int i = 0; i < sort.getColumns().size(); i++) {\n+            Sort.Column column = sort.getColumns().get(i);\n+            if (i > 0)\n+                sb.append(\" , \");\n+            sb.append(column.getName());\n+            if (column.getDirection() != Sort.Direction.Ascending)\n+                sb.append(\" DESC\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    //\n+    // Queries\n+\n+    public Uni<?> findById(Class<?> entityClass, Object id) {\n+        return getEntityManager().flatMap(em -> em.find(entityClass, id));\n+    }\n+\n+    public Uni<?> findById(Class<?> entityClass, Object id, LockModeType lockModeType) {\n+        return getEntityManager().flatMap(em -> em.find(entityClass, id, LockModeConverter.convertToLockMode(lockModeType)));\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Object... params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        String findQuery = createFindQuery(entityClass, query, paramCount(params));\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        // FIXME: check for duplicate ORDER BY clause?\n+        if (isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            NamedQueryUtil.checkNamedQuery(entityClass, namedQuery);\n+            return createPanacheQuery(em, query, toOrderBy(sort), params);\n+        }\n+        return createPanacheQuery(em, findQuery, toOrderBy(sort), params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        String findQuery = createFindQuery(entityClass, query, paramCount(params));\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        // FIXME: check for duplicate ORDER BY clause?\n+        if (isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            NamedQueryUtil.checkNamedQuery(entityClass, namedQuery);\n+            return createPanacheQuery(em, query, toOrderBy(sort), params);\n+        }\n+        return createPanacheQuery(em, findQuery, toOrderBy(sort), params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Parameters params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return find(entityClass, query, sort, params.map());\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Object... params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Parameters params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Object... params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Parameters params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public PanacheQueryType findAll(Class<?> entityClass) {\n+        String query = \"FROM \" + getEntityName(entityClass);\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        return createPanacheQuery(em, query, null, null);\n+    }\n+\n+    public PanacheQueryType findAll(Class<?> entityClass, Sort sort) {\n+        String query = \"FROM \" + getEntityName(entityClass);\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        return createPanacheQuery(em, query, toOrderBy(sort), null);\n+    }\n+\n+    public Uni<List<?>> listAll(Class<?> entityClass) {\n+        return list(findAll(entityClass));\n+    }\n+\n+    public Uni<List<?>> listAll(Class<?> entityClass, Sort sort) {\n+        return list(findAll(entityClass, sort));\n+    }\n+\n+    public Multi<?> streamAll(Class<?> entityClass) {\n+        return stream(findAll(entityClass));\n+    }\n+\n+    public Multi<?> streamAll(Class<?> entityClass, Sort sort) {\n+        return stream(findAll(entityClass, sort));\n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public Uni<Long> count(Class<?> entityClass) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) em.createQuery(\"SELECT COUNT(*) FROM \" + getEntityName(entityClass)).getSingleResult());\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public Uni<Long> count(Class<?> entityClass, String query, Object... params) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) bindParameters(em.createQuery(createCountQuery(entityClass, query, paramCount(params))),\n+                        params).getSingleResult());\n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public Uni<Long> count(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) bindParameters(em.createQuery(createCountQuery(entityClass, query, paramCount(params))),\n+                        params).getSingleResult());\n+    }\n+\n+    public Uni<Long> count(Class<?> entityClass, String query, Parameters params) {\n+        return count(entityClass, query, params.map());\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass) {\n+        return count(entityClass).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Object... params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Parameters params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Long> deleteAll(Class<?> entityClass) {\n+        return getEntityManager().flatMap(em -> em.createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate()\n+                .map(i -> i.longValue()));\n+    }\n+\n+    public Uni<Boolean> deleteById(Class<?> entityClass, Object id) {\n+        // Impl note : we load the entity then delete it because it's the only implementation generic enough for any model,\n+        // and correct in all cases (composite key, graph of entities, ...). HQL cannot be directly used for these reasons.\n+        return findById(entityClass, id)\n+                .flatMap(entity -> {\n+                    if (entity == null) {\n+                        return Uni.createFrom().item(false);\n+                    }\n+                    return getEntityManager().flatMap(em -> em.remove(entity).map(v -> true));\n+                });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYxNjkyNg=="}, "originalCommit": {"oid": "32a3f43141080ba1504c0dbcfaf069954d0a69d5"}, "originalPosition": 436}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MTkxMzUzOnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNDozMToxMFrOG4PhMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNDozMDoxOVrOG9cJig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYyNzY5Ng==", "bodyText": "What about this:\n\t\treturn em.persist( entity ).onItem().ignore().andContinueWithNull();", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r461627696", "createdAt": "2020-07-28T14:31:10Z", "author": {"login": "DavideD"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32a3f43141080ba1504c0dbcfaf069954d0a69d5"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwMzc5Nw==", "bodyText": "+1 this is what reactive MongoDB panache uses", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462203797", "createdAt": "2020-07-29T10:36:47Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYyNzY5Ng=="}, "originalCommit": {"oid": "32a3f43141080ba1504c0dbcfaf069954d0a69d5"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0OTEzMA==", "bodyText": "Yeah, I've found the map(v -> null) to be a lot shorter and to the point. I'd rather keep this :)", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467049130", "createdAt": "2020-08-07T13:44:05Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYyNzY5Ng=="}, "originalCommit": {"oid": "32a3f43141080ba1504c0dbcfaf069954d0a69d5"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA3NzUxNA==", "bodyText": "I first use map(v -> null) than Clement said that .onItem().ignore().andContinueWithNull() is better, I don't remember why (maybe it provides the item to be emitted ...)", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467077514", "createdAt": "2020-08-07T14:30:19Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYyNzY5Ng=="}, "originalCommit": {"oid": "32a3f43141080ba1504c0dbcfaf069954d0a69d5"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NTQ0Nzg0OnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwOTo0MzozN1rOG4w26A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNDozMzo1NFrOG9cRyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3MzkyOA==", "bodyText": "See how I did in the MongoDB ReactivePanacheQueryImpl, I do cache the Uni count.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462173928", "createdAt": "2020-07-29T09:43:37Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA2NzM0NQ==", "bodyText": "Well, I also cache the Uni, but you don't cache its result. It could be cached or recreated every time.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467067345", "createdAt": "2020-08-07T14:14:07Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3MzkyOA=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA3OTYyNA==", "bodyText": "Hum, good point.\nThere is a cache method on Uni it should be use to avoid this.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467079624", "createdAt": "2020-08-07T14:33:54Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3MzkyOA=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NTQ1ODc3OnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwOTo0NjoyOVrOG4w9dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwOTo0NjoyOVrOG4w9dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NTYwNA==", "bodyText": "This is legacy code ;)\nThis was done like this in the first implementation of PanacheQuery, we already question this some times ago and decided to keep it I don't remember why ...\nBut default are no paging this is why there is the Hibernate related stuff right ,", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462175604", "createdAt": "2020-07-29T09:46:29Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here\n+                return applyFilters(em, () -> countQuery.getSingleResult());\n+            });\n+        }\n+        return count;\n+    }\n+\n+    private String countQuery() {\n+        if (countQuery != null) {\n+            return countQuery;\n+        }\n+\n+        // try to generate a good count query from the existing query\n+        Matcher selectMatcher = SELECT_PATTERN.matcher(query);\n+        String countQuery;\n+        if (selectMatcher.matches()) {\n+            // this one cannot be null\n+            String firstSelection = selectMatcher.group(1).trim();\n+            if (firstSelection.toLowerCase().startsWith(\"distinct \")) {\n+                // this one can be null\n+                String secondSelection = selectMatcher.group(2);\n+                // we can only count distinct single columns\n+                if (secondSelection != null && !secondSelection.trim().isEmpty()) {\n+                    throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+                }\n+                countQuery = \"SELECT COUNT(\" + firstSelection + \") \" + selectMatcher.group(3);\n+            } else {\n+                // it's not distinct, forget the column list\n+                countQuery = \"SELECT COUNT(*) \" + selectMatcher.group(3);\n+            }\n+        } else if (FROM_PATTERN.matcher(query).matches()) {\n+            countQuery = \"SELECT COUNT(*) \" + query;\n+        } else {\n+            throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+        }\n+\n+        // remove the order by clause\n+        String lcQuery = countQuery.toLowerCase();\n+        int orderByIndex = lcQuery.lastIndexOf(\" order by \");\n+        if (orderByIndex != -1) {\n+            countQuery = countQuery.substring(0, orderByIndex);\n+        }\n+        return countQuery;\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public <T extends Entity> Uni<List<T>> list() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return (Uni) applyFilters(em, () -> jpaQuery.getResultList());\n+        });\n+    }\n+\n+    public <T extends Entity> Multi<T> stream() {\n+        // FIXME: requires Hibernate support\n+        //        Mutiny.Query<?> jpaQuery = createQuery();\n+        //        return applyFilters(jpaQuery.getResultStream());\n+        Uni<List<T>> results = list();\n+        return (Multi<T>) results.toMulti().flatMap(list -> {\n+            return Multi.createFrom().iterable(list);\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> firstResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em, 1);\n+            return applyFilters(em, () -> jpaQuery.getResultList().map(list -> list.isEmpty() ? null : (T) list.get(0)));\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> singleResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return applyFilters(em, () -> jpaQuery.getSingleResult().map(v -> (T) v));\n+            // FIXME: workaround https://github.com/hibernate/hibernate-reactive/issues/263\n+        }).onFailure(CompletionException.class).apply(t -> t.getCause());\n+    }\n+\n+    private Mutiny.Query<?> createQuery(Mutiny.Session em) {\n+        Mutiny.Query<?> jpaQuery = createBaseQuery(em);\n+\n+        if (range != null) {\n+            jpaQuery.setFirstResult(range.getStartIndex());\n+            // range is 0 based, so we add 1\n+            jpaQuery.setMaxResults(range.getLastIndex() - range.getStartIndex() + 1);\n+        } else if (page != null) {\n+            jpaQuery.setFirstResult(page.index * page.size);\n+            jpaQuery.setMaxResults(page.size);\n+        } else {\n+            // Use deprecated API in org.hibernate.Query that will be moved to org.hibernate.query.Query on Hibernate 6.0\n+            // FIXME: requires Hibernate support\n+            //            @SuppressWarnings(\"deprecation\")\n+            //            RowSelection options = jpaQuery.unwrap(org.hibernate.query.Query.class).getQueryOptions();\n+            //            options.setFirstRow(null);\n+            //            options.setMaxRows(null);\n+            // FIXME: why would we even do that? those are the defaults, let's leave them blank", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 308}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NTQ2NTYzOnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwOTo0ODoyMlrOG4xBhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQwNzowODo0NVrOG94yYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NjY0NQ==", "bodyText": "If hint are not supported, better remove the withHint() method or make it throw an UnsupportedOperationException.\nIf they will be supported in a near future, opennning a followup issue may be a good idead", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462176645", "createdAt": "2020-07-29T09:48:22Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here\n+                return applyFilters(em, () -> countQuery.getSingleResult());\n+            });\n+        }\n+        return count;\n+    }\n+\n+    private String countQuery() {\n+        if (countQuery != null) {\n+            return countQuery;\n+        }\n+\n+        // try to generate a good count query from the existing query\n+        Matcher selectMatcher = SELECT_PATTERN.matcher(query);\n+        String countQuery;\n+        if (selectMatcher.matches()) {\n+            // this one cannot be null\n+            String firstSelection = selectMatcher.group(1).trim();\n+            if (firstSelection.toLowerCase().startsWith(\"distinct \")) {\n+                // this one can be null\n+                String secondSelection = selectMatcher.group(2);\n+                // we can only count distinct single columns\n+                if (secondSelection != null && !secondSelection.trim().isEmpty()) {\n+                    throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+                }\n+                countQuery = \"SELECT COUNT(\" + firstSelection + \") \" + selectMatcher.group(3);\n+            } else {\n+                // it's not distinct, forget the column list\n+                countQuery = \"SELECT COUNT(*) \" + selectMatcher.group(3);\n+            }\n+        } else if (FROM_PATTERN.matcher(query).matches()) {\n+            countQuery = \"SELECT COUNT(*) \" + query;\n+        } else {\n+            throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+        }\n+\n+        // remove the order by clause\n+        String lcQuery = countQuery.toLowerCase();\n+        int orderByIndex = lcQuery.lastIndexOf(\" order by \");\n+        if (orderByIndex != -1) {\n+            countQuery = countQuery.substring(0, orderByIndex);\n+        }\n+        return countQuery;\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public <T extends Entity> Uni<List<T>> list() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return (Uni) applyFilters(em, () -> jpaQuery.getResultList());\n+        });\n+    }\n+\n+    public <T extends Entity> Multi<T> stream() {\n+        // FIXME: requires Hibernate support\n+        //        Mutiny.Query<?> jpaQuery = createQuery();\n+        //        return applyFilters(jpaQuery.getResultStream());\n+        Uni<List<T>> results = list();\n+        return (Multi<T>) results.toMulti().flatMap(list -> {\n+            return Multi.createFrom().iterable(list);\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> firstResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em, 1);\n+            return applyFilters(em, () -> jpaQuery.getResultList().map(list -> list.isEmpty() ? null : (T) list.get(0)));\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> singleResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return applyFilters(em, () -> jpaQuery.getSingleResult().map(v -> (T) v));\n+            // FIXME: workaround https://github.com/hibernate/hibernate-reactive/issues/263\n+        }).onFailure(CompletionException.class).apply(t -> t.getCause());\n+    }\n+\n+    private Mutiny.Query<?> createQuery(Mutiny.Session em) {\n+        Mutiny.Query<?> jpaQuery = createBaseQuery(em);\n+\n+        if (range != null) {\n+            jpaQuery.setFirstResult(range.getStartIndex());\n+            // range is 0 based, so we add 1\n+            jpaQuery.setMaxResults(range.getLastIndex() - range.getStartIndex() + 1);\n+        } else if (page != null) {\n+            jpaQuery.setFirstResult(page.index * page.size);\n+            jpaQuery.setMaxResults(page.size);\n+        } else {\n+            // Use deprecated API in org.hibernate.Query that will be moved to org.hibernate.query.Query on Hibernate 6.0\n+            // FIXME: requires Hibernate support\n+            //            @SuppressWarnings(\"deprecation\")\n+            //            RowSelection options = jpaQuery.unwrap(org.hibernate.query.Query.class).getQueryOptions();\n+            //            options.setFirstRow(null);\n+            //            options.setMaxRows(null);\n+            // FIXME: why would we even do that? those are the defaults, let's leave them blank\n+            // if we don't, we get a LIMIT\n+            //            jpaQuery.setFirstResult(0);\n+            //            jpaQuery.setMaxResults(Integer.MAX_VALUE);\n+        }\n+\n+        return jpaQuery;\n+    }\n+\n+    private Mutiny.Query<?> createQuery(Mutiny.Session em, int maxResults) {\n+        Mutiny.Query<?> jpaQuery = createBaseQuery(em);\n+\n+        if (range != null) {\n+            jpaQuery.setFirstResult(range.getStartIndex());\n+        } else if (page != null) {\n+            jpaQuery.setFirstResult(page.index * page.size);\n+        } else {\n+            // Use deprecated API in org.hibernate.Query that will be moved to org.hibernate.query.Query on Hibernate 6.0\n+            // FIXME: requires Hibernate support\n+            //            @SuppressWarnings(\"deprecation\")\n+            //            RowSelection options = jpaQuery.unwrap(org.hibernate.query.Query.class).getQueryOptions();\n+            //            options.setFirstRow(null);\n+            jpaQuery.setFirstResult(0);\n+        }\n+        jpaQuery.setMaxResults(maxResults);\n+\n+        return jpaQuery;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Mutiny.Query<?> createBaseQuery(Mutiny.Session em) {\n+        Mutiny.Query<?> jpaQuery;\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            jpaQuery = em.createNamedQuery(namedQuery);\n+        } else {\n+            jpaQuery = em.createQuery(orderBy != null ? query + orderBy : query);\n+        }\n+\n+        if (paramsArrayOrMap instanceof Map) {\n+            AbstractJpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        } else {\n+            AbstractJpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+        }\n+\n+        if (this.lockModeType != null) {\n+            jpaQuery.setLockMode(LockModeConverter.convertToLockMode(lockModeType));\n+        }\n+\n+        if (hints != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk2NDg1OQ==", "bodyText": "Alternatively, we should consider simply not supporting hints at all in Panache. They're really there only to allow use of vendor-specific features via the JPA-standard APIs, but they're untypesafe and inconvenient.\nI would argue that it would be better if Panache offered typesafe APIs for Hibernate-specific features. As far as I understand, support for other JPA implementations is a non-goal.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r466964859", "createdAt": "2020-08-07T10:46:49Z", "author": {"login": "gavinking"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here\n+                return applyFilters(em, () -> countQuery.getSingleResult());\n+            });\n+        }\n+        return count;\n+    }\n+\n+    private String countQuery() {\n+        if (countQuery != null) {\n+            return countQuery;\n+        }\n+\n+        // try to generate a good count query from the existing query\n+        Matcher selectMatcher = SELECT_PATTERN.matcher(query);\n+        String countQuery;\n+        if (selectMatcher.matches()) {\n+            // this one cannot be null\n+            String firstSelection = selectMatcher.group(1).trim();\n+            if (firstSelection.toLowerCase().startsWith(\"distinct \")) {\n+                // this one can be null\n+                String secondSelection = selectMatcher.group(2);\n+                // we can only count distinct single columns\n+                if (secondSelection != null && !secondSelection.trim().isEmpty()) {\n+                    throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+                }\n+                countQuery = \"SELECT COUNT(\" + firstSelection + \") \" + selectMatcher.group(3);\n+            } else {\n+                // it's not distinct, forget the column list\n+                countQuery = \"SELECT COUNT(*) \" + selectMatcher.group(3);\n+            }\n+        } else if (FROM_PATTERN.matcher(query).matches()) {\n+            countQuery = \"SELECT COUNT(*) \" + query;\n+        } else {\n+            throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+        }\n+\n+        // remove the order by clause\n+        String lcQuery = countQuery.toLowerCase();\n+        int orderByIndex = lcQuery.lastIndexOf(\" order by \");\n+        if (orderByIndex != -1) {\n+            countQuery = countQuery.substring(0, orderByIndex);\n+        }\n+        return countQuery;\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public <T extends Entity> Uni<List<T>> list() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return (Uni) applyFilters(em, () -> jpaQuery.getResultList());\n+        });\n+    }\n+\n+    public <T extends Entity> Multi<T> stream() {\n+        // FIXME: requires Hibernate support\n+        //        Mutiny.Query<?> jpaQuery = createQuery();\n+        //        return applyFilters(jpaQuery.getResultStream());\n+        Uni<List<T>> results = list();\n+        return (Multi<T>) results.toMulti().flatMap(list -> {\n+            return Multi.createFrom().iterable(list);\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> firstResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em, 1);\n+            return applyFilters(em, () -> jpaQuery.getResultList().map(list -> list.isEmpty() ? null : (T) list.get(0)));\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> singleResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return applyFilters(em, () -> jpaQuery.getSingleResult().map(v -> (T) v));\n+            // FIXME: workaround https://github.com/hibernate/hibernate-reactive/issues/263\n+        }).onFailure(CompletionException.class).apply(t -> t.getCause());\n+    }\n+\n+    private Mutiny.Query<?> createQuery(Mutiny.Session em) {\n+        Mutiny.Query<?> jpaQuery = createBaseQuery(em);\n+\n+        if (range != null) {\n+            jpaQuery.setFirstResult(range.getStartIndex());\n+            // range is 0 based, so we add 1\n+            jpaQuery.setMaxResults(range.getLastIndex() - range.getStartIndex() + 1);\n+        } else if (page != null) {\n+            jpaQuery.setFirstResult(page.index * page.size);\n+            jpaQuery.setMaxResults(page.size);\n+        } else {\n+            // Use deprecated API in org.hibernate.Query that will be moved to org.hibernate.query.Query on Hibernate 6.0\n+            // FIXME: requires Hibernate support\n+            //            @SuppressWarnings(\"deprecation\")\n+            //            RowSelection options = jpaQuery.unwrap(org.hibernate.query.Query.class).getQueryOptions();\n+            //            options.setFirstRow(null);\n+            //            options.setMaxRows(null);\n+            // FIXME: why would we even do that? those are the defaults, let's leave them blank\n+            // if we don't, we get a LIMIT\n+            //            jpaQuery.setFirstResult(0);\n+            //            jpaQuery.setMaxResults(Integer.MAX_VALUE);\n+        }\n+\n+        return jpaQuery;\n+    }\n+\n+    private Mutiny.Query<?> createQuery(Mutiny.Session em, int maxResults) {\n+        Mutiny.Query<?> jpaQuery = createBaseQuery(em);\n+\n+        if (range != null) {\n+            jpaQuery.setFirstResult(range.getStartIndex());\n+        } else if (page != null) {\n+            jpaQuery.setFirstResult(page.index * page.size);\n+        } else {\n+            // Use deprecated API in org.hibernate.Query that will be moved to org.hibernate.query.Query on Hibernate 6.0\n+            // FIXME: requires Hibernate support\n+            //            @SuppressWarnings(\"deprecation\")\n+            //            RowSelection options = jpaQuery.unwrap(org.hibernate.query.Query.class).getQueryOptions();\n+            //            options.setFirstRow(null);\n+            jpaQuery.setFirstResult(0);\n+        }\n+        jpaQuery.setMaxResults(maxResults);\n+\n+        return jpaQuery;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Mutiny.Query<?> createBaseQuery(Mutiny.Session em) {\n+        Mutiny.Query<?> jpaQuery;\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            jpaQuery = em.createNamedQuery(namedQuery);\n+        } else {\n+            jpaQuery = em.createQuery(orderBy != null ? query + orderBy : query);\n+        }\n+\n+        if (paramsArrayOrMap instanceof Map) {\n+            AbstractJpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        } else {\n+            AbstractJpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+        }\n+\n+        if (this.lockModeType != null) {\n+            jpaQuery.setLockMode(LockModeConverter.convertToLockMode(lockModeType));\n+        }\n+\n+        if (hints != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NjY0NQ=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA2ODkwOA==", "bodyText": "They will be, let's throw.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467068908", "createdAt": "2020-08-07T14:16:37Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here\n+                return applyFilters(em, () -> countQuery.getSingleResult());\n+            });\n+        }\n+        return count;\n+    }\n+\n+    private String countQuery() {\n+        if (countQuery != null) {\n+            return countQuery;\n+        }\n+\n+        // try to generate a good count query from the existing query\n+        Matcher selectMatcher = SELECT_PATTERN.matcher(query);\n+        String countQuery;\n+        if (selectMatcher.matches()) {\n+            // this one cannot be null\n+            String firstSelection = selectMatcher.group(1).trim();\n+            if (firstSelection.toLowerCase().startsWith(\"distinct \")) {\n+                // this one can be null\n+                String secondSelection = selectMatcher.group(2);\n+                // we can only count distinct single columns\n+                if (secondSelection != null && !secondSelection.trim().isEmpty()) {\n+                    throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+                }\n+                countQuery = \"SELECT COUNT(\" + firstSelection + \") \" + selectMatcher.group(3);\n+            } else {\n+                // it's not distinct, forget the column list\n+                countQuery = \"SELECT COUNT(*) \" + selectMatcher.group(3);\n+            }\n+        } else if (FROM_PATTERN.matcher(query).matches()) {\n+            countQuery = \"SELECT COUNT(*) \" + query;\n+        } else {\n+            throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+        }\n+\n+        // remove the order by clause\n+        String lcQuery = countQuery.toLowerCase();\n+        int orderByIndex = lcQuery.lastIndexOf(\" order by \");\n+        if (orderByIndex != -1) {\n+            countQuery = countQuery.substring(0, orderByIndex);\n+        }\n+        return countQuery;\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public <T extends Entity> Uni<List<T>> list() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return (Uni) applyFilters(em, () -> jpaQuery.getResultList());\n+        });\n+    }\n+\n+    public <T extends Entity> Multi<T> stream() {\n+        // FIXME: requires Hibernate support\n+        //        Mutiny.Query<?> jpaQuery = createQuery();\n+        //        return applyFilters(jpaQuery.getResultStream());\n+        Uni<List<T>> results = list();\n+        return (Multi<T>) results.toMulti().flatMap(list -> {\n+            return Multi.createFrom().iterable(list);\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> firstResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em, 1);\n+            return applyFilters(em, () -> jpaQuery.getResultList().map(list -> list.isEmpty() ? null : (T) list.get(0)));\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> singleResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return applyFilters(em, () -> jpaQuery.getSingleResult().map(v -> (T) v));\n+            // FIXME: workaround https://github.com/hibernate/hibernate-reactive/issues/263\n+        }).onFailure(CompletionException.class).apply(t -> t.getCause());\n+    }\n+\n+    private Mutiny.Query<?> createQuery(Mutiny.Session em) {\n+        Mutiny.Query<?> jpaQuery = createBaseQuery(em);\n+\n+        if (range != null) {\n+            jpaQuery.setFirstResult(range.getStartIndex());\n+            // range is 0 based, so we add 1\n+            jpaQuery.setMaxResults(range.getLastIndex() - range.getStartIndex() + 1);\n+        } else if (page != null) {\n+            jpaQuery.setFirstResult(page.index * page.size);\n+            jpaQuery.setMaxResults(page.size);\n+        } else {\n+            // Use deprecated API in org.hibernate.Query that will be moved to org.hibernate.query.Query on Hibernate 6.0\n+            // FIXME: requires Hibernate support\n+            //            @SuppressWarnings(\"deprecation\")\n+            //            RowSelection options = jpaQuery.unwrap(org.hibernate.query.Query.class).getQueryOptions();\n+            //            options.setFirstRow(null);\n+            //            options.setMaxRows(null);\n+            // FIXME: why would we even do that? those are the defaults, let's leave them blank\n+            // if we don't, we get a LIMIT\n+            //            jpaQuery.setFirstResult(0);\n+            //            jpaQuery.setMaxResults(Integer.MAX_VALUE);\n+        }\n+\n+        return jpaQuery;\n+    }\n+\n+    private Mutiny.Query<?> createQuery(Mutiny.Session em, int maxResults) {\n+        Mutiny.Query<?> jpaQuery = createBaseQuery(em);\n+\n+        if (range != null) {\n+            jpaQuery.setFirstResult(range.getStartIndex());\n+        } else if (page != null) {\n+            jpaQuery.setFirstResult(page.index * page.size);\n+        } else {\n+            // Use deprecated API in org.hibernate.Query that will be moved to org.hibernate.query.Query on Hibernate 6.0\n+            // FIXME: requires Hibernate support\n+            //            @SuppressWarnings(\"deprecation\")\n+            //            RowSelection options = jpaQuery.unwrap(org.hibernate.query.Query.class).getQueryOptions();\n+            //            options.setFirstRow(null);\n+            jpaQuery.setFirstResult(0);\n+        }\n+        jpaQuery.setMaxResults(maxResults);\n+\n+        return jpaQuery;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Mutiny.Query<?> createBaseQuery(Mutiny.Session em) {\n+        Mutiny.Query<?> jpaQuery;\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            jpaQuery = em.createNamedQuery(namedQuery);\n+        } else {\n+            jpaQuery = em.createQuery(orderBy != null ? query + orderBy : query);\n+        }\n+\n+        if (paramsArrayOrMap instanceof Map) {\n+            AbstractJpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        } else {\n+            AbstractJpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+        }\n+\n+        if (this.lockModeType != null) {\n+            jpaQuery.setLockMode(LockModeConverter.convertToLockMode(lockModeType));\n+        }\n+\n+        if (hints != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NjY0NQ=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA4MzE2MA==", "bodyText": "They will be, let's throw.\n\nSeriously? you're going to make, say, Eclipselink work in Quarkus?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467083160", "createdAt": "2020-08-07T14:39:42Z", "author": {"login": "gavinking"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here\n+                return applyFilters(em, () -> countQuery.getSingleResult());\n+            });\n+        }\n+        return count;\n+    }\n+\n+    private String countQuery() {\n+        if (countQuery != null) {\n+            return countQuery;\n+        }\n+\n+        // try to generate a good count query from the existing query\n+        Matcher selectMatcher = SELECT_PATTERN.matcher(query);\n+        String countQuery;\n+        if (selectMatcher.matches()) {\n+            // this one cannot be null\n+            String firstSelection = selectMatcher.group(1).trim();\n+            if (firstSelection.toLowerCase().startsWith(\"distinct \")) {\n+                // this one can be null\n+                String secondSelection = selectMatcher.group(2);\n+                // we can only count distinct single columns\n+                if (secondSelection != null && !secondSelection.trim().isEmpty()) {\n+                    throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+                }\n+                countQuery = \"SELECT COUNT(\" + firstSelection + \") \" + selectMatcher.group(3);\n+            } else {\n+                // it's not distinct, forget the column list\n+                countQuery = \"SELECT COUNT(*) \" + selectMatcher.group(3);\n+            }\n+        } else if (FROM_PATTERN.matcher(query).matches()) {\n+            countQuery = \"SELECT COUNT(*) \" + query;\n+        } else {\n+            throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+        }\n+\n+        // remove the order by clause\n+        String lcQuery = countQuery.toLowerCase();\n+        int orderByIndex = lcQuery.lastIndexOf(\" order by \");\n+        if (orderByIndex != -1) {\n+            countQuery = countQuery.substring(0, orderByIndex);\n+        }\n+        return countQuery;\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public <T extends Entity> Uni<List<T>> list() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return (Uni) applyFilters(em, () -> jpaQuery.getResultList());\n+        });\n+    }\n+\n+    public <T extends Entity> Multi<T> stream() {\n+        // FIXME: requires Hibernate support\n+        //        Mutiny.Query<?> jpaQuery = createQuery();\n+        //        return applyFilters(jpaQuery.getResultStream());\n+        Uni<List<T>> results = list();\n+        return (Multi<T>) results.toMulti().flatMap(list -> {\n+            return Multi.createFrom().iterable(list);\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> firstResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em, 1);\n+            return applyFilters(em, () -> jpaQuery.getResultList().map(list -> list.isEmpty() ? null : (T) list.get(0)));\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> singleResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return applyFilters(em, () -> jpaQuery.getSingleResult().map(v -> (T) v));\n+            // FIXME: workaround https://github.com/hibernate/hibernate-reactive/issues/263\n+        }).onFailure(CompletionException.class).apply(t -> t.getCause());\n+    }\n+\n+    private Mutiny.Query<?> createQuery(Mutiny.Session em) {\n+        Mutiny.Query<?> jpaQuery = createBaseQuery(em);\n+\n+        if (range != null) {\n+            jpaQuery.setFirstResult(range.getStartIndex());\n+            // range is 0 based, so we add 1\n+            jpaQuery.setMaxResults(range.getLastIndex() - range.getStartIndex() + 1);\n+        } else if (page != null) {\n+            jpaQuery.setFirstResult(page.index * page.size);\n+            jpaQuery.setMaxResults(page.size);\n+        } else {\n+            // Use deprecated API in org.hibernate.Query that will be moved to org.hibernate.query.Query on Hibernate 6.0\n+            // FIXME: requires Hibernate support\n+            //            @SuppressWarnings(\"deprecation\")\n+            //            RowSelection options = jpaQuery.unwrap(org.hibernate.query.Query.class).getQueryOptions();\n+            //            options.setFirstRow(null);\n+            //            options.setMaxRows(null);\n+            // FIXME: why would we even do that? those are the defaults, let's leave them blank\n+            // if we don't, we get a LIMIT\n+            //            jpaQuery.setFirstResult(0);\n+            //            jpaQuery.setMaxResults(Integer.MAX_VALUE);\n+        }\n+\n+        return jpaQuery;\n+    }\n+\n+    private Mutiny.Query<?> createQuery(Mutiny.Session em, int maxResults) {\n+        Mutiny.Query<?> jpaQuery = createBaseQuery(em);\n+\n+        if (range != null) {\n+            jpaQuery.setFirstResult(range.getStartIndex());\n+        } else if (page != null) {\n+            jpaQuery.setFirstResult(page.index * page.size);\n+        } else {\n+            // Use deprecated API in org.hibernate.Query that will be moved to org.hibernate.query.Query on Hibernate 6.0\n+            // FIXME: requires Hibernate support\n+            //            @SuppressWarnings(\"deprecation\")\n+            //            RowSelection options = jpaQuery.unwrap(org.hibernate.query.Query.class).getQueryOptions();\n+            //            options.setFirstRow(null);\n+            jpaQuery.setFirstResult(0);\n+        }\n+        jpaQuery.setMaxResults(maxResults);\n+\n+        return jpaQuery;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Mutiny.Query<?> createBaseQuery(Mutiny.Session em) {\n+        Mutiny.Query<?> jpaQuery;\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            jpaQuery = em.createNamedQuery(namedQuery);\n+        } else {\n+            jpaQuery = em.createQuery(orderBy != null ? query + orderBy : query);\n+        }\n+\n+        if (paramsArrayOrMap instanceof Map) {\n+            AbstractJpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        } else {\n+            AbstractJpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+        }\n+\n+        if (this.lockModeType != null) {\n+            jpaQuery.setLockMode(LockModeConverter.convertToLockMode(lockModeType));\n+        }\n+\n+        if (hints != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NjY0NQ=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA5NzM3Ng==", "bodyText": "No, I meant hints will be supported, because I thought they would (and github didn't show me your answer at the time, so I was replying to Lo\u00efc).\nI don't mind if we replace hint support if you tell me HR will not support them.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467097376", "createdAt": "2020-08-07T15:03:15Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here\n+                return applyFilters(em, () -> countQuery.getSingleResult());\n+            });\n+        }\n+        return count;\n+    }\n+\n+    private String countQuery() {\n+        if (countQuery != null) {\n+            return countQuery;\n+        }\n+\n+        // try to generate a good count query from the existing query\n+        Matcher selectMatcher = SELECT_PATTERN.matcher(query);\n+        String countQuery;\n+        if (selectMatcher.matches()) {\n+            // this one cannot be null\n+            String firstSelection = selectMatcher.group(1).trim();\n+            if (firstSelection.toLowerCase().startsWith(\"distinct \")) {\n+                // this one can be null\n+                String secondSelection = selectMatcher.group(2);\n+                // we can only count distinct single columns\n+                if (secondSelection != null && !secondSelection.trim().isEmpty()) {\n+                    throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+                }\n+                countQuery = \"SELECT COUNT(\" + firstSelection + \") \" + selectMatcher.group(3);\n+            } else {\n+                // it's not distinct, forget the column list\n+                countQuery = \"SELECT COUNT(*) \" + selectMatcher.group(3);\n+            }\n+        } else if (FROM_PATTERN.matcher(query).matches()) {\n+            countQuery = \"SELECT COUNT(*) \" + query;\n+        } else {\n+            throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+        }\n+\n+        // remove the order by clause\n+        String lcQuery = countQuery.toLowerCase();\n+        int orderByIndex = lcQuery.lastIndexOf(\" order by \");\n+        if (orderByIndex != -1) {\n+            countQuery = countQuery.substring(0, orderByIndex);\n+        }\n+        return countQuery;\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public <T extends Entity> Uni<List<T>> list() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return (Uni) applyFilters(em, () -> jpaQuery.getResultList());\n+        });\n+    }\n+\n+    public <T extends Entity> Multi<T> stream() {\n+        // FIXME: requires Hibernate support\n+        //        Mutiny.Query<?> jpaQuery = createQuery();\n+        //        return applyFilters(jpaQuery.getResultStream());\n+        Uni<List<T>> results = list();\n+        return (Multi<T>) results.toMulti().flatMap(list -> {\n+            return Multi.createFrom().iterable(list);\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> firstResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em, 1);\n+            return applyFilters(em, () -> jpaQuery.getResultList().map(list -> list.isEmpty() ? null : (T) list.get(0)));\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> singleResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return applyFilters(em, () -> jpaQuery.getSingleResult().map(v -> (T) v));\n+            // FIXME: workaround https://github.com/hibernate/hibernate-reactive/issues/263\n+        }).onFailure(CompletionException.class).apply(t -> t.getCause());\n+    }\n+\n+    private Mutiny.Query<?> createQuery(Mutiny.Session em) {\n+        Mutiny.Query<?> jpaQuery = createBaseQuery(em);\n+\n+        if (range != null) {\n+            jpaQuery.setFirstResult(range.getStartIndex());\n+            // range is 0 based, so we add 1\n+            jpaQuery.setMaxResults(range.getLastIndex() - range.getStartIndex() + 1);\n+        } else if (page != null) {\n+            jpaQuery.setFirstResult(page.index * page.size);\n+            jpaQuery.setMaxResults(page.size);\n+        } else {\n+            // Use deprecated API in org.hibernate.Query that will be moved to org.hibernate.query.Query on Hibernate 6.0\n+            // FIXME: requires Hibernate support\n+            //            @SuppressWarnings(\"deprecation\")\n+            //            RowSelection options = jpaQuery.unwrap(org.hibernate.query.Query.class).getQueryOptions();\n+            //            options.setFirstRow(null);\n+            //            options.setMaxRows(null);\n+            // FIXME: why would we even do that? those are the defaults, let's leave them blank\n+            // if we don't, we get a LIMIT\n+            //            jpaQuery.setFirstResult(0);\n+            //            jpaQuery.setMaxResults(Integer.MAX_VALUE);\n+        }\n+\n+        return jpaQuery;\n+    }\n+\n+    private Mutiny.Query<?> createQuery(Mutiny.Session em, int maxResults) {\n+        Mutiny.Query<?> jpaQuery = createBaseQuery(em);\n+\n+        if (range != null) {\n+            jpaQuery.setFirstResult(range.getStartIndex());\n+        } else if (page != null) {\n+            jpaQuery.setFirstResult(page.index * page.size);\n+        } else {\n+            // Use deprecated API in org.hibernate.Query that will be moved to org.hibernate.query.Query on Hibernate 6.0\n+            // FIXME: requires Hibernate support\n+            //            @SuppressWarnings(\"deprecation\")\n+            //            RowSelection options = jpaQuery.unwrap(org.hibernate.query.Query.class).getQueryOptions();\n+            //            options.setFirstRow(null);\n+            jpaQuery.setFirstResult(0);\n+        }\n+        jpaQuery.setMaxResults(maxResults);\n+\n+        return jpaQuery;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Mutiny.Query<?> createBaseQuery(Mutiny.Session em) {\n+        Mutiny.Query<?> jpaQuery;\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            jpaQuery = em.createNamedQuery(namedQuery);\n+        } else {\n+            jpaQuery = em.createQuery(orderBy != null ? query + orderBy : query);\n+        }\n+\n+        if (paramsArrayOrMap instanceof Map) {\n+            AbstractJpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        } else {\n+            AbstractJpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+        }\n+\n+        if (this.lockModeType != null) {\n+            jpaQuery.setLockMode(LockModeConverter.convertToLockMode(lockModeType));\n+        }\n+\n+        if (hints != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NjY0NQ=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU0NDY3MA==", "bodyText": "I'd love to fully eradicate support for hints from ORM, and have a proper API instead.\nOf course we can't because of specs, but we could introduce an internal configurtion setting to at least ignore them for Hibernate Reactive (and maybe even for ORM classic when within Quarkus).\nBeyond API benefits of more explicit options, dealing with them is also highl inefficient.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467544670", "createdAt": "2020-08-09T06:44:52Z", "author": {"login": "Sanne"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here\n+                return applyFilters(em, () -> countQuery.getSingleResult());\n+            });\n+        }\n+        return count;\n+    }\n+\n+    private String countQuery() {\n+        if (countQuery != null) {\n+            return countQuery;\n+        }\n+\n+        // try to generate a good count query from the existing query\n+        Matcher selectMatcher = SELECT_PATTERN.matcher(query);\n+        String countQuery;\n+        if (selectMatcher.matches()) {\n+            // this one cannot be null\n+            String firstSelection = selectMatcher.group(1).trim();\n+            if (firstSelection.toLowerCase().startsWith(\"distinct \")) {\n+                // this one can be null\n+                String secondSelection = selectMatcher.group(2);\n+                // we can only count distinct single columns\n+                if (secondSelection != null && !secondSelection.trim().isEmpty()) {\n+                    throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+                }\n+                countQuery = \"SELECT COUNT(\" + firstSelection + \") \" + selectMatcher.group(3);\n+            } else {\n+                // it's not distinct, forget the column list\n+                countQuery = \"SELECT COUNT(*) \" + selectMatcher.group(3);\n+            }\n+        } else if (FROM_PATTERN.matcher(query).matches()) {\n+            countQuery = \"SELECT COUNT(*) \" + query;\n+        } else {\n+            throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+        }\n+\n+        // remove the order by clause\n+        String lcQuery = countQuery.toLowerCase();\n+        int orderByIndex = lcQuery.lastIndexOf(\" order by \");\n+        if (orderByIndex != -1) {\n+            countQuery = countQuery.substring(0, orderByIndex);\n+        }\n+        return countQuery;\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public <T extends Entity> Uni<List<T>> list() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return (Uni) applyFilters(em, () -> jpaQuery.getResultList());\n+        });\n+    }\n+\n+    public <T extends Entity> Multi<T> stream() {\n+        // FIXME: requires Hibernate support\n+        //        Mutiny.Query<?> jpaQuery = createQuery();\n+        //        return applyFilters(jpaQuery.getResultStream());\n+        Uni<List<T>> results = list();\n+        return (Multi<T>) results.toMulti().flatMap(list -> {\n+            return Multi.createFrom().iterable(list);\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> firstResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em, 1);\n+            return applyFilters(em, () -> jpaQuery.getResultList().map(list -> list.isEmpty() ? null : (T) list.get(0)));\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> singleResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return applyFilters(em, () -> jpaQuery.getSingleResult().map(v -> (T) v));\n+            // FIXME: workaround https://github.com/hibernate/hibernate-reactive/issues/263\n+        }).onFailure(CompletionException.class).apply(t -> t.getCause());\n+    }\n+\n+    private Mutiny.Query<?> createQuery(Mutiny.Session em) {\n+        Mutiny.Query<?> jpaQuery = createBaseQuery(em);\n+\n+        if (range != null) {\n+            jpaQuery.setFirstResult(range.getStartIndex());\n+            // range is 0 based, so we add 1\n+            jpaQuery.setMaxResults(range.getLastIndex() - range.getStartIndex() + 1);\n+        } else if (page != null) {\n+            jpaQuery.setFirstResult(page.index * page.size);\n+            jpaQuery.setMaxResults(page.size);\n+        } else {\n+            // Use deprecated API in org.hibernate.Query that will be moved to org.hibernate.query.Query on Hibernate 6.0\n+            // FIXME: requires Hibernate support\n+            //            @SuppressWarnings(\"deprecation\")\n+            //            RowSelection options = jpaQuery.unwrap(org.hibernate.query.Query.class).getQueryOptions();\n+            //            options.setFirstRow(null);\n+            //            options.setMaxRows(null);\n+            // FIXME: why would we even do that? those are the defaults, let's leave them blank\n+            // if we don't, we get a LIMIT\n+            //            jpaQuery.setFirstResult(0);\n+            //            jpaQuery.setMaxResults(Integer.MAX_VALUE);\n+        }\n+\n+        return jpaQuery;\n+    }\n+\n+    private Mutiny.Query<?> createQuery(Mutiny.Session em, int maxResults) {\n+        Mutiny.Query<?> jpaQuery = createBaseQuery(em);\n+\n+        if (range != null) {\n+            jpaQuery.setFirstResult(range.getStartIndex());\n+        } else if (page != null) {\n+            jpaQuery.setFirstResult(page.index * page.size);\n+        } else {\n+            // Use deprecated API in org.hibernate.Query that will be moved to org.hibernate.query.Query on Hibernate 6.0\n+            // FIXME: requires Hibernate support\n+            //            @SuppressWarnings(\"deprecation\")\n+            //            RowSelection options = jpaQuery.unwrap(org.hibernate.query.Query.class).getQueryOptions();\n+            //            options.setFirstRow(null);\n+            jpaQuery.setFirstResult(0);\n+        }\n+        jpaQuery.setMaxResults(maxResults);\n+\n+        return jpaQuery;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Mutiny.Query<?> createBaseQuery(Mutiny.Session em) {\n+        Mutiny.Query<?> jpaQuery;\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            jpaQuery = em.createNamedQuery(namedQuery);\n+        } else {\n+            jpaQuery = em.createQuery(orderBy != null ? query + orderBy : query);\n+        }\n+\n+        if (paramsArrayOrMap instanceof Map) {\n+            AbstractJpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        } else {\n+            AbstractJpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+        }\n+\n+        if (this.lockModeType != null) {\n+            jpaQuery.setLockMode(LockModeConverter.convertToLockMode(lockModeType));\n+        }\n+\n+        if (hints != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NjY0NQ=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU0NjcyMA==", "bodyText": "I don't mind if we replace hint support if you tell me HR will not support them.\n\nYeah but I'm advocating removing them from the regular (non-reactive) API as well. Or rather, representing the specific hints that Hibernate supports in a type safe way, just like what I've done in certain specific cases in the HR API.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467546720", "createdAt": "2020-08-09T07:08:45Z", "author": {"login": "gavinking"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni\n+        if (page == null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+        if (range != null) {\n+            throw new UnsupportedOperationException(\"Cannot call a page related method in a ranged query, \" +\n+                    \"call page(Page) or page(int, int) to initiate pagination first\");\n+        }\n+    }\n+\n+    public void range(int startIndex, int lastIndex) {\n+        this.range = Range.of(startIndex, lastIndex);\n+        // reset the page to its default to be able to switch from page to range\n+        this.page = null;\n+    }\n+\n+    public void withLock(LockModeType lockModeType) {\n+        this.lockModeType = lockModeType;\n+    }\n+\n+    public void withHint(String hintName, Object value) {\n+        if (hints == null) {\n+            hints = new HashMap<>();\n+        }\n+        hints.put(hintName, value);\n+    }\n+\n+    // Results\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Uni<Long> count() {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a count operation on a named query\");\n+        }\n+\n+        if (count == null) {\n+            count = em.flatMap(em -> {\n+                Mutiny.Query<Long> countQuery = em.createQuery(countQuery());\n+                if (paramsArrayOrMap instanceof Map)\n+                    AbstractJpaOperations.bindParameters(countQuery, (Map<String, Object>) paramsArrayOrMap);\n+                else\n+                    AbstractJpaOperations.bindParameters(countQuery, (Object[]) paramsArrayOrMap);\n+                // FIXME: question about caching the result here\n+                return applyFilters(em, () -> countQuery.getSingleResult());\n+            });\n+        }\n+        return count;\n+    }\n+\n+    private String countQuery() {\n+        if (countQuery != null) {\n+            return countQuery;\n+        }\n+\n+        // try to generate a good count query from the existing query\n+        Matcher selectMatcher = SELECT_PATTERN.matcher(query);\n+        String countQuery;\n+        if (selectMatcher.matches()) {\n+            // this one cannot be null\n+            String firstSelection = selectMatcher.group(1).trim();\n+            if (firstSelection.toLowerCase().startsWith(\"distinct \")) {\n+                // this one can be null\n+                String secondSelection = selectMatcher.group(2);\n+                // we can only count distinct single columns\n+                if (secondSelection != null && !secondSelection.trim().isEmpty()) {\n+                    throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+                }\n+                countQuery = \"SELECT COUNT(\" + firstSelection + \") \" + selectMatcher.group(3);\n+            } else {\n+                // it's not distinct, forget the column list\n+                countQuery = \"SELECT COUNT(*) \" + selectMatcher.group(3);\n+            }\n+        } else if (FROM_PATTERN.matcher(query).matches()) {\n+            countQuery = \"SELECT COUNT(*) \" + query;\n+        } else {\n+            throw new PanacheQueryException(\"Count query not supported for select query: \" + query);\n+        }\n+\n+        // remove the order by clause\n+        String lcQuery = countQuery.toLowerCase();\n+        int orderByIndex = lcQuery.lastIndexOf(\" order by \");\n+        if (orderByIndex != -1) {\n+            countQuery = countQuery.substring(0, orderByIndex);\n+        }\n+        return countQuery;\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public <T extends Entity> Uni<List<T>> list() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return (Uni) applyFilters(em, () -> jpaQuery.getResultList());\n+        });\n+    }\n+\n+    public <T extends Entity> Multi<T> stream() {\n+        // FIXME: requires Hibernate support\n+        //        Mutiny.Query<?> jpaQuery = createQuery();\n+        //        return applyFilters(jpaQuery.getResultStream());\n+        Uni<List<T>> results = list();\n+        return (Multi<T>) results.toMulti().flatMap(list -> {\n+            return Multi.createFrom().iterable(list);\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> firstResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em, 1);\n+            return applyFilters(em, () -> jpaQuery.getResultList().map(list -> list.isEmpty() ? null : (T) list.get(0)));\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Entity> Uni<T> singleResult() {\n+        return em.flatMap(em -> {\n+            Mutiny.Query<?> jpaQuery = createQuery(em);\n+            return applyFilters(em, () -> jpaQuery.getSingleResult().map(v -> (T) v));\n+            // FIXME: workaround https://github.com/hibernate/hibernate-reactive/issues/263\n+        }).onFailure(CompletionException.class).apply(t -> t.getCause());\n+    }\n+\n+    private Mutiny.Query<?> createQuery(Mutiny.Session em) {\n+        Mutiny.Query<?> jpaQuery = createBaseQuery(em);\n+\n+        if (range != null) {\n+            jpaQuery.setFirstResult(range.getStartIndex());\n+            // range is 0 based, so we add 1\n+            jpaQuery.setMaxResults(range.getLastIndex() - range.getStartIndex() + 1);\n+        } else if (page != null) {\n+            jpaQuery.setFirstResult(page.index * page.size);\n+            jpaQuery.setMaxResults(page.size);\n+        } else {\n+            // Use deprecated API in org.hibernate.Query that will be moved to org.hibernate.query.Query on Hibernate 6.0\n+            // FIXME: requires Hibernate support\n+            //            @SuppressWarnings(\"deprecation\")\n+            //            RowSelection options = jpaQuery.unwrap(org.hibernate.query.Query.class).getQueryOptions();\n+            //            options.setFirstRow(null);\n+            //            options.setMaxRows(null);\n+            // FIXME: why would we even do that? those are the defaults, let's leave them blank\n+            // if we don't, we get a LIMIT\n+            //            jpaQuery.setFirstResult(0);\n+            //            jpaQuery.setMaxResults(Integer.MAX_VALUE);\n+        }\n+\n+        return jpaQuery;\n+    }\n+\n+    private Mutiny.Query<?> createQuery(Mutiny.Session em, int maxResults) {\n+        Mutiny.Query<?> jpaQuery = createBaseQuery(em);\n+\n+        if (range != null) {\n+            jpaQuery.setFirstResult(range.getStartIndex());\n+        } else if (page != null) {\n+            jpaQuery.setFirstResult(page.index * page.size);\n+        } else {\n+            // Use deprecated API in org.hibernate.Query that will be moved to org.hibernate.query.Query on Hibernate 6.0\n+            // FIXME: requires Hibernate support\n+            //            @SuppressWarnings(\"deprecation\")\n+            //            RowSelection options = jpaQuery.unwrap(org.hibernate.query.Query.class).getQueryOptions();\n+            //            options.setFirstRow(null);\n+            jpaQuery.setFirstResult(0);\n+        }\n+        jpaQuery.setMaxResults(maxResults);\n+\n+        return jpaQuery;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Mutiny.Query<?> createBaseQuery(Mutiny.Session em) {\n+        Mutiny.Query<?> jpaQuery;\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            jpaQuery = em.createNamedQuery(namedQuery);\n+        } else {\n+            jpaQuery = em.createQuery(orderBy != null ? query + orderBy : query);\n+        }\n+\n+        if (paramsArrayOrMap instanceof Map) {\n+            AbstractJpaOperations.bindParameters(jpaQuery, (Map<String, Object>) paramsArrayOrMap);\n+        } else {\n+            AbstractJpaOperations.bindParameters(jpaQuery, (Object[]) paramsArrayOrMap);\n+        }\n+\n+        if (this.lockModeType != null) {\n+            jpaQuery.setLockMode(LockModeConverter.convertToLockMode(lockModeType));\n+        }\n+\n+        if (hints != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NjY0NQ=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 357}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NTQ4MjE0OnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwOTo1MjoyN1rOG4xLcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNDozNjo0OVrOG9cYfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3OTE4Nw==", "bodyText": "In the MongoDB reactive version I do keep this code imperative for the sake of simplicity.\nI think that as long as there is no IO operations, such very quick code can stay imperative but maybe I'm wrong.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462179187", "createdAt": "2020-07-29T09:52:27Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA2OTI3OA==", "bodyText": "Well, it also means we throw in situations where it'd be better to return a failed uni.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467069278", "createdAt": "2020-08-07T14:17:14Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3OTE4Nw=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA4MTM0MQ==", "bodyText": "Hum, in fact I did it this way because ... you did it this way in your first implementation of Panache Rx so do as you want I'll update the MongoDB part later if needed ;)\nI agree that you don't expect reactive code to throw, but this particular case is a developement error (like a NPE) so I think you can throw", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467081341", "createdAt": "2020-08-07T14:36:49Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?\n+    //    public void lastPage() {\n+    //        checkPagination();\n+    //        page(page.index(pageCount() - 1));\n+    //    }\n+\n+    public Uni<Boolean> hasNextPage() {\n+        checkPagination();\n+        return pageCount().map(pageCount -> page.index < (pageCount - 1));\n+    }\n+\n+    public boolean hasPreviousPage() {\n+        checkPagination();\n+        return page.index > 0;\n+    }\n+\n+    public Uni<Integer> pageCount() {\n+        checkPagination();\n+        return count().map(count -> {\n+            if (count == 0)\n+                return 1; // a single page of zero results\n+            return (int) Math.ceil((double) count / (double) page.size);\n+        });\n+    }\n+\n+    public Page page() {\n+        checkPagination();\n+        return page;\n+    }\n+\n+    private void checkPagination() {\n+        // FIXME: turn into Uni", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3OTE4Nw=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NTQ5NDkxOnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwOTo1NTo0N1rOG4xTOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNDoyMTozOFrOG9bz5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4MTE3OQ==", "bodyText": "In MongoDB panache reactive I have the following implementation, why is it the same not possible for Hibernate ?\n    public <T extends Entity> Uni<ReactivePanacheQuery<T>> lastPage() {\n        checkPagination();\n        return pageCount().map(pageCount -> page(page.index(pageCount - 1)));\n    }", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462181179", "createdAt": "2020-07-29T09:55:47Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA3MTk3NA==", "bodyText": "OK.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467071974", "createdAt": "2020-08-07T14:21:38Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/CommonPanacheQueryImpl.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Parameter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.persistence.LockModeType;\n+\n+import org.hibernate.Filter;\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Range;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public class CommonPanacheQueryImpl<Entity> {\n+\n+    // match SELECT DISTINCT? id (AS id)? (, id (AS id)?)*\n+    static final Pattern SELECT_PATTERN = Pattern.compile(\n+            \"^\\\\s*SELECT\\\\s+((?:DISTINCT\\\\s+)?\\\\w+(?:\\\\.\\\\w+)*)(?:\\\\s+AS\\\\s+\\\\w+)?(\\\\s*,\\\\s*\\\\w+(?:\\\\.\\\\w+)*(?:\\\\s+AS\\\\s+\\\\w+)?)*\\\\s+(.*)\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    // match FROM\n+    static final Pattern FROM_PATTERN = Pattern.compile(\"^\\\\s*FROM\\\\s+.*\",\n+            Pattern.CASE_INSENSITIVE);\n+\n+    private Object paramsArrayOrMap;\n+    private String query;\n+    protected String countQuery;\n+    private String orderBy;\n+    private Uni<Mutiny.Session> em;\n+\n+    private Page page;\n+    private Uni<Long> count;\n+\n+    private Range range;\n+\n+    private LockModeType lockModeType;\n+    private Map<String, Object> hints;\n+\n+    private Map<String, Map<String, Object>> filters;\n+\n+    public CommonPanacheQueryImpl(Uni<Mutiny.Session> em, String query, String orderBy, Object paramsArrayOrMap) {\n+        this.em = em;\n+        this.query = query;\n+        this.orderBy = orderBy;\n+        this.paramsArrayOrMap = paramsArrayOrMap;\n+    }\n+\n+    private CommonPanacheQueryImpl(CommonPanacheQueryImpl<?> previousQuery, String newQueryString, String countQuery) {\n+        this.em = previousQuery.em;\n+        this.query = newQueryString;\n+        this.countQuery = countQuery;\n+        this.orderBy = previousQuery.orderBy;\n+        this.paramsArrayOrMap = previousQuery.paramsArrayOrMap;\n+        this.page = previousQuery.page;\n+        this.count = previousQuery.count;\n+        this.range = previousQuery.range;\n+        this.lockModeType = previousQuery.lockModeType;\n+        this.hints = previousQuery.hints;\n+        this.filters = previousQuery.filters;\n+    }\n+\n+    // Builder\n+\n+    public <T> CommonPanacheQueryImpl<T> project(Class<T> type) {\n+        if (AbstractJpaOperations.isNamedQuery(query)) {\n+            throw new PanacheQueryException(\"Unable to perform a projection on a named query\");\n+        }\n+\n+        // We use the first constructor that we found and use the parameter names,\n+        // so the projection class must have only one constructor,\n+        // and the application must be built with parameter names.\n+        // Maybe this should be improved some days ...\n+        Constructor<?> constructor = type.getDeclaredConstructors()[0];\n+\n+        // build select clause with a constructor expression\n+        StringBuilder select = new StringBuilder(\"SELECT new \").append(type.getName()).append(\" (\");\n+        int selectInitialLength = select.length();\n+        for (Parameter parameter : constructor.getParameters()) {\n+            if (!parameter.isNamePresent()) {\n+                throw new PanacheQueryException(\n+                        \"Your application must be built with parameter names, this should be the default if\" +\n+                                \" using Quarkus artifacts. Check the maven or gradle compiler configuration to include '-parameters'.\");\n+            }\n+\n+            if (select.length() > selectInitialLength) {\n+                select.append(\", \");\n+            }\n+            select.append(parameter.getName());\n+        }\n+        select.append(\") \");\n+\n+        return new CommonPanacheQueryImpl<>(this, select.toString() + query, \"select count(*) \" + query);\n+    }\n+\n+    public void filter(String filterName, Map<String, Object> parameters) {\n+        if (filters == null)\n+            filters = new HashMap<>();\n+        filters.put(filterName, parameters);\n+    }\n+\n+    public void page(Page page) {\n+        this.page = page;\n+        this.range = null; // reset the range to be able to switch from range to page\n+    }\n+\n+    public void page(int pageIndex, int pageSize) {\n+        page(Page.of(pageIndex, pageSize));\n+    }\n+\n+    public void nextPage() {\n+        checkPagination();\n+        page(page.next());\n+    }\n+\n+    public void previousPage() {\n+        checkPagination();\n+        page(page.previous());\n+    }\n+\n+    public void firstPage() {\n+        checkPagination();\n+        page(page.first());\n+    }\n+\n+    // FIXME: what do we do for this one?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4MTE3OQ=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NTU0NjQ1OnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/PanacheQuery.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMDowOTo0OFrOG4xyfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNDozODo1OFrOG9cd0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4OTE4Mg==", "bodyText": "It misses firstResultOptional() and singleResultOptional() methods.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462189182", "createdAt": "2020-07-29T10:09:48Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/PanacheQuery.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package io.quarkus.hibernate.reactive.panache;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.persistence.LockModeType;\n+import javax.persistence.NoResultException;\n+import javax.persistence.NonUniqueResultException;\n+\n+import org.hibernate.Session;\n+import org.hibernate.annotations.FilterDef;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Parameters;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+/**\n+ * <p>\n+ * Interface representing an entity query, which abstracts the use of paging, getting the number of results, and\n+ * operating on {@link List} or {@link Stream}.\n+ * </p>\n+ * <p>\n+ * Instances of this interface cannot mutate the query itself or its parameters: only paging information can be\n+ * modified, and instances of this interface can be reused to obtain multiple pages of results.\n+ * </p>\n+ *\n+ * @author St\u00e9phane \u00c9pardaud\n+ * @param <Entity> The entity type being queried\n+ */\n+public interface PanacheQuery<Entity> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA3MjM5OA==", "bodyText": "I really feel like Optional doesn't belong where we deal with Uni which have their own way to return empty results. I don't think we should add them.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467072398", "createdAt": "2020-08-07T14:22:21Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/PanacheQuery.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package io.quarkus.hibernate.reactive.panache;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.persistence.LockModeType;\n+import javax.persistence.NoResultException;\n+import javax.persistence.NonUniqueResultException;\n+\n+import org.hibernate.Session;\n+import org.hibernate.annotations.FilterDef;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Parameters;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+/**\n+ * <p>\n+ * Interface representing an entity query, which abstracts the use of paging, getting the number of results, and\n+ * operating on {@link List} or {@link Stream}.\n+ * </p>\n+ * <p>\n+ * Instances of this interface cannot mutate the query itself or its parameters: only paging information can be\n+ * modified, and instances of this interface can be reused to obtain multiple pages of results.\n+ * </p>\n+ *\n+ * @author St\u00e9phane \u00c9pardaud\n+ * @param <Entity> The entity type being queried\n+ */\n+public interface PanacheQuery<Entity> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4OTE4Mg=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA4MjcwNg==", "bodyText": "Maybe ask some light from the munity expert, I'm OK if we don't provide them (I'll deprecate them in MongoDB then) as soon as we explain somewhere in the doc that we don't provide them because of Mutiny or someone may ask to add them", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467082706", "createdAt": "2020-08-07T14:38:58Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/PanacheQuery.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package io.quarkus.hibernate.reactive.panache;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import javax.persistence.LockModeType;\n+import javax.persistence.NoResultException;\n+import javax.persistence.NonUniqueResultException;\n+\n+import org.hibernate.Session;\n+import org.hibernate.annotations.FilterDef;\n+\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Parameters;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+/**\n+ * <p>\n+ * Interface representing an entity query, which abstracts the use of paging, getting the number of results, and\n+ * operating on {@link List} or {@link Stream}.\n+ * </p>\n+ * <p>\n+ * Instances of this interface cannot mutate the query itself or its parameters: only paging information can be\n+ * modified, and instances of this interface can be reused to obtain multiple pages of results.\n+ * </p>\n+ *\n+ * @author St\u00e9phane \u00c9pardaud\n+ * @param <Entity> The entity type being queried\n+ */\n+public interface PanacheQuery<Entity> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4OTE4Mg=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NTU2ODI3OnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/resources/META-INF/quarkus-extension.yaml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMDoxNjowOVrOG4x_5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNDoyMjozMlrOG9b18Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE5MjYxMg==", "bodyText": "As it's new maybe use the status preview instead of stable ?\nMoreover, the undermying Hibernate reactive extension is in preview state.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462192612", "createdAt": "2020-07-29T10:16:09Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/resources/META-INF/quarkus-extension.yaml", "diffHunk": "@@ -0,0 +1,12 @@\n+---\n+name: \"Hibernate Reactive with Panache\"\n+metadata:\n+  keywords:\n+  - \"hibernate-reactive-panache\"\n+  - \"panache\"\n+  - \"hibernate\"\n+  - \"jpa\"\n+  guide: \"https://quarkus.io/guides/hibernate-orm-panache\"\n+  categories:\n+  - \"data\"\n+  status: \"stable\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA3MjQ5Nw==", "bodyText": "Yeah, absolutely, thanks.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467072497", "createdAt": "2020-08-07T14:22:32Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache/runtime/src/main/resources/META-INF/quarkus-extension.yaml", "diffHunk": "@@ -0,0 +1,12 @@\n+---\n+name: \"Hibernate Reactive with Panache\"\n+metadata:\n+  keywords:\n+  - \"hibernate-reactive-panache\"\n+  - \"panache\"\n+  - \"hibernate\"\n+  - \"jpa\"\n+  guide: \"https://quarkus.io/guides/hibernate-orm-panache\"\n+  categories:\n+  - \"data\"\n+  status: \"stable\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE5MjYxMg=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NTU4NDYzOnYy", "diffSide": "RIGHT", "path": "integration-tests/hibernate-reactive-panache/providers.txt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMDoyMToyMlrOG4yJpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNDoyMjo1OVrOG9b3Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE5NTEwOA==", "bodyText": "What is the purpose of this file ?", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462195108", "createdAt": "2020-07-29T10:21:22Z", "author": {"login": "loicmathieu"}, "path": "integration-tests/hibernate-reactive-panache/providers.txt", "diffHunk": "@@ -0,0 +1,4 @@\n+io.quarkus.resteasy.runtime.ForbiddenExceptionMapper", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA3Mjc3OQ==", "bodyText": "Ouch, sorry.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467072779", "createdAt": "2020-08-07T14:22:59Z", "author": {"login": "FroMage"}, "path": "integration-tests/hibernate-reactive-panache/providers.txt", "diffHunk": "@@ -0,0 +1,4 @@\n+io.quarkus.resteasy.runtime.ForbiddenExceptionMapper", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE5NTEwOA=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NTY1MTU3OnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMDo0MDoyNFrOG4yyng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNDoyMzozMFrOG9b4OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwNTU5OA==", "bodyText": "Maybe encapsulate this inside a Uni.createFrom().deferred(() -> {} block to traverse the entities array asynchronously", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462205598", "createdAt": "2020-07-29T10:40:24Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA3MzA4MQ==", "bodyText": "I've changed this anyway.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467073081", "createdAt": "2020-08-07T14:23:30Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIwNTU5OA=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NTY4NjY5OnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache/deployment/src/test/java/io/quarkus/hibernate/reactive/panache/test/MyOtherTestResource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMDo1MTo0MFrOG4zICQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMDo1MTo0MFrOG4zICQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxMTA4MQ==", "bodyText": "You should use NotFoundException instead", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462211081", "createdAt": "2020-07-29T10:51:40Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache/deployment/src/test/java/io/quarkus/hibernate/reactive/panache/test/MyOtherTestResource.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package io.quarkus.hibernate.reactive.panache.test;\n+\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.WebApplicationException;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.resteasy.annotations.jaxrs.PathParam;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+@Path(\"other-entity\")\n+public class MyOtherTestResource {\n+\n+    @GET\n+    @Path(\"{id}\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Uni<MyOtherEntity> get(@PathParam long id) {\n+        return MyOtherEntity.<MyOtherEntity> findById(id)\n+                .onItem().ifNull().failWith(() -> new WebApplicationException(Response.Status.NOT_FOUND));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NTcwMDYzOnYy", "diffSide": "RIGHT", "path": "integration-tests/hibernate-reactive-panache/src/main/java/io/quarkus/it/panache/reactive/TestEndpoint.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMDo1NjoyMlrOG4zQsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNDoyNTowM1rOG9b8MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxMzI5OA==", "bodyText": "Are transaction mandatory for the test ?\nCan we block and make the assertions out of the reactive code?\nThis test is very hard to read with all the flatMap operations ...", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462213298", "createdAt": "2020-07-29T10:56:22Z", "author": {"login": "loicmathieu"}, "path": "integration-tests/hibernate-reactive-panache/src/main/java/io/quarkus/it/panache/reactive/TestEndpoint.java", "diffHunk": "@@ -0,0 +1,1772 @@\n+package io.quarkus.it.panache.reactive;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+import javax.inject.Inject;\n+import javax.persistence.LockModeType;\n+import javax.persistence.NoResultException;\n+import javax.persistence.NonUniqueResultException;\n+import javax.transaction.Transactional;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.xml.bind.annotation.XmlAttribute;\n+import javax.xml.bind.annotation.XmlElements;\n+import javax.xml.bind.annotation.XmlTransient;\n+\n+import org.hibernate.engine.spi.SelfDirtinessTracker;\n+import org.hibernate.jpa.QueryHints;\n+import org.junit.jupiter.api.Assertions;\n+\n+import io.quarkus.hibernate.reactive.panache.Panache;\n+import io.quarkus.hibernate.reactive.panache.PanacheQuery;\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+/**\n+ * Various tests covering Panache functionality. All tests should work in both standard JVM and in native mode.\n+ */\n+@Path(\"test\")\n+public class TestEndpoint {\n+\n+    // fake unused injection point to force ArC to not remove this otherwise I can't mock it in the tests\n+    @Inject\n+    MockablePersonRepository mockablePersonRepository;\n+\n+    @GET\n+    @Path(\"model\")\n+    @Transactional\n+    public Uni<String> testModel() {\n+        return Panache.withTransaction(() -> Person.findAll().list()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA3NDA5Ng==", "bodyText": "Yes, transaction is required for write operations. The code is indeed hard to read, but it helped writing it to spot issues in the API, so I'd rather keep it reactive.", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467074096", "createdAt": "2020-08-07T14:25:03Z", "author": {"login": "FroMage"}, "path": "integration-tests/hibernate-reactive-panache/src/main/java/io/quarkus/it/panache/reactive/TestEndpoint.java", "diffHunk": "@@ -0,0 +1,1772 @@\n+package io.quarkus.it.panache.reactive;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+import javax.inject.Inject;\n+import javax.persistence.LockModeType;\n+import javax.persistence.NoResultException;\n+import javax.persistence.NonUniqueResultException;\n+import javax.transaction.Transactional;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.xml.bind.annotation.XmlAttribute;\n+import javax.xml.bind.annotation.XmlElements;\n+import javax.xml.bind.annotation.XmlTransient;\n+\n+import org.hibernate.engine.spi.SelfDirtinessTracker;\n+import org.hibernate.jpa.QueryHints;\n+import org.junit.jupiter.api.Assertions;\n+\n+import io.quarkus.hibernate.reactive.panache.Panache;\n+import io.quarkus.hibernate.reactive.panache.PanacheQuery;\n+import io.quarkus.panache.common.Page;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+/**\n+ * Various tests covering Panache functionality. All tests should work in both standard JVM and in native mode.\n+ */\n+@Path(\"test\")\n+public class TestEndpoint {\n+\n+    // fake unused injection point to force ArC to not remove this otherwise I can't mock it in the tests\n+    @Inject\n+    MockablePersonRepository mockablePersonRepository;\n+\n+    @GET\n+    @Path(\"model\")\n+    @Transactional\n+    public Uni<String> testModel() {\n+        return Panache.withTransaction(() -> Person.findAll().list()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxMzI5OA=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NTcxMDc4OnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMDo1OTo0MFrOG4zW2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwOTowMzoyOFrOHFa67w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxNDg3Mg==", "bodyText": "Are these methods used somewhere?\nBecause there is no exists operation at entity/repository level ...", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r462214872", "createdAt": "2020-07-29T10:59:40Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {\n+        @SuppressWarnings(\"serial\")\n+        Uni<Session> entityManager = Arc.container().instance(new TypeLiteral<Uni<Mutiny.Session>>() {\n+        }).get();\n+        // FIXME: handle null or exception?\n+        if (entityManager == null) {\n+            throw new PersistenceException(\"No Mutiny.Session found. Do you have any JPA entities defined?\");\n+        }\n+        return entityManager;\n+    }\n+\n+    public TransactionManager getTransactionManager() {\n+        return Arc.container().instance(TransactionManager.class).get();\n+    }\n+\n+    public static Mutiny.Query<?> bindParameters(Mutiny.Query<?> query, Object[] params) {\n+        if (params == null || params.length == 0)\n+            return query;\n+        for (int i = 0; i < params.length; i++) {\n+            query.setParameter(i + 1, params[i]);\n+        }\n+        return query;\n+    }\n+\n+    public static Mutiny.Query<?> bindParameters(Mutiny.Query<?> query, Map<String, Object> params) {\n+        if (params == null || params.size() == 0)\n+            return query;\n+        for (Entry<String, Object> entry : params.entrySet()) {\n+            query.setParameter(entry.getKey(), entry.getValue());\n+        }\n+        return query;\n+    }\n+\n+    public int paramCount(Object[] params) {\n+        return params != null ? params.length : 0;\n+    }\n+\n+    public int paramCount(Map<String, Object> params) {\n+        return params != null ? params.size() : 0;\n+    }\n+\n+    private String getEntityName(Class<?> entityClass) {\n+        // FIXME: not true?\n+        return entityClass.getName();\n+    }\n+\n+    public String createFindQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null) {\n+            return \"FROM \" + getEntityName(entityClass);\n+        }\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty()) {\n+            return \"FROM \" + getEntityName(entityClass);\n+        }\n+\n+        if (isNamedQuery(query)) {\n+            // we return named query as is\n+            return query;\n+        }\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \") || trimmedLc.startsWith(\"select \")) {\n+            return query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            return \"FROM \" + getEntityName(entityClass) + \" \" + query;\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    static boolean isNamedQuery(String query) {\n+        if (query == null || query.isEmpty()) {\n+            return false;\n+        }\n+        return query.charAt(0) == '#';\n+    }\n+\n+    private String createCountQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null)\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty())\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"SELECT COUNT(*) \" + query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            // ignore it\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    private String createUpdateQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null) {\n+            throw new PanacheQueryException(\"Query string cannot be null\");\n+        }\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty()) {\n+            throw new PanacheQueryException(\"Query string cannot be empty\");\n+        }\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"update \")) {\n+            return query;\n+        }\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"UPDATE \" + query;\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        if (trimmedLc.startsWith(\"set \")) {\n+            return \"UPDATE FROM \" + getEntityName(entityClass) + \" \" + query;\n+        }\n+        return \"UPDATE FROM \" + getEntityName(entityClass) + \" SET \" + query;\n+    }\n+\n+    private String createDeleteQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null)\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty())\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"DELETE \" + query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            // ignore it\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"DELETE FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    public String toOrderBy(Sort sort) {\n+        if (sort == null) {\n+            return null;\n+        }\n+        if (sort.getColumns().size() == 0) {\n+            return \"\";\n+        }\n+        StringBuilder sb = new StringBuilder(\" ORDER BY \");\n+        for (int i = 0; i < sort.getColumns().size(); i++) {\n+            Sort.Column column = sort.getColumns().get(i);\n+            if (i > 0)\n+                sb.append(\" , \");\n+            sb.append(column.getName());\n+            if (column.getDirection() != Sort.Direction.Ascending)\n+                sb.append(\" DESC\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    //\n+    // Queries\n+\n+    public Uni<?> findById(Class<?> entityClass, Object id) {\n+        return getEntityManager().flatMap(em -> em.find(entityClass, id));\n+    }\n+\n+    public Uni<?> findById(Class<?> entityClass, Object id, LockModeType lockModeType) {\n+        return getEntityManager().flatMap(em -> em.find(entityClass, id, LockModeConverter.convertToLockMode(lockModeType)));\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Object... params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        String findQuery = createFindQuery(entityClass, query, paramCount(params));\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        // FIXME: check for duplicate ORDER BY clause?\n+        if (isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            NamedQueryUtil.checkNamedQuery(entityClass, namedQuery);\n+            return createPanacheQuery(em, query, toOrderBy(sort), params);\n+        }\n+        return createPanacheQuery(em, findQuery, toOrderBy(sort), params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        String findQuery = createFindQuery(entityClass, query, paramCount(params));\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        // FIXME: check for duplicate ORDER BY clause?\n+        if (isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            NamedQueryUtil.checkNamedQuery(entityClass, namedQuery);\n+            return createPanacheQuery(em, query, toOrderBy(sort), params);\n+        }\n+        return createPanacheQuery(em, findQuery, toOrderBy(sort), params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Parameters params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return find(entityClass, query, sort, params.map());\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Object... params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Parameters params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Object... params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Parameters params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public PanacheQueryType findAll(Class<?> entityClass) {\n+        String query = \"FROM \" + getEntityName(entityClass);\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        return createPanacheQuery(em, query, null, null);\n+    }\n+\n+    public PanacheQueryType findAll(Class<?> entityClass, Sort sort) {\n+        String query = \"FROM \" + getEntityName(entityClass);\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        return createPanacheQuery(em, query, toOrderBy(sort), null);\n+    }\n+\n+    public Uni<List<?>> listAll(Class<?> entityClass) {\n+        return list(findAll(entityClass));\n+    }\n+\n+    public Uni<List<?>> listAll(Class<?> entityClass, Sort sort) {\n+        return list(findAll(entityClass, sort));\n+    }\n+\n+    public Multi<?> streamAll(Class<?> entityClass) {\n+        return stream(findAll(entityClass));\n+    }\n+\n+    public Multi<?> streamAll(Class<?> entityClass, Sort sort) {\n+        return stream(findAll(entityClass, sort));\n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public Uni<Long> count(Class<?> entityClass) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) em.createQuery(\"SELECT COUNT(*) FROM \" + getEntityName(entityClass)).getSingleResult());\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public Uni<Long> count(Class<?> entityClass, String query, Object... params) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) bindParameters(em.createQuery(createCountQuery(entityClass, query, paramCount(params))),\n+                        params).getSingleResult());\n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public Uni<Long> count(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) bindParameters(em.createQuery(createCountQuery(entityClass, query, paramCount(params))),\n+                        params).getSingleResult());\n+    }\n+\n+    public Uni<Long> count(Class<?> entityClass, String query, Parameters params) {\n+        return count(entityClass, query, params.map());\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass) {\n+        return count(entityClass).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Object... params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Parameters params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 420}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA3NTQwMQ==", "bodyText": "Hum, how did we miss this, they're even missing in the ORM version\u2026", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467075401", "createdAt": "2020-08-07T14:27:00Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {\n+        @SuppressWarnings(\"serial\")\n+        Uni<Session> entityManager = Arc.container().instance(new TypeLiteral<Uni<Mutiny.Session>>() {\n+        }).get();\n+        // FIXME: handle null or exception?\n+        if (entityManager == null) {\n+            throw new PersistenceException(\"No Mutiny.Session found. Do you have any JPA entities defined?\");\n+        }\n+        return entityManager;\n+    }\n+\n+    public TransactionManager getTransactionManager() {\n+        return Arc.container().instance(TransactionManager.class).get();\n+    }\n+\n+    public static Mutiny.Query<?> bindParameters(Mutiny.Query<?> query, Object[] params) {\n+        if (params == null || params.length == 0)\n+            return query;\n+        for (int i = 0; i < params.length; i++) {\n+            query.setParameter(i + 1, params[i]);\n+        }\n+        return query;\n+    }\n+\n+    public static Mutiny.Query<?> bindParameters(Mutiny.Query<?> query, Map<String, Object> params) {\n+        if (params == null || params.size() == 0)\n+            return query;\n+        for (Entry<String, Object> entry : params.entrySet()) {\n+            query.setParameter(entry.getKey(), entry.getValue());\n+        }\n+        return query;\n+    }\n+\n+    public int paramCount(Object[] params) {\n+        return params != null ? params.length : 0;\n+    }\n+\n+    public int paramCount(Map<String, Object> params) {\n+        return params != null ? params.size() : 0;\n+    }\n+\n+    private String getEntityName(Class<?> entityClass) {\n+        // FIXME: not true?\n+        return entityClass.getName();\n+    }\n+\n+    public String createFindQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null) {\n+            return \"FROM \" + getEntityName(entityClass);\n+        }\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty()) {\n+            return \"FROM \" + getEntityName(entityClass);\n+        }\n+\n+        if (isNamedQuery(query)) {\n+            // we return named query as is\n+            return query;\n+        }\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \") || trimmedLc.startsWith(\"select \")) {\n+            return query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            return \"FROM \" + getEntityName(entityClass) + \" \" + query;\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    static boolean isNamedQuery(String query) {\n+        if (query == null || query.isEmpty()) {\n+            return false;\n+        }\n+        return query.charAt(0) == '#';\n+    }\n+\n+    private String createCountQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null)\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty())\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"SELECT COUNT(*) \" + query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            // ignore it\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    private String createUpdateQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null) {\n+            throw new PanacheQueryException(\"Query string cannot be null\");\n+        }\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty()) {\n+            throw new PanacheQueryException(\"Query string cannot be empty\");\n+        }\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"update \")) {\n+            return query;\n+        }\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"UPDATE \" + query;\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        if (trimmedLc.startsWith(\"set \")) {\n+            return \"UPDATE FROM \" + getEntityName(entityClass) + \" \" + query;\n+        }\n+        return \"UPDATE FROM \" + getEntityName(entityClass) + \" SET \" + query;\n+    }\n+\n+    private String createDeleteQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null)\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty())\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"DELETE \" + query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            // ignore it\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"DELETE FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    public String toOrderBy(Sort sort) {\n+        if (sort == null) {\n+            return null;\n+        }\n+        if (sort.getColumns().size() == 0) {\n+            return \"\";\n+        }\n+        StringBuilder sb = new StringBuilder(\" ORDER BY \");\n+        for (int i = 0; i < sort.getColumns().size(); i++) {\n+            Sort.Column column = sort.getColumns().get(i);\n+            if (i > 0)\n+                sb.append(\" , \");\n+            sb.append(column.getName());\n+            if (column.getDirection() != Sort.Direction.Ascending)\n+                sb.append(\" DESC\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    //\n+    // Queries\n+\n+    public Uni<?> findById(Class<?> entityClass, Object id) {\n+        return getEntityManager().flatMap(em -> em.find(entityClass, id));\n+    }\n+\n+    public Uni<?> findById(Class<?> entityClass, Object id, LockModeType lockModeType) {\n+        return getEntityManager().flatMap(em -> em.find(entityClass, id, LockModeConverter.convertToLockMode(lockModeType)));\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Object... params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        String findQuery = createFindQuery(entityClass, query, paramCount(params));\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        // FIXME: check for duplicate ORDER BY clause?\n+        if (isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            NamedQueryUtil.checkNamedQuery(entityClass, namedQuery);\n+            return createPanacheQuery(em, query, toOrderBy(sort), params);\n+        }\n+        return createPanacheQuery(em, findQuery, toOrderBy(sort), params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        String findQuery = createFindQuery(entityClass, query, paramCount(params));\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        // FIXME: check for duplicate ORDER BY clause?\n+        if (isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            NamedQueryUtil.checkNamedQuery(entityClass, namedQuery);\n+            return createPanacheQuery(em, query, toOrderBy(sort), params);\n+        }\n+        return createPanacheQuery(em, findQuery, toOrderBy(sort), params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Parameters params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return find(entityClass, query, sort, params.map());\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Object... params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Parameters params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Object... params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Parameters params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public PanacheQueryType findAll(Class<?> entityClass) {\n+        String query = \"FROM \" + getEntityName(entityClass);\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        return createPanacheQuery(em, query, null, null);\n+    }\n+\n+    public PanacheQueryType findAll(Class<?> entityClass, Sort sort) {\n+        String query = \"FROM \" + getEntityName(entityClass);\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        return createPanacheQuery(em, query, toOrderBy(sort), null);\n+    }\n+\n+    public Uni<List<?>> listAll(Class<?> entityClass) {\n+        return list(findAll(entityClass));\n+    }\n+\n+    public Uni<List<?>> listAll(Class<?> entityClass, Sort sort) {\n+        return list(findAll(entityClass, sort));\n+    }\n+\n+    public Multi<?> streamAll(Class<?> entityClass) {\n+        return stream(findAll(entityClass));\n+    }\n+\n+    public Multi<?> streamAll(Class<?> entityClass, Sort sort) {\n+        return stream(findAll(entityClass, sort));\n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public Uni<Long> count(Class<?> entityClass) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) em.createQuery(\"SELECT COUNT(*) FROM \" + getEntityName(entityClass)).getSingleResult());\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public Uni<Long> count(Class<?> entityClass, String query, Object... params) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) bindParameters(em.createQuery(createCountQuery(entityClass, query, paramCount(params))),\n+                        params).getSingleResult());\n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public Uni<Long> count(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) bindParameters(em.createQuery(createCountQuery(entityClass, query, paramCount(params))),\n+                        params).getSingleResult());\n+    }\n+\n+    public Uni<Long> count(Class<?> entityClass, String query, Parameters params) {\n+        return count(entityClass, query, params.map());\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass) {\n+        return count(entityClass).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Object... params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Parameters params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxNDg3Mg=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 420}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEwNjM5Mw==", "bodyText": "OK, so this is used by c4e84c5 by Spring data even though we don't expose it. Mystery solved. I could remove this, but I bet when sprint data reactive lands they will need this, so\u2026", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r467106393", "createdAt": "2020-08-07T15:19:08Z", "author": {"login": "FroMage"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {\n+        @SuppressWarnings(\"serial\")\n+        Uni<Session> entityManager = Arc.container().instance(new TypeLiteral<Uni<Mutiny.Session>>() {\n+        }).get();\n+        // FIXME: handle null or exception?\n+        if (entityManager == null) {\n+            throw new PersistenceException(\"No Mutiny.Session found. Do you have any JPA entities defined?\");\n+        }\n+        return entityManager;\n+    }\n+\n+    public TransactionManager getTransactionManager() {\n+        return Arc.container().instance(TransactionManager.class).get();\n+    }\n+\n+    public static Mutiny.Query<?> bindParameters(Mutiny.Query<?> query, Object[] params) {\n+        if (params == null || params.length == 0)\n+            return query;\n+        for (int i = 0; i < params.length; i++) {\n+            query.setParameter(i + 1, params[i]);\n+        }\n+        return query;\n+    }\n+\n+    public static Mutiny.Query<?> bindParameters(Mutiny.Query<?> query, Map<String, Object> params) {\n+        if (params == null || params.size() == 0)\n+            return query;\n+        for (Entry<String, Object> entry : params.entrySet()) {\n+            query.setParameter(entry.getKey(), entry.getValue());\n+        }\n+        return query;\n+    }\n+\n+    public int paramCount(Object[] params) {\n+        return params != null ? params.length : 0;\n+    }\n+\n+    public int paramCount(Map<String, Object> params) {\n+        return params != null ? params.size() : 0;\n+    }\n+\n+    private String getEntityName(Class<?> entityClass) {\n+        // FIXME: not true?\n+        return entityClass.getName();\n+    }\n+\n+    public String createFindQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null) {\n+            return \"FROM \" + getEntityName(entityClass);\n+        }\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty()) {\n+            return \"FROM \" + getEntityName(entityClass);\n+        }\n+\n+        if (isNamedQuery(query)) {\n+            // we return named query as is\n+            return query;\n+        }\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \") || trimmedLc.startsWith(\"select \")) {\n+            return query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            return \"FROM \" + getEntityName(entityClass) + \" \" + query;\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    static boolean isNamedQuery(String query) {\n+        if (query == null || query.isEmpty()) {\n+            return false;\n+        }\n+        return query.charAt(0) == '#';\n+    }\n+\n+    private String createCountQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null)\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty())\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"SELECT COUNT(*) \" + query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            // ignore it\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    private String createUpdateQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null) {\n+            throw new PanacheQueryException(\"Query string cannot be null\");\n+        }\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty()) {\n+            throw new PanacheQueryException(\"Query string cannot be empty\");\n+        }\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"update \")) {\n+            return query;\n+        }\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"UPDATE \" + query;\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        if (trimmedLc.startsWith(\"set \")) {\n+            return \"UPDATE FROM \" + getEntityName(entityClass) + \" \" + query;\n+        }\n+        return \"UPDATE FROM \" + getEntityName(entityClass) + \" SET \" + query;\n+    }\n+\n+    private String createDeleteQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null)\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty())\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"DELETE \" + query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            // ignore it\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"DELETE FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    public String toOrderBy(Sort sort) {\n+        if (sort == null) {\n+            return null;\n+        }\n+        if (sort.getColumns().size() == 0) {\n+            return \"\";\n+        }\n+        StringBuilder sb = new StringBuilder(\" ORDER BY \");\n+        for (int i = 0; i < sort.getColumns().size(); i++) {\n+            Sort.Column column = sort.getColumns().get(i);\n+            if (i > 0)\n+                sb.append(\" , \");\n+            sb.append(column.getName());\n+            if (column.getDirection() != Sort.Direction.Ascending)\n+                sb.append(\" DESC\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    //\n+    // Queries\n+\n+    public Uni<?> findById(Class<?> entityClass, Object id) {\n+        return getEntityManager().flatMap(em -> em.find(entityClass, id));\n+    }\n+\n+    public Uni<?> findById(Class<?> entityClass, Object id, LockModeType lockModeType) {\n+        return getEntityManager().flatMap(em -> em.find(entityClass, id, LockModeConverter.convertToLockMode(lockModeType)));\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Object... params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        String findQuery = createFindQuery(entityClass, query, paramCount(params));\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        // FIXME: check for duplicate ORDER BY clause?\n+        if (isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            NamedQueryUtil.checkNamedQuery(entityClass, namedQuery);\n+            return createPanacheQuery(em, query, toOrderBy(sort), params);\n+        }\n+        return createPanacheQuery(em, findQuery, toOrderBy(sort), params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        String findQuery = createFindQuery(entityClass, query, paramCount(params));\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        // FIXME: check for duplicate ORDER BY clause?\n+        if (isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            NamedQueryUtil.checkNamedQuery(entityClass, namedQuery);\n+            return createPanacheQuery(em, query, toOrderBy(sort), params);\n+        }\n+        return createPanacheQuery(em, findQuery, toOrderBy(sort), params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Parameters params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return find(entityClass, query, sort, params.map());\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Object... params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Parameters params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Object... params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Parameters params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public PanacheQueryType findAll(Class<?> entityClass) {\n+        String query = \"FROM \" + getEntityName(entityClass);\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        return createPanacheQuery(em, query, null, null);\n+    }\n+\n+    public PanacheQueryType findAll(Class<?> entityClass, Sort sort) {\n+        String query = \"FROM \" + getEntityName(entityClass);\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        return createPanacheQuery(em, query, toOrderBy(sort), null);\n+    }\n+\n+    public Uni<List<?>> listAll(Class<?> entityClass) {\n+        return list(findAll(entityClass));\n+    }\n+\n+    public Uni<List<?>> listAll(Class<?> entityClass, Sort sort) {\n+        return list(findAll(entityClass, sort));\n+    }\n+\n+    public Multi<?> streamAll(Class<?> entityClass) {\n+        return stream(findAll(entityClass));\n+    }\n+\n+    public Multi<?> streamAll(Class<?> entityClass, Sort sort) {\n+        return stream(findAll(entityClass, sort));\n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public Uni<Long> count(Class<?> entityClass) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) em.createQuery(\"SELECT COUNT(*) FROM \" + getEntityName(entityClass)).getSingleResult());\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public Uni<Long> count(Class<?> entityClass, String query, Object... params) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) bindParameters(em.createQuery(createCountQuery(entityClass, query, paramCount(params))),\n+                        params).getSingleResult());\n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public Uni<Long> count(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) bindParameters(em.createQuery(createCountQuery(entityClass, query, paramCount(params))),\n+                        params).getSingleResult());\n+    }\n+\n+    public Uni<Long> count(Class<?> entityClass, String query, Parameters params) {\n+        return count(entityClass, query, params.map());\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass) {\n+        return count(entityClass).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Object... params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Parameters params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxNDg3Mg=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 420}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0NTk5OQ==", "bodyText": "Ah, OK, maybe add a small comment now that we know why it exist ;)", "url": "https://github.com/quarkusio/quarkus/pull/10769#discussion_r475445999", "createdAt": "2020-08-24T09:03:28Z", "author": {"login": "loicmathieu"}, "path": "extensions/panache/hibernate-reactive-panache-common/runtime/src/main/java/io/quarkus/hibernate/reactive/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -0,0 +1,506 @@\n+package io.quarkus.hibernate.reactive.panache.common.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import javax.enterprise.util.TypeLiteral;\n+import javax.persistence.LockModeType;\n+import javax.persistence.PersistenceException;\n+import javax.transaction.SystemException;\n+import javax.transaction.TransactionManager;\n+\n+import org.hibernate.internal.util.LockModeConverter;\n+import org.hibernate.reactive.mutiny.Mutiny;\n+import org.hibernate.reactive.mutiny.Mutiny.Session;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.panache.common.Parameters;\n+import io.quarkus.panache.common.Sort;\n+import io.quarkus.panache.common.exception.PanacheQueryException;\n+import io.smallrye.mutiny.Multi;\n+import io.smallrye.mutiny.Uni;\n+\n+public abstract class AbstractJpaOperations<PanacheQueryType> {\n+\n+    protected abstract PanacheQueryType createPanacheQuery(Uni<Mutiny.Session> em, String query, String orderBy,\n+            Object paramsArrayOrMap);\n+\n+    protected abstract Uni<List<?>> list(PanacheQueryType query);\n+\n+    protected abstract Multi<?> stream(PanacheQueryType query);\n+\n+    //\n+    // Instance methods\n+\n+    public Uni<Void> persist(Object entity) {\n+        return getEntityManager().flatMap(em -> persist(em, entity));\n+    }\n+\n+    public Uni<Void> persist(Mutiny.Session em, Object entity) {\n+        if (!em.contains(entity)) {\n+            return em.persist(entity).map(v -> null);\n+        }\n+        return Uni.createFrom().nullItem();\n+    }\n+\n+    public Uni<Void> persist(Iterable<?> entities) {\n+        return persist(StreamSupport.stream(entities.spliterator(), false));\n+    }\n+\n+    public Uni<Void> persist(Object firstEntity, Object... entities) {\n+        List<Object> array = new ArrayList<>(entities.length + 1);\n+        array.add(firstEntity);\n+        for (Object entity : entities) {\n+            array.add(entity);\n+        }\n+        return persist(array.stream());\n+    }\n+\n+    public Uni<Void> persist(Stream<?> entities) {\n+        return getEntityManager().flatMap(\n+                em -> Uni.combine().all().unis(entities.map(entity -> persist(em, entity)).collect(Collectors.toList()))\n+                        .combinedWith(list -> null));\n+    }\n+\n+    public Uni<Void> delete(Object entity) {\n+        return getEntityManager().flatMap(em -> em.remove(entity).map(v -> null));\n+    }\n+\n+    public Uni<Boolean> isPersistent(Object entity) {\n+        return getEntityManager().map(em -> em.contains(entity));\n+    }\n+\n+    public Uni<Void> flush() {\n+        return getEntityManager().flatMap(em -> em.flush()).map(v -> null);\n+    }\n+\n+    //\n+    // Private stuff\n+\n+    public Uni<Mutiny.Session> getEntityManager() {\n+        @SuppressWarnings(\"serial\")\n+        Uni<Session> entityManager = Arc.container().instance(new TypeLiteral<Uni<Mutiny.Session>>() {\n+        }).get();\n+        // FIXME: handle null or exception?\n+        if (entityManager == null) {\n+            throw new PersistenceException(\"No Mutiny.Session found. Do you have any JPA entities defined?\");\n+        }\n+        return entityManager;\n+    }\n+\n+    public TransactionManager getTransactionManager() {\n+        return Arc.container().instance(TransactionManager.class).get();\n+    }\n+\n+    public static Mutiny.Query<?> bindParameters(Mutiny.Query<?> query, Object[] params) {\n+        if (params == null || params.length == 0)\n+            return query;\n+        for (int i = 0; i < params.length; i++) {\n+            query.setParameter(i + 1, params[i]);\n+        }\n+        return query;\n+    }\n+\n+    public static Mutiny.Query<?> bindParameters(Mutiny.Query<?> query, Map<String, Object> params) {\n+        if (params == null || params.size() == 0)\n+            return query;\n+        for (Entry<String, Object> entry : params.entrySet()) {\n+            query.setParameter(entry.getKey(), entry.getValue());\n+        }\n+        return query;\n+    }\n+\n+    public int paramCount(Object[] params) {\n+        return params != null ? params.length : 0;\n+    }\n+\n+    public int paramCount(Map<String, Object> params) {\n+        return params != null ? params.size() : 0;\n+    }\n+\n+    private String getEntityName(Class<?> entityClass) {\n+        // FIXME: not true?\n+        return entityClass.getName();\n+    }\n+\n+    public String createFindQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null) {\n+            return \"FROM \" + getEntityName(entityClass);\n+        }\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty()) {\n+            return \"FROM \" + getEntityName(entityClass);\n+        }\n+\n+        if (isNamedQuery(query)) {\n+            // we return named query as is\n+            return query;\n+        }\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \") || trimmedLc.startsWith(\"select \")) {\n+            return query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            return \"FROM \" + getEntityName(entityClass) + \" \" + query;\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    static boolean isNamedQuery(String query) {\n+        if (query == null || query.isEmpty()) {\n+            return false;\n+        }\n+        return query.charAt(0) == '#';\n+    }\n+\n+    private String createCountQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null)\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty())\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"SELECT COUNT(*) \" + query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            // ignore it\n+            return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass);\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"SELECT COUNT(*) FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    private String createUpdateQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null) {\n+            throw new PanacheQueryException(\"Query string cannot be null\");\n+        }\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty()) {\n+            throw new PanacheQueryException(\"Query string cannot be empty\");\n+        }\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"update \")) {\n+            return query;\n+        }\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"UPDATE \" + query;\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        if (trimmedLc.startsWith(\"set \")) {\n+            return \"UPDATE FROM \" + getEntityName(entityClass) + \" \" + query;\n+        }\n+        return \"UPDATE FROM \" + getEntityName(entityClass) + \" SET \" + query;\n+    }\n+\n+    private String createDeleteQuery(Class<?> entityClass, String query, int paramCount) {\n+        if (query == null)\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+\n+        String trimmed = query.trim();\n+        if (trimmed.isEmpty())\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+\n+        String trimmedLc = trimmed.toLowerCase();\n+        if (trimmedLc.startsWith(\"from \")) {\n+            return \"DELETE \" + query;\n+        }\n+        if (trimmedLc.startsWith(\"order by \")) {\n+            // ignore it\n+            return \"DELETE FROM \" + getEntityName(entityClass);\n+        }\n+        if (trimmedLc.indexOf(' ') == -1 && trimmedLc.indexOf('=') == -1 && paramCount == 1) {\n+            query += \" = ?1\";\n+        }\n+        return \"DELETE FROM \" + getEntityName(entityClass) + \" WHERE \" + query;\n+    }\n+\n+    public String toOrderBy(Sort sort) {\n+        if (sort == null) {\n+            return null;\n+        }\n+        if (sort.getColumns().size() == 0) {\n+            return \"\";\n+        }\n+        StringBuilder sb = new StringBuilder(\" ORDER BY \");\n+        for (int i = 0; i < sort.getColumns().size(); i++) {\n+            Sort.Column column = sort.getColumns().get(i);\n+            if (i > 0)\n+                sb.append(\" , \");\n+            sb.append(column.getName());\n+            if (column.getDirection() != Sort.Direction.Ascending)\n+                sb.append(\" DESC\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    //\n+    // Queries\n+\n+    public Uni<?> findById(Class<?> entityClass, Object id) {\n+        return getEntityManager().flatMap(em -> em.find(entityClass, id));\n+    }\n+\n+    public Uni<?> findById(Class<?> entityClass, Object id, LockModeType lockModeType) {\n+        return getEntityManager().flatMap(em -> em.find(entityClass, id, LockModeConverter.convertToLockMode(lockModeType)));\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Object... params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        String findQuery = createFindQuery(entityClass, query, paramCount(params));\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        // FIXME: check for duplicate ORDER BY clause?\n+        if (isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            NamedQueryUtil.checkNamedQuery(entityClass, namedQuery);\n+            return createPanacheQuery(em, query, toOrderBy(sort), params);\n+        }\n+        return createPanacheQuery(em, findQuery, toOrderBy(sort), params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        String findQuery = createFindQuery(entityClass, query, paramCount(params));\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        // FIXME: check for duplicate ORDER BY clause?\n+        if (isNamedQuery(query)) {\n+            String namedQuery = query.substring(1);\n+            NamedQueryUtil.checkNamedQuery(entityClass, namedQuery);\n+            return createPanacheQuery(em, query, toOrderBy(sort), params);\n+        }\n+        return createPanacheQuery(em, findQuery, toOrderBy(sort), params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Parameters params) {\n+        return find(entityClass, query, null, params);\n+    }\n+\n+    public PanacheQueryType find(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return find(entityClass, query, sort, params.map());\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Object... params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Parameters params) {\n+        return list(find(entityClass, query, params));\n+    }\n+\n+    public Uni<List<?>> list(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return list(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Object... params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Object... params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Map<String, Object> params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Parameters params) {\n+        return stream(find(entityClass, query, params));\n+    }\n+\n+    public Multi<?> stream(Class<?> entityClass, String query, Sort sort, Parameters params) {\n+        return stream(find(entityClass, query, sort, params));\n+    }\n+\n+    public PanacheQueryType findAll(Class<?> entityClass) {\n+        String query = \"FROM \" + getEntityName(entityClass);\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        return createPanacheQuery(em, query, null, null);\n+    }\n+\n+    public PanacheQueryType findAll(Class<?> entityClass, Sort sort) {\n+        String query = \"FROM \" + getEntityName(entityClass);\n+        Uni<Mutiny.Session> em = getEntityManager();\n+        return createPanacheQuery(em, query, toOrderBy(sort), null);\n+    }\n+\n+    public Uni<List<?>> listAll(Class<?> entityClass) {\n+        return list(findAll(entityClass));\n+    }\n+\n+    public Uni<List<?>> listAll(Class<?> entityClass, Sort sort) {\n+        return list(findAll(entityClass, sort));\n+    }\n+\n+    public Multi<?> streamAll(Class<?> entityClass) {\n+        return stream(findAll(entityClass));\n+    }\n+\n+    public Multi<?> streamAll(Class<?> entityClass, Sort sort) {\n+        return stream(findAll(entityClass, sort));\n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public Uni<Long> count(Class<?> entityClass) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) em.createQuery(\"SELECT COUNT(*) FROM \" + getEntityName(entityClass)).getSingleResult());\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public Uni<Long> count(Class<?> entityClass, String query, Object... params) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) bindParameters(em.createQuery(createCountQuery(entityClass, query, paramCount(params))),\n+                        params).getSingleResult());\n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public Uni<Long> count(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return getEntityManager()\n+                .flatMap(em -> (Uni) bindParameters(em.createQuery(createCountQuery(entityClass, query, paramCount(params))),\n+                        params).getSingleResult());\n+    }\n+\n+    public Uni<Long> count(Class<?> entityClass, String query, Parameters params) {\n+        return count(entityClass, query, params.map());\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass) {\n+        return count(entityClass).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Object... params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Map<String, Object> params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }\n+\n+    public Uni<Boolean> exists(Class<?> entityClass, String query, Parameters params) {\n+        return count(entityClass, query, params).map(c -> c > 0);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjIxNDg3Mg=="}, "originalCommit": {"oid": "66cd30adf5f65e235831e3cb55ea57ad8f317b48"}, "originalPosition": 420}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 900, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}