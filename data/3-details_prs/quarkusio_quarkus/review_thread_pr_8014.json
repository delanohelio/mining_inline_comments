{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxNDY4Mzk4", "number": 8014, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODowMToxOVrODp9znA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMjo0MzozN1rODroJiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzMwODQ0OnYy", "diffSide": "RIGHT", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/sys/seal/VaultInit.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODowMToxOVrOF5eDZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODowMToxOVrOF5eDZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNTU0Mw==", "bodyText": "it is too dangerous to include sensitive data into a toString(). it is way too easy for somebody to do a log.info(\"init result = \" + vaultInit). if we want to have a meaningful toString(), let's replace it with:\nreturn \"VaultInit{\"+keys.size()+\" keys)\"", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395805543", "createdAt": "2020-03-20T18:01:19Z", "author": {"login": "vsevel"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/sys/seal/VaultInit.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package io.quarkus.vault.runtime.sys.seal;\n+\n+import java.util.List;\n+\n+public class VaultInit {\n+\n+    private List<String> keys;\n+    private List<String> keysBase64;\n+    private String rootToken;\n+\n+    public VaultInit(List<String> keys, List<String> keysBase64, String rootToken) {\n+        this.keys = keys;\n+        this.keysBase64 = keysBase64;\n+        this.rootToken = rootToken;\n+    }\n+\n+    public List<String> getKeys() {\n+        return keys;\n+    }\n+\n+    public List<String> getKeysBase64() {\n+        return keysBase64;\n+    }\n+\n+    public String getRootToken() {\n+        return rootToken;\n+    }\n+\n+    @Override\n+    public String toString() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2a983e6a146694d8d2dddec1884130729929f3b"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzMxMTQwOnYy", "diffSide": "RIGHT", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/sys/seal/VaultInit.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODowMjoxNVrOF5eFYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODowMjoxNVrOF5eFYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNjA1MA==", "bodyText": "this is part of the api. it should be in package io.quarkus.vault.sys", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395806050", "createdAt": "2020-03-20T18:02:15Z", "author": {"login": "vsevel"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/sys/seal/VaultInit.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package io.quarkus.vault.runtime.sys.seal;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2a983e6a146694d8d2dddec1884130729929f3b"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzMxNTU3OnYy", "diffSide": "RIGHT", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/sys/seal/VaultSealStatus.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODowMzoyOVrOF5eIKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODowMzoyOVrOF5eIKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNjc2MA==", "bodyText": "this is part of the api. it should be in package io.quarkus.vault.sys", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395806760", "createdAt": "2020-03-20T18:03:29Z", "author": {"login": "vsevel"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/sys/seal/VaultSealStatus.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package io.quarkus.vault.runtime.sys.seal;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2a983e6a146694d8d2dddec1884130729929f3b"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzMxNzM2OnYy", "diffSide": "RIGHT", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/sys/health/VaultHealth.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODowNDowMlrOF5eJYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODowNDowMlrOF5eJYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNzA3Mw==", "bodyText": "this is part of the api. it should be in package io.quarkus.vault.sys", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395807073", "createdAt": "2020-03-20T18:04:02Z", "author": {"login": "vsevel"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/sys/health/VaultHealth.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package io.quarkus.vault.runtime.sys.health;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2a983e6a146694d8d2dddec1884130729929f3b"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzMxODU4OnYy", "diffSide": "RIGHT", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/sys/health/VaultHealthStatus.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODowNDoyN1rOF5eKIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxOTowMjo0NFrOF5rHZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNzI2Nw==", "bodyText": "this is part of the api. it should be in package io.quarkus.vault.sys", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395807267", "createdAt": "2020-03-20T18:04:27Z", "author": {"login": "vsevel"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/sys/health/VaultHealthStatus.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package io.quarkus.vault.runtime.sys.health;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2a983e6a146694d8d2dddec1884130729929f3b"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyMzM1MQ==", "bodyText": "I was thinking the same but, there are a lot of sys operations so I decided to split but we can put together for sure.", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395823351", "createdAt": "2020-03-20T18:36:16Z", "author": {"login": "lordofthejars"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/sys/health/VaultHealthStatus.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package io.quarkus.vault.runtime.sys.health;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNzI2Nw=="}, "originalCommit": {"oid": "e2a983e6a146694d8d2dddec1884130729929f3b"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyOTA5Mg==", "bodyText": "not sure I got you. everything that is either a param or a return type in the system backend engine interface needs to be in a non runtime package. that's the rule I got from Guillaume when I initially pushed the extension. this applies to:\n\nVaultInit\nVaultHealth\nVaultHealthStatus\nVaultSealStatus\nalso I saw that you decided to not allow passing params to VaultHealth health(); whereas the vault api allows to pass a bunch of args: standbyok, perfstandbyok, activecode, standbycode, drsecondarycode, performancestandbycode, sealedcode\nis that on purpose?", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395829092", "createdAt": "2020-03-20T18:47:56Z", "author": {"login": "vsevel"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/sys/health/VaultHealthStatus.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package io.quarkus.vault.runtime.sys.health;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNzI2Nw=="}, "originalCommit": {"oid": "e2a983e6a146694d8d2dddec1884130729929f3b"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzMjM4Mw==", "bodyText": "Yes it is on purpose. As for me, it sounds strange that someone might want to change the status code definition and the status flags can be configured in application.properties. I was thinking more about simplicity/common cases and if someone requests it we can always extend it easily.", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395832383", "createdAt": "2020-03-20T18:54:21Z", "author": {"login": "lordofthejars"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/sys/health/VaultHealthStatus.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package io.quarkus.vault.runtime.sys.health;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNzI2Nw=="}, "originalCommit": {"oid": "e2a983e6a146694d8d2dddec1884130729929f3b"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxNTM3Nw==", "bodyText": "As for me, it sounds strange that someone might want to change the status code definition\n\nsome time ago I had to integrate vault into k8s. the situation was different because I was implementing the liveness/readiness probes of vault itself (not a client of vault). but still it shows a situation where I had to change the status codes. basically I turned everything to 200 for liveness, otherwise vault would have been killed and restarted anytime its state would have bee something other than the ok state. which would have been counter productive because no restart would have helped. and for the readiness I did the same except for the sealedcode because when vault is sealed I did not want it to be part of the service. but I still wanted it to be reachable when it is not initialized. because if it is, all vaults are in the same situation, and making it not ready will just make it harder to access it.\nsee the probe definitions.\nyou have also to take into account that people sometime use the same endpoint for liveness and readiness, which is a very bad idea when integrating external systems into the app health checks (this could lead to unwanted app restarts, and cascading crash loop backoffs).\nare you expecting your healthchecks to be used for readiness only?", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r396015377", "createdAt": "2020-03-21T18:13:28Z", "author": {"login": "vsevel"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/sys/health/VaultHealthStatus.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package io.quarkus.vault.runtime.sys.health;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNzI2Nw=="}, "originalCommit": {"oid": "e2a983e6a146694d8d2dddec1884130729929f3b"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxOTU1Nw==", "bodyText": "I understand but as you said this is different, we are not integrating Vault directly into Kubernetes health check but we are providing health checks of the service so we are taking care of translating the codes of Vault into Kubernetes health checks by using the Health check spec, so I think that as a starting point is fine.\nBy default yes, if people wants to use it as liveness they can implement by themselves using the programmatic way.", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r396019557", "createdAt": "2020-03-21T19:02:44Z", "author": {"login": "lordofthejars"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/sys/health/VaultHealthStatus.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package io.quarkus.vault.runtime.sys.health;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNzI2Nw=="}, "originalCommit": {"oid": "e2a983e6a146694d8d2dddec1884130729929f3b"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzM2MDkxOnYy", "diffSide": "RIGHT", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/config/VaultConfigSource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODoxODoxMFrOF5elgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODoxODoxMFrOF5elgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxNDI3Mw==", "bodyText": "private VaultRuntimeConfig getRuntimeConfig() {\n        return getConfig(runtimeConfig, () -> loadRuntimeConfig(), \"runtime\");\n    }\n\n    private VaultBuildimeConfig getBuildtimeConfig() {\n        return getConfig(buildtimeConfig, () -> loadBuildtimeConfig(), \"buildtime\");\n    }\n\n    private <T> T getConfig(AtomicReference<T> ref, Supplier<T> supplier, String name) {\n        T config = ref.get();\n        if (config != null) {\n            return config;\n        } else {\n            config = supplier.get();\n            log.debug(\"loaded vault \" + name + \" config \" + config);\n            ref.set(config);\n            return ref.get();\n        }\n    }", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395814273", "createdAt": "2020-03-20T18:18:10Z", "author": {"login": "vsevel"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/config/VaultConfigSource.java", "diffHunk": "@@ -148,16 +150,29 @@ private void fetchSecrets(List<String> paths, String prefix, Map<String, String>\n \n     private VaultManager getVaultManager() {\n \n+        VaultBuildTimeConfig buildTimeConfig = getBuildConfig();\n         VaultRuntimeConfig serverConfig = getConfig();\n \n         // init at most once\n         if (init.compareAndSet(false, true)) {\n-            VaultManager.init(serverConfig);\n+            VaultManager.init(buildTimeConfig, serverConfig);\n         }\n \n         return VaultManager.getInstance();\n     }\n \n+    private VaultBuildTimeConfig getBuildConfig() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2a983e6a146694d8d2dddec1884130729929f3b"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzM4NTM0OnYy", "diffSide": "RIGHT", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/VaultSystemBackendManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODoyNTo1NFrOF5e1Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODozODowOFrOF5fMkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxODI3OA==", "bodyText": "why did you distinguished VaultHealthStatus from VaultHealth? we could have added the status code into the VaultHealthStatus. did you think that for performance reasons , in the context of healthchecks, it was important to do a head instead of a full get?", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395818278", "createdAt": "2020-03-20T18:25:54Z", "author": {"login": "vsevel"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/VaultSystemBackendManager.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package io.quarkus.vault.runtime;\n+\n+import io.quarkus.vault.VaultSystemBackendEngine;\n+import io.quarkus.vault.runtime.client.VaultClient;\n+import io.quarkus.vault.runtime.client.dto.sys.VaultHealthResult;\n+import io.quarkus.vault.runtime.client.dto.sys.VaultInitResponse;\n+import io.quarkus.vault.runtime.client.dto.sys.VaultSealStatusResult;\n+import io.quarkus.vault.runtime.config.VaultBuildTimeConfig;\n+import io.quarkus.vault.runtime.sys.health.VaultHealth;\n+import io.quarkus.vault.runtime.sys.health.VaultHealthStatus;\n+import io.quarkus.vault.runtime.sys.seal.VaultInit;\n+import io.quarkus.vault.runtime.sys.seal.VaultSealStatus;\n+\n+public class VaultSystemBackendManager implements VaultSystemBackendEngine {\n+\n+    private VaultClient vaultClient;\n+    private VaultBuildTimeConfig buildTimeConfig;\n+\n+    public VaultSystemBackendManager(VaultBuildTimeConfig buildTimeConfig, VaultClient vaultClient) {\n+        this.vaultClient = vaultClient;\n+        this.buildTimeConfig = buildTimeConfig;\n+    }\n+\n+    @Override\n+    public VaultInit init(int secretShares, int secretThreshold) {\n+        final VaultInitResponse init = this.vaultClient.init(secretShares, secretThreshold);\n+\n+        final VaultInit vaultInit = new VaultInit(init.keys, init.keysBase64, init.rootToken);\n+        return vaultInit;\n+    }\n+\n+    @Override\n+    public VaultHealth health() {\n+\n+        boolean isStandByOk = false;\n+        if (this.buildTimeConfig.health.standbyok) {\n+            isStandByOk = true;\n+        }\n+\n+        boolean isPerfStandByOk = false;\n+        if (this.buildTimeConfig.health.perfstandbyok) {\n+            isPerfStandByOk = true;\n+        }\n+\n+        return this.health(isStandByOk, isPerfStandByOk);\n+    }\n+\n+    @Override\n+    public VaultHealthStatus healthStatus() {\n+        boolean isStandByOk = false;\n+        if (this.buildTimeConfig.health.standbyok) {\n+            isStandByOk = true;\n+        }\n+\n+        boolean isPerfStandByOk = false;\n+        if (this.buildTimeConfig.health.perfstandbyok) {\n+            isPerfStandByOk = true;\n+        }\n+\n+        return this.healthStatus(isStandByOk, isPerfStandByOk);\n+    }\n+\n+    @Override\n+    public VaultSealStatus sealStatus() {\n+        final VaultSealStatusResult vaultSealStatusResult = this.vaultClient.systemSealStatus();\n+\n+        final VaultSealStatus vaultSealStatus = new VaultSealStatus();\n+        vaultSealStatus.setClusterId(vaultSealStatusResult.clusterId);\n+        vaultSealStatus.setClusterName(vaultSealStatusResult.clusterName);\n+        vaultSealStatus.setInitialized(vaultSealStatusResult.initialized);\n+        vaultSealStatus.setMigration(vaultSealStatusResult.migration);\n+        vaultSealStatus.setN(vaultSealStatusResult.n);\n+        vaultSealStatus.setNonce(vaultSealStatusResult.nonce);\n+        vaultSealStatus.setProgress(vaultSealStatusResult.progress);\n+        vaultSealStatus.setRecoverySeal(vaultSealStatusResult.recoverySeal);\n+        vaultSealStatus.setSealed(vaultSealStatusResult.sealed);\n+        vaultSealStatus.setT(vaultSealStatusResult.t);\n+        vaultSealStatus.setType(vaultSealStatusResult.type);\n+        vaultSealStatus.setVersion(vaultSealStatusResult.version);\n+\n+        return vaultSealStatus;\n+    }\n+\n+    private VaultHealthStatus healthStatus(boolean isStandByOk, boolean isPerfStandByOk) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2a983e6a146694d8d2dddec1884130729929f3b"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNDI3Mg==", "bodyText": "Well two reasons, the first is that as you said head is more performant and in case of readiness checks it is important to be as performant as possible and the second is that Vault offers both options in the API. For this reason, I implemented both, so if someone wants to use programmatically is free to use it but in case of health checks use the more performant one.", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r395824272", "createdAt": "2020-03-20T18:38:08Z", "author": {"login": "lordofthejars"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/VaultSystemBackendManager.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package io.quarkus.vault.runtime;\n+\n+import io.quarkus.vault.VaultSystemBackendEngine;\n+import io.quarkus.vault.runtime.client.VaultClient;\n+import io.quarkus.vault.runtime.client.dto.sys.VaultHealthResult;\n+import io.quarkus.vault.runtime.client.dto.sys.VaultInitResponse;\n+import io.quarkus.vault.runtime.client.dto.sys.VaultSealStatusResult;\n+import io.quarkus.vault.runtime.config.VaultBuildTimeConfig;\n+import io.quarkus.vault.runtime.sys.health.VaultHealth;\n+import io.quarkus.vault.runtime.sys.health.VaultHealthStatus;\n+import io.quarkus.vault.runtime.sys.seal.VaultInit;\n+import io.quarkus.vault.runtime.sys.seal.VaultSealStatus;\n+\n+public class VaultSystemBackendManager implements VaultSystemBackendEngine {\n+\n+    private VaultClient vaultClient;\n+    private VaultBuildTimeConfig buildTimeConfig;\n+\n+    public VaultSystemBackendManager(VaultBuildTimeConfig buildTimeConfig, VaultClient vaultClient) {\n+        this.vaultClient = vaultClient;\n+        this.buildTimeConfig = buildTimeConfig;\n+    }\n+\n+    @Override\n+    public VaultInit init(int secretShares, int secretThreshold) {\n+        final VaultInitResponse init = this.vaultClient.init(secretShares, secretThreshold);\n+\n+        final VaultInit vaultInit = new VaultInit(init.keys, init.keysBase64, init.rootToken);\n+        return vaultInit;\n+    }\n+\n+    @Override\n+    public VaultHealth health() {\n+\n+        boolean isStandByOk = false;\n+        if (this.buildTimeConfig.health.standbyok) {\n+            isStandByOk = true;\n+        }\n+\n+        boolean isPerfStandByOk = false;\n+        if (this.buildTimeConfig.health.perfstandbyok) {\n+            isPerfStandByOk = true;\n+        }\n+\n+        return this.health(isStandByOk, isPerfStandByOk);\n+    }\n+\n+    @Override\n+    public VaultHealthStatus healthStatus() {\n+        boolean isStandByOk = false;\n+        if (this.buildTimeConfig.health.standbyok) {\n+            isStandByOk = true;\n+        }\n+\n+        boolean isPerfStandByOk = false;\n+        if (this.buildTimeConfig.health.perfstandbyok) {\n+            isPerfStandByOk = true;\n+        }\n+\n+        return this.healthStatus(isStandByOk, isPerfStandByOk);\n+    }\n+\n+    @Override\n+    public VaultSealStatus sealStatus() {\n+        final VaultSealStatusResult vaultSealStatusResult = this.vaultClient.systemSealStatus();\n+\n+        final VaultSealStatus vaultSealStatus = new VaultSealStatus();\n+        vaultSealStatus.setClusterId(vaultSealStatusResult.clusterId);\n+        vaultSealStatus.setClusterName(vaultSealStatusResult.clusterName);\n+        vaultSealStatus.setInitialized(vaultSealStatusResult.initialized);\n+        vaultSealStatus.setMigration(vaultSealStatusResult.migration);\n+        vaultSealStatus.setN(vaultSealStatusResult.n);\n+        vaultSealStatus.setNonce(vaultSealStatusResult.nonce);\n+        vaultSealStatus.setProgress(vaultSealStatusResult.progress);\n+        vaultSealStatus.setRecoverySeal(vaultSealStatusResult.recoverySeal);\n+        vaultSealStatus.setSealed(vaultSealStatusResult.sealed);\n+        vaultSealStatus.setT(vaultSealStatusResult.t);\n+        vaultSealStatus.setType(vaultSealStatusResult.type);\n+        vaultSealStatus.setVersion(vaultSealStatusResult.version);\n+\n+        return vaultSealStatus;\n+    }\n+\n+    private VaultHealthStatus healthStatus(boolean isStandByOk, boolean isPerfStandByOk) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxODI3OA=="}, "originalCommit": {"oid": "e2a983e6a146694d8d2dddec1884130729929f3b"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NDgxNzY2OnYy", "diffSide": "RIGHT", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/client/OkHttpVaultClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQyMToxMjoxMVrOF5rupg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQyMToyMTowNFrOF5rxIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAyOTYwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (isStandByOk) {\n          \n          \n            \n                        queryParams.put(\"standbyok\", \"true\");\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    if (isPerfStandByOk) {\n          \n          \n            \n                        queryParams.put(\"perfstandbyok\", \"true\");\n          \n          \n            \n                    }\n          \n          \n            \n                    queryParams.put(\"standbyok\", String.valueOf(isStandByOk));\n          \n          \n            \n                    queryParams.put(\"perfstandbyok\", String.valueOf(isPerfStandByOk));", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r396029606", "createdAt": "2020-03-21T21:12:11Z", "author": {"login": "machi1990"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/client/OkHttpVaultClient.java", "diffHunk": "@@ -312,4 +385,17 @@ private URL getUrl(String path) {\n         }\n     }\n \n+    private Map<String, String> getHealthParams(boolean isStandByOk, boolean isPerfStandByOk) {\n+        Map<String, String> queryParams = new HashMap<>();\n+        if (isStandByOk) {\n+            queryParams.put(\"standbyok\", \"true\");\n+        }\n+\n+        if (isPerfStandByOk) {\n+            queryParams.put(\"perfstandbyok\", \"true\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dcfa9cc8afd0399bdd421495634cc8153fee506"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAyOTk3Mg==", "bodyText": "I have not done in this way to not create objects + parse things when it is false. Also notice that this map is iterated in another piece of code, so a readiness check is called several times + usually user will leave these with defaults (false) I thought that it will be a minor improvement (that's true) but at least an improvement.", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r396029972", "createdAt": "2020-03-21T21:17:21Z", "author": {"login": "lordofthejars"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/client/OkHttpVaultClient.java", "diffHunk": "@@ -312,4 +385,17 @@ private URL getUrl(String path) {\n         }\n     }\n \n+    private Map<String, String> getHealthParams(boolean isStandByOk, boolean isPerfStandByOk) {\n+        Map<String, String> queryParams = new HashMap<>();\n+        if (isStandByOk) {\n+            queryParams.put(\"standbyok\", \"true\");\n+        }\n+\n+        if (isPerfStandByOk) {\n+            queryParams.put(\"perfstandbyok\", \"true\");\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAyOTYwNg=="}, "originalCommit": {"oid": "0dcfa9cc8afd0399bdd421495634cc8153fee506"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAzMDI0MA==", "bodyText": "It was a minor nitpick. We can leave the code as is.", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r396030240", "createdAt": "2020-03-21T21:21:04Z", "author": {"login": "machi1990"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/client/OkHttpVaultClient.java", "diffHunk": "@@ -312,4 +385,17 @@ private URL getUrl(String path) {\n         }\n     }\n \n+    private Map<String, String> getHealthParams(boolean isStandByOk, boolean isPerfStandByOk) {\n+        Map<String, String> queryParams = new HashMap<>();\n+        if (isStandByOk) {\n+            queryParams.put(\"standbyok\", \"true\");\n+        }\n+\n+        if (isPerfStandByOk) {\n+            queryParams.put(\"perfstandbyok\", \"true\");\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAyOTYwNg=="}, "originalCommit": {"oid": "0dcfa9cc8afd0399bdd421495634cc8153fee506"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NDgxOTIxOnYy", "diffSide": "RIGHT", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/config/VaultConfigSource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQyMToxNTowOFrOF5rvew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQwODo1MToyNlrOF5uIQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAyOTgxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            getVaultProperty(\"health.enable\", \"false\"));\n          \n          \n            \n                            getVaultProperty(\"health.enabled\", \"false\"));", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r396029819", "createdAt": "2020-03-21T21:15:08Z", "author": {"login": "machi1990"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/config/VaultConfigSource.java", "diffHunk": "@@ -148,30 +151,55 @@ private void fetchSecrets(List<String> paths, String prefix, Map<String, String>\n \n     private VaultManager getVaultManager() {\n \n-        VaultRuntimeConfig serverConfig = getConfig();\n+        VaultBuildTimeConfig buildTimeConfig = getBuildtimeConfig();\n+        VaultRuntimeConfig serverConfig = getRuntimeConfig();\n \n         // init at most once\n         if (init.compareAndSet(false, true)) {\n-            VaultManager.init(serverConfig);\n+            VaultManager.init(buildTimeConfig, serverConfig);\n         }\n \n         return VaultManager.getInstance();\n     }\n \n-    private VaultRuntimeConfig getConfig() {\n-        VaultRuntimeConfig serverConfig = this.serverConfig.get();\n-        if (serverConfig != null) {\n-            return serverConfig;\n+    private VaultRuntimeConfig getRuntimeConfig() {\n+        return getConfig(this.serverConfig, () -> loadRuntimeConfig(), \"runtime\");\n+    }\n+\n+    private VaultBuildTimeConfig getBuildtimeConfig() {\n+        return getConfig(this.buildServerConfig, () -> loadBuildtimeConfig(), \"buildtime\");\n+    }\n+\n+    private <T> T getConfig(AtomicReference<T> ref, Supplier<T> supplier, String name) {\n+        T config = ref.get();\n+        if (config != null) {\n+            return config;\n         } else {\n-            serverConfig = loadConfig();\n-            log.debug(\"loaded vault server config \" + serverConfig);\n-            this.serverConfig.set(serverConfig);\n-            return this.serverConfig.get();\n+            config = supplier.get();\n+            log.debug(\"loaded vault \" + name + \" config \" + config);\n+            ref.set(config);\n+            return ref.get();\n         }\n     }\n \n     // need to recode config loading since we are at the config source level\n-    private VaultRuntimeConfig loadConfig() {\n+    private VaultBuildTimeConfig loadBuildtimeConfig() {\n+        VaultBuildTimeConfig vaultBuildTimeConfig = new VaultBuildTimeConfig();\n+        vaultBuildTimeConfig.health = new HealthConfig();\n+\n+        vaultBuildTimeConfig.health.enabled = parseBoolean(\n+                getVaultProperty(\"health.enable\", \"false\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dcfa9cc8afd0399bdd421495634cc8153fee506"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA2ODkzMA==", "bodyText": "Good catch.", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r396068930", "createdAt": "2020-03-22T08:51:26Z", "author": {"login": "lordofthejars"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/config/VaultConfigSource.java", "diffHunk": "@@ -148,30 +151,55 @@ private void fetchSecrets(List<String> paths, String prefix, Map<String, String>\n \n     private VaultManager getVaultManager() {\n \n-        VaultRuntimeConfig serverConfig = getConfig();\n+        VaultBuildTimeConfig buildTimeConfig = getBuildtimeConfig();\n+        VaultRuntimeConfig serverConfig = getRuntimeConfig();\n \n         // init at most once\n         if (init.compareAndSet(false, true)) {\n-            VaultManager.init(serverConfig);\n+            VaultManager.init(buildTimeConfig, serverConfig);\n         }\n \n         return VaultManager.getInstance();\n     }\n \n-    private VaultRuntimeConfig getConfig() {\n-        VaultRuntimeConfig serverConfig = this.serverConfig.get();\n-        if (serverConfig != null) {\n-            return serverConfig;\n+    private VaultRuntimeConfig getRuntimeConfig() {\n+        return getConfig(this.serverConfig, () -> loadRuntimeConfig(), \"runtime\");\n+    }\n+\n+    private VaultBuildTimeConfig getBuildtimeConfig() {\n+        return getConfig(this.buildServerConfig, () -> loadBuildtimeConfig(), \"buildtime\");\n+    }\n+\n+    private <T> T getConfig(AtomicReference<T> ref, Supplier<T> supplier, String name) {\n+        T config = ref.get();\n+        if (config != null) {\n+            return config;\n         } else {\n-            serverConfig = loadConfig();\n-            log.debug(\"loaded vault server config \" + serverConfig);\n-            this.serverConfig.set(serverConfig);\n-            return this.serverConfig.get();\n+            config = supplier.get();\n+            log.debug(\"loaded vault \" + name + \" config \" + config);\n+            ref.set(config);\n+            return ref.get();\n         }\n     }\n \n     // need to recode config loading since we are at the config source level\n-    private VaultRuntimeConfig loadConfig() {\n+    private VaultBuildTimeConfig loadBuildtimeConfig() {\n+        VaultBuildTimeConfig vaultBuildTimeConfig = new VaultBuildTimeConfig();\n+        vaultBuildTimeConfig.health = new HealthConfig();\n+\n+        vaultBuildTimeConfig.health.enabled = parseBoolean(\n+                getVaultProperty(\"health.enable\", \"false\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAyOTgxOQ=="}, "originalCommit": {"oid": "0dcfa9cc8afd0399bdd421495634cc8153fee506"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NDgyMTYxOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/vault.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQyMToxOToxM1rOF5rwpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQyMToxOToxM1rOF5rwpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAzMDExOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            WARNING: When the readiness probe is failing in Kubernetes, then the application is not reachable. This means that if Vault is failing, all services depending on Vault will become unreachable and maybe this is not the desired state, so use this flag accordingly to your requirements.\n          \n          \n            \n            WARNING: When the readiness probe is failing in Kubernetes, then the application is not reachable. This means that if Vault is failing, all services depending on Vault will become unreachable and maybe this is not the desired state, so use this flag according to your requirements.", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r396030119", "createdAt": "2020-03-21T21:19:13Z", "author": {"login": "machi1990"}, "path": "docs/src/main/asciidoc/vault.adoc", "diffHunk": "@@ -497,6 +497,27 @@ You should see:\n {password=connor}\n ----\n \n+== Vault Health Check\n+\n+If you are using the `quarkus-smallrye-health` extension, `quarkus-vault` can add a readiness health check\n+to validate the connection to the Vault server. This is disabled by default.\n+\n+If enabled, when you access the `/health/ready` endpoint of your application you will have information about the connection validation status.\n+\n+This behavior can be enabled by setting the `quarkus.vault.health.enabled` property to `true` in your `application.properties`.\n+\n+Only if Vault is initialized, unsealed and active, the health endpoint returns that Vault is ready to serve requests.\n+\n+You can change a bit this behaviour by using `quarkus.vault.health.standbyok` and `quarkus.vault.health.perfstandbyok` to `true` in your `application.properties`.\n+\n+standbyok:: Specifies if being a standby should still return the active status code instead of the standby status code.\n+\n+perfstandbyok:: Specifies if being a performance standby should still return the active status code instead of the performance standby status code.\n+\n+You can inject `io.quarkus.vault.VaultSystemBackendEngine` to run system operations programmatically.\n+\n+WARNING: When the readiness probe is failing in Kubernetes, then the application is not reachable. This means that if Vault is failing, all services depending on Vault will become unreachable and maybe this is not the desired state, so use this flag accordingly to your requirements.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dcfa9cc8afd0399bdd421495634cc8153fee506"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MTQ2NjY0OnYy", "diffSide": "RIGHT", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/VaultSystemBackendEngine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMToxMDowMFrOF6rVQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMTozNTo1NlrOF6sNHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3MTY4MA==", "bodyText": "@lordofthejars Given what you've discussed with Vincent, IMHO the java docs have to be updated to clarify the difference between health and healthStatus methods and VaultHealth and VaultHealthStatus need to be have their names exchanged as it is quite confusing IMHO.\nRight now healthStatus returns VaultHealthStatus which is filled with the real information, while health returns VaultHealth which only has all that real information available in VaultHealthStatus encapsulated  in a status code :-).\nIrrespectively of the way the lower level Vault API represents it all, it would be clearer IMHO if we had:\n// Returns Vault health status code only by using HTTP HEAD requests.\n// It is faster than a health() method which uses HTTP GET  to return a complete VaultHealth state\nVaultHealthStatus healthStatus(); \n\n// Returns a complete VaultHealth state.\nVaultHealth health(); \n\nor may be this would be better,\n// Returns Vault health status code only by using HTTP HEAD requests.\n// It is faster than a healthStatus() method which uses HTTP GET  to return a complete VaultHealthStaus state\nVaultHealthStatusCode healthStatusCode(); \n\n// Returns a complete VaultHealthStatus state.\nVaultHealthStatus healthStatus(); \n\nThanks\nCC @vsevel", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r397071680", "createdAt": "2020-03-24T11:10:00Z", "author": {"login": "sberyozkin"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/VaultSystemBackendEngine.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.vault;\n+\n+import io.quarkus.vault.runtime.config.VaultRuntimeConfig;\n+import io.quarkus.vault.sys.VaultHealth;\n+import io.quarkus.vault.sys.VaultHealthStatus;\n+import io.quarkus.vault.sys.VaultInit;\n+import io.quarkus.vault.sys.VaultSealStatus;\n+\n+/**\n+ * This service provides access to the system backend.\n+ *\n+ * @see VaultRuntimeConfig\n+ */\n+public interface VaultSystemBackendEngine {\n+\n+    /**\n+     * Initializes a new Vault.\n+     * \n+     * @param secretShares specifies the number of shares to split the master key into.\n+     * @param secretThreshold specifies the number of shares required to reconstruct the master key.\n+     * @return Vault Init.\n+     */\n+    VaultInit init(int secretShares, int secretThreshold);\n+\n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c32853f4f967e10ae8400098eb54b2aa07bdb96"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4NTk4Mw==", "bodyText": "I'll update the JavaDoc.", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r397085983", "createdAt": "2020-03-24T11:35:56Z", "author": {"login": "lordofthejars"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/VaultSystemBackendEngine.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.vault;\n+\n+import io.quarkus.vault.runtime.config.VaultRuntimeConfig;\n+import io.quarkus.vault.sys.VaultHealth;\n+import io.quarkus.vault.sys.VaultHealthStatus;\n+import io.quarkus.vault.sys.VaultInit;\n+import io.quarkus.vault.sys.VaultSealStatus;\n+\n+/**\n+ * This service provides access to the system backend.\n+ *\n+ * @see VaultRuntimeConfig\n+ */\n+public interface VaultSystemBackendEngine {\n+\n+    /**\n+     * Initializes a new Vault.\n+     * \n+     * @param secretShares specifies the number of shares to split the master key into.\n+     * @param secretThreshold specifies the number of shares required to reconstruct the master key.\n+     * @return Vault Init.\n+     */\n+    VaultInit init(int secretShares, int secretThreshold);\n+\n+    /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA3MTY4MA=="}, "originalCommit": {"oid": "6c32853f4f967e10ae8400098eb54b2aa07bdb96"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MTUzNzgwOnYy", "diffSide": "RIGHT", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/VaultSystemBackendEngine.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMTozMDoyOFrOF6sBtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMDo0MjoxOVrOF7CSPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4MzA2Mw==", "bodyText": "We don't have init methods exposed anywhere else in the public Vault interfaces, this is an admin operation which should not be visible to the JAX-RS service code having VaultSystemBackendEngine injected", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r397083063", "createdAt": "2020-03-24T11:30:28Z", "author": {"login": "sberyozkin"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/VaultSystemBackendEngine.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.vault;\n+\n+import io.quarkus.vault.runtime.config.VaultRuntimeConfig;\n+import io.quarkus.vault.sys.VaultHealth;\n+import io.quarkus.vault.sys.VaultHealthStatus;\n+import io.quarkus.vault.sys.VaultInit;\n+import io.quarkus.vault.sys.VaultSealStatus;\n+\n+/**\n+ * This service provides access to the system backend.\n+ *\n+ * @see VaultRuntimeConfig\n+ */\n+public interface VaultSystemBackendEngine {\n+\n+    /**\n+     * Initializes a new Vault.\n+     * \n+     * @param secretShares specifies the number of shares to split the master key into.\n+     * @param secretThreshold specifies the number of shares required to reconstruct the master key.\n+     * @return Vault Init.\n+     */\n+    VaultInit init(int secretShares, int secretThreshold);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c32853f4f967e10ae8400098eb54b2aa07bdb96"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4NTg2OA==", "bodyText": "We agreed with @vsevel to move the sys operations here.", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r397085868", "createdAt": "2020-03-24T11:35:42Z", "author": {"login": "lordofthejars"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/VaultSystemBackendEngine.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.vault;\n+\n+import io.quarkus.vault.runtime.config.VaultRuntimeConfig;\n+import io.quarkus.vault.sys.VaultHealth;\n+import io.quarkus.vault.sys.VaultHealthStatus;\n+import io.quarkus.vault.sys.VaultInit;\n+import io.quarkus.vault.sys.VaultSealStatus;\n+\n+/**\n+ * This service provides access to the system backend.\n+ *\n+ * @see VaultRuntimeConfig\n+ */\n+public interface VaultSystemBackendEngine {\n+\n+    /**\n+     * Initializes a new Vault.\n+     * \n+     * @param secretShares specifies the number of shares to split the master key into.\n+     * @param secretThreshold specifies the number of shares required to reconstruct the master key.\n+     * @return Vault Init.\n+     */\n+    VaultInit init(int secretShares, int secretThreshold);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4MzA2Mw=="}, "originalCommit": {"oid": "6c32853f4f967e10ae8400098eb54b2aa07bdb96"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2MTQzMw==", "bodyText": "@lordofthejars OK, @vsevel Hi Vincent, do you feel it would be useful to have some users doing the Vault Initialization in scope of the current call ?", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r397261433", "createdAt": "2020-03-24T15:51:50Z", "author": {"login": "sberyozkin"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/VaultSystemBackendEngine.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.vault;\n+\n+import io.quarkus.vault.runtime.config.VaultRuntimeConfig;\n+import io.quarkus.vault.sys.VaultHealth;\n+import io.quarkus.vault.sys.VaultHealthStatus;\n+import io.quarkus.vault.sys.VaultInit;\n+import io.quarkus.vault.sys.VaultSealStatus;\n+\n+/**\n+ * This service provides access to the system backend.\n+ *\n+ * @see VaultRuntimeConfig\n+ */\n+public interface VaultSystemBackendEngine {\n+\n+    /**\n+     * Initializes a new Vault.\n+     * \n+     * @param secretShares specifies the number of shares to split the master key into.\n+     * @param secretThreshold specifies the number of shares required to reconstruct the master key.\n+     * @return Vault Init.\n+     */\n+    VaultInit init(int secretShares, int secretThreshold);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4MzA2Mw=="}, "originalCommit": {"oid": "6c32853f4f967e10ae8400098eb54b2aa07bdb96"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI3NjE1Mw==", "bodyText": "@vsevel I'm asking because we've tried hard to have all Vault interfaces very user centric in a sense that each of those operations can do something meaningful in scope of a current HTTP request, and init does not fit. However if you do feel it is worth it then I'll be good with it, thanks", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r397276153", "createdAt": "2020-03-24T16:10:18Z", "author": {"login": "sberyozkin"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/VaultSystemBackendEngine.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.vault;\n+\n+import io.quarkus.vault.runtime.config.VaultRuntimeConfig;\n+import io.quarkus.vault.sys.VaultHealth;\n+import io.quarkus.vault.sys.VaultHealthStatus;\n+import io.quarkus.vault.sys.VaultInit;\n+import io.quarkus.vault.sys.VaultSealStatus;\n+\n+/**\n+ * This service provides access to the system backend.\n+ *\n+ * @see VaultRuntimeConfig\n+ */\n+public interface VaultSystemBackendEngine {\n+\n+    /**\n+     * Initializes a new Vault.\n+     * \n+     * @param secretShares specifies the number of shares to split the master key into.\n+     * @param secretThreshold specifies the number of shares required to reconstruct the master key.\n+     * @return Vault Init.\n+     */\n+    VaultInit init(int secretShares, int secretThreshold);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4MzA2Mw=="}, "originalCommit": {"oid": "6c32853f4f967e10ae8400098eb54b2aa07bdb96"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ0Nzc0MA==", "bodyText": "when I talked about moving some methods,I had specifically the sys/health in mind, but did not make it clear. I know @sberyozkin we had long discussion about this :) I think there is value in having those operations too on the SystemBackendEngine. and sometimes it confuses people to not find operations that we categorize as admin (although it is a valid criteria when priorizing what we want to work on first).\nto make it short, now that @lordofthejars has moved all of them, I would not move them back.", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r397447740", "createdAt": "2020-03-24T20:42:19Z", "author": {"login": "vsevel"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/VaultSystemBackendEngine.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.vault;\n+\n+import io.quarkus.vault.runtime.config.VaultRuntimeConfig;\n+import io.quarkus.vault.sys.VaultHealth;\n+import io.quarkus.vault.sys.VaultHealthStatus;\n+import io.quarkus.vault.sys.VaultInit;\n+import io.quarkus.vault.sys.VaultSealStatus;\n+\n+/**\n+ * This service provides access to the system backend.\n+ *\n+ * @see VaultRuntimeConfig\n+ */\n+public interface VaultSystemBackendEngine {\n+\n+    /**\n+     * Initializes a new Vault.\n+     * \n+     * @param secretShares specifies the number of shares to split the master key into.\n+     * @param secretThreshold specifies the number of shares required to reconstruct the master key.\n+     * @return Vault Init.\n+     */\n+    VaultInit init(int secretShares, int secretThreshold);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA4MzA2Mw=="}, "originalCommit": {"oid": "6c32853f4f967e10ae8400098eb54b2aa07bdb96"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MjY1MDg1OnYy", "diffSide": "RIGHT", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/VaultSystemBackendEngine.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNTo1NToyNFrOF63Fjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNTo1NToyNFrOF63Fjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI2NDI3MQ==", "bodyText": "@lordofthejars So do you think that VaultHealth is more appropriate than VaultHealthStatusCode given that is only has a status code ? Wouldn;t VaultHealthStatusCode be more appropriate ?", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r397264271", "createdAt": "2020-03-24T15:55:24Z", "author": {"login": "sberyozkin"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/VaultSystemBackendEngine.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package io.quarkus.vault;\n+\n+import io.quarkus.vault.runtime.config.VaultRuntimeConfig;\n+import io.quarkus.vault.sys.VaultHealth;\n+import io.quarkus.vault.sys.VaultHealthStatus;\n+import io.quarkus.vault.sys.VaultInit;\n+import io.quarkus.vault.sys.VaultSealStatus;\n+\n+/**\n+ * This service provides access to the system backend.\n+ *\n+ * @see VaultRuntimeConfig\n+ */\n+public interface VaultSystemBackendEngine {\n+\n+    /**\n+     * Initializes a new Vault.\n+     * \n+     * @param secretShares specifies the number of shares to split the master key into.\n+     * @param secretThreshold specifies the number of shares required to reconstruct the master key.\n+     * @return Vault Init.\n+     */\n+    VaultInit init(int secretShares, int secretThreshold);\n+\n+    /**\n+     * Check the health status of Vault.\n+     * Returns Vault health status code only by using HTTP HEAD requests.\n+     * It is faster than calling {@link #healthStatus() healthStatus()} method which uses HTTP GET to return a complete\n+     * VaultHealthStatus state.\n+     *\n+     * @return Vault Health Status.\n+     */\n+    VaultHealth health();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c321504dbec989e08b6c4fc7b5f68e1714b7a53"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NzU2MjAwOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/vault.adoc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNzozODo0MFrOF7mvUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwOToyNzozNVrOF7-ByQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA0NTAxMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            standbyok:: Specifies if being a standby should still return the active status code instead of the standby status code.\n          \n          \n            \n            stand-by-ok:: Specifies if being a standby should still return the active status code instead of the standby status code.\n          \n      \n    \n    \n  \n\nwould be more readable maybe?", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r398045011", "createdAt": "2020-03-25T17:38:40Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/vault.adoc", "diffHunk": "@@ -497,6 +497,27 @@ You should see:\n {password=connor}\n ----\n \n+== Vault Health Check\n+\n+If you are using the `quarkus-smallrye-health` extension, `quarkus-vault` can add a readiness health check\n+to validate the connection to the Vault server. This is disabled by default.\n+\n+If enabled, when you access the `/health/ready` endpoint of your application you will have information about the connection validation status.\n+\n+This behavior can be enabled by setting the `quarkus.vault.health.enabled` property to `true` in your `application.properties`.\n+\n+Only if Vault is initialized, unsealed and active, the health endpoint returns that Vault is ready to serve requests.\n+\n+You can change a bit this behaviour by using `quarkus.vault.health.standbyok` and `quarkus.vault.health.perfstandbyok` to `true` in your `application.properties`.\n+\n+standbyok:: Specifies if being a standby should still return the active status code instead of the standby status code.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8903455e76eea832a3a0d6af61412646592b3700"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQyNjU2OQ==", "bodyText": "I understand your point and I thought the same but in Vault, the property is named in this way standbyok so  I decided to leave it in the same name as in Vault so anyone familiar with Vault properties finds the same property. Do you think it has sense or better to adopt to the Quarkus way?", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r398426569", "createdAt": "2020-03-26T09:27:35Z", "author": {"login": "lordofthejars"}, "path": "docs/src/main/asciidoc/vault.adoc", "diffHunk": "@@ -497,6 +497,27 @@ You should see:\n {password=connor}\n ----\n \n+== Vault Health Check\n+\n+If you are using the `quarkus-smallrye-health` extension, `quarkus-vault` can add a readiness health check\n+to validate the connection to the Vault server. This is disabled by default.\n+\n+If enabled, when you access the `/health/ready` endpoint of your application you will have information about the connection validation status.\n+\n+This behavior can be enabled by setting the `quarkus.vault.health.enabled` property to `true` in your `application.properties`.\n+\n+Only if Vault is initialized, unsealed and active, the health endpoint returns that Vault is ready to serve requests.\n+\n+You can change a bit this behaviour by using `quarkus.vault.health.standbyok` and `quarkus.vault.health.perfstandbyok` to `true` in your `application.properties`.\n+\n+standbyok:: Specifies if being a standby should still return the active status code instead of the standby status code.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA0NTAxMQ=="}, "originalCommit": {"oid": "8903455e76eea832a3a0d6af61412646592b3700"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NzU2Mzc5OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/vault.adoc", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNzozOTowNFrOF7mwbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMToxNTowOFrOF8CDsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA0NTI5Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            perfstandbyok:: Specifies if being a performance standby should still return the active status code instead of the performance standby status code.\n          \n          \n            \n            performance-stand-by-ok:: Specifies if being a performance standby should still return the active status code instead of the performance standby status code.\n          \n      \n    \n    \n  \n\nsame here.", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r398045292", "createdAt": "2020-03-25T17:39:04Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/vault.adoc", "diffHunk": "@@ -497,6 +497,27 @@ You should see:\n {password=connor}\n ----\n \n+== Vault Health Check\n+\n+If you are using the `quarkus-smallrye-health` extension, `quarkus-vault` can add a readiness health check\n+to validate the connection to the Vault server. This is disabled by default.\n+\n+If enabled, when you access the `/health/ready` endpoint of your application you will have information about the connection validation status.\n+\n+This behavior can be enabled by setting the `quarkus.vault.health.enabled` property to `true` in your `application.properties`.\n+\n+Only if Vault is initialized, unsealed and active, the health endpoint returns that Vault is ready to serve requests.\n+\n+You can change a bit this behaviour by using `quarkus.vault.health.standbyok` and `quarkus.vault.health.perfstandbyok` to `true` in your `application.properties`.\n+\n+standbyok:: Specifies if being a standby should still return the active status code instead of the standby status code.\n+\n+perfstandbyok:: Specifies if being a performance standby should still return the active status code instead of the performance standby status code.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8903455e76eea832a3a0d6af61412646592b3700"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQyNjcxNA==", "bodyText": "I understand your point and I thought the same but in Vault, the property is named in this way perfstandbyok so  I decided to leave it in the same name as in Vault so anyone familiar with Vault properties finds the same property. Do you think it has sense or better to adopt to the Quarkus way?", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r398426714", "createdAt": "2020-03-26T09:27:45Z", "author": {"login": "lordofthejars"}, "path": "docs/src/main/asciidoc/vault.adoc", "diffHunk": "@@ -497,6 +497,27 @@ You should see:\n {password=connor}\n ----\n \n+== Vault Health Check\n+\n+If you are using the `quarkus-smallrye-health` extension, `quarkus-vault` can add a readiness health check\n+to validate the connection to the Vault server. This is disabled by default.\n+\n+If enabled, when you access the `/health/ready` endpoint of your application you will have information about the connection validation status.\n+\n+This behavior can be enabled by setting the `quarkus.vault.health.enabled` property to `true` in your `application.properties`.\n+\n+Only if Vault is initialized, unsealed and active, the health endpoint returns that Vault is ready to serve requests.\n+\n+You can change a bit this behaviour by using `quarkus.vault.health.standbyok` and `quarkus.vault.health.perfstandbyok` to `true` in your `application.properties`.\n+\n+standbyok:: Specifies if being a standby should still return the active status code instead of the standby status code.\n+\n+perfstandbyok:: Specifies if being a performance standby should still return the active status code instead of the performance standby status code.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA0NTI5Mg=="}, "originalCommit": {"oid": "8903455e76eea832a3a0d6af61412646592b3700"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ5MTMyMg==", "bodyText": "@lordofthejars It should be fine IMHO, Quarkus users who know about Vault will associate performance-stand-by-ok with a lower level Vault perfstandbyok without any problems :-).\nLets tweak the properties across the PR and I believe Guillaume should be fine with the PR going in", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r398491322", "createdAt": "2020-03-26T11:12:58Z", "author": {"login": "sberyozkin"}, "path": "docs/src/main/asciidoc/vault.adoc", "diffHunk": "@@ -497,6 +497,27 @@ You should see:\n {password=connor}\n ----\n \n+== Vault Health Check\n+\n+If you are using the `quarkus-smallrye-health` extension, `quarkus-vault` can add a readiness health check\n+to validate the connection to the Vault server. This is disabled by default.\n+\n+If enabled, when you access the `/health/ready` endpoint of your application you will have information about the connection validation status.\n+\n+This behavior can be enabled by setting the `quarkus.vault.health.enabled` property to `true` in your `application.properties`.\n+\n+Only if Vault is initialized, unsealed and active, the health endpoint returns that Vault is ready to serve requests.\n+\n+You can change a bit this behaviour by using `quarkus.vault.health.standbyok` and `quarkus.vault.health.perfstandbyok` to `true` in your `application.properties`.\n+\n+standbyok:: Specifies if being a standby should still return the active status code instead of the standby status code.\n+\n+perfstandbyok:: Specifies if being a performance standby should still return the active status code instead of the performance standby status code.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA0NTI5Mg=="}, "originalCommit": {"oid": "8903455e76eea832a3a0d6af61412646592b3700"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ5MjU5NQ==", "bodyText": "@lordofthejars FYI, I'm holding merging this PR, #8143, so as to not affect this PR (extra rebase)", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r398492595", "createdAt": "2020-03-26T11:15:08Z", "author": {"login": "sberyozkin"}, "path": "docs/src/main/asciidoc/vault.adoc", "diffHunk": "@@ -497,6 +497,27 @@ You should see:\n {password=connor}\n ----\n \n+== Vault Health Check\n+\n+If you are using the `quarkus-smallrye-health` extension, `quarkus-vault` can add a readiness health check\n+to validate the connection to the Vault server. This is disabled by default.\n+\n+If enabled, when you access the `/health/ready` endpoint of your application you will have information about the connection validation status.\n+\n+This behavior can be enabled by setting the `quarkus.vault.health.enabled` property to `true` in your `application.properties`.\n+\n+Only if Vault is initialized, unsealed and active, the health endpoint returns that Vault is ready to serve requests.\n+\n+You can change a bit this behaviour by using `quarkus.vault.health.standbyok` and `quarkus.vault.health.perfstandbyok` to `true` in your `application.properties`.\n+\n+standbyok:: Specifies if being a standby should still return the active status code instead of the standby status code.\n+\n+perfstandbyok:: Specifies if being a performance standby should still return the active status code instead of the performance standby status code.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA0NTI5Mg=="}, "originalCommit": {"oid": "8903455e76eea832a3a0d6af61412646592b3700"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NzU2ODEzOnYy", "diffSide": "RIGHT", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/health/VaultHealthCheck.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNzo0MDowNVrOF7mzKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxNzo0MDowNVrOF7mzKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA0NTk5NQ==", "bodyText": "This is not API, it should be in the vault.runtime.health package.", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r398045995", "createdAt": "2020-03-25T17:40:05Z", "author": {"login": "gsmet"}, "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/health/VaultHealthCheck.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package io.quarkus.vault.health;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.health.HealthCheck;\n+import org.eclipse.microprofile.health.HealthCheckResponse;\n+import org.eclipse.microprofile.health.HealthCheckResponseBuilder;\n+import org.eclipse.microprofile.health.Readiness;\n+\n+import io.quarkus.vault.VaultSystemBackendEngine;\n+import io.quarkus.vault.sys.VaultHealth;\n+\n+@Readiness\n+@ApplicationScoped\n+public class VaultHealthCheck implements HealthCheck {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8903455e76eea832a3a0d6af61412646592b3700"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MDczMTYxOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/vault.adoc", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMjo0MzozN1rOF8FDzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMjo1NTo1MFrOF8FhoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU0MTc3Mg==", "bodyText": "@lordofthejars Nearly there :-), can you please update vault.adoc too to match the renamed properties (s) ? Just press Commit-Suggestion or do it locally", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r398541772", "createdAt": "2020-03-26T12:43:37Z", "author": {"login": "sberyozkin"}, "path": "docs/src/main/asciidoc/vault.adoc", "diffHunk": "@@ -497,6 +497,27 @@ You should see:\n {password=connor}\n ----\n \n+== Vault Health Check\n+\n+If you are using the `quarkus-smallrye-health` extension, `quarkus-vault` can add a readiness health check\n+to validate the connection to the Vault server. This is disabled by default.\n+\n+If enabled, when you access the `/health/ready` endpoint of your application you will have information about the connection validation status.\n+\n+This behavior can be enabled by setting the `quarkus.vault.health.enabled` property to `true` in your `application.properties`.\n+\n+Only if Vault is initialized, unsealed and active, the health endpoint returns that Vault is ready to serve requests.\n+\n+You can change a bit this behaviour by using `quarkus.vault.health.standbyok` and `quarkus.vault.health.perfstandbyok` to `true` in your `application.properties`.\n+\n+standbyok:: Specifies if being a standby should still return the active status code instead of the standby status code.\n+\n+perfstandbyok:: Specifies if being a performance standby should still return the active status code instead of the performance standby status code.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1191785e67b1bfefa6e4781e17fbaf0cc342b1b9"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU0OTQwOA==", "bodyText": "Oh yes sorry I changed everything and I miss this", "url": "https://github.com/quarkusio/quarkus/pull/8014#discussion_r398549408", "createdAt": "2020-03-26T12:55:50Z", "author": {"login": "lordofthejars"}, "path": "docs/src/main/asciidoc/vault.adoc", "diffHunk": "@@ -497,6 +497,27 @@ You should see:\n {password=connor}\n ----\n \n+== Vault Health Check\n+\n+If you are using the `quarkus-smallrye-health` extension, `quarkus-vault` can add a readiness health check\n+to validate the connection to the Vault server. This is disabled by default.\n+\n+If enabled, when you access the `/health/ready` endpoint of your application you will have information about the connection validation status.\n+\n+This behavior can be enabled by setting the `quarkus.vault.health.enabled` property to `true` in your `application.properties`.\n+\n+Only if Vault is initialized, unsealed and active, the health endpoint returns that Vault is ready to serve requests.\n+\n+You can change a bit this behaviour by using `quarkus.vault.health.standbyok` and `quarkus.vault.health.perfstandbyok` to `true` in your `application.properties`.\n+\n+standbyok:: Specifies if being a standby should still return the active status code instead of the standby status code.\n+\n+perfstandbyok:: Specifies if being a performance standby should still return the active status code instead of the performance standby status code.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU0MTc3Mg=="}, "originalCommit": {"oid": "1191785e67b1bfefa6e4781e17fbaf0cc342b1b9"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4768, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}