{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4Mzg2ODE0", "number": 8813, "title": "Cache bytecode recording proxies", "bodyText": "", "createdAt": "2020-04-24T07:45:51Z", "url": "https://github.com/quarkusio/quarkus/pull/8813", "merged": true, "mergeCommit": {"oid": "02e481fca61507bd730280a23347d8ab224e3a60"}, "closed": true, "closedAt": "2020-05-01T12:58:52Z", "author": {"login": "stuartwdouglas"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcasnLqABqjMyNjgyMzg1OTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcdBRW4gFqTQwNDE0NjMwMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "319d3b98527782e799e3c56ccdf8e5b1cd232301", "author": {"user": {"login": "stuartwdouglas", "name": "Stuart Douglas"}}, "url": "https://github.com/quarkusio/quarkus/commit/319d3b98527782e799e3c56ccdf8e5b1cd232301", "committedDate": "2020-04-24T07:45:33Z", "message": "Cache bytecode recording proxies"}, "afterCommit": {"oid": "b430930138ad5c59bf669376e0c01707b4d83dcf", "author": {"user": {"login": "stuartwdouglas", "name": "Stuart Douglas"}}, "url": "https://github.com/quarkusio/quarkus/commit/b430930138ad5c59bf669376e0c01707b4d83dcf", "committedDate": "2020-04-24T07:46:32Z", "message": "Cache bytecode recording proxies"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b430930138ad5c59bf669376e0c01707b4d83dcf", "author": {"user": {"login": "stuartwdouglas", "name": "Stuart Douglas"}}, "url": "https://github.com/quarkusio/quarkus/commit/b430930138ad5c59bf669376e0c01707b4d83dcf", "committedDate": "2020-04-24T07:46:32Z", "message": "Cache bytecode recording proxies"}, "afterCommit": {"oid": "e3d028085666f9ae60a024a05d3ebb455e86075a", "author": {"user": {"login": "stuartwdouglas", "name": "Stuart Douglas"}}, "url": "https://github.com/quarkusio/quarkus/commit/e3d028085666f9ae60a024a05d3ebb455e86075a", "committedDate": "2020-04-24T07:54:14Z", "message": "Cache bytecode recording proxies"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba24b380be946fda461a516e7385be21b9b2c291", "author": {"user": {"login": "stuartwdouglas", "name": "Stuart Douglas"}}, "url": "https://github.com/quarkusio/quarkus/commit/ba24b380be946fda461a516e7385be21b9b2c291", "committedDate": "2020-04-24T12:32:21Z", "message": "Cache bytecode recording proxies"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e3d028085666f9ae60a024a05d3ebb455e86075a", "author": {"user": {"login": "stuartwdouglas", "name": "Stuart Douglas"}}, "url": "https://github.com/quarkusio/quarkus/commit/e3d028085666f9ae60a024a05d3ebb455e86075a", "committedDate": "2020-04-24T07:54:14Z", "message": "Cache bytecode recording proxies"}, "afterCommit": {"oid": "ba24b380be946fda461a516e7385be21b9b2c291", "author": {"user": {"login": "stuartwdouglas", "name": "Stuart Douglas"}}, "url": "https://github.com/quarkusio/quarkus/commit/ba24b380be946fda461a516e7385be21b9b2c291", "committedDate": "2020-04-24T12:32:21Z", "message": "Cache bytecode recording proxies"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMzgyNjIw", "url": "https://github.com/quarkusio/quarkus/pull/8813#pullrequestreview-400382620", "createdAt": "2020-04-25T10:55:45Z", "commit": {"oid": "ba24b380be946fda461a516e7385be21b9b2c291"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxMDo1NTo0NlrOGLz6Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQxMDo1NTo0NlrOGLz6Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAzNzk5NA==", "bodyText": "It's minor but wouldn't we want a stable name here too?", "url": "https://github.com/quarkusio/quarkus/pull/8813#discussion_r415037994", "createdAt": "2020-04-25T10:55:46Z", "author": {"login": "gsmet"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/recording/BytecodeRecorderImpl.java", "diffHunk": "@@ -224,60 +227,66 @@ private static boolean isProxiable(Class<?> returnType) {\n         if (existingProxyClasses.containsKey(theClass)) {\n             return theClass.cast(existingProxyClasses.get(theClass));\n         }\n-        String proxyNameSuffix = \"$$RecordingProxyProxy\" + COUNT.incrementAndGet();\n \n-        ProxyConfiguration<T> proxyConfiguration = new ProxyConfiguration<T>()\n-                .setSuperClass(theClass)\n-                .setClassLoader(classLoader)\n-                .setAnchorClass(getClass())\n-                .setProxyNameSuffix(proxyNameSuffix);\n-        String proxyName = proxyConfiguration.getProxyName();\n-        ProxyFactory<T> factory = new ProxyFactory<T>(proxyConfiguration);\n-        try {\n-            T recordingProxy = factory.newInstance(new InvocationHandler() {\n-                @Override\n-                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n-                    if (staticInit) {\n-                        for (int i = 0; i < args.length; ++i) {\n-                            if (args[i] instanceof ReturnedProxy) {\n-                                ReturnedProxy p = (ReturnedProxy) args[i];\n-                                if (!p.__static$$init()) {\n-                                    throw new RuntimeException(\"Invalid proxy passed to recorder. Parameter \" + i + \" of type \"\n-                                            + method.getParameterTypes()[i]\n-                                            + \" was created in a runtime recorder method, while this recorder is for a static init method. The object will not have been created at the time this method is run.\");\n-                                }\n+        InvocationHandler invocationHandler = new InvocationHandler() {\n+            @Override\n+            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+                if (staticInit) {\n+                    for (int i = 0; i < args.length; ++i) {\n+                        if (args[i] instanceof ReturnedProxy) {\n+                            ReturnedProxy p = (ReturnedProxy) args[i];\n+                            if (!p.__static$$init()) {\n+                                throw new RuntimeException(\"Invalid proxy passed to recorder. Parameter \" + i + \" of type \"\n+                                        + method.getParameterTypes()[i]\n+                                        + \" was created in a runtime recorder method, while this recorder is for a static init method. The object will not have been created at the time this method is run.\");\n                             }\n                         }\n                     }\n-                    StoredMethodCall storedMethodCall = new StoredMethodCall(theClass, method, args);\n-                    storedMethodCalls.add(storedMethodCall);\n-                    Class<?> returnType = method.getReturnType();\n-                    if (method.getName().equals(\"toString\")\n-                            && method.getParameterTypes().length == 0\n-                            && returnType.equals(String.class)) {\n-                        return proxyName;\n-                    }\n-\n-                    boolean voidMethod = method.getReturnType().equals(void.class);\n-                    if (!voidMethod && !isProxiable(method.getReturnType())) {\n-                        throw new RuntimeException(\"Cannot use \" + method\n-                                + \" as a recorder method as the return type cannot be proxied. Use RuntimeValue to wrap the return value instead.\");\n-                    }\n-                    if (voidMethod) {\n-                        return null;\n-                    }\n-                    ProxyInstance instance = getProxyInstance(returnType);\n-                    if (instance == null) {\n-                        return null;\n-                    }\n+                }\n+                StoredMethodCall storedMethodCall = new StoredMethodCall(theClass, method, args);\n+                storedMethodCalls.add(storedMethodCall);\n+                Class<?> returnType = method.getReturnType();\n+                if (method.getName().equals(\"toString\")\n+                        && method.getParameterTypes().length == 0\n+                        && returnType.equals(String.class)) {\n+                    return proxy.getClass().getName();\n+                }\n \n-                    storedMethodCall.returnedProxy = instance.proxy;\n-                    storedMethodCall.proxyId = instance.key;\n-                    return instance.proxy;\n+                boolean voidMethod = method.getReturnType().equals(void.class);\n+                if (!voidMethod && !isProxiable(method.getReturnType())) {\n+                    throw new RuntimeException(\"Cannot use \" + method\n+                            + \" as a recorder method as the return type cannot be proxied. Use RuntimeValue to wrap the return value instead.\");\n+                }\n+                if (voidMethod) {\n+                    return null;\n+                }\n+                ProxyInstance instance = getProxyInstance(returnType);\n+                if (instance == null) {\n+                    return null;\n                 }\n \n-            });\n+                storedMethodCall.returnedProxy = instance.proxy;\n+                storedMethodCall.proxyId = instance.key;\n+                return instance.proxy;\n+            }\n+\n+        };\n+\n+        try {\n+            if (recordingProxyFactories.containsKey(theClass)) {\n+                return (T) recordingProxyFactories.get(theClass).newInstance(invocationHandler);\n+            }\n+            String proxyNameSuffix = \"$$RecordingProxyProxy\" + COUNT.incrementAndGet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba24b380be946fda461a516e7385be21b9b2c291"}, "originalPosition": 122}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0MTQ2MzAy", "url": "https://github.com/quarkusio/quarkus/pull/8813#pullrequestreview-404146302", "createdAt": "2020-05-01T12:58:45Z", "commit": {"oid": "ba24b380be946fda461a516e7385be21b9b2c291"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4509, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}