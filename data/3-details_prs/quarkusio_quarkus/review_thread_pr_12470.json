{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk2NzQ1ODky", "number": 12470, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDowMzozMFrOEp04Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDowMzozMFrOEp04Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjkzNDM5OnYy", "diffSide": "RIGHT", "path": "extensions/smallrye-reactive-messaging/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/deployment/SmallRyeReactiveMessagingProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDowMzozMFrOHbu5QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDo0MjoyOFrOHbwUJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0MTkyMQ==", "bodyText": "As this is being used to retrieve the blocking annotation as well, maybe rename to getAnnotation and change onOverflowAnnotation to onAnnotation?", "url": "https://github.com/quarkusio/quarkus/pull/12470#discussion_r498841921", "createdAt": "2020-10-02T14:03:30Z", "author": {"login": "kenfinnigan"}, "path": "extensions/smallrye-reactive-messaging/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/deployment/SmallRyeReactiveMessagingProcessor.java", "diffHunk": "@@ -221,27 +201,37 @@ void validateBeanDeployment(\n                                             .getTargetInfo()));\n                 } else {\n                     String channelName = instance.value().asString();\n-                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n-                            .stream()\n-                            .filter(ai -> ReactiveMessagingDotNames.LEGACY_ON_OVERFLOW\n-                                    .equals(ai.name()))\n-                            .filter(ai -> {\n-                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n-                                        .isParam()) {\n-                                    return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n-                                }\n-                                return true;\n-                            })\n-                            .findAny();\n+                    Optional<AnnotationInstance> overflow = getOverflow(annotationStore, injectionPoint,\n+                            ReactiveMessagingDotNames.LEGACY_ON_OVERFLOW);\n \n                     createEmitter(emitters, injectionPoint, channelName, overflow, broadcast);\n                 }\n             }\n         }\n     }\n \n+    private Optional<AnnotationInstance> getOverflow(AnnotationStore annotationStore, InjectionPointInfo injectionPoint,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45bd6b444d701883314a34959b64b25582d9c884"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg2NTE5MQ==", "bodyText": "Fixed and rebased.", "url": "https://github.com/quarkusio/quarkus/pull/12470#discussion_r498865191", "createdAt": "2020-10-02T14:42:28Z", "author": {"login": "cescoffier"}, "path": "extensions/smallrye-reactive-messaging/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/deployment/SmallRyeReactiveMessagingProcessor.java", "diffHunk": "@@ -221,27 +201,37 @@ void validateBeanDeployment(\n                                             .getTargetInfo()));\n                 } else {\n                     String channelName = instance.value().asString();\n-                    Optional<AnnotationInstance> overflow = annotationStore.getAnnotations(injectionPoint.getTarget())\n-                            .stream()\n-                            .filter(ai -> ReactiveMessagingDotNames.LEGACY_ON_OVERFLOW\n-                                    .equals(ai.name()))\n-                            .filter(ai -> {\n-                                if (ai.target().kind() == AnnotationTarget.Kind.METHOD_PARAMETER && injectionPoint\n-                                        .isParam()) {\n-                                    return ai.target().asMethodParameter().position() == injectionPoint.getPosition();\n-                                }\n-                                return true;\n-                            })\n-                            .findAny();\n+                    Optional<AnnotationInstance> overflow = getOverflow(annotationStore, injectionPoint,\n+                            ReactiveMessagingDotNames.LEGACY_ON_OVERFLOW);\n \n                     createEmitter(emitters, injectionPoint, channelName, overflow, broadcast);\n                 }\n             }\n         }\n     }\n \n+    private Optional<AnnotationInstance> getOverflow(AnnotationStore annotationStore, InjectionPointInfo injectionPoint,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0MTkyMQ=="}, "originalCommit": {"oid": "45bd6b444d701883314a34959b64b25582d9c884"}, "originalPosition": 94}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4344, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}