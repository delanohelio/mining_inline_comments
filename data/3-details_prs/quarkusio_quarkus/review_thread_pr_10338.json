{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxMzk0MTMx", "number": 10338, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMjo0Njo0NVrOEKFIHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMjo1ODoxMFrOEKFZTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDA1MjEzOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/scheduler-reference.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMjo0Njo0NVrOGq6pIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMjo0Njo0NVrOGq6pIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY1NDE3Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `quarkus-scheduler` extension brings the API and and a lightweight in-memory scheduler implementation.\n          \n          \n            \n            The `quarkus-scheduler` extension brings the API and a lightweight in-memory scheduler implementation.", "url": "https://github.com/quarkusio/quarkus/pull/10338#discussion_r447654176", "createdAt": "2020-06-30T12:46:45Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/scheduler-reference.adoc", "diffHunk": "@@ -0,0 +1,219 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Scheduler Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+Modern applications often need to run specific tasks periodically.\n+There are two scheduler extensions in Quarkus.\n+The `quarkus-scheduler` extension brings the API and and a lightweight in-memory scheduler implementation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71029ffa1b4184a7be4e6cb5ed7c6b5ac8194659"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDA1NzM0OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/scheduler-reference.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMjo0ODowNFrOGq6sLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNDowNDowOFrOGq996Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY1NDk1OA==", "bodyText": "Should we raise a warning in this case?", "url": "https://github.com/quarkusio/quarkus/pull/10338#discussion_r447654958", "createdAt": "2020-06-30T12:48:04Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/scheduler-reference.adoc", "diffHunk": "@@ -0,0 +1,219 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Scheduler Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+Modern applications often need to run specific tasks periodically.\n+There are two scheduler extensions in Quarkus.\n+The `quarkus-scheduler` extension brings the API and and a lightweight in-memory scheduler implementation.\n+The `quarkus-quartz` extension implements the API from the `quarkus-scheduler` extension and contains a scheduler implementation based on the Quartz library.\n+You will only need `quarkus-quartz` for more advanced scheduling use cases, such as persistent tasks, clustering and programmatic scheduling of jobs.\n+\n+NOTE: If you add the `quarkus-quartz` dependency to your project the lightweight scheduler implementation from the `quarkus-scheduler` extension is automatically disabled. \n+\n+== Scheduled Methods\n+\n+If you annotate a method with `@io.quarkus.scheduler.Scheduled` it is automatically scheduled for invocation.\n+In fact, such a method must be a non-private non-static method of a CDI bean. \n+As a consequence of being a method of a CDI bean a scheduled method can be annotated with interceptor bindings, such as `@javax.transaction.Transactional` and `@org.eclipse.microprofile.metrics.annotation.Counted`.\n+\n+NOTE: If there is no CDI scope defined on the declaring class then `@Singleton` is used. \n+\n+Furthermore, the annotated method must return `void` and either declare no parameters or one parameter of type `io.quarkus.scheduler.ScheduledExecution`.\n+\n+TIP: The annotation is repeatable so a single method could be scheduled multiple times.\n+\n+=== Triggers\n+\n+A trigger is defined either by the `@Scheduled#cron()` or by the `@Scheduled#every()` attributes.\n+If both are specified, the cron expression takes precedence.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71029ffa1b4184a7be4e6cb5ed7c6b5ac8194659"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcwODY0OQ==", "bodyText": "That's a good point.", "url": "https://github.com/quarkusio/quarkus/pull/10338#discussion_r447708649", "createdAt": "2020-06-30T14:04:08Z", "author": {"login": "mkouba"}, "path": "docs/src/main/asciidoc/scheduler-reference.adoc", "diffHunk": "@@ -0,0 +1,219 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Scheduler Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+Modern applications often need to run specific tasks periodically.\n+There are two scheduler extensions in Quarkus.\n+The `quarkus-scheduler` extension brings the API and and a lightweight in-memory scheduler implementation.\n+The `quarkus-quartz` extension implements the API from the `quarkus-scheduler` extension and contains a scheduler implementation based on the Quartz library.\n+You will only need `quarkus-quartz` for more advanced scheduling use cases, such as persistent tasks, clustering and programmatic scheduling of jobs.\n+\n+NOTE: If you add the `quarkus-quartz` dependency to your project the lightweight scheduler implementation from the `quarkus-scheduler` extension is automatically disabled. \n+\n+== Scheduled Methods\n+\n+If you annotate a method with `@io.quarkus.scheduler.Scheduled` it is automatically scheduled for invocation.\n+In fact, such a method must be a non-private non-static method of a CDI bean. \n+As a consequence of being a method of a CDI bean a scheduled method can be annotated with interceptor bindings, such as `@javax.transaction.Transactional` and `@org.eclipse.microprofile.metrics.annotation.Counted`.\n+\n+NOTE: If there is no CDI scope defined on the declaring class then `@Singleton` is used. \n+\n+Furthermore, the annotated method must return `void` and either declare no parameters or one parameter of type `io.quarkus.scheduler.ScheduledExecution`.\n+\n+TIP: The annotation is repeatable so a single method could be scheduled multiple times.\n+\n+=== Triggers\n+\n+A trigger is defined either by the `@Scheduled#cron()` or by the `@Scheduled#every()` attributes.\n+If both are specified, the cron expression takes precedence.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY1NDk1OA=="}, "originalCommit": {"oid": "71029ffa1b4184a7be4e6cb5ed7c6b5ac8194659"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDA2OTIwOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/scheduler-reference.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMjo1MTowN1rOGq6zXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMjo1MTowN1rOGq6zXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY1Njc5OA==", "bodyText": "Maybe we should raise a warning too?", "url": "https://github.com/quarkusio/quarkus/pull/10338#discussion_r447656798", "createdAt": "2020-06-30T12:51:07Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/scheduler-reference.adoc", "diffHunk": "@@ -0,0 +1,219 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Scheduler Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+Modern applications often need to run specific tasks periodically.\n+There are two scheduler extensions in Quarkus.\n+The `quarkus-scheduler` extension brings the API and and a lightweight in-memory scheduler implementation.\n+The `quarkus-quartz` extension implements the API from the `quarkus-scheduler` extension and contains a scheduler implementation based on the Quartz library.\n+You will only need `quarkus-quartz` for more advanced scheduling use cases, such as persistent tasks, clustering and programmatic scheduling of jobs.\n+\n+NOTE: If you add the `quarkus-quartz` dependency to your project the lightweight scheduler implementation from the `quarkus-scheduler` extension is automatically disabled. \n+\n+== Scheduled Methods\n+\n+If you annotate a method with `@io.quarkus.scheduler.Scheduled` it is automatically scheduled for invocation.\n+In fact, such a method must be a non-private non-static method of a CDI bean. \n+As a consequence of being a method of a CDI bean a scheduled method can be annotated with interceptor bindings, such as `@javax.transaction.Transactional` and `@org.eclipse.microprofile.metrics.annotation.Counted`.\n+\n+NOTE: If there is no CDI scope defined on the declaring class then `@Singleton` is used. \n+\n+Furthermore, the annotated method must return `void` and either declare no parameters or one parameter of type `io.quarkus.scheduler.ScheduledExecution`.\n+\n+TIP: The annotation is repeatable so a single method could be scheduled multiple times.\n+\n+=== Triggers\n+\n+A trigger is defined either by the `@Scheduled#cron()` or by the `@Scheduled#every()` attributes.\n+If both are specified, the cron expression takes precedence.\n+If none is specified, the build fails with an `IllegalStateException`.\n+\n+==== CRON\n+\n+A CRON trigger is defined by a cron-like expression.\n+For example `\"0 15 10 * * ?\"` fires at 10:15am every day.\n+\n+.CRON Trigger Example\n+[source,java]\n+----\n+@Scheduled(cron = \"0 15 10 * * ?\")\n+void fireAt10AmEveryDay() { }\n+----\n+\n+The syntax used in CRON expressions is controlled by the `quarkus.scheduler.cron-type` property.\n+The values can be `cron4j`, `quartz`, `unix` and `spring`.\n+`quartz` is used by default.\n+\n+If a CRON expression starts with `{` and ends with `}` then the scheduler attempts to find a corresponding config property and use the configured value instead. \n+\n+.CRON Config Property Example\n+[source,java]\n+----\n+@Scheduled(cron = \"{myMethod.cron.expr}\")\n+void myMethod() { }\n+----\n+\n+==== Intervals\n+\n+An interval trigger defines a period between invocations.\n+The period expression is based on the ISO-8601 duration format `PnDTnHnMn.nS` and the value of `@Scheduled#every()` is parsed with `java.time.Duration#parse(CharSequence)`. \n+However, if an expression starts with a digit then the `PT` prefix is added automatically.\n+So for example, `15m` can be used instead of `PT15M` and is parsed as \"15 minutes\".\n+\n+.Interval Trigger Example\n+[source,java]\n+----\n+@Scheduled(every = \"15m\")\n+void every15Mins() { }\n+----\n+\n+If a value starts with `{` and ends with `}` then the scheduler attempts to find a corresponding config property and use the configured value instead.\n+\n+.Interval Config Property Example\n+[source,java]\n+----\n+@Scheduled(every = \"{myMethod.every.expr}\")\n+void myMethod() { }\n+----\n+\n+=== Identity\n+\n+By default, a unique id is generated for each scheduled method.\n+This id is used in log messages and during debugging.\n+Sometimes a possibility to specify an explicit id may come in handy.\n+\n+.Identity Example\n+[source,java]\n+----\n+@Scheduled(identity = \"myScheduledMethod\")\n+void myMethod() { }\n+----\n+\n+=== Delayed Execution\n+\n+`@Scheduled` provides two ways to delay the time a trigger should start firing at.\n+\n+`@Scheduled#delay()` and `@Scheduled#delayUnit()` form the initial delay together.\n+\n+[source,java]\n+----\n+@Scheduled(every = \"2s\", delay = 2, delayUnit = TimeUnit.HOUR) <1>\n+void everyTwoSeconds() { }\n+----\n+<1> The trigger fires for the first time two hours after the application start.\n+\n+NOTE: The final value is always rounded to full second.\n+\n+`@Scheduled#delayed()` is a text alternative to the properties above.\n+The period expression is based on the ISO-8601 duration format `PnDTnHnMn.nS` and the value is parsed with `java.time.Duration#parse(CharSequence)`. \n+However, if an expression starts with a digit, the `PT` prefix is added automatically.\n+So for example, `15s` can be used instead of `PT15S` and is parsed as \"15 seconds\".\n+\n+[source,java]\n+----\n+@Scheduled(every = \"2s\", delayed = \"2h\")\n+void everyTwoSeconds() { }\n+----\n+\n+NOTE: If `@Scheduled#delay()` is set to a value greater then zero the value of `@Scheduled#delayed()` is ignored.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71029ffa1b4184a7be4e6cb5ed7c6b5ac8194659"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDA3NDMyOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/scheduler-reference.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMjo1MjoyOFrOGq62iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMjo1MjoyOFrOGq62iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY1NzYxMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can even disable scheduler for particular <<getting-started-testing#testing_different_profiles,Test Profiles>>.\n          \n          \n            \n            You can even disable the scheduler for particular <<getting-started-testing#testing_different_profiles,Test Profiles>>.", "url": "https://github.com/quarkusio/quarkus/pull/10338#discussion_r447657611", "createdAt": "2020-06-30T12:52:28Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/scheduler-reference.adoc", "diffHunk": "@@ -0,0 +1,219 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Scheduler Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+Modern applications often need to run specific tasks periodically.\n+There are two scheduler extensions in Quarkus.\n+The `quarkus-scheduler` extension brings the API and and a lightweight in-memory scheduler implementation.\n+The `quarkus-quartz` extension implements the API from the `quarkus-scheduler` extension and contains a scheduler implementation based on the Quartz library.\n+You will only need `quarkus-quartz` for more advanced scheduling use cases, such as persistent tasks, clustering and programmatic scheduling of jobs.\n+\n+NOTE: If you add the `quarkus-quartz` dependency to your project the lightweight scheduler implementation from the `quarkus-scheduler` extension is automatically disabled. \n+\n+== Scheduled Methods\n+\n+If you annotate a method with `@io.quarkus.scheduler.Scheduled` it is automatically scheduled for invocation.\n+In fact, such a method must be a non-private non-static method of a CDI bean. \n+As a consequence of being a method of a CDI bean a scheduled method can be annotated with interceptor bindings, such as `@javax.transaction.Transactional` and `@org.eclipse.microprofile.metrics.annotation.Counted`.\n+\n+NOTE: If there is no CDI scope defined on the declaring class then `@Singleton` is used. \n+\n+Furthermore, the annotated method must return `void` and either declare no parameters or one parameter of type `io.quarkus.scheduler.ScheduledExecution`.\n+\n+TIP: The annotation is repeatable so a single method could be scheduled multiple times.\n+\n+=== Triggers\n+\n+A trigger is defined either by the `@Scheduled#cron()` or by the `@Scheduled#every()` attributes.\n+If both are specified, the cron expression takes precedence.\n+If none is specified, the build fails with an `IllegalStateException`.\n+\n+==== CRON\n+\n+A CRON trigger is defined by a cron-like expression.\n+For example `\"0 15 10 * * ?\"` fires at 10:15am every day.\n+\n+.CRON Trigger Example\n+[source,java]\n+----\n+@Scheduled(cron = \"0 15 10 * * ?\")\n+void fireAt10AmEveryDay() { }\n+----\n+\n+The syntax used in CRON expressions is controlled by the `quarkus.scheduler.cron-type` property.\n+The values can be `cron4j`, `quartz`, `unix` and `spring`.\n+`quartz` is used by default.\n+\n+If a CRON expression starts with `{` and ends with `}` then the scheduler attempts to find a corresponding config property and use the configured value instead. \n+\n+.CRON Config Property Example\n+[source,java]\n+----\n+@Scheduled(cron = \"{myMethod.cron.expr}\")\n+void myMethod() { }\n+----\n+\n+==== Intervals\n+\n+An interval trigger defines a period between invocations.\n+The period expression is based on the ISO-8601 duration format `PnDTnHnMn.nS` and the value of `@Scheduled#every()` is parsed with `java.time.Duration#parse(CharSequence)`. \n+However, if an expression starts with a digit then the `PT` prefix is added automatically.\n+So for example, `15m` can be used instead of `PT15M` and is parsed as \"15 minutes\".\n+\n+.Interval Trigger Example\n+[source,java]\n+----\n+@Scheduled(every = \"15m\")\n+void every15Mins() { }\n+----\n+\n+If a value starts with `{` and ends with `}` then the scheduler attempts to find a corresponding config property and use the configured value instead.\n+\n+.Interval Config Property Example\n+[source,java]\n+----\n+@Scheduled(every = \"{myMethod.every.expr}\")\n+void myMethod() { }\n+----\n+\n+=== Identity\n+\n+By default, a unique id is generated for each scheduled method.\n+This id is used in log messages and during debugging.\n+Sometimes a possibility to specify an explicit id may come in handy.\n+\n+.Identity Example\n+[source,java]\n+----\n+@Scheduled(identity = \"myScheduledMethod\")\n+void myMethod() { }\n+----\n+\n+=== Delayed Execution\n+\n+`@Scheduled` provides two ways to delay the time a trigger should start firing at.\n+\n+`@Scheduled#delay()` and `@Scheduled#delayUnit()` form the initial delay together.\n+\n+[source,java]\n+----\n+@Scheduled(every = \"2s\", delay = 2, delayUnit = TimeUnit.HOUR) <1>\n+void everyTwoSeconds() { }\n+----\n+<1> The trigger fires for the first time two hours after the application start.\n+\n+NOTE: The final value is always rounded to full second.\n+\n+`@Scheduled#delayed()` is a text alternative to the properties above.\n+The period expression is based on the ISO-8601 duration format `PnDTnHnMn.nS` and the value is parsed with `java.time.Duration#parse(CharSequence)`. \n+However, if an expression starts with a digit, the `PT` prefix is added automatically.\n+So for example, `15s` can be used instead of `PT15S` and is parsed as \"15 seconds\".\n+\n+[source,java]\n+----\n+@Scheduled(every = \"2s\", delayed = \"2h\")\n+void everyTwoSeconds() { }\n+----\n+\n+NOTE: If `@Scheduled#delay()` is set to a value greater then zero the value of `@Scheduled#delayed()` is ignored.\n+\n+The main advantage over `@Scheduled#delay()` is that the value is configurable.\n+If the value starts with `{` and ends with `}` then the scheduler attempts to find a corresponding config property and use the configured value instead: \n+\n+[source,java]\n+----\n+@Scheduled(every = \"2s\", delayed = \"{myMethod.delay.expr}\") <1>\n+void everyTwoSeconds() { }\n+----\n+<1> The config property `myMethod.delay.expr` is used to set the delay.\n+\n+[[concurrent_execution]]\n+=== Concurrent Execution\n+\n+By default, a scheduled method can be executed concurrently.\n+Nevertheless, it is possible to specify the strategy to handle concurrent executions via `@Scheduled#concurrentExecution()`.\n+\n+[source,java]\n+----\n+import static io.quarkus.scheduler.Scheduled.ConcurrentExection.SKIP;\n+\n+@Scheduled(every = \"1s\", concurrentExecution = SKIP) <1>\n+void nonConcurrent() {\n+  // we can be sure that this method is never executed concurrently\n+}\n+----\n+<1> Concurrent executions are skipped.\n+\n+== Scheduler\n+\n+Quarkus provides a built-in bean of type `io.quarkus.scheduler.Scheduler` that can be injected and used to pause/resume the scheduler.\n+\n+.Scheduler Injection Example\n+[source,java]\n+----\n+import io.quarkus.scheduler.Scheduler;\n+\n+class MyService {\n+\n+   @Inject\n+   Scheduler scheduler;\n+\n+   void ping() {\n+      scheduler.pause(); <1>\n+      if (scheduler.isRunning()) {\n+         throw new IllegalStateException(\"This should never happen!\");\n+      }\n+      scheduler.resume(); <2>\n+   }\n+}\n+----\n+<1> Pause all triggers.\n+<2> Resume the scheduler.\n+\n+== Programmatic Scheduling\n+\n+If you need to schedule a job programmatically you'll need to add the link:quartz[Quartz extension] and use the Quartz API direcly.\n+\n+.Programmatic Scheduling with Quartz API\n+[source,java]\n+----\n+import org.quartz.Scheduler;\n+\n+class MyJobs {\n+\n+    void onStart(@Observes StartupEvent event, Scheduler quartz) throws SchedulerException {\n+        JobDetail job = JobBuilder.newJob(SomeJob.class)\n+                .withIdentity(\"myJob\", \"myGroup\")\n+                .build();\n+        Trigger trigger = TriggerBuilder.newTrigger()\n+                .withIdentity(\"myTrigger\", \"myGroup\")\n+                .startNow()\n+                .withSchedule(SimpleScheduleBuilder.simpleSchedule()\n+                        .withIntervalInSeconds(1)\n+                        .repeatForever())\n+                .build();\n+        quartz.scheduleJob(job, trigger);\n+    }\n+}\n+----\n+\n+== Scheduled Methods and Testing\n+\n+It is often desirable to disable the scheduler when running the tests.\n+The scheduler can be disabled through the runtime config property `quarkus.scheduler.enabled`.\n+If set to `false` the scheduler is not started even though the application contains scheduled methods.\n+You can even disable scheduler for particular <<getting-started-testing#testing_different_profiles,Test Profiles>>.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71029ffa1b4184a7be4e6cb5ed7c6b5ac8194659"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDA3Njk0OnYy", "diffSide": "RIGHT", "path": "extensions/scheduler/runtime/src/main/java/io/quarkus/scheduler/Scheduled.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMjo1MzoxNVrOGq64Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMjo1MzoxNVrOGq64Uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY1ODA2Nw==", "bodyText": "ConcurrentExection -> ConcurrentExecution", "url": "https://github.com/quarkusio/quarkus/pull/10338#discussion_r447658067", "createdAt": "2020-06-30T12:53:15Z", "author": {"login": "gsmet"}, "path": "extensions/scheduler/runtime/src/main/java/io/quarkus/scheduler/Scheduled.java", "diffHunk": "@@ -104,6 +105,14 @@\n      */\n     String delayed() default \"\";\n \n+    /**\n+     * Specify the strategy to handle concurrent execution of a scheduled method. By default, a scheduled method can be executed\n+     * concurrently.\n+     * \n+     * @return the concurrent execution strategy\n+     */\n+    ConcurrentExection concurrentExecution() default PROCEED;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71029ffa1b4184a7be4e6cb5ed7c6b5ac8194659"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDA5NTEwOnYy", "diffSide": "RIGHT", "path": "extensions/scheduler/runtime/src/main/java/io/quarkus/scheduler/runtime/SkipConcurrentExecutionInvoker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMjo1Nzo1NlrOGq7DiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMjo1Nzo1NlrOGq7DiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY2MDkzNw==", "bodyText": "Just check the refactoring picked this one too.", "url": "https://github.com/quarkusio/quarkus/pull/10338#discussion_r447660937", "createdAt": "2020-06-30T12:57:56Z", "author": {"login": "gsmet"}, "path": "extensions/scheduler/runtime/src/main/java/io/quarkus/scheduler/runtime/SkipConcurrentExecutionInvoker.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package io.quarkus.scheduler.runtime;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.scheduler.Scheduled;\n+import io.quarkus.scheduler.ScheduledExecution;\n+\n+/**\n+ * A scheduled invoker wrapper that skips concurrent executions.\n+ * \n+ * @see Scheduled#concurrentExecution()\n+ * @see io.quarkus.scheduler.Scheduled.ConcurrentExection#SKIP", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71029ffa1b4184a7be4e6cb5ed7c6b5ac8194659"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDA5NjEzOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/scheduler-reference.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMjo1ODoxMFrOGq7EGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxMjo1ODoxMFrOGq7EGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY2MTA4Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import static io.quarkus.scheduler.Scheduled.ConcurrentExection.SKIP;\n          \n          \n            \n            import static io.quarkus.scheduler.Scheduled.ConcurrentExecution.SKIP;", "url": "https://github.com/quarkusio/quarkus/pull/10338#discussion_r447661082", "createdAt": "2020-06-30T12:58:10Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/scheduler-reference.adoc", "diffHunk": "@@ -0,0 +1,219 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Scheduler Reference Guide\n+\n+include::./attributes.adoc[]\n+\n+:numbered:\n+:sectnums:\n+:sectnumlevels: 4\n+:toc:\n+\n+Modern applications often need to run specific tasks periodically.\n+There are two scheduler extensions in Quarkus.\n+The `quarkus-scheduler` extension brings the API and and a lightweight in-memory scheduler implementation.\n+The `quarkus-quartz` extension implements the API from the `quarkus-scheduler` extension and contains a scheduler implementation based on the Quartz library.\n+You will only need `quarkus-quartz` for more advanced scheduling use cases, such as persistent tasks, clustering and programmatic scheduling of jobs.\n+\n+NOTE: If you add the `quarkus-quartz` dependency to your project the lightweight scheduler implementation from the `quarkus-scheduler` extension is automatically disabled. \n+\n+== Scheduled Methods\n+\n+If you annotate a method with `@io.quarkus.scheduler.Scheduled` it is automatically scheduled for invocation.\n+In fact, such a method must be a non-private non-static method of a CDI bean. \n+As a consequence of being a method of a CDI bean a scheduled method can be annotated with interceptor bindings, such as `@javax.transaction.Transactional` and `@org.eclipse.microprofile.metrics.annotation.Counted`.\n+\n+NOTE: If there is no CDI scope defined on the declaring class then `@Singleton` is used. \n+\n+Furthermore, the annotated method must return `void` and either declare no parameters or one parameter of type `io.quarkus.scheduler.ScheduledExecution`.\n+\n+TIP: The annotation is repeatable so a single method could be scheduled multiple times.\n+\n+=== Triggers\n+\n+A trigger is defined either by the `@Scheduled#cron()` or by the `@Scheduled#every()` attributes.\n+If both are specified, the cron expression takes precedence.\n+If none is specified, the build fails with an `IllegalStateException`.\n+\n+==== CRON\n+\n+A CRON trigger is defined by a cron-like expression.\n+For example `\"0 15 10 * * ?\"` fires at 10:15am every day.\n+\n+.CRON Trigger Example\n+[source,java]\n+----\n+@Scheduled(cron = \"0 15 10 * * ?\")\n+void fireAt10AmEveryDay() { }\n+----\n+\n+The syntax used in CRON expressions is controlled by the `quarkus.scheduler.cron-type` property.\n+The values can be `cron4j`, `quartz`, `unix` and `spring`.\n+`quartz` is used by default.\n+\n+If a CRON expression starts with `{` and ends with `}` then the scheduler attempts to find a corresponding config property and use the configured value instead. \n+\n+.CRON Config Property Example\n+[source,java]\n+----\n+@Scheduled(cron = \"{myMethod.cron.expr}\")\n+void myMethod() { }\n+----\n+\n+==== Intervals\n+\n+An interval trigger defines a period between invocations.\n+The period expression is based on the ISO-8601 duration format `PnDTnHnMn.nS` and the value of `@Scheduled#every()` is parsed with `java.time.Duration#parse(CharSequence)`. \n+However, if an expression starts with a digit then the `PT` prefix is added automatically.\n+So for example, `15m` can be used instead of `PT15M` and is parsed as \"15 minutes\".\n+\n+.Interval Trigger Example\n+[source,java]\n+----\n+@Scheduled(every = \"15m\")\n+void every15Mins() { }\n+----\n+\n+If a value starts with `{` and ends with `}` then the scheduler attempts to find a corresponding config property and use the configured value instead.\n+\n+.Interval Config Property Example\n+[source,java]\n+----\n+@Scheduled(every = \"{myMethod.every.expr}\")\n+void myMethod() { }\n+----\n+\n+=== Identity\n+\n+By default, a unique id is generated for each scheduled method.\n+This id is used in log messages and during debugging.\n+Sometimes a possibility to specify an explicit id may come in handy.\n+\n+.Identity Example\n+[source,java]\n+----\n+@Scheduled(identity = \"myScheduledMethod\")\n+void myMethod() { }\n+----\n+\n+=== Delayed Execution\n+\n+`@Scheduled` provides two ways to delay the time a trigger should start firing at.\n+\n+`@Scheduled#delay()` and `@Scheduled#delayUnit()` form the initial delay together.\n+\n+[source,java]\n+----\n+@Scheduled(every = \"2s\", delay = 2, delayUnit = TimeUnit.HOUR) <1>\n+void everyTwoSeconds() { }\n+----\n+<1> The trigger fires for the first time two hours after the application start.\n+\n+NOTE: The final value is always rounded to full second.\n+\n+`@Scheduled#delayed()` is a text alternative to the properties above.\n+The period expression is based on the ISO-8601 duration format `PnDTnHnMn.nS` and the value is parsed with `java.time.Duration#parse(CharSequence)`. \n+However, if an expression starts with a digit, the `PT` prefix is added automatically.\n+So for example, `15s` can be used instead of `PT15S` and is parsed as \"15 seconds\".\n+\n+[source,java]\n+----\n+@Scheduled(every = \"2s\", delayed = \"2h\")\n+void everyTwoSeconds() { }\n+----\n+\n+NOTE: If `@Scheduled#delay()` is set to a value greater then zero the value of `@Scheduled#delayed()` is ignored.\n+\n+The main advantage over `@Scheduled#delay()` is that the value is configurable.\n+If the value starts with `{` and ends with `}` then the scheduler attempts to find a corresponding config property and use the configured value instead: \n+\n+[source,java]\n+----\n+@Scheduled(every = \"2s\", delayed = \"{myMethod.delay.expr}\") <1>\n+void everyTwoSeconds() { }\n+----\n+<1> The config property `myMethod.delay.expr` is used to set the delay.\n+\n+[[concurrent_execution]]\n+=== Concurrent Execution\n+\n+By default, a scheduled method can be executed concurrently.\n+Nevertheless, it is possible to specify the strategy to handle concurrent executions via `@Scheduled#concurrentExecution()`.\n+\n+[source,java]\n+----\n+import static io.quarkus.scheduler.Scheduled.ConcurrentExection.SKIP;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71029ffa1b4184a7be4e6cb5ed7c6b5ac8194659"}, "originalPosition": 148}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2705, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}