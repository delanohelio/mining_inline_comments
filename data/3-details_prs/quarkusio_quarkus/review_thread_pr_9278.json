{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3NTY5Mjgy", "number": 9278, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoyODowMVrOD8ObOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMzoyMDozOFrOEGWLLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDc3NDk3OnYy", "diffSide": "RIGHT", "path": "bom/runtime/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoyODowMVrOGVCVYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDozODo1NVrOGVCqvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxMTUyMA==", "bodyText": "The deployment artifact should also be added to the deployment bom.", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r424711520", "createdAt": "2020-05-13T20:28:01Z", "author": {"login": "gsmet"}, "path": "bom/runtime/pom.xml", "diffHunk": "@@ -734,6 +734,11 @@\n                 <artifactId>quarkus-spring-security</artifactId>\n                 <version>${project.version}</version>\n             </dependency>\n+            <dependency>\n+                <groupId>io.quarkus</groupId>\n+                <artifactId>quarkus-spring-scheduling</artifactId>\n+                <version>${project.version}</version>\n+            </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f685c6e4ae50c7d5e02144c8230a26778d7bd9e5"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxNjk5MQ==", "bodyText": "yes, ok. Thx!", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r424716991", "createdAt": "2020-05-13T20:38:55Z", "author": {"login": "aureamunoz"}, "path": "bom/runtime/pom.xml", "diffHunk": "@@ -734,6 +734,11 @@\n                 <artifactId>quarkus-spring-security</artifactId>\n                 <version>${project.version}</version>\n             </dependency>\n+            <dependency>\n+                <groupId>io.quarkus</groupId>\n+                <artifactId>quarkus-spring-scheduling</artifactId>\n+                <version>${project.version}</version>\n+            </dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxMTUyMA=="}, "originalCommit": {"oid": "f685c6e4ae50c7d5e02144c8230a26778d7bd9e5"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDc3NjQ4OnYy", "diffSide": "RIGHT", "path": "extensions/spring-scheduling/deployment/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoyODozMFrOGVCWXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTozMjoyNVrOGVh9xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxMTc3NA==", "bodyText": "You don't need that one, it will come with the deployment dependency.", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r424711774", "createdAt": "2020-05-13T20:28:30Z", "author": {"login": "gsmet"}, "path": "extensions/spring-scheduling/deployment/pom.xml", "diffHunk": "@@ -0,0 +1,63 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <parent>\n+        <artifactId>quarkus-spring-scheduling-parent</artifactId>\n+        <groupId>io.quarkus</groupId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../</relativePath>\n+    </parent>\n+\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <artifactId>quarkus-spring-scheduling-deployment</artifactId>\n+    <name>Quarkus - Spring - Scheduling - Deployment</name>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-spring-scheduling</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-core-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-arc-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-scheduler</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f685c6e4ae50c7d5e02144c8230a26778d7bd9e5"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIyOTc2Nw==", "bodyText": "\ud83d\udc4d true", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r425229767", "createdAt": "2020-05-14T15:32:25Z", "author": {"login": "aureamunoz"}, "path": "extensions/spring-scheduling/deployment/pom.xml", "diffHunk": "@@ -0,0 +1,63 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <parent>\n+        <artifactId>quarkus-spring-scheduling-parent</artifactId>\n+        <groupId>io.quarkus</groupId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../</relativePath>\n+    </parent>\n+\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <artifactId>quarkus-spring-scheduling-deployment</artifactId>\n+    <name>Quarkus - Spring - Scheduling - Deployment</name>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-spring-scheduling</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-core-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-arc-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-scheduler</artifactId>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxMTc3NA=="}, "originalCommit": {"oid": "f685c6e4ae50c7d5e02144c8230a26778d7bd9e5"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDc3OTQwOnYy", "diffSide": "RIGHT", "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoyOToyOVrOGVCYSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDoyOToyOVrOGVCYSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxMjI2NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * A simple processor that maps annotations Spring DI annotation to CDI annotation\n          \n          \n            \n             * A simple processor that maps Spring DI annotations to Quarkus annotations", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r424712264", "createdAt": "2020-05-13T20:29:29Z", "author": {"login": "gsmet"}, "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.AnnotationsTransformerBuildItem;\n+import io.quarkus.arc.processor.AnnotationsTransformer;\n+import io.quarkus.arc.processor.DotNames;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+\n+/*\n+ * A simple processor that maps annotations Spring DI annotation to CDI annotation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f685c6e4ae50c7d5e02144c8230a26778d7bd9e5"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDc4MjgxOnYy", "diffSide": "RIGHT", "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDozMDozMlrOGVCalA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDo0MDozM1rOGVCt8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxMjg1Mg==", "bodyText": "I suppose you plan to not hardcode it?", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r424712852", "createdAt": "2020-05-13T20:30:32Z", "author": {"login": "gsmet"}, "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.AnnotationsTransformerBuildItem;\n+import io.quarkus.arc.processor.AnnotationsTransformer;\n+import io.quarkus.arc.processor.DotNames;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+\n+/*\n+ * A simple processor that maps annotations Spring DI annotation to CDI annotation\n+ * Arc's handling of annotation mapping (by creating an extra abstraction layer on top of the Jandex index)\n+ * suits this sort of handling perfectly\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    AnnotationsTransformerBuildItem buildScheduledAnnotationTransformer() {\n+        return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+            @Override\n+            public boolean appliesTo(AnnotationTarget.Kind kind) {\n+                return kind == AnnotationTarget.Kind.METHOD;\n+            }\n+\n+            @Override\n+            public void transform(TransformationContext context) {\n+                MethodInfo methodInfo = context.getTarget().asMethod();\n+                List<AnnotationInstance> collect = methodInfo.annotations().stream()\n+                        .filter(annotationInstance -> annotationInstance.name().equals(SPRING_SCHEDULED))\n+                        .collect(Collectors.toList());\n+                if (!collect.isEmpty()) {\n+                    context.transform()\n+                            .add(QUARKUS_SCHEDULED, AnnotationValue.createStringValue(\"cron\", \"0/1 * * * * ?\")).done();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f685c6e4ae50c7d5e02144c8230a26778d7bd9e5"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxNzgxMA==", "bodyText": "Of course not, I need to work on this more. It was just to put the basics in place and see if it works :-)", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r424717810", "createdAt": "2020-05-13T20:40:33Z", "author": {"login": "aureamunoz"}, "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.AnnotationsTransformerBuildItem;\n+import io.quarkus.arc.processor.AnnotationsTransformer;\n+import io.quarkus.arc.processor.DotNames;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+\n+/*\n+ * A simple processor that maps annotations Spring DI annotation to CDI annotation\n+ * Arc's handling of annotation mapping (by creating an extra abstraction layer on top of the Jandex index)\n+ * suits this sort of handling perfectly\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    AnnotationsTransformerBuildItem buildScheduledAnnotationTransformer() {\n+        return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+            @Override\n+            public boolean appliesTo(AnnotationTarget.Kind kind) {\n+                return kind == AnnotationTarget.Kind.METHOD;\n+            }\n+\n+            @Override\n+            public void transform(TransformationContext context) {\n+                MethodInfo methodInfo = context.getTarget().asMethod();\n+                List<AnnotationInstance> collect = methodInfo.annotations().stream()\n+                        .filter(annotationInstance -> annotationInstance.name().equals(SPRING_SCHEDULED))\n+                        .collect(Collectors.toList());\n+                if (!collect.isEmpty()) {\n+                    context.transform()\n+                            .add(QUARKUS_SCHEDULED, AnnotationValue.createStringValue(\"cron\", \"0/1 * * * * ?\")).done();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxMjg1Mg=="}, "originalCommit": {"oid": "f685c6e4ae50c7d5e02144c8230a26778d7bd9e5"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDc4NDY1OnYy", "diffSide": "RIGHT", "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDozMTowN1rOGVCbug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwOTo0MzoyNlrOGVUZow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxMzE0Ng==", "bodyText": "Is this annotation repeatable? If so, there's a good chance the repeatable container will need some special handling (and a test).", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r424713146", "createdAt": "2020-05-13T20:31:07Z", "author": {"login": "gsmet"}, "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.AnnotationsTransformerBuildItem;\n+import io.quarkus.arc.processor.AnnotationsTransformer;\n+import io.quarkus.arc.processor.DotNames;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+\n+/*\n+ * A simple processor that maps annotations Spring DI annotation to CDI annotation\n+ * Arc's handling of annotation mapping (by creating an extra abstraction layer on top of the Jandex index)\n+ * suits this sort of handling perfectly\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    AnnotationsTransformerBuildItem buildScheduledAnnotationTransformer() {\n+        return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+            @Override\n+            public boolean appliesTo(AnnotationTarget.Kind kind) {\n+                return kind == AnnotationTarget.Kind.METHOD;\n+            }\n+\n+            @Override\n+            public void transform(TransformationContext context) {\n+                MethodInfo methodInfo = context.getTarget().asMethod();\n+                List<AnnotationInstance> collect = methodInfo.annotations().stream()\n+                        .filter(annotationInstance -> annotationInstance.name().equals(SPRING_SCHEDULED))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f685c6e4ae50c7d5e02144c8230a26778d7bd9e5"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxODg5Ng==", "bodyText": "I don't get what do you mean. Yes, this annotation is repeatable.", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r424718896", "createdAt": "2020-05-13T20:42:38Z", "author": {"login": "aureamunoz"}, "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.AnnotationsTransformerBuildItem;\n+import io.quarkus.arc.processor.AnnotationsTransformer;\n+import io.quarkus.arc.processor.DotNames;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+\n+/*\n+ * A simple processor that maps annotations Spring DI annotation to CDI annotation\n+ * Arc's handling of annotation mapping (by creating an extra abstraction layer on top of the Jandex index)\n+ * suits this sort of handling perfectly\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    AnnotationsTransformerBuildItem buildScheduledAnnotationTransformer() {\n+        return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+            @Override\n+            public boolean appliesTo(AnnotationTarget.Kind kind) {\n+                return kind == AnnotationTarget.Kind.METHOD;\n+            }\n+\n+            @Override\n+            public void transform(TransformationContext context) {\n+                MethodInfo methodInfo = context.getTarget().asMethod();\n+                List<AnnotationInstance> collect = methodInfo.annotations().stream()\n+                        .filter(annotationInstance -> annotationInstance.name().equals(SPRING_SCHEDULED))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxMzE0Ng=="}, "originalCommit": {"oid": "f685c6e4ae50c7d5e02144c8230a26778d7bd9e5"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAwNzUyMw==", "bodyText": "@gsmet means that you will also have to handle @Schedules", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r425007523", "createdAt": "2020-05-14T09:43:26Z", "author": {"login": "geoand"}, "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.AnnotationsTransformerBuildItem;\n+import io.quarkus.arc.processor.AnnotationsTransformer;\n+import io.quarkus.arc.processor.DotNames;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+\n+/*\n+ * A simple processor that maps annotations Spring DI annotation to CDI annotation\n+ * Arc's handling of annotation mapping (by creating an extra abstraction layer on top of the Jandex index)\n+ * suits this sort of handling perfectly\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    AnnotationsTransformerBuildItem buildScheduledAnnotationTransformer() {\n+        return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+            @Override\n+            public boolean appliesTo(AnnotationTarget.Kind kind) {\n+                return kind == AnnotationTarget.Kind.METHOD;\n+            }\n+\n+            @Override\n+            public void transform(TransformationContext context) {\n+                MethodInfo methodInfo = context.getTarget().asMethod();\n+                List<AnnotationInstance> collect = methodInfo.annotations().stream()\n+                        .filter(annotationInstance -> annotationInstance.name().equals(SPRING_SCHEDULED))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxMzE0Ng=="}, "originalCommit": {"oid": "f685c6e4ae50c7d5e02144c8230a26778d7bd9e5"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NDc4NzM4OnYy", "diffSide": "RIGHT", "path": "integration-tests/spring-scheduling/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDozMjowMFrOGVCdjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMDozMjowMFrOGVCdjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxMzYxMw==", "bodyText": "This will need some cleanup.", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r424713613", "createdAt": "2020-05-13T20:32:00Z", "author": {"login": "gsmet"}, "path": "integration-tests/spring-scheduling/pom.xml", "diffHunk": "@@ -0,0 +1,125 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <artifactId>quarkus-integration-tests-parent</artifactId>\n+        <groupId>io.quarkus</groupId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../</relativePath>\n+    </parent>\n+\n+    <artifactId>quarkus-integration-test-spring-scheduling</artifactId>\n+    <name>Quarkus - Integration Tests - Spring Scheduling</name>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-resteasy</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-scheduler</artifactId>\n+        </dependency>\n+<!--        <dependency>-->\n+<!--            <groupId>io.quarkus</groupId>-->\n+<!--            <artifactId>quarkus-spring-scheduling</artifactId>-->\n+<!--        </dependency>-->\n+<!--        <dependency>-->\n+<!--            <groupId>io.quarkus</groupId>-->\n+<!--            <artifactId>quarkus-undertow</artifactId>-->\n+<!--        </dependency>-->\n+<!--        <dependency>-->\n+<!--            <groupId>io.quarkus</groupId>-->\n+<!--            <artifactId>quarkus-arc</artifactId>-->\n+<!--        </dependency>-->\n+<!--        <dependency>-->\n+<!--            <groupId>io.quarkus</groupId>-->\n+<!--            <artifactId>quarkus-spring-di</artifactId>-->\n+<!--        </dependency>-->\n+\n+<!--        &lt;!&ndash; only needed because of @RequestScope is utilized in the tests &ndash;&gt;-->\n+<!--        <dependency>-->\n+<!--            <groupId>io.quarkus</groupId>-->\n+<!--            <artifactId>quarkus-spring-web-api</artifactId>-->\n+<!--        </dependency>-->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f685c6e4ae50c7d5e02144c8230a26778d7bd9e5"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NjYyODQwOnYy", "diffSide": "RIGHT", "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringScheduledAnnotatedMethodBuildItem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwOTo0MTo0M1rOGVUVUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwOTo0MTo0M1rOGVUVUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAwNjQxOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * {@code @Scheduled}\n          \n          \n            \n             * {@code @org.springframework.scheduling.annotation.Scheduled}", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r425006418", "createdAt": "2020-05-14T09:41:43Z", "author": {"login": "geoand"}, "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringScheduledAnnotatedMethodBuildItem.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.util.Map;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.MethodInfo;\n+\n+import io.quarkus.builder.item.SimpleBuildItem;\n+\n+/**\n+ * Build Item recording all the methods that have been effectively annotated with\n+ * {@code @Scheduled}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f685c6e4ae50c7d5e02144c8230a26778d7bd9e5"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NjY0MjMzOnYy", "diffSide": "RIGHT", "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwOTo0NToxN1rOGVUeJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxODoxMDo0MFrOGVoexg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAwODY3OQ==", "bodyText": "This is a little weird TBH - Does regular Spring make a class a bean by simply annotating with @Scheduled or does it already have to be a bean (by having @Component for example)?", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r425008679", "createdAt": "2020-05-14T09:45:17Z", "author": {"login": "geoand"}, "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.AnnotationsTransformerBuildItem;\n+import io.quarkus.arc.processor.AnnotationsTransformer;\n+import io.quarkus.arc.processor.DotNames;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+\n+/*\n+ * A simple processor that maps annotations Spring DI annotation to CDI annotation\n+ * Arc's handling of annotation mapping (by creating an extra abstraction layer on top of the Jandex index)\n+ * suits this sort of handling perfectly\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    AnnotationsTransformerBuildItem buildScheduledAnnotationTransformer() {\n+        return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+            @Override\n+            public boolean appliesTo(AnnotationTarget.Kind kind) {\n+                return kind == AnnotationTarget.Kind.METHOD;\n+            }\n+\n+            @Override\n+            public void transform(TransformationContext context) {\n+                MethodInfo methodInfo = context.getTarget().asMethod();\n+                List<AnnotationInstance> collect = methodInfo.annotations().stream()\n+                        .filter(annotationInstance -> annotationInstance.name().equals(SPRING_SCHEDULED))\n+                        .collect(Collectors.toList());\n+                if (!collect.isEmpty()) {\n+                    context.transform()\n+                            .add(QUARKUS_SCHEDULED, AnnotationValue.createStringValue(\"cron\", \"0/1 * * * * ?\")).done();\n+                }\n+            }\n+        });\n+    }\n+\n+    @BuildStep\n+    public void collectSpringScheduledMethods(CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<SpringScheduledAnnotatedMethodBuildItem> scheduledBusinessMethods) {\n+\n+        Map<MethodInfo, AnnotationInstance> result = new HashMap<>();\n+\n+        // first first go through the list of annotated methods\n+        for (AnnotationInstance instance : combinedIndex.getIndex().getAnnotations(SPRING_SCHEDULED)) {\n+            if (instance.target().kind() != AnnotationTarget.Kind.METHOD) {\n+                throw new IllegalArgumentException(\"Unsupported annotation target kind \" + instance.target().kind().name());\n+            }\n+            MethodInfo methodInfo = instance.target().asMethod();\n+            result.put(methodInfo, instance);\n+            LOGGER.debugf(\"Found Spring scheduled business method %s declared on %s\", methodInfo.name(),\n+                    methodInfo.declaringClass().name());\n+        }\n+        scheduledBusinessMethods.produce(new SpringScheduledAnnotatedMethodBuildItem(result));\n+    }\n+\n+    @BuildStep\n+    void registerBeans(SpringScheduledAnnotatedMethodBuildItem methodBuildItem,\n+            BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        Map<MethodInfo, AnnotationInstance> methodToInstanceMap = methodBuildItem.getMethodToInstanceMap();\n+        Set<String> beanClasses = new HashSet<>();\n+        for (MethodInfo methodInfo : methodToInstanceMap.keySet()) {\n+            beanClasses.add(methodInfo.declaringClass().asClass().name().toString());\n+        }\n+        additionalBeans.produce(AdditionalBeanBuildItem.builder().addBeanClasses(beanClasses).setUnremovable()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f685c6e4ae50c7d5e02144c8230a26778d7bd9e5"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMzNjUxOA==", "bodyText": "Ok. No, Spring does not make a class a bean by annotating with @scheduled. It has to be already a bean in order to Spring can detect the method annotated with @scheduled.", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r425336518", "createdAt": "2020-05-14T18:10:40Z", "author": {"login": "aureamunoz"}, "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationTarget;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.AnnotationsTransformerBuildItem;\n+import io.quarkus.arc.processor.AnnotationsTransformer;\n+import io.quarkus.arc.processor.DotNames;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+\n+/*\n+ * A simple processor that maps annotations Spring DI annotation to CDI annotation\n+ * Arc's handling of annotation mapping (by creating an extra abstraction layer on top of the Jandex index)\n+ * suits this sort of handling perfectly\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    AnnotationsTransformerBuildItem buildScheduledAnnotationTransformer() {\n+        return new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {\n+            @Override\n+            public boolean appliesTo(AnnotationTarget.Kind kind) {\n+                return kind == AnnotationTarget.Kind.METHOD;\n+            }\n+\n+            @Override\n+            public void transform(TransformationContext context) {\n+                MethodInfo methodInfo = context.getTarget().asMethod();\n+                List<AnnotationInstance> collect = methodInfo.annotations().stream()\n+                        .filter(annotationInstance -> annotationInstance.name().equals(SPRING_SCHEDULED))\n+                        .collect(Collectors.toList());\n+                if (!collect.isEmpty()) {\n+                    context.transform()\n+                            .add(QUARKUS_SCHEDULED, AnnotationValue.createStringValue(\"cron\", \"0/1 * * * * ?\")).done();\n+                }\n+            }\n+        });\n+    }\n+\n+    @BuildStep\n+    public void collectSpringScheduledMethods(CombinedIndexBuildItem combinedIndex,\n+            BuildProducer<SpringScheduledAnnotatedMethodBuildItem> scheduledBusinessMethods) {\n+\n+        Map<MethodInfo, AnnotationInstance> result = new HashMap<>();\n+\n+        // first first go through the list of annotated methods\n+        for (AnnotationInstance instance : combinedIndex.getIndex().getAnnotations(SPRING_SCHEDULED)) {\n+            if (instance.target().kind() != AnnotationTarget.Kind.METHOD) {\n+                throw new IllegalArgumentException(\"Unsupported annotation target kind \" + instance.target().kind().name());\n+            }\n+            MethodInfo methodInfo = instance.target().asMethod();\n+            result.put(methodInfo, instance);\n+            LOGGER.debugf(\"Found Spring scheduled business method %s declared on %s\", methodInfo.name(),\n+                    methodInfo.declaringClass().name());\n+        }\n+        scheduledBusinessMethods.produce(new SpringScheduledAnnotatedMethodBuildItem(result));\n+    }\n+\n+    @BuildStep\n+    void registerBeans(SpringScheduledAnnotatedMethodBuildItem methodBuildItem,\n+            BuildProducer<AdditionalBeanBuildItem> additionalBeans) {\n+        Map<MethodInfo, AnnotationInstance> methodToInstanceMap = methodBuildItem.getMethodToInstanceMap();\n+        Set<String> beanClasses = new HashSet<>();\n+        for (MethodInfo methodInfo : methodToInstanceMap.keySet()) {\n+            beanClasses.add(methodInfo.declaringClass().asClass().name().toString());\n+        }\n+        additionalBeans.produce(AdditionalBeanBuildItem.builder().addBeanClasses(beanClasses).setUnremovable()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAwODY3OQ=="}, "originalCommit": {"oid": "f685c6e4ae50c7d5e02144c8230a26778d7bd9e5"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5OTA1Mjg3OnYy", "diffSide": "RIGHT", "path": "bom/deployment/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNToyMToxMVrOGdOfiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNToyMToxMVrOGdOfiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI5OTMzOQ==", "bodyText": "This (and all other occurences in pom.xml) should probably be scheduled instead of scheduling because we use quarkus-scheduled in the existing extension.", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433299339", "createdAt": "2020-06-01T15:21:11Z", "author": {"login": "geoand"}, "path": "bom/deployment/pom.xml", "diffHunk": "@@ -748,6 +748,11 @@\n                 <artifactId>quarkus-spring-cache-deployment</artifactId>\n                 <version>${project.version}</version>\n             </dependency>\n+            <dependency>\n+                <groupId>io.quarkus</groupId>\n+                <artifactId>quarkus-spring-scheduling-deployment</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac118fe30f6bd3c476cb8f15e8270344c0c721c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5OTA3MzI4OnYy", "diffSide": "RIGHT", "path": "core/deployment/src/main/java/io/quarkus/deployment/builditem/FeatureBuildItem.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNToyNjo1MlrOGdOsnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNToyNjo1MlrOGdOsnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMwMjY4NQ==", "bodyText": "This should probably be spring-scheduled", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433302685", "createdAt": "2020-06-01T15:26:52Z", "author": {"login": "geoand"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/builditem/FeatureBuildItem.java", "diffHunk": "@@ -106,6 +106,7 @@\n     public static final String SPRING_BOOT_PROPERTIES = \"spring-boot-properties\";\n     public static final String SPRING_CACHE = \"spring-cache\";\n     public static final String SPRING_CLOUD_CONFIG_CLIENT = \"spring-cloud-config-client\";\n+    public static final String SPRING_SCHEDULING = \"spring-scheduling\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac118fe30f6bd3c476cb8f15e8270344c0c721c"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5OTA4MDgyOnYy", "diffSide": "RIGHT", "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNToyODoyNFrOGdOxVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNToyODoyNFrOGdOxVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMwMzg5Mg==", "bodyText": "The comment is kind of hard to read. Can you try and make it a little better?", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433303892", "createdAt": "2020-06-01T15:28:24Z", "author": {"login": "geoand"}, "path": "extensions/spring-scheduling/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.BeanRegistrationPhaseBuildItem;\n+import io.quarkus.arc.deployment.UnremovableBeanBuildItem;\n+import io.quarkus.arc.processor.AnnotationStore;\n+import io.quarkus.arc.processor.BeanInfo;\n+import io.quarkus.arc.processor.BuildExtension;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.scheduler.deployment.ScheduledBusinessMethodItem;\n+import io.quarkus.scheduler.runtime.SchedulerContext;\n+\n+/*\n+ * A simple processor that maps annotations Spring Scheduled annotation to Quarkus annotation\n+ * Arc's handling of annotation mapping (by creating an extra abstraction layer on top of the Jandex index)\n+ * suits this sort of handling perfectly", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac118fe30f6bd3c476cb8f15e8270344c0c721c"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5OTExMDU1OnYy", "diffSide": "RIGHT", "path": "extensions/spring-scheduling/deployment/src/test/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTozMzoxNlrOGdPDng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNTozMzoxNlrOGdPDng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMwODU3NA==", "bodyText": "We don't really use underscores, can you please stick to camel case?", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433308574", "createdAt": "2020-06-01T15:33:16Z", "author": {"login": "geoand"}, "path": "extensions/spring-scheduling/deployment/src/test/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessorTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.jandex.Indexer;\n+import org.jboss.jandex.MethodInfo;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.scheduling.annotation.Scheduled;\n+\n+import io.quarkus.arc.processor.BeanArchives;\n+import io.quarkus.deployment.util.IoUtil;\n+\n+public class SpringSchedulingProcessorTest {\n+\n+    final SpringSchedulingProcessor springSchedulingProcessor = new SpringSchedulingProcessor();\n+    final IndexView index = getIndex(SpringScheduledMethodsBean.class);\n+\n+    @Test\n+    public void test_buildCronParam() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eac118fe30f6bd3c476cb8f15e8270344c0c721c"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMTIxNjkzOnYy", "diffSide": "RIGHT", "path": "extensions/spring-scheduled/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNjoxODo1MVrOGdjhfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwODoyOTozNFrOGdnb8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0MzkwMQ==", "bodyText": "What does this do?", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433643901", "createdAt": "2020-06-02T06:18:51Z", "author": {"login": "geoand"}, "path": "extensions/spring-scheduled/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.BeanRegistrationPhaseBuildItem;\n+import io.quarkus.arc.deployment.UnremovableBeanBuildItem;\n+import io.quarkus.arc.processor.AnnotationStore;\n+import io.quarkus.arc.processor.BeanInfo;\n+import io.quarkus.arc.processor.BuildExtension;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.scheduler.deployment.ScheduledBusinessMethodItem;\n+import io.quarkus.scheduler.runtime.SchedulerContext;\n+\n+/**\n+ * A simple processor that search for Spring Scheduled annotations in Beans and produce\n+ * {@code @io.quarkus.spring.scheduling.deployment.SpringScheduledAnnotatedMethodBuildItem}\n+ * to be consumed by Quarkus Scheduler extension\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+    static final DotName SPRING_SCHEDULES = DotName.createSimple(\"org.springframework.scheduling.annotation.Schedules\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    public List<UnremovableBeanBuildItem> unremovableBeans() {\n+        // Beans annotated with @Scheduled should never be removed\n+        return Arrays.asList(\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULED)),\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULES)));\n+    }\n+\n+    @BuildStep\n+    void collectScheduledMethods(BeanRegistrationPhaseBuildItem beanRegistrationPhase,\n+            BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods) {\n+\n+        Map<MethodInfo, AnnotationInstance> result = new HashMap<>();\n+        AnnotationStore annotationStore = beanRegistrationPhase.getContext().get(BuildExtension.Key.ANNOTATION_STORE);\n+\n+        for (BeanInfo bean : beanRegistrationPhase.getContext().beans().classBeans()) {\n+            ClassInfo classInfo = bean.getTarget().get().asClass();\n+            for (MethodInfo method : classInfo.methods()) {\n+                List<AnnotationInstance> schedules = null;\n+                AnnotationInstance scheduledAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULED);\n+                if (scheduledAnnotation != null) {\n+                    schedules = Collections.singletonList(scheduledAnnotation);\n+                } else {\n+                    AnnotationInstance scheduledsAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULES);\n+                    if (scheduledsAnnotation != null) {\n+                        schedules = new ArrayList<>();\n+                        for (AnnotationInstance scheduledInstance : scheduledsAnnotation.value().asNestedArray()) {\n+                            schedules.add(scheduledInstance);\n+                        }\n+                    }\n+                }\n+                processSpringScheduledAnnotation(scheduledBusinessMethods, bean, method, schedules);\n+\n+            }\n+\n+        }\n+    }\n+\n+    void processSpringScheduledAnnotation(BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods,\n+            BeanInfo bean, MethodInfo method, List<AnnotationInstance> scheduledAnnotations) {\n+        List<AnnotationInstance> schedules = new ArrayList<>();\n+        if (scheduledAnnotations != null) {\n+            for (AnnotationInstance scheduledAnnotation : scheduledAnnotations) {\n+                List<AnnotationValue> springAnnotationValues = scheduledAnnotation.values();\n+                List<AnnotationValue> confValues = new ArrayList<>();\n+                if (!springAnnotationValues.isEmpty()) {\n+                    if (annotationsValuesContain(springAnnotationValues, \"fixedRate\")\n+                            || annotationsValuesContain(springAnnotationValues, \"fixedRateString\")) {\n+                        confValues.add(buildEveryParam(springAnnotationValues));\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")\n+                                || annotationsValuesContain(springAnnotationValues, \"initialDelayString\")) {\n+                            confValues.addAll(buildDelayParams(springAnnotationValues));\n+                        }\n+\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"fixedDelay\")) {\n+                        throw new IllegalStateException(\n+                                \"Unsupported @Scheduled param fixedDelay\");\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"cron\")) {\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")) {\n+                            throw new IllegalStateException(\n+                                    \"Invalid @Scheduled method '\" + method.name()\n+                                            + \"': 'initialDelay' not supported for cron triggers\");\n+                        }\n+                        confValues.add(buildCronParam(springAnnotationValues));\n+                    }\n+\n+                }\n+                AnnotationInstance regularAnnotationInstance = AnnotationInstance.create(QUARKUS_SCHEDULED,\n+                        scheduledAnnotation.target(), confValues);\n+                schedules.add(regularAnnotationInstance);\n+            }\n+            if (schedules != null) {\n+                scheduledBusinessMethods.produce(new ScheduledBusinessMethodItem(bean, method, schedules));\n+                LOGGER.debugf(\"Found scheduled business method %s declared on %s\", method, bean);\n+            }\n+        }\n+    }\n+\n+    AnnotationValue buildCronParam(List<AnnotationValue> springAnnotationValues) {\n+        String cronExpression = getAnnotationValueByName(springAnnotationValues, \"cron\").get().asString();\n+        cronExpression = cronExpression.replace(\"${\", \"{\");\n+        return AnnotationValue.createStringValue(\"cron\", cronExpression);\n+    }\n+\n+    AnnotationValue buildEveryParam(List<AnnotationValue> springAnnotationValues) {\n+        long fixedRate = getLongValueFromParam(springAnnotationValues, \"fixedRate\");\n+        String fixedRateString;\n+        fixedRateString = Duration.ofMillis(fixedRate).toString();\n+        AnnotationValue every = AnnotationValue.createStringValue(\"every\", fixedRateString);\n+        return every;\n+    }\n+\n+    List<AnnotationValue> buildDelayParams(List<AnnotationValue> springAnnotationValues) {\n+        List<AnnotationValue> confValues = new ArrayList<>();\n+        long delay = getLongValueFromParam(springAnnotationValues, \"initialDelay\");\n+        confValues.add(AnnotationValue.createLongValue(\"delay\", delay));\n+        confValues.add(AnnotationValue.createEnumValue(\"delayUnit\",\n+                DotName.createSimple(\"java.util.concurrent.TimeUnit\"),\n+                TimeUnit.MILLISECONDS.name()));\n+        return confValues;\n+    }\n+\n+    private long getLongValueFromParam(List<AnnotationValue> springAnnotationValues, String paramName) {\n+        long paramValue = 0;\n+        String paramValueString = \"\";\n+        if (annotationsValuesContain(springAnnotationValues, paramName)) {\n+            paramValue = getAnnotationValueByName(springAnnotationValues, paramName).get().asLong();\n+        } else { //param value as String e.g. a placeholder ${value.from.conf}\n+            paramValueString = getAnnotationValueByName(springAnnotationValues, paramName + \"String\")\n+                    .get().asString();\n+            paramValueString = paramValueString.replace(\"${\", \"{\").trim();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdb890811c2da55b355b7e254e18b6f10dce5738"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5NTgzNA==", "bodyText": "It reads the value from fixedRateString and initialDelayString params in Spring @Scheduled. This params are used to read values from application.properties", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433695834", "createdAt": "2020-06-02T08:08:52Z", "author": {"login": "aureamunoz"}, "path": "extensions/spring-scheduled/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.BeanRegistrationPhaseBuildItem;\n+import io.quarkus.arc.deployment.UnremovableBeanBuildItem;\n+import io.quarkus.arc.processor.AnnotationStore;\n+import io.quarkus.arc.processor.BeanInfo;\n+import io.quarkus.arc.processor.BuildExtension;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.scheduler.deployment.ScheduledBusinessMethodItem;\n+import io.quarkus.scheduler.runtime.SchedulerContext;\n+\n+/**\n+ * A simple processor that search for Spring Scheduled annotations in Beans and produce\n+ * {@code @io.quarkus.spring.scheduling.deployment.SpringScheduledAnnotatedMethodBuildItem}\n+ * to be consumed by Quarkus Scheduler extension\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+    static final DotName SPRING_SCHEDULES = DotName.createSimple(\"org.springframework.scheduling.annotation.Schedules\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    public List<UnremovableBeanBuildItem> unremovableBeans() {\n+        // Beans annotated with @Scheduled should never be removed\n+        return Arrays.asList(\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULED)),\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULES)));\n+    }\n+\n+    @BuildStep\n+    void collectScheduledMethods(BeanRegistrationPhaseBuildItem beanRegistrationPhase,\n+            BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods) {\n+\n+        Map<MethodInfo, AnnotationInstance> result = new HashMap<>();\n+        AnnotationStore annotationStore = beanRegistrationPhase.getContext().get(BuildExtension.Key.ANNOTATION_STORE);\n+\n+        for (BeanInfo bean : beanRegistrationPhase.getContext().beans().classBeans()) {\n+            ClassInfo classInfo = bean.getTarget().get().asClass();\n+            for (MethodInfo method : classInfo.methods()) {\n+                List<AnnotationInstance> schedules = null;\n+                AnnotationInstance scheduledAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULED);\n+                if (scheduledAnnotation != null) {\n+                    schedules = Collections.singletonList(scheduledAnnotation);\n+                } else {\n+                    AnnotationInstance scheduledsAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULES);\n+                    if (scheduledsAnnotation != null) {\n+                        schedules = new ArrayList<>();\n+                        for (AnnotationInstance scheduledInstance : scheduledsAnnotation.value().asNestedArray()) {\n+                            schedules.add(scheduledInstance);\n+                        }\n+                    }\n+                }\n+                processSpringScheduledAnnotation(scheduledBusinessMethods, bean, method, schedules);\n+\n+            }\n+\n+        }\n+    }\n+\n+    void processSpringScheduledAnnotation(BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods,\n+            BeanInfo bean, MethodInfo method, List<AnnotationInstance> scheduledAnnotations) {\n+        List<AnnotationInstance> schedules = new ArrayList<>();\n+        if (scheduledAnnotations != null) {\n+            for (AnnotationInstance scheduledAnnotation : scheduledAnnotations) {\n+                List<AnnotationValue> springAnnotationValues = scheduledAnnotation.values();\n+                List<AnnotationValue> confValues = new ArrayList<>();\n+                if (!springAnnotationValues.isEmpty()) {\n+                    if (annotationsValuesContain(springAnnotationValues, \"fixedRate\")\n+                            || annotationsValuesContain(springAnnotationValues, \"fixedRateString\")) {\n+                        confValues.add(buildEveryParam(springAnnotationValues));\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")\n+                                || annotationsValuesContain(springAnnotationValues, \"initialDelayString\")) {\n+                            confValues.addAll(buildDelayParams(springAnnotationValues));\n+                        }\n+\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"fixedDelay\")) {\n+                        throw new IllegalStateException(\n+                                \"Unsupported @Scheduled param fixedDelay\");\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"cron\")) {\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")) {\n+                            throw new IllegalStateException(\n+                                    \"Invalid @Scheduled method '\" + method.name()\n+                                            + \"': 'initialDelay' not supported for cron triggers\");\n+                        }\n+                        confValues.add(buildCronParam(springAnnotationValues));\n+                    }\n+\n+                }\n+                AnnotationInstance regularAnnotationInstance = AnnotationInstance.create(QUARKUS_SCHEDULED,\n+                        scheduledAnnotation.target(), confValues);\n+                schedules.add(regularAnnotationInstance);\n+            }\n+            if (schedules != null) {\n+                scheduledBusinessMethods.produce(new ScheduledBusinessMethodItem(bean, method, schedules));\n+                LOGGER.debugf(\"Found scheduled business method %s declared on %s\", method, bean);\n+            }\n+        }\n+    }\n+\n+    AnnotationValue buildCronParam(List<AnnotationValue> springAnnotationValues) {\n+        String cronExpression = getAnnotationValueByName(springAnnotationValues, \"cron\").get().asString();\n+        cronExpression = cronExpression.replace(\"${\", \"{\");\n+        return AnnotationValue.createStringValue(\"cron\", cronExpression);\n+    }\n+\n+    AnnotationValue buildEveryParam(List<AnnotationValue> springAnnotationValues) {\n+        long fixedRate = getLongValueFromParam(springAnnotationValues, \"fixedRate\");\n+        String fixedRateString;\n+        fixedRateString = Duration.ofMillis(fixedRate).toString();\n+        AnnotationValue every = AnnotationValue.createStringValue(\"every\", fixedRateString);\n+        return every;\n+    }\n+\n+    List<AnnotationValue> buildDelayParams(List<AnnotationValue> springAnnotationValues) {\n+        List<AnnotationValue> confValues = new ArrayList<>();\n+        long delay = getLongValueFromParam(springAnnotationValues, \"initialDelay\");\n+        confValues.add(AnnotationValue.createLongValue(\"delay\", delay));\n+        confValues.add(AnnotationValue.createEnumValue(\"delayUnit\",\n+                DotName.createSimple(\"java.util.concurrent.TimeUnit\"),\n+                TimeUnit.MILLISECONDS.name()));\n+        return confValues;\n+    }\n+\n+    private long getLongValueFromParam(List<AnnotationValue> springAnnotationValues, String paramName) {\n+        long paramValue = 0;\n+        String paramValueString = \"\";\n+        if (annotationsValuesContain(springAnnotationValues, paramName)) {\n+            paramValue = getAnnotationValueByName(springAnnotationValues, paramName).get().asLong();\n+        } else { //param value as String e.g. a placeholder ${value.from.conf}\n+            paramValueString = getAnnotationValueByName(springAnnotationValues, paramName + \"String\")\n+                    .get().asString();\n+            paramValueString = paramValueString.replace(\"${\", \"{\").trim();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0MzkwMQ=="}, "originalCommit": {"oid": "cdb890811c2da55b355b7e254e18b6f10dce5738"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5ODc0Nw==", "bodyText": "I see, thanks! Do we have tests to verify both kinds of behavior?\nAlso, we need to note that in Quarkus this support is for build-time properties, not runtime properties", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433698747", "createdAt": "2020-06-02T08:13:54Z", "author": {"login": "geoand"}, "path": "extensions/spring-scheduled/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.BeanRegistrationPhaseBuildItem;\n+import io.quarkus.arc.deployment.UnremovableBeanBuildItem;\n+import io.quarkus.arc.processor.AnnotationStore;\n+import io.quarkus.arc.processor.BeanInfo;\n+import io.quarkus.arc.processor.BuildExtension;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.scheduler.deployment.ScheduledBusinessMethodItem;\n+import io.quarkus.scheduler.runtime.SchedulerContext;\n+\n+/**\n+ * A simple processor that search for Spring Scheduled annotations in Beans and produce\n+ * {@code @io.quarkus.spring.scheduling.deployment.SpringScheduledAnnotatedMethodBuildItem}\n+ * to be consumed by Quarkus Scheduler extension\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+    static final DotName SPRING_SCHEDULES = DotName.createSimple(\"org.springframework.scheduling.annotation.Schedules\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    public List<UnremovableBeanBuildItem> unremovableBeans() {\n+        // Beans annotated with @Scheduled should never be removed\n+        return Arrays.asList(\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULED)),\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULES)));\n+    }\n+\n+    @BuildStep\n+    void collectScheduledMethods(BeanRegistrationPhaseBuildItem beanRegistrationPhase,\n+            BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods) {\n+\n+        Map<MethodInfo, AnnotationInstance> result = new HashMap<>();\n+        AnnotationStore annotationStore = beanRegistrationPhase.getContext().get(BuildExtension.Key.ANNOTATION_STORE);\n+\n+        for (BeanInfo bean : beanRegistrationPhase.getContext().beans().classBeans()) {\n+            ClassInfo classInfo = bean.getTarget().get().asClass();\n+            for (MethodInfo method : classInfo.methods()) {\n+                List<AnnotationInstance> schedules = null;\n+                AnnotationInstance scheduledAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULED);\n+                if (scheduledAnnotation != null) {\n+                    schedules = Collections.singletonList(scheduledAnnotation);\n+                } else {\n+                    AnnotationInstance scheduledsAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULES);\n+                    if (scheduledsAnnotation != null) {\n+                        schedules = new ArrayList<>();\n+                        for (AnnotationInstance scheduledInstance : scheduledsAnnotation.value().asNestedArray()) {\n+                            schedules.add(scheduledInstance);\n+                        }\n+                    }\n+                }\n+                processSpringScheduledAnnotation(scheduledBusinessMethods, bean, method, schedules);\n+\n+            }\n+\n+        }\n+    }\n+\n+    void processSpringScheduledAnnotation(BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods,\n+            BeanInfo bean, MethodInfo method, List<AnnotationInstance> scheduledAnnotations) {\n+        List<AnnotationInstance> schedules = new ArrayList<>();\n+        if (scheduledAnnotations != null) {\n+            for (AnnotationInstance scheduledAnnotation : scheduledAnnotations) {\n+                List<AnnotationValue> springAnnotationValues = scheduledAnnotation.values();\n+                List<AnnotationValue> confValues = new ArrayList<>();\n+                if (!springAnnotationValues.isEmpty()) {\n+                    if (annotationsValuesContain(springAnnotationValues, \"fixedRate\")\n+                            || annotationsValuesContain(springAnnotationValues, \"fixedRateString\")) {\n+                        confValues.add(buildEveryParam(springAnnotationValues));\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")\n+                                || annotationsValuesContain(springAnnotationValues, \"initialDelayString\")) {\n+                            confValues.addAll(buildDelayParams(springAnnotationValues));\n+                        }\n+\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"fixedDelay\")) {\n+                        throw new IllegalStateException(\n+                                \"Unsupported @Scheduled param fixedDelay\");\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"cron\")) {\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")) {\n+                            throw new IllegalStateException(\n+                                    \"Invalid @Scheduled method '\" + method.name()\n+                                            + \"': 'initialDelay' not supported for cron triggers\");\n+                        }\n+                        confValues.add(buildCronParam(springAnnotationValues));\n+                    }\n+\n+                }\n+                AnnotationInstance regularAnnotationInstance = AnnotationInstance.create(QUARKUS_SCHEDULED,\n+                        scheduledAnnotation.target(), confValues);\n+                schedules.add(regularAnnotationInstance);\n+            }\n+            if (schedules != null) {\n+                scheduledBusinessMethods.produce(new ScheduledBusinessMethodItem(bean, method, schedules));\n+                LOGGER.debugf(\"Found scheduled business method %s declared on %s\", method, bean);\n+            }\n+        }\n+    }\n+\n+    AnnotationValue buildCronParam(List<AnnotationValue> springAnnotationValues) {\n+        String cronExpression = getAnnotationValueByName(springAnnotationValues, \"cron\").get().asString();\n+        cronExpression = cronExpression.replace(\"${\", \"{\");\n+        return AnnotationValue.createStringValue(\"cron\", cronExpression);\n+    }\n+\n+    AnnotationValue buildEveryParam(List<AnnotationValue> springAnnotationValues) {\n+        long fixedRate = getLongValueFromParam(springAnnotationValues, \"fixedRate\");\n+        String fixedRateString;\n+        fixedRateString = Duration.ofMillis(fixedRate).toString();\n+        AnnotationValue every = AnnotationValue.createStringValue(\"every\", fixedRateString);\n+        return every;\n+    }\n+\n+    List<AnnotationValue> buildDelayParams(List<AnnotationValue> springAnnotationValues) {\n+        List<AnnotationValue> confValues = new ArrayList<>();\n+        long delay = getLongValueFromParam(springAnnotationValues, \"initialDelay\");\n+        confValues.add(AnnotationValue.createLongValue(\"delay\", delay));\n+        confValues.add(AnnotationValue.createEnumValue(\"delayUnit\",\n+                DotName.createSimple(\"java.util.concurrent.TimeUnit\"),\n+                TimeUnit.MILLISECONDS.name()));\n+        return confValues;\n+    }\n+\n+    private long getLongValueFromParam(List<AnnotationValue> springAnnotationValues, String paramName) {\n+        long paramValue = 0;\n+        String paramValueString = \"\";\n+        if (annotationsValuesContain(springAnnotationValues, paramName)) {\n+            paramValue = getAnnotationValueByName(springAnnotationValues, paramName).get().asLong();\n+        } else { //param value as String e.g. a placeholder ${value.from.conf}\n+            paramValueString = getAnnotationValueByName(springAnnotationValues, paramName + \"String\")\n+                    .get().asString();\n+            paramValueString = paramValueString.replace(\"${\", \"{\").trim();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0MzkwMQ=="}, "originalCommit": {"oid": "cdb890811c2da55b355b7e254e18b6f10dce5738"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcwODAxNw==", "bodyText": "Yes, we have tests for both of them.\nOk, I note it for the documentation.", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433708017", "createdAt": "2020-06-02T08:29:34Z", "author": {"login": "aureamunoz"}, "path": "extensions/spring-scheduled/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.BeanRegistrationPhaseBuildItem;\n+import io.quarkus.arc.deployment.UnremovableBeanBuildItem;\n+import io.quarkus.arc.processor.AnnotationStore;\n+import io.quarkus.arc.processor.BeanInfo;\n+import io.quarkus.arc.processor.BuildExtension;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.scheduler.deployment.ScheduledBusinessMethodItem;\n+import io.quarkus.scheduler.runtime.SchedulerContext;\n+\n+/**\n+ * A simple processor that search for Spring Scheduled annotations in Beans and produce\n+ * {@code @io.quarkus.spring.scheduling.deployment.SpringScheduledAnnotatedMethodBuildItem}\n+ * to be consumed by Quarkus Scheduler extension\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+    static final DotName SPRING_SCHEDULES = DotName.createSimple(\"org.springframework.scheduling.annotation.Schedules\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    public List<UnremovableBeanBuildItem> unremovableBeans() {\n+        // Beans annotated with @Scheduled should never be removed\n+        return Arrays.asList(\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULED)),\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULES)));\n+    }\n+\n+    @BuildStep\n+    void collectScheduledMethods(BeanRegistrationPhaseBuildItem beanRegistrationPhase,\n+            BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods) {\n+\n+        Map<MethodInfo, AnnotationInstance> result = new HashMap<>();\n+        AnnotationStore annotationStore = beanRegistrationPhase.getContext().get(BuildExtension.Key.ANNOTATION_STORE);\n+\n+        for (BeanInfo bean : beanRegistrationPhase.getContext().beans().classBeans()) {\n+            ClassInfo classInfo = bean.getTarget().get().asClass();\n+            for (MethodInfo method : classInfo.methods()) {\n+                List<AnnotationInstance> schedules = null;\n+                AnnotationInstance scheduledAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULED);\n+                if (scheduledAnnotation != null) {\n+                    schedules = Collections.singletonList(scheduledAnnotation);\n+                } else {\n+                    AnnotationInstance scheduledsAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULES);\n+                    if (scheduledsAnnotation != null) {\n+                        schedules = new ArrayList<>();\n+                        for (AnnotationInstance scheduledInstance : scheduledsAnnotation.value().asNestedArray()) {\n+                            schedules.add(scheduledInstance);\n+                        }\n+                    }\n+                }\n+                processSpringScheduledAnnotation(scheduledBusinessMethods, bean, method, schedules);\n+\n+            }\n+\n+        }\n+    }\n+\n+    void processSpringScheduledAnnotation(BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods,\n+            BeanInfo bean, MethodInfo method, List<AnnotationInstance> scheduledAnnotations) {\n+        List<AnnotationInstance> schedules = new ArrayList<>();\n+        if (scheduledAnnotations != null) {\n+            for (AnnotationInstance scheduledAnnotation : scheduledAnnotations) {\n+                List<AnnotationValue> springAnnotationValues = scheduledAnnotation.values();\n+                List<AnnotationValue> confValues = new ArrayList<>();\n+                if (!springAnnotationValues.isEmpty()) {\n+                    if (annotationsValuesContain(springAnnotationValues, \"fixedRate\")\n+                            || annotationsValuesContain(springAnnotationValues, \"fixedRateString\")) {\n+                        confValues.add(buildEveryParam(springAnnotationValues));\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")\n+                                || annotationsValuesContain(springAnnotationValues, \"initialDelayString\")) {\n+                            confValues.addAll(buildDelayParams(springAnnotationValues));\n+                        }\n+\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"fixedDelay\")) {\n+                        throw new IllegalStateException(\n+                                \"Unsupported @Scheduled param fixedDelay\");\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"cron\")) {\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")) {\n+                            throw new IllegalStateException(\n+                                    \"Invalid @Scheduled method '\" + method.name()\n+                                            + \"': 'initialDelay' not supported for cron triggers\");\n+                        }\n+                        confValues.add(buildCronParam(springAnnotationValues));\n+                    }\n+\n+                }\n+                AnnotationInstance regularAnnotationInstance = AnnotationInstance.create(QUARKUS_SCHEDULED,\n+                        scheduledAnnotation.target(), confValues);\n+                schedules.add(regularAnnotationInstance);\n+            }\n+            if (schedules != null) {\n+                scheduledBusinessMethods.produce(new ScheduledBusinessMethodItem(bean, method, schedules));\n+                LOGGER.debugf(\"Found scheduled business method %s declared on %s\", method, bean);\n+            }\n+        }\n+    }\n+\n+    AnnotationValue buildCronParam(List<AnnotationValue> springAnnotationValues) {\n+        String cronExpression = getAnnotationValueByName(springAnnotationValues, \"cron\").get().asString();\n+        cronExpression = cronExpression.replace(\"${\", \"{\");\n+        return AnnotationValue.createStringValue(\"cron\", cronExpression);\n+    }\n+\n+    AnnotationValue buildEveryParam(List<AnnotationValue> springAnnotationValues) {\n+        long fixedRate = getLongValueFromParam(springAnnotationValues, \"fixedRate\");\n+        String fixedRateString;\n+        fixedRateString = Duration.ofMillis(fixedRate).toString();\n+        AnnotationValue every = AnnotationValue.createStringValue(\"every\", fixedRateString);\n+        return every;\n+    }\n+\n+    List<AnnotationValue> buildDelayParams(List<AnnotationValue> springAnnotationValues) {\n+        List<AnnotationValue> confValues = new ArrayList<>();\n+        long delay = getLongValueFromParam(springAnnotationValues, \"initialDelay\");\n+        confValues.add(AnnotationValue.createLongValue(\"delay\", delay));\n+        confValues.add(AnnotationValue.createEnumValue(\"delayUnit\",\n+                DotName.createSimple(\"java.util.concurrent.TimeUnit\"),\n+                TimeUnit.MILLISECONDS.name()));\n+        return confValues;\n+    }\n+\n+    private long getLongValueFromParam(List<AnnotationValue> springAnnotationValues, String paramName) {\n+        long paramValue = 0;\n+        String paramValueString = \"\";\n+        if (annotationsValuesContain(springAnnotationValues, paramName)) {\n+            paramValue = getAnnotationValueByName(springAnnotationValues, paramName).get().asLong();\n+        } else { //param value as String e.g. a placeholder ${value.from.conf}\n+            paramValueString = getAnnotationValueByName(springAnnotationValues, paramName + \"String\")\n+                    .get().asString();\n+            paramValueString = paramValueString.replace(\"${\", \"{\").trim();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0MzkwMQ=="}, "originalCommit": {"oid": "cdb890811c2da55b355b7e254e18b6f10dce5738"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMTIyMDM4OnYy", "diffSide": "RIGHT", "path": "extensions/spring-scheduled/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNjoyMDoxOFrOGdjjlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMTozMzowN1rOGdti2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0NDQzNw==", "bodyText": "We should have a consistent format for the error messages.  Also, we should probable use IllegalArgumentException instead of IllegalStateException", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433644437", "createdAt": "2020-06-02T06:20:18Z", "author": {"login": "geoand"}, "path": "extensions/spring-scheduled/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.BeanRegistrationPhaseBuildItem;\n+import io.quarkus.arc.deployment.UnremovableBeanBuildItem;\n+import io.quarkus.arc.processor.AnnotationStore;\n+import io.quarkus.arc.processor.BeanInfo;\n+import io.quarkus.arc.processor.BuildExtension;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.scheduler.deployment.ScheduledBusinessMethodItem;\n+import io.quarkus.scheduler.runtime.SchedulerContext;\n+\n+/**\n+ * A simple processor that search for Spring Scheduled annotations in Beans and produce\n+ * {@code @io.quarkus.spring.scheduling.deployment.SpringScheduledAnnotatedMethodBuildItem}\n+ * to be consumed by Quarkus Scheduler extension\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+    static final DotName SPRING_SCHEDULES = DotName.createSimple(\"org.springframework.scheduling.annotation.Schedules\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    public List<UnremovableBeanBuildItem> unremovableBeans() {\n+        // Beans annotated with @Scheduled should never be removed\n+        return Arrays.asList(\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULED)),\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULES)));\n+    }\n+\n+    @BuildStep\n+    void collectScheduledMethods(BeanRegistrationPhaseBuildItem beanRegistrationPhase,\n+            BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods) {\n+\n+        Map<MethodInfo, AnnotationInstance> result = new HashMap<>();\n+        AnnotationStore annotationStore = beanRegistrationPhase.getContext().get(BuildExtension.Key.ANNOTATION_STORE);\n+\n+        for (BeanInfo bean : beanRegistrationPhase.getContext().beans().classBeans()) {\n+            ClassInfo classInfo = bean.getTarget().get().asClass();\n+            for (MethodInfo method : classInfo.methods()) {\n+                List<AnnotationInstance> schedules = null;\n+                AnnotationInstance scheduledAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULED);\n+                if (scheduledAnnotation != null) {\n+                    schedules = Collections.singletonList(scheduledAnnotation);\n+                } else {\n+                    AnnotationInstance scheduledsAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULES);\n+                    if (scheduledsAnnotation != null) {\n+                        schedules = new ArrayList<>();\n+                        for (AnnotationInstance scheduledInstance : scheduledsAnnotation.value().asNestedArray()) {\n+                            schedules.add(scheduledInstance);\n+                        }\n+                    }\n+                }\n+                processSpringScheduledAnnotation(scheduledBusinessMethods, bean, method, schedules);\n+\n+            }\n+\n+        }\n+    }\n+\n+    void processSpringScheduledAnnotation(BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods,\n+            BeanInfo bean, MethodInfo method, List<AnnotationInstance> scheduledAnnotations) {\n+        List<AnnotationInstance> schedules = new ArrayList<>();\n+        if (scheduledAnnotations != null) {\n+            for (AnnotationInstance scheduledAnnotation : scheduledAnnotations) {\n+                List<AnnotationValue> springAnnotationValues = scheduledAnnotation.values();\n+                List<AnnotationValue> confValues = new ArrayList<>();\n+                if (!springAnnotationValues.isEmpty()) {\n+                    if (annotationsValuesContain(springAnnotationValues, \"fixedRate\")\n+                            || annotationsValuesContain(springAnnotationValues, \"fixedRateString\")) {\n+                        confValues.add(buildEveryParam(springAnnotationValues));\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")\n+                                || annotationsValuesContain(springAnnotationValues, \"initialDelayString\")) {\n+                            confValues.addAll(buildDelayParams(springAnnotationValues));\n+                        }\n+\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"fixedDelay\")) {\n+                        throw new IllegalStateException(\n+                                \"Unsupported @Scheduled param fixedDelay\");\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"cron\")) {\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")) {\n+                            throw new IllegalStateException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdb890811c2da55b355b7e254e18b6f10dce5738"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMTczMA==", "bodyText": "I changed the exception type and homogenized the message, wdyt @geoand", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433801730", "createdAt": "2020-06-02T11:20:29Z", "author": {"login": "aureamunoz"}, "path": "extensions/spring-scheduled/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.BeanRegistrationPhaseBuildItem;\n+import io.quarkus.arc.deployment.UnremovableBeanBuildItem;\n+import io.quarkus.arc.processor.AnnotationStore;\n+import io.quarkus.arc.processor.BeanInfo;\n+import io.quarkus.arc.processor.BuildExtension;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.scheduler.deployment.ScheduledBusinessMethodItem;\n+import io.quarkus.scheduler.runtime.SchedulerContext;\n+\n+/**\n+ * A simple processor that search for Spring Scheduled annotations in Beans and produce\n+ * {@code @io.quarkus.spring.scheduling.deployment.SpringScheduledAnnotatedMethodBuildItem}\n+ * to be consumed by Quarkus Scheduler extension\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+    static final DotName SPRING_SCHEDULES = DotName.createSimple(\"org.springframework.scheduling.annotation.Schedules\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    public List<UnremovableBeanBuildItem> unremovableBeans() {\n+        // Beans annotated with @Scheduled should never be removed\n+        return Arrays.asList(\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULED)),\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULES)));\n+    }\n+\n+    @BuildStep\n+    void collectScheduledMethods(BeanRegistrationPhaseBuildItem beanRegistrationPhase,\n+            BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods) {\n+\n+        Map<MethodInfo, AnnotationInstance> result = new HashMap<>();\n+        AnnotationStore annotationStore = beanRegistrationPhase.getContext().get(BuildExtension.Key.ANNOTATION_STORE);\n+\n+        for (BeanInfo bean : beanRegistrationPhase.getContext().beans().classBeans()) {\n+            ClassInfo classInfo = bean.getTarget().get().asClass();\n+            for (MethodInfo method : classInfo.methods()) {\n+                List<AnnotationInstance> schedules = null;\n+                AnnotationInstance scheduledAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULED);\n+                if (scheduledAnnotation != null) {\n+                    schedules = Collections.singletonList(scheduledAnnotation);\n+                } else {\n+                    AnnotationInstance scheduledsAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULES);\n+                    if (scheduledsAnnotation != null) {\n+                        schedules = new ArrayList<>();\n+                        for (AnnotationInstance scheduledInstance : scheduledsAnnotation.value().asNestedArray()) {\n+                            schedules.add(scheduledInstance);\n+                        }\n+                    }\n+                }\n+                processSpringScheduledAnnotation(scheduledBusinessMethods, bean, method, schedules);\n+\n+            }\n+\n+        }\n+    }\n+\n+    void processSpringScheduledAnnotation(BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods,\n+            BeanInfo bean, MethodInfo method, List<AnnotationInstance> scheduledAnnotations) {\n+        List<AnnotationInstance> schedules = new ArrayList<>();\n+        if (scheduledAnnotations != null) {\n+            for (AnnotationInstance scheduledAnnotation : scheduledAnnotations) {\n+                List<AnnotationValue> springAnnotationValues = scheduledAnnotation.values();\n+                List<AnnotationValue> confValues = new ArrayList<>();\n+                if (!springAnnotationValues.isEmpty()) {\n+                    if (annotationsValuesContain(springAnnotationValues, \"fixedRate\")\n+                            || annotationsValuesContain(springAnnotationValues, \"fixedRateString\")) {\n+                        confValues.add(buildEveryParam(springAnnotationValues));\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")\n+                                || annotationsValuesContain(springAnnotationValues, \"initialDelayString\")) {\n+                            confValues.addAll(buildDelayParams(springAnnotationValues));\n+                        }\n+\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"fixedDelay\")) {\n+                        throw new IllegalStateException(\n+                                \"Unsupported @Scheduled param fixedDelay\");\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"cron\")) {\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")) {\n+                            throw new IllegalStateException(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0NDQzNw=="}, "originalCommit": {"oid": "cdb890811c2da55b355b7e254e18b6f10dce5738"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwODA4OA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433808088", "createdAt": "2020-06-02T11:33:07Z", "author": {"login": "geoand"}, "path": "extensions/spring-scheduled/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.BeanRegistrationPhaseBuildItem;\n+import io.quarkus.arc.deployment.UnremovableBeanBuildItem;\n+import io.quarkus.arc.processor.AnnotationStore;\n+import io.quarkus.arc.processor.BeanInfo;\n+import io.quarkus.arc.processor.BuildExtension;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.scheduler.deployment.ScheduledBusinessMethodItem;\n+import io.quarkus.scheduler.runtime.SchedulerContext;\n+\n+/**\n+ * A simple processor that search for Spring Scheduled annotations in Beans and produce\n+ * {@code @io.quarkus.spring.scheduling.deployment.SpringScheduledAnnotatedMethodBuildItem}\n+ * to be consumed by Quarkus Scheduler extension\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+    static final DotName SPRING_SCHEDULES = DotName.createSimple(\"org.springframework.scheduling.annotation.Schedules\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    public List<UnremovableBeanBuildItem> unremovableBeans() {\n+        // Beans annotated with @Scheduled should never be removed\n+        return Arrays.asList(\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULED)),\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULES)));\n+    }\n+\n+    @BuildStep\n+    void collectScheduledMethods(BeanRegistrationPhaseBuildItem beanRegistrationPhase,\n+            BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods) {\n+\n+        Map<MethodInfo, AnnotationInstance> result = new HashMap<>();\n+        AnnotationStore annotationStore = beanRegistrationPhase.getContext().get(BuildExtension.Key.ANNOTATION_STORE);\n+\n+        for (BeanInfo bean : beanRegistrationPhase.getContext().beans().classBeans()) {\n+            ClassInfo classInfo = bean.getTarget().get().asClass();\n+            for (MethodInfo method : classInfo.methods()) {\n+                List<AnnotationInstance> schedules = null;\n+                AnnotationInstance scheduledAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULED);\n+                if (scheduledAnnotation != null) {\n+                    schedules = Collections.singletonList(scheduledAnnotation);\n+                } else {\n+                    AnnotationInstance scheduledsAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULES);\n+                    if (scheduledsAnnotation != null) {\n+                        schedules = new ArrayList<>();\n+                        for (AnnotationInstance scheduledInstance : scheduledsAnnotation.value().asNestedArray()) {\n+                            schedules.add(scheduledInstance);\n+                        }\n+                    }\n+                }\n+                processSpringScheduledAnnotation(scheduledBusinessMethods, bean, method, schedules);\n+\n+            }\n+\n+        }\n+    }\n+\n+    void processSpringScheduledAnnotation(BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods,\n+            BeanInfo bean, MethodInfo method, List<AnnotationInstance> scheduledAnnotations) {\n+        List<AnnotationInstance> schedules = new ArrayList<>();\n+        if (scheduledAnnotations != null) {\n+            for (AnnotationInstance scheduledAnnotation : scheduledAnnotations) {\n+                List<AnnotationValue> springAnnotationValues = scheduledAnnotation.values();\n+                List<AnnotationValue> confValues = new ArrayList<>();\n+                if (!springAnnotationValues.isEmpty()) {\n+                    if (annotationsValuesContain(springAnnotationValues, \"fixedRate\")\n+                            || annotationsValuesContain(springAnnotationValues, \"fixedRateString\")) {\n+                        confValues.add(buildEveryParam(springAnnotationValues));\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")\n+                                || annotationsValuesContain(springAnnotationValues, \"initialDelayString\")) {\n+                            confValues.addAll(buildDelayParams(springAnnotationValues));\n+                        }\n+\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"fixedDelay\")) {\n+                        throw new IllegalStateException(\n+                                \"Unsupported @Scheduled param fixedDelay\");\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"cron\")) {\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")) {\n+                            throw new IllegalStateException(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY0NDQzNw=="}, "originalCommit": {"oid": "cdb890811c2da55b355b7e254e18b6f10dce5738"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMTUyMTAwOnYy", "diffSide": "RIGHT", "path": "extensions/spring-scheduled/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwODowMjoyOFrOGdmeZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwODoxNzowM1rOGdm_Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5MjI2MA==", "bodyText": "@aureamunoz, IIUC correctly from your Pull Request, Spring's ability to read the cron expression from application.properties using ${} isn't supported, right? If not, is there a proper error message?\n\nYes @geoand , it is supported.", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433692260", "createdAt": "2020-06-02T08:02:28Z", "author": {"login": "aureamunoz"}, "path": "extensions/spring-scheduled/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.BeanRegistrationPhaseBuildItem;\n+import io.quarkus.arc.deployment.UnremovableBeanBuildItem;\n+import io.quarkus.arc.processor.AnnotationStore;\n+import io.quarkus.arc.processor.BeanInfo;\n+import io.quarkus.arc.processor.BuildExtension;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.scheduler.deployment.ScheduledBusinessMethodItem;\n+import io.quarkus.scheduler.runtime.SchedulerContext;\n+\n+/**\n+ * A simple processor that search for Spring Scheduled annotations in Beans and produce\n+ * {@code @io.quarkus.spring.scheduling.deployment.SpringScheduledAnnotatedMethodBuildItem}\n+ * to be consumed by Quarkus Scheduler extension\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+    static final DotName SPRING_SCHEDULES = DotName.createSimple(\"org.springframework.scheduling.annotation.Schedules\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    public List<UnremovableBeanBuildItem> unremovableBeans() {\n+        // Beans annotated with @Scheduled should never be removed\n+        return Arrays.asList(\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULED)),\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULES)));\n+    }\n+\n+    @BuildStep\n+    void collectScheduledMethods(BeanRegistrationPhaseBuildItem beanRegistrationPhase,\n+            BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods) {\n+\n+        Map<MethodInfo, AnnotationInstance> result = new HashMap<>();\n+        AnnotationStore annotationStore = beanRegistrationPhase.getContext().get(BuildExtension.Key.ANNOTATION_STORE);\n+\n+        for (BeanInfo bean : beanRegistrationPhase.getContext().beans().classBeans()) {\n+            ClassInfo classInfo = bean.getTarget().get().asClass();\n+            for (MethodInfo method : classInfo.methods()) {\n+                List<AnnotationInstance> schedules = null;\n+                AnnotationInstance scheduledAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULED);\n+                if (scheduledAnnotation != null) {\n+                    schedules = Collections.singletonList(scheduledAnnotation);\n+                } else {\n+                    AnnotationInstance scheduledsAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULES);\n+                    if (scheduledsAnnotation != null) {\n+                        schedules = new ArrayList<>();\n+                        for (AnnotationInstance scheduledInstance : scheduledsAnnotation.value().asNestedArray()) {\n+                            schedules.add(scheduledInstance);\n+                        }\n+                    }\n+                }\n+                processSpringScheduledAnnotation(scheduledBusinessMethods, bean, method, schedules);\n+\n+            }\n+\n+        }\n+    }\n+\n+    void processSpringScheduledAnnotation(BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods,\n+            BeanInfo bean, MethodInfo method, List<AnnotationInstance> scheduledAnnotations) {\n+        List<AnnotationInstance> schedules = new ArrayList<>();\n+        if (scheduledAnnotations != null) {\n+            for (AnnotationInstance scheduledAnnotation : scheduledAnnotations) {\n+                List<AnnotationValue> springAnnotationValues = scheduledAnnotation.values();\n+                List<AnnotationValue> confValues = new ArrayList<>();\n+                if (!springAnnotationValues.isEmpty()) {\n+                    if (annotationsValuesContain(springAnnotationValues, \"fixedRate\")\n+                            || annotationsValuesContain(springAnnotationValues, \"fixedRateString\")) {\n+                        confValues.add(buildEveryParam(springAnnotationValues));\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")\n+                                || annotationsValuesContain(springAnnotationValues, \"initialDelayString\")) {\n+                            confValues.addAll(buildDelayParams(springAnnotationValues));\n+                        }\n+\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"fixedDelay\")) {\n+                        throw new IllegalStateException(\n+                                \"Unsupported @Scheduled param fixedDelay\");\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"cron\")) {\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")) {\n+                            throw new IllegalStateException(\n+                                    \"Invalid @Scheduled method '\" + method.name()\n+                                            + \"': 'initialDelay' not supported for cron triggers\");\n+                        }\n+                        confValues.add(buildCronParam(springAnnotationValues));\n+                    }\n+\n+                }\n+                AnnotationInstance regularAnnotationInstance = AnnotationInstance.create(QUARKUS_SCHEDULED,\n+                        scheduledAnnotation.target(), confValues);\n+                schedules.add(regularAnnotationInstance);\n+            }\n+            if (schedules != null) {\n+                scheduledBusinessMethods.produce(new ScheduledBusinessMethodItem(bean, method, schedules));\n+                LOGGER.debugf(\"Found scheduled business method %s declared on %s\", method, bean);\n+            }\n+        }\n+    }\n+\n+    AnnotationValue buildCronParam(List<AnnotationValue> springAnnotationValues) {\n+        String cronExpression = getAnnotationValueByName(springAnnotationValues, \"cron\").get().asString();\n+        cronExpression = cronExpression.replace(\"${\", \"{\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdb890811c2da55b355b7e254e18b6f10dce5738"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5MzI1OA==", "bodyText": "Is there a test that shows this functionality? I mean adding a cron expression in application.properties and making sure that it works.", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433693258", "createdAt": "2020-06-02T08:04:14Z", "author": {"login": "geoand"}, "path": "extensions/spring-scheduled/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.BeanRegistrationPhaseBuildItem;\n+import io.quarkus.arc.deployment.UnremovableBeanBuildItem;\n+import io.quarkus.arc.processor.AnnotationStore;\n+import io.quarkus.arc.processor.BeanInfo;\n+import io.quarkus.arc.processor.BuildExtension;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.scheduler.deployment.ScheduledBusinessMethodItem;\n+import io.quarkus.scheduler.runtime.SchedulerContext;\n+\n+/**\n+ * A simple processor that search for Spring Scheduled annotations in Beans and produce\n+ * {@code @io.quarkus.spring.scheduling.deployment.SpringScheduledAnnotatedMethodBuildItem}\n+ * to be consumed by Quarkus Scheduler extension\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+    static final DotName SPRING_SCHEDULES = DotName.createSimple(\"org.springframework.scheduling.annotation.Schedules\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    public List<UnremovableBeanBuildItem> unremovableBeans() {\n+        // Beans annotated with @Scheduled should never be removed\n+        return Arrays.asList(\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULED)),\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULES)));\n+    }\n+\n+    @BuildStep\n+    void collectScheduledMethods(BeanRegistrationPhaseBuildItem beanRegistrationPhase,\n+            BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods) {\n+\n+        Map<MethodInfo, AnnotationInstance> result = new HashMap<>();\n+        AnnotationStore annotationStore = beanRegistrationPhase.getContext().get(BuildExtension.Key.ANNOTATION_STORE);\n+\n+        for (BeanInfo bean : beanRegistrationPhase.getContext().beans().classBeans()) {\n+            ClassInfo classInfo = bean.getTarget().get().asClass();\n+            for (MethodInfo method : classInfo.methods()) {\n+                List<AnnotationInstance> schedules = null;\n+                AnnotationInstance scheduledAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULED);\n+                if (scheduledAnnotation != null) {\n+                    schedules = Collections.singletonList(scheduledAnnotation);\n+                } else {\n+                    AnnotationInstance scheduledsAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULES);\n+                    if (scheduledsAnnotation != null) {\n+                        schedules = new ArrayList<>();\n+                        for (AnnotationInstance scheduledInstance : scheduledsAnnotation.value().asNestedArray()) {\n+                            schedules.add(scheduledInstance);\n+                        }\n+                    }\n+                }\n+                processSpringScheduledAnnotation(scheduledBusinessMethods, bean, method, schedules);\n+\n+            }\n+\n+        }\n+    }\n+\n+    void processSpringScheduledAnnotation(BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods,\n+            BeanInfo bean, MethodInfo method, List<AnnotationInstance> scheduledAnnotations) {\n+        List<AnnotationInstance> schedules = new ArrayList<>();\n+        if (scheduledAnnotations != null) {\n+            for (AnnotationInstance scheduledAnnotation : scheduledAnnotations) {\n+                List<AnnotationValue> springAnnotationValues = scheduledAnnotation.values();\n+                List<AnnotationValue> confValues = new ArrayList<>();\n+                if (!springAnnotationValues.isEmpty()) {\n+                    if (annotationsValuesContain(springAnnotationValues, \"fixedRate\")\n+                            || annotationsValuesContain(springAnnotationValues, \"fixedRateString\")) {\n+                        confValues.add(buildEveryParam(springAnnotationValues));\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")\n+                                || annotationsValuesContain(springAnnotationValues, \"initialDelayString\")) {\n+                            confValues.addAll(buildDelayParams(springAnnotationValues));\n+                        }\n+\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"fixedDelay\")) {\n+                        throw new IllegalStateException(\n+                                \"Unsupported @Scheduled param fixedDelay\");\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"cron\")) {\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")) {\n+                            throw new IllegalStateException(\n+                                    \"Invalid @Scheduled method '\" + method.name()\n+                                            + \"': 'initialDelay' not supported for cron triggers\");\n+                        }\n+                        confValues.add(buildCronParam(springAnnotationValues));\n+                    }\n+\n+                }\n+                AnnotationInstance regularAnnotationInstance = AnnotationInstance.create(QUARKUS_SCHEDULED,\n+                        scheduledAnnotation.target(), confValues);\n+                schedules.add(regularAnnotationInstance);\n+            }\n+            if (schedules != null) {\n+                scheduledBusinessMethods.produce(new ScheduledBusinessMethodItem(bean, method, schedules));\n+                LOGGER.debugf(\"Found scheduled business method %s declared on %s\", method, bean);\n+            }\n+        }\n+    }\n+\n+    AnnotationValue buildCronParam(List<AnnotationValue> springAnnotationValues) {\n+        String cronExpression = getAnnotationValueByName(springAnnotationValues, \"cron\").get().asString();\n+        cronExpression = cronExpression.replace(\"${\", \"{\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5MjI2MA=="}, "originalCommit": {"oid": "cdb890811c2da55b355b7e254e18b6f10dce5738"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcwMDYxNA==", "bodyText": "Yes, in SpringScheduledMethodTest.java I add the cron expression in application.properties and have a test. And SpringScheduledMethodsBean#checkEverySecondCronConfig is the method.", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r433700614", "createdAt": "2020-06-02T08:17:03Z", "author": {"login": "aureamunoz"}, "path": "extensions/spring-scheduled/deployment/src/main/java/io/quarkus/spring/scheduling/deployment/SpringSchedulingProcessor.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package io.quarkus.spring.scheduling.deployment;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;\n+import org.jboss.jandex.AnnotationInstance;\n+import org.jboss.jandex.AnnotationValue;\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.MethodInfo;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.BeanRegistrationPhaseBuildItem;\n+import io.quarkus.arc.deployment.UnremovableBeanBuildItem;\n+import io.quarkus.arc.processor.AnnotationStore;\n+import io.quarkus.arc.processor.BeanInfo;\n+import io.quarkus.arc.processor.BuildExtension;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.scheduler.deployment.ScheduledBusinessMethodItem;\n+import io.quarkus.scheduler.runtime.SchedulerContext;\n+\n+/**\n+ * A simple processor that search for Spring Scheduled annotations in Beans and produce\n+ * {@code @io.quarkus.spring.scheduling.deployment.SpringScheduledAnnotatedMethodBuildItem}\n+ * to be consumed by Quarkus Scheduler extension\n+ */\n+public class SpringSchedulingProcessor {\n+\n+    static final DotName SPRING_SCHEDULED = DotName.createSimple(\"org.springframework.scheduling.annotation.Scheduled\");\n+    static final DotName SPRING_SCHEDULES = DotName.createSimple(\"org.springframework.scheduling.annotation.Schedules\");\n+\n+    private static final DotName QUARKUS_SCHEDULED = DotName.createSimple(io.quarkus.scheduler.Scheduled.class.getName());\n+    private static final Logger LOGGER = Logger.getLogger(SpringSchedulingProcessor.class);\n+\n+    @BuildStep\n+    FeatureBuildItem registerFeature() {\n+        return new FeatureBuildItem(FeatureBuildItem.SPRING_SCHEDULING);\n+    }\n+\n+    @BuildStep\n+    public List<UnremovableBeanBuildItem> unremovableBeans() {\n+        // Beans annotated with @Scheduled should never be removed\n+        return Arrays.asList(\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULED)),\n+                new UnremovableBeanBuildItem(new UnremovableBeanBuildItem.BeanClassAnnotationExclusion(SPRING_SCHEDULES)));\n+    }\n+\n+    @BuildStep\n+    void collectScheduledMethods(BeanRegistrationPhaseBuildItem beanRegistrationPhase,\n+            BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods) {\n+\n+        Map<MethodInfo, AnnotationInstance> result = new HashMap<>();\n+        AnnotationStore annotationStore = beanRegistrationPhase.getContext().get(BuildExtension.Key.ANNOTATION_STORE);\n+\n+        for (BeanInfo bean : beanRegistrationPhase.getContext().beans().classBeans()) {\n+            ClassInfo classInfo = bean.getTarget().get().asClass();\n+            for (MethodInfo method : classInfo.methods()) {\n+                List<AnnotationInstance> schedules = null;\n+                AnnotationInstance scheduledAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULED);\n+                if (scheduledAnnotation != null) {\n+                    schedules = Collections.singletonList(scheduledAnnotation);\n+                } else {\n+                    AnnotationInstance scheduledsAnnotation = annotationStore.getAnnotation(method, SPRING_SCHEDULES);\n+                    if (scheduledsAnnotation != null) {\n+                        schedules = new ArrayList<>();\n+                        for (AnnotationInstance scheduledInstance : scheduledsAnnotation.value().asNestedArray()) {\n+                            schedules.add(scheduledInstance);\n+                        }\n+                    }\n+                }\n+                processSpringScheduledAnnotation(scheduledBusinessMethods, bean, method, schedules);\n+\n+            }\n+\n+        }\n+    }\n+\n+    void processSpringScheduledAnnotation(BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods,\n+            BeanInfo bean, MethodInfo method, List<AnnotationInstance> scheduledAnnotations) {\n+        List<AnnotationInstance> schedules = new ArrayList<>();\n+        if (scheduledAnnotations != null) {\n+            for (AnnotationInstance scheduledAnnotation : scheduledAnnotations) {\n+                List<AnnotationValue> springAnnotationValues = scheduledAnnotation.values();\n+                List<AnnotationValue> confValues = new ArrayList<>();\n+                if (!springAnnotationValues.isEmpty()) {\n+                    if (annotationsValuesContain(springAnnotationValues, \"fixedRate\")\n+                            || annotationsValuesContain(springAnnotationValues, \"fixedRateString\")) {\n+                        confValues.add(buildEveryParam(springAnnotationValues));\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")\n+                                || annotationsValuesContain(springAnnotationValues, \"initialDelayString\")) {\n+                            confValues.addAll(buildDelayParams(springAnnotationValues));\n+                        }\n+\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"fixedDelay\")) {\n+                        throw new IllegalStateException(\n+                                \"Unsupported @Scheduled param fixedDelay\");\n+                    } else if (annotationsValuesContain(springAnnotationValues, \"cron\")) {\n+                        if (annotationsValuesContain(springAnnotationValues, \"initialDelay\")) {\n+                            throw new IllegalStateException(\n+                                    \"Invalid @Scheduled method '\" + method.name()\n+                                            + \"': 'initialDelay' not supported for cron triggers\");\n+                        }\n+                        confValues.add(buildCronParam(springAnnotationValues));\n+                    }\n+\n+                }\n+                AnnotationInstance regularAnnotationInstance = AnnotationInstance.create(QUARKUS_SCHEDULED,\n+                        scheduledAnnotation.target(), confValues);\n+                schedules.add(regularAnnotationInstance);\n+            }\n+            if (schedules != null) {\n+                scheduledBusinessMethods.produce(new ScheduledBusinessMethodItem(bean, method, schedules));\n+                LOGGER.debugf(\"Found scheduled business method %s declared on %s\", method, bean);\n+            }\n+        }\n+    }\n+\n+    AnnotationValue buildCronParam(List<AnnotationValue> springAnnotationValues) {\n+        String cronExpression = getAnnotationValueByName(springAnnotationValues, \"cron\").get().asString();\n+        cronExpression = cronExpression.replace(\"${\", \"{\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5MjI2MA=="}, "originalCommit": {"oid": "cdb890811c2da55b355b7e254e18b6f10dce5738"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMzY3MDA5OnYy", "diffSide": "RIGHT", "path": "extensions/scheduler/deployment/src/test/java/io/quarkus/scheduler/test/SimpleJobs.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNzoxNzo0NlrOGd72wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMDoyOToyNFrOGeC1jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0MjU2MQ==", "bodyText": "Hm, why did you need to add this?", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r434042561", "createdAt": "2020-06-02T17:17:46Z", "author": {"login": "geoand"}, "path": "extensions/scheduler/deployment/src/test/java/io/quarkus/scheduler/test/SimpleJobs.java", "diffHunk": "@@ -4,8 +4,11 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.CountDownLatch;\n \n+import javax.enterprise.context.ApplicationScoped;\n+\n import io.quarkus.scheduler.Scheduled;\n \n+@ApplicationScoped", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de5cde5c40a0078837c112edd634bc8bfd501845"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1MjQ5Mw==", "bodyText": "It has to be a bean in order to detect the method annotated with @scheduled", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r434152493", "createdAt": "2020-06-02T20:20:19Z", "author": {"login": "aureamunoz"}, "path": "extensions/scheduler/deployment/src/test/java/io/quarkus/scheduler/test/SimpleJobs.java", "diffHunk": "@@ -4,8 +4,11 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.CountDownLatch;\n \n+import javax.enterprise.context.ApplicationScoped;\n+\n import io.quarkus.scheduler.Scheduled;\n \n+@ApplicationScoped", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0MjU2MQ=="}, "originalCommit": {"oid": "de5cde5c40a0078837c112edd634bc8bfd501845"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1MzQ4Nw==", "bodyText": "But why did you have to add it as part of the PR?\nHow did it work before?", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r434153487", "createdAt": "2020-06-02T20:22:27Z", "author": {"login": "geoand"}, "path": "extensions/scheduler/deployment/src/test/java/io/quarkus/scheduler/test/SimpleJobs.java", "diffHunk": "@@ -4,8 +4,11 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.CountDownLatch;\n \n+import javax.enterprise.context.ApplicationScoped;\n+\n import io.quarkus.scheduler.Scheduled;\n \n+@ApplicationScoped", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0MjU2MQ=="}, "originalCommit": {"oid": "de5cde5c40a0078837c112edd634bc8bfd501845"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1Njk0MA==", "bodyText": "Ah, sorry, my bad. I thought I was watching at SimpleJobs.java in spring-scheduled extension. I should have added it to test something and it slipped through the cracks :-S Let me remove it", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r434156940", "createdAt": "2020-06-02T20:29:24Z", "author": {"login": "aureamunoz"}, "path": "extensions/scheduler/deployment/src/test/java/io/quarkus/scheduler/test/SimpleJobs.java", "diffHunk": "@@ -4,8 +4,11 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.CountDownLatch;\n \n+import javax.enterprise.context.ApplicationScoped;\n+\n import io.quarkus.scheduler.Scheduled;\n \n+@ApplicationScoped", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0MjU2MQ=="}, "originalCommit": {"oid": "de5cde5c40a0078837c112edd634bc8bfd501845"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDkwMDMzOnYy", "diffSide": "RIGHT", "path": "extensions/spring-scheduled/deployment/pom.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMzoyMDowOVrOGlFXtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMzoyMDowOVrOGlFXtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUzODQ4Nw==", "bodyText": "You definitely don't need this dependency since it's brought in transitively. But this can be fixed in a follow up.", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r441538487", "createdAt": "2020-06-17T13:20:09Z", "author": {"login": "geoand"}, "path": "extensions/spring-scheduled/deployment/pom.xml", "diffHunk": "@@ -0,0 +1,64 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <parent>\n+        <artifactId>quarkus-spring-scheduled-parent</artifactId>\n+        <groupId>io.quarkus</groupId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../</relativePath>\n+    </parent>\n+\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <artifactId>quarkus-spring-scheduled-deployment</artifactId>\n+    <name>Quarkus - Spring - Scheduling - Deployment</name>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-spring-scheduled</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-core-deployment</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f6fd58c9d89edca3a5c60b7fd7c64e56063424a"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDkwMjIxOnYy", "diffSide": "RIGHT", "path": "extensions/spring-scheduled/deployment/pom.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMzoyMDozOFrOGlFY4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMzoyMDozOFrOGlFY4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUzODc4Ng==", "bodyText": "I am pretty sure that this is also brought in by quarkus-scheduler-deployment. Please check and fix in a follow up.", "url": "https://github.com/quarkusio/quarkus/pull/9278#discussion_r441538786", "createdAt": "2020-06-17T13:20:38Z", "author": {"login": "geoand"}, "path": "extensions/spring-scheduled/deployment/pom.xml", "diffHunk": "@@ -0,0 +1,64 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <parent>\n+        <artifactId>quarkus-spring-scheduled-parent</artifactId>\n+        <groupId>io.quarkus</groupId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../</relativePath>\n+    </parent>\n+\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <artifactId>quarkus-spring-scheduled-deployment</artifactId>\n+    <name>Quarkus - Spring - Scheduling - Deployment</name>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-spring-scheduled</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-core-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-arc-deployment</artifactId>\n+        </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f6fd58c9d89edca3a5c60b7fd7c64e56063424a"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3207, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}