{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3MTY2NjYw", "number": 10626, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNDo1NTo1MFrOENI5ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwNjo1MjozMVrOERtyqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjEyNzY2OnYy", "diffSide": "RIGHT", "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/metrics/HibernateMpMetricsProvider.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNDo1NTo1MFrOGvp1Ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNToyMTozMFrOGvqMjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYyMTY1MA==", "bodyText": "persistence-unit would sound more suitable to me for the tag key", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r452621650", "createdAt": "2020-07-10T04:55:50Z", "author": {"login": "jmartisk"}, "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/metrics/HibernateMpMetricsProvider.java", "diffHunk": "@@ -0,0 +1,185 @@\n+package io.quarkus.hibernate.orm.runtime.metrics;\n+\n+import java.util.function.ToLongFunction;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.Instance;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.metrics.*;\n+import org.eclipse.microprofile.metrics.annotation.RegistryType;\n+import org.hibernate.SessionFactory;\n+import org.hibernate.stat.Statistics;\n+\n+import io.quarkus.hibernate.orm.runtime.JPAConfig;\n+import io.quarkus.runtime.StartupEvent;\n+\n+/**\n+ * This is only discovered if\n+ */\n+public class HibernateMpMetricsProvider {\n+    private static final String SESSION_FACTORY_TAG_NAME = \"entityManagerFactory\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0209901a10cb064fe1fe3a464cba9202cf65737c"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYyNDUzNQ==", "bodyText": "Meh. I used what micrometer uses. Allows metrics to be aggregated across spring/micronaut/quarkus runtimes.", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r452624535", "createdAt": "2020-07-10T05:08:13Z", "author": {"login": "ebullient"}, "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/metrics/HibernateMpMetricsProvider.java", "diffHunk": "@@ -0,0 +1,185 @@\n+package io.quarkus.hibernate.orm.runtime.metrics;\n+\n+import java.util.function.ToLongFunction;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.Instance;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.metrics.*;\n+import org.eclipse.microprofile.metrics.annotation.RegistryType;\n+import org.hibernate.SessionFactory;\n+import org.hibernate.stat.Statistics;\n+\n+import io.quarkus.hibernate.orm.runtime.JPAConfig;\n+import io.quarkus.runtime.StartupEvent;\n+\n+/**\n+ * This is only discovered if\n+ */\n+public class HibernateMpMetricsProvider {\n+    private static final String SESSION_FACTORY_TAG_NAME = \"entityManagerFactory\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYyMTY1MA=="}, "originalCommit": {"oid": "0209901a10cb064fe1fe3a464cba9202cf65737c"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYyNzU5Nw==", "bodyText": "Ah, now I get it, ok then", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r452627597", "createdAt": "2020-07-10T05:21:30Z", "author": {"login": "jmartisk"}, "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/metrics/HibernateMpMetricsProvider.java", "diffHunk": "@@ -0,0 +1,185 @@\n+package io.quarkus.hibernate.orm.runtime.metrics;\n+\n+import java.util.function.ToLongFunction;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.Instance;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.metrics.*;\n+import org.eclipse.microprofile.metrics.annotation.RegistryType;\n+import org.hibernate.SessionFactory;\n+import org.hibernate.stat.Statistics;\n+\n+import io.quarkus.hibernate.orm.runtime.JPAConfig;\n+import io.quarkus.runtime.StartupEvent;\n+\n+/**\n+ * This is only discovered if\n+ */\n+public class HibernateMpMetricsProvider {\n+    private static final String SESSION_FACTORY_TAG_NAME = \"entityManagerFactory\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYyMTY1MA=="}, "originalCommit": {"oid": "0209901a10cb064fe1fe3a464cba9202cf65737c"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzQ3MTUyOnYy", "diffSide": "RIGHT", "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/metrics/HibernateMpMetricsProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMzowMzozN1rOGv2gQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNzozNzozMFrOGv_ylg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgyOTI1MA==", "bodyText": "I think there's some sentence missing?", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r452829250", "createdAt": "2020-07-10T13:03:37Z", "author": {"login": "kenfinnigan"}, "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/metrics/HibernateMpMetricsProvider.java", "diffHunk": "@@ -0,0 +1,185 @@\n+package io.quarkus.hibernate.orm.runtime.metrics;\n+\n+import java.util.function.ToLongFunction;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.Instance;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.metrics.*;\n+import org.eclipse.microprofile.metrics.annotation.RegistryType;\n+import org.hibernate.SessionFactory;\n+import org.hibernate.stat.Statistics;\n+\n+import io.quarkus.hibernate.orm.runtime.JPAConfig;\n+import io.quarkus.runtime.StartupEvent;\n+\n+/**\n+ * This is only discovered if", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "896a43d7123f96ad941d11040a026d488682797f"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk4MTM5OA==", "bodyText": "woops. indeed there is.", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r452981398", "createdAt": "2020-07-10T17:37:30Z", "author": {"login": "ebullient"}, "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/metrics/HibernateMpMetricsProvider.java", "diffHunk": "@@ -0,0 +1,185 @@\n+package io.quarkus.hibernate.orm.runtime.metrics;\n+\n+import java.util.function.ToLongFunction;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.Instance;\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.metrics.*;\n+import org.eclipse.microprofile.metrics.annotation.RegistryType;\n+import org.hibernate.SessionFactory;\n+import org.hibernate.stat.Statistics;\n+\n+import io.quarkus.hibernate.orm.runtime.JPAConfig;\n+import io.quarkus.runtime.StartupEvent;\n+\n+/**\n+ * This is only discovered if", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgyOTI1MA=="}, "originalCommit": {"oid": "896a43d7123f96ad941d11040a026d488682797f"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MTcxMjI0OnYy", "diffSide": "RIGHT", "path": "core/runtime/src/main/java/io/quarkus/runtime/metrics/MetricsFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNjo1NTo1M1rOG1VKJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNjo1NTo1M1rOG1VKJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU3NDM3NA==", "bodyText": "incorrect description on this one", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r458574374", "createdAt": "2020-07-22T06:55:53Z", "author": {"login": "jmartisk"}, "path": "core/runtime/src/main/java/io/quarkus/runtime/metrics/MetricsFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.quarkus.runtime.metrics;\n+\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+\n+/**\n+ * Extensions can create or register metrics using this factory\n+ * independent of the enabled metrics provider\n+ */\n+public interface MetricsFactory {\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MP_METRICS = \"smallrye-metrics\";\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9587033c14746a322d934066312c4e0e55bc4205"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MTczOTI1OnYy", "diffSide": "RIGHT", "path": "extensions/smallrye-metrics/runtime/src/main/java/io/quarkus/smallrye/metrics/runtime/SmallRyeMetricsFactory.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNzowNTowNlrOG1VacQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowOToxMlrOG1fgSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU3ODU0NQ==", "bodyText": "Some metrics created by extensions go to BASE, so this needs to be a changeable", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r458578545", "createdAt": "2020-07-22T07:05:06Z", "author": {"login": "jmartisk"}, "path": "extensions/smallrye-metrics/runtime/src/main/java/io/quarkus/smallrye/metrics/runtime/SmallRyeMetricsFactory.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package io.quarkus.smallrye.metrics.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+\n+import org.eclipse.microprofile.metrics.Counter;\n+import org.eclipse.microprofile.metrics.Gauge;\n+import org.eclipse.microprofile.metrics.MetricRegistry;\n+import org.eclipse.microprofile.metrics.MetricType;\n+import org.eclipse.microprofile.metrics.Tag;\n+import org.eclipse.microprofile.metrics.Timer;\n+\n+import io.quarkus.runtime.metrics.MetricsFactory;\n+import io.smallrye.metrics.MetricRegistries;\n+\n+public class SmallRyeMetricsFactory implements MetricsFactory {\n+    MetricRegistry registry = MetricRegistries.get(MetricRegistry.Type.VENDOR);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9587033c14746a322d934066312c4e0e55bc4205"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcxOTk4Mw==", "bodyText": "this is hard to translate as the notion of base or vendor doesn't apply.. but I will note it as optional/ignored in some contexts", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r458719983", "createdAt": "2020-07-22T11:21:01Z", "author": {"login": "ebullient"}, "path": "extensions/smallrye-metrics/runtime/src/main/java/io/quarkus/smallrye/metrics/runtime/SmallRyeMetricsFactory.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package io.quarkus.smallrye.metrics.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+\n+import org.eclipse.microprofile.metrics.Counter;\n+import org.eclipse.microprofile.metrics.Gauge;\n+import org.eclipse.microprofile.metrics.MetricRegistry;\n+import org.eclipse.microprofile.metrics.MetricType;\n+import org.eclipse.microprofile.metrics.Tag;\n+import org.eclipse.microprofile.metrics.Timer;\n+\n+import io.quarkus.runtime.metrics.MetricsFactory;\n+import io.smallrye.metrics.MetricRegistries;\n+\n+public class SmallRyeMetricsFactory implements MetricsFactory {\n+    MetricRegistry registry = MetricRegistries.get(MetricRegistry.Type.VENDOR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU3ODU0NQ=="}, "originalCommit": {"oid": "9587033c14746a322d934066312c4e0e55bc4205"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODczODg2NQ==", "bodyText": "This is smallrye-specific so here this notion does apply (at least for the time being), doesn't it? Could we make the registry type a field of this class and set it by a constructor parameter?", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r458738865", "createdAt": "2020-07-22T11:59:14Z", "author": {"login": "jmartisk"}, "path": "extensions/smallrye-metrics/runtime/src/main/java/io/quarkus/smallrye/metrics/runtime/SmallRyeMetricsFactory.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package io.quarkus.smallrye.metrics.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+\n+import org.eclipse.microprofile.metrics.Counter;\n+import org.eclipse.microprofile.metrics.Gauge;\n+import org.eclipse.microprofile.metrics.MetricRegistry;\n+import org.eclipse.microprofile.metrics.MetricType;\n+import org.eclipse.microprofile.metrics.Tag;\n+import org.eclipse.microprofile.metrics.Timer;\n+\n+import io.quarkus.runtime.metrics.MetricsFactory;\n+import io.smallrye.metrics.MetricRegistries;\n+\n+public class SmallRyeMetricsFactory implements MetricsFactory {\n+    MetricRegistry registry = MetricRegistries.get(MetricRegistry.Type.VENDOR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU3ODU0NQ=="}, "originalCommit": {"oid": "9587033c14746a322d934066312c4e0e55bc4205"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0Mzg4Mw==", "bodyText": "Yes, this is what I was thinking. Would be a simple enum on this interface, rather than pulling in MP Metrics API.", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r458743883", "createdAt": "2020-07-22T12:09:12Z", "author": {"login": "ebullient"}, "path": "extensions/smallrye-metrics/runtime/src/main/java/io/quarkus/smallrye/metrics/runtime/SmallRyeMetricsFactory.java", "diffHunk": "@@ -0,0 +1,203 @@\n+package io.quarkus.smallrye.metrics.runtime;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+\n+import org.eclipse.microprofile.metrics.Counter;\n+import org.eclipse.microprofile.metrics.Gauge;\n+import org.eclipse.microprofile.metrics.MetricRegistry;\n+import org.eclipse.microprofile.metrics.MetricType;\n+import org.eclipse.microprofile.metrics.Tag;\n+import org.eclipse.microprofile.metrics.Timer;\n+\n+import io.quarkus.runtime.metrics.MetricsFactory;\n+import io.smallrye.metrics.MetricRegistries;\n+\n+public class SmallRyeMetricsFactory implements MetricsFactory {\n+    MetricRegistry registry = MetricRegistries.get(MetricRegistry.Type.VENDOR);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU3ODU0NQ=="}, "originalCommit": {"oid": "9587033c14746a322d934066312c4e0e55bc4205"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MTc3OTU3OnYy", "diffSide": "RIGHT", "path": "core/runtime/src/main/java/io/quarkus/runtime/metrics/MetricsFactory.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNzoxODoyN1rOG1VyzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowNjo0OFrOG1fbfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU4NDc4MQ==", "bodyText": "What if an extension needs to create a counter that will be updated via calls to inc() rather than be a supplier or function? I guess we need a counter() function here without parameters that just registers  a plain counter", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r458584781", "createdAt": "2020-07-22T07:18:27Z", "author": {"login": "jmartisk"}, "path": "core/runtime/src/main/java/io/quarkus/runtime/metrics/MetricsFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.quarkus.runtime.metrics;\n+\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+\n+/**\n+ * Extensions can create or register metrics using this factory\n+ * independent of the enabled metrics provider\n+ */\n+public interface MetricsFactory {\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MP_METRICS = \"smallrye-metrics\";\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MICROMETER = \"micrometer\";\n+\n+    /**\n+     * @return true if this factory supports the named metrics system. Arbitrary\n+     *         strings are allowed. Constants are present for a few.\n+     * @see #MICROMETER\n+     * @see #MP_METRICS\n+     */\n+    boolean metricsSystemSupported(String name);\n+\n+    /** Create a fluid builder for registering counters and gauges */\n+    MetricBuilder builder(String name);\n+\n+    interface MetricBuilder {\n+        /**\n+         * @param description Description text of the eventual metric (optional).\n+         * @return The builder with added description.\n+         */\n+        MetricBuilder description(String description);\n+\n+        /**\n+         * @param key The tag key.\n+         * @param value The tag value.\n+         * @return The builder with added tag.\n+         */\n+        MetricBuilder tag(String key, String value);\n+\n+        /**\n+         * Specify the metric unit (optional)\n+         * \n+         * @param unit Base unit of the eventual metric\n+         * @return The builder with added base unit.\n+         */\n+        MetricBuilder unit(String unit);\n+\n+        /**\n+         * Register a counter that retrieves its value from a supplier function\n+         * \n+         * @param countFunction Function supplying a monotonically increasing number value\n+         */\n+        void counter(Supplier<Number> countFunction);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9587033c14746a322d934066312c4e0e55bc4205"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcyMDgxOQ==", "bodyText": "my intent was to use supplier or ToDoubleFunction always via the shared API. IMO, it is a best practice for reusable libraries anyway.", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r458720819", "createdAt": "2020-07-22T11:22:50Z", "author": {"login": "ebullient"}, "path": "core/runtime/src/main/java/io/quarkus/runtime/metrics/MetricsFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.quarkus.runtime.metrics;\n+\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+\n+/**\n+ * Extensions can create or register metrics using this factory\n+ * independent of the enabled metrics provider\n+ */\n+public interface MetricsFactory {\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MP_METRICS = \"smallrye-metrics\";\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MICROMETER = \"micrometer\";\n+\n+    /**\n+     * @return true if this factory supports the named metrics system. Arbitrary\n+     *         strings are allowed. Constants are present for a few.\n+     * @see #MICROMETER\n+     * @see #MP_METRICS\n+     */\n+    boolean metricsSystemSupported(String name);\n+\n+    /** Create a fluid builder for registering counters and gauges */\n+    MetricBuilder builder(String name);\n+\n+    interface MetricBuilder {\n+        /**\n+         * @param description Description text of the eventual metric (optional).\n+         * @return The builder with added description.\n+         */\n+        MetricBuilder description(String description);\n+\n+        /**\n+         * @param key The tag key.\n+         * @param value The tag value.\n+         * @return The builder with added tag.\n+         */\n+        MetricBuilder tag(String key, String value);\n+\n+        /**\n+         * Specify the metric unit (optional)\n+         * \n+         * @param unit Base unit of the eventual metric\n+         * @return The builder with added base unit.\n+         */\n+        MetricBuilder unit(String unit);\n+\n+        /**\n+         * Register a counter that retrieves its value from a supplier function\n+         * \n+         * @param countFunction Function supplying a monotonically increasing number value\n+         */\n+        void counter(Supplier<Number> countFunction);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU4NDc4MQ=="}, "originalCommit": {"oid": "9587033c14746a322d934066312c4e0e55bc4205"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODczOTkwMw==", "bodyText": "Well, but it would force some libraries to make significant changes, because they work by calling inc() and don't create any state objects for their counters.", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r458739903", "createdAt": "2020-07-22T12:01:09Z", "author": {"login": "jmartisk"}, "path": "core/runtime/src/main/java/io/quarkus/runtime/metrics/MetricsFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.quarkus.runtime.metrics;\n+\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+\n+/**\n+ * Extensions can create or register metrics using this factory\n+ * independent of the enabled metrics provider\n+ */\n+public interface MetricsFactory {\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MP_METRICS = \"smallrye-metrics\";\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MICROMETER = \"micrometer\";\n+\n+    /**\n+     * @return true if this factory supports the named metrics system. Arbitrary\n+     *         strings are allowed. Constants are present for a few.\n+     * @see #MICROMETER\n+     * @see #MP_METRICS\n+     */\n+    boolean metricsSystemSupported(String name);\n+\n+    /** Create a fluid builder for registering counters and gauges */\n+    MetricBuilder builder(String name);\n+\n+    interface MetricBuilder {\n+        /**\n+         * @param description Description text of the eventual metric (optional).\n+         * @return The builder with added description.\n+         */\n+        MetricBuilder description(String description);\n+\n+        /**\n+         * @param key The tag key.\n+         * @param value The tag value.\n+         * @return The builder with added tag.\n+         */\n+        MetricBuilder tag(String key, String value);\n+\n+        /**\n+         * Specify the metric unit (optional)\n+         * \n+         * @param unit Base unit of the eventual metric\n+         * @return The builder with added base unit.\n+         */\n+        MetricBuilder unit(String unit);\n+\n+        /**\n+         * Register a counter that retrieves its value from a supplier function\n+         * \n+         * @param countFunction Function supplying a monotonically increasing number value\n+         */\n+        void counter(Supplier<Number> countFunction);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU4NDc4MQ=="}, "originalCommit": {"oid": "9587033c14746a322d934066312c4e0e55bc4205"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MjY1NA==", "bodyText": "I am going to go find out how common that is. So far, it isn't very. And yes, this is on me to achieve. The goal of this common facade is to make that transition easier... but the model here is what Hibernate, Agroal, and Vert.x use..\nCreating any kind of additional Counter interface introduces a lot of wrapper items (which is essentially what the Counter type is.. it just isn't managed by the library.\nMP Metrics, FWIW, uses long values with inc() for counters, while Micrometer uses double values with increment(). This is why a simple \"counter\" interface isn't as simple as it sounds. A MeterBinder pattern works best to cover this case (using metricsSystemSupported method to do something more advanced/native/specific).\nIn the case of http (for example), I'm doing something native to micrometer for tracking http/eventbus/... metrics within the micrometer extension. I imagine the MP Metrics extension will do the same, and I think (for that case) it is the wiser thing to do. For Micrometer, there are existing MeterBinders that can be reused/pulled in (still @ bytecode recording time), and I prefer to reuse those where we can (this is where metricsSystemSupported can be used for deferred imports to ensure optional/compile-only dependencies.", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r458742654", "createdAt": "2020-07-22T12:06:48Z", "author": {"login": "ebullient"}, "path": "core/runtime/src/main/java/io/quarkus/runtime/metrics/MetricsFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.quarkus.runtime.metrics;\n+\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+\n+/**\n+ * Extensions can create or register metrics using this factory\n+ * independent of the enabled metrics provider\n+ */\n+public interface MetricsFactory {\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MP_METRICS = \"smallrye-metrics\";\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MICROMETER = \"micrometer\";\n+\n+    /**\n+     * @return true if this factory supports the named metrics system. Arbitrary\n+     *         strings are allowed. Constants are present for a few.\n+     * @see #MICROMETER\n+     * @see #MP_METRICS\n+     */\n+    boolean metricsSystemSupported(String name);\n+\n+    /** Create a fluid builder for registering counters and gauges */\n+    MetricBuilder builder(String name);\n+\n+    interface MetricBuilder {\n+        /**\n+         * @param description Description text of the eventual metric (optional).\n+         * @return The builder with added description.\n+         */\n+        MetricBuilder description(String description);\n+\n+        /**\n+         * @param key The tag key.\n+         * @param value The tag value.\n+         * @return The builder with added tag.\n+         */\n+        MetricBuilder tag(String key, String value);\n+\n+        /**\n+         * Specify the metric unit (optional)\n+         * \n+         * @param unit Base unit of the eventual metric\n+         * @return The builder with added base unit.\n+         */\n+        MetricBuilder unit(String unit);\n+\n+        /**\n+         * Register a counter that retrieves its value from a supplier function\n+         * \n+         * @param countFunction Function supplying a monotonically increasing number value\n+         */\n+        void counter(Supplier<Number> countFunction);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU4NDc4MQ=="}, "originalCommit": {"oid": "9587033c14746a322d934066312c4e0e55bc4205"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MTc5OTYxOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/writing-extensions.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNzoyNDoxOVrOG1V--Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMzozMDo0MlrOG1ie-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU4Nzg5Nw==", "bodyText": "the question is whether we will merge the micrometer extension to the core repo, if not then we shouldn't be mentioning that Quarkus can use that out of the box (not yet)", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r458587897", "createdAt": "2020-07-22T07:24:19Z", "author": {"login": "jmartisk"}, "path": "docs/src/main/asciidoc/writing-extensions.adoc", "diffHunk": "@@ -1486,143 +1486,111 @@ HealthBuildItem addHealthCheck(AgroalBuildTimeConfig agroalBuildTimeConfig) {\n \n === Extension Metrics\n \n-An extension can decide to provide metrics through the `quarkus-smallrye-metrics` extension.\n-A typical use case for this would be that an extension scans the application code for relevant components (like entities, messaging endpoints, etc.)\n-and creates a set of metrics for each of these components. A unified mechanism for metric registration is provided via the `MetricBuildItem` class\n-provided by the `quarkus-smallrye-metrics-spi` module.\n-\n-There are several distinct situations that can occur and each requires slightly different handling:\n-\n-1. The underlying library used by your extension is using the MicroProfile Metrics API directly.\n-2. The underlying library uses its own way for collecting metrics and makes them available at runtime using its own API.\n-3. The underlying library does not provide metrics (or there is no library at all) and you need to insert some code in the extension's codebase that will collect the metrics.\n-\n-What is common for all cases is that the extension should have a build-time config property that enables metrics exposure for the extension,\n-it should be named `quarkus.<extension>.metrics.enabled` and be `false` by default.\n-\n-==== Case 1: The library uses MP Metrics\n-If the library exposes metrics by itself, we don't have to do much. However, there are a few points to consider:\n-\n-- It should be possible to disable all metrics for an extension, which can be a bit problematic if the library registers them directly\n-rather than through the unified registration mechanism in the `quarkus-smallrye-metrics-spi` module. Therefore the library should contain\n-a way to turn all metrics off, for example using a library-specific system property that can be set during build time (by emitting a `SystemPropertyBuildItem`),\n-and will disable metrics if at least one of the properties `quarkus.<extensionName>.metrics.enabled` and `quarkus.smallrye-metrics.extensions.enabled` is `false`.\n-- It is desirable to be able to omit the MP Metrics dependency at runtime, so if possible, the library should be written in a way that\n-it will still work when the MP Metrics dependencies (or at least the implementation, `io.smallrye:smallrye-metrics`) are unavailable. This can be achieved by\n-wrapping all code that does something metric-related into an `if` condition that checks whether metrics integration is enabled. If the library performs injections\n-of the `MetricRegistry`, which is not avoidable by introducing an `if` condition, it will unfortunately not be possible to remove the `microprofile-metrics` dependency,\n-but it is still possible to avoid the need for `smallrye-metrics` (which contains the implementation class of the metric registry) by introducing a custom \"no-op\"\n-implementation of the `MetricRegistry` which can, for example, return `null` from all its methods. This no-op implementation should be added to the application's classes\n-so that it can be injected instead of the regular `io.smallrye.metrics.MetricRegistryImpl`. An example of a no-op implementation can be found at\n-https://github.com/quarkusio/quarkus/blob/master/extensions/smallrye-fault-tolerance/runtime/src/main/java/io/quarkus/smallrye/faulttolerance/runtime/NoopMetricRegistry.java[NoopMetricRegistry]\n+Quarkus can be configured to gather and emit metrics using either MicroProfile Metrics or Micrometer. Extensions may want to contribute their own instrumentation, and usually do so in one of the following ways :", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9587033c14746a322d934066312c4e0e55bc4205"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc5MjY5Nw==", "bodyText": "Attempt made.", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r458792697", "createdAt": "2020-07-22T13:30:42Z", "author": {"login": "ebullient"}, "path": "docs/src/main/asciidoc/writing-extensions.adoc", "diffHunk": "@@ -1486,143 +1486,111 @@ HealthBuildItem addHealthCheck(AgroalBuildTimeConfig agroalBuildTimeConfig) {\n \n === Extension Metrics\n \n-An extension can decide to provide metrics through the `quarkus-smallrye-metrics` extension.\n-A typical use case for this would be that an extension scans the application code for relevant components (like entities, messaging endpoints, etc.)\n-and creates a set of metrics for each of these components. A unified mechanism for metric registration is provided via the `MetricBuildItem` class\n-provided by the `quarkus-smallrye-metrics-spi` module.\n-\n-There are several distinct situations that can occur and each requires slightly different handling:\n-\n-1. The underlying library used by your extension is using the MicroProfile Metrics API directly.\n-2. The underlying library uses its own way for collecting metrics and makes them available at runtime using its own API.\n-3. The underlying library does not provide metrics (or there is no library at all) and you need to insert some code in the extension's codebase that will collect the metrics.\n-\n-What is common for all cases is that the extension should have a build-time config property that enables metrics exposure for the extension,\n-it should be named `quarkus.<extension>.metrics.enabled` and be `false` by default.\n-\n-==== Case 1: The library uses MP Metrics\n-If the library exposes metrics by itself, we don't have to do much. However, there are a few points to consider:\n-\n-- It should be possible to disable all metrics for an extension, which can be a bit problematic if the library registers them directly\n-rather than through the unified registration mechanism in the `quarkus-smallrye-metrics-spi` module. Therefore the library should contain\n-a way to turn all metrics off, for example using a library-specific system property that can be set during build time (by emitting a `SystemPropertyBuildItem`),\n-and will disable metrics if at least one of the properties `quarkus.<extensionName>.metrics.enabled` and `quarkus.smallrye-metrics.extensions.enabled` is `false`.\n-- It is desirable to be able to omit the MP Metrics dependency at runtime, so if possible, the library should be written in a way that\n-it will still work when the MP Metrics dependencies (or at least the implementation, `io.smallrye:smallrye-metrics`) are unavailable. This can be achieved by\n-wrapping all code that does something metric-related into an `if` condition that checks whether metrics integration is enabled. If the library performs injections\n-of the `MetricRegistry`, which is not avoidable by introducing an `if` condition, it will unfortunately not be possible to remove the `microprofile-metrics` dependency,\n-but it is still possible to avoid the need for `smallrye-metrics` (which contains the implementation class of the metric registry) by introducing a custom \"no-op\"\n-implementation of the `MetricRegistry` which can, for example, return `null` from all its methods. This no-op implementation should be added to the application's classes\n-so that it can be injected instead of the regular `io.smallrye.metrics.MetricRegistryImpl`. An example of a no-op implementation can be found at\n-https://github.com/quarkusio/quarkus/blob/master/extensions/smallrye-fault-tolerance/runtime/src/main/java/io/quarkus/smallrye/faulttolerance/runtime/NoopMetricRegistry.java[NoopMetricRegistry]\n+Quarkus can be configured to gather and emit metrics using either MicroProfile Metrics or Micrometer. Extensions may want to contribute their own instrumentation, and usually do so in one of the following ways :", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU4Nzg5Nw=="}, "originalCommit": {"oid": "9587033c14746a322d934066312c4e0e55bc4205"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MTgzNzI0OnYy", "diffSide": "RIGHT", "path": "core/runtime/src/main/java/io/quarkus/runtime/metrics/MetricsFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNzozNToxOFrOG1WV9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjoyMDoyOVrOG1f3fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU5Mzc4Mw==", "bodyText": "I find it a bit odd when something called *Builder doesn't have any build() method to be called last, but it seems it would be quite hard to add one here because we build distinct types of objects. Just thinking, would it help if we renamed the counter, gauge, etc. methods to buildCounter, buildGauge?", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r458593783", "createdAt": "2020-07-22T07:35:18Z", "author": {"login": "jmartisk"}, "path": "core/runtime/src/main/java/io/quarkus/runtime/metrics/MetricsFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.quarkus.runtime.metrics;\n+\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+\n+/**\n+ * Extensions can create or register metrics using this factory\n+ * independent of the enabled metrics provider\n+ */\n+public interface MetricsFactory {\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MP_METRICS = \"smallrye-metrics\";\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MICROMETER = \"micrometer\";\n+\n+    /**\n+     * @return true if this factory supports the named metrics system. Arbitrary\n+     *         strings are allowed. Constants are present for a few.\n+     * @see #MICROMETER\n+     * @see #MP_METRICS\n+     */\n+    boolean metricsSystemSupported(String name);\n+\n+    /** Create a fluid builder for registering counters and gauges */\n+    MetricBuilder builder(String name);\n+\n+    interface MetricBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9587033c14746a322d934066312c4e0e55bc4205"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0OTgyMA==", "bodyText": "Naming things is hard. ;)\nWill make some changes and see what you think.", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r458749820", "createdAt": "2020-07-22T12:20:29Z", "author": {"login": "ebullient"}, "path": "core/runtime/src/main/java/io/quarkus/runtime/metrics/MetricsFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.quarkus.runtime.metrics;\n+\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+\n+/**\n+ * Extensions can create or register metrics using this factory\n+ * independent of the enabled metrics provider\n+ */\n+public interface MetricsFactory {\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MP_METRICS = \"smallrye-metrics\";\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MICROMETER = \"micrometer\";\n+\n+    /**\n+     * @return true if this factory supports the named metrics system. Arbitrary\n+     *         strings are allowed. Constants are present for a few.\n+     * @see #MICROMETER\n+     * @see #MP_METRICS\n+     */\n+    boolean metricsSystemSupported(String name);\n+\n+    /** Create a fluid builder for registering counters and gauges */\n+    MetricBuilder builder(String name);\n+\n+    interface MetricBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODU5Mzc4Mw=="}, "originalCommit": {"oid": "9587033c14746a322d934066312c4e0e55bc4205"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjA0OTM4OnYy", "diffSide": "RIGHT", "path": "core/runtime/src/main/java/io/quarkus/runtime/metrics/MetricsFactory.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwODozMjozMlrOG1YXpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowNTowNlrOG1fYQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYyNjk4Mg==", "bodyText": "\u26d4", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r458626982", "createdAt": "2020-07-22T08:32:32Z", "author": {"login": "jmartisk"}, "path": "core/runtime/src/main/java/io/quarkus/runtime/metrics/MetricsFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.quarkus.runtime.metrics;\n+\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+\n+/**\n+ * Extensions can create or register metrics using this factory\n+ * independent of the enabled metrics provider\n+ */\n+public interface MetricsFactory {\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MP_METRICS = \"smallrye-metrics\";\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MICROMETER = \"micrometer\";\n+\n+    /**\n+     * @return true if this factory supports the named metrics system. Arbitrary\n+     *         strings are allowed. Constants are present for a few.\n+     * @see #MICROMETER\n+     * @see #MP_METRICS\n+     */\n+    boolean metricsSystemSupported(String name);\n+\n+    /** Create a fluid builder for registering counters and gauges */\n+    MetricBuilder builder(String name);\n+\n+    interface MetricBuilder {\n+        /**\n+         * @param description Description text of the eventual metric (optional).\n+         * @return The builder with added description.\n+         */\n+        MetricBuilder description(String description);\n+\n+        /**\n+         * @param key The tag key.\n+         * @param value The tag value.\n+         * @return The builder with added tag.\n+         */\n+        MetricBuilder tag(String key, String value);\n+\n+        /**\n+         * Specify the metric unit (optional)\n+         * \n+         * @param unit Base unit of the eventual metric\n+         * @return The builder with added base unit.\n+         */\n+        MetricBuilder unit(String unit);\n+\n+        /**\n+         * Register a counter that retrieves its value from a supplier function\n+         * \n+         * @param countFunction Function supplying a monotonically increasing number value\n+         */\n+        void counter(Supplier<Number> countFunction);\n+\n+        /**\n+         * Register a counter that retrieves its value by the applying a function\n+         * to an object\n+         * \n+         * @param obj Object instance to observe\n+         * @param countFunction Function returning a monotonically increasing double value\n+         */\n+        <S> void counter(S obj, ToDoubleFunction<S> countFunction);\n+\n+        /**\n+         * Register a gauge that retrieves its value from a supplier function\n+         * \n+         * @param gaugeFunction Function supplying number value\n+         */\n+        void gauge(Supplier<Number> gaugeFunction);\n+\n+        /**\n+         * Register a gauge that retrieves its value by applying a function\n+         * to an object\n+         * \n+         * @param obj Object instance to observe\n+         * @param gaugeFunction Function returning a long value\n+         */\n+        <S> void gauge(S obj, ToDoubleFunction<S> gaugeFunction);\n+\n+        /**\n+         * @return TimeRecorder to measure passage of time using\n+         *         incremental updates.\n+         */\n+        TimeRecorder timeRecorder();\n+\n+        /**\n+         * Wrap a {@link Runnable} so that it is timed when invoked.\n+         *\n+         * @param f The Runnable to time when it is invoked.\n+         * @return The wrapped Runnable.\n+         */\n+        Runnable timed(Runnable f);\n+\n+        /**\n+         * Wrap a {@link Callable} so that it is timed when invoked.\n+         *\n+         * @param f The Callable to time when it is invoked.\n+         * @param <T> The return type of the callable.\n+         * @return The wrapped callable.\n+         */\n+        <T> Callable<T> timed(Callable<T> f);\n+\n+        /**\n+         * Wrap a {@link Supplier} so that it is timed when invoked.\n+         *\n+         * @param f The {@code Supplier} to time when it is invoked.\n+         * @param <T> The return type of the {@code Supplier} result.\n+         * @return The wrapped supplier.\n+         * @since 1.2.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9587033c14746a322d934066312c4e0e55bc4205"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYzMjAwMw==", "bodyText": "Better avoid emoji comments for reviews as the intent might not be clear :). And if you get a question about it, it's not going to be a win.", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r458632003", "createdAt": "2020-07-22T08:40:52Z", "author": {"login": "gsmet"}, "path": "core/runtime/src/main/java/io/quarkus/runtime/metrics/MetricsFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.quarkus.runtime.metrics;\n+\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+\n+/**\n+ * Extensions can create or register metrics using this factory\n+ * independent of the enabled metrics provider\n+ */\n+public interface MetricsFactory {\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MP_METRICS = \"smallrye-metrics\";\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MICROMETER = \"micrometer\";\n+\n+    /**\n+     * @return true if this factory supports the named metrics system. Arbitrary\n+     *         strings are allowed. Constants are present for a few.\n+     * @see #MICROMETER\n+     * @see #MP_METRICS\n+     */\n+    boolean metricsSystemSupported(String name);\n+\n+    /** Create a fluid builder for registering counters and gauges */\n+    MetricBuilder builder(String name);\n+\n+    interface MetricBuilder {\n+        /**\n+         * @param description Description text of the eventual metric (optional).\n+         * @return The builder with added description.\n+         */\n+        MetricBuilder description(String description);\n+\n+        /**\n+         * @param key The tag key.\n+         * @param value The tag value.\n+         * @return The builder with added tag.\n+         */\n+        MetricBuilder tag(String key, String value);\n+\n+        /**\n+         * Specify the metric unit (optional)\n+         * \n+         * @param unit Base unit of the eventual metric\n+         * @return The builder with added base unit.\n+         */\n+        MetricBuilder unit(String unit);\n+\n+        /**\n+         * Register a counter that retrieves its value from a supplier function\n+         * \n+         * @param countFunction Function supplying a monotonically increasing number value\n+         */\n+        void counter(Supplier<Number> countFunction);\n+\n+        /**\n+         * Register a counter that retrieves its value by the applying a function\n+         * to an object\n+         * \n+         * @param obj Object instance to observe\n+         * @param countFunction Function returning a monotonically increasing double value\n+         */\n+        <S> void counter(S obj, ToDoubleFunction<S> countFunction);\n+\n+        /**\n+         * Register a gauge that retrieves its value from a supplier function\n+         * \n+         * @param gaugeFunction Function supplying number value\n+         */\n+        void gauge(Supplier<Number> gaugeFunction);\n+\n+        /**\n+         * Register a gauge that retrieves its value by applying a function\n+         * to an object\n+         * \n+         * @param obj Object instance to observe\n+         * @param gaugeFunction Function returning a long value\n+         */\n+        <S> void gauge(S obj, ToDoubleFunction<S> gaugeFunction);\n+\n+        /**\n+         * @return TimeRecorder to measure passage of time using\n+         *         incremental updates.\n+         */\n+        TimeRecorder timeRecorder();\n+\n+        /**\n+         * Wrap a {@link Runnable} so that it is timed when invoked.\n+         *\n+         * @param f The Runnable to time when it is invoked.\n+         * @return The wrapped Runnable.\n+         */\n+        Runnable timed(Runnable f);\n+\n+        /**\n+         * Wrap a {@link Callable} so that it is timed when invoked.\n+         *\n+         * @param f The Callable to time when it is invoked.\n+         * @param <T> The return type of the callable.\n+         * @return The wrapped callable.\n+         */\n+        <T> Callable<T> timed(Callable<T> f);\n+\n+        /**\n+         * Wrap a {@link Supplier} so that it is timed when invoked.\n+         *\n+         * @param f The {@code Supplier} to time when it is invoked.\n+         * @param <T> The return type of the {@code Supplier} result.\n+         * @return The wrapped supplier.\n+         * @since 1.2.0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYyNjk4Mg=="}, "originalCommit": {"oid": "9587033c14746a322d934066312c4e0e55bc4205"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY1NjQwMQ==", "bodyText": "Right. Also I'm not sure what you mean @jmartisk ? suggesting that the since attribute should be removed?", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r458656401", "createdAt": "2020-07-22T09:21:18Z", "author": {"login": "Sanne"}, "path": "core/runtime/src/main/java/io/quarkus/runtime/metrics/MetricsFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.quarkus.runtime.metrics;\n+\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+\n+/**\n+ * Extensions can create or register metrics using this factory\n+ * independent of the enabled metrics provider\n+ */\n+public interface MetricsFactory {\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MP_METRICS = \"smallrye-metrics\";\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MICROMETER = \"micrometer\";\n+\n+    /**\n+     * @return true if this factory supports the named metrics system. Arbitrary\n+     *         strings are allowed. Constants are present for a few.\n+     * @see #MICROMETER\n+     * @see #MP_METRICS\n+     */\n+    boolean metricsSystemSupported(String name);\n+\n+    /** Create a fluid builder for registering counters and gauges */\n+    MetricBuilder builder(String name);\n+\n+    interface MetricBuilder {\n+        /**\n+         * @param description Description text of the eventual metric (optional).\n+         * @return The builder with added description.\n+         */\n+        MetricBuilder description(String description);\n+\n+        /**\n+         * @param key The tag key.\n+         * @param value The tag value.\n+         * @return The builder with added tag.\n+         */\n+        MetricBuilder tag(String key, String value);\n+\n+        /**\n+         * Specify the metric unit (optional)\n+         * \n+         * @param unit Base unit of the eventual metric\n+         * @return The builder with added base unit.\n+         */\n+        MetricBuilder unit(String unit);\n+\n+        /**\n+         * Register a counter that retrieves its value from a supplier function\n+         * \n+         * @param countFunction Function supplying a monotonically increasing number value\n+         */\n+        void counter(Supplier<Number> countFunction);\n+\n+        /**\n+         * Register a counter that retrieves its value by the applying a function\n+         * to an object\n+         * \n+         * @param obj Object instance to observe\n+         * @param countFunction Function returning a monotonically increasing double value\n+         */\n+        <S> void counter(S obj, ToDoubleFunction<S> countFunction);\n+\n+        /**\n+         * Register a gauge that retrieves its value from a supplier function\n+         * \n+         * @param gaugeFunction Function supplying number value\n+         */\n+        void gauge(Supplier<Number> gaugeFunction);\n+\n+        /**\n+         * Register a gauge that retrieves its value by applying a function\n+         * to an object\n+         * \n+         * @param obj Object instance to observe\n+         * @param gaugeFunction Function returning a long value\n+         */\n+        <S> void gauge(S obj, ToDoubleFunction<S> gaugeFunction);\n+\n+        /**\n+         * @return TimeRecorder to measure passage of time using\n+         *         incremental updates.\n+         */\n+        TimeRecorder timeRecorder();\n+\n+        /**\n+         * Wrap a {@link Runnable} so that it is timed when invoked.\n+         *\n+         * @param f The Runnable to time when it is invoked.\n+         * @return The wrapped Runnable.\n+         */\n+        Runnable timed(Runnable f);\n+\n+        /**\n+         * Wrap a {@link Callable} so that it is timed when invoked.\n+         *\n+         * @param f The Callable to time when it is invoked.\n+         * @param <T> The return type of the callable.\n+         * @return The wrapped callable.\n+         */\n+        <T> Callable<T> timed(Callable<T> f);\n+\n+        /**\n+         * Wrap a {@link Supplier} so that it is timed when invoked.\n+         *\n+         * @param f The {@code Supplier} to time when it is invoked.\n+         * @param <T> The return type of the {@code Supplier} result.\n+         * @return The wrapped supplier.\n+         * @since 1.2.0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYyNjk4Mg=="}, "originalCommit": {"oid": "9587033c14746a322d934066312c4e0e55bc4205"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY4MTU1OA==", "bodyText": "Ok, noted. I'm saying that this is clearly not since Quarkus 1.2.0, so either the version number should be corrected, or the attribute removed :)", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r458681558", "createdAt": "2020-07-22T10:04:27Z", "author": {"login": "jmartisk"}, "path": "core/runtime/src/main/java/io/quarkus/runtime/metrics/MetricsFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.quarkus.runtime.metrics;\n+\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+\n+/**\n+ * Extensions can create or register metrics using this factory\n+ * independent of the enabled metrics provider\n+ */\n+public interface MetricsFactory {\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MP_METRICS = \"smallrye-metrics\";\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MICROMETER = \"micrometer\";\n+\n+    /**\n+     * @return true if this factory supports the named metrics system. Arbitrary\n+     *         strings are allowed. Constants are present for a few.\n+     * @see #MICROMETER\n+     * @see #MP_METRICS\n+     */\n+    boolean metricsSystemSupported(String name);\n+\n+    /** Create a fluid builder for registering counters and gauges */\n+    MetricBuilder builder(String name);\n+\n+    interface MetricBuilder {\n+        /**\n+         * @param description Description text of the eventual metric (optional).\n+         * @return The builder with added description.\n+         */\n+        MetricBuilder description(String description);\n+\n+        /**\n+         * @param key The tag key.\n+         * @param value The tag value.\n+         * @return The builder with added tag.\n+         */\n+        MetricBuilder tag(String key, String value);\n+\n+        /**\n+         * Specify the metric unit (optional)\n+         * \n+         * @param unit Base unit of the eventual metric\n+         * @return The builder with added base unit.\n+         */\n+        MetricBuilder unit(String unit);\n+\n+        /**\n+         * Register a counter that retrieves its value from a supplier function\n+         * \n+         * @param countFunction Function supplying a monotonically increasing number value\n+         */\n+        void counter(Supplier<Number> countFunction);\n+\n+        /**\n+         * Register a counter that retrieves its value by the applying a function\n+         * to an object\n+         * \n+         * @param obj Object instance to observe\n+         * @param countFunction Function returning a monotonically increasing double value\n+         */\n+        <S> void counter(S obj, ToDoubleFunction<S> countFunction);\n+\n+        /**\n+         * Register a gauge that retrieves its value from a supplier function\n+         * \n+         * @param gaugeFunction Function supplying number value\n+         */\n+        void gauge(Supplier<Number> gaugeFunction);\n+\n+        /**\n+         * Register a gauge that retrieves its value by applying a function\n+         * to an object\n+         * \n+         * @param obj Object instance to observe\n+         * @param gaugeFunction Function returning a long value\n+         */\n+        <S> void gauge(S obj, ToDoubleFunction<S> gaugeFunction);\n+\n+        /**\n+         * @return TimeRecorder to measure passage of time using\n+         *         incremental updates.\n+         */\n+        TimeRecorder timeRecorder();\n+\n+        /**\n+         * Wrap a {@link Runnable} so that it is timed when invoked.\n+         *\n+         * @param f The Runnable to time when it is invoked.\n+         * @return The wrapped Runnable.\n+         */\n+        Runnable timed(Runnable f);\n+\n+        /**\n+         * Wrap a {@link Callable} so that it is timed when invoked.\n+         *\n+         * @param f The Callable to time when it is invoked.\n+         * @param <T> The return type of the callable.\n+         * @return The wrapped callable.\n+         */\n+        <T> Callable<T> timed(Callable<T> f);\n+\n+        /**\n+         * Wrap a {@link Supplier} so that it is timed when invoked.\n+         *\n+         * @param f The {@code Supplier} to time when it is invoked.\n+         * @param <T> The return type of the {@code Supplier} result.\n+         * @return The wrapped supplier.\n+         * @since 1.2.0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYyNjk4Mg=="}, "originalCommit": {"oid": "9587033c14746a322d934066312c4e0e55bc4205"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc0MTgyNQ==", "bodyText": "HA! Yes. I can remove that. Thanks for asking for emoji clarity @gsmet and @Sanne =)", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r458741825", "createdAt": "2020-07-22T12:05:06Z", "author": {"login": "ebullient"}, "path": "core/runtime/src/main/java/io/quarkus/runtime/metrics/MetricsFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.quarkus.runtime.metrics;\n+\n+import java.time.Duration;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.function.ToDoubleFunction;\n+\n+/**\n+ * Extensions can create or register metrics using this factory\n+ * independent of the enabled metrics provider\n+ */\n+public interface MetricsFactory {\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MP_METRICS = \"smallrye-metrics\";\n+\n+    /** A well-known string for MicroProfile metrics provided by the SmallRye Metrics quarkus extension */\n+    final String MICROMETER = \"micrometer\";\n+\n+    /**\n+     * @return true if this factory supports the named metrics system. Arbitrary\n+     *         strings are allowed. Constants are present for a few.\n+     * @see #MICROMETER\n+     * @see #MP_METRICS\n+     */\n+    boolean metricsSystemSupported(String name);\n+\n+    /** Create a fluid builder for registering counters and gauges */\n+    MetricBuilder builder(String name);\n+\n+    interface MetricBuilder {\n+        /**\n+         * @param description Description text of the eventual metric (optional).\n+         * @return The builder with added description.\n+         */\n+        MetricBuilder description(String description);\n+\n+        /**\n+         * @param key The tag key.\n+         * @param value The tag value.\n+         * @return The builder with added tag.\n+         */\n+        MetricBuilder tag(String key, String value);\n+\n+        /**\n+         * Specify the metric unit (optional)\n+         * \n+         * @param unit Base unit of the eventual metric\n+         * @return The builder with added base unit.\n+         */\n+        MetricBuilder unit(String unit);\n+\n+        /**\n+         * Register a counter that retrieves its value from a supplier function\n+         * \n+         * @param countFunction Function supplying a monotonically increasing number value\n+         */\n+        void counter(Supplier<Number> countFunction);\n+\n+        /**\n+         * Register a counter that retrieves its value by the applying a function\n+         * to an object\n+         * \n+         * @param obj Object instance to observe\n+         * @param countFunction Function returning a monotonically increasing double value\n+         */\n+        <S> void counter(S obj, ToDoubleFunction<S> countFunction);\n+\n+        /**\n+         * Register a gauge that retrieves its value from a supplier function\n+         * \n+         * @param gaugeFunction Function supplying number value\n+         */\n+        void gauge(Supplier<Number> gaugeFunction);\n+\n+        /**\n+         * Register a gauge that retrieves its value by applying a function\n+         * to an object\n+         * \n+         * @param obj Object instance to observe\n+         * @param gaugeFunction Function returning a long value\n+         */\n+        <S> void gauge(S obj, ToDoubleFunction<S> gaugeFunction);\n+\n+        /**\n+         * @return TimeRecorder to measure passage of time using\n+         *         incremental updates.\n+         */\n+        TimeRecorder timeRecorder();\n+\n+        /**\n+         * Wrap a {@link Runnable} so that it is timed when invoked.\n+         *\n+         * @param f The Runnable to time when it is invoked.\n+         * @return The wrapped Runnable.\n+         */\n+        Runnable timed(Runnable f);\n+\n+        /**\n+         * Wrap a {@link Callable} so that it is timed when invoked.\n+         *\n+         * @param f The Callable to time when it is invoked.\n+         * @param <T> The return type of the callable.\n+         * @return The wrapped callable.\n+         */\n+        <T> Callable<T> timed(Callable<T> f);\n+\n+        /**\n+         * Wrap a {@link Supplier} so that it is timed when invoked.\n+         *\n+         * @param f The {@code Supplier} to time when it is invoked.\n+         * @param <T> The return type of the {@code Supplier} result.\n+         * @return The wrapped supplier.\n+         * @since 1.2.0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYyNjk4Mg=="}, "originalCommit": {"oid": "9587033c14746a322d934066312c4e0e55bc4205"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzA4MzA1OnYy", "diffSide": "RIGHT", "path": "extensions/smallrye-metrics/runtime/src/main/java/io/quarkus/smallrye/metrics/runtime/SmallRyeMetricsRecorder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMjoyODoyMFrOG2IN9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxMjoyODoyMFrOG2IN9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQxMDkzMg==", "bodyText": "Does it need a new factory for each consumer, or because each consumer creates a new builder from the factory, the factory can be the same?", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r459410932", "createdAt": "2020-07-23T12:28:20Z", "author": {"login": "kenfinnigan"}, "path": "extensions/smallrye-metrics/runtime/src/main/java/io/quarkus/smallrye/metrics/runtime/SmallRyeMetricsRecorder.java", "diffHunk": "@@ -209,6 +211,11 @@ public void registerMetric(MetricRegistry.Type scope,\n         }\n     }\n \n+    public void registerMetrics(Consumer<MetricsFactory> consumer) {\n+        SmallRyeMetricsFactory factory = new SmallRyeMetricsFactory();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4666b60fac97aaf564d3aa213506e4a8e3cd890d"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MDExNDk3OnYy", "diffSide": "RIGHT", "path": "extensions/smallrye-metrics/deployment/src/main/java/io/quarkus/smallrye/metrics/deployment/SmallRyeMetricsProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwNjo1MjozMVrOG2k3TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNDo1NzoyNlrOG2yqDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg4MDI2OA==", "bodyText": "Why is this inside the method registerMetricsFromProducers? Metrics from producers will go away in MP Metrics 3.0 and so will this method. Perhaps this can be moved to a new method with a RUNTIME_INIT recorder?", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r459880268", "createdAt": "2020-07-24T06:52:31Z", "author": {"login": "jmartisk"}, "path": "extensions/smallrye-metrics/deployment/src/main/java/io/quarkus/smallrye/metrics/deployment/SmallRyeMetricsProcessor.java", "diffHunk": "@@ -495,6 +507,12 @@ void registerMetricsFromProducers(\n                 }\n             }\n         }\n+\n+        for (MetricsFactoryConsumerBuildItem item : metricsFactoryConsumerBuildItems) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5932d186e595e403941b4b13c310dc2ab851d7b5"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEwNjI1Mw==", "bodyText": "Ah. I will rename that method -- the reason is mostly parameters (that takes place at runtime init after bean validation, which means the beans that some of the consumers will need will all be resolved (ValidationPhaseBuildItem / BeanArchiveIndexBuildItem)", "url": "https://github.com/quarkusio/quarkus/pull/10626#discussion_r460106253", "createdAt": "2020-07-24T14:57:26Z", "author": {"login": "ebullient"}, "path": "extensions/smallrye-metrics/deployment/src/main/java/io/quarkus/smallrye/metrics/deployment/SmallRyeMetricsProcessor.java", "diffHunk": "@@ -495,6 +507,12 @@ void registerMetricsFromProducers(\n                 }\n             }\n         }\n+\n+        for (MetricsFactoryConsumerBuildItem item : metricsFactoryConsumerBuildItems) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg4MDI2OA=="}, "originalCommit": {"oid": "5932d186e595e403941b4b13c310dc2ab851d7b5"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2428, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}