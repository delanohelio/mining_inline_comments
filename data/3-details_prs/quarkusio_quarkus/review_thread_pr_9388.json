{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5MTU5Nzcw", "number": 9388, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNTowNzoxNVrOD9Pemw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMjoyOToxNFrOD-lGMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTQzMzIzOnYy", "diffSide": "RIGHT", "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "isResolved": false, "comments": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNTowNzoxNVrOGWnrkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMToxMDoyOVrOGXywFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA==", "bodyText": "I'm afraid that this could get us into trouble.\nWhat this does is basically set a private field on the CDI proxy. For mock that works great because the mock is just some object. But in this case you would be setting the that private field to the CDI proxy itself.\nI really think we need to find a more safe way of providing this facility.", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426371984", "createdAt": "2020-05-18T05:07:15Z", "author": {"login": "geoand"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU1NjA5Ng==", "bodyText": "I am not sure I am following the concern.\nIn both the mock and spy use cases we are wrapping an Object into the Mockito Framework.\nIn the case of a Mock that is that Object is instantiated with null for all internal variables, and the Mockito Framework is set to doReturn(null) for any method that returns anything, or doNothing() for methods that return void.\nIn the case of the Spy that Object is a fully instantiated Object with all of the variables set how they are expected. Then the Mockito Framework will by default call doCallRealMethod() on all method calls into that Object.\nIn both cases, we are putting into the CDI proxy a Mockito wrapped Object.", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426556096", "createdAt": "2020-05-18T11:26:35Z", "author": {"login": "aaron-rogers82"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU1ODU4NQ==", "bodyText": "The problem is that with the Spy, what you are putting in, actually contains a reference to the object itself, no?", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426558585", "createdAt": "2020-05-18T11:31:16Z", "author": {"login": "geoand"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU2MjUzMA==", "bodyText": "Yes, you are just using a wrapper pattern to provide additional functionality to the Object.\nAt the end, the CDI proxy isn't pointing to the first Object it originally created, it is pointing to the Mockito Framework wrapped Object. If the CDI interacts with that Bean, it will be doing so to the wrapped Object, not to the original Bean itself.", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426562530", "createdAt": "2020-05-18T11:39:17Z", "author": {"login": "aaron-rogers82"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU2NjU4NA==", "bodyText": "So I think I haven't been clear.\nWhen  MockSupport.installMock() gets called (down the line) what happens is that whatever you pass as the objects gets stuffed into a special field called mock of  the CDI proxy.\nIn this case, you are passing an object which essentially wraps the proxy itself (unless I have misunderstood).\nSo this mock field of the CDI proxy would (once the intermediate is removed) essentially contains a reference to itself. That is what has me worried.", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426566584", "createdAt": "2020-05-18T11:47:21Z", "author": {"login": "geoand"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjYxMDc2Mw==", "bodyText": "Okay, I ran some additional tests and compared the memory addresses for the different objects.\nIn the test I had one Object annotated with @InjectMock and another Object annotated with @InjectSpy. I then ran two @test method and compared the actual Bean, ClientProxy, and mock/spy objects.\nIn both @test cases, the actual CDI Bean instance stayed the same (mock = @34d3bfca and spy = @1d57b8f1), and the ClentProxy instance stayed the same (mock = @16660 and spy = @16705). However, the Mockito wrapped instance change between each test (mock = test1 = @16662, test2 = @17364, and the spy = test1 = @16707, test2 = @17370).\nDoes this help address your concern?", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426610763", "createdAt": "2020-05-18T13:05:39Z", "author": {"login": "aaron-rogers82"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjYxMTU0OA==", "bodyText": "Thanks for the info, I'll take a look at it and get back to you", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426611548", "createdAt": "2020-05-18T13:06:57Z", "author": {"login": "geoand"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5MzQ3MA==", "bodyText": "There is a copy of the CDI proxy deep inside the mock field. See\n\nIt might be completely safe, but I would like to hear from @mkouba or @manovotn first :)", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426693470", "createdAt": "2020-05-18T15:04:07Z", "author": {"login": "geoand"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc4MDEyOQ==", "bodyText": "@geoand aren't we doing the same thing in CreateMockitoMocksCallback#beforeAll()? When you retrieve the CDI bean there, it also looks to be a proxy, right?", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426780129", "createdAt": "2020-05-18T17:19:38Z", "author": {"login": "manovotn"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc4MTA2NA==", "bodyText": "I mean you also base the mock on the proxy and then store that into  MockitoMocksTracker. I don't know the internals but I would assume there isn't much difference in spy versus mock in this regard.", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426781064", "createdAt": "2020-05-18T17:21:09Z", "author": {"login": "manovotn"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg0ODgxMQ==", "bodyText": "I think that it shoudln't be a problem although it's a bit \"tangled\".\nThere is a difference though because for @InjectMock a mock object is created and injected into the test class instance AND this mock is set to the mock field of the relevant client proxy object so that any client proxy method invocation is redirected to the mock.\nFor @InjectSpy a copy (according to the javadoc) of the client proxy object is created AND then this copy is set to the mock field of the relevant client proxy object. And it seems to work because the spy copy is created before the mock field is set and so if the client proxy is invoked (i.e. from another bean) the spy copy that has mock=null is used and so non-stubbed methods delegate to the underlying bean instance.", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426848811", "createdAt": "2020-05-18T19:31:52Z", "author": {"login": "mkouba"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg3NTg3NA==", "bodyText": "Oh my bad, Mockito.mock() is based off a Class, not actual instance...\nIn that case, it might be \"cleaner\" to unwrap the proxies before creating the spy, WDYT?", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426875874", "createdAt": "2020-05-18T20:28:59Z", "author": {"login": "manovotn"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkwNzU4OQ==", "bodyText": "In that case, it might be \"cleaner\" to unwrap the proxies before creating the spy, WDYT?\n\nJust to be clear, you are suggesting we do something like:\nClientProxyUnwrapper unwrapProxy = new ClientProxyUnwrapper();\nObject spy = Mockito.spy(unwrapProxy.apply(beanInstance));\nI tested this locally, and the \"WithSpiesTest\" tests all work with that. This appears to be a good solution, as we are not adding a circular reference to the Proxy.", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426907589", "createdAt": "2020-05-18T21:39:15Z", "author": {"login": "aaron-rogers82"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAzNzM5NA==", "bodyText": "I like @manovotn's idea, WDYT @mkouba ?", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r427037394", "createdAt": "2020-05-19T05:24:50Z", "author": {"login": "geoand"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NDAwMA==", "bodyText": "I'm not sure it's a good idea because if Mockito.spy() copies the state and does not delegate to the original instance we may end up with unexpected behavior. Let's say we have @ApplicationScoped Foo then @InjectSpy Foo -> this creates a copy of Foo instance. Now if you call an unstubbed method on the spy instance the state of the original bean instance does not change. Ideally, test methods should not be connected in any way but since the @ApplicationScoped beans are shared...", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r427044000", "createdAt": "2020-05-19T05:47:56Z", "author": {"login": "mkouba"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0ODE2NQ==", "bodyText": "So @mkouba do you propose we just leave the PR as is?", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r427048165", "createdAt": "2020-05-19T06:00:44Z", "author": {"login": "geoand"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA5MDc0MA==", "bodyText": "Frankly, I never used the spy functionality before but looking at the docs, this seems to be what you would expect - that the real instance is in fact not invoked, it's state unchanged.", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r427090740", "createdAt": "2020-05-19T07:36:57Z", "author": {"login": "manovotn"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI0Mzc3NQ==", "bodyText": "FWIW, @mkouba fixed the issue he mentioned above", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r427243775", "createdAt": "2020-05-19T11:56:01Z", "author": {"login": "geoand"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI5MDMxOQ==", "bodyText": "Ideally, test methods should not be connected in any way but since the @ApplicationScoped beans are shared...\n\nI still think we should unwrap the ClientProxy. I did a quick test with the \"quarkus-integration-test-injectmock\" project and if we just create the Spy on the ClientProxy then the internal state of the actual bean will persist between test. I agree with @mkouba above, that test state should not be shared. If we do share the state, then Testers will see unexpected results.\nI updated MessageServiceImpl to:\nprivate int count = 0;\n@Override\npublic String getMessage() {\n    System.out.println(\"Test Instance: \"+this);\n    System.out.println(\"Count: \"+count++);\n    return \"hello\";\n}\n\nBetween all of the test in the integration project, the MessageServiceImpl is called three times.\nSpy on ClientProxy:\nTest Instance: io.quarkus.it.mockbean.MessageServiceImpl@62ce03cc Count: 0\nTest Instance: io.quarkus.it.mockbean.MessageServiceImpl@62ce03cc Count: 1\nTest Instance: io.quarkus.it.mockbean.MessageServiceImpl@62ce03cc Count: 2\nSpy on Unwrapped ClientProxy:\nTest Instance: org.mockito.codegen.MessageServiceImpl$MockitoMock$718960814@9131950 Count: 0\nTest Instance: org.mockito.codegen.MessageServiceImpl$MockitoMock$718960814@38d42ab7 Count: 0\nTest Instance: io.quarkus.it.mockbean.MessageServiceImpl@2553ddc4 Count: 0\nI will defer and leave the Spy at the ClientProxy if y'all really think that the Test should alter the internal state of ApplicationScoped beans.\nPlease advise how y'all would like to proceed.", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r427290319", "createdAt": "2020-05-19T13:12:25Z", "author": {"login": "aaron-rogers82"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMyMjQ2OQ==", "bodyText": "I don't have a strong opinion. Both approaches probably have pros and cons. To me it sounds more natural to delegate the calls to the real instance but the contract of mockito spy is probably more important.", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r427322469", "createdAt": "2020-05-19T13:57:43Z", "author": {"login": "mkouba"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4ODk2Nw==", "bodyText": "I think we should stick to what mockito spy contract is since we are trying to mimick that.\nBut truth be told, I am not sure I see the use case where you would actually need a spy versus standard mock...", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r427588967", "createdAt": "2020-05-19T20:45:38Z", "author": {"login": "manovotn"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwMTk0Mw==", "bodyText": "I provided a few reasons in the documentation.\nAn example, in my current project I am working on, we have three possible methods that will all return the same object, but will go about looking up the data for the object different ways. We determine which method to call based on the JSON object passed into the project. When testing, we don't really want to alter how the code operates, we just want to be able to verify that the logic called the correct method.\nTo do that with a Mock it would have to create the mock and then in setup (@beforeeach) call doCallRealMethod().when(logic).method() for each public/protected/package private method on the class. Just creating a Spy eliminates that setup and simplifies maintenance as new methods are added.\nFor the majority of time, a Mock is just fine and will accomplish the majority of testing. Having the ability to use a Spy just provides more options to use when they are beneficial.", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r427601943", "createdAt": "2020-05-19T21:10:29Z", "author": {"login": "aaron-rogers82"}, "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, "originalCommit": {"oid": "677fa036c0975056826ffbf66aab395bb7b90fd5"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NDMwMjM0OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/getting-started-testing.adoc", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwNzoxNzowMVrOGX-RlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwODo1MzowN1rOGYrULQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc5MDc0MA==", "bodyText": "I think that we should be clear what \"called normally\" means and describe the lifecycle of the spied bean more thoroughly....", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r427790740", "createdAt": "2020-05-20T07:17:01Z", "author": {"login": "mkouba"}, "path": "docs/src/main/asciidoc/getting-started-testing.adoc", "diffHunk": "@@ -525,6 +525,72 @@ public class MockGreetingServiceTest {\n ----\n <1> Since we configured `greetingService` as a mock, the `GreetingResource` which uses the `GreetingService` bean, we get the mocked response instead of the response of the regular `GreetingService` bean\n \n+==== Using Spies instead of Mocks with `@InjectSpy`\n+\n+Building on the features provided by `InjectMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for spying on the beans supported by `QuarkusMock`.\n+This functionality is available via the `@io.quarkus.test.junit.mockito.InjectSpy` annotation which is available in the `quarkus-junit5-mockito` dependency.\n+\n+Sometimes when testing you only need to verify that a certain logical path was taken, or you only need to override a single method and want the rest of the methods to be called normally.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e7fe2bddc768c10b6dca3b33d33873b8834015e"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE3OTU1OA==", "bodyText": "So, we are linking to the Mockito site. Doing some cursory digging on the links there, I was able to find This, where it has this block...\n\nMockito does not delegate calls to the passed real instance, instead it actually creates a copy of it. So if you keep the real instance and interact with it, don't expect the spied to be aware of those interaction and their effect on real instance state. The corollary is that when an unstubbed method is called on the spy but not on the real instance, you won't see any effects on the real instance.\n\nBased on that information, would you be okay with changing that last paragraph to...\n\nSometimes when testing you only need to verify that a certain logical path was taken, or you only need to stub out a single method's response while still executing the rest of the methods on the Spied clone. Please see Mockito documentation for more details on Spy partial mocks.\n\nThis makes is clearer that we will not be executing the methods on the real instance and what happens in this test will be isolated to just the Spied clone. While still directing them to the full documentation that Mockito has already compiled on Spied objects.", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r428179558", "createdAt": "2020-05-20T17:18:44Z", "author": {"login": "aaron-rogers82"}, "path": "docs/src/main/asciidoc/getting-started-testing.adoc", "diffHunk": "@@ -525,6 +525,72 @@ public class MockGreetingServiceTest {\n ----\n <1> Since we configured `greetingService` as a mock, the `GreetingResource` which uses the `GreetingService` bean, we get the mocked response instead of the response of the regular `GreetingService` bean\n \n+==== Using Spies instead of Mocks with `@InjectSpy`\n+\n+Building on the features provided by `InjectMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for spying on the beans supported by `QuarkusMock`.\n+This functionality is available via the `@io.quarkus.test.junit.mockito.InjectSpy` annotation which is available in the `quarkus-junit5-mockito` dependency.\n+\n+Sometimes when testing you only need to verify that a certain logical path was taken, or you only need to override a single method and want the rest of the methods to be called normally.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc5MDc0MA=="}, "originalCommit": {"oid": "0e7fe2bddc768c10b6dca3b33d33873b8834015e"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyNDg2Nw==", "bodyText": "I like the idea... @geoand WDYT?", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r428524867", "createdAt": "2020-05-21T08:44:54Z", "author": {"login": "mkouba"}, "path": "docs/src/main/asciidoc/getting-started-testing.adoc", "diffHunk": "@@ -525,6 +525,72 @@ public class MockGreetingServiceTest {\n ----\n <1> Since we configured `greetingService` as a mock, the `GreetingResource` which uses the `GreetingService` bean, we get the mocked response instead of the response of the regular `GreetingService` bean\n \n+==== Using Spies instead of Mocks with `@InjectSpy`\n+\n+Building on the features provided by `InjectMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for spying on the beans supported by `QuarkusMock`.\n+This functionality is available via the `@io.quarkus.test.junit.mockito.InjectSpy` annotation which is available in the `quarkus-junit5-mockito` dependency.\n+\n+Sometimes when testing you only need to verify that a certain logical path was taken, or you only need to override a single method and want the rest of the methods to be called normally.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc5MDc0MA=="}, "originalCommit": {"oid": "0e7fe2bddc768c10b6dca3b33d33873b8834015e"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUyODY4NQ==", "bodyText": "I like it as well", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r428528685", "createdAt": "2020-05-21T08:53:07Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/getting-started-testing.adoc", "diffHunk": "@@ -525,6 +525,72 @@ public class MockGreetingServiceTest {\n ----\n <1> Since we configured `greetingService` as a mock, the `GreetingResource` which uses the `GreetingService` bean, we get the mocked response instead of the response of the regular `GreetingService` bean\n \n+==== Using Spies instead of Mocks with `@InjectSpy`\n+\n+Building on the features provided by `InjectMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for spying on the beans supported by `QuarkusMock`.\n+This functionality is available via the `@io.quarkus.test.junit.mockito.InjectSpy` annotation which is available in the `quarkus-junit5-mockito` dependency.\n+\n+Sometimes when testing you only need to verify that a certain logical path was taken, or you only need to override a single method and want the rest of the methods to be called normally.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc5MDc0MA=="}, "originalCommit": {"oid": "0e7fe2bddc768c10b6dca3b33d33873b8834015e"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2OTQ2MDk2OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/getting-started-testing.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMjoyOToxNFrOGYw-6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMjoyOToxNFrOGYw-6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYyMTU0NQ==", "bodyText": "Small nitpick: Can we add a link to that documentation please?", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r428621545", "createdAt": "2020-05-21T12:29:14Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/getting-started-testing.adoc", "diffHunk": "@@ -525,6 +525,72 @@ public class MockGreetingServiceTest {\n ----\n <1> Since we configured `greetingService` as a mock, the `GreetingResource` which uses the `GreetingService` bean, we get the mocked response instead of the response of the regular `GreetingService` bean\n \n+==== Using Spies instead of Mocks with `@InjectSpy`\n+\n+Building on the features provided by `InjectMock`, Quarkus also allows users to effortlessly take advantage of link:https://site.mockito.org/[Mockito] for spying on the beans supported by `QuarkusMock`.\n+This functionality is available via the `@io.quarkus.test.junit.mockito.InjectSpy` annotation which is available in the `quarkus-junit5-mockito` dependency.\n+\n+Sometimes when testing you only need to verify that a certain logical path was taken, or you only need to stub out a single method's response while still executing the rest of the methods on the Spied clone. Please see Mockito documentation for more details on Spy partial mocks.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d44ccdd066435dbcf14f83f33b4cd5770c211e69"}, "originalPosition": 9}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3070, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}