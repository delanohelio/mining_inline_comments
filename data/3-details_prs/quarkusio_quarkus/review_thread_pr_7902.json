{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5Njg0MTU3", "number": 7902, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwODo1MDo0MFrODooUQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMzozNTo1N1rODpHMvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTMwMTc2OnYy", "diffSide": "RIGHT", "path": "extensions/smallrye-metrics/runtime/src/main/java/io/quarkus/smallrye/metrics/runtime/SmallRyeMetricsRecorder.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwODo1MDo0MFrOF3SwiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMjo0NTozM1rOF3amNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUyMzMzNw==", "bodyText": "While we are at it, can we remove the use of lambdas in runtime code please?", "url": "https://github.com/quarkusio/quarkus/pull/7902#discussion_r393523337", "createdAt": "2020-03-17T08:50:40Z", "author": {"login": "geoand"}, "path": "extensions/smallrye-metrics/runtime/src/main/java/io/quarkus/smallrye/metrics/runtime/SmallRyeMetricsRecorder.java", "diffHunk": "@@ -558,28 +559,38 @@ private void micrometerJvmGcMetrics(MetricRegistry registry, ShutdownContext shu\n         if (!ImageInfo.inImageCode()) {\n             MicrometerGCMetrics gcMetrics = new MicrometerGCMetrics();\n \n-            registry.register(new ExtendedMetadata(\"jvm.gc.max.data.size\",\n-                    MetricType.GAUGE,\n-                    MetricUnits.BYTES,\n-                    \"Max size of old generation memory pool\",\n-                    true), new LambdaGauge(gcMetrics::getMaxDataSize));\n-            registry.register(new ExtendedMetadata(\"jvm.gc.live.data.size\",\n-                    MetricType.GAUGE,\n-                    MetricUnits.BYTES,\n-                    \"Size of old generation memory pool after a full GC\",\n-                    true), new LambdaGauge(gcMetrics::getLiveDataSize));\n-            registry.register(new ExtendedMetadata(\"jvm.gc.memory.promoted\",\n-                    MetricType.COUNTER,\n-                    MetricUnits.BYTES,\n-                    \"Count of positive increases in the size of the old generation memory pool before GC to after GC\",\n-                    true,\n-                    \"jvm_gc_memory_promoted_bytes_total\"), new LambdaCounter(gcMetrics::getPromotedBytes));\n-            registry.register(new ExtendedMetadata(\"jvm.gc.memory.allocated\",\n-                    MetricType.COUNTER,\n-                    MetricUnits.BYTES,\n-                    \"Incremented for an increase in the size of the young generation memory pool after one GC to before the next\",\n-                    true,\n-                    \"jvm_gc_memory_allocated_bytes_total\"), new LambdaCounter(gcMetrics::getAllocatedBytes));\n+            registry.register(new ExtendedMetadataBuilder()\n+                    .withName(\"jvm.gc.max.data.size\")\n+                    .withType(MetricType.GAUGE)\n+                    .withUnit(MetricUnits.BYTES)\n+                    .withDescription(\"Max size of old generation memory pool\")\n+                    .skipsScopeInOpenMetricsExportCompletely(true)\n+                    .build(), new LambdaGauge(gcMetrics::getMaxDataSize));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4e0d6e293ecc6f51bce36fbd7cff73162f92ea3"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUzMzgzNg==", "bodyText": "Do we really have to do that?\nsee #3732 (comment)\nI'm not an expert on this topic but it seems the memory penalty is negligible", "url": "https://github.com/quarkusio/quarkus/pull/7902#discussion_r393533836", "createdAt": "2020-03-17T09:09:42Z", "author": {"login": "jmartisk"}, "path": "extensions/smallrye-metrics/runtime/src/main/java/io/quarkus/smallrye/metrics/runtime/SmallRyeMetricsRecorder.java", "diffHunk": "@@ -558,28 +559,38 @@ private void micrometerJvmGcMetrics(MetricRegistry registry, ShutdownContext shu\n         if (!ImageInfo.inImageCode()) {\n             MicrometerGCMetrics gcMetrics = new MicrometerGCMetrics();\n \n-            registry.register(new ExtendedMetadata(\"jvm.gc.max.data.size\",\n-                    MetricType.GAUGE,\n-                    MetricUnits.BYTES,\n-                    \"Max size of old generation memory pool\",\n-                    true), new LambdaGauge(gcMetrics::getMaxDataSize));\n-            registry.register(new ExtendedMetadata(\"jvm.gc.live.data.size\",\n-                    MetricType.GAUGE,\n-                    MetricUnits.BYTES,\n-                    \"Size of old generation memory pool after a full GC\",\n-                    true), new LambdaGauge(gcMetrics::getLiveDataSize));\n-            registry.register(new ExtendedMetadata(\"jvm.gc.memory.promoted\",\n-                    MetricType.COUNTER,\n-                    MetricUnits.BYTES,\n-                    \"Count of positive increases in the size of the old generation memory pool before GC to after GC\",\n-                    true,\n-                    \"jvm_gc_memory_promoted_bytes_total\"), new LambdaCounter(gcMetrics::getPromotedBytes));\n-            registry.register(new ExtendedMetadata(\"jvm.gc.memory.allocated\",\n-                    MetricType.COUNTER,\n-                    MetricUnits.BYTES,\n-                    \"Incremented for an increase in the size of the young generation memory pool after one GC to before the next\",\n-                    true,\n-                    \"jvm_gc_memory_allocated_bytes_total\"), new LambdaCounter(gcMetrics::getAllocatedBytes));\n+            registry.register(new ExtendedMetadataBuilder()\n+                    .withName(\"jvm.gc.max.data.size\")\n+                    .withType(MetricType.GAUGE)\n+                    .withUnit(MetricUnits.BYTES)\n+                    .withDescription(\"Max size of old generation memory pool\")\n+                    .skipsScopeInOpenMetricsExportCompletely(true)\n+                    .build(), new LambdaGauge(gcMetrics::getMaxDataSize));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUyMzMzNw=="}, "originalCommit": {"oid": "e4e0d6e293ecc6f51bce36fbd7cff73162f92ea3"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUzNTQzMg==", "bodyText": "We don't have to do it, but it's been a general guideline for the runtime code of the project that we generally do try to follow.\nAFAIR, it's not only small memory penalty, it's also a small startup penalty. Of course one extension won't make a difference, but it's a case of death by a thousand cuts", "url": "https://github.com/quarkusio/quarkus/pull/7902#discussion_r393535432", "createdAt": "2020-03-17T09:12:35Z", "author": {"login": "geoand"}, "path": "extensions/smallrye-metrics/runtime/src/main/java/io/quarkus/smallrye/metrics/runtime/SmallRyeMetricsRecorder.java", "diffHunk": "@@ -558,28 +559,38 @@ private void micrometerJvmGcMetrics(MetricRegistry registry, ShutdownContext shu\n         if (!ImageInfo.inImageCode()) {\n             MicrometerGCMetrics gcMetrics = new MicrometerGCMetrics();\n \n-            registry.register(new ExtendedMetadata(\"jvm.gc.max.data.size\",\n-                    MetricType.GAUGE,\n-                    MetricUnits.BYTES,\n-                    \"Max size of old generation memory pool\",\n-                    true), new LambdaGauge(gcMetrics::getMaxDataSize));\n-            registry.register(new ExtendedMetadata(\"jvm.gc.live.data.size\",\n-                    MetricType.GAUGE,\n-                    MetricUnits.BYTES,\n-                    \"Size of old generation memory pool after a full GC\",\n-                    true), new LambdaGauge(gcMetrics::getLiveDataSize));\n-            registry.register(new ExtendedMetadata(\"jvm.gc.memory.promoted\",\n-                    MetricType.COUNTER,\n-                    MetricUnits.BYTES,\n-                    \"Count of positive increases in the size of the old generation memory pool before GC to after GC\",\n-                    true,\n-                    \"jvm_gc_memory_promoted_bytes_total\"), new LambdaCounter(gcMetrics::getPromotedBytes));\n-            registry.register(new ExtendedMetadata(\"jvm.gc.memory.allocated\",\n-                    MetricType.COUNTER,\n-                    MetricUnits.BYTES,\n-                    \"Incremented for an increase in the size of the young generation memory pool after one GC to before the next\",\n-                    true,\n-                    \"jvm_gc_memory_allocated_bytes_total\"), new LambdaCounter(gcMetrics::getAllocatedBytes));\n+            registry.register(new ExtendedMetadataBuilder()\n+                    .withName(\"jvm.gc.max.data.size\")\n+                    .withType(MetricType.GAUGE)\n+                    .withUnit(MetricUnits.BYTES)\n+                    .withDescription(\"Max size of old generation memory pool\")\n+                    .skipsScopeInOpenMetricsExportCompletely(true)\n+                    .build(), new LambdaGauge(gcMetrics::getMaxDataSize));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUyMzMzNw=="}, "originalCommit": {"oid": "e4e0d6e293ecc6f51bce36fbd7cff73162f92ea3"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0Nzc3MA==", "bodyText": "Ok I'll do that then, but give me some time, hopefully will get round to it tomorrow :)", "url": "https://github.com/quarkusio/quarkus/pull/7902#discussion_r393647770", "createdAt": "2020-03-17T12:38:17Z", "author": {"login": "jmartisk"}, "path": "extensions/smallrye-metrics/runtime/src/main/java/io/quarkus/smallrye/metrics/runtime/SmallRyeMetricsRecorder.java", "diffHunk": "@@ -558,28 +559,38 @@ private void micrometerJvmGcMetrics(MetricRegistry registry, ShutdownContext shu\n         if (!ImageInfo.inImageCode()) {\n             MicrometerGCMetrics gcMetrics = new MicrometerGCMetrics();\n \n-            registry.register(new ExtendedMetadata(\"jvm.gc.max.data.size\",\n-                    MetricType.GAUGE,\n-                    MetricUnits.BYTES,\n-                    \"Max size of old generation memory pool\",\n-                    true), new LambdaGauge(gcMetrics::getMaxDataSize));\n-            registry.register(new ExtendedMetadata(\"jvm.gc.live.data.size\",\n-                    MetricType.GAUGE,\n-                    MetricUnits.BYTES,\n-                    \"Size of old generation memory pool after a full GC\",\n-                    true), new LambdaGauge(gcMetrics::getLiveDataSize));\n-            registry.register(new ExtendedMetadata(\"jvm.gc.memory.promoted\",\n-                    MetricType.COUNTER,\n-                    MetricUnits.BYTES,\n-                    \"Count of positive increases in the size of the old generation memory pool before GC to after GC\",\n-                    true,\n-                    \"jvm_gc_memory_promoted_bytes_total\"), new LambdaCounter(gcMetrics::getPromotedBytes));\n-            registry.register(new ExtendedMetadata(\"jvm.gc.memory.allocated\",\n-                    MetricType.COUNTER,\n-                    MetricUnits.BYTES,\n-                    \"Incremented for an increase in the size of the young generation memory pool after one GC to before the next\",\n-                    true,\n-                    \"jvm_gc_memory_allocated_bytes_total\"), new LambdaCounter(gcMetrics::getAllocatedBytes));\n+            registry.register(new ExtendedMetadataBuilder()\n+                    .withName(\"jvm.gc.max.data.size\")\n+                    .withType(MetricType.GAUGE)\n+                    .withUnit(MetricUnits.BYTES)\n+                    .withDescription(\"Max size of old generation memory pool\")\n+                    .skipsScopeInOpenMetricsExportCompletely(true)\n+                    .build(), new LambdaGauge(gcMetrics::getMaxDataSize));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUyMzMzNw=="}, "originalCommit": {"oid": "e4e0d6e293ecc6f51bce36fbd7cff73162f92ea3"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY1MTc2NA==", "bodyText": "Sure thing, no rush :)", "url": "https://github.com/quarkusio/quarkus/pull/7902#discussion_r393651764", "createdAt": "2020-03-17T12:45:33Z", "author": {"login": "geoand"}, "path": "extensions/smallrye-metrics/runtime/src/main/java/io/quarkus/smallrye/metrics/runtime/SmallRyeMetricsRecorder.java", "diffHunk": "@@ -558,28 +559,38 @@ private void micrometerJvmGcMetrics(MetricRegistry registry, ShutdownContext shu\n         if (!ImageInfo.inImageCode()) {\n             MicrometerGCMetrics gcMetrics = new MicrometerGCMetrics();\n \n-            registry.register(new ExtendedMetadata(\"jvm.gc.max.data.size\",\n-                    MetricType.GAUGE,\n-                    MetricUnits.BYTES,\n-                    \"Max size of old generation memory pool\",\n-                    true), new LambdaGauge(gcMetrics::getMaxDataSize));\n-            registry.register(new ExtendedMetadata(\"jvm.gc.live.data.size\",\n-                    MetricType.GAUGE,\n-                    MetricUnits.BYTES,\n-                    \"Size of old generation memory pool after a full GC\",\n-                    true), new LambdaGauge(gcMetrics::getLiveDataSize));\n-            registry.register(new ExtendedMetadata(\"jvm.gc.memory.promoted\",\n-                    MetricType.COUNTER,\n-                    MetricUnits.BYTES,\n-                    \"Count of positive increases in the size of the old generation memory pool before GC to after GC\",\n-                    true,\n-                    \"jvm_gc_memory_promoted_bytes_total\"), new LambdaCounter(gcMetrics::getPromotedBytes));\n-            registry.register(new ExtendedMetadata(\"jvm.gc.memory.allocated\",\n-                    MetricType.COUNTER,\n-                    MetricUnits.BYTES,\n-                    \"Incremented for an increase in the size of the young generation memory pool after one GC to before the next\",\n-                    true,\n-                    \"jvm_gc_memory_allocated_bytes_total\"), new LambdaCounter(gcMetrics::getAllocatedBytes));\n+            registry.register(new ExtendedMetadataBuilder()\n+                    .withName(\"jvm.gc.max.data.size\")\n+                    .withType(MetricType.GAUGE)\n+                    .withUnit(MetricUnits.BYTES)\n+                    .withDescription(\"Max size of old generation memory pool\")\n+                    .skipsScopeInOpenMetricsExportCompletely(true)\n+                    .build(), new LambdaGauge(gcMetrics::getMaxDataSize));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUyMzMzNw=="}, "originalCommit": {"oid": "e4e0d6e293ecc6f51bce36fbd7cff73162f92ea3"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NDM2MDA5OnYy", "diffSide": "RIGHT", "path": "extensions/smallrye-metrics/runtime/src/main/java/io/quarkus/smallrye/metrics/runtime/MicrometerGCMetrics.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMzozNTozNFrOF4FMOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNDoxOTowOVrOF4HGIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0OTYyNA==", "bodyText": "Is it normal that both the descriptions of this one and the one above are identical?", "url": "https://github.com/quarkusio/quarkus/pull/7902#discussion_r394349624", "createdAt": "2020-03-18T13:35:34Z", "author": {"login": "gsmet"}, "path": "extensions/smallrye-metrics/runtime/src/main/java/io/quarkus/smallrye/metrics/runtime/MicrometerGCMetrics.java", "diffHunk": "@@ -147,28 +148,34 @@ public void startWatchingNotifications() {\n                     gcPauseMaxValue.set(duration); // update the maximum GC length if needed\n                 }\n                 if (!registry.getGauges().containsKey(pauseSecondsMaxMetricID)) {\n-                    registry.register(new ExtendedMetadata(metricName + \".seconds.max\",\n-                            MetricType.GAUGE,\n-                            MetricUnits.NONE,\n-                            \"Time spent in GC pause\",\n-                            true),\n+                    registry.register(new ExtendedMetadataBuilder()\n+                            .withName(metricName + \".seconds.max\")\n+                            .withType(MetricType.GAUGE)\n+                            .withUnit(MetricUnits.NONE)\n+                            .withDescription(\"Time spent in GC pause\")\n+                            .skipsScopeInOpenMetricsExportCompletely(true)\n+                            .build(),\n                             new LambdaGauge(() -> mapForStoringMax.get(causeAndAction).doubleValue() / 1000.0), tags);\n                 }\n \n-                ExtendedMetadata countMetadata = new ExtendedMetadata(metricName + \".seconds.count\",\n-                        MetricType.COUNTER,\n-                        MetricUnits.NONE,\n-                        \"Time spent in GC pause\",\n-                        true,\n-                        metricName.replace(\".\", \"_\") + \"_seconds_count\");\n+                ExtendedMetadata countMetadata = new ExtendedMetadataBuilder()\n+                        .withName(metricName + \".seconds.count\")\n+                        .withType(MetricType.COUNTER)\n+                        .withUnit(MetricUnits.NONE)\n+                        .withDescription(\"Time spent in GC pause\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4e0d6e293ecc6f51bce36fbd7cff73162f92ea3"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM4MDgzMg==", "bodyText": "I too find it a bit odd, but that's how Micrometer (in the latest version) does it, and we try to mimic it as closely as possible", "url": "https://github.com/quarkusio/quarkus/pull/7902#discussion_r394380832", "createdAt": "2020-03-18T14:19:09Z", "author": {"login": "jmartisk"}, "path": "extensions/smallrye-metrics/runtime/src/main/java/io/quarkus/smallrye/metrics/runtime/MicrometerGCMetrics.java", "diffHunk": "@@ -147,28 +148,34 @@ public void startWatchingNotifications() {\n                     gcPauseMaxValue.set(duration); // update the maximum GC length if needed\n                 }\n                 if (!registry.getGauges().containsKey(pauseSecondsMaxMetricID)) {\n-                    registry.register(new ExtendedMetadata(metricName + \".seconds.max\",\n-                            MetricType.GAUGE,\n-                            MetricUnits.NONE,\n-                            \"Time spent in GC pause\",\n-                            true),\n+                    registry.register(new ExtendedMetadataBuilder()\n+                            .withName(metricName + \".seconds.max\")\n+                            .withType(MetricType.GAUGE)\n+                            .withUnit(MetricUnits.NONE)\n+                            .withDescription(\"Time spent in GC pause\")\n+                            .skipsScopeInOpenMetricsExportCompletely(true)\n+                            .build(),\n                             new LambdaGauge(() -> mapForStoringMax.get(causeAndAction).doubleValue() / 1000.0), tags);\n                 }\n \n-                ExtendedMetadata countMetadata = new ExtendedMetadata(metricName + \".seconds.count\",\n-                        MetricType.COUNTER,\n-                        MetricUnits.NONE,\n-                        \"Time spent in GC pause\",\n-                        true,\n-                        metricName.replace(\".\", \"_\") + \"_seconds_count\");\n+                ExtendedMetadata countMetadata = new ExtendedMetadataBuilder()\n+                        .withName(metricName + \".seconds.count\")\n+                        .withType(MetricType.COUNTER)\n+                        .withUnit(MetricUnits.NONE)\n+                        .withDescription(\"Time spent in GC pause\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0OTYyNA=="}, "originalCommit": {"oid": "e4e0d6e293ecc6f51bce36fbd7cff73162f92ea3"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NDM2MTU3OnYy", "diffSide": "RIGHT", "path": "extensions/smallrye-metrics/runtime/src/main/java/io/quarkus/smallrye/metrics/runtime/MicrometerGCMetrics.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMzozNTo1N1rOF4FNKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMzozNTo1N1rOF4FNKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM0OTg2Nw==", "bodyText": "And same here?", "url": "https://github.com/quarkusio/quarkus/pull/7902#discussion_r394349867", "createdAt": "2020-03-18T13:35:57Z", "author": {"login": "gsmet"}, "path": "extensions/smallrye-metrics/runtime/src/main/java/io/quarkus/smallrye/metrics/runtime/MicrometerGCMetrics.java", "diffHunk": "@@ -147,28 +148,34 @@ public void startWatchingNotifications() {\n                     gcPauseMaxValue.set(duration); // update the maximum GC length if needed\n                 }\n                 if (!registry.getGauges().containsKey(pauseSecondsMaxMetricID)) {\n-                    registry.register(new ExtendedMetadata(metricName + \".seconds.max\",\n-                            MetricType.GAUGE,\n-                            MetricUnits.NONE,\n-                            \"Time spent in GC pause\",\n-                            true),\n+                    registry.register(new ExtendedMetadataBuilder()\n+                            .withName(metricName + \".seconds.max\")\n+                            .withType(MetricType.GAUGE)\n+                            .withUnit(MetricUnits.NONE)\n+                            .withDescription(\"Time spent in GC pause\")\n+                            .skipsScopeInOpenMetricsExportCompletely(true)\n+                            .build(),\n                             new LambdaGauge(() -> mapForStoringMax.get(causeAndAction).doubleValue() / 1000.0), tags);\n                 }\n \n-                ExtendedMetadata countMetadata = new ExtendedMetadata(metricName + \".seconds.count\",\n-                        MetricType.COUNTER,\n-                        MetricUnits.NONE,\n-                        \"Time spent in GC pause\",\n-                        true,\n-                        metricName.replace(\".\", \"_\") + \"_seconds_count\");\n+                ExtendedMetadata countMetadata = new ExtendedMetadataBuilder()\n+                        .withName(metricName + \".seconds.count\")\n+                        .withType(MetricType.COUNTER)\n+                        .withUnit(MetricUnits.NONE)\n+                        .withDescription(\"Time spent in GC pause\")\n+                        .skipsScopeInOpenMetricsExportCompletely(true)\n+                        .withOpenMetricsKeyOverride(metricName.replace(\".\", \"_\") + \"_seconds_count\")\n+                        .build();\n                 registry.counter(countMetadata, tags).inc();\n \n-                registry.counter(new ExtendedMetadata(metricName + \".seconds.sum\",\n-                        MetricType.COUNTER,\n-                        MetricUnits.MILLISECONDS,\n-                        \"Time spent in GC pause\",\n-                        true,\n-                        metricName.replace(\".\", \"_\") + \"_seconds_sum\"), tags).inc(duration);\n+                registry.counter(new ExtendedMetadataBuilder()\n+                        .withName(metricName + \".seconds.sum\")\n+                        .withType(MetricType.COUNTER)\n+                        .withUnit(MetricUnits.MILLISECONDS)\n+                        .withDescription(\"Time spent in GC pause\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4e0d6e293ecc6f51bce36fbd7cff73162f92ea3"}, "originalPosition": 53}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4688, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}