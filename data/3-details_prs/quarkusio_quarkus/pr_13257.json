{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE5ODkxNzk1", "number": 13257, "title": "Remove Uni await for OIDC code access token validation and user info calls", "bodyText": "Fixes #13249.\nThis PR follows the earlier PR improving OIDC Uni related code:\n\ncode access token verification and user info calls are totally async now;\nuser-info calls are always blocking hence they will run by the blocking executor\ncode access token as well as a bearer access token will also be run by the blocking executor if the token is opaque - right now the introspection requests initiated internally by Vert.x would run on the IO thread\n\nChanges look extensive but they are really not, it is just related to me having to collapse some code into reusable functions to minimize the duplication.\nAlso, BlockingOperationControl code branches will be gone as soon as I make sure that refreshing the tokens does not require a blocking call, but until then I have to check it to avoid re-dispatching to the executor (as explained by Stuart).\nWe already have the tests for all the affected combinations (code access token is a source of roles, opaque tokens, user-info)\nMy Uni confidence is high now thanks to @cescoffier so this PR should be good to go once it will go green :-)\nCC @cescoffier @gsmet", "createdAt": "2020-11-12T13:39:15Z", "url": "https://github.com/quarkusio/quarkus/pull/13257", "merged": true, "mergeCommit": {"oid": "b6a04f6cee4f78bfbe4181857c8d12fc9c405931"}, "closed": true, "closedAt": "2020-11-13T10:05:39Z", "author": {"login": "sberyozkin"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdbzQKQAFqTUyOTExMjkxOQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdcDbQWAFqTUyOTg4OTkyMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5MTEyOTE5", "url": "https://github.com/quarkusio/quarkus/pull/13257#pullrequestreview-529112919", "createdAt": "2020-11-12T14:01:10Z", "commit": {"oid": "2b370d52d73c49fd8e2348ee3e76604c414c362d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNDowMToxMVrOHx8E6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNDoxNTo0MlrOHx8tgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyNjU2OA==", "bodyText": "Why removing the deprecation?", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522126568", "createdAt": "2020-11-12T14:01:11Z", "author": {"login": "cescoffier"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcIdentityProvider.java", "diffHunk": "@@ -35,6 +36,11 @@\n \n @ApplicationScoped\n public class OidcIdentityProvider implements IdentityProvider<TokenAuthenticationRequest> {\n+\n+    @SuppressWarnings(\"deprecation\")\n+    private static final Uni<AccessToken> NULL_CODE_ACCESS_TOKEN_UNI = Uni.createFrom().nullItem();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b370d52d73c49fd8e2348ee3e76604c414c362d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyNzA4Mw==", "bodyText": "should be a constant.", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522127083", "createdAt": "2020-11-12T14:01:53Z", "author": {"login": "cescoffier"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcIdentityProvider.java", "diffHunk": "@@ -81,101 +87,157 @@ public SecurityIdentity get() {\n         if (resolvedContext.oidcConfig.publicKey.isPresent()) {\n             return validateTokenWithoutOidcServer(request, resolvedContext);\n         } else {\n-            return validateTokenWithOidcServer(vertxContext, request, resolvedContext);\n+            return validateAllTokensWithOidcServer(vertxContext, request, resolvedContext);\n         }\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+    private Uni<SecurityIdentity> validateAllTokensWithOidcServer(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request,\n             TenantConfigContext resolvedContext) {\n \n-        if (request.getToken() instanceof IdTokenCredential\n-                && (resolvedContext.oidcConfig.authentication.verifyAccessToken\n-                        || resolvedContext.oidcConfig.roles.source.orElse(null) == Source.accesstoken)) {\n-            vertxContext.put(\"code_flow_access_token_result\",\n-                    verifyCodeFlowAccessToken(vertxContext, request, resolvedContext));\n+        Uni<AccessToken> codeAccessTokenUni = verifyCodeFlowAccessTokenUni(vertxContext, request, resolvedContext);\n+\n+        return codeAccessTokenUni.onItem().transformToUni(\n+                new Function<AccessToken, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(AccessToken codeAccessToken) {\n+                        return validateTokenWithOidcServer(vertxContext, request, resolvedContext, codeAccessToken);\n+                    }\n+                });\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+            TenantConfigContext resolvedContext, AccessToken codeAccessToken) {\n+\n+        if (codeAccessToken != null) {\n+            vertxContext.put(\"code_flow_access_token_result\", codeAccessToken);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b370d52d73c49fd8e2348ee3e76604c414c362d"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyODY4Mw==", "bodyText": "even if blocking is allowed, it may be not called on the same thread. This method is called on the subscription thread, not the assembly thread.", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522128683", "createdAt": "2020-11-12T14:04:10Z", "author": {"login": "cescoffier"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcIdentityProvider.java", "diffHunk": "@@ -81,101 +87,157 @@ public SecurityIdentity get() {\n         if (resolvedContext.oidcConfig.publicKey.isPresent()) {\n             return validateTokenWithoutOidcServer(request, resolvedContext);\n         } else {\n-            return validateTokenWithOidcServer(vertxContext, request, resolvedContext);\n+            return validateAllTokensWithOidcServer(vertxContext, request, resolvedContext);\n         }\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+    private Uni<SecurityIdentity> validateAllTokensWithOidcServer(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request,\n             TenantConfigContext resolvedContext) {\n \n-        if (request.getToken() instanceof IdTokenCredential\n-                && (resolvedContext.oidcConfig.authentication.verifyAccessToken\n-                        || resolvedContext.oidcConfig.roles.source.orElse(null) == Source.accesstoken)) {\n-            vertxContext.put(\"code_flow_access_token_result\",\n-                    verifyCodeFlowAccessToken(vertxContext, request, resolvedContext));\n+        Uni<AccessToken> codeAccessTokenUni = verifyCodeFlowAccessTokenUni(vertxContext, request, resolvedContext);\n+\n+        return codeAccessTokenUni.onItem().transformToUni(\n+                new Function<AccessToken, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(AccessToken codeAccessToken) {\n+                        return validateTokenWithOidcServer(vertxContext, request, resolvedContext, codeAccessToken);\n+                    }\n+                });\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+            TenantConfigContext resolvedContext, AccessToken codeAccessToken) {\n+\n+        if (codeAccessToken != null) {\n+            vertxContext.put(\"code_flow_access_token_result\", codeAccessToken);\n         }\n \n-        final JsonObject userInfo = resolvedContext.oidcConfig.authentication.isUserInfoRequired()\n-                ? getUserInfo(vertxContext, request, resolvedContext)\n-                : null;\n+        Uni<JsonObject> userInfo = getUserInfoUni(vertxContext, request, resolvedContext);\n \n-        return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n-            @Override\n-            public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+        return userInfo.onItem().transformToUni(\n+                new Function<JsonObject, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(JsonObject userInfo) {\n+                        return createSecurityIdentityWithOidcServerUni(vertxContext, request, resolvedContext, userInfo);\n+                    }\n+                });\n+    }\n+\n+    private Uni<SecurityIdentity> createSecurityIdentityWithOidcServerUni(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request, TenantConfigContext resolvedContext, final JsonObject userInfo) {\n \n-                resolvedContext.auth.decodeToken(request.getToken().getToken(),\n-                        new Handler<AsyncResult<AccessToken>>() {\n+        final TokenCredential tokenCred = request.getToken();\n+        if (tokenCred instanceof AccessTokenCredential && ((AccessTokenCredential) tokenCred).isOpaque()) {\n+            // remote introspection is required, a blocking call\n+            if (BlockingOperationControl.isBlockingAllowed()) {\n+                return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                    @Override\n+                    public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                        createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext, userInfo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b370d52d73c49fd8e2348ee3e76604c414c362d"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyOTE0Nw==", "bodyText": "Any reason to not use Infrastructure.getDEfaultWorkerPool()?", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522129147", "createdAt": "2020-11-12T14:04:46Z", "author": {"login": "cescoffier"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcIdentityProvider.java", "diffHunk": "@@ -81,101 +87,157 @@ public SecurityIdentity get() {\n         if (resolvedContext.oidcConfig.publicKey.isPresent()) {\n             return validateTokenWithoutOidcServer(request, resolvedContext);\n         } else {\n-            return validateTokenWithOidcServer(vertxContext, request, resolvedContext);\n+            return validateAllTokensWithOidcServer(vertxContext, request, resolvedContext);\n         }\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+    private Uni<SecurityIdentity> validateAllTokensWithOidcServer(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request,\n             TenantConfigContext resolvedContext) {\n \n-        if (request.getToken() instanceof IdTokenCredential\n-                && (resolvedContext.oidcConfig.authentication.verifyAccessToken\n-                        || resolvedContext.oidcConfig.roles.source.orElse(null) == Source.accesstoken)) {\n-            vertxContext.put(\"code_flow_access_token_result\",\n-                    verifyCodeFlowAccessToken(vertxContext, request, resolvedContext));\n+        Uni<AccessToken> codeAccessTokenUni = verifyCodeFlowAccessTokenUni(vertxContext, request, resolvedContext);\n+\n+        return codeAccessTokenUni.onItem().transformToUni(\n+                new Function<AccessToken, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(AccessToken codeAccessToken) {\n+                        return validateTokenWithOidcServer(vertxContext, request, resolvedContext, codeAccessToken);\n+                    }\n+                });\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+            TenantConfigContext resolvedContext, AccessToken codeAccessToken) {\n+\n+        if (codeAccessToken != null) {\n+            vertxContext.put(\"code_flow_access_token_result\", codeAccessToken);\n         }\n \n-        final JsonObject userInfo = resolvedContext.oidcConfig.authentication.isUserInfoRequired()\n-                ? getUserInfo(vertxContext, request, resolvedContext)\n-                : null;\n+        Uni<JsonObject> userInfo = getUserInfoUni(vertxContext, request, resolvedContext);\n \n-        return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n-            @Override\n-            public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+        return userInfo.onItem().transformToUni(\n+                new Function<JsonObject, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(JsonObject userInfo) {\n+                        return createSecurityIdentityWithOidcServerUni(vertxContext, request, resolvedContext, userInfo);\n+                    }\n+                });\n+    }\n+\n+    private Uni<SecurityIdentity> createSecurityIdentityWithOidcServerUni(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request, TenantConfigContext resolvedContext, final JsonObject userInfo) {\n \n-                resolvedContext.auth.decodeToken(request.getToken().getToken(),\n-                        new Handler<AsyncResult<AccessToken>>() {\n+        final TokenCredential tokenCred = request.getToken();\n+        if (tokenCred instanceof AccessTokenCredential && ((AccessTokenCredential) tokenCred).isOpaque()) {\n+            // remote introspection is required, a blocking call\n+            if (BlockingOperationControl.isBlockingAllowed()) {\n+                return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                    @Override\n+                    public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                        createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext, userInfo);\n+                    }\n+                });\n+            } else {\n+                return Uni.createFrom().emitter(\n+                        new Consumer<UniEmitter<? super SecurityIdentity>>() {\n                             @Override\n-                            public void handle(AsyncResult<AccessToken> event) {\n-                                if (event.failed()) {\n-                                    uniEmitter.fail(new AuthenticationFailedException(event.cause()));\n-                                    return;\n-                                }\n+                            public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                                tenantResolver.getBlockingExecutor().execute(new Runnable() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b370d52d73c49fd8e2348ee3e76604c414c362d"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyOTg0OQ==", "bodyText": "if I'm not mistaken this may be blocking, here you may be on the event loop.", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522129849", "createdAt": "2020-11-12T14:05:46Z", "author": {"login": "cescoffier"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcIdentityProvider.java", "diffHunk": "@@ -81,101 +87,157 @@ public SecurityIdentity get() {\n         if (resolvedContext.oidcConfig.publicKey.isPresent()) {\n             return validateTokenWithoutOidcServer(request, resolvedContext);\n         } else {\n-            return validateTokenWithOidcServer(vertxContext, request, resolvedContext);\n+            return validateAllTokensWithOidcServer(vertxContext, request, resolvedContext);\n         }\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+    private Uni<SecurityIdentity> validateAllTokensWithOidcServer(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request,\n             TenantConfigContext resolvedContext) {\n \n-        if (request.getToken() instanceof IdTokenCredential\n-                && (resolvedContext.oidcConfig.authentication.verifyAccessToken\n-                        || resolvedContext.oidcConfig.roles.source.orElse(null) == Source.accesstoken)) {\n-            vertxContext.put(\"code_flow_access_token_result\",\n-                    verifyCodeFlowAccessToken(vertxContext, request, resolvedContext));\n+        Uni<AccessToken> codeAccessTokenUni = verifyCodeFlowAccessTokenUni(vertxContext, request, resolvedContext);\n+\n+        return codeAccessTokenUni.onItem().transformToUni(\n+                new Function<AccessToken, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(AccessToken codeAccessToken) {\n+                        return validateTokenWithOidcServer(vertxContext, request, resolvedContext, codeAccessToken);\n+                    }\n+                });\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+            TenantConfigContext resolvedContext, AccessToken codeAccessToken) {\n+\n+        if (codeAccessToken != null) {\n+            vertxContext.put(\"code_flow_access_token_result\", codeAccessToken);\n         }\n \n-        final JsonObject userInfo = resolvedContext.oidcConfig.authentication.isUserInfoRequired()\n-                ? getUserInfo(vertxContext, request, resolvedContext)\n-                : null;\n+        Uni<JsonObject> userInfo = getUserInfoUni(vertxContext, request, resolvedContext);\n \n-        return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n-            @Override\n-            public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+        return userInfo.onItem().transformToUni(\n+                new Function<JsonObject, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(JsonObject userInfo) {\n+                        return createSecurityIdentityWithOidcServerUni(vertxContext, request, resolvedContext, userInfo);\n+                    }\n+                });\n+    }\n+\n+    private Uni<SecurityIdentity> createSecurityIdentityWithOidcServerUni(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request, TenantConfigContext resolvedContext, final JsonObject userInfo) {\n \n-                resolvedContext.auth.decodeToken(request.getToken().getToken(),\n-                        new Handler<AsyncResult<AccessToken>>() {\n+        final TokenCredential tokenCred = request.getToken();\n+        if (tokenCred instanceof AccessTokenCredential && ((AccessTokenCredential) tokenCred).isOpaque()) {\n+            // remote introspection is required, a blocking call\n+            if (BlockingOperationControl.isBlockingAllowed()) {\n+                return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                    @Override\n+                    public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                        createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext, userInfo);\n+                    }\n+                });\n+            } else {\n+                return Uni.createFrom().emitter(\n+                        new Consumer<UniEmitter<? super SecurityIdentity>>() {\n                             @Override\n-                            public void handle(AsyncResult<AccessToken> event) {\n-                                if (event.failed()) {\n-                                    uniEmitter.fail(new AuthenticationFailedException(event.cause()));\n-                                    return;\n-                                }\n+                            public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                                tenantResolver.getBlockingExecutor().execute(new Runnable() {\n+                                    @Override\n+                                    public void run() {\n+                                        createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext,\n+                                                userInfo);\n+                                    }\n+                                });\n+                            }\n+                        });\n+            }\n+        } else {\n+            return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                @Override\n+                public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                    createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext, userInfo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b370d52d73c49fd8e2348ee3e76604c414c362d"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMDcwNw==", "bodyText": "on which thread is this called? Are you 100% sure it cannot be the event loop?", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522130707", "createdAt": "2020-11-12T14:07:00Z", "author": {"login": "cescoffier"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcIdentityProvider.java", "diffHunk": "@@ -81,101 +87,157 @@ public SecurityIdentity get() {\n         if (resolvedContext.oidcConfig.publicKey.isPresent()) {\n             return validateTokenWithoutOidcServer(request, resolvedContext);\n         } else {\n-            return validateTokenWithOidcServer(vertxContext, request, resolvedContext);\n+            return validateAllTokensWithOidcServer(vertxContext, request, resolvedContext);\n         }\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+    private Uni<SecurityIdentity> validateAllTokensWithOidcServer(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request,\n             TenantConfigContext resolvedContext) {\n \n-        if (request.getToken() instanceof IdTokenCredential\n-                && (resolvedContext.oidcConfig.authentication.verifyAccessToken\n-                        || resolvedContext.oidcConfig.roles.source.orElse(null) == Source.accesstoken)) {\n-            vertxContext.put(\"code_flow_access_token_result\",\n-                    verifyCodeFlowAccessToken(vertxContext, request, resolvedContext));\n+        Uni<AccessToken> codeAccessTokenUni = verifyCodeFlowAccessTokenUni(vertxContext, request, resolvedContext);\n+\n+        return codeAccessTokenUni.onItem().transformToUni(\n+                new Function<AccessToken, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(AccessToken codeAccessToken) {\n+                        return validateTokenWithOidcServer(vertxContext, request, resolvedContext, codeAccessToken);\n+                    }\n+                });\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+            TenantConfigContext resolvedContext, AccessToken codeAccessToken) {\n+\n+        if (codeAccessToken != null) {\n+            vertxContext.put(\"code_flow_access_token_result\", codeAccessToken);\n         }\n \n-        final JsonObject userInfo = resolvedContext.oidcConfig.authentication.isUserInfoRequired()\n-                ? getUserInfo(vertxContext, request, resolvedContext)\n-                : null;\n+        Uni<JsonObject> userInfo = getUserInfoUni(vertxContext, request, resolvedContext);\n \n-        return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n-            @Override\n-            public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+        return userInfo.onItem().transformToUni(\n+                new Function<JsonObject, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(JsonObject userInfo) {\n+                        return createSecurityIdentityWithOidcServerUni(vertxContext, request, resolvedContext, userInfo);\n+                    }\n+                });\n+    }\n+\n+    private Uni<SecurityIdentity> createSecurityIdentityWithOidcServerUni(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request, TenantConfigContext resolvedContext, final JsonObject userInfo) {\n \n-                resolvedContext.auth.decodeToken(request.getToken().getToken(),\n-                        new Handler<AsyncResult<AccessToken>>() {\n+        final TokenCredential tokenCred = request.getToken();\n+        if (tokenCred instanceof AccessTokenCredential && ((AccessTokenCredential) tokenCred).isOpaque()) {\n+            // remote introspection is required, a blocking call\n+            if (BlockingOperationControl.isBlockingAllowed()) {\n+                return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                    @Override\n+                    public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                        createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext, userInfo);\n+                    }\n+                });\n+            } else {\n+                return Uni.createFrom().emitter(\n+                        new Consumer<UniEmitter<? super SecurityIdentity>>() {\n                             @Override\n-                            public void handle(AsyncResult<AccessToken> event) {\n-                                if (event.failed()) {\n-                                    uniEmitter.fail(new AuthenticationFailedException(event.cause()));\n-                                    return;\n-                                }\n+                            public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                                tenantResolver.getBlockingExecutor().execute(new Runnable() {\n+                                    @Override\n+                                    public void run() {\n+                                        createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext,\n+                                                userInfo);\n+                                    }\n+                                });\n+                            }\n+                        });\n+            }\n+        } else {\n+            return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                @Override\n+                public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                    createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext, userInfo);\n+                }\n+            });\n+        }\n+    }\n \n-                                // Token has been verified, as a JWT or an opaque token, possibly involving\n-                                // an introspection request.\n-                                final TokenCredential tokenCred = request.getToken();\n+    @SuppressWarnings(\"deprecation\")\n+    private void createSecurityIdentityWithOidcServer(UniEmitter<? super SecurityIdentity> uniEmitter,\n+            RoutingContext vertxContext,\n+            TokenAuthenticationRequest request, TenantConfigContext resolvedContext, final JsonObject userInfo) {\n+        resolvedContext.auth.decodeToken(request.getToken().getToken(),\n+                new Handler<AsyncResult<AccessToken>>() {\n+                    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b370d52d73c49fd8e2348ee3e76604c414c362d"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMTAyNA==", "bodyText": "better failing and not throwing.", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522131024", "createdAt": "2020-11-12T14:07:24Z", "author": {"login": "cescoffier"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcIdentityProvider.java", "diffHunk": "@@ -81,101 +87,157 @@ public SecurityIdentity get() {\n         if (resolvedContext.oidcConfig.publicKey.isPresent()) {\n             return validateTokenWithoutOidcServer(request, resolvedContext);\n         } else {\n-            return validateTokenWithOidcServer(vertxContext, request, resolvedContext);\n+            return validateAllTokensWithOidcServer(vertxContext, request, resolvedContext);\n         }\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+    private Uni<SecurityIdentity> validateAllTokensWithOidcServer(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request,\n             TenantConfigContext resolvedContext) {\n \n-        if (request.getToken() instanceof IdTokenCredential\n-                && (resolvedContext.oidcConfig.authentication.verifyAccessToken\n-                        || resolvedContext.oidcConfig.roles.source.orElse(null) == Source.accesstoken)) {\n-            vertxContext.put(\"code_flow_access_token_result\",\n-                    verifyCodeFlowAccessToken(vertxContext, request, resolvedContext));\n+        Uni<AccessToken> codeAccessTokenUni = verifyCodeFlowAccessTokenUni(vertxContext, request, resolvedContext);\n+\n+        return codeAccessTokenUni.onItem().transformToUni(\n+                new Function<AccessToken, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(AccessToken codeAccessToken) {\n+                        return validateTokenWithOidcServer(vertxContext, request, resolvedContext, codeAccessToken);\n+                    }\n+                });\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+            TenantConfigContext resolvedContext, AccessToken codeAccessToken) {\n+\n+        if (codeAccessToken != null) {\n+            vertxContext.put(\"code_flow_access_token_result\", codeAccessToken);\n         }\n \n-        final JsonObject userInfo = resolvedContext.oidcConfig.authentication.isUserInfoRequired()\n-                ? getUserInfo(vertxContext, request, resolvedContext)\n-                : null;\n+        Uni<JsonObject> userInfo = getUserInfoUni(vertxContext, request, resolvedContext);\n \n-        return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n-            @Override\n-            public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+        return userInfo.onItem().transformToUni(\n+                new Function<JsonObject, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(JsonObject userInfo) {\n+                        return createSecurityIdentityWithOidcServerUni(vertxContext, request, resolvedContext, userInfo);\n+                    }\n+                });\n+    }\n+\n+    private Uni<SecurityIdentity> createSecurityIdentityWithOidcServerUni(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request, TenantConfigContext resolvedContext, final JsonObject userInfo) {\n \n-                resolvedContext.auth.decodeToken(request.getToken().getToken(),\n-                        new Handler<AsyncResult<AccessToken>>() {\n+        final TokenCredential tokenCred = request.getToken();\n+        if (tokenCred instanceof AccessTokenCredential && ((AccessTokenCredential) tokenCred).isOpaque()) {\n+            // remote introspection is required, a blocking call\n+            if (BlockingOperationControl.isBlockingAllowed()) {\n+                return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                    @Override\n+                    public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                        createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext, userInfo);\n+                    }\n+                });\n+            } else {\n+                return Uni.createFrom().emitter(\n+                        new Consumer<UniEmitter<? super SecurityIdentity>>() {\n                             @Override\n-                            public void handle(AsyncResult<AccessToken> event) {\n-                                if (event.failed()) {\n-                                    uniEmitter.fail(new AuthenticationFailedException(event.cause()));\n-                                    return;\n-                                }\n+                            public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                                tenantResolver.getBlockingExecutor().execute(new Runnable() {\n+                                    @Override\n+                                    public void run() {\n+                                        createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext,\n+                                                userInfo);\n+                                    }\n+                                });\n+                            }\n+                        });\n+            }\n+        } else {\n+            return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                @Override\n+                public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                    createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext, userInfo);\n+                }\n+            });\n+        }\n+    }\n \n-                                // Token has been verified, as a JWT or an opaque token, possibly involving\n-                                // an introspection request.\n-                                final TokenCredential tokenCred = request.getToken();\n+    @SuppressWarnings(\"deprecation\")\n+    private void createSecurityIdentityWithOidcServer(UniEmitter<? super SecurityIdentity> uniEmitter,\n+            RoutingContext vertxContext,\n+            TokenAuthenticationRequest request, TenantConfigContext resolvedContext, final JsonObject userInfo) {\n+        resolvedContext.auth.decodeToken(request.getToken().getToken(),\n+                new Handler<AsyncResult<AccessToken>>() {\n+                    @Override\n+                    public void handle(AsyncResult<AccessToken> event) {\n+                        if (event.failed()) {\n+                            uniEmitter.fail(new AuthenticationFailedException(event.cause()));\n+                            return;\n+                        }\n \n-                                JsonObject tokenJson = event.result().accessToken();\n+                        // Token has been verified, as a JWT or an opaque token, possibly involving\n+                        // an introspection request.\n+                        final TokenCredential tokenCred = request.getToken();\n \n-                                if (tokenJson == null) {\n-                                    // JSON token representation may be null not only if it is an opaque access token\n-                                    // but also if it is JWT and no JWK with a matching kid is available, asynchronous\n-                                    // JWK refresh has not finished yet, but the fallback introspection request has succeeded.\n-                                    tokenJson = OidcUtils.decodeJwtContent(tokenCred.getToken());\n-                                }\n-                                if (tokenJson != null) {\n-                                    OidcUtils.validatePrimaryJwtTokenType(resolvedContext.oidcConfig.token, tokenJson);\n-                                    JsonObject rolesJson = getRolesJson(vertxContext, resolvedContext, tokenCred, tokenJson,\n-                                            userInfo);\n-                                    try {\n-                                        SecurityIdentity securityIdentity = validateAndCreateIdentity(vertxContext, tokenCred,\n-                                                resolvedContext.oidcConfig,\n-                                                tokenJson, rolesJson, userInfo);\n-                                        if (tokenAutoRefreshPrepared(tokenJson, vertxContext, resolvedContext.oidcConfig)) {\n-                                            throw new TokenAutoRefreshException(securityIdentity);\n-                                        } else {\n-                                            uniEmitter.complete(securityIdentity);\n-                                        }\n-                                    } catch (Throwable ex) {\n-                                        uniEmitter.fail(ex);\n-                                    }\n-                                } else if (tokenCred instanceof IdTokenCredential\n-                                        || tokenCred instanceof AccessTokenCredential\n-                                                && !((AccessTokenCredential) tokenCred).isOpaque()) {\n-                                    uniEmitter\n-                                            .fail(new AuthenticationFailedException(\"JWT token can not be converted to JSON\"));\n+                        JsonObject tokenJson = event.result().accessToken();\n+\n+                        if (tokenJson == null) {\n+                            // JSON token representation may be null not only if it is an opaque access token\n+                            // but also if it is JWT and no JWK with a matching kid is available, asynchronous\n+                            // JWK refresh has not finished yet, but the fallback introspection request has succeeded.\n+                            tokenJson = OidcUtils.decodeJwtContent(tokenCred.getToken());\n+                        }\n+                        if (tokenJson != null) {\n+                            OidcUtils.validatePrimaryJwtTokenType(resolvedContext.oidcConfig.token, tokenJson);\n+                            JsonObject rolesJson = getRolesJson(vertxContext, resolvedContext, tokenCred, tokenJson,\n+                                    userInfo);\n+                            try {\n+                                SecurityIdentity securityIdentity = validateAndCreateIdentity(vertxContext, tokenCred,\n+                                        resolvedContext.oidcConfig,\n+                                        tokenJson, rolesJson, userInfo);\n+                                if (tokenAutoRefreshPrepared(tokenJson, vertxContext, resolvedContext.oidcConfig)) {\n+                                    throw new TokenAutoRefreshException(securityIdentity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b370d52d73c49fd8e2348ee3e76604c414c362d"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMTQzNw==", "bodyText": "where is the blocking call you mentioned earlier?", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522131437", "createdAt": "2020-11-12T14:08:03Z", "author": {"login": "cescoffier"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcIdentityProvider.java", "diffHunk": "@@ -81,101 +87,157 @@ public SecurityIdentity get() {\n         if (resolvedContext.oidcConfig.publicKey.isPresent()) {\n             return validateTokenWithoutOidcServer(request, resolvedContext);\n         } else {\n-            return validateTokenWithOidcServer(vertxContext, request, resolvedContext);\n+            return validateAllTokensWithOidcServer(vertxContext, request, resolvedContext);\n         }\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+    private Uni<SecurityIdentity> validateAllTokensWithOidcServer(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request,\n             TenantConfigContext resolvedContext) {\n \n-        if (request.getToken() instanceof IdTokenCredential\n-                && (resolvedContext.oidcConfig.authentication.verifyAccessToken\n-                        || resolvedContext.oidcConfig.roles.source.orElse(null) == Source.accesstoken)) {\n-            vertxContext.put(\"code_flow_access_token_result\",\n-                    verifyCodeFlowAccessToken(vertxContext, request, resolvedContext));\n+        Uni<AccessToken> codeAccessTokenUni = verifyCodeFlowAccessTokenUni(vertxContext, request, resolvedContext);\n+\n+        return codeAccessTokenUni.onItem().transformToUni(\n+                new Function<AccessToken, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(AccessToken codeAccessToken) {\n+                        return validateTokenWithOidcServer(vertxContext, request, resolvedContext, codeAccessToken);\n+                    }\n+                });\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    private Uni<SecurityIdentity> validateTokenWithOidcServer(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+            TenantConfigContext resolvedContext, AccessToken codeAccessToken) {\n+\n+        if (codeAccessToken != null) {\n+            vertxContext.put(\"code_flow_access_token_result\", codeAccessToken);\n         }\n \n-        final JsonObject userInfo = resolvedContext.oidcConfig.authentication.isUserInfoRequired()\n-                ? getUserInfo(vertxContext, request, resolvedContext)\n-                : null;\n+        Uni<JsonObject> userInfo = getUserInfoUni(vertxContext, request, resolvedContext);\n \n-        return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n-            @Override\n-            public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+        return userInfo.onItem().transformToUni(\n+                new Function<JsonObject, Uni<? extends SecurityIdentity>>() {\n+                    @Override\n+                    public Uni<SecurityIdentity> apply(JsonObject userInfo) {\n+                        return createSecurityIdentityWithOidcServerUni(vertxContext, request, resolvedContext, userInfo);\n+                    }\n+                });\n+    }\n+\n+    private Uni<SecurityIdentity> createSecurityIdentityWithOidcServerUni(RoutingContext vertxContext,\n+            TokenAuthenticationRequest request, TenantConfigContext resolvedContext, final JsonObject userInfo) {\n \n-                resolvedContext.auth.decodeToken(request.getToken().getToken(),\n-                        new Handler<AsyncResult<AccessToken>>() {\n+        final TokenCredential tokenCred = request.getToken();\n+        if (tokenCred instanceof AccessTokenCredential && ((AccessTokenCredential) tokenCred).isOpaque()) {\n+            // remote introspection is required, a blocking call\n+            if (BlockingOperationControl.isBlockingAllowed()) {\n+                return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                    @Override\n+                    public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                        createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext, userInfo);\n+                    }\n+                });\n+            } else {\n+                return Uni.createFrom().emitter(\n+                        new Consumer<UniEmitter<? super SecurityIdentity>>() {\n                             @Override\n-                            public void handle(AsyncResult<AccessToken> event) {\n-                                if (event.failed()) {\n-                                    uniEmitter.fail(new AuthenticationFailedException(event.cause()));\n-                                    return;\n-                                }\n+                            public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                                tenantResolver.getBlockingExecutor().execute(new Runnable() {\n+                                    @Override\n+                                    public void run() {\n+                                        createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext,\n+                                                userInfo);\n+                                    }\n+                                });\n+                            }\n+                        });\n+            }\n+        } else {\n+            return Uni.createFrom().emitter(new Consumer<UniEmitter<? super SecurityIdentity>>() {\n+                @Override\n+                public void accept(UniEmitter<? super SecurityIdentity> uniEmitter) {\n+                    createSecurityIdentityWithOidcServer(uniEmitter, vertxContext, request, resolvedContext, userInfo);\n+                }\n+            });\n+        }\n+    }\n \n-                                // Token has been verified, as a JWT or an opaque token, possibly involving\n-                                // an introspection request.\n-                                final TokenCredential tokenCred = request.getToken();\n+    @SuppressWarnings(\"deprecation\")\n+    private void createSecurityIdentityWithOidcServer(UniEmitter<? super SecurityIdentity> uniEmitter,\n+            RoutingContext vertxContext,\n+            TokenAuthenticationRequest request, TenantConfigContext resolvedContext, final JsonObject userInfo) {\n+        resolvedContext.auth.decodeToken(request.getToken().getToken(),\n+                new Handler<AsyncResult<AccessToken>>() {\n+                    @Override", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMDcwNw=="}, "originalCommit": {"oid": "2b370d52d73c49fd8e2348ee3e76604c414c362d"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMjg5NQ==", "bodyText": "again, may be a different thread. assembly and subscription threads different might be different.", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522132895", "createdAt": "2020-11-12T14:09:59Z", "author": {"login": "cescoffier"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcIdentityProvider.java", "diffHunk": "@@ -224,23 +286,62 @@ private static JsonObject getRolesJson(RoutingContext vertxContext, TenantConfig\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private static AccessToken verifyCodeFlowAccessToken(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+    private Uni<AccessToken> verifyCodeFlowAccessTokenUni(RoutingContext vertxContext, TokenAuthenticationRequest request,\n             TenantConfigContext resolvedContext) {\n-        return Uni.createFrom().emitter(new Consumer<UniEmitter<? super AccessToken>>() {\n-            @Override\n-            public void accept(UniEmitter<? super AccessToken> uniEmitter) {\n-                resolvedContext.auth.decodeToken((String) vertxContext.get(\"access_token\"),\n-                        new Handler<AsyncResult<AccessToken>>() {\n-                            @Override\n-                            public void handle(AsyncResult<AccessToken> event) {\n-                                if (event.failed()) {\n-                                    uniEmitter.fail(new AuthenticationFailedException(event.cause()));\n+        if (request.getToken() instanceof IdTokenCredential\n+                && (resolvedContext.oidcConfig.authentication.verifyAccessToken\n+                        || resolvedContext.oidcConfig.roles.source.orElse(null) == Source.accesstoken)) {\n+            final String codeAccessToken = (String) vertxContext.get(\"access_token\");\n+            if (OidcUtils.isOpaqueToken(codeAccessToken)) {\n+                // remote introspection is required, a blocking call\n+                if (BlockingOperationControl.isBlockingAllowed()) {\n+                    return Uni.createFrom().emitter(\n+                            new Consumer<UniEmitter<? super AccessToken>>() {\n+                                @Override\n+                                public void accept(UniEmitter<? super AccessToken> uniEmitter) {\n+                                    verifyCodeFlowAccessToken(uniEmitter, resolvedContext, codeAccessToken);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b370d52d73c49fd8e2348ee3e76604c414c362d"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzNjYxMw==", "bodyText": "I don't get why sometimes it must be wrapped on an executor and sometimes not.", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522136613", "createdAt": "2020-11-12T14:15:12Z", "author": {"login": "cescoffier"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcIdentityProvider.java", "diffHunk": "@@ -224,23 +286,62 @@ private static JsonObject getRolesJson(RoutingContext vertxContext, TenantConfig\n     }\n \n     @SuppressWarnings(\"deprecation\")\n-    private static AccessToken verifyCodeFlowAccessToken(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+    private Uni<AccessToken> verifyCodeFlowAccessTokenUni(RoutingContext vertxContext, TokenAuthenticationRequest request,\n             TenantConfigContext resolvedContext) {\n-        return Uni.createFrom().emitter(new Consumer<UniEmitter<? super AccessToken>>() {\n-            @Override\n-            public void accept(UniEmitter<? super AccessToken> uniEmitter) {\n-                resolvedContext.auth.decodeToken((String) vertxContext.get(\"access_token\"),\n-                        new Handler<AsyncResult<AccessToken>>() {\n-                            @Override\n-                            public void handle(AsyncResult<AccessToken> event) {\n-                                if (event.failed()) {\n-                                    uniEmitter.fail(new AuthenticationFailedException(event.cause()));\n+        if (request.getToken() instanceof IdTokenCredential\n+                && (resolvedContext.oidcConfig.authentication.verifyAccessToken\n+                        || resolvedContext.oidcConfig.roles.source.orElse(null) == Source.accesstoken)) {\n+            final String codeAccessToken = (String) vertxContext.get(\"access_token\");\n+            if (OidcUtils.isOpaqueToken(codeAccessToken)) {\n+                // remote introspection is required, a blocking call\n+                if (BlockingOperationControl.isBlockingAllowed()) {\n+                    return Uni.createFrom().emitter(\n+                            new Consumer<UniEmitter<? super AccessToken>>() {\n+                                @Override\n+                                public void accept(UniEmitter<? super AccessToken> uniEmitter) {\n+                                    verifyCodeFlowAccessToken(uniEmitter, resolvedContext, codeAccessToken);\n                                 }\n-                                uniEmitter.complete(event.result());\n-                            }\n-                        });\n+                            });\n+                } else {\n+                    return Uni.createFrom().emitter(\n+                            new Consumer<UniEmitter<? super AccessToken>>() {\n+                                @Override\n+                                public void accept(UniEmitter<? super AccessToken> uniEmitter) {\n+                                    tenantResolver.getBlockingExecutor().execute(new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            verifyCodeFlowAccessToken(uniEmitter, resolvedContext, codeAccessToken);\n+                                        }\n+                                    });\n+                                }\n+                            });\n+                }\n+            } else {\n+                return Uni.createFrom().emitter(new Consumer<UniEmitter<? super AccessToken>>() {\n+                    @Override\n+                    public void accept(UniEmitter<? super AccessToken> uniEmitter) {\n+                        verifyCodeFlowAccessToken(uniEmitter, resolvedContext, codeAccessToken);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b370d52d73c49fd8e2348ee3e76604c414c362d"}, "originalPosition": 315}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzNjk2Mw==", "bodyText": "Again, same issue.", "url": "https://github.com/quarkusio/quarkus/pull/13257#discussion_r522136963", "createdAt": "2020-11-12T14:15:42Z", "author": {"login": "cescoffier"}, "path": "extensions/oidc/runtime/src/main/java/io/quarkus/oidc/runtime/OidcIdentityProvider.java", "diffHunk": "@@ -266,33 +367,57 @@ public void handle(AsyncResult<AccessToken> event) {\n         }\n     }\n \n-    private static JsonObject getUserInfo(RoutingContext vertxContext, TokenAuthenticationRequest request,\n+    private Uni<JsonObject> getUserInfoUni(RoutingContext vertxContext, TokenAuthenticationRequest request,\n             TenantConfigContext resolvedContext) {\n+        if (resolvedContext.oidcConfig.authentication.isUserInfoRequired()) {\n+            if (BlockingOperationControl.isBlockingAllowed()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b370d52d73c49fd8e2348ee3e76604c414c362d"}, "originalPosition": 349}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2b370d52d73c49fd8e2348ee3e76604c414c362d", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/2b370d52d73c49fd8e2348ee3e76604c414c362d", "committedDate": "2020-11-12T13:28:31Z", "message": "Remove Uni await for OIDC code access token validation and user info calls"}, "afterCommit": {"oid": "994c6b8caecfa7c9cabc8346f57a943cb2879b35", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/994c6b8caecfa7c9cabc8346f57a943cb2879b35", "committedDate": "2020-11-12T15:15:23Z", "message": "Remove Uni await for OIDC code access token validation and user info calls"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a2afc076575abaac486c5d23b698b2e6d8594ef", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/4a2afc076575abaac486c5d23b698b2e6d8594ef", "committedDate": "2020-11-12T16:05:23Z", "message": "Remove Uni await for OIDC code access token validation and user info calls"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "994c6b8caecfa7c9cabc8346f57a943cb2879b35", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/994c6b8caecfa7c9cabc8346f57a943cb2879b35", "committedDate": "2020-11-12T15:15:23Z", "message": "Remove Uni await for OIDC code access token validation and user info calls"}, "afterCommit": {"oid": "4a2afc076575abaac486c5d23b698b2e6d8594ef", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/4a2afc076575abaac486c5d23b698b2e6d8594ef", "committedDate": "2020-11-12T16:05:23Z", "message": "Remove Uni await for OIDC code access token validation and user info calls"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5MjU0MTc5", "url": "https://github.com/quarkusio/quarkus/pull/13257#pullrequestreview-529254179", "createdAt": "2020-11-12T16:18:06Z", "commit": {"oid": "4a2afc076575abaac486c5d23b698b2e6d8594ef"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5ODg5OTIw", "url": "https://github.com/quarkusio/quarkus/pull/13257#pullrequestreview-529889920", "createdAt": "2020-11-13T09:06:36Z", "commit": {"oid": "4a2afc076575abaac486c5d23b698b2e6d8594ef"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1542, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}