{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU4OTIwMjQw", "number": 6387, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QwOTo1NTowNFrODVn52w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxMjo0MDozN1rODVpmpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDAwNDc1OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/kafka.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QwOTo1NTowNFrOFZ8wRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QwOTo1NTowNFrOFZ8wRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NDExOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Quarkus has built-in capabilities to deals with JSON Kafka messages.\n          \n          \n            \n            Quarkus has built-in capabilities to deal with JSON Kafka messages.", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362754119", "createdAt": "2020-01-03T09:55:04Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b07574a9589794cafb098c722b60096916ab0dcd"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDAwNTE5OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/kafka.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QwOTo1NToxOFrOFZ8wiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QwOTo1NToxOFrOFZ8wiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NDE4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Imagine we have a `Fruit` pojo as following:\n          \n          \n            \n            Imagine we have a `Fruit` pojo as follows:", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362754184", "createdAt": "2020-01-03T09:55:18Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as following:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b07574a9589794cafb098c722b60096916ab0dcd"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDAwNzI0OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/kafka.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QwOTo1NjoxN1rOFZ8xwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QwOTo1NjoxN1rOFZ8xwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NDQ5Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            First, you need to include the `quarkus-jsonb` dependency (if you already use the `quarkus-resteasy-jsonb` dependency this is not needed).\n          \n          \n            \n            First, you need to include the `quarkus-jsonb` extension (if you already use the `quarkus-resteasy-jsonb` extension, this is not needed).", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362754496", "createdAt": "2020-01-03T09:56:17Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as following:\n+\n+[source,java]\n+----\n+public class Fruit {\n+\n+    public String name;\n+    public int price;\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, int price) {\n+        this.name = name;\n+        this.price = price;\n+    }\n+}\n+----\n+\n+And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.\n+\n+[source,java]\n+----\n+import io.smallrye.reactive.messaging.annotations.Broadcast;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+/**\n+* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n+* The result is pushed to the \"fruit-out\" stream.\n+*/\n+@ApplicationScoped\n+public class FruitProcessor {\n+\n+    private static final double CONVERSION_RATE = 0.88;\n+\n+    @Incoming(\"fruit-in\")\n+    @Outgoing(\"fruit-out\")\n+    @Broadcast\n+    public double process(Fruit fruit) {\n+        fruit.price = fruit.price * CONVERSION_RATE;\n+        return fruit;\n+    }\n+\n+}\n+----\n+\n+To do this, we will need to setup JSON serialization with JSON-B or Jackson.\n+\n+NOTE: With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`.\n+\n+=== Serializing via JSON-B\n+\n+First, you need to include the `quarkus-jsonb` dependency (if you already use the `quarkus-resteasy-jsonb` dependency this is not needed).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b07574a9589794cafb098c722b60096916ab0dcd"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDAwODk4OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/kafka.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QwOTo1NzoxMFrOFZ8yvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QwOTo1NzoxMFrOFZ8yvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NDc0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Now, your Kafka messages will contains a JSON-B serialized representation of your Fruit pojo !\n          \n          \n            \n            Now, your Kafka messages will contain a JSON-B serialized representation of your Fruit pojo.", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362754748", "createdAt": "2020-01-03T09:57:10Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as following:\n+\n+[source,java]\n+----\n+public class Fruit {\n+\n+    public String name;\n+    public int price;\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, int price) {\n+        this.name = name;\n+        this.price = price;\n+    }\n+}\n+----\n+\n+And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.\n+\n+[source,java]\n+----\n+import io.smallrye.reactive.messaging.annotations.Broadcast;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+/**\n+* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n+* The result is pushed to the \"fruit-out\" stream.\n+*/\n+@ApplicationScoped\n+public class FruitProcessor {\n+\n+    private static final double CONVERSION_RATE = 0.88;\n+\n+    @Incoming(\"fruit-in\")\n+    @Outgoing(\"fruit-out\")\n+    @Broadcast\n+    public double process(Fruit fruit) {\n+        fruit.price = fruit.price * CONVERSION_RATE;\n+        return fruit;\n+    }\n+\n+}\n+----\n+\n+To do this, we will need to setup JSON serialization with JSON-B or Jackson.\n+\n+NOTE: With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`.\n+\n+=== Serializing via JSON-B\n+\n+First, you need to include the `quarkus-jsonb` dependency (if you already use the `quarkus-resteasy-jsonb` dependency this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jsonb</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jsonb;\n+\n+import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n+\n+public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+NOTE: If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer`\n+that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.\n+\n+Finally, configure your streams to use the JSON-B serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n+----\n+\n+Now, your Kafka messages will contains a JSON-B serialized representation of your Fruit pojo !", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b07574a9589794cafb098c722b60096916ab0dcd"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDAwOTQ2OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/kafka.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QwOTo1NzoyN1rOFZ8zDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QwOTo1NzoyN1rOFZ8zDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NDgyOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            First, you need to include the `quarkus-jackson` dependency (if you already use the `quarkus-jackson-jsonb` dependency this is not needed).\n          \n          \n            \n            First, you need to include the `quarkus-jackson` extension (if you already use the `quarkus-jackson-jsonb` extension, this is not needed).", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362754829", "createdAt": "2020-01-03T09:57:27Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as following:\n+\n+[source,java]\n+----\n+public class Fruit {\n+\n+    public String name;\n+    public int price;\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, int price) {\n+        this.name = name;\n+        this.price = price;\n+    }\n+}\n+----\n+\n+And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.\n+\n+[source,java]\n+----\n+import io.smallrye.reactive.messaging.annotations.Broadcast;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+/**\n+* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n+* The result is pushed to the \"fruit-out\" stream.\n+*/\n+@ApplicationScoped\n+public class FruitProcessor {\n+\n+    private static final double CONVERSION_RATE = 0.88;\n+\n+    @Incoming(\"fruit-in\")\n+    @Outgoing(\"fruit-out\")\n+    @Broadcast\n+    public double process(Fruit fruit) {\n+        fruit.price = fruit.price * CONVERSION_RATE;\n+        return fruit;\n+    }\n+\n+}\n+----\n+\n+To do this, we will need to setup JSON serialization with JSON-B or Jackson.\n+\n+NOTE: With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`.\n+\n+=== Serializing via JSON-B\n+\n+First, you need to include the `quarkus-jsonb` dependency (if you already use the `quarkus-resteasy-jsonb` dependency this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jsonb</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jsonb;\n+\n+import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n+\n+public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+NOTE: If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer`\n+that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.\n+\n+Finally, configure your streams to use the JSON-B serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n+----\n+\n+Now, your Kafka messages will contains a JSON-B serialized representation of your Fruit pojo !\n+\n+=== Serializing via Jackson\n+\n+First, you need to include the `quarkus-jackson` dependency (if you already use the `quarkus-jackson-jsonb` dependency this is not needed).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b07574a9589794cafb098c722b60096916ab0dcd"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDAxMDM1OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/kafka.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QwOTo1Nzo1NFrOFZ8zlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxMTowNzozM1rOFZ99iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NDk2NA==", "bodyText": "Let's get rid of the blank lines.", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362754964", "createdAt": "2020-01-03T09:57:54Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as following:\n+\n+[source,java]\n+----\n+public class Fruit {\n+\n+    public String name;\n+    public int price;\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, int price) {\n+        this.name = name;\n+        this.price = price;\n+    }\n+}\n+----\n+\n+And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.\n+\n+[source,java]\n+----\n+import io.smallrye.reactive.messaging.annotations.Broadcast;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+/**\n+* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n+* The result is pushed to the \"fruit-out\" stream.\n+*/\n+@ApplicationScoped\n+public class FruitProcessor {\n+\n+    private static final double CONVERSION_RATE = 0.88;\n+\n+    @Incoming(\"fruit-in\")\n+    @Outgoing(\"fruit-out\")\n+    @Broadcast\n+    public double process(Fruit fruit) {\n+        fruit.price = fruit.price * CONVERSION_RATE;\n+        return fruit;\n+    }\n+\n+}\n+----\n+\n+To do this, we will need to setup JSON serialization with JSON-B or Jackson.\n+\n+NOTE: With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`.\n+\n+=== Serializing via JSON-B\n+\n+First, you need to include the `quarkus-jsonb` dependency (if you already use the `quarkus-resteasy-jsonb` dependency this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jsonb</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jsonb;\n+\n+import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n+\n+public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+NOTE: If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer`\n+that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.\n+\n+Finally, configure your streams to use the JSON-B serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n+----\n+\n+Now, your Kafka messages will contains a JSON-B serialized representation of your Fruit pojo !\n+\n+=== Serializing via Jackson\n+\n+First, you need to include the `quarkus-jackson` dependency (if you already use the `quarkus-jackson-jsonb` dependency this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jackson</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `ObjectMapperSerializer` that can be used to serialize all pojos via Jackson,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jackson;\n+\n+import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n+\n+public class FruitDeserializer extends ObjectMapperDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+Finally, configure your streams to use the Jackson serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b07574a9589794cafb098c722b60096916ab0dcd"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc3Mzg5Nw==", "bodyText": "done", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362773897", "createdAt": "2020-01-03T11:07:33Z", "author": {"login": "loicmathieu"}, "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as following:\n+\n+[source,java]\n+----\n+public class Fruit {\n+\n+    public String name;\n+    public int price;\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, int price) {\n+        this.name = name;\n+        this.price = price;\n+    }\n+}\n+----\n+\n+And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.\n+\n+[source,java]\n+----\n+import io.smallrye.reactive.messaging.annotations.Broadcast;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+/**\n+* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n+* The result is pushed to the \"fruit-out\" stream.\n+*/\n+@ApplicationScoped\n+public class FruitProcessor {\n+\n+    private static final double CONVERSION_RATE = 0.88;\n+\n+    @Incoming(\"fruit-in\")\n+    @Outgoing(\"fruit-out\")\n+    @Broadcast\n+    public double process(Fruit fruit) {\n+        fruit.price = fruit.price * CONVERSION_RATE;\n+        return fruit;\n+    }\n+\n+}\n+----\n+\n+To do this, we will need to setup JSON serialization with JSON-B or Jackson.\n+\n+NOTE: With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`.\n+\n+=== Serializing via JSON-B\n+\n+First, you need to include the `quarkus-jsonb` dependency (if you already use the `quarkus-resteasy-jsonb` dependency this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jsonb</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jsonb;\n+\n+import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n+\n+public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+NOTE: If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer`\n+that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.\n+\n+Finally, configure your streams to use the JSON-B serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n+----\n+\n+Now, your Kafka messages will contains a JSON-B serialized representation of your Fruit pojo !\n+\n+=== Serializing via Jackson\n+\n+First, you need to include the `quarkus-jackson` dependency (if you already use the `quarkus-jackson-jsonb` dependency this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jackson</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `ObjectMapperSerializer` that can be used to serialize all pojos via Jackson,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jackson;\n+\n+import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n+\n+public class FruitDeserializer extends ObjectMapperDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+Finally, configure your streams to use the Jackson serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer\n+\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NDk2NA=="}, "originalCommit": {"oid": "b07574a9589794cafb098c722b60096916ab0dcd"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDAxMDcwOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/kafka.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QwOTo1ODowNlrOFZ8z0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QwOTo1ODowNlrOFZ8z0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc1NTAyNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Now, your Kafka messages will contains a Jackson serialized representation of your Fruit pojo !\n          \n          \n            \n            Now, your Kafka messages will contain a Jackson serialized representation of your Fruit pojo.", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362755024", "createdAt": "2020-01-03T09:58:06Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,164 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deals with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as following:\n+\n+[source,java]\n+----\n+public class Fruit {\n+\n+    public String name;\n+    public int price;\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, int price) {\n+        this.name = name;\n+        this.price = price;\n+    }\n+}\n+----\n+\n+And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.\n+\n+[source,java]\n+----\n+import io.smallrye.reactive.messaging.annotations.Broadcast;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+/**\n+* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n+* The result is pushed to the \"fruit-out\" stream.\n+*/\n+@ApplicationScoped\n+public class FruitProcessor {\n+\n+    private static final double CONVERSION_RATE = 0.88;\n+\n+    @Incoming(\"fruit-in\")\n+    @Outgoing(\"fruit-out\")\n+    @Broadcast\n+    public double process(Fruit fruit) {\n+        fruit.price = fruit.price * CONVERSION_RATE;\n+        return fruit;\n+    }\n+\n+}\n+----\n+\n+To do this, we will need to setup JSON serialization with JSON-B or Jackson.\n+\n+NOTE: With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`.\n+\n+=== Serializing via JSON-B\n+\n+First, you need to include the `quarkus-jsonb` dependency (if you already use the `quarkus-resteasy-jsonb` dependency this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jsonb</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jsonb;\n+\n+import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n+\n+public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+NOTE: If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer`\n+that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.\n+\n+Finally, configure your streams to use the JSON-B serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n+----\n+\n+Now, your Kafka messages will contains a JSON-B serialized representation of your Fruit pojo !\n+\n+=== Serializing via Jackson\n+\n+First, you need to include the `quarkus-jackson` dependency (if you already use the `quarkus-jackson-jsonb` dependency this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jackson</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `ObjectMapperSerializer` that can be used to serialize all pojos via Jackson,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jackson;\n+\n+import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n+\n+public class FruitDeserializer extends ObjectMapperDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+Finally, configure your streams to use the Jackson serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer\n+\n+\n+----\n+\n+Now, your Kafka messages will contains a Jackson serialized representation of your Fruit pojo !", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b07574a9589794cafb098c722b60096916ab0dcd"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0MDI4MzI3OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/kafka.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxMjo0MDozN1rOFZ_S9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wM1QxMjo0MDozN1rOFZ_S9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mjc5NTc2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you want Resteasy to send JSON Server-Sent Events, you need to use the `@SseElementType` annotation to define the content type of the events,\n          \n          \n            \n            If you want RESTEasy to send JSON Server-Sent Events, you need to use the `@SseElementType` annotation to define the content type of the events,", "url": "https://github.com/quarkusio/quarkus/pull/6387#discussion_r362795765", "createdAt": "2020-01-03T12:40:37Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/kafka.adoc", "diffHunk": "@@ -354,6 +354,197 @@ If enabled, when you access the `/health/ready` endpoint of your application you\n This behavior can be enabled by setting the `quarkus.kafka.health.enabled` property to `true` in your `application.properties`.\n You also need to point `quarkus.kafka.bootstrap-servers` to your Kafka cluster.\n \n+== JSON serialization\n+\n+Quarkus has built-in capabilities to deal with JSON Kafka messages.\n+\n+Imagine we have a `Fruit` pojo as follows:\n+\n+[source,java]\n+----\n+public class Fruit {\n+\n+    public String name;\n+    public int price;\n+\n+    public Fruit() {\n+    }\n+\n+    public Fruit(String name, int price) {\n+        this.name = name;\n+        this.price = price;\n+    }\n+}\n+----\n+\n+And we want to use it to receive messages from Kafka, make some price transformation, and send messages back to Kafka.\n+\n+[source,java]\n+----\n+import io.smallrye.reactive.messaging.annotations.Broadcast;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+/**\n+* A bean consuming data from the \"fruit-in\" Kafka topic and applying some price conversion.\n+* The result is pushed to the \"fruit-out\" stream.\n+*/\n+@ApplicationScoped\n+public class FruitProcessor {\n+\n+    private static final double CONVERSION_RATE = 0.88;\n+\n+    @Incoming(\"fruit-in\")\n+    @Outgoing(\"fruit-out\")\n+    @Broadcast\n+    public double process(Fruit fruit) {\n+        fruit.price = fruit.price * CONVERSION_RATE;\n+        return fruit;\n+    }\n+\n+}\n+----\n+\n+To do this, we will need to setup JSON serialization with JSON-B or Jackson.\n+\n+NOTE: With JSON serialization correctly configured, you can also use `Publisher<Fruit>` and `Emitter<Fruit>`.\n+\n+=== Serializing via JSON-B\n+\n+First, you need to include the `quarkus-jsonb` extension (if you already use the `quarkus-resteasy-jsonb` extension, this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jsonb</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `JsonbSerializer` that can be used to serialize all pojos via JSON-B,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the generic `JsonbDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jsonb;\n+\n+import io.quarkus.kafka.client.serialization.JsonbDeserializer;\n+\n+public class FruitDeserializer extends JsonbDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+NOTE: If you don't want to create a deserializer for each of your pojo, you can use the generic `io.vertx.kafka.client.serialization.JsonObjectDeserializer`\n+that will deserialize to a `javax.json.JsonObject`. The corresponding serializer can also be used: `io.vertx.kafka.client.serialization.JsonObjectSerializer`.\n+\n+Finally, configure your streams to use the JSON-B serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jsonb.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.JsonbSerializer\n+----\n+\n+Now, your Kafka messages will contain a JSON-B serialized representation of your Fruit pojo.\n+\n+=== Serializing via Jackson\n+\n+First, you need to include the `quarkus-jackson` extension (if you already use the `quarkus-jackson-jsonb` extension, this is not needed).\n+\n+[source, xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-jackson</artifactId>\n+</dependency>\n+----\n+\n+There is an existing `ObjectMapperSerializer` that can be used to serialize all pojos via Jackson,\n+but the corresponding deserializer is generic, so it needs to be subclassed.\n+\n+So, let's create a `FruitDeserializer` that extends the `ObjectMapperDeserializer`.\n+\n+[source,java]\n+----\n+package com.acme.fruit.jackson;\n+\n+import io.quarkus.kafka.client.serialization.ObjectMapperDeserializer;\n+\n+public class FruitDeserializer extends ObjectMapperDeserializer<Fruit> {\n+    public FruitDeserializer(){\n+        // pass the class to the parent.\n+        super(Fruit.class);\n+    }\n+}\n+----\n+\n+Finally, configure your streams to use the Jackson serializer and deserializer.\n+\n+[source,properties]\n+----\n+# Configure the Kafka source (we read from it)\n+mp.messaging.incoming.fruit-in.connector=smallrye-kafka\n+mp.messaging.incoming.fruit-in.topic=fruit-in\n+mp.messaging.incoming.fruit-in.value.deserializer=com.acme.fruit.jackson.FruitDeserializer\n+\n+# Configure the Kafka sink (we write to it)\n+mp.messaging.outgoing.fruit-out.connector=smallrye-kafka\n+mp.messaging.outgoing.fruit-out.topic=fruit-out\n+mp.messaging.outgoing.fruit-out.value.serializer=io.quarkus.kafka.client.serialization.ObjectMapperSerializer\n+----\n+\n+Now, your Kafka messages will contain a Jackson serialized representation of your Fruit pojo.\n+\n+=== Sending JSON Server-Sent Events (SSE)\n+\n+If you want Resteasy to send JSON Server-Sent Events, you need to use the `@SseElementType` annotation to define the content type of the events,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "400475b22bd9e783faa7f4a788779ecf1e3dd96d"}, "originalPosition": 162}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1277, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}