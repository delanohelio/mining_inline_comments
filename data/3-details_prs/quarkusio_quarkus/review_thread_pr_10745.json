{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ5NDI4NzY1", "number": 10745, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMTo1NDoxMlrOEOpoSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNTo1Njo1N1rOEQsI8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzk3NTc4OnYy", "diffSide": "RIGHT", "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/ElasticsearchConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMTo1NDoxMlrOGx6qpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMTo1NDoxMlrOGx6qpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5NDU5Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * The username used for authentication.\n          \n          \n            \n                 * The username for basic HTTP authentication.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r454994596", "createdAt": "2020-07-15T11:54:12Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/ElasticsearchConfig.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigPhase;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot(phase = ConfigPhase.RUN_TIME)\n+public class ElasticsearchConfig {\n+\n+    /**\n+     * The list of hosts of the Elasticsearch servers.\n+     */\n+    @ConfigItem(defaultValue = \"localhost:9200\")\n+    public List<String> hosts;\n+\n+    /**\n+     * The protocol to use when contacting Elasticsearch servers.\n+     * Set to \"https\" to enable SSL/TLS.\n+     */\n+    @ConfigItem(defaultValue = \"http\")\n+    public String protocol;\n+\n+    /**\n+     * The username used for authentication.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzk3NjY0OnYy", "diffSide": "RIGHT", "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/ElasticsearchConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMTo1NDoyOFrOGx6rHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMTo1NDoyOFrOGx6rHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5NDcxOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * The password used for authentication.\n          \n          \n            \n                 * The password for basic HTTP authentication.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r454994718", "createdAt": "2020-07-15T11:54:28Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/ElasticsearchConfig.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigPhase;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot(phase = ConfigPhase.RUN_TIME)\n+public class ElasticsearchConfig {\n+\n+    /**\n+     * The list of hosts of the Elasticsearch servers.\n+     */\n+    @ConfigItem(defaultValue = \"localhost:9200\")\n+    public List<String> hosts;\n+\n+    /**\n+     * The protocol to use when contacting Elasticsearch servers.\n+     * Set to \"https\" to enable SSL/TLS.\n+     */\n+    @ConfigItem(defaultValue = \"http\")\n+    public String protocol;\n+\n+    /**\n+     * The username used for authentication.\n+     */\n+    @ConfigItem\n+    public Optional<String> username;\n+\n+    /**\n+     * The password used for authentication.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzk4MzMwOnYy", "diffSide": "RIGHT", "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/ElasticsearchConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMTo1NjoyN1rOGx6vJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMTo1NjoyN1rOGx6vJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5NTc0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * By default, this is the number of locally detected processors.\n          \n          \n            \n                 * By default, this is the number of locally detected processors.\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * Thread counts higher than the number of processors should not be necessary because the I/O threads rely on non-blocking operations,\n          \n          \n            \n                 * but you may want to use a thread count lower than the number of processors.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r454995748", "createdAt": "2020-07-15T11:56:27Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/ElasticsearchConfig.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigPhase;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot(phase = ConfigPhase.RUN_TIME)\n+public class ElasticsearchConfig {\n+\n+    /**\n+     * The list of hosts of the Elasticsearch servers.\n+     */\n+    @ConfigItem(defaultValue = \"localhost:9200\")\n+    public List<String> hosts;\n+\n+    /**\n+     * The protocol to use when contacting Elasticsearch servers.\n+     * Set to \"https\" to enable SSL/TLS.\n+     */\n+    @ConfigItem(defaultValue = \"http\")\n+    public String protocol;\n+\n+    /**\n+     * The username used for authentication.\n+     */\n+    @ConfigItem\n+    public Optional<String> username;\n+\n+    /**\n+     * The password used for authentication.\n+     */\n+    @ConfigItem\n+    public Optional<String> password;\n+\n+    /**\n+     * The connection timeout.\n+     */\n+    @ConfigItem(defaultValue = \"1S\")\n+    public Duration connectionTimeout;\n+\n+    /**\n+     * The socket timeout.\n+     */\n+    @ConfigItem(defaultValue = \"30S\")\n+    public Duration socketTimeout;\n+\n+    /**\n+     * The number of IO thread.\n+     * By default, this is the number of locally detected processors.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzk5MDIwOnYy", "diffSide": "RIGHT", "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMTo1ODoyM1rOGx6zNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNTo1OToxNVrOGyEywg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5Njc5MA==", "bodyText": "Shouldn't the port be optional and default to 9200?", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r454996790", "createdAt": "2020-07-15T11:58:23Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;\n+import org.apache.http.impl.nio.reactor.IOReactorConfig;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.sniff.Sniffer;\n+\n+public final class RestClientBuilderHelper {\n+\n+    private RestClientBuilderHelper() {\n+        // avoid instantiation\n+    }\n+\n+    static RestClientBuilder createRestClientBuilder(ElasticsearchConfig config) {\n+        List<HttpHost> hosts = config.hosts.stream().map(s -> new HttpHost(s.substring(0, s.indexOf(\":\")),\n+                Integer.parseInt(s.substring(s.indexOf(\":\") + 1)), config.protocol)).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA5ODQyNw==", "bodyText": "I'm not sure tbh but we should at least change the config stuff to use InetSocketAddress IMHO.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455098427", "createdAt": "2020-07-15T14:32:07Z", "author": {"login": "gsmet"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;\n+import org.apache.http.impl.nio.reactor.IOReactorConfig;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.sniff.Sniffer;\n+\n+public final class RestClientBuilderHelper {\n+\n+    private RestClientBuilderHelper() {\n+        // avoid instantiation\n+    }\n+\n+    static RestClientBuilder createRestClientBuilder(ElasticsearchConfig config) {\n+        List<HttpHost> hosts = config.hosts.stream().map(s -> new HttpHost(s.substring(0, s.indexOf(\":\")),\n+                Integer.parseInt(s.substring(s.indexOf(\":\") + 1)), config.protocol)).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5Njc5MA=="}, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE2MDUxNA==", "bodyText": "mongodb, hibernate-search-elasticsearch and neo4j uses such a construct so I think it's OK here.\nWe can of course make the port optional but it's really standard to define elasticsearch URL this way so I wouldn't bother as it will implies a lot more branches in the configuration code.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455160514", "createdAt": "2020-07-15T15:59:15Z", "author": {"login": "loicmathieu"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;\n+import org.apache.http.impl.nio.reactor.IOReactorConfig;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.sniff.Sniffer;\n+\n+public final class RestClientBuilderHelper {\n+\n+    private RestClientBuilderHelper() {\n+        // avoid instantiation\n+    }\n+\n+    static RestClientBuilder createRestClientBuilder(ElasticsearchConfig config) {\n+        List<HttpHost> hosts = config.hosts.stream().map(s -> new HttpHost(s.substring(0, s.indexOf(\":\")),\n+                Integer.parseInt(s.substring(s.indexOf(\":\") + 1)), config.protocol)).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5Njc5MA=="}, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzk5NTQ5OnYy", "diffSide": "RIGHT", "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjowMDowN1rOGx62cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDozMjo0NFrOGyBCKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5NzYxOA==", "bodyText": "In Hibernate Search, we issue a warning in this case if the protocol is set to http (the default), because then the password will be transmitted using a clear-text connection, which is a security issue on public networks.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r454997618", "createdAt": "2020-07-15T12:00:07Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;\n+import org.apache.http.impl.nio.reactor.IOReactorConfig;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.sniff.Sniffer;\n+\n+public final class RestClientBuilderHelper {\n+\n+    private RestClientBuilderHelper() {\n+        // avoid instantiation\n+    }\n+\n+    static RestClientBuilder createRestClientBuilder(ElasticsearchConfig config) {\n+        List<HttpHost> hosts = config.hosts.stream().map(s -> new HttpHost(s.substring(0, s.indexOf(\":\")),\n+                Integer.parseInt(s.substring(s.indexOf(\":\") + 1)), config.protocol)).collect(Collectors.toList());\n+        RestClientBuilder builder = RestClient.builder(hosts.toArray(new HttpHost[0]));\n+\n+        builder.setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() {\n+            @Override\n+            public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {\n+                return requestConfigBuilder\n+                        .setConnectTimeout((int) config.connectionTimeout.toMillis())\n+                        .setSocketTimeout((int) config.socketTimeout.toMillis());\n+            }\n+        });\n+\n+        builder.setHttpClientConfigCallback(new RestClientBuilder.HttpClientConfigCallback() {\n+            @Override\n+            public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {\n+                if (config.username.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA5ODkyMQ==", "bodyText": "That's a good idea.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455098921", "createdAt": "2020-07-15T14:32:44Z", "author": {"login": "gsmet"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;\n+import org.apache.http.impl.nio.reactor.IOReactorConfig;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.sniff.Sniffer;\n+\n+public final class RestClientBuilderHelper {\n+\n+    private RestClientBuilderHelper() {\n+        // avoid instantiation\n+    }\n+\n+    static RestClientBuilder createRestClientBuilder(ElasticsearchConfig config) {\n+        List<HttpHost> hosts = config.hosts.stream().map(s -> new HttpHost(s.substring(0, s.indexOf(\":\")),\n+                Integer.parseInt(s.substring(s.indexOf(\":\") + 1)), config.protocol)).collect(Collectors.toList());\n+        RestClientBuilder builder = RestClient.builder(hosts.toArray(new HttpHost[0]));\n+\n+        builder.setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() {\n+            @Override\n+            public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {\n+                return requestConfigBuilder\n+                        .setConnectTimeout((int) config.connectionTimeout.toMillis())\n+                        .setSocketTimeout((int) config.socketTimeout.toMillis());\n+            }\n+        });\n+\n+        builder.setHttpClientConfigCallback(new RestClientBuilder.HttpClientConfigCallback() {\n+            @Override\n+            public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {\n+                if (config.username.isPresent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5NzYxOA=="}, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODAwMzYyOnYy", "diffSide": "RIGHT", "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjowMjoyM1rOGx67HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDozMzoxMFrOGyBDTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5ODgxMg==", "bodyText": "As far as I know, the passowrd may not be provided here. I believe HTTP authentication with an empty password is legal?\nThe http client seems to handle this case by using the string \"null\" as the password, though. Which I doubt will ever work.\nIn any case, you may want a better exception than the NoSuchElementException currently being thrown by password.get().", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r454998812", "createdAt": "2020-07-15T12:02:23Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;\n+import org.apache.http.impl.nio.reactor.IOReactorConfig;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.sniff.Sniffer;\n+\n+public final class RestClientBuilderHelper {\n+\n+    private RestClientBuilderHelper() {\n+        // avoid instantiation\n+    }\n+\n+    static RestClientBuilder createRestClientBuilder(ElasticsearchConfig config) {\n+        List<HttpHost> hosts = config.hosts.stream().map(s -> new HttpHost(s.substring(0, s.indexOf(\":\")),\n+                Integer.parseInt(s.substring(s.indexOf(\":\") + 1)), config.protocol)).collect(Collectors.toList());\n+        RestClientBuilder builder = RestClient.builder(hosts.toArray(new HttpHost[0]));\n+\n+        builder.setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() {\n+            @Override\n+            public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {\n+                return requestConfigBuilder\n+                        .setConnectTimeout((int) config.connectionTimeout.toMillis())\n+                        .setSocketTimeout((int) config.socketTimeout.toMillis());\n+            }\n+        });\n+\n+        builder.setHttpClientConfigCallback(new RestClientBuilder.HttpClientConfigCallback() {\n+            @Override\n+            public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {\n+                if (config.username.isPresent()) {\n+                    CredentialsProvider credentialsProvider = new BasicCredentialsProvider();\n+                    credentialsProvider.setCredentials(AuthScope.ANY,\n+                            new UsernamePasswordCredentials(config.username.get(), config.password.get()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA5OTIxNQ==", "bodyText": "Agreed.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455099215", "createdAt": "2020-07-15T14:33:10Z", "author": {"login": "gsmet"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;\n+import org.apache.http.impl.nio.reactor.IOReactorConfig;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.sniff.Sniffer;\n+\n+public final class RestClientBuilderHelper {\n+\n+    private RestClientBuilderHelper() {\n+        // avoid instantiation\n+    }\n+\n+    static RestClientBuilder createRestClientBuilder(ElasticsearchConfig config) {\n+        List<HttpHost> hosts = config.hosts.stream().map(s -> new HttpHost(s.substring(0, s.indexOf(\":\")),\n+                Integer.parseInt(s.substring(s.indexOf(\":\") + 1)), config.protocol)).collect(Collectors.toList());\n+        RestClientBuilder builder = RestClient.builder(hosts.toArray(new HttpHost[0]));\n+\n+        builder.setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() {\n+            @Override\n+            public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {\n+                return requestConfigBuilder\n+                        .setConnectTimeout((int) config.connectionTimeout.toMillis())\n+                        .setSocketTimeout((int) config.socketTimeout.toMillis());\n+            }\n+        });\n+\n+        builder.setHttpClientConfigCallback(new RestClientBuilder.HttpClientConfigCallback() {\n+            @Override\n+            public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {\n+                if (config.username.isPresent()) {\n+                    CredentialsProvider credentialsProvider = new BasicCredentialsProvider();\n+                    credentialsProvider.setCredentials(AuthScope.ANY,\n+                            new UsernamePasswordCredentials(config.username.get(), config.password.get()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5ODgxMg=="}, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODAyNzc1OnYy", "diffSide": "RIGHT", "path": "integration-tests/elasticsearch-rest-client/src/main/java/io/quarkus/it/elasticsearch/FruitService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjowOTo0NFrOGx7Jnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDozNTo0NVrOGyBKfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAwMjUyNw==", "bodyText": "I don't know if you intend to use the same code for the quickstart, but in case you do... this code is prone to injection. Users could potentially insert some very heavy aggregation in your query, for example. I don't know for sure, but I can imagine building on this vulnerability to trigger a DOS.\nThe proper way to do this would be to use a library such as GSON, Jackson, or whatever you fancy to build a structured JSON object, then serializing that object to a string. But then the code gets ugly, there's no denying that :)", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455002527", "createdAt": "2020-07-15T12:09:44Z", "author": {"login": "yrodiere"}, "path": "integration-tests/elasticsearch-rest-client/src/main/java/io/quarkus/it/elasticsearch/FruitService.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package io.quarkus.it.elasticsearch;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.http.util.EntityUtils;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+@ApplicationScoped\n+public class FruitService {\n+    @Inject\n+    RestClient restClient;\n+\n+    public void index(Fruit fruit) throws IOException {\n+        Request request = new Request(\n+                \"PUT\",\n+                \"/fruits/_doc/\" + fruit.id);\n+        request.setJsonEntity(JsonObject.mapFrom(fruit).toString());\n+        restClient.performRequest(request);\n+    }\n+\n+    public Fruit get(String id) throws IOException {\n+        Request request = new Request(\n+                \"GET\",\n+                \"/fruits/_doc/\" + id);\n+        Response response = restClient.performRequest(request);\n+        String responseBody = EntityUtils.toString(response.getEntity());\n+        JsonObject json = new JsonObject(responseBody);\n+        return json.getJsonObject(\"_source\").mapTo(Fruit.class);\n+    }\n+\n+    public List<Fruit> searchByColor(String color) throws IOException {\n+        return search(\"color\", color);\n+    }\n+\n+    public List<Fruit> searchByName(String name) throws IOException {\n+        return search(\"name\", name);\n+    }\n+\n+    private List<Fruit> search(String term, String match) throws IOException {\n+        Request request = new Request(\n+                \"GET\",\n+                \"/fruits/_search\");\n+        String query = String.format(\"{\\\"query\\\": { \\\"match\\\": { \\\"%s\\\":\\\"%s\\\"}}}\", term, match);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEwMTA1Mg==", "bodyText": "Agreed, that can't happen in the quickstart as people might use it. As you already use Jackson and Vert.x JsonObject, looks like you could use that.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455101052", "createdAt": "2020-07-15T14:35:45Z", "author": {"login": "gsmet"}, "path": "integration-tests/elasticsearch-rest-client/src/main/java/io/quarkus/it/elasticsearch/FruitService.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package io.quarkus.it.elasticsearch;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.http.util.EntityUtils;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+@ApplicationScoped\n+public class FruitService {\n+    @Inject\n+    RestClient restClient;\n+\n+    public void index(Fruit fruit) throws IOException {\n+        Request request = new Request(\n+                \"PUT\",\n+                \"/fruits/_doc/\" + fruit.id);\n+        request.setJsonEntity(JsonObject.mapFrom(fruit).toString());\n+        restClient.performRequest(request);\n+    }\n+\n+    public Fruit get(String id) throws IOException {\n+        Request request = new Request(\n+                \"GET\",\n+                \"/fruits/_doc/\" + id);\n+        Response response = restClient.performRequest(request);\n+        String responseBody = EntityUtils.toString(response.getEntity());\n+        JsonObject json = new JsonObject(responseBody);\n+        return json.getJsonObject(\"_source\").mapTo(Fruit.class);\n+    }\n+\n+    public List<Fruit> searchByColor(String color) throws IOException {\n+        return search(\"color\", color);\n+    }\n+\n+    public List<Fruit> searchByName(String name) throws IOException {\n+        return search(\"name\", name);\n+    }\n+\n+    private List<Fruit> search(String term, String match) throws IOException {\n+        Request request = new Request(\n+                \"GET\",\n+                \"/fruits/_search\");\n+        String query = String.format(\"{\\\"query\\\": { \\\"match\\\": { \\\"%s\\\":\\\"%s\\\"}}}\", term, match);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAwMjUyNw=="}, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODA0MDk1OnYy", "diffSide": "RIGHT", "path": "integration-tests/elasticsearch-rest-client/src/main/resources/application.properties", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjoxMzozOFrOGx7Rww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjoxMzozOFrOGx7Rww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAwNDYxMQ==", "bodyText": "You might want to test that the configuration properties actually do something?", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455004611", "createdAt": "2020-07-15T12:13:38Z", "author": {"login": "yrodiere"}, "path": "integration-tests/elasticsearch-rest-client/src/main/resources/application.properties", "diffHunk": "@@ -0,0 +1,2 @@\n+# Configuration file\n+# key = value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODA2MTQxOnYy", "diffSide": "RIGHT", "path": "extensions/elasticsearch-rest-high-level-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/highlevel/runtime/ElasticsearchRestHighLevelClientProducer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjoxOToyMFrOGx7eCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDo0Njo1NFrOGyBqoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAwNzc1Mw==", "bodyText": "Just a heads-up: this will fail in an application that defines multiple rest clients (to communicate with multiple Elasticsearch clusters from the same application).\nI know the current low-level REST client extension doesn't allow that, but users can still define their own beans (which is typically what I would do if I needed to communicate with multiple Elasticsearch clusters).", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455007753", "createdAt": "2020-07-15T12:19:20Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-high-level-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/highlevel/runtime/ElasticsearchRestHighLevelClientProducer.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package io.quarkus.elasticsearch.restclient.highlevel.runtime;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Collections;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestHighLevelClient;\n+\n+@ApplicationScoped\n+public class ElasticsearchRestHighLevelClientProducer {\n+\n+    @Inject\n+    RestClient restClient;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "213034de857bfefe50c74d7a25b0175c1e5a7280"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAyODQyNA==", "bodyText": "Named Elasticsearch client (to allow connecting to multiple cluster) will be done in a followup PR, I'll open a followup PR to keep track of it.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455028424", "createdAt": "2020-07-15T12:54:38Z", "author": {"login": "loicmathieu"}, "path": "extensions/elasticsearch-rest-high-level-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/highlevel/runtime/ElasticsearchRestHighLevelClientProducer.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package io.quarkus.elasticsearch.restclient.highlevel.runtime;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Collections;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestHighLevelClient;\n+\n+@ApplicationScoped\n+public class ElasticsearchRestHighLevelClientProducer {\n+\n+    @Inject\n+    RestClient restClient;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAwNzc1Mw=="}, "originalCommit": {"oid": "213034de857bfefe50c74d7a25b0175c1e5a7280"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEwOTI4MA==", "bodyText": "I think we should add the @Default qualifier to the produced bean and the injection point here.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455109280", "createdAt": "2020-07-15T14:46:54Z", "author": {"login": "gsmet"}, "path": "extensions/elasticsearch-rest-high-level-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/highlevel/runtime/ElasticsearchRestHighLevelClientProducer.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package io.quarkus.elasticsearch.restclient.highlevel.runtime;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Collections;\n+\n+import javax.annotation.PreDestroy;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.inject.Produces;\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestHighLevelClient;\n+\n+@ApplicationScoped\n+public class ElasticsearchRestHighLevelClientProducer {\n+\n+    @Inject\n+    RestClient restClient;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAwNzc1Mw=="}, "originalCommit": {"oid": "213034de857bfefe50c74d7a25b0175c1e5a7280"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODA4NTUwOnYy", "diffSide": "RIGHT", "path": "integration-tests/elasticsearch-rest-client/src/main/java/io/quarkus/it/elasticsearch/FruitService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjoyNTo1OFrOGx7slA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDozNDo0MVrOGyBHbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxMTQ3Ng==", "bodyText": "Since we're all about reactive these days, maybe you could use performRequestAsync instead? It's not exactly reactive, but it's async and accepts a callback, so...\nThe code would definitely be more complex, though.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455011476", "createdAt": "2020-07-15T12:25:58Z", "author": {"login": "yrodiere"}, "path": "integration-tests/elasticsearch-rest-client/src/main/java/io/quarkus/it/elasticsearch/FruitService.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package io.quarkus.it.elasticsearch;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.http.util.EntityUtils;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+@ApplicationScoped\n+public class FruitService {\n+    @Inject\n+    RestClient restClient;\n+\n+    public void index(Fruit fruit) throws IOException {\n+        Request request = new Request(\n+                \"PUT\",\n+                \"/fruits/_doc/\" + fruit.id);\n+        request.setJsonEntity(JsonObject.mapFrom(fruit).toString());\n+        restClient.performRequest(request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEwMDI3MA==", "bodyText": "Yeah, let's keep it simple in the tests IMHO.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455100270", "createdAt": "2020-07-15T14:34:41Z", "author": {"login": "gsmet"}, "path": "integration-tests/elasticsearch-rest-client/src/main/java/io/quarkus/it/elasticsearch/FruitService.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package io.quarkus.it.elasticsearch;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.http.util.EntityUtils;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+@ApplicationScoped\n+public class FruitService {\n+    @Inject\n+    RestClient restClient;\n+\n+    public void index(Fruit fruit) throws IOException {\n+        Request request = new Request(\n+                \"PUT\",\n+                \"/fruits/_doc/\" + fruit.id);\n+        request.setJsonEntity(JsonObject.mapFrom(fruit).toString());\n+        restClient.performRequest(request);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxMTQ3Ng=="}, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODA5OTYyOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/elasticsearch.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjoyOTo0NVrOGx71Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDoyODo0N1rOGyA1Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxMzY2Ng==", "bodyText": "Not sure \"readiness\" should be mentioned here? Unless Quarkus waits for the health check to pass before bringing the application online, this wording is confusing.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455013666", "createdAt": "2020-07-15T12:29:45Z", "author": {"login": "yrodiere"}, "path": "docs/src/main/asciidoc/elasticsearch.adoc", "diffHunk": "@@ -0,0 +1,414 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Connecting to an Elasticsearch cluster\n+include::./attributes.adoc[]\n+:extension-status: preview\n+\n+Elasticsearch is a well known full text search engine and NoSQL datastore.\n+\n+In this guide, we will see how you can get your REST services to use an Elasticsearch cluster.\n+\n+Quarkus provides two ways of accessing Elasticsearch: via the lower level `RestClient` or via the `RestHighLevelClient` we will call them\n+the low level and the high level clients.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Elasticsearch installed or Docker installed\n+\n+== Architecture\n+\n+The application built in this guide is quite simple: the user can add elements in a list using a form and the list is updated.\n+\n+All the information between the browser and the server is formatted as JSON.\n+\n+The elements are stored in Elasticsearch.\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution for the low level client is located in the `elasticsearch-rest-client-quickstart` {quickstarts-tree-url}/elasticsearch-rest-client-quickstart[directory].\n+\n+The solution for the high level client is located in the `elasticsearch-rest-high-level-client-quickstart` {quickstarts-tree-url}/elasticsearch-rest-high-level-client-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=elasticsearch-quickstart \\\n+    -DclassName=\"org.acme.elasticsearch.FruitResource\" \\\n+    -Dpath=\"/fruits\" \\\n+    -Dextensions=\"resteasy-jackson,elasticsearch-rest-client\"\n+cd elasticsearch-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Jackson, and the Elasticsearch low level client extensions.\n+After this, the `quarkus-elasticsearch-rest-client` extension has been added to your `pom.xml`.\n+\n+If you want to use the high level client instead, replace the `elasticsearch-rest-client` extension by the `elasticsearch-rest-high-level-client` extension.\n+\n+[NOTE]\n+====\n+We use the `resteasy-jackson` extension here and not the JSON-B variant because we will use the Vert.x `JsonObject` helper\n+to serialize/deserialize our objects to/from Elasticsearch and it uses Jackson under the hood.\n+====\n+\n+If you don\u2019t want to generate a new project, add the following dependencies to your pom.xml.\n+\n+For the Elasticsearch low level client, add:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-elasticsearch-rest-client</artifactId>\n+</dependency>\n+----\n+\n+For the Elasticsearch high level client, add:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-elasticsearch-rest-high-level-client</artifactId>\n+</dependency>\n+----\n+\n+== Creating your first JSON REST service\n+\n+In this example, we will create an application to manage a list of fruits.\n+\n+First, let's create the `Fruit` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.elasticsearch;\n+\n+public class Fruit {\n+    public String id;\n+    public String name;\n+    public String color;\n+}\n+----\n+\n+Nothing fancy. One important thing to note is that having a default constructor is required by the JSON serialization layer.\n+\n+Now create a `org.acme.elasticsearch.FruitService` that will be the business layer of our application and store/load the fruits from the Elasticsearch instance.\n+Here we use the low level client, if you want to use the high level client instead follow the instructions in the link:#using-the-high-level-rest-client[Using the High Level REST Client] paragraph instead.\n+\n+[source,java]\n+----\n+package org.acme.elasticsearch;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.http.util.EntityUtils;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+@ApplicationScoped\n+public class FruitService {\n+    @Inject\n+    RestClient restClient; //<1>\n+\n+    public void index(Fruit fruit) throws IOException {\n+        Request request = new Request(\n+                \"PUT\",\n+                \"/fruits/_doc/\" + fruit.id); //<2>\n+        request.setJsonEntity(JsonObject.mapFrom(fruit).toString()); //<3>\n+        restClient.performRequest(request); //<4>\n+    }\n+\n+    public Fruit get(String id) throws IOException {\n+        Request request = new Request(\n+                \"GET\",\n+                \"/fruits/_doc/\" + id);\n+        Response response = restClient.performRequest(request);\n+        String responseBody = EntityUtils.toString(response.getEntity());\n+        JsonObject json = new JsonObject(responseBody); //<5>\n+        return json.getJsonObject(\"_source\").mapTo(Fruit.class);\n+    }\n+\n+    public List<Fruit> searchByColor(String color) throws IOException {\n+        return search(\"color\", color);\n+    }\n+\n+    public List<Fruit> searchByName(String name) throws IOException {\n+        return search(\"name\", name);\n+    }\n+\n+    private List<Fruit> search(String term, String match) throws IOException {\n+        Request request = new Request(\n+                \"GET\",\n+                \"/fruits/_search\");\n+        String query = String.format(\"{\\\"query\\\": { \\\"match\\\": { \\\"%s\\\":\\\"%s\\\"}}}\", term, match);\n+        request.setJsonEntity(query);\n+        Response response = restClient.performRequest(request);\n+        String responseBody = EntityUtils.toString(response.getEntity());\n+\n+        JsonObject json = new JsonObject(responseBody);\n+        JsonArray hits = json.getJsonObject(\"hits\").getJsonArray(\"hits\");\n+        List<Fruit> results = new ArrayList<>(hits.size());\n+        for (int i = 0; i < hits.size(); i++) {\n+            JsonObject hit = hits.getJsonObject(i);\n+            Fruit fruit = hit.getJsonObject(\"_source\").mapTo(Fruit.class);\n+            results.add(fruit);\n+        }\n+        return results;\n+    }\n+}\n+----\n+\n+In this example you can note the following:\n+\n+1. We inject an Elasticsearch low level `RestClient` into our service.\n+2. We create an Elasticsearch request.\n+3. We use Vert.x `JsonObject` to serialize the object before sending it to Elasticsearch, you can use whatever you want to serialize to JSON.\n+4. We send the request (indexing request here) to Elasticsearch.\n+5. In order to deserialize the object from Elasticsearch, we again use Vert.x `JsonObject`.\n+\n+Now, edit the `org.acme.elasticsearch.FruitResource` class as follows:\n+\n+[source,java]\n+----\n+@Path(\"/fruits\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class FruitResource {\n+    @Inject\n+    FruitService fruitService;\n+\n+    @POST\n+    public Response index(Fruit fruit) throws IOException {\n+        if (fruit.id == null) {\n+            fruit.id = UUID.randomUUID().toString();\n+        }\n+        fruitService.index(fruit);\n+        return Response.created(URI.create(\"/fruits/\" + fruit.id)).build();\n+    }\n+\n+    @GET\n+    @Path(\"/{id}\")\n+    public Fruit get(@PathParam(\"id\") String id) throws IOException {\n+        return fruitService.get(id);\n+    }\n+\n+    @GET\n+    @Path(\"/search\")\n+    public List<Fruit> search(@QueryParam(\"name\") String name, @QueryParam(\"color\") String color) throws IOException {\n+        if (name != null) {\n+            return fruitService.searchByName(name);\n+        } else if (color != null) {\n+            return fruitService.searchByColor(color);\n+        } else {\n+            throw new BadRequestException(\"Should provide name or color query parameter\");\n+        }\n+    }\n+\n+}\n+----\n+\n+The implementation is pretty straightforward and you just need to define your endpoints using the JAX-RS annotations and use the `FruitService` to list/add new fruits.\n+\n+== Configuring Elasticsearch\n+The main property to configure is the URL to connect to the Elasticsearch cluster.\n+\n+A sample configuration should look like this:\n+\n+[source,properties]\n+----\n+# configure the Elasticsearch client for a cluster of two nodes\n+quarkus.elasticsearch.hosts = elasticsearch1:9200,elasticsearch2:9200\n+----\n+\n+In this example, we are using a single instance running on localhost:\n+\n+[source,properties]\n+----\n+# configure the Elasticsearch client for a single instance on localhost\n+quarkus.elasticsearch.hosts = localhost:9200\n+----\n+\n+If you need a more advanced configuration, you can find the comprehensive list of supported configuration properties at the end of this guide.\n+\n+\n+== Running an Elasticsearch cluster\n+\n+As by default, the Elasticsearch client is configured to access a local Elasticsearch cluster on port 9200 (the default Elasticsearch port),\n+if you have a local running instance on this port, there is nothing more to do before being able to test it!\n+\n+If you want to use Docker to run an Elasticsearch instance, you can use the following command to launch one:\n+\n+[source,shell,subs=attributes+]\n+----\n+docker run --name elasticsearch  -e \"discovery.type=single-node\" -e \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"\\\n+       --rm -p 9200:9200 docker.elastic.co/elasticsearch/elasticsearch-oss:{elasticsearch-version}\n+----\n+\n+== Creating a frontend\n+\n+Now let's add a simple web page to interact with our `FruitResource`.\n+Quarkus automatically serves static resources located under the `META-INF/resources` directory.\n+In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the content from this {quickstarts-blob-url}/elasticsearch-low-level-client-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] file in it.\n+\n+You can now interact with your REST service:\n+\n+* start Quarkus with `./mvnw quarkus:dev`\n+* open a browser to `http://localhost:8080/fruits.html`\n+* add new fruits to the list via the 'Add fruit' form\n+* search for fruits by name or color via the 'Search Fruit' form\n+\n+== Using the High Level REST Client\n+\n+Quarkus provides support for the Elasticsearch High Level REST Client but keep in mind that it comes with some caveats:\n+\n+- It drags a lot of dependencies - especially Lucene -, which doesn't fit well with Quarkus philosophy. The Elasticsearch team is aware of this issue and it might improve sometime in the future.\n+- It is tied to a certain version of the Elasticsearch server: you cannot use a High Level REST Client version 7 to access a server version 6.\n+\n+Here is a version of the `FruitService` using the high level client instead of the low level one:\n+\n+[source,java]\n+----\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import io.vertx.core.json.JsonObject;\n+\n+@ApplicationScoped\n+public class FruitService {\n+    @Inject\n+    RestHighLevelClient restHighLevelClient; // <1>\n+\n+    public void index(Fruit fruit) throws IOException {\n+        IndexRequest request = new IndexRequest(\"fruits\"); // <2>\n+        request.id(fruit.id);\n+        request.source(JsonObject.mapFrom(fruit).toString(), XContentType.JSON); // <3>\n+        restHighLevelClient.index(request, RequestOptions.DEFAULT); // <4>\n+    }\n+\n+    public Fruit get(String id) throws IOException {\n+        GetRequest getRequest = new GetRequest(\"fruits\", id);\n+        GetResponse getResponse = restHighLevelClient.get(getRequest, RequestOptions.DEFAULT);\n+        if (getResponse.isExists()) {\n+            String sourceAsString = getResponse.getSourceAsString();\n+            JsonObject json = new JsonObject(sourceAsString); // <5>\n+            return json.mapTo(Fruit.class);\n+        }\n+        return null;\n+    }\n+\n+    public List<Fruit> searchByColor(String color) throws IOException {\n+        return search(\"color\", color);\n+    }\n+\n+    public List<Fruit> searchByName(String name) throws IOException {\n+        return search(\"name\", name);\n+    }\n+\n+    private List<Fruit> search(String term, String match) throws IOException {\n+        SearchRequest searchRequest = new SearchRequest(\"fruits\");\n+        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\n+        searchSourceBuilder.query(QueryBuilders.matchQuery(term, match));\n+        searchRequest.source(searchSourceBuilder);\n+\n+        SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);\n+        SearchHits hits = searchResponse.getHits();\n+        List<Fruit> results = new ArrayList<>(hits.getHits().length);\n+        for (SearchHit hit : hits.getHits()) {\n+            String sourceAsString = hit.getSourceAsString();\n+            JsonObject json = new JsonObject(sourceAsString);\n+            results.add(json.mapTo(Fruit.class));\n+        }\n+        return results;\n+    }\n+}\n+----\n+\n+In this example you can note the following:\n+\n+1. We inject an Elasticsearch `RestHighLevelClient` inside the service.\n+2. We create an Elasticsearch index request.\n+3. We use Vert.x `JsonObject` to serialize the object before sending it to Elasticsearch, you can use whatever you want to serialize to JSON.\n+4. We send the request to Elasticsearch.\n+5. In order to deserialize the object from Elasticsearch, we again use Vert.x `JsonObject`.\n+\n+== Hibernate Search Elasticsearch\n+\n+Quarkus supports Hibernate Search with Elasticsearch via the `hibernate-search-elasticsearch` extension.\n+\n+Hibernate Search Elasticsearch allows to synchronize your JPA entities to an Elasticsearch cluster and offers a way to query your Elasticsearch cluster using the Hibernate Search API.\n+\n+If you're interested in it, you can read the link:hibernate-search-elasticsearch[Hibernate Search with Elasticsearch guide].\n+\n+== Cluster Health Check\n+\n+If you are using the `quarkus-smallrye-health` extension, both the extension will automatically add a readiness health check", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fa8866fb9dabe4a656c9d7c4ac78da2ffaf85e6"}, "originalPosition": 390}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA5NTU4Nw==", "bodyText": "That's the appropriate vocabulary. You have readiness and liveness checks.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455095587", "createdAt": "2020-07-15T14:28:47Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/elasticsearch.adoc", "diffHunk": "@@ -0,0 +1,414 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Connecting to an Elasticsearch cluster\n+include::./attributes.adoc[]\n+:extension-status: preview\n+\n+Elasticsearch is a well known full text search engine and NoSQL datastore.\n+\n+In this guide, we will see how you can get your REST services to use an Elasticsearch cluster.\n+\n+Quarkus provides two ways of accessing Elasticsearch: via the lower level `RestClient` or via the `RestHighLevelClient` we will call them\n+the low level and the high level clients.\n+\n+include::./status-include.adoc[]\n+\n+== Prerequisites\n+\n+To complete this guide, you need:\n+\n+* less than 15 minutes\n+* an IDE\n+* JDK 1.8+ installed with `JAVA_HOME` configured appropriately\n+* Apache Maven {maven-version}\n+* Elasticsearch installed or Docker installed\n+\n+== Architecture\n+\n+The application built in this guide is quite simple: the user can add elements in a list using a form and the list is updated.\n+\n+All the information between the browser and the server is formatted as JSON.\n+\n+The elements are stored in Elasticsearch.\n+\n+== Solution\n+\n+We recommend that you follow the instructions in the next sections and create the application step by step.\n+However, you can go right to the completed example.\n+\n+Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].\n+\n+The solution for the low level client is located in the `elasticsearch-rest-client-quickstart` {quickstarts-tree-url}/elasticsearch-rest-client-quickstart[directory].\n+\n+The solution for the high level client is located in the `elasticsearch-rest-high-level-client-quickstart` {quickstarts-tree-url}/elasticsearch-rest-high-level-client-quickstart[directory].\n+\n+== Creating the Maven project\n+\n+First, we need a new project. Create a new project with the following command:\n+\n+[source,shell,subs=attributes+]\n+----\n+mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \\\n+    -DprojectGroupId=org.acme \\\n+    -DprojectArtifactId=elasticsearch-quickstart \\\n+    -DclassName=\"org.acme.elasticsearch.FruitResource\" \\\n+    -Dpath=\"/fruits\" \\\n+    -Dextensions=\"resteasy-jackson,elasticsearch-rest-client\"\n+cd elasticsearch-quickstart\n+----\n+\n+This command generates a Maven structure importing the RESTEasy/JAX-RS, Jackson, and the Elasticsearch low level client extensions.\n+After this, the `quarkus-elasticsearch-rest-client` extension has been added to your `pom.xml`.\n+\n+If you want to use the high level client instead, replace the `elasticsearch-rest-client` extension by the `elasticsearch-rest-high-level-client` extension.\n+\n+[NOTE]\n+====\n+We use the `resteasy-jackson` extension here and not the JSON-B variant because we will use the Vert.x `JsonObject` helper\n+to serialize/deserialize our objects to/from Elasticsearch and it uses Jackson under the hood.\n+====\n+\n+If you don\u2019t want to generate a new project, add the following dependencies to your pom.xml.\n+\n+For the Elasticsearch low level client, add:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-elasticsearch-rest-client</artifactId>\n+</dependency>\n+----\n+\n+For the Elasticsearch high level client, add:\n+\n+[source,xml]\n+----\n+<dependency>\n+    <groupId>io.quarkus</groupId>\n+    <artifactId>quarkus-elasticsearch-rest-high-level-client</artifactId>\n+</dependency>\n+----\n+\n+== Creating your first JSON REST service\n+\n+In this example, we will create an application to manage a list of fruits.\n+\n+First, let's create the `Fruit` bean as follows:\n+\n+[source,java]\n+----\n+package org.acme.elasticsearch;\n+\n+public class Fruit {\n+    public String id;\n+    public String name;\n+    public String color;\n+}\n+----\n+\n+Nothing fancy. One important thing to note is that having a default constructor is required by the JSON serialization layer.\n+\n+Now create a `org.acme.elasticsearch.FruitService` that will be the business layer of our application and store/load the fruits from the Elasticsearch instance.\n+Here we use the low level client, if you want to use the high level client instead follow the instructions in the link:#using-the-high-level-rest-client[Using the High Level REST Client] paragraph instead.\n+\n+[source,java]\n+----\n+package org.acme.elasticsearch;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.apache.http.util.EntityUtils;\n+import org.elasticsearch.client.Request;\n+import org.elasticsearch.client.Response;\n+import org.elasticsearch.client.RestClient;\n+\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+@ApplicationScoped\n+public class FruitService {\n+    @Inject\n+    RestClient restClient; //<1>\n+\n+    public void index(Fruit fruit) throws IOException {\n+        Request request = new Request(\n+                \"PUT\",\n+                \"/fruits/_doc/\" + fruit.id); //<2>\n+        request.setJsonEntity(JsonObject.mapFrom(fruit).toString()); //<3>\n+        restClient.performRequest(request); //<4>\n+    }\n+\n+    public Fruit get(String id) throws IOException {\n+        Request request = new Request(\n+                \"GET\",\n+                \"/fruits/_doc/\" + id);\n+        Response response = restClient.performRequest(request);\n+        String responseBody = EntityUtils.toString(response.getEntity());\n+        JsonObject json = new JsonObject(responseBody); //<5>\n+        return json.getJsonObject(\"_source\").mapTo(Fruit.class);\n+    }\n+\n+    public List<Fruit> searchByColor(String color) throws IOException {\n+        return search(\"color\", color);\n+    }\n+\n+    public List<Fruit> searchByName(String name) throws IOException {\n+        return search(\"name\", name);\n+    }\n+\n+    private List<Fruit> search(String term, String match) throws IOException {\n+        Request request = new Request(\n+                \"GET\",\n+                \"/fruits/_search\");\n+        String query = String.format(\"{\\\"query\\\": { \\\"match\\\": { \\\"%s\\\":\\\"%s\\\"}}}\", term, match);\n+        request.setJsonEntity(query);\n+        Response response = restClient.performRequest(request);\n+        String responseBody = EntityUtils.toString(response.getEntity());\n+\n+        JsonObject json = new JsonObject(responseBody);\n+        JsonArray hits = json.getJsonObject(\"hits\").getJsonArray(\"hits\");\n+        List<Fruit> results = new ArrayList<>(hits.size());\n+        for (int i = 0; i < hits.size(); i++) {\n+            JsonObject hit = hits.getJsonObject(i);\n+            Fruit fruit = hit.getJsonObject(\"_source\").mapTo(Fruit.class);\n+            results.add(fruit);\n+        }\n+        return results;\n+    }\n+}\n+----\n+\n+In this example you can note the following:\n+\n+1. We inject an Elasticsearch low level `RestClient` into our service.\n+2. We create an Elasticsearch request.\n+3. We use Vert.x `JsonObject` to serialize the object before sending it to Elasticsearch, you can use whatever you want to serialize to JSON.\n+4. We send the request (indexing request here) to Elasticsearch.\n+5. In order to deserialize the object from Elasticsearch, we again use Vert.x `JsonObject`.\n+\n+Now, edit the `org.acme.elasticsearch.FruitResource` class as follows:\n+\n+[source,java]\n+----\n+@Path(\"/fruits\")\n+@Produces(MediaType.APPLICATION_JSON)\n+@Consumes(MediaType.APPLICATION_JSON)\n+public class FruitResource {\n+    @Inject\n+    FruitService fruitService;\n+\n+    @POST\n+    public Response index(Fruit fruit) throws IOException {\n+        if (fruit.id == null) {\n+            fruit.id = UUID.randomUUID().toString();\n+        }\n+        fruitService.index(fruit);\n+        return Response.created(URI.create(\"/fruits/\" + fruit.id)).build();\n+    }\n+\n+    @GET\n+    @Path(\"/{id}\")\n+    public Fruit get(@PathParam(\"id\") String id) throws IOException {\n+        return fruitService.get(id);\n+    }\n+\n+    @GET\n+    @Path(\"/search\")\n+    public List<Fruit> search(@QueryParam(\"name\") String name, @QueryParam(\"color\") String color) throws IOException {\n+        if (name != null) {\n+            return fruitService.searchByName(name);\n+        } else if (color != null) {\n+            return fruitService.searchByColor(color);\n+        } else {\n+            throw new BadRequestException(\"Should provide name or color query parameter\");\n+        }\n+    }\n+\n+}\n+----\n+\n+The implementation is pretty straightforward and you just need to define your endpoints using the JAX-RS annotations and use the `FruitService` to list/add new fruits.\n+\n+== Configuring Elasticsearch\n+The main property to configure is the URL to connect to the Elasticsearch cluster.\n+\n+A sample configuration should look like this:\n+\n+[source,properties]\n+----\n+# configure the Elasticsearch client for a cluster of two nodes\n+quarkus.elasticsearch.hosts = elasticsearch1:9200,elasticsearch2:9200\n+----\n+\n+In this example, we are using a single instance running on localhost:\n+\n+[source,properties]\n+----\n+# configure the Elasticsearch client for a single instance on localhost\n+quarkus.elasticsearch.hosts = localhost:9200\n+----\n+\n+If you need a more advanced configuration, you can find the comprehensive list of supported configuration properties at the end of this guide.\n+\n+\n+== Running an Elasticsearch cluster\n+\n+As by default, the Elasticsearch client is configured to access a local Elasticsearch cluster on port 9200 (the default Elasticsearch port),\n+if you have a local running instance on this port, there is nothing more to do before being able to test it!\n+\n+If you want to use Docker to run an Elasticsearch instance, you can use the following command to launch one:\n+\n+[source,shell,subs=attributes+]\n+----\n+docker run --name elasticsearch  -e \"discovery.type=single-node\" -e \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"\\\n+       --rm -p 9200:9200 docker.elastic.co/elasticsearch/elasticsearch-oss:{elasticsearch-version}\n+----\n+\n+== Creating a frontend\n+\n+Now let's add a simple web page to interact with our `FruitResource`.\n+Quarkus automatically serves static resources located under the `META-INF/resources` directory.\n+In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the content from this {quickstarts-blob-url}/elasticsearch-low-level-client-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] file in it.\n+\n+You can now interact with your REST service:\n+\n+* start Quarkus with `./mvnw quarkus:dev`\n+* open a browser to `http://localhost:8080/fruits.html`\n+* add new fruits to the list via the 'Add fruit' form\n+* search for fruits by name or color via the 'Search Fruit' form\n+\n+== Using the High Level REST Client\n+\n+Quarkus provides support for the Elasticsearch High Level REST Client but keep in mind that it comes with some caveats:\n+\n+- It drags a lot of dependencies - especially Lucene -, which doesn't fit well with Quarkus philosophy. The Elasticsearch team is aware of this issue and it might improve sometime in the future.\n+- It is tied to a certain version of the Elasticsearch server: you cannot use a High Level REST Client version 7 to access a server version 6.\n+\n+Here is a version of the `FruitService` using the high level client instead of the low level one:\n+\n+[source,java]\n+----\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+\n+import io.vertx.core.json.JsonObject;\n+\n+@ApplicationScoped\n+public class FruitService {\n+    @Inject\n+    RestHighLevelClient restHighLevelClient; // <1>\n+\n+    public void index(Fruit fruit) throws IOException {\n+        IndexRequest request = new IndexRequest(\"fruits\"); // <2>\n+        request.id(fruit.id);\n+        request.source(JsonObject.mapFrom(fruit).toString(), XContentType.JSON); // <3>\n+        restHighLevelClient.index(request, RequestOptions.DEFAULT); // <4>\n+    }\n+\n+    public Fruit get(String id) throws IOException {\n+        GetRequest getRequest = new GetRequest(\"fruits\", id);\n+        GetResponse getResponse = restHighLevelClient.get(getRequest, RequestOptions.DEFAULT);\n+        if (getResponse.isExists()) {\n+            String sourceAsString = getResponse.getSourceAsString();\n+            JsonObject json = new JsonObject(sourceAsString); // <5>\n+            return json.mapTo(Fruit.class);\n+        }\n+        return null;\n+    }\n+\n+    public List<Fruit> searchByColor(String color) throws IOException {\n+        return search(\"color\", color);\n+    }\n+\n+    public List<Fruit> searchByName(String name) throws IOException {\n+        return search(\"name\", name);\n+    }\n+\n+    private List<Fruit> search(String term, String match) throws IOException {\n+        SearchRequest searchRequest = new SearchRequest(\"fruits\");\n+        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\n+        searchSourceBuilder.query(QueryBuilders.matchQuery(term, match));\n+        searchRequest.source(searchSourceBuilder);\n+\n+        SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);\n+        SearchHits hits = searchResponse.getHits();\n+        List<Fruit> results = new ArrayList<>(hits.getHits().length);\n+        for (SearchHit hit : hits.getHits()) {\n+            String sourceAsString = hit.getSourceAsString();\n+            JsonObject json = new JsonObject(sourceAsString);\n+            results.add(json.mapTo(Fruit.class));\n+        }\n+        return results;\n+    }\n+}\n+----\n+\n+In this example you can note the following:\n+\n+1. We inject an Elasticsearch `RestHighLevelClient` inside the service.\n+2. We create an Elasticsearch index request.\n+3. We use Vert.x `JsonObject` to serialize the object before sending it to Elasticsearch, you can use whatever you want to serialize to JSON.\n+4. We send the request to Elasticsearch.\n+5. In order to deserialize the object from Elasticsearch, we again use Vert.x `JsonObject`.\n+\n+== Hibernate Search Elasticsearch\n+\n+Quarkus supports Hibernate Search with Elasticsearch via the `hibernate-search-elasticsearch` extension.\n+\n+Hibernate Search Elasticsearch allows to synchronize your JPA entities to an Elasticsearch cluster and offers a way to query your Elasticsearch cluster using the Hibernate Search API.\n+\n+If you're interested in it, you can read the link:hibernate-search-elasticsearch[Hibernate Search with Elasticsearch guide].\n+\n+== Cluster Health Check\n+\n+If you are using the `quarkus-smallrye-health` extension, both the extension will automatically add a readiness health check", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxMzY2Ng=="}, "originalCommit": {"oid": "1fa8866fb9dabe4a656c9d7c4ac78da2ffaf85e6"}, "originalPosition": 390}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODExMDE1OnYy", "diffSide": "RIGHT", "path": "core/deployment/src/main/java/io/quarkus/deployment/Feature.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjozMjozN1rOGx77nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDo0MjowNlrOGyBcsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxNTMyNQ==", "bodyText": "I thought enumeration of the features inside th Feature class was something we want to avoid for now.\nI remember some discussion about this last time I created an extension ...", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455015325", "createdAt": "2020-07-15T12:32:37Z", "author": {"login": "loicmathieu"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/Feature.java", "diffHunk": "@@ -23,7 +23,9 @@\n     CDI,\n     CONFIG_YAML,\n     CONSUL_CONFIG,\n+    ELASTICSEARCH_REST_CLIENT_COMMON,\n     ELASTICSEARCH_REST_CLIENT,\n+    ELASTICSEARCH_REST_HIGH_LEVEL_CLIENT,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7384a1267e6bcc24c35ef167363d57e347f1b39"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA5NTA2OA==", "bodyText": "Yeah, well, no :).", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455095068", "createdAt": "2020-07-15T14:28:06Z", "author": {"login": "gsmet"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/Feature.java", "diffHunk": "@@ -23,7 +23,9 @@\n     CDI,\n     CONFIG_YAML,\n     CONSUL_CONFIG,\n+    ELASTICSEARCH_REST_CLIENT_COMMON,\n     ELASTICSEARCH_REST_CLIENT,\n+    ELASTICSEARCH_REST_HIGH_LEVEL_CLIENT,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxNTMyNQ=="}, "originalCommit": {"oid": "b7384a1267e6bcc24c35ef167363d57e347f1b39"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEwNTcxMg==", "bodyText": "I'm pretty sure Alexey or David didn't agree with you but OK :)", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455105712", "createdAt": "2020-07-15T14:42:06Z", "author": {"login": "loicmathieu"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/Feature.java", "diffHunk": "@@ -23,7 +23,9 @@\n     CDI,\n     CONFIG_YAML,\n     CONSUL_CONFIG,\n+    ELASTICSEARCH_REST_CLIENT_COMMON,\n     ELASTICSEARCH_REST_CLIENT,\n+    ELASTICSEARCH_REST_HIGH_LEVEL_CLIENT,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxNTMyNQ=="}, "originalCommit": {"oid": "b7384a1267e6bcc24c35ef167363d57e347f1b39"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODEyMTcxOnYy", "diffSide": "RIGHT", "path": "extensions/elasticsearch-rest-client/runtime/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjozNTo0MlrOGx8Ciw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDoyOToyMVrOGyA3Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxNzA5OQ==", "bodyText": "Shouldn't it be the REST client ?", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455017099", "createdAt": "2020-07-15T12:35:42Z", "author": {"login": "loicmathieu"}, "path": "extensions/elasticsearch-rest-client/runtime/pom.xml", "diffHunk": "@@ -2,49 +2,35 @@\n <project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n     <parent>\n-        <artifactId>quarkus-elasticsearch-rest-client-parent</artifactId>\n         <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-elasticsearch-rest-client-parent</artifactId>\n         <version>999-SNAPSHOT</version>\n-        <relativePath>../</relativePath>\n+        <relativePath>../pom.xml</relativePath>\n     </parent>\n-    <modelVersion>4.0.0</modelVersion>\n \n     <artifactId>quarkus-elasticsearch-rest-client</artifactId>\n     <name>Quarkus - Elasticsearch REST client - Runtime</name>\n-    <description>Elasticsearch REST client</description>\n+    <description>Connect to an Elasticsearch cluster using the low level client</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7384a1267e6bcc24c35ef167363d57e347f1b39"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA5NjA3OQ==", "bodyText": "Yeah, it could. I will change that.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455096079", "createdAt": "2020-07-15T14:29:21Z", "author": {"login": "gsmet"}, "path": "extensions/elasticsearch-rest-client/runtime/pom.xml", "diffHunk": "@@ -2,49 +2,35 @@\n <project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n     <parent>\n-        <artifactId>quarkus-elasticsearch-rest-client-parent</artifactId>\n         <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-elasticsearch-rest-client-parent</artifactId>\n         <version>999-SNAPSHOT</version>\n-        <relativePath>../</relativePath>\n+        <relativePath>../pom.xml</relativePath>\n     </parent>\n-    <modelVersion>4.0.0</modelVersion>\n \n     <artifactId>quarkus-elasticsearch-rest-client</artifactId>\n     <name>Quarkus - Elasticsearch REST client - Runtime</name>\n-    <description>Elasticsearch REST client</description>\n+    <description>Connect to an Elasticsearch cluster using the low level client</description>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxNzA5OQ=="}, "originalCommit": {"oid": "b7384a1267e6bcc24c35ef167363d57e347f1b39"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODEzNDg4OnYy", "diffSide": "RIGHT", "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/ElasticsearchConfig.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjozOToyOFrOGx8Krg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNDo0ODoxNlrOGyBurw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxOTE4Mg==", "bodyText": "Connections settings, which I think are quite important, are missing:\n\nmax_connections: the maximum number of connections to the cluster.\nmax_connections_per_route: the maximum number of connections to each node in the cluster.\n\nSee https://github.com/hibernate/hibernate-search/blob/9da99d7de8f346aa0ec81ae2ce0a1fa2c1657b2a/backend/elasticsearch/src/main/java/org/hibernate/search/backend/elasticsearch/client/impl/ElasticsearchClientFactoryImpl.java#L201-L200", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455019182", "createdAt": "2020-07-15T12:39:28Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/ElasticsearchConfig.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigPhase;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot(phase = ConfigPhase.RUN_TIME)\n+public class ElasticsearchConfig {\n+\n+    /**\n+     * The list of hosts of the Elasticsearch servers.\n+     */\n+    @ConfigItem(defaultValue = \"localhost:9200\")\n+    public List<String> hosts;\n+\n+    /**\n+     * The protocol to use when contacting Elasticsearch servers.\n+     * Set to \"https\" to enable SSL/TLS.\n+     */\n+    @ConfigItem(defaultValue = \"http\")\n+    public String protocol;\n+\n+    /**\n+     * The username used for authentication.\n+     */\n+    @ConfigItem\n+    public Optional<String> username;\n+\n+    /**\n+     * The password used for authentication.\n+     */\n+    @ConfigItem\n+    public Optional<String> password;\n+\n+    /**\n+     * The connection timeout.\n+     */\n+    @ConfigItem(defaultValue = \"1S\")\n+    public Duration connectionTimeout;\n+\n+    /**\n+     * The socket timeout.\n+     */\n+    @ConfigItem(defaultValue = \"30S\")\n+    public Duration socketTimeout;\n+\n+    /**\n+     * The number of IO thread.\n+     * By default, this is the number of locally detected processors.\n+     *\n+     * @see <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/_number_of_threads.html\">number of\n+     *      threads</a>\n+     */\n+    @ConfigItem\n+    public Optional<Integer> ioThreadCounts;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEwMjczNQ==", "bodyText": "The documentation now only references this one. See https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/_number_of_threads.html", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455102735", "createdAt": "2020-07-15T14:37:58Z", "author": {"login": "loicmathieu"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/ElasticsearchConfig.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigPhase;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot(phase = ConfigPhase.RUN_TIME)\n+public class ElasticsearchConfig {\n+\n+    /**\n+     * The list of hosts of the Elasticsearch servers.\n+     */\n+    @ConfigItem(defaultValue = \"localhost:9200\")\n+    public List<String> hosts;\n+\n+    /**\n+     * The protocol to use when contacting Elasticsearch servers.\n+     * Set to \"https\" to enable SSL/TLS.\n+     */\n+    @ConfigItem(defaultValue = \"http\")\n+    public String protocol;\n+\n+    /**\n+     * The username used for authentication.\n+     */\n+    @ConfigItem\n+    public Optional<String> username;\n+\n+    /**\n+     * The password used for authentication.\n+     */\n+    @ConfigItem\n+    public Optional<String> password;\n+\n+    /**\n+     * The connection timeout.\n+     */\n+    @ConfigItem(defaultValue = \"1S\")\n+    public Duration connectionTimeout;\n+\n+    /**\n+     * The socket timeout.\n+     */\n+    @ConfigItem(defaultValue = \"30S\")\n+    public Duration socketTimeout;\n+\n+    /**\n+     * The number of IO thread.\n+     * By default, this is the number of locally detected processors.\n+     *\n+     * @see <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/_number_of_threads.html\">number of\n+     *      threads</a>\n+     */\n+    @ConfigItem\n+    public Optional<Integer> ioThreadCounts;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxOTE4Mg=="}, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEwNjAyMA==", "bodyText": "I think it's because of https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/_others.html . They basically send you to the Apache HTTP client doc.\nI would trust Yoann on that one :).", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455106020", "createdAt": "2020-07-15T14:42:30Z", "author": {"login": "gsmet"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/ElasticsearchConfig.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigPhase;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot(phase = ConfigPhase.RUN_TIME)\n+public class ElasticsearchConfig {\n+\n+    /**\n+     * The list of hosts of the Elasticsearch servers.\n+     */\n+    @ConfigItem(defaultValue = \"localhost:9200\")\n+    public List<String> hosts;\n+\n+    /**\n+     * The protocol to use when contacting Elasticsearch servers.\n+     * Set to \"https\" to enable SSL/TLS.\n+     */\n+    @ConfigItem(defaultValue = \"http\")\n+    public String protocol;\n+\n+    /**\n+     * The username used for authentication.\n+     */\n+    @ConfigItem\n+    public Optional<String> username;\n+\n+    /**\n+     * The password used for authentication.\n+     */\n+    @ConfigItem\n+    public Optional<String> password;\n+\n+    /**\n+     * The connection timeout.\n+     */\n+    @ConfigItem(defaultValue = \"1S\")\n+    public Duration connectionTimeout;\n+\n+    /**\n+     * The socket timeout.\n+     */\n+    @ConfigItem(defaultValue = \"30S\")\n+    public Duration socketTimeout;\n+\n+    /**\n+     * The number of IO thread.\n+     * By default, this is the number of locally detected processors.\n+     *\n+     * @see <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/_number_of_threads.html\">number of\n+     *      threads</a>\n+     */\n+    @ConfigItem\n+    public Optional<Integer> ioThreadCounts;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxOTE4Mg=="}, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTEwNjI3MQ==", "bodyText": "I'm not sure I'm following. The settings I mentioned are settings of the underlying HTTP client, not of the Elasticsearch Rest client. So indeed, they don't have dedicated entries in the Elasticsearch Rest client documentation. They are still relevant, though. See https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/_others.html", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455106271", "createdAt": "2020-07-15T14:42:50Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/ElasticsearchConfig.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigPhase;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot(phase = ConfigPhase.RUN_TIME)\n+public class ElasticsearchConfig {\n+\n+    /**\n+     * The list of hosts of the Elasticsearch servers.\n+     */\n+    @ConfigItem(defaultValue = \"localhost:9200\")\n+    public List<String> hosts;\n+\n+    /**\n+     * The protocol to use when contacting Elasticsearch servers.\n+     * Set to \"https\" to enable SSL/TLS.\n+     */\n+    @ConfigItem(defaultValue = \"http\")\n+    public String protocol;\n+\n+    /**\n+     * The username used for authentication.\n+     */\n+    @ConfigItem\n+    public Optional<String> username;\n+\n+    /**\n+     * The password used for authentication.\n+     */\n+    @ConfigItem\n+    public Optional<String> password;\n+\n+    /**\n+     * The connection timeout.\n+     */\n+    @ConfigItem(defaultValue = \"1S\")\n+    public Duration connectionTimeout;\n+\n+    /**\n+     * The socket timeout.\n+     */\n+    @ConfigItem(defaultValue = \"30S\")\n+    public Duration socketTimeout;\n+\n+    /**\n+     * The number of IO thread.\n+     * By default, this is the number of locally detected processors.\n+     *\n+     * @see <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/_number_of_threads.html\">number of\n+     *      threads</a>\n+     */\n+    @ConfigItem\n+    public Optional<Integer> ioThreadCounts;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxOTE4Mg=="}, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTExMDMxOQ==", "bodyText": "Yeah, I understand it now, it's different things ;)", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455110319", "createdAt": "2020-07-15T14:48:16Z", "author": {"login": "loicmathieu"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/ElasticsearchConfig.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigPhase;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+\n+@ConfigRoot(phase = ConfigPhase.RUN_TIME)\n+public class ElasticsearchConfig {\n+\n+    /**\n+     * The list of hosts of the Elasticsearch servers.\n+     */\n+    @ConfigItem(defaultValue = \"localhost:9200\")\n+    public List<String> hosts;\n+\n+    /**\n+     * The protocol to use when contacting Elasticsearch servers.\n+     * Set to \"https\" to enable SSL/TLS.\n+     */\n+    @ConfigItem(defaultValue = \"http\")\n+    public String protocol;\n+\n+    /**\n+     * The username used for authentication.\n+     */\n+    @ConfigItem\n+    public Optional<String> username;\n+\n+    /**\n+     * The password used for authentication.\n+     */\n+    @ConfigItem\n+    public Optional<String> password;\n+\n+    /**\n+     * The connection timeout.\n+     */\n+    @ConfigItem(defaultValue = \"1S\")\n+    public Duration connectionTimeout;\n+\n+    /**\n+     * The socket timeout.\n+     */\n+    @ConfigItem(defaultValue = \"30S\")\n+    public Duration socketTimeout;\n+\n+    /**\n+     * The number of IO thread.\n+     * By default, this is the number of locally detected processors.\n+     *\n+     * @see <a href=\"https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/_number_of_threads.html\">number of\n+     *      threads</a>\n+     */\n+    @ConfigItem\n+    public Optional<Integer> ioThreadCounts;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxOTE4Mg=="}, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODE0MTUyOnYy", "diffSide": "RIGHT", "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjo0MToxOFrOGx8O1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNzo1NTo0MlrOGyexkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAyMDI0Nw==", "bodyText": "You may want to customize the thread factory to give a better name to client threads (something that mentions Elasticsearch).\nSee https://github.com/hibernate/hibernate-search/blob/9da99d7de8f346aa0ec81ae2ce0a1fa2c1657b2a/backend/elasticsearch/src/main/java/org/hibernate/search/backend/elasticsearch/client/impl/ElasticsearchClientFactoryImpl.java#L203", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455020247", "createdAt": "2020-07-15T12:41:18Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;\n+import org.apache.http.impl.nio.reactor.IOReactorConfig;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.sniff.Sniffer;\n+\n+public final class RestClientBuilderHelper {\n+\n+    private RestClientBuilderHelper() {\n+        // avoid instantiation\n+    }\n+\n+    static RestClientBuilder createRestClientBuilder(ElasticsearchConfig config) {\n+        List<HttpHost> hosts = config.hosts.stream().map(s -> new HttpHost(s.substring(0, s.indexOf(\":\")),\n+                Integer.parseInt(s.substring(s.indexOf(\":\") + 1)), config.protocol)).collect(Collectors.toList());\n+        RestClientBuilder builder = RestClient.builder(hosts.toArray(new HttpHost[0]));\n+\n+        builder.setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() {\n+            @Override\n+            public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {\n+                return requestConfigBuilder\n+                        .setConnectTimeout((int) config.connectionTimeout.toMillis())\n+                        .setSocketTimeout((int) config.socketTimeout.toMillis());\n+            }\n+        });\n+\n+        builder.setHttpClientConfigCallback(new RestClientBuilder.HttpClientConfigCallback() {\n+            @Override\n+            public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {\n+                if (config.username.isPresent()) {\n+                    CredentialsProvider credentialsProvider = new BasicCredentialsProvider();\n+                    credentialsProvider.setCredentials(AuthScope.ANY,\n+                            new UsernamePasswordCredentials(config.username.get(), config.password.get()));\n+                    httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider);\n+                }\n+\n+                if (config.ioThreadCounts.isPresent()) {\n+                    IOReactorConfig ioReactorConfig = IOReactorConfig.custom()\n+                            .setIoThreadCount(config.ioThreadCounts.get())\n+                            .build();\n+                    httpClientBuilder.setDefaultIOReactorConfig(ioReactorConfig);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU2ODQ1MQ==", "bodyText": "We don't have a ThreadProvider available yet inside the extension so I would not implement this now.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455568451", "createdAt": "2020-07-16T07:31:49Z", "author": {"login": "loicmathieu"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;\n+import org.apache.http.impl.nio.reactor.IOReactorConfig;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.sniff.Sniffer;\n+\n+public final class RestClientBuilderHelper {\n+\n+    private RestClientBuilderHelper() {\n+        // avoid instantiation\n+    }\n+\n+    static RestClientBuilder createRestClientBuilder(ElasticsearchConfig config) {\n+        List<HttpHost> hosts = config.hosts.stream().map(s -> new HttpHost(s.substring(0, s.indexOf(\":\")),\n+                Integer.parseInt(s.substring(s.indexOf(\":\") + 1)), config.protocol)).collect(Collectors.toList());\n+        RestClientBuilder builder = RestClient.builder(hosts.toArray(new HttpHost[0]));\n+\n+        builder.setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() {\n+            @Override\n+            public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {\n+                return requestConfigBuilder\n+                        .setConnectTimeout((int) config.connectionTimeout.toMillis())\n+                        .setSocketTimeout((int) config.socketTimeout.toMillis());\n+            }\n+        });\n+\n+        builder.setHttpClientConfigCallback(new RestClientBuilder.HttpClientConfigCallback() {\n+            @Override\n+            public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {\n+                if (config.username.isPresent()) {\n+                    CredentialsProvider credentialsProvider = new BasicCredentialsProvider();\n+                    credentialsProvider.setCredentials(AuthScope.ANY,\n+                            new UsernamePasswordCredentials(config.username.get(), config.password.get()));\n+                    httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider);\n+                }\n+\n+                if (config.ioThreadCounts.isPresent()) {\n+                    IOReactorConfig ioReactorConfig = IOReactorConfig.custom()\n+                            .setIoThreadCount(config.ioThreadCounts.get())\n+                            .build();\n+                    httpClientBuilder.setDefaultIOReactorConfig(ioReactorConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAyMDI0Nw=="}, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU4NjE5NA==", "bodyText": "Right, that's something specific to Hibernate Search. You can implement a much simpler ThreadFactory that simply creates threads with an appropriate name. For example like this: https://github.com/hibernate/hibernate-search/blob/9da99d7de8f346aa0ec81ae2ce0a1fa2c1657b2a/legacy/engine/src/main/java/org/hibernate/search/util/impl/SearchThreadFactory.java\nThat is, if you consider thread names are important.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455586194", "createdAt": "2020-07-16T07:55:42Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;\n+import org.apache.http.impl.nio.reactor.IOReactorConfig;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.sniff.Sniffer;\n+\n+public final class RestClientBuilderHelper {\n+\n+    private RestClientBuilderHelper() {\n+        // avoid instantiation\n+    }\n+\n+    static RestClientBuilder createRestClientBuilder(ElasticsearchConfig config) {\n+        List<HttpHost> hosts = config.hosts.stream().map(s -> new HttpHost(s.substring(0, s.indexOf(\":\")),\n+                Integer.parseInt(s.substring(s.indexOf(\":\") + 1)), config.protocol)).collect(Collectors.toList());\n+        RestClientBuilder builder = RestClient.builder(hosts.toArray(new HttpHost[0]));\n+\n+        builder.setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() {\n+            @Override\n+            public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {\n+                return requestConfigBuilder\n+                        .setConnectTimeout((int) config.connectionTimeout.toMillis())\n+                        .setSocketTimeout((int) config.socketTimeout.toMillis());\n+            }\n+        });\n+\n+        builder.setHttpClientConfigCallback(new RestClientBuilder.HttpClientConfigCallback() {\n+            @Override\n+            public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {\n+                if (config.username.isPresent()) {\n+                    CredentialsProvider credentialsProvider = new BasicCredentialsProvider();\n+                    credentialsProvider.setCredentials(AuthScope.ANY,\n+                            new UsernamePasswordCredentials(config.username.get(), config.password.get()));\n+                    httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider);\n+                }\n+\n+                if (config.ioThreadCounts.isPresent()) {\n+                    IOReactorConfig ioReactorConfig = IOReactorConfig.custom()\n+                            .setIoThreadCount(config.ioThreadCounts.get())\n+                            .build();\n+                    httpClientBuilder.setDefaultIOReactorConfig(ioReactorConfig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAyMDI0Nw=="}, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODE0NzA5OnYy", "diffSide": "RIGHT", "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjo0Mjo0OFrOGx8STg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjo0Mjo0OFrOGx8STg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAyMTEzNA==", "bodyText": "You don't seem to be using the \"protocol\" setting. You should use it here to disable SSL if it's not necessary, because SSL causes significant slowdowns on startup.\nSee https://github.com/hibernate/hibernate-search/blob/9da99d7de8f346aa0ec81ae2ce0a1fa2c1657b2a/backend/elasticsearch/src/main/java/org/hibernate/search/backend/elasticsearch/client/impl/ElasticsearchClientFactoryImpl.java#L204-L208", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455021134", "createdAt": "2020-07-15T12:42:48Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;\n+import org.apache.http.impl.nio.reactor.IOReactorConfig;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.sniff.Sniffer;\n+\n+public final class RestClientBuilderHelper {\n+\n+    private RestClientBuilderHelper() {\n+        // avoid instantiation\n+    }\n+\n+    static RestClientBuilder createRestClientBuilder(ElasticsearchConfig config) {\n+        List<HttpHost> hosts = config.hosts.stream().map(s -> new HttpHost(s.substring(0, s.indexOf(\":\")),\n+                Integer.parseInt(s.substring(s.indexOf(\":\") + 1)), config.protocol)).collect(Collectors.toList());\n+        RestClientBuilder builder = RestClient.builder(hosts.toArray(new HttpHost[0]));\n+\n+        builder.setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() {\n+            @Override\n+            public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {\n+                return requestConfigBuilder\n+                        .setConnectTimeout((int) config.connectionTimeout.toMillis())\n+                        .setSocketTimeout((int) config.socketTimeout.toMillis());\n+            }\n+        });\n+\n+        builder.setHttpClientConfigCallback(new RestClientBuilder.HttpClientConfigCallback() {\n+            @Override\n+            public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {\n+                if (config.username.isPresent()) {\n+                    CredentialsProvider credentialsProvider = new BasicCredentialsProvider();\n+                    credentialsProvider.setCredentials(AuthScope.ANY,\n+                            new UsernamePasswordCredentials(config.username.get(), config.password.get()));\n+                    httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider);\n+                }\n+\n+                if (config.ioThreadCounts.isPresent()) {\n+                    IOReactorConfig ioReactorConfig = IOReactorConfig.custom()\n+                            .setIoThreadCount(config.ioThreadCounts.get())\n+                            .build();\n+                    httpClientBuilder.setDefaultIOReactorConfig(ioReactorConfig);\n+                }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODE1MTcxOnYy", "diffSide": "RIGHT", "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjo0Mzo1OFrOGx8VJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjo0Mzo1OFrOGx8VJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAyMTg2Mw==", "bodyText": "You need to take the protocol into account here, too.\nSee https://github.com/hibernate/hibernate-search/blob/9da99d7de8f346aa0ec81ae2ce0a1fa2c1657b2a/backend/elasticsearch/src/main/java/org/hibernate/search/backend/elasticsearch/client/impl/ElasticsearchClientFactoryImpl.java#L182-L190", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455021863", "createdAt": "2020-07-15T12:43:58Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;\n+import org.apache.http.impl.nio.reactor.IOReactorConfig;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.sniff.Sniffer;\n+\n+public final class RestClientBuilderHelper {\n+\n+    private RestClientBuilderHelper() {\n+        // avoid instantiation\n+    }\n+\n+    static RestClientBuilder createRestClientBuilder(ElasticsearchConfig config) {\n+        List<HttpHost> hosts = config.hosts.stream().map(s -> new HttpHost(s.substring(0, s.indexOf(\":\")),\n+                Integer.parseInt(s.substring(s.indexOf(\":\") + 1)), config.protocol)).collect(Collectors.toList());\n+        RestClientBuilder builder = RestClient.builder(hosts.toArray(new HttpHost[0]));\n+\n+        builder.setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() {\n+            @Override\n+            public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {\n+                return requestConfigBuilder\n+                        .setConnectTimeout((int) config.connectionTimeout.toMillis())\n+                        .setSocketTimeout((int) config.socketTimeout.toMillis());\n+            }\n+        });\n+\n+        builder.setHttpClientConfigCallback(new RestClientBuilder.HttpClientConfigCallback() {\n+            @Override\n+            public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {\n+                if (config.username.isPresent()) {\n+                    CredentialsProvider credentialsProvider = new BasicCredentialsProvider();\n+                    credentialsProvider.setCredentials(AuthScope.ANY,\n+                            new UsernamePasswordCredentials(config.username.get(), config.password.get()));\n+                    httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider);\n+                }\n+\n+                if (config.ioThreadCounts.isPresent()) {\n+                    IOReactorConfig ioReactorConfig = IOReactorConfig.custom()\n+                            .setIoThreadCount(config.ioThreadCounts.get())\n+                            .build();\n+                    httpClientBuilder.setDefaultIOReactorConfig(ioReactorConfig);\n+                }\n+\n+                return httpClientBuilder;\n+            }\n+        });\n+\n+        return builder;\n+    }\n+\n+    static Sniffer createSniffer(RestClient client, ElasticsearchConfig config) {\n+        return Sniffer.builder(client)\n+                .setSniffIntervalMillis((int) config.discovery.refreshInterval.toMillis())\n+                .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODE2NTk2OnYy", "diffSide": "RIGHT", "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjo0NzoyMFrOGx8dkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjo0NzoyMFrOGx8dkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAyNDAxNg==", "bodyText": "Not sure it's still relevant nowadays, but you might want to call setConnectionRequestTimeout( 0 ) here to avoid requests being flagged as timed out even when they didn't time out.\nSee https://hibernate.atlassian.net/browse/HSEARCH-2681\nSee https://github.com/hibernate/hibernate-search/blob/9da99d7de8f346aa0ec81ae2ce0a1fa2c1657b2a/backend/elasticsearch/src/main/java/org/hibernate/search/backend/elasticsearch/client/impl/ElasticsearchClientFactoryImpl.java#L236", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r455024016", "createdAt": "2020-07-15T12:47:20Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/RestClientBuilderHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package io.quarkus.elasticsearch.restclient.lowlevel.runtime;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.http.HttpHost;\n+import org.apache.http.auth.AuthScope;\n+import org.apache.http.auth.UsernamePasswordCredentials;\n+import org.apache.http.client.CredentialsProvider;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.impl.client.BasicCredentialsProvider;\n+import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;\n+import org.apache.http.impl.nio.reactor.IOReactorConfig;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.sniff.Sniffer;\n+\n+public final class RestClientBuilderHelper {\n+\n+    private RestClientBuilderHelper() {\n+        // avoid instantiation\n+    }\n+\n+    static RestClientBuilder createRestClientBuilder(ElasticsearchConfig config) {\n+        List<HttpHost> hosts = config.hosts.stream().map(s -> new HttpHost(s.substring(0, s.indexOf(\":\")),\n+                Integer.parseInt(s.substring(s.indexOf(\":\") + 1)), config.protocol)).collect(Collectors.toList());\n+        RestClientBuilder builder = RestClient.builder(hosts.toArray(new HttpHost[0]));\n+\n+        builder.setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() {\n+            @Override\n+            public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {\n+                return requestConfigBuilder\n+                        .setConnectTimeout((int) config.connectionTimeout.toMillis())\n+                        .setSocketTimeout((int) config.socketTimeout.toMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdd022fdc4675285e57715ea3fd4ea7f651077ed"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTM1ODU5OnYy", "diffSide": "RIGHT", "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/ElasticsearchConfig.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNTo1Njo1N1rOG0-0WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjowNzoxM1rOG0_RDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwODM0NA==", "bodyText": "From the javadoc:\n * This class implements an IP Socket Address (IP address + port number)\n * It can also be a pair (hostname + port number), in which case an attempt\n * will be made to resolve the hostname.\n\nDo you really want that?", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r458208344", "createdAt": "2020-07-21T15:56:57Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/ElasticsearchConfig.java", "diffHunk": "@@ -16,7 +17,7 @@\n      * The list of hosts of the Elasticsearch servers.\n      */\n     @ConfigItem(defaultValue = \"localhost:9200\")\n-    public List<String> hosts;\n+    public List<InetSocketAddress> hosts;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfbccaab4633b8901adc7eb98eaf50fe0cfd1980"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxMTQ1Ng==", "bodyText": "We use InetSocketAddress in Quarkus for all the host:port combinations. I think, if I use getHostString() as I did, it does not resolve anything. At least that's what the Javadoc says.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r458211456", "createdAt": "2020-07-21T16:01:12Z", "author": {"login": "gsmet"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/ElasticsearchConfig.java", "diffHunk": "@@ -16,7 +17,7 @@\n      * The list of hosts of the Elasticsearch servers.\n      */\n     @ConfigItem(defaultValue = \"localhost:9200\")\n-    public List<String> hosts;\n+    public List<InetSocketAddress> hosts;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwODM0NA=="}, "originalCommit": {"oid": "dfbccaab4633b8901adc7eb98eaf50fe0cfd1980"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxNTY5Mg==", "bodyText": "I checked (statically) what java.net.InetSocketAddress#InetSocketAddress(java.lang.String, int) calls and ended up in java.net.InetAddress#getAddressesFromNameService...  Might be worth a double-check.", "url": "https://github.com/quarkusio/quarkus/pull/10745#discussion_r458215692", "createdAt": "2020-07-21T16:07:13Z", "author": {"login": "yrodiere"}, "path": "extensions/elasticsearch-rest-client/runtime/src/main/java/io/quarkus/elasticsearch/restclient/lowlevel/runtime/ElasticsearchConfig.java", "diffHunk": "@@ -16,7 +17,7 @@\n      * The list of hosts of the Elasticsearch servers.\n      */\n     @ConfigItem(defaultValue = \"localhost:9200\")\n-    public List<String> hosts;\n+    public List<InetSocketAddress> hosts;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwODM0NA=="}, "originalCommit": {"oid": "dfbccaab4633b8901adc7eb98eaf50fe0cfd1980"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2508, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}