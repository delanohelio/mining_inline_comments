{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc0NjQwMjc4", "number": 11664, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxODozNDozOFrOEea52A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMToxOToyN1rOEjx2cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzMzNTI4OnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-orm-panache-common/runtime/src/main/java/io/quarkus/hibernate/orm/panache/common/runtime/AbstractJpaOperations.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxODozNDozOFrOHKD_vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNTo1Mzo1NlrOHL1_jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMxMzI3OQ==", "bodyText": "Is this enough? Don't you also need to consider associations with cascade delete enabled?", "url": "https://github.com/quarkusio/quarkus/pull/11664#discussion_r480313279", "createdAt": "2020-08-31T18:34:38Z", "author": {"login": "gavinking"}, "path": "extensions/panache/hibernate-orm-panache-common/runtime/src/main/java/io/quarkus/hibernate/orm/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -414,7 +420,21 @@ public boolean exists(Class<?> entityClass, String query, Parameters params) {\n     }\n \n     public long deleteAll(Class<?> entityClass) {\n+        Metamodel metamodel = getEntityManager().getMetamodel();\n+        EntityType<?> entity1 = metamodel.entity(entityClass);\n+        Set<Attribute<?, ?>> declaredAttributes = ((EntityTypeImpl) entity1).getDeclaredAttributes();\n+        if (declaredAttributes.stream().filter(attribute -> attribute.getPersistentAttributeType()\n+                .equals(Attribute.PersistentAttributeType.ELEMENT_COLLECTION)).count() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31f8d9eb22628186c4fd593c2e3e4caa529a9e3e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMxNTMyOA==", "bodyText": "Unfortunately it looks like JPA doesn\u2019t expose the cascade style so you would need to look at something Hibernate-specific.", "url": "https://github.com/quarkusio/quarkus/pull/11664#discussion_r480315328", "createdAt": "2020-08-31T18:38:17Z", "author": {"login": "gavinking"}, "path": "extensions/panache/hibernate-orm-panache-common/runtime/src/main/java/io/quarkus/hibernate/orm/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -414,7 +420,21 @@ public boolean exists(Class<?> entityClass, String query, Parameters params) {\n     }\n \n     public long deleteAll(Class<?> entityClass) {\n+        Metamodel metamodel = getEntityManager().getMetamodel();\n+        EntityType<?> entity1 = metamodel.entity(entityClass);\n+        Set<Attribute<?, ?>> declaredAttributes = ((EntityTypeImpl) entity1).getDeclaredAttributes();\n+        if (declaredAttributes.stream().filter(attribute -> attribute.getPersistentAttributeType()\n+                .equals(Attribute.PersistentAttributeType.ELEMENT_COLLECTION)).count() > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMxMzI3OQ=="}, "originalCommit": {"oid": "31f8d9eb22628186c4fd593c2e3e4caa529a9e3e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4MTAwNg==", "bodyText": "Yes, effectively. I need to detect the both cases. I will push very soon my code re-factored. Thank you for the proposition.", "url": "https://github.com/quarkusio/quarkus/pull/11664#discussion_r482181006", "createdAt": "2020-09-02T15:53:56Z", "author": {"login": "aureamunoz"}, "path": "extensions/panache/hibernate-orm-panache-common/runtime/src/main/java/io/quarkus/hibernate/orm/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -414,7 +420,21 @@ public boolean exists(Class<?> entityClass, String query, Parameters params) {\n     }\n \n     public long deleteAll(Class<?> entityClass) {\n+        Metamodel metamodel = getEntityManager().getMetamodel();\n+        EntityType<?> entity1 = metamodel.entity(entityClass);\n+        Set<Attribute<?, ?>> declaredAttributes = ((EntityTypeImpl) entity1).getDeclaredAttributes();\n+        if (declaredAttributes.stream().filter(attribute -> attribute.getPersistentAttributeType()\n+                .equals(Attribute.PersistentAttributeType.ELEMENT_COLLECTION)).count() > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDMxMzI3OQ=="}, "originalCommit": {"oid": "31f8d9eb22628186c4fd593c2e3e4caa529a9e3e"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDk1NzM2OnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-orm-panache-common/runtime/src/main/java/io/quarkus/hibernate/orm/panache/common/runtime/AbstractJpaOperations.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNjoxMToyNVrOHL2tBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwNzoyODo0NVrOHMZocQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE5MjY0Ng==", "bodyText": "Very minor, but I think you can use anyMatch() here, no?", "url": "https://github.com/quarkusio/quarkus/pull/11664#discussion_r482192646", "createdAt": "2020-09-02T16:11:25Z", "author": {"login": "gavinking"}, "path": "extensions/panache/hibernate-orm-panache-common/runtime/src/main/java/io/quarkus/hibernate/orm/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -421,7 +431,43 @@ public boolean exists(Class<?> entityClass, String query, Parameters params) {\n     }\n \n     public long deleteAll(Class<?> entityClass) {\n-        return (long) getEntityManager(entityClass).createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate();\n+        //detecting the case where there are cascade-delete associations, and do the the bulk delete query otherwise.\n+        if (deleteOnCascadeDetected(entityClass)) {\n+            int count = 0;\n+            List<?> objects = list(findAll(entityClass));\n+            for (Object entity : objects) {\n+                getEntityManager().remove(entity);\n+                count++;\n+            }\n+            return count;\n+        }\n+        return (long) getEntityManager().createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate();\n+\n+    }\n+\n+    /**\n+     * Detects if cascading delete is needed. The delete-cascading is needed when associations with cascade delete enabled\n+     * {@link javax.persistence.OneToMany#cascade()} and also on entities containing a collection of elements\n+     * {@link javax.persistence.ElementCollection}\n+     * \n+     * @param entityClass\n+     * @return true if cascading delete is needed. False otherwise\n+     */\n+    private boolean deleteOnCascadeDetected(Class<?> entityClass) {\n+        Metamodel metamodel = getEntityManager().getMetamodel();\n+        EntityType<?> entity1 = metamodel.entity(entityClass);\n+        Set<Attribute<?, ?>> declaredAttributes = ((EntityTypeImpl) entity1).getDeclaredAttributes();\n+\n+        CascadeStyle[] propertyCascadeStyles = getEntityManager().unwrap(SessionImplementor.class)\n+                .getEntityPersister(entityClass.getName(), null)\n+                .getPropertyCascadeStyles();\n+        boolean doCascade = Arrays.stream(propertyCascadeStyles)\n+                .filter(cascadeStyle -> cascadeStyle.doCascade(CascadingActions.DELETE))\n+                .count() > 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d50b53cf2e8b84786625db77e5b07f1146e7be9"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc2NDkxMw==", "bodyText": "yes, of course. Indeed, I used firstly the anyMatch but change because I was using another method and forget to use it again after refactor.", "url": "https://github.com/quarkusio/quarkus/pull/11664#discussion_r482764913", "createdAt": "2020-09-03T07:28:45Z", "author": {"login": "aureamunoz"}, "path": "extensions/panache/hibernate-orm-panache-common/runtime/src/main/java/io/quarkus/hibernate/orm/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -421,7 +431,43 @@ public boolean exists(Class<?> entityClass, String query, Parameters params) {\n     }\n \n     public long deleteAll(Class<?> entityClass) {\n-        return (long) getEntityManager(entityClass).createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate();\n+        //detecting the case where there are cascade-delete associations, and do the the bulk delete query otherwise.\n+        if (deleteOnCascadeDetected(entityClass)) {\n+            int count = 0;\n+            List<?> objects = list(findAll(entityClass));\n+            for (Object entity : objects) {\n+                getEntityManager().remove(entity);\n+                count++;\n+            }\n+            return count;\n+        }\n+        return (long) getEntityManager().createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate();\n+\n+    }\n+\n+    /**\n+     * Detects if cascading delete is needed. The delete-cascading is needed when associations with cascade delete enabled\n+     * {@link javax.persistence.OneToMany#cascade()} and also on entities containing a collection of elements\n+     * {@link javax.persistence.ElementCollection}\n+     * \n+     * @param entityClass\n+     * @return true if cascading delete is needed. False otherwise\n+     */\n+    private boolean deleteOnCascadeDetected(Class<?> entityClass) {\n+        Metamodel metamodel = getEntityManager().getMetamodel();\n+        EntityType<?> entity1 = metamodel.entity(entityClass);\n+        Set<Attribute<?, ?>> declaredAttributes = ((EntityTypeImpl) entity1).getDeclaredAttributes();\n+\n+        CascadeStyle[] propertyCascadeStyles = getEntityManager().unwrap(SessionImplementor.class)\n+                .getEntityPersister(entityClass.getName(), null)\n+                .getPropertyCascadeStyles();\n+        boolean doCascade = Arrays.stream(propertyCascadeStyles)\n+                .filter(cascadeStyle -> cascadeStyle.doCascade(CascadingActions.DELETE))\n+                .count() > 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE5MjY0Ng=="}, "originalCommit": {"oid": "7d50b53cf2e8b84786625db77e5b07f1146e7be9"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNDk5OTI5OnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-orm-panache-common/runtime/src/main/java/io/quarkus/hibernate/orm/panache/common/runtime/AbstractJpaOperations.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxNjoyMTo1MVrOHL3HHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxMTowOTo0NVrOHR8oTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE5OTMyNw==", "bodyText": "You need to at least also detect MANY_TO_MANY here.", "url": "https://github.com/quarkusio/quarkus/pull/11664#discussion_r482199327", "createdAt": "2020-09-02T16:21:51Z", "author": {"login": "gavinking"}, "path": "extensions/panache/hibernate-orm-panache-common/runtime/src/main/java/io/quarkus/hibernate/orm/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -421,7 +431,43 @@ public boolean exists(Class<?> entityClass, String query, Parameters params) {\n     }\n \n     public long deleteAll(Class<?> entityClass) {\n-        return (long) getEntityManager(entityClass).createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate();\n+        //detecting the case where there are cascade-delete associations, and do the the bulk delete query otherwise.\n+        if (deleteOnCascadeDetected(entityClass)) {\n+            int count = 0;\n+            List<?> objects = list(findAll(entityClass));\n+            for (Object entity : objects) {\n+                getEntityManager().remove(entity);\n+                count++;\n+            }\n+            return count;\n+        }\n+        return (long) getEntityManager().createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate();\n+\n+    }\n+\n+    /**\n+     * Detects if cascading delete is needed. The delete-cascading is needed when associations with cascade delete enabled\n+     * {@link javax.persistence.OneToMany#cascade()} and also on entities containing a collection of elements\n+     * {@link javax.persistence.ElementCollection}\n+     * \n+     * @param entityClass\n+     * @return true if cascading delete is needed. False otherwise\n+     */\n+    private boolean deleteOnCascadeDetected(Class<?> entityClass) {\n+        Metamodel metamodel = getEntityManager().getMetamodel();\n+        EntityType<?> entity1 = metamodel.entity(entityClass);\n+        Set<Attribute<?, ?>> declaredAttributes = ((EntityTypeImpl) entity1).getDeclaredAttributes();\n+\n+        CascadeStyle[] propertyCascadeStyles = getEntityManager().unwrap(SessionImplementor.class)\n+                .getEntityPersister(entityClass.getName(), null)\n+                .getPropertyCascadeStyles();\n+        boolean doCascade = Arrays.stream(propertyCascadeStyles)\n+                .filter(cascadeStyle -> cascadeStyle.doCascade(CascadingActions.DELETE))\n+                .count() > 0;\n+        boolean hasElementCollection = declaredAttributes.stream().filter(attribute -> attribute.getPersistentAttributeType()\n+                .equals(Attribute.PersistentAttributeType.ELEMENT_COLLECTION)).count() > 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d50b53cf2e8b84786625db77e5b07f1146e7be9"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc2OTA5Mg==", "bodyText": "Not sure to understand. I'm not detecting the kind of association (MANY_TO_MANY or ONE_TO_MANY and so on) but if the association has the cascade mode enabled. So the MANY_TO_MANY with cascade enabled will be detected here.\nIn the other hand, when an attribute has @ElementCollection, it is meaningless without the parent entity, so, whenever a parent entity is removed, the children will also be, no?", "url": "https://github.com/quarkusio/quarkus/pull/11664#discussion_r482769092", "createdAt": "2020-09-03T07:35:56Z", "author": {"login": "aureamunoz"}, "path": "extensions/panache/hibernate-orm-panache-common/runtime/src/main/java/io/quarkus/hibernate/orm/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -421,7 +431,43 @@ public boolean exists(Class<?> entityClass, String query, Parameters params) {\n     }\n \n     public long deleteAll(Class<?> entityClass) {\n-        return (long) getEntityManager(entityClass).createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate();\n+        //detecting the case where there are cascade-delete associations, and do the the bulk delete query otherwise.\n+        if (deleteOnCascadeDetected(entityClass)) {\n+            int count = 0;\n+            List<?> objects = list(findAll(entityClass));\n+            for (Object entity : objects) {\n+                getEntityManager().remove(entity);\n+                count++;\n+            }\n+            return count;\n+        }\n+        return (long) getEntityManager().createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate();\n+\n+    }\n+\n+    /**\n+     * Detects if cascading delete is needed. The delete-cascading is needed when associations with cascade delete enabled\n+     * {@link javax.persistence.OneToMany#cascade()} and also on entities containing a collection of elements\n+     * {@link javax.persistence.ElementCollection}\n+     * \n+     * @param entityClass\n+     * @return true if cascading delete is needed. False otherwise\n+     */\n+    private boolean deleteOnCascadeDetected(Class<?> entityClass) {\n+        Metamodel metamodel = getEntityManager().getMetamodel();\n+        EntityType<?> entity1 = metamodel.entity(entityClass);\n+        Set<Attribute<?, ?>> declaredAttributes = ((EntityTypeImpl) entity1).getDeclaredAttributes();\n+\n+        CascadeStyle[] propertyCascadeStyles = getEntityManager().unwrap(SessionImplementor.class)\n+                .getEntityPersister(entityClass.getName(), null)\n+                .getPropertyCascadeStyles();\n+        boolean doCascade = Arrays.stream(propertyCascadeStyles)\n+                .filter(cascadeStyle -> cascadeStyle.doCascade(CascadingActions.DELETE))\n+                .count() > 0;\n+        boolean hasElementCollection = declaredAttributes.stream().filter(attribute -> attribute.getPersistentAttributeType()\n+                .equals(Attribute.PersistentAttributeType.ELEMENT_COLLECTION)).count() > 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE5OTMyNw=="}, "originalCommit": {"oid": "7d50b53cf2e8b84786625db77e5b07f1146e7be9"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIwODI4Mg==", "bodyText": "The thing is that many-to-many associations have the link table that needs to be cleaned up when you delete the current entity, even if you're not cascading the delete to the associated entity (which you wouldn't usually do anyway for a many-to-many).", "url": "https://github.com/quarkusio/quarkus/pull/11664#discussion_r485208282", "createdAt": "2020-09-08T21:33:19Z", "author": {"login": "gavinking"}, "path": "extensions/panache/hibernate-orm-panache-common/runtime/src/main/java/io/quarkus/hibernate/orm/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -421,7 +431,43 @@ public boolean exists(Class<?> entityClass, String query, Parameters params) {\n     }\n \n     public long deleteAll(Class<?> entityClass) {\n-        return (long) getEntityManager(entityClass).createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate();\n+        //detecting the case where there are cascade-delete associations, and do the the bulk delete query otherwise.\n+        if (deleteOnCascadeDetected(entityClass)) {\n+            int count = 0;\n+            List<?> objects = list(findAll(entityClass));\n+            for (Object entity : objects) {\n+                getEntityManager().remove(entity);\n+                count++;\n+            }\n+            return count;\n+        }\n+        return (long) getEntityManager().createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate();\n+\n+    }\n+\n+    /**\n+     * Detects if cascading delete is needed. The delete-cascading is needed when associations with cascade delete enabled\n+     * {@link javax.persistence.OneToMany#cascade()} and also on entities containing a collection of elements\n+     * {@link javax.persistence.ElementCollection}\n+     * \n+     * @param entityClass\n+     * @return true if cascading delete is needed. False otherwise\n+     */\n+    private boolean deleteOnCascadeDetected(Class<?> entityClass) {\n+        Metamodel metamodel = getEntityManager().getMetamodel();\n+        EntityType<?> entity1 = metamodel.entity(entityClass);\n+        Set<Attribute<?, ?>> declaredAttributes = ((EntityTypeImpl) entity1).getDeclaredAttributes();\n+\n+        CascadeStyle[] propertyCascadeStyles = getEntityManager().unwrap(SessionImplementor.class)\n+                .getEntityPersister(entityClass.getName(), null)\n+                .getPropertyCascadeStyles();\n+        boolean doCascade = Arrays.stream(propertyCascadeStyles)\n+                .filter(cascadeStyle -> cascadeStyle.doCascade(CascadingActions.DELETE))\n+                .count() > 0;\n+        boolean hasElementCollection = declaredAttributes.stream().filter(attribute -> attribute.getPersistentAttributeType()\n+                .equals(Attribute.PersistentAttributeType.ELEMENT_COLLECTION)).count() > 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE5OTMyNw=="}, "originalCommit": {"oid": "7d50b53cf2e8b84786625db77e5b07f1146e7be9"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIwODYwOA==", "bodyText": "(So you need to treat many-to-many the same as an element collection.)", "url": "https://github.com/quarkusio/quarkus/pull/11664#discussion_r485208608", "createdAt": "2020-09-08T21:34:00Z", "author": {"login": "gavinking"}, "path": "extensions/panache/hibernate-orm-panache-common/runtime/src/main/java/io/quarkus/hibernate/orm/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -421,7 +431,43 @@ public boolean exists(Class<?> entityClass, String query, Parameters params) {\n     }\n \n     public long deleteAll(Class<?> entityClass) {\n-        return (long) getEntityManager(entityClass).createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate();\n+        //detecting the case where there are cascade-delete associations, and do the the bulk delete query otherwise.\n+        if (deleteOnCascadeDetected(entityClass)) {\n+            int count = 0;\n+            List<?> objects = list(findAll(entityClass));\n+            for (Object entity : objects) {\n+                getEntityManager().remove(entity);\n+                count++;\n+            }\n+            return count;\n+        }\n+        return (long) getEntityManager().createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate();\n+\n+    }\n+\n+    /**\n+     * Detects if cascading delete is needed. The delete-cascading is needed when associations with cascade delete enabled\n+     * {@link javax.persistence.OneToMany#cascade()} and also on entities containing a collection of elements\n+     * {@link javax.persistence.ElementCollection}\n+     * \n+     * @param entityClass\n+     * @return true if cascading delete is needed. False otherwise\n+     */\n+    private boolean deleteOnCascadeDetected(Class<?> entityClass) {\n+        Metamodel metamodel = getEntityManager().getMetamodel();\n+        EntityType<?> entity1 = metamodel.entity(entityClass);\n+        Set<Attribute<?, ?>> declaredAttributes = ((EntityTypeImpl) entity1).getDeclaredAttributes();\n+\n+        CascadeStyle[] propertyCascadeStyles = getEntityManager().unwrap(SessionImplementor.class)\n+                .getEntityPersister(entityClass.getName(), null)\n+                .getPropertyCascadeStyles();\n+        boolean doCascade = Arrays.stream(propertyCascadeStyles)\n+                .filter(cascadeStyle -> cascadeStyle.doCascade(CascadingActions.DELETE))\n+                .count() > 0;\n+        boolean hasElementCollection = declaredAttributes.stream().filter(attribute -> attribute.getPersistentAttributeType()\n+                .equals(Attribute.PersistentAttributeType.ELEMENT_COLLECTION)).count() > 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE5OTMyNw=="}, "originalCommit": {"oid": "7d50b53cf2e8b84786625db77e5b07f1146e7be9"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODU4MTE5Ng==", "bodyText": "I have added a test to verify that many-to-many associations are correctly managed and it's ok, the link table is also cleaned up. I've just pushed the code.", "url": "https://github.com/quarkusio/quarkus/pull/11664#discussion_r488581196", "createdAt": "2020-09-15T11:09:45Z", "author": {"login": "aureamunoz"}, "path": "extensions/panache/hibernate-orm-panache-common/runtime/src/main/java/io/quarkus/hibernate/orm/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -421,7 +431,43 @@ public boolean exists(Class<?> entityClass, String query, Parameters params) {\n     }\n \n     public long deleteAll(Class<?> entityClass) {\n-        return (long) getEntityManager(entityClass).createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate();\n+        //detecting the case where there are cascade-delete associations, and do the the bulk delete query otherwise.\n+        if (deleteOnCascadeDetected(entityClass)) {\n+            int count = 0;\n+            List<?> objects = list(findAll(entityClass));\n+            for (Object entity : objects) {\n+                getEntityManager().remove(entity);\n+                count++;\n+            }\n+            return count;\n+        }\n+        return (long) getEntityManager().createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate();\n+\n+    }\n+\n+    /**\n+     * Detects if cascading delete is needed. The delete-cascading is needed when associations with cascade delete enabled\n+     * {@link javax.persistence.OneToMany#cascade()} and also on entities containing a collection of elements\n+     * {@link javax.persistence.ElementCollection}\n+     * \n+     * @param entityClass\n+     * @return true if cascading delete is needed. False otherwise\n+     */\n+    private boolean deleteOnCascadeDetected(Class<?> entityClass) {\n+        Metamodel metamodel = getEntityManager().getMetamodel();\n+        EntityType<?> entity1 = metamodel.entity(entityClass);\n+        Set<Attribute<?, ?>> declaredAttributes = ((EntityTypeImpl) entity1).getDeclaredAttributes();\n+\n+        CascadeStyle[] propertyCascadeStyles = getEntityManager().unwrap(SessionImplementor.class)\n+                .getEntityPersister(entityClass.getName(), null)\n+                .getPropertyCascadeStyles();\n+        boolean doCascade = Arrays.stream(propertyCascadeStyles)\n+                .filter(cascadeStyle -> cascadeStyle.doCascade(CascadingActions.DELETE))\n+                .count() > 0;\n+        boolean hasElementCollection = declaredAttributes.stream().filter(attribute -> attribute.getPersistentAttributeType()\n+                .equals(Attribute.PersistentAttributeType.ELEMENT_COLLECTION)).count() > 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE5OTMyNw=="}, "originalCommit": {"oid": "7d50b53cf2e8b84786625db77e5b07f1146e7be9"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NzU3ODQ4OnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-orm-panache-common/runtime/src/main/java/io/quarkus/hibernate/orm/panache/common/runtime/AbstractJpaOperations.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxMzoyOTo1NVrOHSB7DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMDoyODo0MVrOHSTXFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY2NzkxNw==", "bodyText": "This doesn't seem right TBH", "url": "https://github.com/quarkusio/quarkus/pull/11664#discussion_r488667917", "createdAt": "2020-09-15T13:29:55Z", "author": {"login": "geoand"}, "path": "extensions/panache/hibernate-orm-panache-common/runtime/src/main/java/io/quarkus/hibernate/orm/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -421,7 +421,8 @@ public boolean exists(Class<?> entityClass, String query, Parameters params) {\n     }\n \n     public long deleteAll(Class<?> entityClass) {\n-        return (long) getEntityManager(entityClass).createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate();\n+        return (long) getEntityManager().createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e56cf323d599913f83d35b8b439b748f02ac157"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk1MzYyMQ==", "bodyText": "Weird, I should have done a wrong copy/paste or something. Fixed in the last push", "url": "https://github.com/quarkusio/quarkus/pull/11664#discussion_r488953621", "createdAt": "2020-09-15T20:28:41Z", "author": {"login": "aureamunoz"}, "path": "extensions/panache/hibernate-orm-panache-common/runtime/src/main/java/io/quarkus/hibernate/orm/panache/common/runtime/AbstractJpaOperations.java", "diffHunk": "@@ -421,7 +421,8 @@ public boolean exists(Class<?> entityClass, String query, Parameters params) {\n     }\n \n     public long deleteAll(Class<?> entityClass) {\n-        return (long) getEntityManager(entityClass).createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate();\n+        return (long) getEntityManager().createQuery(\"DELETE FROM \" + getEntityName(entityClass)).executeUpdate();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY2NzkxNw=="}, "originalCommit": {"oid": "4e56cf323d599913f83d35b8b439b748f02ac157"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1OTUyMzY4OnYy", "diffSide": "RIGHT", "path": "extensions/panache/hibernate-orm-panache/runtime/src/main/java/io/quarkus/hibernate/orm/panache/runtime/AdditionalJpaOperations.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMToxOToyN1rOHSU7ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMToxOToyN1rOHSU7ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3OTMzOA==", "bodyText": "I still think this needs to be || MANY_TO_MANY", "url": "https://github.com/quarkusio/quarkus/pull/11664#discussion_r488979338", "createdAt": "2020-09-15T21:19:27Z", "author": {"login": "gavinking"}, "path": "extensions/panache/hibernate-orm-panache/runtime/src/main/java/io/quarkus/hibernate/orm/panache/runtime/AdditionalJpaOperations.java", "diffHunk": "@@ -36,4 +47,76 @@\n         JpaOperations.bindParameters(jpaQuery, params);\n         return new CustomCountPanacheQuery(em, jpaQuery, findQuery, countQuery, params);\n     }\n+\n+    public static long deleteAllWithCascade(Class<?> entityClass) {\n+        EntityManager em = JpaOperations.getEntityManager();\n+        //detecting the case where there are cascade-delete associations, and do the the bulk delete query otherwise.\n+        if (deleteOnCascadeDetected(entityClass)) {\n+            int count = 0;\n+            List<?> objects = JpaOperations.listAll(entityClass);\n+            for (Object entity : objects) {\n+                em.remove(entity);\n+                count++;\n+            }\n+            return count;\n+        }\n+        return JpaOperations.deleteAll(entityClass);\n+    }\n+\n+    /**\n+     * Detects if cascading delete is needed. The delete-cascading is needed when associations with cascade delete enabled\n+     * {@link javax.persistence.OneToMany#cascade()} and also on entities containing a collection of elements\n+     * {@link javax.persistence.ElementCollection}\n+     *\n+     * @param entityClass\n+     * @return true if cascading delete is needed. False otherwise\n+     */\n+    private static boolean deleteOnCascadeDetected(Class<?> entityClass) {\n+        EntityManager em = JpaOperations.getEntityManager();\n+        Metamodel metamodel = em.getMetamodel();\n+        EntityType<?> entity1 = metamodel.entity(entityClass);\n+        Set<Attribute<?, ?>> declaredAttributes = ((EntityTypeImpl) entity1).getDeclaredAttributes();\n+\n+        CascadeStyle[] propertyCascadeStyles = em.unwrap(SessionImplementor.class)\n+                .getEntityPersister(entityClass.getName(), null)\n+                .getPropertyCascadeStyles();\n+        boolean doCascade = Arrays.stream(propertyCascadeStyles)\n+                .anyMatch(cascadeStyle -> cascadeStyle.doCascade(CascadingActions.DELETE));\n+        boolean hasElementCollection = declaredAttributes.stream().filter(attribute -> attribute.getPersistentAttributeType()\n+                .equals(Attribute.PersistentAttributeType.ELEMENT_COLLECTION)).count() > 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd72be74ab93bb5d6c6675c00ba6edaba46a5f27"}, "originalPosition": 61}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 544, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}