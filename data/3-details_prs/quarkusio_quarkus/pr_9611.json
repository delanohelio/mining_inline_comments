{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzMjkxNzgw", "number": 9611, "title": "Add a kotlin panache guide", "bodyText": "This guide is intended to be more of a supplement to the Java version so we don't duplicate and have to update multiple versions of the same information.  It's intended to focus on the Kotlin deviations specifically.\nThis also removes the Id type parameter from PanacheEntityBase to better align with the Java version.", "createdAt": "2020-05-26T15:47:24Z", "url": "https://github.com/quarkusio/quarkus/pull/9611", "merged": true, "mergeCommit": {"oid": "f7d195c920de4377b14441ac8ff08f59fae22806"}, "closed": true, "closedAt": "2020-06-03T02:55:39Z", "author": {"login": "evanchooly"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABclSLQcAFqTQxODg1ODY5MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcnRTQigFqTQyMjQ5Mzk1MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4ODU4Njkw", "url": "https://github.com/quarkusio/quarkus/pull/9611#pullrequestreview-418858690", "createdAt": "2020-05-27T05:03:56Z", "commit": {"oid": "3cb7267c575bde7f103677b868246629fabb62be"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNTowMzo1NlrOGa5hSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNTowNjoyMFrOGa5jpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1ODU3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            As you can see our entities remain simple there is, however, a slight difference from the Java version.  The Kotlin\n          \n          \n            \n            As you can see our entities remain simple, there is however, a slight difference from the Java version.  The Kotlin", "url": "https://github.com/quarkusio/quarkus/pull/9611#discussion_r430858570", "createdAt": "2020-05-27T05:03:56Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/hibernate-orm-panache-kotlin.adoc", "diffHunk": "@@ -0,0 +1,204 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Simplified Hibernate ORM with Panache and Kotlin\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+Hibernate ORM is the de facto standard JPA implementation and is well-known in the Java ecosystem.  Panache offers a\n+new layer atop this familiar framework.  This guide will not dive in to the specifics of either as those are already\n+covered in the link:hibernate-orm-panache.adoc[Panache guide].  In this guide, we'll cover the Kotlin specific changes\n+needed to use Panache in your Kotlin-based Quarkus applications.\n+\n+== First: an example\n+\n+As we saw in the Panache guide, Panache allows us to extend the functionality in our entities and DAOs with some automatically\n+provided functionality.  When using Kotlin, the approach is very similar to what we see in the Java version with a slight\n+change or two.  To Panache-enable your entity, you would define it something like:\n+\n+[source,kotlin]\n+----\n+@Entity\n+class Person: PanacheEntity {\n+    lateinit var name: String\n+    lateinit var birth: LocalDate\n+    lateinit var status: Status\n+}\n+----\n+\n+As you can see our entities remain simple there is, however, a slight difference from the Java version.  The Kotlin", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb7267c575bde7f103677b868246629fabb62be"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1ODg1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `companion object`:\n          \n          \n            \n            [companion object](https://kotlinlang.org/docs/tutorials/kotlin-for-py/objects-and-companion-objects.html#companion-objects):", "url": "https://github.com/quarkusio/quarkus/pull/9611#discussion_r430858856", "createdAt": "2020-05-27T05:05:07Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/hibernate-orm-panache-kotlin.adoc", "diffHunk": "@@ -0,0 +1,204 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Simplified Hibernate ORM with Panache and Kotlin\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+Hibernate ORM is the de facto standard JPA implementation and is well-known in the Java ecosystem.  Panache offers a\n+new layer atop this familiar framework.  This guide will not dive in to the specifics of either as those are already\n+covered in the link:hibernate-orm-panache.adoc[Panache guide].  In this guide, we'll cover the Kotlin specific changes\n+needed to use Panache in your Kotlin-based Quarkus applications.\n+\n+== First: an example\n+\n+As we saw in the Panache guide, Panache allows us to extend the functionality in our entities and DAOs with some automatically\n+provided functionality.  When using Kotlin, the approach is very similar to what we see in the Java version with a slight\n+change or two.  To Panache-enable your entity, you would define it something like:\n+\n+[source,kotlin]\n+----\n+@Entity\n+class Person: PanacheEntity {\n+    lateinit var name: String\n+    lateinit var birth: LocalDate\n+    lateinit var status: Status\n+}\n+----\n+\n+As you can see our entities remain simple there is, however, a slight difference from the Java version.  The Kotlin\n+language doesn't support the notion of static methods in quite the same way as Java does.  Instead, we use the\n+`companion object`:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb7267c575bde7f103677b868246629fabb62be"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1OTE3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            by making them implements `PanacheRepository`:\n          \n          \n            \n            by making them implement `PanacheRepository`:", "url": "https://github.com/quarkusio/quarkus/pull/9611#discussion_r430859172", "createdAt": "2020-05-27T05:06:20Z", "author": {"login": "geoand"}, "path": "docs/src/main/asciidoc/hibernate-orm-panache-kotlin.adoc", "diffHunk": "@@ -0,0 +1,204 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Simplified Hibernate ORM with Panache and Kotlin\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+Hibernate ORM is the de facto standard JPA implementation and is well-known in the Java ecosystem.  Panache offers a\n+new layer atop this familiar framework.  This guide will not dive in to the specifics of either as those are already\n+covered in the link:hibernate-orm-panache.adoc[Panache guide].  In this guide, we'll cover the Kotlin specific changes\n+needed to use Panache in your Kotlin-based Quarkus applications.\n+\n+== First: an example\n+\n+As we saw in the Panache guide, Panache allows us to extend the functionality in our entities and DAOs with some automatically\n+provided functionality.  When using Kotlin, the approach is very similar to what we see in the Java version with a slight\n+change or two.  To Panache-enable your entity, you would define it something like:\n+\n+[source,kotlin]\n+----\n+@Entity\n+class Person: PanacheEntity {\n+    lateinit var name: String\n+    lateinit var birth: LocalDate\n+    lateinit var status: Status\n+}\n+----\n+\n+As you can see our entities remain simple there is, however, a slight difference from the Java version.  The Kotlin\n+language doesn't support the notion of static methods in quite the same way as Java does.  Instead, we use the\n+`companion object`:\n+\n+[source,kotlin]\n+----\n+@Entity\n+class Person : PanacheEntity {\n+    companion object: PanacheCompanion<Person> {  // <1>\n+        fun findByName(name: String) = find(\"name\", name).firstResult()\n+        fun findAlive() = list(\"status\", Status.Alive)\n+        fun deleteStefs() = delete(\"name\", \"Stef\")\n+    }\n+\n+    lateinit var name: String  // <2>\n+    lateinit var birth: LocalDate\n+    lateinit var status: Status\n+}\n+----\n+<1> The companion object holds all the methods not related to a specific instance allowing for general management and\n+querying bound to a specific type.\n+<2> Here there are options, but we've chosen the `lateinit` approach.  This allows us to declare these fields as non-null\n+knowing they will be properly assigned either by the constructor (not shown) or by hibernate loading data from the\n+database.\n+\n+NOTE: Note that these types differ from the Java types mentioned in those tutorials.  For kotlin support, all the Panache\n+types will be found in the `io.quarkus.hibernate.orm.panache.kotlin` package.  This subpackage allows for the distinction\n+between the Java and Kotlin variants and allows for both to be used unambiguously in a single project.\n+\n+In the Kotlin version, we've simply moved the bulk of the link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[`entity pattern`]\n+functionality to the `companion object`.  Apart from this slight change, we can then work with our types in ways that map easily\n+from the Java side of world.\n+\n+\n+== Using the repository pattern\n+\n+\n+=== Defining your entity\n+\n+When using the repository pattern, you can define your entities as regular JPA entities.\n+[source,kotlin]\n+----\n+@Entity\n+class Person {\n+    @Id\n+    @GeneratedValue\n+    var id: Long? = null;\n+    lateinit var name: String\n+    lateinit var birth: LocalDate\n+    lateinit var status: Status\n+}\n+----\n+\n+=== Defining your repository\n+\n+When using Repositories, you get the exact same convenient methods as with the active record pattern, injected in your Repository,\n+by making them implements `PanacheRepository`:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cb7267c575bde7f103677b868246629fabb62be"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5OTI2Mzc1", "url": "https://github.com/quarkusio/quarkus/pull/9611#pullrequestreview-419926375", "createdAt": "2020-05-28T09:18:28Z", "commit": {"oid": "c0ab2195f2834e5217dd0178a88e612b5470f24a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwOToxODoyOVrOGbstTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwOToyNDowNVrOGbs5_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY5NzIyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            As we saw in the Panache guide, Panache allows us to extend the functionality in our entities and DAOs with some automatically\n          \n          \n            \n            As we saw in the Panache guide, Panache allows us to extend the functionality in our entities and repositories (also known as DAOs) with some automatically", "url": "https://github.com/quarkusio/quarkus/pull/9611#discussion_r431697228", "createdAt": "2020-05-28T09:18:29Z", "author": {"login": "FroMage"}, "path": "docs/src/main/asciidoc/hibernate-orm-panache-kotlin.adoc", "diffHunk": "@@ -0,0 +1,204 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Simplified Hibernate ORM with Panache and Kotlin\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+Hibernate ORM is the de facto standard JPA implementation and is well-known in the Java ecosystem.  Panache offers a\n+new layer atop this familiar framework.  This guide will not dive in to the specifics of either as those are already\n+covered in the link:hibernate-orm-panache.adoc[Panache guide].  In this guide, we'll cover the Kotlin specific changes\n+needed to use Panache in your Kotlin-based Quarkus applications.\n+\n+== First: an example\n+\n+As we saw in the Panache guide, Panache allows us to extend the functionality in our entities and DAOs with some automatically", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0ab2195f2834e5217dd0178a88e612b5470f24a"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY5Nzk3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            language doesn't support the notion of static methods in quite the same way as Java does.  Instead, we use the\n          \n          \n            \n            language doesn't support the notion of static methods in quite the same way as Java does.  Instead, we must use a", "url": "https://github.com/quarkusio/quarkus/pull/9611#discussion_r431697972", "createdAt": "2020-05-28T09:19:44Z", "author": {"login": "FroMage"}, "path": "docs/src/main/asciidoc/hibernate-orm-panache-kotlin.adoc", "diffHunk": "@@ -0,0 +1,204 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Simplified Hibernate ORM with Panache and Kotlin\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+Hibernate ORM is the de facto standard JPA implementation and is well-known in the Java ecosystem.  Panache offers a\n+new layer atop this familiar framework.  This guide will not dive in to the specifics of either as those are already\n+covered in the link:hibernate-orm-panache.adoc[Panache guide].  In this guide, we'll cover the Kotlin specific changes\n+needed to use Panache in your Kotlin-based Quarkus applications.\n+\n+== First: an example\n+\n+As we saw in the Panache guide, Panache allows us to extend the functionality in our entities and DAOs with some automatically\n+provided functionality.  When using Kotlin, the approach is very similar to what we see in the Java version with a slight\n+change or two.  To Panache-enable your entity, you would define it something like:\n+\n+[source,kotlin]\n+----\n+@Entity\n+class Person: PanacheEntity {\n+    lateinit var name: String\n+    lateinit var birth: LocalDate\n+    lateinit var status: Status\n+}\n+----\n+\n+As you can see our entities remain simple there is, however, a slight difference from the Java version.  The Kotlin\n+language doesn't support the notion of static methods in quite the same way as Java does.  Instead, we use the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0ab2195f2834e5217dd0178a88e612b5470f24a"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY5ODQ5Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            NOTE: Note that these types differ from the Java types mentioned in those tutorials.  For kotlin support, all the Panache\n          \n          \n            \n            NOTE: These types differ from the Java types mentioned in those tutorials.  For kotlin support, all the Panache", "url": "https://github.com/quarkusio/quarkus/pull/9611#discussion_r431698492", "createdAt": "2020-05-28T09:20:40Z", "author": {"login": "FroMage"}, "path": "docs/src/main/asciidoc/hibernate-orm-panache-kotlin.adoc", "diffHunk": "@@ -0,0 +1,204 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Simplified Hibernate ORM with Panache and Kotlin\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+Hibernate ORM is the de facto standard JPA implementation and is well-known in the Java ecosystem.  Panache offers a\n+new layer atop this familiar framework.  This guide will not dive in to the specifics of either as those are already\n+covered in the link:hibernate-orm-panache.adoc[Panache guide].  In this guide, we'll cover the Kotlin specific changes\n+needed to use Panache in your Kotlin-based Quarkus applications.\n+\n+== First: an example\n+\n+As we saw in the Panache guide, Panache allows us to extend the functionality in our entities and DAOs with some automatically\n+provided functionality.  When using Kotlin, the approach is very similar to what we see in the Java version with a slight\n+change or two.  To Panache-enable your entity, you would define it something like:\n+\n+[source,kotlin]\n+----\n+@Entity\n+class Person: PanacheEntity {\n+    lateinit var name: String\n+    lateinit var birth: LocalDate\n+    lateinit var status: Status\n+}\n+----\n+\n+As you can see our entities remain simple there is, however, a slight difference from the Java version.  The Kotlin\n+language doesn't support the notion of static methods in quite the same way as Java does.  Instead, we use the\n+[companion object](https://kotlinlang.org/docs/tutorials/kotlin-for-py/objects-and-companion-objects.html#companion-objects):\n+\n+[source,kotlin]\n+----\n+@Entity\n+class Person : PanacheEntity {\n+    companion object: PanacheCompanion<Person> {  // <1>\n+        fun findByName(name: String) = find(\"name\", name).firstResult()\n+        fun findAlive() = list(\"status\", Status.Alive)\n+        fun deleteStefs() = delete(\"name\", \"Stef\")\n+    }\n+\n+    lateinit var name: String  // <2>\n+    lateinit var birth: LocalDate\n+    lateinit var status: Status\n+}\n+----\n+<1> The companion object holds all the methods not related to a specific instance allowing for general management and\n+querying bound to a specific type.\n+<2> Here there are options, but we've chosen the `lateinit` approach.  This allows us to declare these fields as non-null\n+knowing they will be properly assigned either by the constructor (not shown) or by hibernate loading data from the\n+database.\n+\n+NOTE: Note that these types differ from the Java types mentioned in those tutorials.  For kotlin support, all the Panache", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0ab2195f2834e5217dd0178a88e612b5470f24a"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY5OTc3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In the Kotlin version, we've simply moved the bulk of the link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[`entity pattern`]\n          \n          \n            \n            In the Kotlin version, we've simply moved the bulk of the link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[`active record pattern`]\n          \n      \n    \n    \n  \n\nFor some reason, the Hibernate ORM with Panache guide seems to prefer this term, even though I don't agree with it.", "url": "https://github.com/quarkusio/quarkus/pull/9611#discussion_r431699774", "createdAt": "2020-05-28T09:22:50Z", "author": {"login": "FroMage"}, "path": "docs/src/main/asciidoc/hibernate-orm-panache-kotlin.adoc", "diffHunk": "@@ -0,0 +1,204 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Simplified Hibernate ORM with Panache and Kotlin\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+Hibernate ORM is the de facto standard JPA implementation and is well-known in the Java ecosystem.  Panache offers a\n+new layer atop this familiar framework.  This guide will not dive in to the specifics of either as those are already\n+covered in the link:hibernate-orm-panache.adoc[Panache guide].  In this guide, we'll cover the Kotlin specific changes\n+needed to use Panache in your Kotlin-based Quarkus applications.\n+\n+== First: an example\n+\n+As we saw in the Panache guide, Panache allows us to extend the functionality in our entities and DAOs with some automatically\n+provided functionality.  When using Kotlin, the approach is very similar to what we see in the Java version with a slight\n+change or two.  To Panache-enable your entity, you would define it something like:\n+\n+[source,kotlin]\n+----\n+@Entity\n+class Person: PanacheEntity {\n+    lateinit var name: String\n+    lateinit var birth: LocalDate\n+    lateinit var status: Status\n+}\n+----\n+\n+As you can see our entities remain simple there is, however, a slight difference from the Java version.  The Kotlin\n+language doesn't support the notion of static methods in quite the same way as Java does.  Instead, we use the\n+[companion object](https://kotlinlang.org/docs/tutorials/kotlin-for-py/objects-and-companion-objects.html#companion-objects):\n+\n+[source,kotlin]\n+----\n+@Entity\n+class Person : PanacheEntity {\n+    companion object: PanacheCompanion<Person> {  // <1>\n+        fun findByName(name: String) = find(\"name\", name).firstResult()\n+        fun findAlive() = list(\"status\", Status.Alive)\n+        fun deleteStefs() = delete(\"name\", \"Stef\")\n+    }\n+\n+    lateinit var name: String  // <2>\n+    lateinit var birth: LocalDate\n+    lateinit var status: Status\n+}\n+----\n+<1> The companion object holds all the methods not related to a specific instance allowing for general management and\n+querying bound to a specific type.\n+<2> Here there are options, but we've chosen the `lateinit` approach.  This allows us to declare these fields as non-null\n+knowing they will be properly assigned either by the constructor (not shown) or by hibernate loading data from the\n+database.\n+\n+NOTE: Note that these types differ from the Java types mentioned in those tutorials.  For kotlin support, all the Panache\n+types will be found in the `io.quarkus.hibernate.orm.panache.kotlin` package.  This subpackage allows for the distinction\n+between the Java and Kotlin variants and allows for both to be used unambiguously in a single project.\n+\n+In the Kotlin version, we've simply moved the bulk of the link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[`entity pattern`]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0ab2195f2834e5217dd0178a88e612b5470f24a"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcwMDQ3OQ==", "bodyText": "Isn't it a bit weird to declare it as a nulltable type here? I guess we re-use the variable later, but still\u2026", "url": "https://github.com/quarkusio/quarkus/pull/9611#discussion_r431700479", "createdAt": "2020-05-28T09:24:05Z", "author": {"login": "FroMage"}, "path": "docs/src/main/asciidoc/hibernate-orm-panache-kotlin.adoc", "diffHunk": "@@ -0,0 +1,204 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Simplified Hibernate ORM with Panache and Kotlin\n+\n+include::./attributes.adoc[]\n+:config-file: application.properties\n+\n+Hibernate ORM is the de facto standard JPA implementation and is well-known in the Java ecosystem.  Panache offers a\n+new layer atop this familiar framework.  This guide will not dive in to the specifics of either as those are already\n+covered in the link:hibernate-orm-panache.adoc[Panache guide].  In this guide, we'll cover the Kotlin specific changes\n+needed to use Panache in your Kotlin-based Quarkus applications.\n+\n+== First: an example\n+\n+As we saw in the Panache guide, Panache allows us to extend the functionality in our entities and DAOs with some automatically\n+provided functionality.  When using Kotlin, the approach is very similar to what we see in the Java version with a slight\n+change or two.  To Panache-enable your entity, you would define it something like:\n+\n+[source,kotlin]\n+----\n+@Entity\n+class Person: PanacheEntity {\n+    lateinit var name: String\n+    lateinit var birth: LocalDate\n+    lateinit var status: Status\n+}\n+----\n+\n+As you can see our entities remain simple there is, however, a slight difference from the Java version.  The Kotlin\n+language doesn't support the notion of static methods in quite the same way as Java does.  Instead, we use the\n+[companion object](https://kotlinlang.org/docs/tutorials/kotlin-for-py/objects-and-companion-objects.html#companion-objects):\n+\n+[source,kotlin]\n+----\n+@Entity\n+class Person : PanacheEntity {\n+    companion object: PanacheCompanion<Person> {  // <1>\n+        fun findByName(name: String) = find(\"name\", name).firstResult()\n+        fun findAlive() = list(\"status\", Status.Alive)\n+        fun deleteStefs() = delete(\"name\", \"Stef\")\n+    }\n+\n+    lateinit var name: String  // <2>\n+    lateinit var birth: LocalDate\n+    lateinit var status: Status\n+}\n+----\n+<1> The companion object holds all the methods not related to a specific instance allowing for general management and\n+querying bound to a specific type.\n+<2> Here there are options, but we've chosen the `lateinit` approach.  This allows us to declare these fields as non-null\n+knowing they will be properly assigned either by the constructor (not shown) or by hibernate loading data from the\n+database.\n+\n+NOTE: Note that these types differ from the Java types mentioned in those tutorials.  For kotlin support, all the Panache\n+types will be found in the `io.quarkus.hibernate.orm.panache.kotlin` package.  This subpackage allows for the distinction\n+between the Java and Kotlin variants and allows for both to be used unambiguously in a single project.\n+\n+In the Kotlin version, we've simply moved the bulk of the link:https://www.martinfowler.com/eaaCatalog/activeRecord.html[`entity pattern`]\n+functionality to the `companion object`.  Apart from this slight change, we can then work with our types in ways that map easily\n+from the Java side of world.\n+\n+\n+== Using the repository pattern\n+\n+\n+=== Defining your entity\n+\n+When using the repository pattern, you can define your entities as regular JPA entities.\n+[source,kotlin]\n+----\n+@Entity\n+class Person {\n+    @Id\n+    @GeneratedValue\n+    var id: Long? = null;\n+    lateinit var name: String\n+    lateinit var birth: LocalDate\n+    lateinit var status: Status\n+}\n+----\n+\n+=== Defining your repository\n+\n+When using Repositories, you get the exact same convenient methods as with the active record pattern, injected in your Repository,\n+by making them implement `PanacheRepository`:\n+\n+[source,kotlin]\n+----\n+class PersonRepository: PanacheRepository<Person> {\n+     fun findByName(name: String) = find(\"name\", name).firstResult()\n+     fun findAlive() = list(\"status\", Status.Alive)\n+     fun deleteStefs() = delete(\"name\", \"Stef\")\n+}\n+----\n+\n+All the operations that are defined on `PanacheEntityBase` are available on your repository, so using it\n+is exactly the same as using the active record pattern, except you need to inject it:\n+\n+[source,kotlin]\n+----\n+@Inject\n+lateinit var personRepository: PersonRepository\n+\n+@GET\n+fun count() = personRepository.count()\n+----\n+\n+=== Most useful operations\n+\n+Once you have written your repository, here are the most common operations you will be able to perform:\n+\n+[source,kotlin]\n+----\n+// creating a person\n+var person: Person? = Person()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0ab2195f2834e5217dd0178a88e612b5470f24a"}, "originalPosition": 118}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63fd5222c0e8dee7feabc9c1de793a45c6368b18", "author": {"user": null}, "url": "https://github.com/quarkusio/quarkus/commit/63fd5222c0e8dee7feabc9c1de793a45c6368b18", "committedDate": "2020-06-01T18:52:18Z", "message": "add a guide for the kotlin specific bits\nunparameterize the ID type on PanacheEntityBase to match the java side"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ed497aea20f62a0956ba893ce9a278f1c1b4f93e", "author": {"user": null}, "url": "https://github.com/quarkusio/quarkus/commit/ed497aea20f62a0956ba893ce9a278f1c1b4f93e", "committedDate": "2020-05-28T14:04:16Z", "message": "remove stray letter"}, "afterCommit": {"oid": "63fd5222c0e8dee7feabc9c1de793a45c6368b18", "author": {"user": null}, "url": "https://github.com/quarkusio/quarkus/commit/63fd5222c0e8dee7feabc9c1de793a45c6368b18", "committedDate": "2020-06-01T18:52:18Z", "message": "add a guide for the kotlin specific bits\nunparameterize the ID type on PanacheEntityBase to match the java side"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMDk5MTM1", "url": "https://github.com/quarkusio/quarkus/pull/9611#pullrequestreview-422099135", "createdAt": "2020-06-01T18:56:26Z", "commit": {"oid": "63fd5222c0e8dee7feabc9c1de793a45c6368b18"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNDkzOTUx", "url": "https://github.com/quarkusio/quarkus/pull/9611#pullrequestreview-422493951", "createdAt": "2020-06-02T09:18:33Z", "commit": {"oid": "63fd5222c0e8dee7feabc9c1de793a45c6368b18"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3213, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}