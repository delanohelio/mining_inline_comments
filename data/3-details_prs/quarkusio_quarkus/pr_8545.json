{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAyNTE1MDI1", "number": 8545, "title": "Hibernate ORM Multitenancy", "bodyText": "Fixes #5681", "createdAt": "2020-04-13T07:30:57Z", "url": "https://github.com/quarkusio/quarkus/pull/8545", "merged": true, "mergeCommit": {"oid": "87522320380e9f201a2f4c027f3e50bc1ffd6f06"}, "closed": true, "closedAt": "2020-05-17T20:31:43Z", "author": {"login": "michael-schnell"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcbJlN3AFqTM5NTU1MTMwNA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABciRNxQAFqTQxMzE5NTUwMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NTUxMzA0", "url": "https://github.com/quarkusio/quarkus/pull/8545#pullrequestreview-395551304", "createdAt": "2020-04-17T15:24:50Z", "commit": {"oid": "a24a32087d6f107eb5fe4fff8f757a1baf928850"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNToyNDo1MFrOGHSgfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNTozMjo0NlrOGHSzjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI5NjQ0NA==", "bodyText": "Great example! thanks a lot", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r410296444", "createdAt": "2020-04-17T15:24:50Z", "author": {"login": "Sanne"}, "path": "docs/src/main/asciidoc/hibernate-orm.adoc", "diffHunk": "@@ -542,3 +542,216 @@ Datasource configuration is extremely simple, but is covered in a different guid\n it's implemented by the Agroal connection pool extension for Quarkus.\n \n Jump over to link:datasource[Quarkus - Datasources] for all details.\n+\n+== Multitenancy\n+\n+\"The term multitenancy, in general, is applied to software development to indicate an architecture in which a single running instance of an application simultaneously serves multiple clients (tenants). This is highly common in SaaS solutions. Isolating information (data, customizations, etc.) pertaining to the various tenants is a particular challenge in these systems. This includes the data owned by each tenant stored in the database\" (link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy[Hibernate User Guide]).\n+\n+Quarkus currently supports the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-database[separate database] and the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-schema[separate schema] approach. \n+\n+=== Writing the application\n+\n+Let's start by implementing the `/{tenant}` endpoint. As you can see from the source code below it is just a regular JAX-RS resource:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24a32087d6f107eb5fe4fff8f757a1baf928850"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI5NjY0NA==", "bodyText": "Shouldn't this have a @Transactional as well?", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r410296644", "createdAt": "2020-04-17T15:25:09Z", "author": {"login": "Sanne"}, "path": "docs/src/main/asciidoc/hibernate-orm.adoc", "diffHunk": "@@ -542,3 +542,216 @@ Datasource configuration is extremely simple, but is covered in a different guid\n it's implemented by the Agroal connection pool extension for Quarkus.\n \n Jump over to link:datasource[Quarkus - Datasources] for all details.\n+\n+== Multitenancy\n+\n+\"The term multitenancy, in general, is applied to software development to indicate an architecture in which a single running instance of an application simultaneously serves multiple clients (tenants). This is highly common in SaaS solutions. Isolating information (data, customizations, etc.) pertaining to the various tenants is a particular challenge in these systems. This includes the data owned by each tenant stored in the database\" (link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy[Hibernate User Guide]).\n+\n+Quarkus currently supports the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-database[separate database] and the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-schema[separate schema] approach. \n+\n+=== Writing the application\n+\n+Let's start by implementing the `/{tenant}` endpoint. As you can see from the source code below it is just a regular JAX-RS resource:\n+\n+[source,java]\n+----\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.persistence.EntityManager;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+\n+@ApplicationScoped\n+@Produces(\"application/json\")\n+@Consumes(\"application/json\")\n+@Path(\"/{tenant}\")\n+public class FruitResource {\n+\n+    @Inject\n+    EntityManager entityManager;\n+\n+    @GET\n+    @Path(\"fruits\")\n+    public Fruit[] getFruits() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24a32087d6f107eb5fe4fff8f757a1baf928850"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMwMDg4MA==", "bodyText": "I'm not sure about exposing the RoutingContext component on the TenantResolver API. Do we possibly have better alternatives? Ideally something that could directly take the /{tenant} variable from the @Path annotation on the endpoint?\n@FroMage as someone knowing well both Hibernate , REST and vertx.. maybe you have a better idea of how this should look like?", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r410300880", "createdAt": "2020-04-17T15:32:03Z", "author": {"login": "Sanne"}, "path": "docs/src/main/asciidoc/hibernate-orm.adoc", "diffHunk": "@@ -542,3 +542,216 @@ Datasource configuration is extremely simple, but is covered in a different guid\n it's implemented by the Agroal connection pool extension for Quarkus.\n \n Jump over to link:datasource[Quarkus - Datasources] for all details.\n+\n+== Multitenancy\n+\n+\"The term multitenancy, in general, is applied to software development to indicate an architecture in which a single running instance of an application simultaneously serves multiple clients (tenants). This is highly common in SaaS solutions. Isolating information (data, customizations, etc.) pertaining to the various tenants is a particular challenge in these systems. This includes the data owned by each tenant stored in the database\" (link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy[Hibernate User Guide]).\n+\n+Quarkus currently supports the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-database[separate database] and the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-schema[separate schema] approach. \n+\n+=== Writing the application\n+\n+Let's start by implementing the `/{tenant}` endpoint. As you can see from the source code below it is just a regular JAX-RS resource:\n+\n+[source,java]\n+----\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.persistence.EntityManager;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+\n+@ApplicationScoped\n+@Produces(\"application/json\")\n+@Consumes(\"application/json\")\n+@Path(\"/{tenant}\")\n+public class FruitResource {\n+\n+    @Inject\n+    EntityManager entityManager;\n+\n+    @GET\n+    @Path(\"fruits\")\n+    public Fruit[] getFruits() {\n+        return entityManager.createNamedQuery(\"Fruits.findAll\", Fruit.class)\n+                .getResultList().toArray(new Fruit[0]);\n+    }\n+    \n+}\n+----\n+\n+In order to resolve the tenant from incoming requests and map it to a specific tenant configuration, you need to create an implementation for the `io.quarkus.hibernate.orm.runtime.tenant.TenantResolver` interface.\n+\n+[source,java]\n+----\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.Unremovable;\n+import io.quarkus.hibernate.orm.runtime.tenant.TenantResolver;\n+import io.vertx.ext.web.RoutingContext;\n+\n+@ApplicationScoped\n+@Unremovable\n+public class CustomTenantResolver implements TenantResolver {\n+\n+    @Override\n+    public String getDefaultHibernateOrmTenantId() {\n+        return \"base\";\n+    }\n+    \n+    @Override\n+    public String resolveHibernateOrmTenantId(RoutingContext context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24a32087d6f107eb5fe4fff8f757a1baf928850"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMwMTMyNA==", "bodyText": "(it especially bothers me that the user code needs to validate/split/parse the request path again)", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r410301324", "createdAt": "2020-04-17T15:32:46Z", "author": {"login": "Sanne"}, "path": "docs/src/main/asciidoc/hibernate-orm.adoc", "diffHunk": "@@ -542,3 +542,216 @@ Datasource configuration is extremely simple, but is covered in a different guid\n it's implemented by the Agroal connection pool extension for Quarkus.\n \n Jump over to link:datasource[Quarkus - Datasources] for all details.\n+\n+== Multitenancy\n+\n+\"The term multitenancy, in general, is applied to software development to indicate an architecture in which a single running instance of an application simultaneously serves multiple clients (tenants). This is highly common in SaaS solutions. Isolating information (data, customizations, etc.) pertaining to the various tenants is a particular challenge in these systems. This includes the data owned by each tenant stored in the database\" (link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy[Hibernate User Guide]).\n+\n+Quarkus currently supports the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-database[separate database] and the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-schema[separate schema] approach. \n+\n+=== Writing the application\n+\n+Let's start by implementing the `/{tenant}` endpoint. As you can see from the source code below it is just a regular JAX-RS resource:\n+\n+[source,java]\n+----\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.persistence.EntityManager;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+\n+@ApplicationScoped\n+@Produces(\"application/json\")\n+@Consumes(\"application/json\")\n+@Path(\"/{tenant}\")\n+public class FruitResource {\n+\n+    @Inject\n+    EntityManager entityManager;\n+\n+    @GET\n+    @Path(\"fruits\")\n+    public Fruit[] getFruits() {\n+        return entityManager.createNamedQuery(\"Fruits.findAll\", Fruit.class)\n+                .getResultList().toArray(new Fruit[0]);\n+    }\n+    \n+}\n+----\n+\n+In order to resolve the tenant from incoming requests and map it to a specific tenant configuration, you need to create an implementation for the `io.quarkus.hibernate.orm.runtime.tenant.TenantResolver` interface.\n+\n+[source,java]\n+----\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.Unremovable;\n+import io.quarkus.hibernate.orm.runtime.tenant.TenantResolver;\n+import io.vertx.ext.web.RoutingContext;\n+\n+@ApplicationScoped\n+@Unremovable\n+public class CustomTenantResolver implements TenantResolver {\n+\n+    @Override\n+    public String getDefaultHibernateOrmTenantId() {\n+        return \"base\";\n+    }\n+    \n+    @Override\n+    public String resolveHibernateOrmTenantId(RoutingContext context) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMwMDg4MA=="}, "originalCommit": {"oid": "a24a32087d6f107eb5fe4fff8f757a1baf928850"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwOTQxOTE3", "url": "https://github.com/quarkusio/quarkus/pull/8545#pullrequestreview-400941917", "createdAt": "2020-04-27T13:18:19Z", "commit": {"oid": "a24a32087d6f107eb5fe4fff8f757a1baf928850"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzoxODoxOVrOGMiszw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzoxODoxOVrOGMiszw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgwNDYyMw==", "bodyText": "I'm not eager to require a dependency on the vertx module: it needs to be possible to use the Hibernate ORM extension even in an application which doesn't have any web endpoint.\nI think there's some options:\n\nExpose a different type, something like TenantId, or MultitenancyContext, and leave it to the developer to have a bean which performs the conversion - possibly making it easy such as having a CDI Factory.\nMove your TenantResolver approach into a dedicated module / extension\nMake sure that TenantResolver is one way out of several options - making the binding to the VertX module optional.\n\nI suppose we can mix these approaches; for example my favourite is 1# in terms of clean design, but you could have a default factory (2#) provided for user's convenience. This could initially like in this same module (3#) and later be broken out as a future improvement.\nOr maybe you have a better idea?", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r415804623", "createdAt": "2020-04-27T13:18:19Z", "author": {"login": "Sanne"}, "path": "docs/src/main/asciidoc/hibernate-orm.adoc", "diffHunk": "@@ -542,3 +542,216 @@ Datasource configuration is extremely simple, but is covered in a different guid\n it's implemented by the Agroal connection pool extension for Quarkus.\n \n Jump over to link:datasource[Quarkus - Datasources] for all details.\n+\n+== Multitenancy\n+\n+\"The term multitenancy, in general, is applied to software development to indicate an architecture in which a single running instance of an application simultaneously serves multiple clients (tenants). This is highly common in SaaS solutions. Isolating information (data, customizations, etc.) pertaining to the various tenants is a particular challenge in these systems. This includes the data owned by each tenant stored in the database\" (link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy[Hibernate User Guide]).\n+\n+Quarkus currently supports the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-database[separate database] and the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-schema[separate schema] approach. \n+\n+=== Writing the application\n+\n+Let's start by implementing the `/{tenant}` endpoint. As you can see from the source code below it is just a regular JAX-RS resource:\n+\n+[source,java]\n+----\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.persistence.EntityManager;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+\n+@ApplicationScoped\n+@Produces(\"application/json\")\n+@Consumes(\"application/json\")\n+@Path(\"/{tenant}\")\n+public class FruitResource {\n+\n+    @Inject\n+    EntityManager entityManager;\n+\n+    @GET\n+    @Path(\"fruits\")\n+    public Fruit[] getFruits() {\n+        return entityManager.createNamedQuery(\"Fruits.findAll\", Fruit.class)\n+                .getResultList().toArray(new Fruit[0]);\n+    }\n+    \n+}\n+----\n+\n+In order to resolve the tenant from incoming requests and map it to a specific tenant configuration, you need to create an implementation for the `io.quarkus.hibernate.orm.runtime.tenant.TenantResolver` interface.\n+\n+[source,java]\n+----\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.Unremovable;\n+import io.quarkus.hibernate.orm.runtime.tenant.TenantResolver;\n+import io.vertx.ext.web.RoutingContext;\n+\n+@ApplicationScoped\n+@Unremovable\n+public class CustomTenantResolver implements TenantResolver {\n+\n+    @Override\n+    public String getDefaultHibernateOrmTenantId() {\n+        return \"base\";\n+    }\n+    \n+    @Override\n+    public String resolveHibernateOrmTenantId(RoutingContext context) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDMwMDg4MA=="}, "originalCommit": {"oid": "a24a32087d6f107eb5fe4fff8f757a1baf928850"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwOTcyNjMy", "url": "https://github.com/quarkusio/quarkus/pull/8545#pullrequestreview-400972632", "createdAt": "2020-04-27T13:52:21Z", "commit": {"oid": "a24a32087d6f107eb5fe4fff8f757a1baf928850"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzo1MjoyMVrOGMkT6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzo1MjoyMVrOGMkT6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMTAxNg==", "bodyText": "Resolving the reference to the right TenantResolver via Arc is not necessary and actually a problem as we want to be able to start multiple instances of Hibernate ORM, which could be configured differently.\nYou should be able to simply inject the HibernateCurrentTenantIdentifierResolver instance into the ORM configuration; for example this should work:\nconfiguration.put( org.hibernate.cfg.AvailableSettings.MULTI_TENANT_IDENTIFIER_RESOLVER, new HibernateCurrentTenantIdentifierResolver( tenantResolver ) );\n\nThis way you can store the tenant into a final field, properly and simply initialized in its constructor.", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r415831016", "createdAt": "2020-04-27T13:52:21Z", "author": {"login": "Sanne"}, "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/tenant/HibernateCurrentTenantIdentifierResolver.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package io.quarkus.hibernate.orm.runtime.tenant;\n+\n+import org.hibernate.context.spi.CurrentTenantIdentifierResolver;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.hibernate.orm.runtime.JPAConfig;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Maps from the Quarkus {@link TenantResolver} to the Hibernate {@link CurrentTenantIdentifierResolver} model.\n+ * \n+ * @author Michael Schnell\n+ *\n+ */\n+public class HibernateCurrentTenantIdentifierResolver implements CurrentTenantIdentifierResolver {\n+\n+    private static final Logger LOG = Logger.getLogger(HibernateCurrentTenantIdentifierResolver.class);\n+\n+    @Override\n+    public String resolveCurrentTenantIdentifier() {\n+\n+        TenantResolver resolver = tenantResolver();\n+\n+        // Make sure that we're in a request or return default tenant\n+        if (!Arc.container().requestContext().isActive()) {\n+            return resolver.getDefaultHibernateOrmTenantId();\n+        }\n+\n+        RoutingContext routingContext = routingContext();\n+        String tenantId = resolver.resolveHibernateOrmTenantId(routingContext);\n+        if (tenantId == null) {\n+            throw new IllegalStateException(\"Method 'CurrentTenantIdentifierResolver.\"\n+                    + \"resolveHibernateOrmTenantId(RoutingContext)' returned a null value. \"\n+                    + \"Unfortunately Hibernate ORM does not allow null for tenant identifiers. \"\n+                    + \"Please use a non-null value!\");\n+        }\n+        LOG.debugv(\"resolveCurrentTenantIdentifier(): {0}\", tenantId);\n+        return tenantId;\n+\n+    }\n+\n+    @Override\n+    public boolean validateExistingCurrentSessions() {\n+        return jpaConfig().isValidateTenantInCurrentSessions();\n+    }\n+\n+    /**\n+     * Returns the singleton JPA configuration instance.\n+     * \n+     * @return JPA configuration.\n+     */\n+    private static JPAConfig jpaConfig() {\n+        InstanceHandle<JPAConfig> jpaConfigInstance = Arc.container().instance(JPAConfig.class);\n+        if (!jpaConfigInstance.isAvailable()) {\n+            throw new IllegalStateException(\"No instance of JPAConfig found\");\n+        }\n+        return jpaConfigInstance.get();\n+    }\n+\n+    /**\n+     * Retrieves the routing context or fails if it is not available.\n+     * \n+     * @return Current routing context.\n+     */\n+    private static RoutingContext routingContext() {\n+        InstanceHandle<RoutingContext> routingContextInstance = Arc.container().instance(RoutingContext.class);\n+        if (!routingContextInstance.isAvailable()) {\n+            throw new IllegalStateException(\"No instance of \" + RoutingContext.class.getName() + \" was found.\");\n+        }\n+        return routingContextInstance.get();\n+    }\n+\n+    /**\n+     * Retrieves the tenant resolver or fails if it is not available.\n+     * \n+     * @return Current tenant resolver.\n+     */\n+    private static TenantResolver tenantResolver() {\n+        InstanceHandle<TenantResolver> resolverInstance = Arc.container().instance(TenantResolver.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a24a32087d6f107eb5fe4fff8f757a1baf928850"}, "originalPosition": 81}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwMjMxNzE3", "url": "https://github.com/quarkusio/quarkus/pull/8545#pullrequestreview-410231717", "createdAt": "2020-05-12T16:46:13Z", "commit": {"oid": "280564264ba45877df7d15ad285cc1caf588b73d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjo0NjoxM1rOGUPs4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNzo0MToxMFrOGUR0VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MTk1Mw==", "bodyText": "Returning null here is illegal. Is this were you plan to use getDefaultTenantId() ?\nPerhaps an runtime exception is more suited?", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423881953", "createdAt": "2020-05-12T16:46:13Z", "author": {"login": "Sanne"}, "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/tenant/HibernateCurrentTenantIdentifierResolver.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package io.quarkus.hibernate.orm.runtime.tenant;\n+\n+import org.hibernate.context.spi.CurrentTenantIdentifierResolver;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.hibernate.orm.runtime.JPAConfig;\n+\n+/**\n+ * Maps from the Quarkus {@link TenantResolver} to the Hibernate {@link CurrentTenantIdentifierResolver} model.\n+ * \n+ * @author Michael Schnell\n+ *\n+ */\n+public class HibernateCurrentTenantIdentifierResolver implements CurrentTenantIdentifierResolver {\n+\n+    private static final Logger LOG = Logger.getLogger(HibernateCurrentTenantIdentifierResolver.class);\n+\n+    private final JPAConfig jpaConfig;\n+\n+    public HibernateCurrentTenantIdentifierResolver(final JPAConfig jpaConfig) {\n+        super();\n+        this.jpaConfig = jpaConfig;\n+    }\n+\n+    @Override\n+    public String resolveCurrentTenantIdentifier() {\n+\n+        // Make sure that we're in a request\n+        if (!Arc.container().requestContext().isActive()) {\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "280564264ba45877df7d15ad285cc1caf588b73d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4Mzk0Ng==", "bodyText": "It seems this is the only use for the jpaConfig object. Does this stricly need some lazy initialization, or could you read the field earlier and store only an immutable boolean field rather than keeping a reference to the bootstrap proxy?", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423883946", "createdAt": "2020-05-12T16:49:16Z", "author": {"login": "Sanne"}, "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/tenant/HibernateCurrentTenantIdentifierResolver.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package io.quarkus.hibernate.orm.runtime.tenant;\n+\n+import org.hibernate.context.spi.CurrentTenantIdentifierResolver;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.hibernate.orm.runtime.JPAConfig;\n+\n+/**\n+ * Maps from the Quarkus {@link TenantResolver} to the Hibernate {@link CurrentTenantIdentifierResolver} model.\n+ * \n+ * @author Michael Schnell\n+ *\n+ */\n+public class HibernateCurrentTenantIdentifierResolver implements CurrentTenantIdentifierResolver {\n+\n+    private static final Logger LOG = Logger.getLogger(HibernateCurrentTenantIdentifierResolver.class);\n+\n+    private final JPAConfig jpaConfig;\n+\n+    public HibernateCurrentTenantIdentifierResolver(final JPAConfig jpaConfig) {\n+        super();\n+        this.jpaConfig = jpaConfig;\n+    }\n+\n+    @Override\n+    public String resolveCurrentTenantIdentifier() {\n+\n+        // Make sure that we're in a request\n+        if (!Arc.container().requestContext().isActive()) {\n+            return null;\n+        }\n+\n+        TenantResolver resolver = tenantResolver();\n+        String tenantId = resolver.resolveTenantId();\n+        if (tenantId == null) {\n+            throw new IllegalStateException(\"Method 'TenantResolver.resolveTenantId()' returned a null value. \"\n+                    + \"Unfortunately Hibernate ORM does not allow null for tenant identifiers. \"\n+                    + \"Please use a non-null value!\");\n+        }\n+        LOG.debugv(\"resolveCurrentTenantIdentifier(): {0}\", tenantId);\n+        return tenantId;\n+\n+    }\n+\n+    @Override\n+    public boolean validateExistingCurrentSessions() {\n+        return jpaConfig.isValidateTenantInCurrentSessions();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "280564264ba45877df7d15ad285cc1caf588b73d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4NDYzNQ==", "bodyText": "this should be safe to remove; we generally don't use Serialization, and when we do we prefer to not declare serial version ids as constants.", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423884635", "createdAt": "2020-05-12T16:50:11Z", "author": {"login": "Sanne"}, "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/tenant/HibernateMultiTenantConnectionProvider.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package io.quarkus.hibernate.orm.runtime.tenant;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.hibernate.engine.jdbc.connections.spi.AbstractMultiTenantConnectionProvider;\n+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+\n+/**\n+ * Maps from the Quarkus {@link TenantConnectionResolver} to the {@link HibernateMultiTenantConnectionProvider} model.\n+ * \n+ * @author Michael Schnell\n+ *\n+ */\n+public class HibernateMultiTenantConnectionProvider extends AbstractMultiTenantConnectionProvider {\n+\n+    private static final long serialVersionUID = 1L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "280564264ba45877df7d15ad285cc1caf588b73d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5MDcwOA==", "bodyText": "Why is this static ? Let's try to avoid that, especially as this Service doesn't have any stop/destroy facility.\nFYI there's the option to implement org.hibernate.service.spi.Stoppable if you need a callback, but I believe removing the static should be done as well.", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423890708", "createdAt": "2020-05-12T16:59:12Z", "author": {"login": "Sanne"}, "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/tenant/HibernateMultiTenantConnectionProvider.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package io.quarkus.hibernate.orm.runtime.tenant;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.hibernate.engine.jdbc.connections.spi.AbstractMultiTenantConnectionProvider;\n+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+\n+/**\n+ * Maps from the Quarkus {@link TenantConnectionResolver} to the {@link HibernateMultiTenantConnectionProvider} model.\n+ * \n+ * @author Michael Schnell\n+ *\n+ */\n+public class HibernateMultiTenantConnectionProvider extends AbstractMultiTenantConnectionProvider {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private static final Logger LOG = Logger.getLogger(HibernateMultiTenantConnectionProvider.class);\n+\n+    private static final Map<String, ConnectionProvider> PROVIDER_MAP = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "280564264ba45877df7d15ad285cc1caf588b73d"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5Mzg5MQ==", "bodyText": "I'd prefer if you could use an \"old fashioned get\" here first, only falling back to a computeIfAbsent operation if your local cache doesn't have it so to avoid contention in the implementation of ConcurrentHashMap#computeIfAbsent since there is no need to have contention.", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423893891", "createdAt": "2020-05-12T17:04:24Z", "author": {"login": "Sanne"}, "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/tenant/HibernateMultiTenantConnectionProvider.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package io.quarkus.hibernate.orm.runtime.tenant;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.hibernate.engine.jdbc.connections.spi.AbstractMultiTenantConnectionProvider;\n+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+\n+/**\n+ * Maps from the Quarkus {@link TenantConnectionResolver} to the {@link HibernateMultiTenantConnectionProvider} model.\n+ * \n+ * @author Michael Schnell\n+ *\n+ */\n+public class HibernateMultiTenantConnectionProvider extends AbstractMultiTenantConnectionProvider {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private static final Logger LOG = Logger.getLogger(HibernateMultiTenantConnectionProvider.class);\n+\n+    private static final Map<String, ConnectionProvider> PROVIDER_MAP = new ConcurrentHashMap<>();\n+\n+    @Override\n+    protected ConnectionProvider getAnyConnectionProvider() {\n+        String tenantId = tenantResolver().getDefaultTenantId();\n+        if (tenantId == null) {\n+            throw new IllegalStateException(\"Method 'TenantResolver.getDefaultTenantId()' returned a null value. \"\n+                    + \"This violates the contract of the interface!\");\n+        }\n+        return selectConnectionProvider(tenantId);\n+    }\n+\n+    @Override\n+    protected ConnectionProvider selectConnectionProvider(String tenantIdentifier) {\n+        LOG.debugv(\"selectConnectionProvider({0})\", tenantIdentifier);\n+\n+        return PROVIDER_MAP.computeIfAbsent(tenantIdentifier, tid -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "280564264ba45877df7d15ad285cc1caf588b73d"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5OTMyMA==", "bodyText": "I'm wondering if it wouldn't be better to refrain from exposing this option. AFAIR Quarkus we don't expose org.hibernate.context.spi.CurrentSessionContext, which makes this check useless?\nI'd prefer to omit this, as less is more - especially when it's easy to add things, but never easy to remove something.\nAlso, removing this configuration option would resolve a couple more comments I had :)", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423899320", "createdAt": "2020-05-12T17:13:08Z", "author": {"login": "Sanne"}, "path": "extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmConfig.java", "diffHunk": "@@ -101,6 +101,33 @@\n     @ConfigItem\n     Optional<String> implicitNamingStrategy;\n \n+    /**\n+     * Defines the method for multi-tenancy (DATABASE, NONE, SCHEMA). The complete list of allowed values is available in the\n+     * https://docs.jboss.org/hibernate/stable/orm/javadocs/org/hibernate/MultiTenancyStrategy.html[Hibernate ORM JavaDoc].\n+     * The type DISCRIMINATOR is currently not supported.\n+     *\n+     * @asciidoclet\n+     */\n+    @ConfigItem\n+    public Optional<String> multitenant;\n+\n+    /**\n+     * Defines the name of the data source to use in case of SCHEMA approach. The default data source will be used if not set.\n+     *\n+     * @asciidoclet\n+     */\n+    @ConfigItem\n+    public Optional<String> multitenantSchemaDatasource;\n+\n+    /**\n+     * Defines if the tenant identifier of the \"current sessions\" should be validated every time the tenant identifier is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "280564264ba45877df7d15ad285cc1caf588b73d"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg5OTYwMw==", "bodyText": "Could you also clarify that NONE is the default?", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423899603", "createdAt": "2020-05-12T17:13:35Z", "author": {"login": "Sanne"}, "path": "extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmConfig.java", "diffHunk": "@@ -101,6 +101,33 @@\n     @ConfigItem\n     Optional<String> implicitNamingStrategy;\n \n+    /**\n+     * Defines the method for multi-tenancy (DATABASE, NONE, SCHEMA). The complete list of allowed values is available in the\n+     * https://docs.jboss.org/hibernate/stable/orm/javadocs/org/hibernate/MultiTenancyStrategy.html[Hibernate ORM JavaDoc].\n+     * The type DISCRIMINATOR is currently not supported.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "280564264ba45877df7d15ad285cc1caf588b73d"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwNjY1NQ==", "bodyText": "Could you avoid registering this bean as \"unremovable\" when multitenancy is not being used?", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423906655", "createdAt": "2020-05-12T17:25:09Z", "author": {"login": "Sanne"}, "path": "extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java", "diffHunk": "@@ -405,7 +417,7 @@ void registerBeans(BuildProducer<AdditionalBeanBuildItem> additionalBeans, Combi\n \n         additionalBeans.produce(AdditionalBeanBuildItem.builder().setUnremovable()\n                 .addBeanClasses(JPAConfig.class, TransactionEntityManagers.class,\n-                        RequestScopedEntityManagerHolder.class)\n+                        RequestScopedEntityManagerHolder.class, DataSourceTenantConnectionResolver.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "280564264ba45877df7d15ad285cc1caf588b73d"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkxMDQ2OA==", "bodyText": "So assuming I set it to \"schema\" approach, why would I ever want to set this to a different value than what I'm configuring Hiberante ORM to use in the database.defaultSchema setting?\nI would prefer to imply (and enforce) a reasonable default rather than exposing another configuration option. Unless I'm missing something of course.", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423910468", "createdAt": "2020-05-12T17:31:19Z", "author": {"login": "Sanne"}, "path": "extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmConfig.java", "diffHunk": "@@ -101,6 +101,33 @@\n     @ConfigItem\n     Optional<String> implicitNamingStrategy;\n \n+    /**\n+     * Defines the method for multi-tenancy (DATABASE, NONE, SCHEMA). The complete list of allowed values is available in the\n+     * https://docs.jboss.org/hibernate/stable/orm/javadocs/org/hibernate/MultiTenancyStrategy.html[Hibernate ORM JavaDoc].\n+     * The type DISCRIMINATOR is currently not supported.\n+     *\n+     * @asciidoclet\n+     */\n+    @ConfigItem\n+    public Optional<String> multitenant;\n+\n+    /**\n+     * Defines the name of the data source to use in case of SCHEMA approach. The default data source will be used if not set.\n+     *\n+     * @asciidoclet\n+     */\n+    @ConfigItem\n+    public Optional<String> multitenantSchemaDatasource;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "280564264ba45877df7d15ad285cc1caf588b73d"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkxNjYyOA==", "bodyText": "you're suggesting that the interface exists, but not how one creates one. Should it suggest also that we'll look for a CDI bean having such an interface?", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r423916628", "createdAt": "2020-05-12T17:41:10Z", "author": {"login": "Sanne"}, "path": "docs/src/main/asciidoc/hibernate-orm.adoc", "diffHunk": "@@ -542,3 +542,219 @@ Datasource configuration is extremely simple, but is covered in a different guid\n it's implemented by the Agroal connection pool extension for Quarkus.\n \n Jump over to link:datasource[Quarkus - Datasources] for all details.\n+\n+== Multitenancy\n+\n+\"The term multitenancy, in general, is applied to software development to indicate an architecture in which a single running instance of an application simultaneously serves multiple clients (tenants). This is highly common in SaaS solutions. Isolating information (data, customizations, etc.) pertaining to the various tenants is a particular challenge in these systems. This includes the data owned by each tenant stored in the database\" (link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy[Hibernate User Guide]).\n+\n+Quarkus currently supports the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-database[separate database] and the link:https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-schema[separate schema] approach. \n+\n+=== Writing the application\n+\n+Let's start by implementing the `/{tenant}` endpoint. As you can see from the source code below it is just a regular JAX-RS resource:\n+\n+[source,java]\n+----\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.persistence.EntityManager;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+\n+@ApplicationScoped\n+@Produces(\"application/json\")\n+@Consumes(\"application/json\")\n+@Path(\"/{tenant}\")\n+public class FruitResource {\n+\n+    @Inject\n+    EntityManager entityManager;\n+\n+    @GET\n+    @Path(\"fruits\")\n+    public Fruit[] getFruits() {\n+        return entityManager.createNamedQuery(\"Fruits.findAll\", Fruit.class)\n+                .getResultList().toArray(new Fruit[0]);\n+    }\n+    \n+}\n+----\n+\n+In order to resolve the tenant from incoming requests and map it to a specific tenant configuration, you need to create an implementation for the `io.quarkus.hibernate.orm.runtime.tenant.TenantResolver` interface.\n+\n+[source,java]\n+----\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.Unremovable;\n+import io.quarkus.hibernate.orm.runtime.tenant.TenantResolver;\n+import io.vertx.ext.web.RoutingContext;\n+\n+@@RequestScoped\n+@Unremovable\n+public class CustomTenantResolver implements TenantResolver {\n+\n+    @Inject\n+    RoutingContext context;\n+\n+    @Override\n+    public String getDefaultTenantId() {\n+        return \"base\";\n+    }\n+    \n+    @Override\n+    public String resolveTenantId() {\n+        String path = context.request().path();\n+        String[] parts = path.split(\"/\");\n+\n+        if (parts.length == 0) {\n+            // resolve to default tenant config\n+            return getDefaultTenantId();\n+        }\n+\n+        return parts[1];\n+    }\n+    \n+}\n+----\n+\n+From the implementation above, tenants are resolved from the request path so that in case no tenant could be inferred, the default tenant identifier is returned.\n+\n+=== Configuring the application\n+\n+In general it is not possible to use the Hibernate ORM database generation feature in conjunction with a multitenancy setup.\n+Therefore you have to disable it and you need to make sure that the tables are created per schema. \n+The following setup will use the link:https://quarkus.io/guides/flyway[Flyway] extension to achieve this goal.\n+\n+==== SCHEMA approach\n+\n+The same data source will be used for all tenants and a schema has to be created for every tenant inside that data source. \n+\n+[source,properties]\n+----\n+# Disable generation\n+quarkus.hibernate-orm.database.generation=none\n+\n+# Enable SCHEMA approach and use default schema\n+quarkus.hibernate-orm.multitenant=SCHEMA\n+# You could use a non-default schema by using the following setting \n+# quarkus.hibernate-orm.multitenant-schema-datasource=other\n+\n+# The default data source used for all tenant schemas\n+quarkus.datasource.db-kind=postgresql\n+quarkus.datasource.username=quarkus_test\n+quarkus.datasource.password=quarkus_test\n+quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/quarkus_test\n+\n+# Enable Flyway configuration to create schemas\n+quarkus.flyway.schemas=base,mycompany\n+quarkus.flyway.locations=classpath:schema\n+quarkus.flyway.migrate-at-start=true\n+----\n+\n+Here is an example of the Flyway SQL (`V1.0.0__create_fruits.sql`) to be created in the configured folder `src/main/resources/schema`.\n+\n+[source,sql]\n+----\n+CREATE SEQUENCE base.known_fruits_id_seq;\n+SELECT setval('base.\"known_fruits_id_seq\"', 3);\n+CREATE TABLE base.known_fruits\n+(\n+  id   INT,\n+  name VARCHAR(40)\n+);\n+INSERT INTO base.known_fruits(id, name) VALUES (1, 'Cherry');\n+INSERT INTO base.known_fruits(id, name) VALUES (2, 'Apple');\n+INSERT INTO base.known_fruits(id, name) VALUES (3, 'Banana');\n+\n+CREATE SEQUENCE mycompany.known_fruits_id_seq;\n+SELECT setval('mycompany.\"known_fruits_id_seq\"', 3);\n+CREATE TABLE mycompany.known_fruits\n+(\n+  id   INT,\n+  name VARCHAR(40)\n+);\n+INSERT INTO mycompany.known_fruits(id, name) VALUES (1, 'Avocado');\n+INSERT INTO mycompany.known_fruits(id, name) VALUES (2, 'Apricots');\n+INSERT INTO mycompany.known_fruits(id, name) VALUES (3, 'Blackberries');\n+----\n+\n+\n+\n+==== DATABASE approach\n+\n+For every tenant you need to create a named data source with the same identifier that is returned by the `TenantResolver`. \n+\n+[source,properties]\n+----\n+# Disable generation\n+quarkus.hibernate-orm.database.generation=none\n+\n+# Enable DATABASE approach\n+quarkus.hibernate-orm.multitenant=DATABASE\n+\n+# Default tenant 'base'\n+quarkus.datasource.base.db-kind=postgresql\n+quarkus.datasource.base.username=quarkus_test\n+quarkus.datasource.base.password=quarkus_test\n+quarkus.datasource.base.jdbc.url=jdbc:postgresql://localhost:5432/quarkus_test\n+\n+# Tenant 'mycompany'\n+quarkus.datasource.mycompany.db-kind=postgresql\n+quarkus.datasource.mycompany.username=mycompany\n+quarkus.datasource.mycompany.password=mycompany\n+quarkus.datasource.mycompany.jdbc.url=jdbc:postgresql://localhost:5433/mycompany\n+\n+# Flyway configuration for the default datasource\n+quarkus.flyway.locations=classpath:database/default\n+quarkus.flyway.migrate-at-start=true\n+\n+# Flyway configuration for the mycompany datasource\n+quarkus.flyway.mycompany.locations=classpath:database/mycompany\n+quarkus.flyway.mycompany.migrate-at-start=true\n+----\n+\n+Following are examples of the Flyway SQL files to be created in the configured folder `src/main/resources/database`.\n+\n+Default schema (`src/main/resources/database/default/V1.0.0__create_fruits.sql`):\n+\n+[source,sql]\n+----\n+CREATE SEQUENCE known_fruits_id_seq;\n+SELECT setval('known_fruits_id_seq', 3);\n+CREATE TABLE known_fruits\n+(\n+  id   INT,\n+  name VARCHAR(40)\n+);\n+INSERT INTO known_fruits(id, name) VALUES (1, 'Cherry');\n+INSERT INTO known_fruits(id, name) VALUES (2, 'Apple');\n+INSERT INTO known_fruits(id, name) VALUES (3, 'Banana');\n+----\n+\n+Mycompany schema (`src/main/resources/database/mycompany/V1.0.0__create_fruits.sql`):\n+\n+[source,sql]\n+----\n+CREATE SEQUENCE known_fruits_id_seq;\n+SELECT setval('known_fruits_id_seq', 3);\n+CREATE TABLE known_fruits\n+(\n+  id   INT,\n+  name VARCHAR(40)\n+);\n+INSERT INTO known_fruits(id, name) VALUES (1, 'Avocado');\n+INSERT INTO known_fruits(id, name) VALUES (2, 'Apricots');\n+INSERT INTO known_fruits(id, name) VALUES (3, 'Blackberries');\n+----\n+\n+=== Programmatically Resolving Tenants Connections\n+\n+If you need a more dynamic configuration for the different tenants you want to support and don't want to end up with multiple\n+entries in your configuration file, you can use the `io.quarkus.hibernate.orm.runtime.tenant.TenantConnectionResolver`.\n+\n+This interface allows you to dynamically create tenant connections at runtime.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "280564264ba45877df7d15ad285cc1caf588b73d"}, "originalPosition": 218}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24b81ab92d3d927cc666dc2685d803188015aa3a", "author": {"user": {"login": "michael-schnell", "name": "Michael Schnell"}}, "url": "https://github.com/quarkusio/quarkus/commit/24b81ab92d3d927cc666dc2685d803188015aa3a", "committedDate": "2020-05-17T07:15:01Z", "message": "Hibernate ORM Multitenancy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMTk0MDE3", "url": "https://github.com/quarkusio/quarkus/pull/8545#pullrequestreview-413194017", "createdAt": "2020-05-17T20:03:12Z", "commit": {"oid": "24b81ab92d3d927cc666dc2685d803188015aa3a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QyMDowMzoxMlrOGWjPEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xN1QyMDowMzoxMlrOGWjPEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI5OTE1Mw==", "bodyText": "this property no longer exists", "url": "https://github.com/quarkusio/quarkus/pull/8545#discussion_r426299153", "createdAt": "2020-05-17T20:03:12Z", "author": {"login": "Sanne"}, "path": "integration-tests/hibernate-tenancy/src/main/resources/application.properties", "diffHunk": "@@ -0,0 +1,38 @@\n+# Hibernate ORM settings \n+quarkus.hibernate-orm.database.generation=none\n+quarkus.hibernate-orm.multitenant=DATABASE\n+quarkus.hibernate-orm.validate-tenant-in-current-sessions=false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24b81ab92d3d927cc666dc2685d803188015aa3a"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMTk1NTAx", "url": "https://github.com/quarkusio/quarkus/pull/8545#pullrequestreview-413195501", "createdAt": "2020-05-17T20:22:56Z", "commit": {"oid": "24b81ab92d3d927cc666dc2685d803188015aa3a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4557, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}