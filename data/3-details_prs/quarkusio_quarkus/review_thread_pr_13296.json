{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIxMDU5MDUx", "number": 13296, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNzoxNzowNVrOE9twYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNzoxNzowNVrOE9twYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMTQ4MjU4OnYy", "diffSide": "RIGHT", "path": "extensions/cache/runtime/src/main/java/io/quarkus/cache/CacheName.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNzoxNzowNVrOH6jRCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODoxMjozNlrOIDWygA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE1NzI1Ng==", "bodyText": "You allow it for methods here but you don't check the method case in the processor. Is it normal?", "url": "https://github.com/quarkusio/quarkus/pull/13296#discussion_r531157256", "createdAt": "2020-11-26T17:17:05Z", "author": {"login": "gsmet"}, "path": "extensions/cache/runtime/src/main/java/io/quarkus/cache/CacheName.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.cache;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import static java.lang.annotation.ElementType.PARAMETER;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import javax.enterprise.util.Nonbinding;\n+import javax.inject.Qualifier;\n+\n+/**\n+ * <p>\n+ * Use this annotation to inject a {@link Cache} and interact with it programmatically.\n+ * </p>\n+ * <p>\n+ * Code example:\n+ * \n+ * <pre>\n+ * {@literal @}ApplicationScoped\n+ * public class CachedService {\n+ * \n+ *     {@literal @}CacheName(\"my-cache\")\n+ *     Cache cache;\n+ *     \n+ *     // Interact with the cache.\n+ * }\n+ * </pre>\n+ * </p>\n+ * \n+ * @see CacheManager\n+ */\n+@Qualifier\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ FIELD, METHOD, PARAMETER })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35212e59210903193fdcdfd2b175c9e4d6977d08"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI5ODE1Mw==", "bodyText": "Good catch! It is allowed on methods because of CacheProducer but I should add a check in CacheProcessor to forbid the annotation on any other method than the one from the producer.", "url": "https://github.com/quarkusio/quarkus/pull/13296#discussion_r540298153", "createdAt": "2020-12-10T16:13:44Z", "author": {"login": "gwenneg"}, "path": "extensions/cache/runtime/src/main/java/io/quarkus/cache/CacheName.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.cache;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import static java.lang.annotation.ElementType.PARAMETER;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import javax.enterprise.util.Nonbinding;\n+import javax.inject.Qualifier;\n+\n+/**\n+ * <p>\n+ * Use this annotation to inject a {@link Cache} and interact with it programmatically.\n+ * </p>\n+ * <p>\n+ * Code example:\n+ * \n+ * <pre>\n+ * {@literal @}ApplicationScoped\n+ * public class CachedService {\n+ * \n+ *     {@literal @}CacheName(\"my-cache\")\n+ *     Cache cache;\n+ *     \n+ *     // Interact with the cache.\n+ * }\n+ * </pre>\n+ * </p>\n+ * \n+ * @see CacheManager\n+ */\n+@Qualifier\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ FIELD, METHOD, PARAMETER })", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE1NzI1Ng=="}, "originalCommit": {"oid": "35212e59210903193fdcdfd2b175c9e4d6977d08"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5MDAxNg==", "bodyText": "I made the following changes:\n\nrebase on master to fix conflicts\nnew check in CacheProcessor: @CacheName is now only allowed on methods from io.quarkus.cache.runtime.CacheProducer\ninjection tests coverage improvement\n\nDespite the targets of @CacheName and the new check, it is possible to inject a cache using that annotation at all CDI usual injections points: fields, constructors parameters and methods parameters. These are all tested in this PR.", "url": "https://github.com/quarkusio/quarkus/pull/13296#discussion_r540390016", "createdAt": "2020-12-10T18:12:36Z", "author": {"login": "gwenneg"}, "path": "extensions/cache/runtime/src/main/java/io/quarkus/cache/CacheName.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package io.quarkus.cache;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.METHOD;\n+import static java.lang.annotation.ElementType.PARAMETER;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import javax.enterprise.util.Nonbinding;\n+import javax.inject.Qualifier;\n+\n+/**\n+ * <p>\n+ * Use this annotation to inject a {@link Cache} and interact with it programmatically.\n+ * </p>\n+ * <p>\n+ * Code example:\n+ * \n+ * <pre>\n+ * {@literal @}ApplicationScoped\n+ * public class CachedService {\n+ * \n+ *     {@literal @}CacheName(\"my-cache\")\n+ *     Cache cache;\n+ *     \n+ *     // Interact with the cache.\n+ * }\n+ * </pre>\n+ * </p>\n+ * \n+ * @see CacheManager\n+ */\n+@Qualifier\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ FIELD, METHOD, PARAMETER })", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE1NzI1Ng=="}, "originalCommit": {"oid": "35212e59210903193fdcdfd2b175c9e4d6977d08"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3915, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}