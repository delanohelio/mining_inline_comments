{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk4MDExNzY3", "number": 12531, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwNjowNzoyN1rOEqk_jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwNjoxMDo0NVrOEqlCQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMDgxNzQzOnYy", "diffSide": "RIGHT", "path": "extensions/micrometer/deployment/src/main/java/io/quarkus/micrometer/deployment/binder/KafkaBinderProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwNjowNzoyN1rOHc3I5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMjoxMDo1OFrOHdDQNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNTU3Mw==", "bodyText": "Why is Vert.x mentioned here?", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500025573", "createdAt": "2020-10-06T06:07:27Z", "author": {"login": "cescoffier"}, "path": "extensions/micrometer/deployment/src/main/java/io/quarkus/micrometer/deployment/binder/KafkaBinderProcessor.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package io.quarkus.micrometer.deployment.binder;\n+\n+import java.util.function.BooleanSupplier;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.micrometer.runtime.MicrometerRecorder;\n+import io.quarkus.micrometer.runtime.config.MicrometerConfig;\n+\n+/**\n+ * Add support for Kafka Producer and Consumer instrumentation. Note that\n+ * various bits of support may not be present at deploy time. Avoid referencing\n+ * classes that in turn import optional dependencies.\n+ */\n+public class KafkaBinderProcessor {\n+    static final String KAFKA_CONSUMER_CLASS_NAME = \"org.apache.kafka.clients.consumer.Consumer\";\n+    static final Class<?> KAFKA_CONSUMER_CLASS_CLASS = MicrometerRecorder.getClassForName(KAFKA_CONSUMER_CLASS_NAME);\n+\n+    static final String KAFKA_EVENT_CONSUMER_CLASS_NAME = \"io.quarkus.micrometer.runtime.binder.kafka.KafkaEventObserver\";\n+\n+    static class KafkaSupportEnabled implements BooleanSupplier {\n+        MicrometerConfig mConfig;\n+\n+        public boolean getAsBoolean() {\n+            return KAFKA_CONSUMER_CLASS_CLASS != null && mConfig.checkBinderEnabledWithDefault(mConfig.binder.kafka);\n+        }\n+    }\n+\n+    @BuildStep(onlyIf = KafkaSupportEnabled.class)\n+    AdditionalBeanBuildItem createCDIEventConsumer() {\n+        // Add Vertx meter adapters", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIyNDA1NQ==", "bodyText": "copy/paste? =) Will fix.", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500224055", "createdAt": "2020-10-06T12:10:58Z", "author": {"login": "ebullient"}, "path": "extensions/micrometer/deployment/src/main/java/io/quarkus/micrometer/deployment/binder/KafkaBinderProcessor.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package io.quarkus.micrometer.deployment.binder;\n+\n+import java.util.function.BooleanSupplier;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.micrometer.runtime.MicrometerRecorder;\n+import io.quarkus.micrometer.runtime.config.MicrometerConfig;\n+\n+/**\n+ * Add support for Kafka Producer and Consumer instrumentation. Note that\n+ * various bits of support may not be present at deploy time. Avoid referencing\n+ * classes that in turn import optional dependencies.\n+ */\n+public class KafkaBinderProcessor {\n+    static final String KAFKA_CONSUMER_CLASS_NAME = \"org.apache.kafka.clients.consumer.Consumer\";\n+    static final Class<?> KAFKA_CONSUMER_CLASS_CLASS = MicrometerRecorder.getClassForName(KAFKA_CONSUMER_CLASS_NAME);\n+\n+    static final String KAFKA_EVENT_CONSUMER_CLASS_NAME = \"io.quarkus.micrometer.runtime.binder.kafka.KafkaEventObserver\";\n+\n+    static class KafkaSupportEnabled implements BooleanSupplier {\n+        MicrometerConfig mConfig;\n+\n+        public boolean getAsBoolean() {\n+            return KAFKA_CONSUMER_CLASS_CLASS != null && mConfig.checkBinderEnabledWithDefault(mConfig.binder.kafka);\n+        }\n+    }\n+\n+    @BuildStep(onlyIf = KafkaSupportEnabled.class)\n+    AdditionalBeanBuildItem createCDIEventConsumer() {\n+        // Add Vertx meter adapters", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNTU3Mw=="}, "originalCommit": {"oid": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMDgxOTIxOnYy", "diffSide": "RIGHT", "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwNjowODoyN1rOHc3J-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMjoxMDo1N1rOHdDQLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNTg1MQ==", "bodyText": "Should this be logged instead?", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500025851", "createdAt": "2020-10-06T06:08:27Z", "author": {"login": "cescoffier"}, "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.micrometer.runtime.binder.kafka;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.producer.Producer;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Metrics;\n+import io.micrometer.core.instrument.binder.kafka.KafkaClientMetrics;\n+\n+@ApplicationScoped\n+public class KafkaEventObserver {\n+    MeterRegistry registry = Metrics.globalRegistry;\n+    ConcurrentHashMap<Object, KafkaClientMetrics> clientMetrics = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Manage bind/close of KafkaClientMetrics for the specified Consumer.\n+     * If the consumer has not been seen before, it will be bound to the\n+     * Micrometer registry and instrumented using a Kafka MeterBinder.\n+     * If the consumer has been seen before, the MeterBinder will be closed.\n+     * \n+     * @param consumer Observed Kafka Consumer\n+     */\n+    public void consumerCreated(@Observes Consumer<?, ?> consumer) {\n+        KafkaClientMetrics prev = clientMetrics.remove(consumer);\n+        if (prev == null) {\n+            clientMetrics.computeIfAbsent(consumer, x -> {\n+                try {\n+                    KafkaClientMetrics metrics = new KafkaClientMetrics(consumer);\n+                    metrics.bindTo(registry);\n+                    return metrics;\n+                } catch (Throwable t) {\n+                    t.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIyNDA0NA==", "bodyText": "yes!", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500224044", "createdAt": "2020-10-06T12:10:57Z", "author": {"login": "ebullient"}, "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.micrometer.runtime.binder.kafka;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.producer.Producer;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Metrics;\n+import io.micrometer.core.instrument.binder.kafka.KafkaClientMetrics;\n+\n+@ApplicationScoped\n+public class KafkaEventObserver {\n+    MeterRegistry registry = Metrics.globalRegistry;\n+    ConcurrentHashMap<Object, KafkaClientMetrics> clientMetrics = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Manage bind/close of KafkaClientMetrics for the specified Consumer.\n+     * If the consumer has not been seen before, it will be bound to the\n+     * Micrometer registry and instrumented using a Kafka MeterBinder.\n+     * If the consumer has been seen before, the MeterBinder will be closed.\n+     * \n+     * @param consumer Observed Kafka Consumer\n+     */\n+    public void consumerCreated(@Observes Consumer<?, ?> consumer) {\n+        KafkaClientMetrics prev = clientMetrics.remove(consumer);\n+        if (prev == null) {\n+            clientMetrics.computeIfAbsent(consumer, x -> {\n+                try {\n+                    KafkaClientMetrics metrics = new KafkaClientMetrics(consumer);\n+                    metrics.bindTo(registry);\n+                    return metrics;\n+                } catch (Throwable t) {\n+                    t.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNTg1MQ=="}, "originalCommit": {"oid": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMDgyMjY5OnYy", "diffSide": "RIGHT", "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwNjoxMDowM1rOHc3MCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMjoxNToyN1rOHdDang==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNjM3Nw==", "bodyText": "Why do you remove it and then computeIfAbsent? Do you expect concurrent access? If I'm not sure it works.", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500026377", "createdAt": "2020-10-06T06:10:03Z", "author": {"login": "cescoffier"}, "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.micrometer.runtime.binder.kafka;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.producer.Producer;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Metrics;\n+import io.micrometer.core.instrument.binder.kafka.KafkaClientMetrics;\n+\n+@ApplicationScoped\n+public class KafkaEventObserver {\n+    MeterRegistry registry = Metrics.globalRegistry;\n+    ConcurrentHashMap<Object, KafkaClientMetrics> clientMetrics = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Manage bind/close of KafkaClientMetrics for the specified Consumer.\n+     * If the consumer has not been seen before, it will be bound to the\n+     * Micrometer registry and instrumented using a Kafka MeterBinder.\n+     * If the consumer has been seen before, the MeterBinder will be closed.\n+     * \n+     * @param consumer Observed Kafka Consumer\n+     */\n+    public void consumerCreated(@Observes Consumer<?, ?> consumer) {\n+        KafkaClientMetrics prev = clientMetrics.remove(consumer);\n+        if (prev == null) {\n+            clientMetrics.computeIfAbsent(consumer, x -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNjUyMw==", "bodyText": "it might be safer to just synchronized the whole method.", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500026523", "createdAt": "2020-10-06T06:10:30Z", "author": {"login": "cescoffier"}, "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.micrometer.runtime.binder.kafka;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.producer.Producer;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Metrics;\n+import io.micrometer.core.instrument.binder.kafka.KafkaClientMetrics;\n+\n+@ApplicationScoped\n+public class KafkaEventObserver {\n+    MeterRegistry registry = Metrics.globalRegistry;\n+    ConcurrentHashMap<Object, KafkaClientMetrics> clientMetrics = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Manage bind/close of KafkaClientMetrics for the specified Consumer.\n+     * If the consumer has not been seen before, it will be bound to the\n+     * Micrometer registry and instrumented using a Kafka MeterBinder.\n+     * If the consumer has been seen before, the MeterBinder will be closed.\n+     * \n+     * @param consumer Observed Kafka Consumer\n+     */\n+    public void consumerCreated(@Observes Consumer<?, ?> consumer) {\n+        KafkaClientMetrics prev = clientMetrics.remove(consumer);\n+        if (prev == null) {\n+            clientMetrics.computeIfAbsent(consumer, x -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNjM3Nw=="}, "originalCommit": {"oid": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIyNjcxOA==", "bodyText": "I can change that. I like computeIfAbsent as an atomic operation (personal bias), but I can see that it is confusing.", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500226718", "createdAt": "2020-10-06T12:15:27Z", "author": {"login": "ebullient"}, "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.micrometer.runtime.binder.kafka;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.producer.Producer;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Metrics;\n+import io.micrometer.core.instrument.binder.kafka.KafkaClientMetrics;\n+\n+@ApplicationScoped\n+public class KafkaEventObserver {\n+    MeterRegistry registry = Metrics.globalRegistry;\n+    ConcurrentHashMap<Object, KafkaClientMetrics> clientMetrics = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Manage bind/close of KafkaClientMetrics for the specified Consumer.\n+     * If the consumer has not been seen before, it will be bound to the\n+     * Micrometer registry and instrumented using a Kafka MeterBinder.\n+     * If the consumer has been seen before, the MeterBinder will be closed.\n+     * \n+     * @param consumer Observed Kafka Consumer\n+     */\n+    public void consumerCreated(@Observes Consumer<?, ?> consumer) {\n+        KafkaClientMetrics prev = clientMetrics.remove(consumer);\n+        if (prev == null) {\n+            clientMetrics.computeIfAbsent(consumer, x -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNjM3Nw=="}, "originalCommit": {"oid": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMDgyNDM1OnYy", "diffSide": "RIGHT", "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwNjoxMDo0NVrOHc3M_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwNjoxMDo0NVrOHc3M_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNjYyMA==", "bodyText": "Same comment", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500026620", "createdAt": "2020-10-06T06:10:45Z", "author": {"login": "cescoffier"}, "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.micrometer.runtime.binder.kafka;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.producer.Producer;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Metrics;\n+import io.micrometer.core.instrument.binder.kafka.KafkaClientMetrics;\n+\n+@ApplicationScoped\n+public class KafkaEventObserver {\n+    MeterRegistry registry = Metrics.globalRegistry;\n+    ConcurrentHashMap<Object, KafkaClientMetrics> clientMetrics = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Manage bind/close of KafkaClientMetrics for the specified Consumer.\n+     * If the consumer has not been seen before, it will be bound to the\n+     * Micrometer registry and instrumented using a Kafka MeterBinder.\n+     * If the consumer has been seen before, the MeterBinder will be closed.\n+     * \n+     * @param consumer Observed Kafka Consumer\n+     */\n+    public void consumerCreated(@Observes Consumer<?, ?> consumer) {\n+        KafkaClientMetrics prev = clientMetrics.remove(consumer);\n+        if (prev == null) {\n+            clientMetrics.computeIfAbsent(consumer, x -> {\n+                try {\n+                    KafkaClientMetrics metrics = new KafkaClientMetrics(consumer);\n+                    metrics.bindTo(registry);\n+                    return metrics;\n+                } catch (Throwable t) {\n+                    t.printStackTrace();\n+                    return null;\n+                }\n+            });\n+        } else {\n+            prev.close();\n+        }\n+    }\n+\n+    /**\n+     * Manage bind/close of KafkaClientMetrics for the specified Producer.\n+     * If the producer has not been seen before, it will be bound to the\n+     * Micrometer registry and instrumented using a Kafka MeterBinder.\n+     * If the producer has been seen before, the MeterBinder will be closed.\n+     * \n+     * @param producer Observed Kafka Producer\n+     */\n+    public void producerCreated(@Observes Producer<?, ?> producer) {\n+        KafkaClientMetrics prev = clientMetrics.remove(producer);\n+        if (prev == null) {\n+            clientMetrics.computeIfAbsent(producer, x -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b"}, "originalPosition": 57}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4363, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}