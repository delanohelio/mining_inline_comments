{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3MDU1MTcz", "number": 6782, "title": "Allow multiple caching annotations on a single method", "bodyText": "Fixes #6682\n\nAll AugmentedCache* classes have been replaced with a much simpler code using CacheInterceptorBinding and CacheInterceptor.\nIt is now possible to combine multiple caching annotations on a single method. The operations order will always be the same: CacheInvalidateAll first, then CacheInvalidate and finally CacheResult.\nUsing a combination of @CacheInvalidate and @CacheResult on a method is equivalent to the old @CacheStore annotation that existed at the beginning of this extension development.\nThe only restriction is a one @CacheResult annotation limit per method. Everything else is allowed in terms of annotations combination and/or caches involved in a single method.", "createdAt": "2020-01-24T23:30:04Z", "url": "https://github.com/quarkusio/quarkus/pull/6782", "merged": true, "mergeCommit": {"oid": "749b3ac6bdcae87d09f464fdf07c3d7f29c095aa"}, "closed": true, "closedAt": "2020-02-05T10:40:06Z", "author": {"login": "gwenneg"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb9nvHOABqjI5Nzg5MTIyMTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcBTvJbAFqTM1MzYxNjkzMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5d92776592c3b71adbbba7d2b9ec41deaab92ffb", "author": {"user": {"login": "gwenneg", "name": "Gwenneg Lepage"}}, "url": "https://github.com/quarkusio/quarkus/commit/5d92776592c3b71adbbba7d2b9ec41deaab92ffb", "committedDate": "2020-01-24T23:25:48Z", "message": "Allow multiple caching annotations on a single method"}, "afterCommit": {"oid": "d821a6b75de5efd5ffe49b514db0b988f7dbf1de", "author": {"user": {"login": "gwenneg", "name": "Gwenneg Lepage"}}, "url": "https://github.com/quarkusio/quarkus/commit/d821a6b75de5efd5ffe49b514db0b988f7dbf1de", "committedDate": "2020-01-24T23:41:25Z", "message": "Allow multiple caching annotations on a single method"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d821a6b75de5efd5ffe49b514db0b988f7dbf1de", "author": {"user": {"login": "gwenneg", "name": "Gwenneg Lepage"}}, "url": "https://github.com/quarkusio/quarkus/commit/d821a6b75de5efd5ffe49b514db0b988f7dbf1de", "committedDate": "2020-01-24T23:41:25Z", "message": "Allow multiple caching annotations on a single method"}, "afterCommit": {"oid": "172dd52342871e41f617273ef48b409e4e0fda9e", "author": {"user": {"login": "gwenneg", "name": "Gwenneg Lepage"}}, "url": "https://github.com/quarkusio/quarkus/commit/172dd52342871e41f617273ef48b409e4e0fda9e", "committedDate": "2020-01-25T00:01:04Z", "message": "Allow multiple caching annotations on a single method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5NzEwNzc0", "url": "https://github.com/quarkusio/quarkus/pull/6782#pullrequestreview-349710774", "createdAt": "2020-01-28T21:19:30Z", "commit": {"oid": "172dd52342871e41f617273ef48b409e4e0fda9e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMToxOTozMFrOFi082g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMToxOTozMFrOFi082g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA2MzQ1MA==", "bodyText": "Name it List to match the same pattern used in other places (including Bean validation)", "url": "https://github.com/quarkusio/quarkus/pull/6782#discussion_r372063450", "createdAt": "2020-01-28T21:19:30Z", "author": {"login": "gastaldi"}, "path": "extensions/cache/runtime/src/main/java/io/quarkus/cache/CacheInvalidate.java", "diffHunk": "@@ -1,31 +1,43 @@\n package io.quarkus.cache;\n \n import java.lang.annotation.ElementType;\n+import java.lang.annotation.Repeatable;\n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n import java.lang.annotation.Target;\n \n import javax.enterprise.util.Nonbinding;\n \n+import io.quarkus.cache.CacheInvalidate.CacheInvalidateContainer;\n+\n /**\n  * When a method annotated with {@link CacheInvalidate} is invoked, Quarkus will compute a cache key and use it to try to\n  * remove an existing entry from the cache. If the method has one or more arguments, the key computation is done from all the\n  * method arguments if none of them is annotated with {@link CacheKey}, or all the arguments annotated with {@link CacheKey}\n  * otherwise. This annotation can also be used on a method with no arguments, a default key derived from the cache name is\n  * generated in that case. If the key does not identify any cache entry, nothing will happen.\n  * <p>\n- * You can only use one of the cache operations (and this annotation) on a given method: {@link CacheResult},\n- * {@link CacheInvalidate} or {@link CacheInvalidateAll}.\n+ * This annotation can be combined with multiple other caching annotations on a single method. Caching operations will always\n+ * be executed in the same order: {@link CacheInvalidateAll} first, then {@link CacheInvalidate} and finally\n+ * {@link CacheResult}.\n  * <p>\n  * The underlying caching provider can be chosen and configured in the Quarkus {@link application.properties} file.\n  */\n-@Retention(value = RetentionPolicy.RUNTIME)\n+@Retention(RetentionPolicy.RUNTIME)\n @Target(ElementType.METHOD)\n+@Repeatable(CacheInvalidateContainer.class)\n public @interface CacheInvalidate {\n \n     /**\n      * The name of the cache.\n      */\n     @Nonbinding\n     String cacheName();\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.METHOD)\n+    @interface CacheInvalidateContainer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "172dd52342871e41f617273ef48b409e4e0fda9e"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5NzExMDgw", "url": "https://github.com/quarkusio/quarkus/pull/6782#pullrequestreview-349711080", "createdAt": "2020-01-28T21:19:59Z", "commit": {"oid": "172dd52342871e41f617273ef48b409e4e0fda9e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMToyMDowMFrOFi09sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMToyMDowMFrOFi09sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA2MzY2Nw==", "bodyText": "Same here", "url": "https://github.com/quarkusio/quarkus/pull/6782#discussion_r372063667", "createdAt": "2020-01-28T21:20:00Z", "author": {"login": "gastaldi"}, "path": "extensions/cache/runtime/src/main/java/io/quarkus/cache/CacheInvalidateAll.java", "diffHunk": "@@ -1,27 +1,39 @@\n package io.quarkus.cache;\n \n import java.lang.annotation.ElementType;\n+import java.lang.annotation.Repeatable;\n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n import java.lang.annotation.Target;\n \n import javax.enterprise.util.Nonbinding;\n \n+import io.quarkus.cache.CacheInvalidateAll.CacheInvalidateAllContainer;\n+\n /**\n  * When a method annotated with {@link CacheInvalidateAll} is invoked, Quarkus will remove all entries from the cache.\n  * <p>\n- * You can only use one of the cache operations (and this annotation) on a given method: {@link CacheResult},\n- * {@link CacheInvalidate} or {@link CacheInvalidateAll}.\n+ * This annotation can be combined with multiple other caching annotations on a single method. Caching operations will always\n+ * be executed in the same order: {@link CacheInvalidateAll} first, then {@link CacheInvalidate} and finally\n+ * {@link CacheResult}.\n  * <p>\n  * The underlying caching provider can be chosen and configured in the Quarkus {@link application.properties} file.\n  */\n-@Retention(value = RetentionPolicy.RUNTIME)\n+@Retention(RetentionPolicy.RUNTIME)\n @Target(ElementType.METHOD)\n+@Repeatable(CacheInvalidateAllContainer.class)\n public @interface CacheInvalidateAll {\n \n     /**\n      * The name of the cache.\n      */\n     @Nonbinding\n     String cacheName();\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.METHOD)\n+    @interface CacheInvalidateAllContainer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "172dd52342871e41f617273ef48b409e4e0fda9e"}, "originalPosition": 38}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "172dd52342871e41f617273ef48b409e4e0fda9e", "author": {"user": {"login": "gwenneg", "name": "Gwenneg Lepage"}}, "url": "https://github.com/quarkusio/quarkus/commit/172dd52342871e41f617273ef48b409e4e0fda9e", "committedDate": "2020-01-25T00:01:04Z", "message": "Allow multiple caching annotations on a single method"}, "afterCommit": {"oid": "464b091cb5c03845b496287f72a007f921a4b1ce", "author": {"user": {"login": "gwenneg", "name": "Gwenneg Lepage"}}, "url": "https://github.com/quarkusio/quarkus/commit/464b091cb5c03845b496287f72a007f921a4b1ce", "committedDate": "2020-01-28T21:30:55Z", "message": "Allow multiple caching annotations on a single method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNDcyNDk0", "url": "https://github.com/quarkusio/quarkus/pull/6782#pullrequestreview-350472494", "createdAt": "2020-01-29T22:33:16Z", "commit": {"oid": "464b091cb5c03845b496287f72a007f921a4b1ce"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMjozMzoxNlrOFjZ39w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMjozMzo1MlrOFjZ45Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2ODQwNw==", "bodyText": "I wonder how efficient this code will be considering it will call declaredAnnotations() (which is a synchronized method) 3 times.", "url": "https://github.com/quarkusio/quarkus/pull/6782#discussion_r372668407", "createdAt": "2020-01-29T22:33:16Z", "author": {"login": "gsmet"}, "path": "extensions/cache/runtime/src/main/java/io/quarkus/cache/runtime/CacheInterceptor.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package io.quarkus.cache.runtime;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.annotation.Priority;\n+import javax.inject.Inject;\n+import javax.interceptor.AroundInvoke;\n+import javax.interceptor.Interceptor;\n+import javax.interceptor.InvocationContext;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.cache.CacheInvalidate;\n+import io.quarkus.cache.CacheInvalidateAll;\n+import io.quarkus.cache.CacheKey;\n+import io.quarkus.cache.CacheResult;\n+import io.quarkus.cache.runtime.caffeine.CaffeineCache;\n+\n+@CacheInterceptorBinding\n+@Interceptor\n+@Priority(PLATFORM_BEFORE)\n+public class CacheInterceptor {\n+\n+    private static final Logger LOGGER = Logger.getLogger(CacheInterceptor.class);\n+\n+    @Inject\n+    CacheRepository cacheRepository;\n+\n+    @AroundInvoke\n+    public Object intercept(InvocationContext context) throws Exception {\n+        Method method = context.getMethod();\n+\n+        for (CacheInvalidateAll cacheInvalidateAll : method.getDeclaredAnnotationsByType(CacheInvalidateAll.class)) {\n+            if (LOGGER.isDebugEnabled()) {\n+                LOGGER.debugf(\"Invalidating all entries from cache [%s]\", cacheInvalidateAll.cacheName());\n+            }\n+            CaffeineCache cache = cacheRepository.getCache(cacheInvalidateAll.cacheName());\n+            cache.invalidateAll();\n+        }\n+\n+        for (CacheInvalidate cacheInvalidate : method.getDeclaredAnnotationsByType(CacheInvalidate.class)) {\n+            Object key = getCacheKey(context, cacheInvalidate.cacheName());\n+            if (LOGGER.isDebugEnabled()) {\n+                LOGGER.debugf(\"Invalidating entry with key [%s] from cache [%s]\", key, cacheInvalidate.cacheName());\n+            }\n+            CaffeineCache cache = cacheRepository.getCache(cacheInvalidate.cacheName());\n+            cache.invalidate(key);\n+        }\n+\n+        CacheResult cacheResult = method.getDeclaredAnnotation(CacheResult.class);\n+        if (cacheResult != null) {\n+            Object key = getCacheKey(context, cacheResult.cacheName());\n+            if (LOGGER.isDebugEnabled()) {\n+                LOGGER.debugf(\"Loading entry with key [%s] from cache [%s]\", key, cacheResult.cacheName());\n+            }\n+            CaffeineCache cache = cacheRepository.getCache(cacheResult.cacheName());\n+            return cache.get(key, () -> context.proceed(), cacheResult.lockTimeout());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "464b091cb5c03845b496287f72a007f921a4b1ce"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2ODY0NQ==", "bodyText": "Same here, I'm pretty sure it will end up calling declaredAnnotations() again.", "url": "https://github.com/quarkusio/quarkus/pull/6782#discussion_r372668645", "createdAt": "2020-01-29T22:33:52Z", "author": {"login": "gsmet"}, "path": "extensions/cache/runtime/src/main/java/io/quarkus/cache/runtime/CacheInterceptor.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package io.quarkus.cache.runtime;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.annotation.Priority;\n+import javax.inject.Inject;\n+import javax.interceptor.AroundInvoke;\n+import javax.interceptor.Interceptor;\n+import javax.interceptor.InvocationContext;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.cache.CacheInvalidate;\n+import io.quarkus.cache.CacheInvalidateAll;\n+import io.quarkus.cache.CacheKey;\n+import io.quarkus.cache.CacheResult;\n+import io.quarkus.cache.runtime.caffeine.CaffeineCache;\n+\n+@CacheInterceptorBinding\n+@Interceptor\n+@Priority(PLATFORM_BEFORE)\n+public class CacheInterceptor {\n+\n+    private static final Logger LOGGER = Logger.getLogger(CacheInterceptor.class);\n+\n+    @Inject\n+    CacheRepository cacheRepository;\n+\n+    @AroundInvoke\n+    public Object intercept(InvocationContext context) throws Exception {\n+        Method method = context.getMethod();\n+\n+        for (CacheInvalidateAll cacheInvalidateAll : method.getDeclaredAnnotationsByType(CacheInvalidateAll.class)) {\n+            if (LOGGER.isDebugEnabled()) {\n+                LOGGER.debugf(\"Invalidating all entries from cache [%s]\", cacheInvalidateAll.cacheName());\n+            }\n+            CaffeineCache cache = cacheRepository.getCache(cacheInvalidateAll.cacheName());\n+            cache.invalidateAll();\n+        }\n+\n+        for (CacheInvalidate cacheInvalidate : method.getDeclaredAnnotationsByType(CacheInvalidate.class)) {\n+            Object key = getCacheKey(context, cacheInvalidate.cacheName());\n+            if (LOGGER.isDebugEnabled()) {\n+                LOGGER.debugf(\"Invalidating entry with key [%s] from cache [%s]\", key, cacheInvalidate.cacheName());\n+            }\n+            CaffeineCache cache = cacheRepository.getCache(cacheInvalidate.cacheName());\n+            cache.invalidate(key);\n+        }\n+\n+        CacheResult cacheResult = method.getDeclaredAnnotation(CacheResult.class);\n+        if (cacheResult != null) {\n+            Object key = getCacheKey(context, cacheResult.cacheName());\n+            if (LOGGER.isDebugEnabled()) {\n+                LOGGER.debugf(\"Loading entry with key [%s] from cache [%s]\", key, cacheResult.cacheName());\n+            }\n+            CaffeineCache cache = cacheRepository.getCache(cacheResult.cacheName());\n+            return cache.get(key, () -> context.proceed(), cacheResult.lockTimeout());\n+        }\n+\n+        return context.proceed();\n+    }\n+\n+    private Object getCacheKey(InvocationContext context, String cacheName) {\n+        // If the method doesn't have any parameter, then a unique default key is generated and used.\n+        if (context.getParameters().length == 0) {\n+            return CacheKeyBuilder.buildDefault(cacheName);\n+        } else {\n+            List<Object> cacheKeyElements = new ArrayList<>();\n+            // If at least one of the method parameters is annotated with @CacheKey, then the key is composed of all\n+            // @CacheKey-annotated parameters.\n+            for (int i = 0; i < context.getParameters().length; i++) {\n+                if (context.getMethod().getParameters()[i].isAnnotationPresent(CacheKey.class)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "464b091cb5c03845b496287f72a007f921a4b1ce"}, "originalPosition": 77}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "464b091cb5c03845b496287f72a007f921a4b1ce", "author": {"user": {"login": "gwenneg", "name": "Gwenneg Lepage"}}, "url": "https://github.com/quarkusio/quarkus/commit/464b091cb5c03845b496287f72a007f921a4b1ce", "committedDate": "2020-01-28T21:30:55Z", "message": "Allow multiple caching annotations on a single method"}, "afterCommit": {"oid": "d8dedfd57a58dcc7c6605d5afd0f7a0de86db97b", "author": {"user": {"login": "gwenneg", "name": "Gwenneg Lepage"}}, "url": "https://github.com/quarkusio/quarkus/commit/d8dedfd57a58dcc7c6605d5afd0f7a0de86db97b", "committedDate": "2020-01-30T03:50:02Z", "message": "Allow multiple caching annotations on a single method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNjM2OTYx", "url": "https://github.com/quarkusio/quarkus/pull/6782#pullrequestreview-350636961", "createdAt": "2020-01-30T08:05:21Z", "commit": {"oid": "ab7782f9b2eb59fc5281d483e0d13d294e998e90"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwODowNToyMVrOFjiL6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwODoxNjo1M1rOFjibwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgwNDU4Nw==", "bodyText": "I wonder if you need to mention that, do you think it helps the reader or is it just a remnent of the old implementation that you want to emphasize the change of?", "url": "https://github.com/quarkusio/quarkus/pull/6782#discussion_r372804587", "createdAt": "2020-01-30T08:05:21Z", "author": {"login": "emmanuelbernard"}, "path": "docs/src/main/asciidoc/cache.adoc", "diffHunk": "@@ -288,7 +288,8 @@ If the method has one or more arguments, the key computation is done from all th\n This annotation can also be used on a method with no arguments, a default key derived from the cache name is generated in that case.\n If the key does not identify any cache entry, nothing will happen.\n \n-You can only use one of the cache operations (and this annotation) on a given method: `@CacheResult`, `@CacheInvalidate` or `@CacheInvalidateAll`.\n+This annotation can be combined with multiple other caching annotations on a single method.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab7782f9b2eb59fc5281d483e0d13d294e998e90"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgwNDYxNg==", "bodyText": "same here", "url": "https://github.com/quarkusio/quarkus/pull/6782#discussion_r372804616", "createdAt": "2020-01-30T08:05:27Z", "author": {"login": "emmanuelbernard"}, "path": "docs/src/main/asciidoc/cache.adoc", "diffHunk": "@@ -299,7 +300,8 @@ If the `@CacheResult` or `@CacheInvalidate` annotations are used on a method wit\n \n When a method annotated with `@CacheInvalidateAll` is invoked, Quarkus will remove all entries from the cache.\n \n-You can only use one of the cache operations (and this annotation) on a given method: `@CacheResult`, `@CacheInvalidate` or `@CacheInvalidateAll`.\n+This annotation can be combined with multiple other caching annotations on a single method.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab7782f9b2eb59fc5281d483e0d13d294e998e90"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgwODAyOQ==", "bodyText": "So I'm a bit disappointed in the sense that witht he build time knowledge, we should be able to add an interceptor with the right state. We should know the annotations effectively present and even the cache name state and it should be burnt into the interceptor instance. I don't know how much of this is doable with the CDI model but that would be a nice improvement. Is that the conversation you had with @mkouba @gwenneg ?", "url": "https://github.com/quarkusio/quarkus/pull/6782#discussion_r372808029", "createdAt": "2020-01-30T08:15:25Z", "author": {"login": "emmanuelbernard"}, "path": "extensions/cache/runtime/src/main/java/io/quarkus/cache/runtime/CacheInterceptor.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package io.quarkus.cache.runtime;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.annotation.Priority;\n+import javax.inject.Inject;\n+import javax.interceptor.AroundInvoke;\n+import javax.interceptor.Interceptor;\n+import javax.interceptor.InvocationContext;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.cache.CacheInvalidate;\n+import io.quarkus.cache.CacheInvalidateAll;\n+import io.quarkus.cache.CacheKey;\n+import io.quarkus.cache.CacheResult;\n+import io.quarkus.cache.runtime.caffeine.CaffeineCache;\n+\n+@CacheInterceptorBinding\n+@Interceptor\n+@Priority(PLATFORM_BEFORE)\n+public class CacheInterceptor {\n+\n+    private static final Logger LOGGER = Logger.getLogger(CacheInterceptor.class);\n+\n+    @Inject\n+    CacheRepository cacheRepository;\n+\n+    @AroundInvoke\n+    public Object intercept(InvocationContext context) throws Exception {\n+        Method method = context.getMethod();\n+\n+        for (CacheInvalidateAll cacheInvalidateAll : method.getDeclaredAnnotationsByType(CacheInvalidateAll.class)) {\n+            if (LOGGER.isDebugEnabled()) {\n+                LOGGER.debugf(\"Invalidating all entries from cache [%s]\", cacheInvalidateAll.cacheName());\n+            }\n+            CaffeineCache cache = cacheRepository.getCache(cacheInvalidateAll.cacheName());\n+            cache.invalidateAll();\n+        }\n+\n+        for (CacheInvalidate cacheInvalidate : method.getDeclaredAnnotationsByType(CacheInvalidate.class)) {\n+            Object key = getCacheKey(context, cacheInvalidate.cacheName());\n+            if (LOGGER.isDebugEnabled()) {\n+                LOGGER.debugf(\"Invalidating entry with key [%s] from cache [%s]\", key, cacheInvalidate.cacheName());\n+            }\n+            CaffeineCache cache = cacheRepository.getCache(cacheInvalidate.cacheName());\n+            cache.invalidate(key);\n+        }\n+\n+        CacheResult cacheResult = method.getDeclaredAnnotation(CacheResult.class);\n+        if (cacheResult != null) {\n+            Object key = getCacheKey(context, cacheResult.cacheName());\n+            if (LOGGER.isDebugEnabled()) {\n+                LOGGER.debugf(\"Loading entry with key [%s] from cache [%s]\", key, cacheResult.cacheName());\n+            }\n+            CaffeineCache cache = cacheRepository.getCache(cacheResult.cacheName());\n+            return cache.get(key, () -> context.proceed(), cacheResult.lockTimeout());\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2ODQwNw=="}, "originalCommit": {"oid": "464b091cb5c03845b496287f72a007f921a4b1ce"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjgwODY0Mg==", "bodyText": "But as a temp measure, it looks like the synchronize call will only happen the first time the service class is requested its annotations. We could do this in a static_init block to do it at \"startup time\" if we feel its a problem to pay the cost lazily.", "url": "https://github.com/quarkusio/quarkus/pull/6782#discussion_r372808642", "createdAt": "2020-01-30T08:16:53Z", "author": {"login": "emmanuelbernard"}, "path": "extensions/cache/runtime/src/main/java/io/quarkus/cache/runtime/CacheInterceptor.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package io.quarkus.cache.runtime;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.annotation.Priority;\n+import javax.inject.Inject;\n+import javax.interceptor.AroundInvoke;\n+import javax.interceptor.Interceptor;\n+import javax.interceptor.InvocationContext;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.cache.CacheInvalidate;\n+import io.quarkus.cache.CacheInvalidateAll;\n+import io.quarkus.cache.CacheKey;\n+import io.quarkus.cache.CacheResult;\n+import io.quarkus.cache.runtime.caffeine.CaffeineCache;\n+\n+@CacheInterceptorBinding\n+@Interceptor\n+@Priority(PLATFORM_BEFORE)\n+public class CacheInterceptor {\n+\n+    private static final Logger LOGGER = Logger.getLogger(CacheInterceptor.class);\n+\n+    @Inject\n+    CacheRepository cacheRepository;\n+\n+    @AroundInvoke\n+    public Object intercept(InvocationContext context) throws Exception {\n+        Method method = context.getMethod();\n+\n+        for (CacheInvalidateAll cacheInvalidateAll : method.getDeclaredAnnotationsByType(CacheInvalidateAll.class)) {\n+            if (LOGGER.isDebugEnabled()) {\n+                LOGGER.debugf(\"Invalidating all entries from cache [%s]\", cacheInvalidateAll.cacheName());\n+            }\n+            CaffeineCache cache = cacheRepository.getCache(cacheInvalidateAll.cacheName());\n+            cache.invalidateAll();\n+        }\n+\n+        for (CacheInvalidate cacheInvalidate : method.getDeclaredAnnotationsByType(CacheInvalidate.class)) {\n+            Object key = getCacheKey(context, cacheInvalidate.cacheName());\n+            if (LOGGER.isDebugEnabled()) {\n+                LOGGER.debugf(\"Invalidating entry with key [%s] from cache [%s]\", key, cacheInvalidate.cacheName());\n+            }\n+            CaffeineCache cache = cacheRepository.getCache(cacheInvalidate.cacheName());\n+            cache.invalidate(key);\n+        }\n+\n+        CacheResult cacheResult = method.getDeclaredAnnotation(CacheResult.class);\n+        if (cacheResult != null) {\n+            Object key = getCacheKey(context, cacheResult.cacheName());\n+            if (LOGGER.isDebugEnabled()) {\n+                LOGGER.debugf(\"Loading entry with key [%s] from cache [%s]\", key, cacheResult.cacheName());\n+            }\n+            CaffeineCache cache = cacheRepository.getCache(cacheResult.cacheName());\n+            return cache.get(key, () -> context.proceed(), cacheResult.lockTimeout());\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2ODQwNw=="}, "originalCommit": {"oid": "464b091cb5c03845b496287f72a007f921a4b1ce"}, "originalPosition": 63}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ab7782f9b2eb59fc5281d483e0d13d294e998e90", "author": {"user": {"login": "gwenneg", "name": "Gwenneg Lepage"}}, "url": "https://github.com/quarkusio/quarkus/commit/ab7782f9b2eb59fc5281d483e0d13d294e998e90", "committedDate": "2020-01-30T06:16:13Z", "message": "Lower the number of times a cache key is built"}, "afterCommit": {"oid": "859c603171fe27074a45cdeda17a047f7accfd43", "author": {"user": {"login": "gwenneg", "name": "Gwenneg Lepage"}}, "url": "https://github.com/quarkusio/quarkus/commit/859c603171fe27074a45cdeda17a047f7accfd43", "committedDate": "2020-01-31T22:50:01Z", "message": "Allow multiple caching annotations on a single method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7fd77cc19de98463864468e4dbb245e417029a0", "author": {"user": {"login": "gwenneg", "name": "Gwenneg Lepage"}}, "url": "https://github.com/quarkusio/quarkus/commit/f7fd77cc19de98463864468e4dbb245e417029a0", "committedDate": "2020-01-31T23:02:18Z", "message": "Allow bytecode generation of short array annotations parameters"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "859c603171fe27074a45cdeda17a047f7accfd43", "author": {"user": {"login": "gwenneg", "name": "Gwenneg Lepage"}}, "url": "https://github.com/quarkusio/quarkus/commit/859c603171fe27074a45cdeda17a047f7accfd43", "committedDate": "2020-01-31T22:50:01Z", "message": "Allow multiple caching annotations on a single method"}, "afterCommit": {"oid": "d9fb15af9e154f12acb3cd3129270dc5520fd6bb", "author": {"user": {"login": "gwenneg", "name": "Gwenneg Lepage"}}, "url": "https://github.com/quarkusio/quarkus/commit/d9fb15af9e154f12acb3cd3129270dc5520fd6bb", "committedDate": "2020-01-31T23:04:04Z", "message": "Allow multiple caching annotations on a single method"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d9fb15af9e154f12acb3cd3129270dc5520fd6bb", "author": {"user": {"login": "gwenneg", "name": "Gwenneg Lepage"}}, "url": "https://github.com/quarkusio/quarkus/commit/d9fb15af9e154f12acb3cd3129270dc5520fd6bb", "committedDate": "2020-01-31T23:04:04Z", "message": "Allow multiple caching annotations on a single method"}, "afterCommit": {"oid": "4646a3d5c3777121d0d4028fb69f03ee8152f86e", "author": {"user": {"login": "gwenneg", "name": "Gwenneg Lepage"}}, "url": "https://github.com/quarkusio/quarkus/commit/4646a3d5c3777121d0d4028fb69f03ee8152f86e", "committedDate": "2020-01-31T23:30:21Z", "message": "Allow multiple caching annotations on a single method"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4646a3d5c3777121d0d4028fb69f03ee8152f86e", "author": {"user": {"login": "gwenneg", "name": "Gwenneg Lepage"}}, "url": "https://github.com/quarkusio/quarkus/commit/4646a3d5c3777121d0d4028fb69f03ee8152f86e", "committedDate": "2020-01-31T23:30:21Z", "message": "Allow multiple caching annotations on a single method"}, "afterCommit": {"oid": "1cfc35cbb53eefb88a3df1a9f5aadf9484e99407", "author": {"user": {"login": "gwenneg", "name": "Gwenneg Lepage"}}, "url": "https://github.com/quarkusio/quarkus/commit/1cfc35cbb53eefb88a3df1a9f5aadf9484e99407", "committedDate": "2020-02-01T20:40:06Z", "message": "Allow multiple caching annotations on a single method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "911f40fd404f10d32654b1e5def7370de80e4bcf", "author": {"user": {"login": "gwenneg", "name": "Gwenneg Lepage"}}, "url": "https://github.com/quarkusio/quarkus/commit/911f40fd404f10d32654b1e5def7370de80e4bcf", "committedDate": "2020-02-03T22:04:52Z", "message": "Allow multiple caching annotations on a single method"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1cfc35cbb53eefb88a3df1a9f5aadf9484e99407", "author": {"user": {"login": "gwenneg", "name": "Gwenneg Lepage"}}, "url": "https://github.com/quarkusio/quarkus/commit/1cfc35cbb53eefb88a3df1a9f5aadf9484e99407", "committedDate": "2020-02-01T20:40:06Z", "message": "Allow multiple caching annotations on a single method"}, "afterCommit": {"oid": "911f40fd404f10d32654b1e5def7370de80e4bcf", "author": {"user": {"login": "gwenneg", "name": "Gwenneg Lepage"}}, "url": "https://github.com/quarkusio/quarkus/commit/911f40fd404f10d32654b1e5def7370de80e4bcf", "committedDate": "2020-02-03T22:04:52Z", "message": "Allow multiple caching annotations on a single method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNjE2OTMy", "url": "https://github.com/quarkusio/quarkus/pull/6782#pullrequestreview-353616932", "createdAt": "2020-02-05T10:39:42Z", "commit": {"oid": "911f40fd404f10d32654b1e5def7370de80e4bcf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 147, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}