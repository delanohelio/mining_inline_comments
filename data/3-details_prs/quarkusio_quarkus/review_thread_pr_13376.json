{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzODc0MzQ5", "number": 13376, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDowNjo0MVrOFGG_Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDoxMjo1NVrOFGHKTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTUwMjcxOnYy", "diffSide": "RIGHT", "path": "core/runtime/src/main/java/io/quarkus/runtime/logging/CategoryBuildTimeConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDowNjo0MVrOIG9eeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDowNjo0MVrOIG9eeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE2OTU5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * The minimum log level level for this category.\n          \n          \n            \n                 * The minimum log level for this category.", "url": "https://github.com/quarkusio/quarkus/pull/13376#discussion_r544169593", "createdAt": "2020-12-16T10:06:41Z", "author": {"login": "gsmet"}, "path": "core/runtime/src/main/java/io/quarkus/runtime/logging/CategoryBuildTimeConfig.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package io.quarkus.runtime.logging;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+@ConfigGroup\n+public class CategoryBuildTimeConfig {\n+    /**\n+     * The minimum log level level for this category.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdfc43fcb3cd0ecdbc525ba9eb8efb69f267ed07"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTUwNjU5OnYy", "diffSide": "RIGHT", "path": "core/runtime/src/main/java/io/quarkus/runtime/logging/CategoryConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDowNzoyNlrOIG9gpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDowNzoyNlrOIG9gpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3MDE1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * The log level level for this category.\n          \n          \n            \n                 * The log level for this category.", "url": "https://github.com/quarkusio/quarkus/pull/13376#discussion_r544170150", "createdAt": "2020-12-16T10:07:26Z", "author": {"login": "gsmet"}, "path": "core/runtime/src/main/java/io/quarkus/runtime/logging/CategoryConfig.java", "diffHunk": "@@ -10,7 +10,10 @@\n public class CategoryConfig {\n \n     /**\n-     * The log level level for this category\n+     * The log level level for this category.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdfc43fcb3cd0ecdbc525ba9eb8efb69f267ed07"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTUxODEwOnYy", "diffSide": "RIGHT", "path": "core/deployment/src/main/java/io/quarkus/deployment/logging/LoggingResourceProcessor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDoxMDoyMVrOIG9n8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDoxMDoyMVrOIG9n8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3MjAxOQ==", "bodyText": "This requires a comment to explain why it's there?", "url": "https://github.com/quarkusio/quarkus/pull/13376#discussion_r544172019", "createdAt": "2020-12-16T10:10:21Z", "author": {"login": "gsmet"}, "path": "core/deployment/src/main/java/io/quarkus/deployment/logging/LoggingResourceProcessor.java", "diffHunk": "@@ -140,4 +166,177 @@ void registerMetrics(LogMetricsHandlerRecorder recorder, LogBuildTimeConfig log,\n             logHandler.produce(new LogHandlerBuildItem(recorder.getLogHandler()));\n         }\n     }\n+\n+    @BuildStep(onlyIf = NativeBuild.class)\n+    void setUpMinLevelLogging(LogBuildTimeConfig log,\n+            final BuildProducer<GeneratedClassBuildItem> generatedTraceLogger) {\n+        ClassOutput output = new GeneratedClassGizmoAdaptor(generatedTraceLogger, false);\n+        if (log.categories.isEmpty() || allMinLevelInfoOrHigher(log.categories)) {\n+            generateDefaultLoggers(output);\n+        } else {\n+            generateCategoryMinLevelLoggers(log.categories, log.minLevel, output);\n+        }\n+    }\n+\n+    private static boolean allMinLevelInfoOrHigher(Map<String, CategoryBuildTimeConfig> categories) {\n+        return categories.values().stream()\n+                .allMatch(categoryConfig -> categoryConfig.minLevel.getLevel().intValue() >= org.jboss.logmanager.Level.INFO\n+                        .intValue());\n+    }\n+\n+    private static void generateDefaultLoggers(ClassOutput output) {\n+        generateDefaultLoggingLogger(output);\n+        generateDefaultLoggerNode(output);\n+        generateLogManagerLogger(output, LoggingResourceProcessor::generateMinLevelDefault);\n+    }\n+\n+    private static void generateCategoryMinLevelLoggers(Map<String, CategoryBuildTimeConfig> categories, Level minLevel,\n+            ClassOutput output) {\n+        generateMinLevelCompute(categories, minLevel.toString(), output);\n+        generateDefaultLoggerNode(output);\n+        generateLogManagerLogger(output, LoggingResourceProcessor::generateMinLevelCheckCategory);\n+    }\n+\n+    private static BranchResult generateMinLevelCheckCategory(MethodCreator method, FieldDescriptor nameAliasDescriptor) {\n+        final ResultHandle levelIntValue = getParamLevelIntValue(method);\n+        final ResultHandle nameAlias = method.readInstanceField(nameAliasDescriptor, method.getThis());\n+        return method.ifTrue(method.invokeStaticMethod(IS_MIN_LEVEL_ENABLED, levelIntValue, nameAlias));\n+    }\n+\n+    private static void generateMinLevelCompute(Map<String, CategoryBuildTimeConfig> categories, String defaultMinLevelName,\n+            ClassOutput output) {\n+        try (ClassCreator cc = ClassCreator.builder().setFinal(true)\n+                .className(MIN_LEVEL_COMPUTE_CLASS_NAME)\n+                .classOutput(output).build()) {\n+\n+            try (MethodCreator mc = cc.getMethodCreator(IS_MIN_LEVEL_ENABLED)) {\n+                mc.setModifiers(Opcodes.ACC_STATIC);\n+\n+                final ResultHandle level = mc.getMethodParam(0);\n+                final ResultHandle name = mc.getMethodParam(1);\n+\n+                BytecodeCreator current = mc;\n+                for (Map.Entry<String, CategoryBuildTimeConfig> entry : categories.entrySet()) {\n+                    final String category = entry.getKey();\n+                    final int categoryLevelIntValue = entry.getValue().minLevel.getLevel().intValue();\n+\n+                    ResultHandle equalsResult = current.invokeVirtualMethod(\n+                            MethodDescriptor.ofMethod(Object.class, \"equals\", boolean.class, Object.class),\n+                            name, current.load(category));\n+\n+                    BranchResult equalsBranch = current.ifTrue(equalsResult);\n+                    try (BytecodeCreator false1 = equalsBranch.falseBranch()) {\n+                        ResultHandle startsWithResult = false1.invokeVirtualMethod(\n+                                MethodDescriptor.ofMethod(String.class, \"startsWith\", boolean.class, String.class),\n+                                name, false1.load(category));\n+\n+                        BranchResult startsWithBranch = false1.ifTrue(startsWithResult);\n+\n+                        final BytecodeCreator startsWithTrue = startsWithBranch.trueBranch();\n+                        final BranchResult levelCompareBranch = startsWithTrue.ifIntegerGreaterEqual(level,\n+                                startsWithTrue.load(categoryLevelIntValue));\n+                        levelCompareBranch.trueBranch().returnValue(levelCompareBranch.trueBranch().load(true));\n+                        levelCompareBranch.falseBranch().returnValue(levelCompareBranch.falseBranch().load(false));\n+\n+                        current = startsWithBranch.falseBranch();\n+                    }\n+\n+                    equalsBranch.trueBranch().returnValue(equalsBranch.trueBranch().load(true));\n+                }\n+\n+                final ResultHandle infoLevelIntValue = getLogManagerLevelIntValue(defaultMinLevelName, current);\n+                final BranchResult isInfoOrHigherBranch = current.ifIntegerGreaterEqual(level, infoLevelIntValue);\n+                isInfoOrHigherBranch.trueBranch().returnValue(isInfoOrHigherBranch.trueBranch().load(true));\n+                isInfoOrHigherBranch.falseBranch().returnValue(isInfoOrHigherBranch.falseBranch().load(false));\n+            }\n+        }\n+    }\n+\n+    private static void generateDefaultLoggerNode(ClassOutput output) {\n+        try (ClassCreator cc = ClassCreator.builder().setFinal(true)\n+                .className(LOGGER_NODE_CLASS_NAME)\n+                .classOutput(output).build()) {\n+\n+            AnnotationCreator targetClass = cc.addAnnotation(\"com.oracle.svm.core.annotate.TargetClass\");\n+            targetClass.addValue(\"className\", \"org.jboss.logmanager.LoggerNode\");\n+\n+            final MethodCreator isLoggableLevelMethod = cc.getMethodCreator(\"isLoggableLevel\", boolean.class, int.class);\n+            isLoggableLevelMethod.addAnnotation(\"com.oracle.svm.core.annotate.Alias\");\n+            isLoggableLevelMethod.returnValue(isLoggableLevelMethod.load(false));\n+        }\n+    }\n+\n+    private static void generateLogManagerLogger(ClassOutput output,\n+            BiFunction<MethodCreator, FieldDescriptor, BranchResult> isMinLevelEnabledFunction) {\n+        try (ClassCreator cc = ClassCreator.builder().setFinal(true)\n+                .className(LOGMANAGER_LOGGER_CLASS_NAME)\n+                .classOutput(output).build()) {\n+\n+            AnnotationCreator targetClass = cc.addAnnotation(\"com.oracle.svm.core.annotate.TargetClass\");\n+            targetClass.addValue(\"className\", \"org.jboss.logmanager.Logger\");\n+\n+            FieldCreator nameAlias = cc.getFieldCreator(\"name\", String.class);\n+            nameAlias.addAnnotation(\"com.oracle.svm.core.annotate.Alias\");\n+\n+            FieldCreator loggerNodeAlias = cc.getFieldCreator(\"loggerNode\", LOGGER_NODE_CLASS_NAME);\n+            loggerNodeAlias.addAnnotation(\"com.oracle.svm.core.annotate.Alias\");\n+\n+            final MethodCreator isLoggableMethod = cc.getMethodCreator(\"isLoggable\", boolean.class,\n+                    java.util.logging.Level.class);\n+            isLoggableMethod.addAnnotation(\"com.oracle.svm.core.annotate.Substitute\");\n+\n+            final ResultHandle levelIntValue = getParamLevelIntValue(isLoggableMethod);\n+\n+            final BranchResult levelBranch = isMinLevelEnabledFunction.apply(isLoggableMethod, nameAlias.getFieldDescriptor());\n+\n+            final BytecodeCreator levelTrue = levelBranch.trueBranch();\n+            levelTrue.returnValue(\n+                    levelTrue.invokeVirtualMethod(\n+                            MethodDescriptor.ofMethod(LOGGER_NODE_CLASS_NAME, \"isLoggableLevel\", boolean.class, int.class),\n+                            levelTrue.readInstanceField(loggerNodeAlias.getFieldDescriptor(), levelTrue.getThis()),\n+                            levelIntValue));\n+\n+            final BytecodeCreator levelFalse = levelBranch.falseBranch();\n+            levelFalse.returnValue(levelFalse.load(false));\n+        }\n+    }\n+\n+    private static ResultHandle getParamLevelIntValue(MethodCreator method) {\n+        final ResultHandle level = method.getMethodParam(0);\n+        return method\n+                .invokeVirtualMethod(MethodDescriptor.ofMethod(Level.class, \"intValue\", int.class), level);\n+    }\n+\n+    private static BranchResult generateMinLevelDefault(MethodCreator method, FieldDescriptor nameAliasDescriptor) {\n+        final ResultHandle levelIntValue = getParamLevelIntValue(method);\n+        final ResultHandle infoLevelIntValue = getLogManagerLevelIntValue(\"INFO\", method);\n+        return method.ifIntegerGreaterEqual(levelIntValue, infoLevelIntValue);\n+    }\n+\n+    private static ResultHandle getLogManagerLevelIntValue(String levelName, BytecodeCreator method) {\n+        final ResultHandle infoLevel = method.readStaticField(\n+                FieldDescriptor.of(org.jboss.logmanager.Level.class, levelName, org.jboss.logmanager.Level.class));\n+        return method\n+                .invokeVirtualMethod(MethodDescriptor.ofMethod(Level.class, \"intValue\", int.class), infoLevel);\n+    }\n+\n+    private static void generateDefaultLoggingLogger(ClassOutput output) {\n+        try (ClassCreator cc = ClassCreator.builder().setFinal(true)\n+                .className(LOGGING_LOGGER_CLASS_NAME)\n+                .classOutput(output).build()) {\n+\n+            AnnotationCreator targetClass = cc.addAnnotation(\"com.oracle.svm.core.annotate.TargetClass\");\n+            targetClass.addValue(\"className\", \"org.jboss.logging.Logger\");\n+\n+            generateFalseFoldMethod(\"isTraceEnabled\", cc);\n+            generateFalseFoldMethod(\"isDebugEnabled\", cc);\n+        }\n+    }\n+\n+    private static void generateFalseFoldMethod(String name, ClassCreator cc) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdfc43fcb3cd0ecdbc525ba9eb8efb69f267ed07"}, "originalPosition": 250}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTUyODk1OnYy", "diffSide": "RIGHT", "path": "integration-tests/pom.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDoxMjozMVrOIG9t_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDoxMjozMVrOIG9t_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3MzU2Ng==", "bodyText": "If you want these modules to be tested on CI in native, they need to be added there: https://github.com/quarkusio/quarkus/blob/master/.github/native-tests.json .", "url": "https://github.com/quarkusio/quarkus/pull/13376#discussion_r544173566", "createdAt": "2020-12-16T10:12:31Z", "author": {"login": "gsmet"}, "path": "integration-tests/pom.xml", "diffHunk": "@@ -148,6 +148,8 @@\n         <module>logging-json</module>\n         <module>jaxp</module>\n         <module>mailer</module>\n+        <module>logging-min-level-unset</module>\n+        <module>logging-min-level-set</module>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdfc43fcb3cd0ecdbc525ba9eb8efb69f267ed07"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxOTUzMTAzOnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/logging.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDoxMjo1NVrOIG9vMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDoxMjo1NVrOIG9vMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3Mzg3Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            either globally via `quarkus.log.min-level` property or per-category as show in the example above,\n          \n          \n            \n            either globally via the `quarkus.log.min-level` property or per-category as shown in the example above,", "url": "https://github.com/quarkusio/quarkus/pull/13376#discussion_r544173872", "createdAt": "2020-12-16T10:12:55Z", "author": {"login": "gsmet"}, "path": "docs/src/main/asciidoc/logging.adoc", "diffHunk": "@@ -128,9 +128,19 @@ for example, to set the default log level to `INFO` logging and include Hibernat\n [source, properties]\n ----\n quarkus.log.level=INFO\n+quarkus.log.category.\"org.hibernate\".min-level=DEBUG\n quarkus.log.category.\"org.hibernate\".level=DEBUG\n ----\n \n+Setting a log level below `INFO` requires the minimum log level to be adjusted,\n+either globally via `quarkus.log.min-level` property or per-category as show in the example above,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdfc43fcb3cd0ecdbc525ba9eb8efb69f267ed07"}, "originalPosition": 9}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3959, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}