{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0NTI1OTA4", "number": 9144, "title": "Add SmallRye GraphQL extension", "bodyText": "This PR adds Smallrye GraphQL (a MicroProfile GraphQL Implementation) to Quarkus.\nThis PR will also resolve #2509", "createdAt": "2020-05-07T08:04:24Z", "url": "https://github.com/quarkusio/quarkus/pull/9144", "merged": true, "mergeCommit": {"oid": "0a6e09edfa033d961d782a148ff4d013fbe971fe"}, "closed": true, "closedAt": "2020-05-14T15:40:24Z", "author": {"login": "phillip-kruger"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABce5BuagFqTQwNzI0Nzg2MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABchNZGhAH2gAyNDE0NTI1OTA4OmU4YjJiMjU4ZjE1YWQ2Y2E5YmU5ZmJhMjk5NGNhZTc0MjJiNzlmMDU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MjQ3ODYw", "url": "https://github.com/quarkusio/quarkus/pull/9144#pullrequestreview-407247860", "createdAt": "2020-05-07T08:18:02Z", "commit": {"oid": "95364fa8df3489d7a62b1f4789b76f07e9301837"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwODoxODowMlrOGRzihw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwODoyOToyNlrOGRz9yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyMzM5OQ==", "bodyText": "This one doesn't look necessary :).", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421323399", "createdAt": "2020-05-07T08:18:02Z", "author": {"login": "gsmet"}, "path": "bom/runtime/pom.xml", "diffHunk": "@@ -2968,7 +2995,7 @@\n                 <artifactId>swagger-ui</artifactId>\n                 <version>${swagger-ui.version}</version>\n             </dependency>\n-\n+            ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95364fa8df3489d7a62b1f4789b76f07e9301837"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyMzYzMQ==", "bodyText": "Indentation issues.", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421323631", "createdAt": "2020-05-07T08:18:30Z", "author": {"login": "gsmet"}, "path": "extensions/pom.xml", "diffHunk": "@@ -158,9 +158,12 @@\n         <module>optaplanner-jackson</module>\n         <module>optaplanner-jsonb</module>\n \n-        <!-- vault -->\n+        <!-- Vault -->\n         <module>vault</module>\n+\n+\t<!-- GraphQL -->\n         <module>vertx-graphql</module>\n+\t<module>smallrye-graphql</module>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95364fa8df3489d7a62b1f4789b76f07e9301837"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNDEwMw==", "bodyText": "Maybe add the -api suffix? Looks like they are all consistent except context-propagation.", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421324103", "createdAt": "2020-05-07T08:19:18Z", "author": {"login": "gsmet"}, "path": "build-parent/pom.xml", "diffHunk": "@@ -68,7 +68,8 @@\n         <microprofile-opentracing-api.version>1.3.3</microprofile-opentracing-api.version>\n         <microprofile-context-propagation.version>1.0.1</microprofile-context-propagation.version>\n         <microprofile-jwt-api.version>1.1.1</microprofile-jwt-api.version>\n-\n+        <microprofile-graphql.version>1.0.2</microprofile-graphql.version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95364fa8df3489d7a62b1f4789b76f07e9301837"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNDQxNA==", "bodyText": "We don't do @author tags in Quarkus and rely on Git history.", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421324414", "createdAt": "2020-05-07T08:19:49Z", "author": {"login": "gsmet"}, "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.smallrye.graphql.spi.MetricsService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ * \n+ * @author Phillip Kruger (phillip.kruger@redhat.com)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95364fa8df3489d7a62b1f4789b76f07e9301837"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNDY1Ng==", "bodyText": "Better push that as a parameter of your methods. It's better to keep track of dependencies.", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421324656", "createdAt": "2020-05-07T08:20:11Z", "author": {"login": "gsmet"}, "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.smallrye.graphql.spi.MetricsService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ * \n+ * @author Phillip Kruger (phillip.kruger@redhat.com)\n+ */\n+public class SmallryeGraphqlProcessor {\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    @Inject\n+    private LaunchModeBuildItem launchMode;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95364fa8df3489d7a62b1f4789b76f07e9301837"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNDc4OA==", "bodyText": "I would make that a separate class.", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421324788", "createdAt": "2020-05-07T08:20:24Z", "author": {"login": "gsmet"}, "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.smallrye.graphql.spi.MetricsService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ * \n+ * @author Phillip Kruger (phillip.kruger@redhat.com)\n+ */\n+public class SmallryeGraphqlProcessor {\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    @Inject\n+    private LaunchModeBuildItem launchMode;\n+\n+    /**\n+     * The configuration\n+     */\n+    SmallRyeGraphQLConfig quarkusConfig;\n+\n+    @ConfigRoot(name = \"smallrye-graphql\")\n+    static final class SmallRyeGraphQLConfig {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95364fa8df3489d7a62b1f4789b76f07e9301837"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNTQ1Ng==", "bodyText": "Is this related to SmallRye Metrics, should we test the presence of it?", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421325456", "createdAt": "2020-05-07T08:21:34Z", "author": {"login": "gsmet"}, "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.smallrye.graphql.spi.MetricsService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ * \n+ * @author Phillip Kruger (phillip.kruger@redhat.com)\n+ */\n+public class SmallryeGraphqlProcessor {\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    @Inject\n+    private LaunchModeBuildItem launchMode;\n+\n+    /**\n+     * The configuration\n+     */\n+    SmallRyeGraphQLConfig quarkusConfig;\n+\n+    @ConfigRoot(name = \"smallrye-graphql\")\n+    static final class SmallRyeGraphQLConfig {\n+        /**\n+         * The rootPath under which queries will be served. Default to /graphql\n+         */\n+        @ConfigItem(defaultValue = \"/graphql\")\n+        String rootPath;\n+\n+        /**\n+         * The path where GraphQL UI is available.\n+         * <p>\n+         * The value `/` is not allowed as it blocks the application from serving anything else.\n+         */\n+        @ConfigItem(defaultValue = \"/graphql-ui\")\n+        String rootPathUi;\n+\n+        /**\n+         * Always include the UI. By default this will only be included in dev and test.\n+         * Setting this to true will also include the UI in Prod\n+         */\n+        @ConfigItem(defaultValue = \"false\")\n+        boolean alwaysIncludeUi;\n+\n+        /**\n+         * If GraphQL UI should be enabled. By default, GraphQL UI is enabled.\n+         */\n+        @ConfigItem(defaultValue = \"true\")\n+        boolean enableUi;\n+    }\n+\n+    @BuildStep\n+    void feature(BuildProducer<FeatureBuildItem> featureProducer) {\n+        featureProducer.produce(new FeatureBuildItem(FeatureBuildItem.SMALLRYE_GRAPHQL));\n+    }\n+\n+    @BuildStep\n+    void additionalBeanDefiningAnnotation(BuildProducer<BeanDefiningAnnotationBuildItem> beanDefiningAnnotationProducer) {\n+        // Make ArC discover the beans marked with the @GraphQlApi qualifier\n+        beanDefiningAnnotationProducer.produce(new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API));\n+    }\n+\n+    @BuildStep\n+    void additionalBean(BuildProducer<AdditionalBeanBuildItem> additionalBeanProducer) {\n+        additionalBeanProducer.produce(AdditionalBeanBuildItem.builder()\n+                .addBeanClass(GraphQLConfig.class)\n+                .addBeanClass(GraphQLProducer.class)\n+                .setUnremovable().build());\n+    }\n+\n+    @BuildStep\n+    void registerNativeImageResources(BuildProducer<ServiceProviderBuildItem> serviceProvider) throws IOException {\n+        // Lookup Service (We use the one from the CDI Module)\n+        String lookupService = SPI_PATH + LookupService.class.getName();\n+        Set<String> lookupImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                lookupService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(LookupService.class.getName(), lookupImplementations.toArray(new String[0])));\n+\n+        // Metrics (We use the one from the CDI Module)\n+        String metricsService = SPI_PATH + MetricsService.class.getName();\n+        Set<String> metricsImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                metricsService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(MetricsService.class.getName(), metricsImplementations.toArray(new String[0])));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95364fa8df3489d7a62b1f4789b76f07e9301837"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNTk0OA==", "bodyText": "This is being worked on by @stuartwdouglas IIUC the issue.", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421325948", "createdAt": "2020-05-07T08:22:23Z", "author": {"login": "gsmet"}, "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.smallrye.graphql.spi.MetricsService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ * \n+ * @author Phillip Kruger (phillip.kruger@redhat.com)\n+ */\n+public class SmallryeGraphqlProcessor {\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    @Inject\n+    private LaunchModeBuildItem launchMode;\n+\n+    /**\n+     * The configuration\n+     */\n+    SmallRyeGraphQLConfig quarkusConfig;\n+\n+    @ConfigRoot(name = \"smallrye-graphql\")\n+    static final class SmallRyeGraphQLConfig {\n+        /**\n+         * The rootPath under which queries will be served. Default to /graphql\n+         */\n+        @ConfigItem(defaultValue = \"/graphql\")\n+        String rootPath;\n+\n+        /**\n+         * The path where GraphQL UI is available.\n+         * <p>\n+         * The value `/` is not allowed as it blocks the application from serving anything else.\n+         */\n+        @ConfigItem(defaultValue = \"/graphql-ui\")\n+        String rootPathUi;\n+\n+        /**\n+         * Always include the UI. By default this will only be included in dev and test.\n+         * Setting this to true will also include the UI in Prod\n+         */\n+        @ConfigItem(defaultValue = \"false\")\n+        boolean alwaysIncludeUi;\n+\n+        /**\n+         * If GraphQL UI should be enabled. By default, GraphQL UI is enabled.\n+         */\n+        @ConfigItem(defaultValue = \"true\")\n+        boolean enableUi;\n+    }\n+\n+    @BuildStep\n+    void feature(BuildProducer<FeatureBuildItem> featureProducer) {\n+        featureProducer.produce(new FeatureBuildItem(FeatureBuildItem.SMALLRYE_GRAPHQL));\n+    }\n+\n+    @BuildStep\n+    void additionalBeanDefiningAnnotation(BuildProducer<BeanDefiningAnnotationBuildItem> beanDefiningAnnotationProducer) {\n+        // Make ArC discover the beans marked with the @GraphQlApi qualifier\n+        beanDefiningAnnotationProducer.produce(new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API));\n+    }\n+\n+    @BuildStep\n+    void additionalBean(BuildProducer<AdditionalBeanBuildItem> additionalBeanProducer) {\n+        additionalBeanProducer.produce(AdditionalBeanBuildItem.builder()\n+                .addBeanClass(GraphQLConfig.class)\n+                .addBeanClass(GraphQLProducer.class)\n+                .setUnremovable().build());\n+    }\n+\n+    @BuildStep\n+    void registerNativeImageResources(BuildProducer<ServiceProviderBuildItem> serviceProvider) throws IOException {\n+        // Lookup Service (We use the one from the CDI Module)\n+        String lookupService = SPI_PATH + LookupService.class.getName();\n+        Set<String> lookupImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                lookupService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(LookupService.class.getName(), lookupImplementations.toArray(new String[0])));\n+\n+        // Metrics (We use the one from the CDI Module)\n+        String metricsService = SPI_PATH + MetricsService.class.getName();\n+        Set<String> metricsImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                metricsService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(MetricsService.class.getName(), metricsImplementations.toArray(new String[0])));\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildExecutionService(BuildProducer<ReflectiveClassBuildItem> reflectiveClassProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            CombinedIndexBuildItem combinedIndex) {\n+\n+        IndexView index = combinedIndex.getIndex();\n+        Schema schema = SchemaBuilder.build(index);\n+\n+        reflectiveClassProducer\n+                .produce(new ReflectiveClassBuildItem(true, true, getClassesToRegisterForReflection(schema)));\n+\n+        recorder.createExecutionService(schema);\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildEndpoints(\n+            BuildProducer<RequireBodyHandlerBuildItem> requireBodyHandlerProducer,\n+            BuildProducer<RouteBuildItem> routeProducer,\n+            BuildProducer<NotFoundPageDisplayableEndpointBuildItem> notFoundPageDisplayableEndpointProducer,\n+            //BuildProducer<ExtensionSslNativeSupportBuildItem> extensionSslNativeSupportProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            ShutdownContextBuildItem shutdownContext) throws IOException {\n+\n+        /*\n+         * <em>Ugly Hack</em>\n+         * In dev mode, we pass a classloader to use in the CDI Loader.\n+         * This hack is required because using the TCCL would get an outdated version - the initial one.\n+         * This is because the worker thread on which the handler is called captures the TCCL at creation time\n+         * and does not allow updating it.\n+         *\n+         * In non dev mode, the TCCL is used.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95364fa8df3489d7a62b1f4789b76f07e9301837"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNjI0OQ==", "bodyText": "Why would the extension need SSL? It connects to something?", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421326249", "createdAt": "2020-05-07T08:22:53Z", "author": {"login": "gsmet"}, "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.smallrye.graphql.spi.MetricsService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ * \n+ * @author Phillip Kruger (phillip.kruger@redhat.com)\n+ */\n+public class SmallryeGraphqlProcessor {\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    @Inject\n+    private LaunchModeBuildItem launchMode;\n+\n+    /**\n+     * The configuration\n+     */\n+    SmallRyeGraphQLConfig quarkusConfig;\n+\n+    @ConfigRoot(name = \"smallrye-graphql\")\n+    static final class SmallRyeGraphQLConfig {\n+        /**\n+         * The rootPath under which queries will be served. Default to /graphql\n+         */\n+        @ConfigItem(defaultValue = \"/graphql\")\n+        String rootPath;\n+\n+        /**\n+         * The path where GraphQL UI is available.\n+         * <p>\n+         * The value `/` is not allowed as it blocks the application from serving anything else.\n+         */\n+        @ConfigItem(defaultValue = \"/graphql-ui\")\n+        String rootPathUi;\n+\n+        /**\n+         * Always include the UI. By default this will only be included in dev and test.\n+         * Setting this to true will also include the UI in Prod\n+         */\n+        @ConfigItem(defaultValue = \"false\")\n+        boolean alwaysIncludeUi;\n+\n+        /**\n+         * If GraphQL UI should be enabled. By default, GraphQL UI is enabled.\n+         */\n+        @ConfigItem(defaultValue = \"true\")\n+        boolean enableUi;\n+    }\n+\n+    @BuildStep\n+    void feature(BuildProducer<FeatureBuildItem> featureProducer) {\n+        featureProducer.produce(new FeatureBuildItem(FeatureBuildItem.SMALLRYE_GRAPHQL));\n+    }\n+\n+    @BuildStep\n+    void additionalBeanDefiningAnnotation(BuildProducer<BeanDefiningAnnotationBuildItem> beanDefiningAnnotationProducer) {\n+        // Make ArC discover the beans marked with the @GraphQlApi qualifier\n+        beanDefiningAnnotationProducer.produce(new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API));\n+    }\n+\n+    @BuildStep\n+    void additionalBean(BuildProducer<AdditionalBeanBuildItem> additionalBeanProducer) {\n+        additionalBeanProducer.produce(AdditionalBeanBuildItem.builder()\n+                .addBeanClass(GraphQLConfig.class)\n+                .addBeanClass(GraphQLProducer.class)\n+                .setUnremovable().build());\n+    }\n+\n+    @BuildStep\n+    void registerNativeImageResources(BuildProducer<ServiceProviderBuildItem> serviceProvider) throws IOException {\n+        // Lookup Service (We use the one from the CDI Module)\n+        String lookupService = SPI_PATH + LookupService.class.getName();\n+        Set<String> lookupImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                lookupService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(LookupService.class.getName(), lookupImplementations.toArray(new String[0])));\n+\n+        // Metrics (We use the one from the CDI Module)\n+        String metricsService = SPI_PATH + MetricsService.class.getName();\n+        Set<String> metricsImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                metricsService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(MetricsService.class.getName(), metricsImplementations.toArray(new String[0])));\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildExecutionService(BuildProducer<ReflectiveClassBuildItem> reflectiveClassProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            CombinedIndexBuildItem combinedIndex) {\n+\n+        IndexView index = combinedIndex.getIndex();\n+        Schema schema = SchemaBuilder.build(index);\n+\n+        reflectiveClassProducer\n+                .produce(new ReflectiveClassBuildItem(true, true, getClassesToRegisterForReflection(schema)));\n+\n+        recorder.createExecutionService(schema);\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildEndpoints(\n+            BuildProducer<RequireBodyHandlerBuildItem> requireBodyHandlerProducer,\n+            BuildProducer<RouteBuildItem> routeProducer,\n+            BuildProducer<NotFoundPageDisplayableEndpointBuildItem> notFoundPageDisplayableEndpointProducer,\n+            //BuildProducer<ExtensionSslNativeSupportBuildItem> extensionSslNativeSupportProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            ShutdownContextBuildItem shutdownContext) throws IOException {\n+\n+        /*\n+         * <em>Ugly Hack</em>\n+         * In dev mode, we pass a classloader to use in the CDI Loader.\n+         * This hack is required because using the TCCL would get an outdated version - the initial one.\n+         * This is because the worker thread on which the handler is called captures the TCCL at creation time\n+         * and does not allow updating it.\n+         *\n+         * In non dev mode, the TCCL is used.\n+         */\n+        if (launchMode.getLaunchMode() == LaunchMode.DEVELOPMENT) {\n+            recorder.setupClDevMode(shutdownContext);\n+        }\n+        // add graphql endpoint for not found display in dev or test mode\n+        if (launchMode.getLaunchMode().isDevOrTest()) {\n+            notFoundPageDisplayableEndpointProducer\n+                    .produce(new NotFoundPageDisplayableEndpointBuildItem(quarkusConfig.rootPath));\n+            notFoundPageDisplayableEndpointProducer\n+                    .produce(new NotFoundPageDisplayableEndpointBuildItem(quarkusConfig.rootPath + SCHEMA_PATH));\n+        }\n+\n+        Boolean allowGet = ConfigProvider.getConfig().getOptionalValue(ConfigKey.ALLOW_GET, boolean.class).orElse(false);\n+\n+        Handler<RoutingContext> executionHandler = recorder.executionHandler(allowGet);\n+        routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPath, executionHandler, HandlerType.BLOCKING));\n+\n+        Handler<RoutingContext> schemaHandler = recorder.schemaHandler();\n+        routeProducer.produce(\n+                new RouteBuildItem(quarkusConfig.rootPath + SCHEMA_PATH, schemaHandler, HandlerType.BLOCKING));\n+\n+        // Because we need to read the body\n+        requireBodyHandlerProducer.produce(new RequireBodyHandlerBuildItem());\n+\n+        // TODO: SSL Support by default ?\n+        // extensionSslNativeSupportProducer.produce(new ExtensionSslNativeSupportBuildItem(FeatureBuildItem.SMALLRYE_GRAPHQL));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95364fa8df3489d7a62b1f4789b76f07e9301837"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNjUyOA==", "bodyText": "This should definitely be at the top of the class.", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421326528", "createdAt": "2020-05-07T08:23:19Z", "author": {"login": "gsmet"}, "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import javax.inject.Inject;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+import io.quarkus.runtime.annotations.ConfigRoot;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.smallrye.graphql.spi.MetricsService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ * \n+ * @author Phillip Kruger (phillip.kruger@redhat.com)\n+ */\n+public class SmallryeGraphqlProcessor {\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    @Inject\n+    private LaunchModeBuildItem launchMode;\n+\n+    /**\n+     * The configuration\n+     */\n+    SmallRyeGraphQLConfig quarkusConfig;\n+\n+    @ConfigRoot(name = \"smallrye-graphql\")\n+    static final class SmallRyeGraphQLConfig {\n+        /**\n+         * The rootPath under which queries will be served. Default to /graphql\n+         */\n+        @ConfigItem(defaultValue = \"/graphql\")\n+        String rootPath;\n+\n+        /**\n+         * The path where GraphQL UI is available.\n+         * <p>\n+         * The value `/` is not allowed as it blocks the application from serving anything else.\n+         */\n+        @ConfigItem(defaultValue = \"/graphql-ui\")\n+        String rootPathUi;\n+\n+        /**\n+         * Always include the UI. By default this will only be included in dev and test.\n+         * Setting this to true will also include the UI in Prod\n+         */\n+        @ConfigItem(defaultValue = \"false\")\n+        boolean alwaysIncludeUi;\n+\n+        /**\n+         * If GraphQL UI should be enabled. By default, GraphQL UI is enabled.\n+         */\n+        @ConfigItem(defaultValue = \"true\")\n+        boolean enableUi;\n+    }\n+\n+    @BuildStep\n+    void feature(BuildProducer<FeatureBuildItem> featureProducer) {\n+        featureProducer.produce(new FeatureBuildItem(FeatureBuildItem.SMALLRYE_GRAPHQL));\n+    }\n+\n+    @BuildStep\n+    void additionalBeanDefiningAnnotation(BuildProducer<BeanDefiningAnnotationBuildItem> beanDefiningAnnotationProducer) {\n+        // Make ArC discover the beans marked with the @GraphQlApi qualifier\n+        beanDefiningAnnotationProducer.produce(new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API));\n+    }\n+\n+    @BuildStep\n+    void additionalBean(BuildProducer<AdditionalBeanBuildItem> additionalBeanProducer) {\n+        additionalBeanProducer.produce(AdditionalBeanBuildItem.builder()\n+                .addBeanClass(GraphQLConfig.class)\n+                .addBeanClass(GraphQLProducer.class)\n+                .setUnremovable().build());\n+    }\n+\n+    @BuildStep\n+    void registerNativeImageResources(BuildProducer<ServiceProviderBuildItem> serviceProvider) throws IOException {\n+        // Lookup Service (We use the one from the CDI Module)\n+        String lookupService = SPI_PATH + LookupService.class.getName();\n+        Set<String> lookupImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                lookupService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(LookupService.class.getName(), lookupImplementations.toArray(new String[0])));\n+\n+        // Metrics (We use the one from the CDI Module)\n+        String metricsService = SPI_PATH + MetricsService.class.getName();\n+        Set<String> metricsImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                metricsService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(MetricsService.class.getName(), metricsImplementations.toArray(new String[0])));\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildExecutionService(BuildProducer<ReflectiveClassBuildItem> reflectiveClassProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            CombinedIndexBuildItem combinedIndex) {\n+\n+        IndexView index = combinedIndex.getIndex();\n+        Schema schema = SchemaBuilder.build(index);\n+\n+        reflectiveClassProducer\n+                .produce(new ReflectiveClassBuildItem(true, true, getClassesToRegisterForReflection(schema)));\n+\n+        recorder.createExecutionService(schema);\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildEndpoints(\n+            BuildProducer<RequireBodyHandlerBuildItem> requireBodyHandlerProducer,\n+            BuildProducer<RouteBuildItem> routeProducer,\n+            BuildProducer<NotFoundPageDisplayableEndpointBuildItem> notFoundPageDisplayableEndpointProducer,\n+            //BuildProducer<ExtensionSslNativeSupportBuildItem> extensionSslNativeSupportProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            ShutdownContextBuildItem shutdownContext) throws IOException {\n+\n+        /*\n+         * <em>Ugly Hack</em>\n+         * In dev mode, we pass a classloader to use in the CDI Loader.\n+         * This hack is required because using the TCCL would get an outdated version - the initial one.\n+         * This is because the worker thread on which the handler is called captures the TCCL at creation time\n+         * and does not allow updating it.\n+         *\n+         * In non dev mode, the TCCL is used.\n+         */\n+        if (launchMode.getLaunchMode() == LaunchMode.DEVELOPMENT) {\n+            recorder.setupClDevMode(shutdownContext);\n+        }\n+        // add graphql endpoint for not found display in dev or test mode\n+        if (launchMode.getLaunchMode().isDevOrTest()) {\n+            notFoundPageDisplayableEndpointProducer\n+                    .produce(new NotFoundPageDisplayableEndpointBuildItem(quarkusConfig.rootPath));\n+            notFoundPageDisplayableEndpointProducer\n+                    .produce(new NotFoundPageDisplayableEndpointBuildItem(quarkusConfig.rootPath + SCHEMA_PATH));\n+        }\n+\n+        Boolean allowGet = ConfigProvider.getConfig().getOptionalValue(ConfigKey.ALLOW_GET, boolean.class).orElse(false);\n+\n+        Handler<RoutingContext> executionHandler = recorder.executionHandler(allowGet);\n+        routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPath, executionHandler, HandlerType.BLOCKING));\n+\n+        Handler<RoutingContext> schemaHandler = recorder.schemaHandler();\n+        routeProducer.produce(\n+                new RouteBuildItem(quarkusConfig.rootPath + SCHEMA_PATH, schemaHandler, HandlerType.BLOCKING));\n+\n+        // Because we need to read the body\n+        requireBodyHandlerProducer.produce(new RequireBodyHandlerBuildItem());\n+\n+        // TODO: SSL Support by default ?\n+        // extensionSslNativeSupportProducer.produce(new ExtensionSslNativeSupportBuildItem(FeatureBuildItem.SMALLRYE_GRAPHQL));\n+    }\n+\n+    private String[] getClassesToRegisterForReflection(Schema schema) {\n+        // Unique list of classes we need to do reflection on\n+        Set<String> classes = new HashSet<>();\n+\n+        classes.addAll(getOperationClassNames(schema.getQueries()));\n+        classes.addAll(getOperationClassNames(schema.getMutations()));\n+        classes.addAll(getReferenceClassNames(schema.getTypes().values()));\n+        classes.addAll(getReferenceClassNames(schema.getInputs().values()));\n+        classes.addAll(getReferenceClassNames(schema.getInterfaces().values()));\n+\n+        // TODO: Introspection classes. (In native mode, the graphiQL introspection query fails. Below is not working)\n+//        classes.add(GraphQLObjectType.class.getName());\n+//        classes.add(GraphQLInputObjectType.class.getName());\n+//        classes.add(GraphQLEnumType.class.getName());\n+//        classes.add(GraphQLInputObjectField.class.getName());\n+//        classes.add(GraphQLInterfaceType.class.getName());\n+\n+        String[] arrayOfClassNames = classes.toArray(new String[] {});\n+        return arrayOfClassNames;\n+    }\n+\n+    private Set<String> getOperationClassNames(Set<Operation> operations) {\n+        Set<String> classes = new HashSet<>();\n+        for (Operation operation : operations) {\n+            classes.add(operation.getClassName());\n+        }\n+        return classes;\n+    }\n+\n+    private Set<String> getReferenceClassNames(Collection complexGraphQLTypes) {\n+        Set<String> classes = new HashSet<>();\n+        for (Object complexGraphQLType : complexGraphQLTypes) {\n+            Reference reference = Reference.class.cast(complexGraphQLType);\n+            classes.add(reference.getClassName());\n+        }\n+        return classes;\n+    }\n+\n+    // For the UI\n+    private static final String GRAPHQL_UI_WEBJAR_GROUP_ID = \"io.smallrye\";\n+    private static final String GRAPHQL_UI_WEBJAR_ARTIFACT_ID = \"smallrye-graphql-ui-graphiql\";\n+    private static final String GRAPHQL_UI_WEBJAR_PREFIX = \"META-INF/resources/graphql-ui\";\n+    private static final String OWN_MEDIA_FOLDER = \"META-INF/resources/\";\n+    private static final String GRAPHQL_UI_FINAL_DESTINATION = \"META-INF/graphql-ui-files\";\n+    private static final String TEMP_DIR_PREFIX = \"quarkus-graphql-ui_\" + System.nanoTime();\n+    private static final List<String> IGNORE_LIST = Arrays.asList(new String[] { \"logo.png\", \"favicon.ico\" });\n+    private static final String FILE_TO_UPDATE = \"render.js\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95364fa8df3489d7a62b1f4789b76f07e9301837"}, "originalPosition": 261}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyNzc4Ng==", "bodyText": "This module needs a description, it's used in code.quarkus.io. Better start the description with a verb \"Connect to...\" or whatever :).", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421327786", "createdAt": "2020-05-07T08:25:19Z", "author": {"login": "gsmet"}, "path": "extensions/smallrye-graphql/runtime/pom.xml", "diffHunk": "@@ -0,0 +1,76 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <parent>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-smallrye-graphql-parent</artifactId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../pom.xml</relativePath>\n+    </parent>\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <artifactId>quarkus-smallrye-graphql</artifactId>\n+    <name>Quarkus - SmallRye GraphQL - Runtime</name>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95364fa8df3489d7a62b1f4789b76f07e9301837"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyODU3Nw==", "bodyText": "The jsonp deployment is missing here. It should be symmetrical with the runtime pom. As this dependency comes with jsonb, I would simply remove it from the runtime module", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421328577", "createdAt": "2020-05-07T08:26:38Z", "author": {"login": "gsmet"}, "path": "extensions/smallrye-graphql/deployment/pom.xml", "diffHunk": "@@ -0,0 +1,83 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <parent>\n+        <groupId>io.quarkus</groupId>\n+        <artifactId>quarkus-smallrye-graphql-parent</artifactId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../pom.xml</relativePath>\n+    </parent>\n+    <modelVersion>4.0.0</modelVersion>\n+    \n+    <artifactId>quarkus-smallrye-graphql-deployment</artifactId>\n+    <name>Quarkus - SmallRye GraphQL - Deployment</name>\n+\n+    <dependencies>\n+        \n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-smallrye-graphql</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+        \n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-core-deployment</artifactId>\n+        </dependency>\n+        \n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-arc-deployment</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-vertx-http-deployment</artifactId>\n+        </dependency>\n+        \n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-jsonb-deployment</artifactId>\n+        </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95364fa8df3489d7a62b1f4789b76f07e9301837"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyOTA5Mw==", "bodyText": "Please put the constants at the top of the class.", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421329093", "createdAt": "2020-05-07T08:27:26Z", "author": {"login": "gsmet"}, "path": "extensions/smallrye-graphql/runtime/src/main/java/io/quarkus/smallrye/graphql/runtime/SmallRyeGraphQLExecutionHandler.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package io.quarkus.smallrye.graphql.runtime;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.util.List;\n+\n+import javax.enterprise.inject.spi.CDI;\n+import javax.json.Json;\n+import javax.json.JsonObject;\n+import javax.json.JsonReader;\n+import javax.json.JsonWriter;\n+\n+import io.smallrye.graphql.execution.ExecutionService;\n+import io.vertx.core.Handler;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.http.HttpServerRequest;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Handler that does the execution of GraphQL Requests\n+ * \n+ * @author Phillip Kruger (phillip.kruger@redhat.com)\n+ */\n+public class SmallRyeGraphQLExecutionHandler implements Handler<RoutingContext> {\n+    private static boolean allowGet = false;\n+\n+    public SmallRyeGraphQLExecutionHandler(boolean allowGet) {\n+        this.allowGet = allowGet;\n+    }\n+\n+    @Override\n+    public void handle(final RoutingContext ctx) {\n+        HttpServerRequest request = ctx.request();\n+        HttpServerResponse response = ctx.response();\n+\n+        response.headers().set(HttpHeaders.CONTENT_TYPE, \"application/json; charset=UTF-8\");\n+\n+        switch (request.method()) {\n+            case OPTIONS:\n+                response.headers().set(HttpHeaders.ALLOW, getAllowedMethods());\n+                response.setStatusCode(200)\n+                        .setStatusMessage(OK)\n+                        .end();\n+                break;\n+            case POST:\n+                String graphqlPostRequest = ctx.getBodyAsString();\n+                String postResponse = doRequest(graphqlPostRequest);\n+                response.setStatusCode(200)\n+                        .setStatusMessage(OK)\n+                        .end(Buffer.buffer(postResponse));\n+                break;\n+            case GET:\n+                if (allowGet) {\n+                    List<String> queries = ctx.queryParam(QUERY);\n+                    if (queries != null && !queries.isEmpty()) {\n+                        String graphqlGetRequest = queries.get(0);\n+                        String getResponse = doRequest(graphqlGetRequest);\n+                        response.setStatusCode(200)\n+                                .setStatusMessage(OK)\n+                                .end(Buffer.buffer(getResponse));\n+                    } else {\n+                        response.setStatusCode(204).setStatusMessage(\"Provide a query parameter\").end();\n+                    }\n+                } else {\n+                    response.setStatusCode(405).setStatusMessage(\"GET Queries is not enabled\").end();\n+                }\n+                break;\n+            default:\n+                response.setStatusCode(405).setStatusMessage(request.method() + \" Method is not supported\").end();\n+                break;\n+        }\n+    }\n+\n+    private String getAllowedMethods() {\n+        if (allowGet) {\n+            return \"GET, POST, OPTIONS\";\n+        } else {\n+            return \"POST, OPTIONS\";\n+        }\n+    }\n+\n+    private String doRequest(final String body) {\n+        try (StringReader input = new StringReader(body);\n+                final JsonReader jsonReader = Json.createReader(input)) {\n+            JsonObject jsonInput = jsonReader.readObject();\n+            ExecutionService executionService = CDI.current().select(ExecutionService.class).get();\n+            JsonObject outputJson = executionService.execute(jsonInput);\n+            if (outputJson != null) {\n+                try (StringWriter output = new StringWriter();\n+                        final JsonWriter jsonWriter = Json.createWriter(output)) {\n+                    jsonWriter.writeObject(outputJson);\n+                    output.flush();\n+                    return output.toString();\n+                }\n+            }\n+            return null;\n+        } catch (IOException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    private static final String QUERY = \"query\";\n+    private static final String OK = \"OK\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95364fa8df3489d7a62b1f4789b76f07e9301837"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyOTI1Nw==", "bodyText": "Let's drop useless javadoc comments.", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421329257", "createdAt": "2020-05-07T08:27:39Z", "author": {"login": "gsmet"}, "path": "extensions/smallrye-graphql/runtime/src/main/java/io/quarkus/smallrye/graphql/runtime/SmallRyeGraphQLRecorder.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package io.quarkus.smallrye.graphql.runtime;\n+\n+import java.util.function.Supplier;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.runtime.ShutdownContext;\n+import io.quarkus.runtime.annotations.Recorder;\n+import io.quarkus.smallrye.graphql.runtime.spi.QuarkusClassloadingService;\n+import io.quarkus.vertx.http.runtime.ThreadLocalHandler;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.ext.web.RoutingContext;\n+import io.vertx.ext.web.handler.StaticHandler;\n+\n+/**\n+ * Recorder", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95364fa8df3489d7a62b1f4789b76f07e9301837"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyOTU2Mw==", "bodyText": "This is incorrect. You probably want a BeanContainerListener.", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421329563", "createdAt": "2020-05-07T08:28:11Z", "author": {"login": "gsmet"}, "path": "extensions/smallrye-graphql/runtime/src/main/java/io/quarkus/smallrye/graphql/runtime/SmallRyeGraphQLRecorder.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package io.quarkus.smallrye.graphql.runtime;\n+\n+import java.util.function.Supplier;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.runtime.ShutdownContext;\n+import io.quarkus.runtime.annotations.Recorder;\n+import io.quarkus.smallrye.graphql.runtime.spi.QuarkusClassloadingService;\n+import io.quarkus.vertx.http.runtime.ThreadLocalHandler;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.ext.web.RoutingContext;\n+import io.vertx.ext.web.handler.StaticHandler;\n+\n+/**\n+ * Recorder\n+ * \n+ * @author Phillip Kruger (phillip.kruger@redhat.com)\n+ */\n+@Recorder\n+public class SmallRyeGraphQLRecorder {\n+\n+    public void createExecutionService(Schema schema) {\n+        Arc.initialize(); // FIXME: why do I need this?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95364fa8df3489d7a62b1f4789b76f07e9301837"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzMDA2Mg==", "bodyText": "This needs @stuartwdouglas 's attention.", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421330062", "createdAt": "2020-05-07T08:28:56Z", "author": {"login": "gsmet"}, "path": "extensions/smallrye-graphql/runtime/src/main/java/io/quarkus/smallrye/graphql/runtime/spi/QuarkusClassloadingService.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package io.quarkus.smallrye.graphql.runtime.spi;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+\n+import graphql.schema.PropertyDataFetcherHelper;\n+import io.smallrye.graphql.execution.Classes;\n+import io.smallrye.graphql.spi.ClassloadingService;\n+\n+/**\n+ * Quarkus specific classloading service, that allows\n+ * hot reloading to work in dev mode.\n+ * \n+ * @author Phillip Kruger (phillip.kruger@redhat.com)\n+ */\n+public class QuarkusClassloadingService implements ClassloadingService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95364fa8df3489d7a62b1f4789b76f07e9301837"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzMDM3Ng==", "bodyText": "Please make the indentation consistent.", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421330376", "createdAt": "2020-05-07T08:29:26Z", "author": {"login": "gsmet"}, "path": "tcks/microprofile-graphql/pom.xml", "diffHunk": "@@ -0,0 +1,48 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <parent>\n+        <artifactId>quarkus-tck-parent</artifactId>\n+        <groupId>io.quarkus</groupId>\n+        <version>999-SNAPSHOT</version>\n+        <relativePath>../pom.xml</relativePath>\n+    </parent>\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <artifactId>quarkus-tck-microprofile-graphql</artifactId>\n+    <name>Quarkus - TCK - MicroProfile GraphQL</name>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <configuration>\n+                    <dependenciesToScan>\n+                        <dependency>org.eclipse.microprofile.graphql:microprofile-graphql-tck</dependency>\n+                    </dependenciesToScan>\n+                </configuration>\n+            </plugin>\n+        </plugins>\n+    </build>\n+    <dependencies>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-arquillian</artifactId>\n+        </dependency>\n+        <dependency>\n+            <groupId>io.quarkus</groupId>\n+            <artifactId>quarkus-smallrye-graphql</artifactId>\n+        </dependency>\n+        \n+         <dependency>\n+            <groupId>org.eclipse.microprofile.graphql</groupId>\n+            <artifactId>microprofile-graphql-tck</artifactId>\n+            <version>${microprofile-graphql.version}</version>\n+            <scope>provided</scope>\n+        </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95364fa8df3489d7a62b1f4789b76f07e9301837"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3Mjk1NTcz", "url": "https://github.com/quarkusio/quarkus/pull/9144#pullrequestreview-407295573", "createdAt": "2020-05-07T09:20:32Z", "commit": {"oid": "1ff8048310e426e6220807cb3e94d20c7c3566e3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOToyMDozMlrOGR17Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOToyMDozMlrOGR17Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2MjQ3OQ==", "bodyText": "Could we use org.apache.commons.io.IOUtils.toByteArray(InputStream) instead? It seems to be somewhere among the dependencies and some other extensions use it too", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421362479", "createdAt": "2020-05-07T09:20:32Z", "author": {"login": "jmartisk"}, "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,384 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.smallrye.graphql.spi.MetricsService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ */\n+public class SmallryeGraphqlProcessor {\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    // For the UI\n+    private static final String GRAPHQL_UI_WEBJAR_GROUP_ID = \"io.smallrye\";\n+    private static final String GRAPHQL_UI_WEBJAR_ARTIFACT_ID = \"smallrye-graphql-ui-graphiql\";\n+    private static final String GRAPHQL_UI_WEBJAR_PREFIX = \"META-INF/resources/graphql-ui\";\n+    private static final String OWN_MEDIA_FOLDER = \"META-INF/resources/\";\n+    private static final String GRAPHQL_UI_FINAL_DESTINATION = \"META-INF/graphql-ui-files\";\n+    private static final String TEMP_DIR_PREFIX = \"quarkus-graphql-ui_\" + System.nanoTime();\n+    private static final List<String> IGNORE_LIST = Arrays.asList(new String[] { \"logo.png\", \"favicon.ico\" });\n+    private static final String FILE_TO_UPDATE = \"render.js\";\n+    \n+    SmallRyeGraphQLConfig quarkusConfig;\n+\n+    @BuildStep\n+    void feature(BuildProducer<FeatureBuildItem> featureProducer) {\n+        featureProducer.produce(new FeatureBuildItem(FeatureBuildItem.SMALLRYE_GRAPHQL));\n+    }\n+\n+    @BuildStep\n+    void additionalBeanDefiningAnnotation(BuildProducer<BeanDefiningAnnotationBuildItem> beanDefiningAnnotationProducer) {\n+        // Make ArC discover the beans marked with the @GraphQlApi qualifier\n+        beanDefiningAnnotationProducer.produce(new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API));\n+    }\n+\n+    @BuildStep\n+    void additionalBean(BuildProducer<AdditionalBeanBuildItem> additionalBeanProducer) {\n+        additionalBeanProducer.produce(AdditionalBeanBuildItem.builder()\n+                .addBeanClass(GraphQLConfig.class)\n+                .addBeanClass(GraphQLProducer.class)\n+                .setUnremovable().build());\n+    }\n+\n+    @BuildStep\n+    void registerNativeImageResources(BuildProducer<ServiceProviderBuildItem> serviceProvider) throws IOException {\n+        // Lookup Service (We use the one from the CDI Module)\n+        String lookupService = SPI_PATH + LookupService.class.getName();\n+        Set<String> lookupImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                lookupService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(LookupService.class.getName(), lookupImplementations.toArray(new String[0])));\n+\n+        // Metrics (We use the one from the CDI Module)\n+        String metricsService = SPI_PATH + MetricsService.class.getName();\n+        Set<String> metricsImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                metricsService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(MetricsService.class.getName(), metricsImplementations.toArray(new String[0])));\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildExecutionService(BuildProducer<ReflectiveClassBuildItem> reflectiveClassProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            CombinedIndexBuildItem combinedIndex) {\n+\n+        IndexView index = combinedIndex.getIndex();\n+        Schema schema = SchemaBuilder.build(index);\n+\n+        reflectiveClassProducer\n+                .produce(new ReflectiveClassBuildItem(true, true, getClassesToRegisterForReflection(schema)));\n+\n+        recorder.createExecutionService(schema);\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildEndpoints(\n+            BuildProducer<RequireBodyHandlerBuildItem> requireBodyHandlerProducer,\n+            BuildProducer<RouteBuildItem> routeProducer,\n+            BuildProducer<NotFoundPageDisplayableEndpointBuildItem> notFoundPageDisplayableEndpointProducer,\n+            LaunchModeBuildItem launchMode,\n+            SmallRyeGraphQLRecorder recorder,\n+            ShutdownContextBuildItem shutdownContext) throws IOException {\n+\n+        /*\n+         * <em>Ugly Hack</em>\n+         * In dev mode, we pass a classloader to use in the CDI Loader.\n+         * This hack is required because using the TCCL would get an outdated version - the initial one.\n+         * This is because the worker thread on which the handler is called captures the TCCL at creation time\n+         * and does not allow updating it.\n+         *\n+         * In non dev mode, the TCCL is used.\n+         */\n+        if (launchMode.getLaunchMode() == LaunchMode.DEVELOPMENT) {\n+            recorder.setupClDevMode(shutdownContext);\n+        }\n+        // add graphql endpoint for not found display in dev or test mode\n+        if (launchMode.getLaunchMode().isDevOrTest()) {\n+            notFoundPageDisplayableEndpointProducer\n+                    .produce(new NotFoundPageDisplayableEndpointBuildItem(quarkusConfig.rootPath));\n+            notFoundPageDisplayableEndpointProducer\n+                    .produce(new NotFoundPageDisplayableEndpointBuildItem(quarkusConfig.rootPath + SCHEMA_PATH));\n+        }\n+\n+        Boolean allowGet = ConfigProvider.getConfig().getOptionalValue(ConfigKey.ALLOW_GET, boolean.class).orElse(false);\n+\n+        Handler<RoutingContext> executionHandler = recorder.executionHandler(allowGet);\n+        routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPath, executionHandler, HandlerType.BLOCKING));\n+\n+        Handler<RoutingContext> schemaHandler = recorder.schemaHandler();\n+        routeProducer.produce(\n+                new RouteBuildItem(quarkusConfig.rootPath + SCHEMA_PATH, schemaHandler, HandlerType.BLOCKING));\n+\n+        // Because we need to read the body\n+        requireBodyHandlerProducer.produce(new RequireBodyHandlerBuildItem());\n+\n+    }\n+\n+    private String[] getClassesToRegisterForReflection(Schema schema) {\n+        // Unique list of classes we need to do reflection on\n+        Set<String> classes = new HashSet<>();\n+\n+        classes.addAll(getOperationClassNames(schema.getQueries()));\n+        classes.addAll(getOperationClassNames(schema.getMutations()));\n+        classes.addAll(getReferenceClassNames(schema.getTypes().values()));\n+        classes.addAll(getReferenceClassNames(schema.getInputs().values()));\n+        classes.addAll(getReferenceClassNames(schema.getInterfaces().values()));\n+\n+        String[] arrayOfClassNames = classes.toArray(new String[] {});\n+        return arrayOfClassNames;\n+    }\n+\n+    private Set<String> getOperationClassNames(Set<Operation> operations) {\n+        Set<String> classes = new HashSet<>();\n+        for (Operation operation : operations) {\n+            classes.add(operation.getClassName());\n+        }\n+        return classes;\n+    }\n+\n+    private Set<String> getReferenceClassNames(Collection complexGraphQLTypes) {\n+        Set<String> classes = new HashSet<>();\n+        for (Object complexGraphQLType : complexGraphQLTypes) {\n+            Reference reference = Reference.class.cast(complexGraphQLType);\n+            classes.add(reference.getClassName());\n+        }\n+        return classes;\n+    }\n+\n+    @BuildStep\n+    @Record(ExecutionTime.STATIC_INIT)\n+    void registerGraphQLUiServletExtension(\n+            BuildProducer<RouteBuildItem> routeProducer,\n+            BuildProducer<GeneratedResourceBuildItem> generatedResourceProducer,\n+            BuildProducer<NativeImageResourceBuildItem> nativeImageResourceProducer,\n+            BuildProducer<NotFoundPageDisplayableEndpointBuildItem> notFoundPageDisplayableEndpointProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            LaunchModeBuildItem launchMode,\n+            LiveReloadBuildItem liveReload,\n+            HttpRootPathBuildItem httpRootPath) throws Exception {\n+\n+        if (!quarkusConfig.enableUi) {\n+            return;\n+        }\n+        if (\"/\".equals(quarkusConfig.rootPathUi)) {\n+            throw new ConfigurationError(\n+                    \"quarkus.smallrye-graphql.root-path-ui was set to \\\"/\\\", this is not allowed as it blocks the application from serving anything else.\");\n+        }\n+\n+        String graphQLPath = httpRootPath.adjustPath(quarkusConfig.rootPath);\n+\n+        if (launchMode.getLaunchMode().isDevOrTest()) {\n+            CachedGraphQLUI cached = liveReload.getContextObject(CachedGraphQLUI.class);\n+            boolean extractionNeeded = cached == null;\n+\n+            if (cached != null && !cached.cachedGraphQLPath.equals(graphQLPath)) {\n+                try {\n+                    FileUtil.deleteDirectory(Paths.get(cached.cachedDirectory));\n+                } catch (IOException e) {\n+                    LOG.error(\"Failed to clean GraphQL UI temp directory on restart\", e);\n+                }\n+                extractionNeeded = true;\n+            }\n+            if (extractionNeeded) {\n+                if (cached == null) {\n+                    cached = new CachedGraphQLUI();\n+                    liveReload.setContextObject(CachedGraphQLUI.class, cached);\n+                    Runtime.getRuntime().addShutdownHook(new Thread(cached, \"GraphQL UI Shutdown Hook\"));\n+                }\n+                try {\n+                    ResolvedArtifact artifact = getGraphQLUiArtifact();\n+                    Path tempDir = Files.createTempDirectory(TEMP_DIR_PREFIX).toRealPath();\n+                    extractGraphQLUi(artifact, tempDir);\n+                    updateApiUrl(tempDir.resolve(FILE_TO_UPDATE), graphQLPath);\n+                    cached.cachedDirectory = tempDir.toAbsolutePath().toString();\n+                    cached.cachedGraphQLPath = graphQLPath;\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+            Handler<RoutingContext> handler = recorder.uiHandler(cached.cachedDirectory,\n+                    httpRootPath.adjustPath(quarkusConfig.rootPathUi));\n+            routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPathUi, handler));\n+            routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPathUi + \"/*\", handler));\n+            notFoundPageDisplayableEndpointProducer\n+                    .produce(new NotFoundPageDisplayableEndpointBuildItem(quarkusConfig.rootPathUi + \"/\"));\n+        } else if (quarkusConfig.alwaysIncludeUi) {\n+            ResolvedArtifact artifact = getGraphQLUiArtifact();\n+            //we are including in a production artifact\n+            //just stick the files in the generated output\n+            //we could do this for dev mode as well but then we need to extract them every time\n+            File artifactFile = artifact.getArtifactPath().toFile();\n+            try (JarFile jarFile = new JarFile(artifactFile)) {\n+                Enumeration<JarEntry> entries = jarFile.entries();\n+\n+                while (entries.hasMoreElements()) {\n+                    JarEntry entry = entries.nextElement();\n+                    if (entry.getName().startsWith(GRAPHQL_UI_WEBJAR_PREFIX) && !entry.isDirectory()) {\n+                        try (InputStream inputStream = jarFile.getInputStream(entry)) {\n+                            String filename = entry.getName().replace(GRAPHQL_UI_WEBJAR_PREFIX + \"/\", \"\");\n+                            byte[] content = FileUtil.readFileContents(inputStream);\n+                            if (entry.getName().endsWith(FILE_TO_UPDATE)) {\n+                                content = updateApiUrl(new String(content, StandardCharsets.UTF_8), graphQLPath)\n+                                        .getBytes(StandardCharsets.UTF_8);\n+                            }\n+                            if (IGNORE_LIST.contains(filename)) {\n+                                ClassLoader classLoader = SmallryeGraphqlProcessor.class.getClassLoader();\n+                                InputStream resourceAsStream = classLoader\n+                                        .getResourceAsStream(OWN_MEDIA_FOLDER + filename);\n+                                content = streamToByte(resourceAsStream);\n+                            }\n+\n+                            String fileName = GRAPHQL_UI_FINAL_DESTINATION + \"/\" + filename;\n+\n+                            generatedResourceProducer\n+                                    .produce(new GeneratedResourceBuildItem(fileName, content));\n+\n+                            nativeImageResourceProducer\n+                                    .produce(new NativeImageResourceBuildItem(fileName));\n+\n+                        }\n+                    }\n+                }\n+            }\n+\n+            Handler<RoutingContext> handler = recorder\n+                    .uiHandler(GRAPHQL_UI_FINAL_DESTINATION, httpRootPath.adjustPath(quarkusConfig.rootPathUi));\n+            routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPathUi, handler));\n+            routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPathUi + \"/*\", handler));\n+        }\n+    }\n+\n+    private byte[] streamToByte(InputStream is) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ff8048310e426e6220807cb3e94d20c7c3566e3"}, "originalPosition": 315}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MzA1OTkw", "url": "https://github.com/quarkusio/quarkus/pull/9144#pullrequestreview-407305990", "createdAt": "2020-05-07T09:34:22Z", "commit": {"oid": "9116b680e0a81cefb277d3d4d2b82af8e1631ba5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTozNDoyM1rOGR2c9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTozNDoyM1rOGR2c9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3MTEyNg==", "bodyText": "I am getting a compile error now, seems you forgot to commit this class after extracting it", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r421371126", "createdAt": "2020-05-07T09:34:23Z", "author": {"login": "jmartisk"}, "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,376 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ */\n+public class SmallryeGraphqlProcessor {\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    // For the UI\n+    private static final String GRAPHQL_UI_WEBJAR_GROUP_ID = \"io.smallrye\";\n+    private static final String GRAPHQL_UI_WEBJAR_ARTIFACT_ID = \"smallrye-graphql-ui-graphiql\";\n+    private static final String GRAPHQL_UI_WEBJAR_PREFIX = \"META-INF/resources/graphql-ui\";\n+    private static final String OWN_MEDIA_FOLDER = \"META-INF/resources/\";\n+    private static final String GRAPHQL_UI_FINAL_DESTINATION = \"META-INF/graphql-ui-files\";\n+    private static final String TEMP_DIR_PREFIX = \"quarkus-graphql-ui_\" + System.nanoTime();\n+    private static final List<String> IGNORE_LIST = Arrays.asList(new String[] { \"logo.png\", \"favicon.ico\" });\n+    private static final String FILE_TO_UPDATE = \"render.js\";\n+\n+    SmallRyeGraphQLConfig quarkusConfig;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9116b680e0a81cefb277d3d4d2b82af8e1631ba5"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4ODE3MDY1", "url": "https://github.com/quarkusio/quarkus/pull/9144#pullrequestreview-408817065", "createdAt": "2020-05-11T01:52:46Z", "commit": {"oid": "0092cb643cee66fbde04d9bedf9b48e99439f28b"}, "state": "DISMISSED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwMTo1Mjo0NlrOGTKA-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwMjozNjo1MFrOGTKknw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc0MDIxNw==", "bodyText": "What is the purpose of this? Class.forName(GraphQLProducer.class.getName()) is equivalent to GraphQLProducer.class.", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r422740217", "createdAt": "2020-05-11T01:52:46Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,373 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.IoUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ */\n+public class SmallryeGraphqlProcessor {\n+    private static final Logger log = Logger.getLogger(SmallryeGraphqlProcessor.class);\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    // For the UI\n+    private static final String GRAPHQL_UI_WEBJAR_GROUP_ID = \"io.smallrye\";\n+    private static final String GRAPHQL_UI_WEBJAR_ARTIFACT_ID = \"smallrye-graphql-ui-graphiql\";\n+    private static final String GRAPHQL_UI_WEBJAR_PREFIX = \"META-INF/resources/graphql-ui\";\n+    private static final String OWN_MEDIA_FOLDER = \"META-INF/resources/\";\n+    private static final String GRAPHQL_UI_FINAL_DESTINATION = \"META-INF/graphql-ui-files\";\n+    private static final String TEMP_DIR_PREFIX = \"quarkus-graphql-ui_\" + System.nanoTime();\n+    private static final List<String> IGNORE_LIST = Arrays.asList(new String[] { \"logo.png\", \"favicon.ico\" });\n+    private static final String FILE_TO_UPDATE = \"render.js\";\n+\n+    SmallRyeGraphQLConfig quarkusConfig;\n+\n+    @BuildStep\n+    void feature(BuildProducer<FeatureBuildItem> featureProducer) {\n+        featureProducer.produce(new FeatureBuildItem(FeatureBuildItem.SMALLRYE_GRAPHQL));\n+    }\n+\n+    @BuildStep\n+    void additionalBeanDefiningAnnotation(BuildProducer<BeanDefiningAnnotationBuildItem> beanDefiningAnnotationProducer) {\n+        // Make ArC discover the beans marked with the @GraphQlApi qualifier\n+        beanDefiningAnnotationProducer.produce(new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API));\n+    }\n+\n+    @BuildStep\n+    void additionalBean(BuildProducer<AdditionalBeanBuildItem> additionalBeanProducer) {\n+        additionalBeanProducer.produce(AdditionalBeanBuildItem.builder()\n+                .addBeanClass(GraphQLConfig.class)\n+                .addBeanClass(GraphQLProducer.class)\n+                .setUnremovable().build());\n+    }\n+\n+    @BuildStep\n+    void registerNativeImageResources(BuildProducer<ServiceProviderBuildItem> serviceProvider) throws IOException {\n+        // Lookup Service (We use the one from the CDI Module)\n+        String lookupService = SPI_PATH + LookupService.class.getName();\n+        Set<String> lookupImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                lookupService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(LookupService.class.getName(), lookupImplementations.toArray(new String[0])));\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildExecutionService(BuildProducer<ReflectiveClassBuildItem> reflectiveClassProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            BeanContainerBuildItem beanContainer,\n+            CombinedIndexBuildItem combinedIndex) {\n+\n+        IndexView index = combinedIndex.getIndex();\n+        Schema schema = SchemaBuilder.build(index);\n+\n+        try {\n+            Class<GraphQLProducer> beanClass = (Class<GraphQLProducer>) Class", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0092cb643cee66fbde04d9bedf9b48e99439f28b"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc0MDk3NQ==", "bodyText": "Are you sure you don't need ReflectiveHierachyBuildItem here? ReflectiveClassBuildItem just registers the type, it won't register superclases, and it won't register types used by methods/fields (so a complex return type from a method would not be registered).\nI am not sure exactly how these classes are used, so maybe this is fine, but just something to be aware of.", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r422740975", "createdAt": "2020-05-11T01:56:26Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,373 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.IoUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ */\n+public class SmallryeGraphqlProcessor {\n+    private static final Logger log = Logger.getLogger(SmallryeGraphqlProcessor.class);\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    // For the UI\n+    private static final String GRAPHQL_UI_WEBJAR_GROUP_ID = \"io.smallrye\";\n+    private static final String GRAPHQL_UI_WEBJAR_ARTIFACT_ID = \"smallrye-graphql-ui-graphiql\";\n+    private static final String GRAPHQL_UI_WEBJAR_PREFIX = \"META-INF/resources/graphql-ui\";\n+    private static final String OWN_MEDIA_FOLDER = \"META-INF/resources/\";\n+    private static final String GRAPHQL_UI_FINAL_DESTINATION = \"META-INF/graphql-ui-files\";\n+    private static final String TEMP_DIR_PREFIX = \"quarkus-graphql-ui_\" + System.nanoTime();\n+    private static final List<String> IGNORE_LIST = Arrays.asList(new String[] { \"logo.png\", \"favicon.ico\" });\n+    private static final String FILE_TO_UPDATE = \"render.js\";\n+\n+    SmallRyeGraphQLConfig quarkusConfig;\n+\n+    @BuildStep\n+    void feature(BuildProducer<FeatureBuildItem> featureProducer) {\n+        featureProducer.produce(new FeatureBuildItem(FeatureBuildItem.SMALLRYE_GRAPHQL));\n+    }\n+\n+    @BuildStep\n+    void additionalBeanDefiningAnnotation(BuildProducer<BeanDefiningAnnotationBuildItem> beanDefiningAnnotationProducer) {\n+        // Make ArC discover the beans marked with the @GraphQlApi qualifier\n+        beanDefiningAnnotationProducer.produce(new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API));\n+    }\n+\n+    @BuildStep\n+    void additionalBean(BuildProducer<AdditionalBeanBuildItem> additionalBeanProducer) {\n+        additionalBeanProducer.produce(AdditionalBeanBuildItem.builder()\n+                .addBeanClass(GraphQLConfig.class)\n+                .addBeanClass(GraphQLProducer.class)\n+                .setUnremovable().build());\n+    }\n+\n+    @BuildStep\n+    void registerNativeImageResources(BuildProducer<ServiceProviderBuildItem> serviceProvider) throws IOException {\n+        // Lookup Service (We use the one from the CDI Module)\n+        String lookupService = SPI_PATH + LookupService.class.getName();\n+        Set<String> lookupImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                lookupService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(LookupService.class.getName(), lookupImplementations.toArray(new String[0])));\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildExecutionService(BuildProducer<ReflectiveClassBuildItem> reflectiveClassProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            BeanContainerBuildItem beanContainer,\n+            CombinedIndexBuildItem combinedIndex) {\n+\n+        IndexView index = combinedIndex.getIndex();\n+        Schema schema = SchemaBuilder.build(index);\n+\n+        try {\n+            Class<GraphQLProducer> beanClass = (Class<GraphQLProducer>) Class\n+                    .forName(GraphQLProducer.class.getName());\n+            recorder.createExecutionService(beanContainer.getValue(), beanClass, schema);\n+        } catch (ClassNotFoundException ex) {\n+            log.warn(\"Failed to load GraphQLProducer\", ex);\n+        }\n+\n+        // Make sure the complex object from the application can work in native mode\n+        reflectiveClassProducer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0092cb643cee66fbde04d9bedf9b48e99439f28b"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc0MjE2Ng==", "bodyText": "This should be in a try with resources block.", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r422742166", "createdAt": "2020-05-11T02:01:59Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/smallrye-graphql/deployment/src/main/java/io/quarkus/smallrye/graphql/deployment/SmallryeGraphqlProcessor.java", "diffHunk": "@@ -0,0 +1,373 @@\n+package io.quarkus.smallrye.graphql.deployment;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.jboss.jandex.IndexView;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.arc.deployment.BeanContainerBuildItem;\n+import io.quarkus.arc.deployment.BeanDefiningAnnotationBuildItem;\n+import io.quarkus.deployment.annotations.BuildProducer;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.deployment.annotations.ExecutionTime;\n+import io.quarkus.deployment.annotations.Record;\n+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;\n+import io.quarkus.deployment.builditem.FeatureBuildItem;\n+import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;\n+import io.quarkus.deployment.builditem.LaunchModeBuildItem;\n+import io.quarkus.deployment.builditem.LiveReloadBuildItem;\n+import io.quarkus.deployment.builditem.ShutdownContextBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.NativeImageResourceBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;\n+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;\n+import io.quarkus.deployment.configuration.ConfigurationError;\n+import io.quarkus.deployment.index.ClassPathArtifactResolver;\n+import io.quarkus.deployment.index.ResolvedArtifact;\n+import io.quarkus.deployment.util.FileUtil;\n+import io.quarkus.deployment.util.IoUtil;\n+import io.quarkus.deployment.util.ServiceUtil;\n+import io.quarkus.runtime.LaunchMode;\n+import io.quarkus.smallrye.graphql.runtime.SmallRyeGraphQLRecorder;\n+import io.quarkus.vertx.http.deployment.HttpRootPathBuildItem;\n+import io.quarkus.vertx.http.deployment.RequireBodyHandlerBuildItem;\n+import io.quarkus.vertx.http.deployment.RouteBuildItem;\n+import io.quarkus.vertx.http.deployment.devmode.NotFoundPageDisplayableEndpointBuildItem;\n+import io.quarkus.vertx.http.runtime.HandlerType;\n+import io.smallrye.graphql.cdi.config.ConfigKey;\n+import io.smallrye.graphql.cdi.config.GraphQLConfig;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.Annotations;\n+import io.smallrye.graphql.schema.SchemaBuilder;\n+import io.smallrye.graphql.schema.model.Operation;\n+import io.smallrye.graphql.schema.model.Reference;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.smallrye.graphql.spi.LookupService;\n+import io.vertx.core.Handler;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Processor for Smallrye GraphQL.\n+ * We scan all annotations and build the model during build.\n+ */\n+public class SmallryeGraphqlProcessor {\n+    private static final Logger log = Logger.getLogger(SmallryeGraphqlProcessor.class);\n+\n+    private static final Logger LOG = Logger.getLogger(SmallryeGraphqlProcessor.class.getName());\n+    private static final String SCHEMA_PATH = \"/schema.graphql\";\n+    private static final String SPI_PATH = \"META-INF/services/\";\n+\n+    // For the UI\n+    private static final String GRAPHQL_UI_WEBJAR_GROUP_ID = \"io.smallrye\";\n+    private static final String GRAPHQL_UI_WEBJAR_ARTIFACT_ID = \"smallrye-graphql-ui-graphiql\";\n+    private static final String GRAPHQL_UI_WEBJAR_PREFIX = \"META-INF/resources/graphql-ui\";\n+    private static final String OWN_MEDIA_FOLDER = \"META-INF/resources/\";\n+    private static final String GRAPHQL_UI_FINAL_DESTINATION = \"META-INF/graphql-ui-files\";\n+    private static final String TEMP_DIR_PREFIX = \"quarkus-graphql-ui_\" + System.nanoTime();\n+    private static final List<String> IGNORE_LIST = Arrays.asList(new String[] { \"logo.png\", \"favicon.ico\" });\n+    private static final String FILE_TO_UPDATE = \"render.js\";\n+\n+    SmallRyeGraphQLConfig quarkusConfig;\n+\n+    @BuildStep\n+    void feature(BuildProducer<FeatureBuildItem> featureProducer) {\n+        featureProducer.produce(new FeatureBuildItem(FeatureBuildItem.SMALLRYE_GRAPHQL));\n+    }\n+\n+    @BuildStep\n+    void additionalBeanDefiningAnnotation(BuildProducer<BeanDefiningAnnotationBuildItem> beanDefiningAnnotationProducer) {\n+        // Make ArC discover the beans marked with the @GraphQlApi qualifier\n+        beanDefiningAnnotationProducer.produce(new BeanDefiningAnnotationBuildItem(Annotations.GRAPHQL_API));\n+    }\n+\n+    @BuildStep\n+    void additionalBean(BuildProducer<AdditionalBeanBuildItem> additionalBeanProducer) {\n+        additionalBeanProducer.produce(AdditionalBeanBuildItem.builder()\n+                .addBeanClass(GraphQLConfig.class)\n+                .addBeanClass(GraphQLProducer.class)\n+                .setUnremovable().build());\n+    }\n+\n+    @BuildStep\n+    void registerNativeImageResources(BuildProducer<ServiceProviderBuildItem> serviceProvider) throws IOException {\n+        // Lookup Service (We use the one from the CDI Module)\n+        String lookupService = SPI_PATH + LookupService.class.getName();\n+        Set<String> lookupImplementations = ServiceUtil.classNamesNamedIn(Thread.currentThread().getContextClassLoader(),\n+                lookupService);\n+        serviceProvider.produce(\n+                new ServiceProviderBuildItem(LookupService.class.getName(), lookupImplementations.toArray(new String[0])));\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildExecutionService(BuildProducer<ReflectiveClassBuildItem> reflectiveClassProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            BeanContainerBuildItem beanContainer,\n+            CombinedIndexBuildItem combinedIndex) {\n+\n+        IndexView index = combinedIndex.getIndex();\n+        Schema schema = SchemaBuilder.build(index);\n+\n+        try {\n+            Class<GraphQLProducer> beanClass = (Class<GraphQLProducer>) Class\n+                    .forName(GraphQLProducer.class.getName());\n+            recorder.createExecutionService(beanContainer.getValue(), beanClass, schema);\n+        } catch (ClassNotFoundException ex) {\n+            log.warn(\"Failed to load GraphQLProducer\", ex);\n+        }\n+\n+        // Make sure the complex object from the application can work in native mode\n+        reflectiveClassProducer\n+                .produce(new ReflectiveClassBuildItem(true, true, getClassesToRegisterForReflection(schema)));\n+    }\n+\n+    @Record(ExecutionTime.STATIC_INIT)\n+    @BuildStep\n+    void buildEndpoints(\n+            BuildProducer<RequireBodyHandlerBuildItem> requireBodyHandlerProducer,\n+            BuildProducer<RouteBuildItem> routeProducer,\n+            BuildProducer<NotFoundPageDisplayableEndpointBuildItem> notFoundPageDisplayableEndpointProducer,\n+            LaunchModeBuildItem launchMode,\n+            SmallRyeGraphQLRecorder recorder,\n+            ShutdownContextBuildItem shutdownContext) throws IOException {\n+\n+        /*\n+         * <em>Ugly Hack</em>\n+         * In dev mode, we pass a classloader to use in the CDI Loader.\n+         * This hack is required because using the TCCL would get an outdated version - the initial one.\n+         * This is because the worker thread on which the handler is called captures the TCCL at creation time\n+         * and does not allow updating it.\n+         *\n+         * In non dev mode, the TCCL is used.\n+         */\n+        if (launchMode.getLaunchMode() == LaunchMode.DEVELOPMENT) {\n+            recorder.setupClDevMode(shutdownContext);\n+        }\n+        // add graphql endpoint for not found display in dev or test mode\n+        if (launchMode.getLaunchMode().isDevOrTest()) {\n+            notFoundPageDisplayableEndpointProducer\n+                    .produce(new NotFoundPageDisplayableEndpointBuildItem(quarkusConfig.rootPath));\n+            notFoundPageDisplayableEndpointProducer\n+                    .produce(new NotFoundPageDisplayableEndpointBuildItem(quarkusConfig.rootPath + SCHEMA_PATH));\n+        }\n+\n+        Boolean allowGet = ConfigProvider.getConfig().getOptionalValue(ConfigKey.ALLOW_GET, boolean.class).orElse(false);\n+\n+        Handler<RoutingContext> executionHandler = recorder.executionHandler(allowGet);\n+        routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPath, executionHandler, HandlerType.BLOCKING));\n+\n+        Handler<RoutingContext> schemaHandler = recorder.schemaHandler();\n+        routeProducer.produce(\n+                new RouteBuildItem(quarkusConfig.rootPath + SCHEMA_PATH, schemaHandler, HandlerType.BLOCKING));\n+\n+        // Because we need to read the body\n+        requireBodyHandlerProducer.produce(new RequireBodyHandlerBuildItem());\n+\n+    }\n+\n+    private String[] getClassesToRegisterForReflection(Schema schema) {\n+        // Unique list of classes we need to do reflection on\n+        Set<String> classes = new HashSet<>();\n+\n+        classes.addAll(getOperationClassNames(schema.getQueries()));\n+        classes.addAll(getOperationClassNames(schema.getMutations()));\n+        classes.addAll(getReferenceClassNames(schema.getTypes().values()));\n+        classes.addAll(getReferenceClassNames(schema.getInputs().values()));\n+        classes.addAll(getReferenceClassNames(schema.getInterfaces().values()));\n+\n+        String[] arrayOfClassNames = classes.toArray(new String[] {});\n+        return arrayOfClassNames;\n+    }\n+\n+    private Set<String> getOperationClassNames(Set<Operation> operations) {\n+        Set<String> classes = new HashSet<>();\n+        for (Operation operation : operations) {\n+            classes.add(operation.getClassName());\n+        }\n+        return classes;\n+    }\n+\n+    private Set<String> getReferenceClassNames(Collection complexGraphQLTypes) {\n+        Set<String> classes = new HashSet<>();\n+        for (Object complexGraphQLType : complexGraphQLTypes) {\n+            Reference reference = Reference.class.cast(complexGraphQLType);\n+            classes.add(reference.getClassName());\n+        }\n+        return classes;\n+    }\n+\n+    @BuildStep\n+    @Record(ExecutionTime.STATIC_INIT)\n+    void registerGraphQLUiServletExtension(\n+            BuildProducer<RouteBuildItem> routeProducer,\n+            BuildProducer<GeneratedResourceBuildItem> generatedResourceProducer,\n+            BuildProducer<NativeImageResourceBuildItem> nativeImageResourceProducer,\n+            BuildProducer<NotFoundPageDisplayableEndpointBuildItem> notFoundPageDisplayableEndpointProducer,\n+            SmallRyeGraphQLRecorder recorder,\n+            LaunchModeBuildItem launchMode,\n+            LiveReloadBuildItem liveReload,\n+            HttpRootPathBuildItem httpRootPath) throws Exception {\n+\n+        if (!quarkusConfig.enableUi) {\n+            return;\n+        }\n+        if (\"/\".equals(quarkusConfig.rootPathUi)) {\n+            throw new ConfigurationError(\n+                    \"quarkus.smallrye-graphql.root-path-ui was set to \\\"/\\\", this is not allowed as it blocks the application from serving anything else.\");\n+        }\n+\n+        String graphQLPath = httpRootPath.adjustPath(quarkusConfig.rootPath);\n+\n+        if (launchMode.getLaunchMode().isDevOrTest()) {\n+            CachedGraphQLUI cached = liveReload.getContextObject(CachedGraphQLUI.class);\n+            boolean extractionNeeded = cached == null;\n+\n+            if (cached != null && !cached.cachedGraphQLPath.equals(graphQLPath)) {\n+                try {\n+                    FileUtil.deleteDirectory(Paths.get(cached.cachedDirectory));\n+                } catch (IOException e) {\n+                    LOG.error(\"Failed to clean GraphQL UI temp directory on restart\", e);\n+                }\n+                extractionNeeded = true;\n+            }\n+            if (extractionNeeded) {\n+                if (cached == null) {\n+                    cached = new CachedGraphQLUI();\n+                    liveReload.setContextObject(CachedGraphQLUI.class, cached);\n+                    Runtime.getRuntime().addShutdownHook(new Thread(cached, \"GraphQL UI Shutdown Hook\"));\n+                }\n+                try {\n+                    ResolvedArtifact artifact = getGraphQLUiArtifact();\n+                    Path tempDir = Files.createTempDirectory(TEMP_DIR_PREFIX).toRealPath();\n+                    extractGraphQLUi(artifact, tempDir);\n+                    updateApiUrl(tempDir.resolve(FILE_TO_UPDATE), graphQLPath);\n+                    cached.cachedDirectory = tempDir.toAbsolutePath().toString();\n+                    cached.cachedGraphQLPath = graphQLPath;\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+            Handler<RoutingContext> handler = recorder.uiHandler(cached.cachedDirectory,\n+                    httpRootPath.adjustPath(quarkusConfig.rootPathUi));\n+            routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPathUi, handler));\n+            routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPathUi + \"/*\", handler));\n+            notFoundPageDisplayableEndpointProducer\n+                    .produce(new NotFoundPageDisplayableEndpointBuildItem(quarkusConfig.rootPathUi + \"/\"));\n+        } else if (quarkusConfig.alwaysIncludeUi) {\n+            ResolvedArtifact artifact = getGraphQLUiArtifact();\n+            //we are including in a production artifact\n+            //just stick the files in the generated output\n+            //we could do this for dev mode as well but then we need to extract them every time\n+            File artifactFile = artifact.getArtifactPath().toFile();\n+            try (JarFile jarFile = new JarFile(artifactFile)) {\n+                Enumeration<JarEntry> entries = jarFile.entries();\n+\n+                while (entries.hasMoreElements()) {\n+                    JarEntry entry = entries.nextElement();\n+                    if (entry.getName().startsWith(GRAPHQL_UI_WEBJAR_PREFIX) && !entry.isDirectory()) {\n+                        try (InputStream inputStream = jarFile.getInputStream(entry)) {\n+                            String filename = entry.getName().replace(GRAPHQL_UI_WEBJAR_PREFIX + \"/\", \"\");\n+                            byte[] content = FileUtil.readFileContents(inputStream);\n+                            if (entry.getName().endsWith(FILE_TO_UPDATE)) {\n+                                content = updateApiUrl(new String(content, StandardCharsets.UTF_8), graphQLPath)\n+                                        .getBytes(StandardCharsets.UTF_8);\n+                            }\n+                            if (IGNORE_LIST.contains(filename)) {\n+                                ClassLoader classLoader = SmallryeGraphqlProcessor.class.getClassLoader();\n+                                InputStream resourceAsStream = classLoader\n+                                        .getResourceAsStream(OWN_MEDIA_FOLDER + filename);\n+                                content = IoUtil.readBytes(resourceAsStream);\n+                            }\n+\n+                            String fileName = GRAPHQL_UI_FINAL_DESTINATION + \"/\" + filename;\n+\n+                            generatedResourceProducer\n+                                    .produce(new GeneratedResourceBuildItem(fileName, content));\n+\n+                            nativeImageResourceProducer\n+                                    .produce(new NativeImageResourceBuildItem(fileName));\n+\n+                        }\n+                    }\n+                }\n+            }\n+\n+            Handler<RoutingContext> handler = recorder\n+                    .uiHandler(GRAPHQL_UI_FINAL_DESTINATION, httpRootPath.adjustPath(quarkusConfig.rootPathUi));\n+            routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPathUi, handler));\n+            routeProducer.produce(new RouteBuildItem(quarkusConfig.rootPathUi + \"/*\", handler));\n+        }\n+    }\n+\n+    private ResolvedArtifact getGraphQLUiArtifact() {\n+        ClassPathArtifactResolver resolver = new ClassPathArtifactResolver(SmallryeGraphqlProcessor.class.getClassLoader());\n+        return resolver.getArtifact(GRAPHQL_UI_WEBJAR_GROUP_ID, GRAPHQL_UI_WEBJAR_ARTIFACT_ID, null);\n+    }\n+\n+    private void extractGraphQLUi(ResolvedArtifact artifact, Path resourceDir) throws IOException {\n+        File artifactFile = artifact.getArtifactPath().toFile();\n+        try (JarFile jarFile = new JarFile(artifactFile)) {\n+            Enumeration<JarEntry> entries = jarFile.entries();\n+\n+            while (entries.hasMoreElements()) {\n+                JarEntry entry = entries.nextElement();\n+                if (entry.getName().startsWith(GRAPHQL_UI_WEBJAR_PREFIX) && !entry.isDirectory()) {\n+                    try (InputStream inputStream = jarFile.getInputStream(entry)) {\n+                        String filename = entry.getName().replace(GRAPHQL_UI_WEBJAR_PREFIX + \"/\", \"\");\n+                        if (!IGNORE_LIST.contains(filename)) {\n+                            Files.copy(inputStream, resourceDir.resolve(filename));\n+                        }\n+                    }\n+                }\n+            }\n+            // Now add our own logo and favicon\n+            ClassLoader classLoader = SmallryeGraphqlProcessor.class.getClassLoader();\n+            for (String ownMedia : IGNORE_LIST) {\n+                InputStream logo = classLoader.getResourceAsStream(OWN_MEDIA_FOLDER + ownMedia);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0092cb643cee66fbde04d9bedf9b48e99439f28b"}, "originalPosition": 341}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc0ODI0NA==", "bodyText": "I don't think you need to bother with the status messages, they are not supported with HTTP/2 and are generally considered to have been a bad idea. We don't want to encourage their use as they are basically deprecated.", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r422748244", "createdAt": "2020-05-11T02:31:31Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/smallrye-graphql/runtime/src/main/java/io/quarkus/smallrye/graphql/runtime/SmallRyeGraphQLExecutionHandler.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package io.quarkus.smallrye.graphql.runtime;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.util.List;\n+\n+import javax.enterprise.inject.spi.CDI;\n+import javax.json.Json;\n+import javax.json.JsonObject;\n+import javax.json.JsonReader;\n+import javax.json.JsonWriter;\n+\n+import io.smallrye.graphql.execution.ExecutionService;\n+import io.vertx.core.Handler;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.http.HttpServerRequest;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Handler that does the execution of GraphQL Requests\n+ */\n+public class SmallRyeGraphQLExecutionHandler implements Handler<RoutingContext> {\n+    private static boolean allowGet = false;\n+    private static final String QUERY = \"query\";\n+    private static final String OK = \"OK\";\n+\n+    public SmallRyeGraphQLExecutionHandler(boolean allowGet) {\n+        this.allowGet = allowGet;\n+    }\n+\n+    @Override\n+    public void handle(final RoutingContext ctx) {\n+        HttpServerRequest request = ctx.request();\n+        HttpServerResponse response = ctx.response();\n+\n+        response.headers().set(HttpHeaders.CONTENT_TYPE, \"application/json; charset=UTF-8\");\n+\n+        switch (request.method()) {\n+            case OPTIONS:\n+                response.headers().set(HttpHeaders.ALLOW, getAllowedMethods());\n+                response.setStatusCode(200)\n+                        .setStatusMessage(OK)\n+                        .end();\n+                break;\n+            case POST:\n+                String graphqlPostRequest = ctx.getBodyAsString();\n+                String postResponse = doRequest(graphqlPostRequest);\n+                response.setStatusCode(200)\n+                        .setStatusMessage(OK)\n+                        .end(Buffer.buffer(postResponse));\n+                break;\n+            case GET:\n+                if (allowGet) {\n+                    List<String> queries = ctx.queryParam(QUERY);\n+                    if (queries != null && !queries.isEmpty()) {\n+                        String graphqlGetRequest = queries.get(0);\n+                        String getResponse = doRequest(graphqlGetRequest);\n+                        response.setStatusCode(200)\n+                                .setStatusMessage(OK)\n+                                .end(Buffer.buffer(getResponse));\n+                    } else {\n+                        response.setStatusCode(204).setStatusMessage(\"Provide a query parameter\").end();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0092cb643cee66fbde04d9bedf9b48e99439f28b"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc0ODQ2Mg==", "bodyText": "You probably want to cache this in a volatile variable. CDI.current().select() is relatively expensive.", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r422748462", "createdAt": "2020-05-11T02:32:43Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/smallrye-graphql/runtime/src/main/java/io/quarkus/smallrye/graphql/runtime/SmallRyeGraphQLExecutionHandler.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package io.quarkus.smallrye.graphql.runtime;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.util.List;\n+\n+import javax.enterprise.inject.spi.CDI;\n+import javax.json.Json;\n+import javax.json.JsonObject;\n+import javax.json.JsonReader;\n+import javax.json.JsonWriter;\n+\n+import io.smallrye.graphql.execution.ExecutionService;\n+import io.vertx.core.Handler;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.http.HttpServerRequest;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * Handler that does the execution of GraphQL Requests\n+ */\n+public class SmallRyeGraphQLExecutionHandler implements Handler<RoutingContext> {\n+    private static boolean allowGet = false;\n+    private static final String QUERY = \"query\";\n+    private static final String OK = \"OK\";\n+\n+    public SmallRyeGraphQLExecutionHandler(boolean allowGet) {\n+        this.allowGet = allowGet;\n+    }\n+\n+    @Override\n+    public void handle(final RoutingContext ctx) {\n+        HttpServerRequest request = ctx.request();\n+        HttpServerResponse response = ctx.response();\n+\n+        response.headers().set(HttpHeaders.CONTENT_TYPE, \"application/json; charset=UTF-8\");\n+\n+        switch (request.method()) {\n+            case OPTIONS:\n+                response.headers().set(HttpHeaders.ALLOW, getAllowedMethods());\n+                response.setStatusCode(200)\n+                        .setStatusMessage(OK)\n+                        .end();\n+                break;\n+            case POST:\n+                String graphqlPostRequest = ctx.getBodyAsString();\n+                String postResponse = doRequest(graphqlPostRequest);\n+                response.setStatusCode(200)\n+                        .setStatusMessage(OK)\n+                        .end(Buffer.buffer(postResponse));\n+                break;\n+            case GET:\n+                if (allowGet) {\n+                    List<String> queries = ctx.queryParam(QUERY);\n+                    if (queries != null && !queries.isEmpty()) {\n+                        String graphqlGetRequest = queries.get(0);\n+                        String getResponse = doRequest(graphqlGetRequest);\n+                        response.setStatusCode(200)\n+                                .setStatusMessage(OK)\n+                                .end(Buffer.buffer(getResponse));\n+                    } else {\n+                        response.setStatusCode(204).setStatusMessage(\"Provide a query parameter\").end();\n+                    }\n+                } else {\n+                    response.setStatusCode(405).setStatusMessage(\"GET Queries is not enabled\").end();\n+                }\n+                break;\n+            default:\n+                response.setStatusCode(405).setStatusMessage(request.method() + \" Method is not supported\").end();\n+                break;\n+        }\n+    }\n+\n+    private String getAllowedMethods() {\n+        if (allowGet) {\n+            return \"GET, POST, OPTIONS\";\n+        } else {\n+            return \"POST, OPTIONS\";\n+        }\n+    }\n+\n+    private String doRequest(final String body) {\n+        try (StringReader input = new StringReader(body);\n+                final JsonReader jsonReader = Json.createReader(input)) {\n+            JsonObject jsonInput = jsonReader.readObject();\n+            ExecutionService executionService = CDI.current().select(ExecutionService.class).get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0092cb643cee66fbde04d9bedf9b48e99439f28b"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc0OTM0Mw==", "bodyText": "Why do you pass the bean class in like this, when it is hard coded anyway? Why not just use GraphQLProducer.class?", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r422749343", "createdAt": "2020-05-11T02:36:50Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/smallrye-graphql/runtime/src/main/java/io/quarkus/smallrye/graphql/runtime/SmallRyeGraphQLRecorder.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package io.quarkus.smallrye.graphql.runtime;\n+\n+import java.util.function.Supplier;\n+\n+import io.quarkus.arc.runtime.BeanContainer;\n+import io.quarkus.runtime.ShutdownContext;\n+import io.quarkus.runtime.annotations.Recorder;\n+import io.quarkus.smallrye.graphql.runtime.spi.QuarkusClassloadingService;\n+import io.quarkus.vertx.http.runtime.ThreadLocalHandler;\n+import io.smallrye.graphql.cdi.producer.GraphQLProducer;\n+import io.smallrye.graphql.schema.model.Schema;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.ext.web.RoutingContext;\n+import io.vertx.ext.web.handler.StaticHandler;\n+\n+@Recorder\n+public class SmallRyeGraphQLRecorder {\n+\n+    public void createExecutionService(BeanContainer beanContainer, Class<GraphQLProducer> beanClass, Schema schema) {\n+        GraphQLProducer graphQLProducer = beanContainer.instance(beanClass);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0092cb643cee66fbde04d9bedf9b48e99439f28b"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNjE0Nzg5", "url": "https://github.com/quarkusio/quarkus/pull/9144#pullrequestreview-410614789", "createdAt": "2020-05-13T06:14:43Z", "commit": {"oid": "1af8aee9e7f8f83389af52e3a75c34a0220087b1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNjoxNDo0M1rOGUizoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNjoxNDo0M1rOGUizoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE5NDk3Nw==", "bodyText": "This file shouldn't be here. Perhaps add a nbactions.xml entry to .gitignore?", "url": "https://github.com/quarkusio/quarkus/pull/9144#discussion_r424194977", "createdAt": "2020-05-13T06:14:43Z", "author": {"login": "jmartisk"}, "path": "integration-tests/smallrye-graphql/nbactions.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1af8aee9e7f8f83389af52e3a75c34a0220087b1"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwODE1OTQ0", "url": "https://github.com/quarkusio/quarkus/pull/9144#pullrequestreview-410815944", "createdAt": "2020-05-13T11:04:08Z", "commit": {"oid": "8290edc7867402acb1ec37502ed6dcd9385f9b75"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwOTE1MDc5", "url": "https://github.com/quarkusio/quarkus/pull/9144#pullrequestreview-410915079", "createdAt": "2020-05-13T13:19:39Z", "commit": {"oid": "8290edc7867402acb1ec37502ed6dcd9385f9b75"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c1d024dc2102d342a52b4b27f052836dcdc96be", "author": {"user": {"login": "phillip-kruger", "name": "Phillip Kr\u00fcger"}}, "url": "https://github.com/quarkusio/quarkus/commit/5c1d024dc2102d342a52b4b27f052836dcdc96be", "committedDate": "2020-05-14T13:20:37Z", "message": "Adding SmallRye GraphQL Extension\n\nSigned-off-by: Phillip Kruger <phillip.kruger@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8b2b258f15ad6ca9be9fba2994cae7422b79f05", "author": {"user": {"login": "gsmet", "name": "Guillaume Smet"}}, "url": "https://github.com/quarkusio/quarkus/commit/e8b2b258f15ad6ca9be9fba2994cae7422b79f05", "committedDate": "2020-05-14T13:21:46Z", "message": "Add GraphQL to the native workflow and reorganize things a bit\n\nAlso the Vault native tests weren't running at all. I hope they are not\nfailing..."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3347, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}