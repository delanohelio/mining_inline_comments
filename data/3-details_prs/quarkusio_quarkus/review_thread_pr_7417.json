{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5NjMyNDQ4", "number": 7417, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMToxMjowM1rODjCUDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMjo0NjozNVrOD4Bu7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MDY0NjU1OnYy", "diffSide": "RIGHT", "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/SaslConfig.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMToxMjowNFrOFunibg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOToyMjoyMVrOFvKldg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNjYwNg==", "bodyText": "Why is this a string, shouldn't it be rather a double (some for some more props below)?", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r384426606", "createdAt": "2020-02-26T11:12:04Z", "author": {"login": "gunnarmorling"}, "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/SaslConfig.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package io.quarkus.kafka.streams.runtime;\n+\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+@ConfigGroup\n+public class SaslConfig {\n+\n+    /**\n+     * JAAS login context parameters for SASL connections in the format used by JAAS configuration files\n+     */\n+    @ConfigItem(name = \"jaas.config\")\n+    public Optional<String> jaasConfig;\n+\n+    /**\n+     * The fully qualified name of a SASL client callback handler class\n+     */\n+    @ConfigItem(name = \"client.callback.handler.class\")\n+    public Optional<String> clientCallbackHandlerClass;\n+\n+    /**\n+     * The fully qualified name of a SASL login callback handler class\n+     */\n+    @ConfigItem(name = \"login.callback.handler.class\")\n+    public Optional<String> loginCallbackHandlerClass;\n+\n+    /**\n+     * The fully qualified name of a class that implements the Login interface\n+     */\n+    @ConfigItem(name = \"login.class\")\n+    public Optional<String> loginClass;\n+\n+    /**\n+     * The Kerberos principal name that Kafka runs as\n+     */\n+    @ConfigItem(name = \"kerberos.service.name\")\n+    public Optional<String> kerberosServiceName;\n+\n+    /**\n+     * Kerberos kinit command path\n+     */\n+    @ConfigItem(name = \"kerberos.kinit.cmd\")\n+    public Optional<String> kerberosKinitCmd;\n+\n+    /**\n+     * Login thread will sleep until the specified window factor of time from last refresh\n+     */\n+    @ConfigItem(name = \"kerberos.ticket.renew.window.factor\")\n+    public Optional<String> kerberosTicketRenewWindowFactor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa1326ce07f8a0a706a0ede54f698ef5538d1829"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ4OTA3Mw==", "bodyText": "Yeah, I didn't bother, since KS's config takes care of the conversions anyway.\nIf you think we should, then this can easily be changed.", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r384489073", "createdAt": "2020-02-26T13:25:43Z", "author": {"login": "alesj"}, "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/SaslConfig.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package io.quarkus.kafka.streams.runtime;\n+\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+@ConfigGroup\n+public class SaslConfig {\n+\n+    /**\n+     * JAAS login context parameters for SASL connections in the format used by JAAS configuration files\n+     */\n+    @ConfigItem(name = \"jaas.config\")\n+    public Optional<String> jaasConfig;\n+\n+    /**\n+     * The fully qualified name of a SASL client callback handler class\n+     */\n+    @ConfigItem(name = \"client.callback.handler.class\")\n+    public Optional<String> clientCallbackHandlerClass;\n+\n+    /**\n+     * The fully qualified name of a SASL login callback handler class\n+     */\n+    @ConfigItem(name = \"login.callback.handler.class\")\n+    public Optional<String> loginCallbackHandlerClass;\n+\n+    /**\n+     * The fully qualified name of a class that implements the Login interface\n+     */\n+    @ConfigItem(name = \"login.class\")\n+    public Optional<String> loginClass;\n+\n+    /**\n+     * The Kerberos principal name that Kafka runs as\n+     */\n+    @ConfigItem(name = \"kerberos.service.name\")\n+    public Optional<String> kerberosServiceName;\n+\n+    /**\n+     * Kerberos kinit command path\n+     */\n+    @ConfigItem(name = \"kerberos.kinit.cmd\")\n+    public Optional<String> kerberosKinitCmd;\n+\n+    /**\n+     * Login thread will sleep until the specified window factor of time from last refresh\n+     */\n+    @ConfigItem(name = \"kerberos.ticket.renew.window.factor\")\n+    public Optional<String> kerberosTicketRenewWindowFactor;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNjYwNg=="}, "originalCommit": {"oid": "fa1326ce07f8a0a706a0ede54f698ef5538d1829"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ5MTI1NA==", "bodyText": "Let's ask @gsmet. My understanding is that Quarkus wants to expose properly typed options, so to offer e.g. editor support (validation) down the road.", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r384491254", "createdAt": "2020-02-26T13:29:40Z", "author": {"login": "gunnarmorling"}, "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/SaslConfig.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package io.quarkus.kafka.streams.runtime;\n+\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+@ConfigGroup\n+public class SaslConfig {\n+\n+    /**\n+     * JAAS login context parameters for SASL connections in the format used by JAAS configuration files\n+     */\n+    @ConfigItem(name = \"jaas.config\")\n+    public Optional<String> jaasConfig;\n+\n+    /**\n+     * The fully qualified name of a SASL client callback handler class\n+     */\n+    @ConfigItem(name = \"client.callback.handler.class\")\n+    public Optional<String> clientCallbackHandlerClass;\n+\n+    /**\n+     * The fully qualified name of a SASL login callback handler class\n+     */\n+    @ConfigItem(name = \"login.callback.handler.class\")\n+    public Optional<String> loginCallbackHandlerClass;\n+\n+    /**\n+     * The fully qualified name of a class that implements the Login interface\n+     */\n+    @ConfigItem(name = \"login.class\")\n+    public Optional<String> loginClass;\n+\n+    /**\n+     * The Kerberos principal name that Kafka runs as\n+     */\n+    @ConfigItem(name = \"kerberos.service.name\")\n+    public Optional<String> kerberosServiceName;\n+\n+    /**\n+     * Kerberos kinit command path\n+     */\n+    @ConfigItem(name = \"kerberos.kinit.cmd\")\n+    public Optional<String> kerberosKinitCmd;\n+\n+    /**\n+     * Login thread will sleep until the specified window factor of time from last refresh\n+     */\n+    @ConfigItem(name = \"kerberos.ticket.renew.window.factor\")\n+    public Optional<String> kerberosTicketRenewWindowFactor;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNjYwNg=="}, "originalCommit": {"oid": "fa1326ce07f8a0a706a0ede54f698ef5538d1829"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk5OTc0NQ==", "bodyText": "Yes, the Quarkus config should be properly typed.", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r384999745", "createdAt": "2020-02-27T09:20:17Z", "author": {"login": "gsmet"}, "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/SaslConfig.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package io.quarkus.kafka.streams.runtime;\n+\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+@ConfigGroup\n+public class SaslConfig {\n+\n+    /**\n+     * JAAS login context parameters for SASL connections in the format used by JAAS configuration files\n+     */\n+    @ConfigItem(name = \"jaas.config\")\n+    public Optional<String> jaasConfig;\n+\n+    /**\n+     * The fully qualified name of a SASL client callback handler class\n+     */\n+    @ConfigItem(name = \"client.callback.handler.class\")\n+    public Optional<String> clientCallbackHandlerClass;\n+\n+    /**\n+     * The fully qualified name of a SASL login callback handler class\n+     */\n+    @ConfigItem(name = \"login.callback.handler.class\")\n+    public Optional<String> loginCallbackHandlerClass;\n+\n+    /**\n+     * The fully qualified name of a class that implements the Login interface\n+     */\n+    @ConfigItem(name = \"login.class\")\n+    public Optional<String> loginClass;\n+\n+    /**\n+     * The Kerberos principal name that Kafka runs as\n+     */\n+    @ConfigItem(name = \"kerberos.service.name\")\n+    public Optional<String> kerberosServiceName;\n+\n+    /**\n+     * Kerberos kinit command path\n+     */\n+    @ConfigItem(name = \"kerberos.kinit.cmd\")\n+    public Optional<String> kerberosKinitCmd;\n+\n+    /**\n+     * Login thread will sleep until the specified window factor of time from last refresh\n+     */\n+    @ConfigItem(name = \"kerberos.ticket.renew.window.factor\")\n+    public Optional<String> kerberosTicketRenewWindowFactor;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNjYwNg=="}, "originalCommit": {"oid": "fa1326ce07f8a0a706a0ede54f698ef5538d1829"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwMDgyMg==", "bodyText": "Yes, it should be typed.", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r385000822", "createdAt": "2020-02-27T09:22:21Z", "author": {"login": "gsmet"}, "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/SaslConfig.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package io.quarkus.kafka.streams.runtime;\n+\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+@ConfigGroup\n+public class SaslConfig {\n+\n+    /**\n+     * JAAS login context parameters for SASL connections in the format used by JAAS configuration files\n+     */\n+    @ConfigItem(name = \"jaas.config\")\n+    public Optional<String> jaasConfig;\n+\n+    /**\n+     * The fully qualified name of a SASL client callback handler class\n+     */\n+    @ConfigItem(name = \"client.callback.handler.class\")\n+    public Optional<String> clientCallbackHandlerClass;\n+\n+    /**\n+     * The fully qualified name of a SASL login callback handler class\n+     */\n+    @ConfigItem(name = \"login.callback.handler.class\")\n+    public Optional<String> loginCallbackHandlerClass;\n+\n+    /**\n+     * The fully qualified name of a class that implements the Login interface\n+     */\n+    @ConfigItem(name = \"login.class\")\n+    public Optional<String> loginClass;\n+\n+    /**\n+     * The Kerberos principal name that Kafka runs as\n+     */\n+    @ConfigItem(name = \"kerberos.service.name\")\n+    public Optional<String> kerberosServiceName;\n+\n+    /**\n+     * Kerberos kinit command path\n+     */\n+    @ConfigItem(name = \"kerberos.kinit.cmd\")\n+    public Optional<String> kerberosKinitCmd;\n+\n+    /**\n+     * Login thread will sleep until the specified window factor of time from last refresh\n+     */\n+    @ConfigItem(name = \"kerberos.ticket.renew.window.factor\")\n+    public Optional<String> kerberosTicketRenewWindowFactor;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNjYwNg=="}, "originalCommit": {"oid": "fa1326ce07f8a0a706a0ede54f698ef5538d1829"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MDY1MTk1OnYy", "diffSide": "RIGHT", "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/SaslConfig.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMToxMzo0NFrOFunlqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOToyMjo1OVrOFvKm6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNzQzMw==", "bodyText": "Should be an int. But also worth double checking with Quarkus guidelines: should it be rather Duration, and be given as such (which would impact the option name, though, which might not be desirable as it's coming from Kafka upstream IIUC).", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r384427433", "createdAt": "2020-02-26T11:13:44Z", "author": {"login": "gunnarmorling"}, "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/SaslConfig.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package io.quarkus.kafka.streams.runtime;\n+\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+@ConfigGroup\n+public class SaslConfig {\n+\n+    /**\n+     * JAAS login context parameters for SASL connections in the format used by JAAS configuration files\n+     */\n+    @ConfigItem(name = \"jaas.config\")\n+    public Optional<String> jaasConfig;\n+\n+    /**\n+     * The fully qualified name of a SASL client callback handler class\n+     */\n+    @ConfigItem(name = \"client.callback.handler.class\")\n+    public Optional<String> clientCallbackHandlerClass;\n+\n+    /**\n+     * The fully qualified name of a SASL login callback handler class\n+     */\n+    @ConfigItem(name = \"login.callback.handler.class\")\n+    public Optional<String> loginCallbackHandlerClass;\n+\n+    /**\n+     * The fully qualified name of a class that implements the Login interface\n+     */\n+    @ConfigItem(name = \"login.class\")\n+    public Optional<String> loginClass;\n+\n+    /**\n+     * The Kerberos principal name that Kafka runs as\n+     */\n+    @ConfigItem(name = \"kerberos.service.name\")\n+    public Optional<String> kerberosServiceName;\n+\n+    /**\n+     * Kerberos kinit command path\n+     */\n+    @ConfigItem(name = \"kerberos.kinit.cmd\")\n+    public Optional<String> kerberosKinitCmd;\n+\n+    /**\n+     * Login thread will sleep until the specified window factor of time from last refresh\n+     */\n+    @ConfigItem(name = \"kerberos.ticket.renew.window.factor\")\n+    public Optional<String> kerberosTicketRenewWindowFactor;\n+\n+    /**\n+     * Percentage of random jitter added to the renewal time\n+     */\n+    @ConfigItem(name = \"kerberos.ticket.renew.jitter\")\n+    public Optional<String> kerberosTicketRenewJitter;\n+\n+    /**\n+     * Percentage of random jitter added to the renewal time\n+     */\n+    @ConfigItem(name = \"kerberos.min.time.before.relogin\")\n+    public Optional<String> kerberosMinTimeBeforeRelogin;\n+\n+    /**\n+     * Login refresh thread will sleep until the specified window factor relative to the\n+     * credential's lifetime has been reached.\n+     */\n+    @ConfigItem(name = \"login.refresh.window.factor\")\n+    public Optional<String> loginRefreshWindowFactor;\n+\n+    /**\n+     * The maximum amount of random jitter relative to the credential's lifetime\n+     */\n+    @ConfigItem(name = \"login.refresh.window.jitter\")\n+    public Optional<String> loginRefreshWindowJitter;\n+\n+    /**\n+     * The desired minimum time for the login refresh thread to wait before refreshing a credential\n+     */\n+    @ConfigItem(name = \"login.refresh.min.period.seconds\")\n+    public Optional<String> loginRefreshMinPeriodSeconds;\n+\n+    /**\n+     * The amount of buffer time before credential expiration to maintain when refreshing a credential\n+     */\n+    @ConfigItem(name = \"login.refresh.buffer.seconds\")\n+    public Optional<String> loginRefreshBufferSeconds;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa1326ce07f8a0a706a0ede54f698ef5538d1829"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwMTE5NQ==", "bodyText": "Yeah all these properties should be Duration and we should drop the Seconds part. They will be documented so it's OK.", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r385001195", "createdAt": "2020-02-27T09:22:59Z", "author": {"login": "gsmet"}, "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/SaslConfig.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package io.quarkus.kafka.streams.runtime;\n+\n+import java.util.Optional;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+@ConfigGroup\n+public class SaslConfig {\n+\n+    /**\n+     * JAAS login context parameters for SASL connections in the format used by JAAS configuration files\n+     */\n+    @ConfigItem(name = \"jaas.config\")\n+    public Optional<String> jaasConfig;\n+\n+    /**\n+     * The fully qualified name of a SASL client callback handler class\n+     */\n+    @ConfigItem(name = \"client.callback.handler.class\")\n+    public Optional<String> clientCallbackHandlerClass;\n+\n+    /**\n+     * The fully qualified name of a SASL login callback handler class\n+     */\n+    @ConfigItem(name = \"login.callback.handler.class\")\n+    public Optional<String> loginCallbackHandlerClass;\n+\n+    /**\n+     * The fully qualified name of a class that implements the Login interface\n+     */\n+    @ConfigItem(name = \"login.class\")\n+    public Optional<String> loginClass;\n+\n+    /**\n+     * The Kerberos principal name that Kafka runs as\n+     */\n+    @ConfigItem(name = \"kerberos.service.name\")\n+    public Optional<String> kerberosServiceName;\n+\n+    /**\n+     * Kerberos kinit command path\n+     */\n+    @ConfigItem(name = \"kerberos.kinit.cmd\")\n+    public Optional<String> kerberosKinitCmd;\n+\n+    /**\n+     * Login thread will sleep until the specified window factor of time from last refresh\n+     */\n+    @ConfigItem(name = \"kerberos.ticket.renew.window.factor\")\n+    public Optional<String> kerberosTicketRenewWindowFactor;\n+\n+    /**\n+     * Percentage of random jitter added to the renewal time\n+     */\n+    @ConfigItem(name = \"kerberos.ticket.renew.jitter\")\n+    public Optional<String> kerberosTicketRenewJitter;\n+\n+    /**\n+     * Percentage of random jitter added to the renewal time\n+     */\n+    @ConfigItem(name = \"kerberos.min.time.before.relogin\")\n+    public Optional<String> kerberosMinTimeBeforeRelogin;\n+\n+    /**\n+     * Login refresh thread will sleep until the specified window factor relative to the\n+     * credential's lifetime has been reached.\n+     */\n+    @ConfigItem(name = \"login.refresh.window.factor\")\n+    public Optional<String> loginRefreshWindowFactor;\n+\n+    /**\n+     * The maximum amount of random jitter relative to the credential's lifetime\n+     */\n+    @ConfigItem(name = \"login.refresh.window.jitter\")\n+    public Optional<String> loginRefreshWindowJitter;\n+\n+    /**\n+     * The desired minimum time for the login refresh thread to wait before refreshing a credential\n+     */\n+    @ConfigItem(name = \"login.refresh.min.period.seconds\")\n+    public Optional<String> loginRefreshMinPeriodSeconds;\n+\n+    /**\n+     * The amount of buffer time before credential expiration to maintain when refreshing a credential\n+     */\n+    @ConfigItem(name = \"login.refresh.buffer.seconds\")\n+    public Optional<String> loginRefreshBufferSeconds;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNzQzMw=="}, "originalCommit": {"oid": "fa1326ce07f8a0a706a0ede54f698ef5538d1829"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MDY1NDY3OnYy", "diffSide": "RIGHT", "path": "integration-tests/kafka-streams/src/test/java/io/quarkus/it/kafka/streams/KafkaStreamsPropertiesTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMToxNDozOVrOFunnPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxMzozMDo0NFrOFurhHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNzgzOQ==", "bodyText": "How about adding a package visible accessor?", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r384427839", "createdAt": "2020-02-26T11:14:39Z", "author": {"login": "gunnarmorling"}, "path": "integration-tests/kafka-streams/src/test/java/io/quarkus/it/kafka/streams/KafkaStreamsPropertiesTest.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package io.quarkus.it.kafka.streams;\n+\n+import java.lang.reflect.Field;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import io.quarkus.test.common.QuarkusTestResource;\n+import io.quarkus.test.junit.QuarkusTest;\n+\n+@QuarkusTestResource(KafkaTestResource.class)\n+@QuarkusTest\n+public class KafkaStreamsPropertiesTest {\n+\n+    @Inject\n+    KafkaStreams streams;\n+\n+    @Test\n+    public void testProperties() throws Exception {\n+        // reflection hack ... no other way to get raw props ...\n+        Field configField = KafkaStreams.class.getDeclaredField(\"config\");\n+        configField.setAccessible(true);\n+        StreamsConfig config = (StreamsConfig) configField.get(streams);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa1326ce07f8a0a706a0ede54f698ef5538d1829"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ4OTYyOQ==", "bodyText": "What do you mean?", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r384489629", "createdAt": "2020-02-26T13:26:40Z", "author": {"login": "alesj"}, "path": "integration-tests/kafka-streams/src/test/java/io/quarkus/it/kafka/streams/KafkaStreamsPropertiesTest.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package io.quarkus.it.kafka.streams;\n+\n+import java.lang.reflect.Field;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import io.quarkus.test.common.QuarkusTestResource;\n+import io.quarkus.test.junit.QuarkusTest;\n+\n+@QuarkusTestResource(KafkaTestResource.class)\n+@QuarkusTest\n+public class KafkaStreamsPropertiesTest {\n+\n+    @Inject\n+    KafkaStreams streams;\n+\n+    @Test\n+    public void testProperties() throws Exception {\n+        // reflection hack ... no other way to get raw props ...\n+        Field configField = KafkaStreams.class.getDeclaredField(\"config\");\n+        configField.setAccessible(true);\n+        StreamsConfig config = (StreamsConfig) configField.get(streams);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNzgzOQ=="}, "originalCommit": {"oid": "fa1326ce07f8a0a706a0ede54f698ef5538d1829"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ5MTgwNA==", "bodyText": "Ah, seems you get a field from the upstream KafkaStreams object. I thought about having a getter in our own object (topology manager), where we could expose a package-visible getter for testing purposes.", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r384491804", "createdAt": "2020-02-26T13:30:44Z", "author": {"login": "gunnarmorling"}, "path": "integration-tests/kafka-streams/src/test/java/io/quarkus/it/kafka/streams/KafkaStreamsPropertiesTest.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package io.quarkus.it.kafka.streams;\n+\n+import java.lang.reflect.Field;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import io.quarkus.test.common.QuarkusTestResource;\n+import io.quarkus.test.junit.QuarkusTest;\n+\n+@QuarkusTestResource(KafkaTestResource.class)\n+@QuarkusTest\n+public class KafkaStreamsPropertiesTest {\n+\n+    @Inject\n+    KafkaStreams streams;\n+\n+    @Test\n+    public void testProperties() throws Exception {\n+        // reflection hack ... no other way to get raw props ...\n+        Field configField = KafkaStreams.class.getDeclaredField(\"config\");\n+        configField.setAccessible(true);\n+        StreamsConfig config = (StreamsConfig) configField.get(streams);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQyNzgzOQ=="}, "originalCommit": {"oid": "fa1326ce07f8a0a706a0ede54f698ef5538d1829"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDMxODQ1OnYy", "diffSide": "RIGHT", "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/KafkaStreamsRuntimeConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOToyMTo1M1rOFvKknA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOToyMTo1M1rOFvKknA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwMDYwNA==", "bodyText": "In Quarkus config, we use a dot to separate sections and a dash to separate words. It's a general comment about the config key of this PR.", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r385000604", "createdAt": "2020-02-27T09:21:53Z", "author": {"login": "gsmet"}, "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/KafkaStreamsRuntimeConfig.java", "diffHunk": "@@ -37,10 +37,42 @@\n     @ConfigItem\n     public List<String> topics;\n \n+    /**\n+     * The schema registry key.\n+     * e.g. to diff between different registry impls / instances\n+     * as they have this registry url under different property key.\n+     */\n+    @ConfigItem(name = \"schema.registry.key\", defaultValue = \"schema.registry.url\")\n+    public String schemaRegistryKey;\n+\n+    /**\n+     * The schema registry url.\n+     */\n+    @ConfigItem(name = \"schema.registry.url\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa1326ce07f8a0a706a0ede54f698ef5538d1829"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MjI5NTU5OnYy", "diffSide": "RIGHT", "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/KafkaStreamsRuntimeConfig.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzozMzoxMlrOF5T0lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDowODo0NlrOF6HD4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzNzkwOQ==", "bodyText": "Perhaps clarify the value to be used for Apicurio?", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r395637909", "createdAt": "2020-03-20T13:33:12Z", "author": {"login": "gunnarmorling"}, "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/KafkaStreamsRuntimeConfig.java", "diffHunk": "@@ -37,10 +37,42 @@\n     @ConfigItem\n     public List<String> topics;\n \n+    /**\n+     * The schema registry key.\n+     * e.g. to diff between different registry impls / instances", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4b1fbc4f2626423d57ba4cf6a571f427f334afd"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3NzQwOA==", "bodyText": "OK, will do.", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r396477408", "createdAt": "2020-03-23T14:08:46Z", "author": {"login": "alesj"}, "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/KafkaStreamsRuntimeConfig.java", "diffHunk": "@@ -37,10 +37,42 @@\n     @ConfigItem\n     public List<String> topics;\n \n+    /**\n+     * The schema registry key.\n+     * e.g. to diff between different registry impls / instances", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYzNzkwOQ=="}, "originalCommit": {"oid": "d4b1fbc4f2626423d57ba4cf6a571f427f334afd"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MjA4NDYzOnYy", "diffSide": "RIGHT", "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/KafkaStreamsTopologyManager.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMzo0MDo1OVrOGNUlhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTo1MjowNFrOGOFhIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjYyMTk1Ng==", "bodyText": "I don't understand why we need that here?", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r416621956", "createdAt": "2020-04-28T13:40:59Z", "author": {"login": "gsmet"}, "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/KafkaStreamsTopologyManager.java", "diffHunk": "@@ -80,17 +84,90 @@ private static Properties getStreamsProperties(Properties properties, String boo\n         // build-time options\n         streamsProperties.putAll(properties);\n \n+        // dynamic add -- back-compatibility\n+        streamsProperties.putAll(KafkaStreamsPropertiesUtil.quarkusKafkaStreamsProperties());\n+        streamsProperties.putAll(KafkaStreamsPropertiesUtil.appKafkaStreamsProperties());\n+\n         // add runtime options\n         streamsProperties.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig);\n         streamsProperties.put(StreamsConfig.APPLICATION_ID_CONFIG, runtimeConfig.applicationId);\n \n+        // app id\n         if (runtimeConfig.applicationServer.isPresent()) {\n             streamsProperties.put(StreamsConfig.APPLICATION_SERVER_CONFIG, runtimeConfig.applicationServer.get());\n         }\n \n+        // schema registry\n+        if (runtimeConfig.schemaRegistryUrl.isPresent()) {\n+            streamsProperties.put(runtimeConfig.schemaRegistryKey, runtimeConfig.schemaRegistryUrl.get());\n+        }\n+\n+        // sasl\n+        SaslConfig sc = runtimeConfig.sasl;\n+        if (sc != null) {\n+            setProperty(sc.jaasConfig, streamsProperties, SaslConfigs.SASL_JAAS_CONFIG);\n+\n+            setProperty(sc.clientCallbackHandlerClass, streamsProperties, SaslConfigs.SASL_CLIENT_CALLBACK_HANDLER_CLASS);\n+\n+            setProperty(sc.loginCallbackHandlerClass, streamsProperties, SaslConfigs.SASL_LOGIN_CALLBACK_HANDLER_CLASS);\n+            setProperty(sc.loginClass, streamsProperties, SaslConfigs.SASL_LOGIN_CLASS);\n+\n+            setProperty(sc.kerberosServiceName, streamsProperties, SaslConfigs.SASL_KERBEROS_SERVICE_NAME);\n+            setProperty(sc.kerberosKinitCmd, streamsProperties, SaslConfigs.SASL_KERBEROS_KINIT_CMD);\n+            setProperty(sc.kerberosTicketRenewWindowFactor, streamsProperties,\n+                    SaslConfigs.SASL_KERBEROS_TICKET_RENEW_WINDOW_FACTOR);\n+            setProperty(sc.kerberosTicketRenewJitter, streamsProperties, SaslConfigs.SASL_KERBEROS_TICKET_RENEW_JITTER);\n+            setProperty(sc.kerberosMinTimeBeforeRelogin, streamsProperties, SaslConfigs.SASL_KERBEROS_MIN_TIME_BEFORE_RELOGIN);\n+\n+            setProperty(sc.loginRefreshWindowFactor, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_FACTOR);\n+            setProperty(sc.loginRefreshWindowJitter, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_JITTER);\n+\n+            setProperty(sc.loginRefreshMinPeriod, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_MIN_PERIOD_SECONDS,\n+                    DurationToSecondsFunction.INSTANCE);\n+            setProperty(sc.loginRefreshBuffer, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_BUFFER_SECONDS,\n+                    DurationToSecondsFunction.INSTANCE);\n+        }\n+\n+        // ssl\n+        SslConfig ssl = runtimeConfig.ssl;\n+        if (ssl != null) {\n+            setProperty(ssl.protocol, streamsProperties, SslConfigs.SSL_PROTOCOL_CONFIG);\n+            setProperty(ssl.provider, streamsProperties, SslConfigs.SSL_PROVIDER_CONFIG);\n+            setProperty(ssl.cipherSuites, streamsProperties, SslConfigs.SSL_CIPHER_SUITES_CONFIG);\n+            setProperty(ssl.enabledProtocols, streamsProperties, SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG);\n+\n+            setStoreConfig(ssl.truststore, streamsProperties, \"ssl.truststore\");\n+            setStoreConfig(ssl.keystore, streamsProperties, \"ssl.keystore\");\n+            setStoreConfig(ssl.key, streamsProperties, \"ssl.key\");\n+\n+            setProperty(ssl.keymanagerAlgorithm, streamsProperties, SslConfigs.SSL_KEYMANAGER_ALGORITHM_CONFIG);\n+            setProperty(ssl.trustmanagerAlgorithm, streamsProperties, SslConfigs.SSL_TRUSTMANAGER_ALGORITHM_CONFIG);\n+            setProperty(ssl.endpointIdentificationAlgorithm.map(s -> \"\\\"\\\"\".equals(s) ? \"\" : s), streamsProperties,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16df4e9ac65e8caf28c7f92ddfed01161fbb2c69"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE4ODMxNQ==", "bodyText": "There is no other (or better / smarter) way to pass-in an empty string.\n(that's what I've been told by @dmlloyd )\nAnd in this case you need to have an empty string, to disable this config/setting.", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r417188315", "createdAt": "2020-04-29T09:38:13Z", "author": {"login": "alesj"}, "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/KafkaStreamsTopologyManager.java", "diffHunk": "@@ -80,17 +84,90 @@ private static Properties getStreamsProperties(Properties properties, String boo\n         // build-time options\n         streamsProperties.putAll(properties);\n \n+        // dynamic add -- back-compatibility\n+        streamsProperties.putAll(KafkaStreamsPropertiesUtil.quarkusKafkaStreamsProperties());\n+        streamsProperties.putAll(KafkaStreamsPropertiesUtil.appKafkaStreamsProperties());\n+\n         // add runtime options\n         streamsProperties.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig);\n         streamsProperties.put(StreamsConfig.APPLICATION_ID_CONFIG, runtimeConfig.applicationId);\n \n+        // app id\n         if (runtimeConfig.applicationServer.isPresent()) {\n             streamsProperties.put(StreamsConfig.APPLICATION_SERVER_CONFIG, runtimeConfig.applicationServer.get());\n         }\n \n+        // schema registry\n+        if (runtimeConfig.schemaRegistryUrl.isPresent()) {\n+            streamsProperties.put(runtimeConfig.schemaRegistryKey, runtimeConfig.schemaRegistryUrl.get());\n+        }\n+\n+        // sasl\n+        SaslConfig sc = runtimeConfig.sasl;\n+        if (sc != null) {\n+            setProperty(sc.jaasConfig, streamsProperties, SaslConfigs.SASL_JAAS_CONFIG);\n+\n+            setProperty(sc.clientCallbackHandlerClass, streamsProperties, SaslConfigs.SASL_CLIENT_CALLBACK_HANDLER_CLASS);\n+\n+            setProperty(sc.loginCallbackHandlerClass, streamsProperties, SaslConfigs.SASL_LOGIN_CALLBACK_HANDLER_CLASS);\n+            setProperty(sc.loginClass, streamsProperties, SaslConfigs.SASL_LOGIN_CLASS);\n+\n+            setProperty(sc.kerberosServiceName, streamsProperties, SaslConfigs.SASL_KERBEROS_SERVICE_NAME);\n+            setProperty(sc.kerberosKinitCmd, streamsProperties, SaslConfigs.SASL_KERBEROS_KINIT_CMD);\n+            setProperty(sc.kerberosTicketRenewWindowFactor, streamsProperties,\n+                    SaslConfigs.SASL_KERBEROS_TICKET_RENEW_WINDOW_FACTOR);\n+            setProperty(sc.kerberosTicketRenewJitter, streamsProperties, SaslConfigs.SASL_KERBEROS_TICKET_RENEW_JITTER);\n+            setProperty(sc.kerberosMinTimeBeforeRelogin, streamsProperties, SaslConfigs.SASL_KERBEROS_MIN_TIME_BEFORE_RELOGIN);\n+\n+            setProperty(sc.loginRefreshWindowFactor, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_FACTOR);\n+            setProperty(sc.loginRefreshWindowJitter, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_JITTER);\n+\n+            setProperty(sc.loginRefreshMinPeriod, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_MIN_PERIOD_SECONDS,\n+                    DurationToSecondsFunction.INSTANCE);\n+            setProperty(sc.loginRefreshBuffer, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_BUFFER_SECONDS,\n+                    DurationToSecondsFunction.INSTANCE);\n+        }\n+\n+        // ssl\n+        SslConfig ssl = runtimeConfig.ssl;\n+        if (ssl != null) {\n+            setProperty(ssl.protocol, streamsProperties, SslConfigs.SSL_PROTOCOL_CONFIG);\n+            setProperty(ssl.provider, streamsProperties, SslConfigs.SSL_PROVIDER_CONFIG);\n+            setProperty(ssl.cipherSuites, streamsProperties, SslConfigs.SSL_CIPHER_SUITES_CONFIG);\n+            setProperty(ssl.enabledProtocols, streamsProperties, SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG);\n+\n+            setStoreConfig(ssl.truststore, streamsProperties, \"ssl.truststore\");\n+            setStoreConfig(ssl.keystore, streamsProperties, \"ssl.keystore\");\n+            setStoreConfig(ssl.key, streamsProperties, \"ssl.key\");\n+\n+            setProperty(ssl.keymanagerAlgorithm, streamsProperties, SslConfigs.SSL_KEYMANAGER_ALGORITHM_CONFIG);\n+            setProperty(ssl.trustmanagerAlgorithm, streamsProperties, SslConfigs.SSL_TRUSTMANAGER_ALGORITHM_CONFIG);\n+            setProperty(ssl.endpointIdentificationAlgorithm.map(s -> \"\\\"\\\"\".equals(s) ? \"\" : s), streamsProperties,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjYyMTk1Ng=="}, "originalCommit": {"oid": "16df4e9ac65e8caf28c7f92ddfed01161fbb2c69"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI1MjU0Mw==", "bodyText": "OK. Can't say I'm excited about it but can't think of a better solution. Or maybe we could use -1 to disable? It's a bit of dark magic but could be documented.\nJust a proposal, WDYT?", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r417252543", "createdAt": "2020-04-29T11:44:17Z", "author": {"login": "gsmet"}, "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/KafkaStreamsTopologyManager.java", "diffHunk": "@@ -80,17 +84,90 @@ private static Properties getStreamsProperties(Properties properties, String boo\n         // build-time options\n         streamsProperties.putAll(properties);\n \n+        // dynamic add -- back-compatibility\n+        streamsProperties.putAll(KafkaStreamsPropertiesUtil.quarkusKafkaStreamsProperties());\n+        streamsProperties.putAll(KafkaStreamsPropertiesUtil.appKafkaStreamsProperties());\n+\n         // add runtime options\n         streamsProperties.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig);\n         streamsProperties.put(StreamsConfig.APPLICATION_ID_CONFIG, runtimeConfig.applicationId);\n \n+        // app id\n         if (runtimeConfig.applicationServer.isPresent()) {\n             streamsProperties.put(StreamsConfig.APPLICATION_SERVER_CONFIG, runtimeConfig.applicationServer.get());\n         }\n \n+        // schema registry\n+        if (runtimeConfig.schemaRegistryUrl.isPresent()) {\n+            streamsProperties.put(runtimeConfig.schemaRegistryKey, runtimeConfig.schemaRegistryUrl.get());\n+        }\n+\n+        // sasl\n+        SaslConfig sc = runtimeConfig.sasl;\n+        if (sc != null) {\n+            setProperty(sc.jaasConfig, streamsProperties, SaslConfigs.SASL_JAAS_CONFIG);\n+\n+            setProperty(sc.clientCallbackHandlerClass, streamsProperties, SaslConfigs.SASL_CLIENT_CALLBACK_HANDLER_CLASS);\n+\n+            setProperty(sc.loginCallbackHandlerClass, streamsProperties, SaslConfigs.SASL_LOGIN_CALLBACK_HANDLER_CLASS);\n+            setProperty(sc.loginClass, streamsProperties, SaslConfigs.SASL_LOGIN_CLASS);\n+\n+            setProperty(sc.kerberosServiceName, streamsProperties, SaslConfigs.SASL_KERBEROS_SERVICE_NAME);\n+            setProperty(sc.kerberosKinitCmd, streamsProperties, SaslConfigs.SASL_KERBEROS_KINIT_CMD);\n+            setProperty(sc.kerberosTicketRenewWindowFactor, streamsProperties,\n+                    SaslConfigs.SASL_KERBEROS_TICKET_RENEW_WINDOW_FACTOR);\n+            setProperty(sc.kerberosTicketRenewJitter, streamsProperties, SaslConfigs.SASL_KERBEROS_TICKET_RENEW_JITTER);\n+            setProperty(sc.kerberosMinTimeBeforeRelogin, streamsProperties, SaslConfigs.SASL_KERBEROS_MIN_TIME_BEFORE_RELOGIN);\n+\n+            setProperty(sc.loginRefreshWindowFactor, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_FACTOR);\n+            setProperty(sc.loginRefreshWindowJitter, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_JITTER);\n+\n+            setProperty(sc.loginRefreshMinPeriod, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_MIN_PERIOD_SECONDS,\n+                    DurationToSecondsFunction.INSTANCE);\n+            setProperty(sc.loginRefreshBuffer, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_BUFFER_SECONDS,\n+                    DurationToSecondsFunction.INSTANCE);\n+        }\n+\n+        // ssl\n+        SslConfig ssl = runtimeConfig.ssl;\n+        if (ssl != null) {\n+            setProperty(ssl.protocol, streamsProperties, SslConfigs.SSL_PROTOCOL_CONFIG);\n+            setProperty(ssl.provider, streamsProperties, SslConfigs.SSL_PROVIDER_CONFIG);\n+            setProperty(ssl.cipherSuites, streamsProperties, SslConfigs.SSL_CIPHER_SUITES_CONFIG);\n+            setProperty(ssl.enabledProtocols, streamsProperties, SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG);\n+\n+            setStoreConfig(ssl.truststore, streamsProperties, \"ssl.truststore\");\n+            setStoreConfig(ssl.keystore, streamsProperties, \"ssl.keystore\");\n+            setStoreConfig(ssl.key, streamsProperties, \"ssl.key\");\n+\n+            setProperty(ssl.keymanagerAlgorithm, streamsProperties, SslConfigs.SSL_KEYMANAGER_ALGORITHM_CONFIG);\n+            setProperty(ssl.trustmanagerAlgorithm, streamsProperties, SslConfigs.SSL_TRUSTMANAGER_ALGORITHM_CONFIG);\n+            setProperty(ssl.endpointIdentificationAlgorithm.map(s -> \"\\\"\\\"\".equals(s) ? \"\" : s), streamsProperties,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjYyMTk1Ng=="}, "originalCommit": {"oid": "16df4e9ac65e8caf28c7f92ddfed01161fbb2c69"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI1NDIyOA==", "bodyText": "It's a string ... so setting a number ... hmmm, dunno :-)", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r417254228", "createdAt": "2020-04-29T11:47:27Z", "author": {"login": "alesj"}, "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/KafkaStreamsTopologyManager.java", "diffHunk": "@@ -80,17 +84,90 @@ private static Properties getStreamsProperties(Properties properties, String boo\n         // build-time options\n         streamsProperties.putAll(properties);\n \n+        // dynamic add -- back-compatibility\n+        streamsProperties.putAll(KafkaStreamsPropertiesUtil.quarkusKafkaStreamsProperties());\n+        streamsProperties.putAll(KafkaStreamsPropertiesUtil.appKafkaStreamsProperties());\n+\n         // add runtime options\n         streamsProperties.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig);\n         streamsProperties.put(StreamsConfig.APPLICATION_ID_CONFIG, runtimeConfig.applicationId);\n \n+        // app id\n         if (runtimeConfig.applicationServer.isPresent()) {\n             streamsProperties.put(StreamsConfig.APPLICATION_SERVER_CONFIG, runtimeConfig.applicationServer.get());\n         }\n \n+        // schema registry\n+        if (runtimeConfig.schemaRegistryUrl.isPresent()) {\n+            streamsProperties.put(runtimeConfig.schemaRegistryKey, runtimeConfig.schemaRegistryUrl.get());\n+        }\n+\n+        // sasl\n+        SaslConfig sc = runtimeConfig.sasl;\n+        if (sc != null) {\n+            setProperty(sc.jaasConfig, streamsProperties, SaslConfigs.SASL_JAAS_CONFIG);\n+\n+            setProperty(sc.clientCallbackHandlerClass, streamsProperties, SaslConfigs.SASL_CLIENT_CALLBACK_HANDLER_CLASS);\n+\n+            setProperty(sc.loginCallbackHandlerClass, streamsProperties, SaslConfigs.SASL_LOGIN_CALLBACK_HANDLER_CLASS);\n+            setProperty(sc.loginClass, streamsProperties, SaslConfigs.SASL_LOGIN_CLASS);\n+\n+            setProperty(sc.kerberosServiceName, streamsProperties, SaslConfigs.SASL_KERBEROS_SERVICE_NAME);\n+            setProperty(sc.kerberosKinitCmd, streamsProperties, SaslConfigs.SASL_KERBEROS_KINIT_CMD);\n+            setProperty(sc.kerberosTicketRenewWindowFactor, streamsProperties,\n+                    SaslConfigs.SASL_KERBEROS_TICKET_RENEW_WINDOW_FACTOR);\n+            setProperty(sc.kerberosTicketRenewJitter, streamsProperties, SaslConfigs.SASL_KERBEROS_TICKET_RENEW_JITTER);\n+            setProperty(sc.kerberosMinTimeBeforeRelogin, streamsProperties, SaslConfigs.SASL_KERBEROS_MIN_TIME_BEFORE_RELOGIN);\n+\n+            setProperty(sc.loginRefreshWindowFactor, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_FACTOR);\n+            setProperty(sc.loginRefreshWindowJitter, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_JITTER);\n+\n+            setProperty(sc.loginRefreshMinPeriod, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_MIN_PERIOD_SECONDS,\n+                    DurationToSecondsFunction.INSTANCE);\n+            setProperty(sc.loginRefreshBuffer, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_BUFFER_SECONDS,\n+                    DurationToSecondsFunction.INSTANCE);\n+        }\n+\n+        // ssl\n+        SslConfig ssl = runtimeConfig.ssl;\n+        if (ssl != null) {\n+            setProperty(ssl.protocol, streamsProperties, SslConfigs.SSL_PROTOCOL_CONFIG);\n+            setProperty(ssl.provider, streamsProperties, SslConfigs.SSL_PROVIDER_CONFIG);\n+            setProperty(ssl.cipherSuites, streamsProperties, SslConfigs.SSL_CIPHER_SUITES_CONFIG);\n+            setProperty(ssl.enabledProtocols, streamsProperties, SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG);\n+\n+            setStoreConfig(ssl.truststore, streamsProperties, \"ssl.truststore\");\n+            setStoreConfig(ssl.keystore, streamsProperties, \"ssl.keystore\");\n+            setStoreConfig(ssl.key, streamsProperties, \"ssl.key\");\n+\n+            setProperty(ssl.keymanagerAlgorithm, streamsProperties, SslConfigs.SSL_KEYMANAGER_ALGORITHM_CONFIG);\n+            setProperty(ssl.trustmanagerAlgorithm, streamsProperties, SslConfigs.SSL_TRUSTMANAGER_ALGORITHM_CONFIG);\n+            setProperty(ssl.endpointIdentificationAlgorithm.map(s -> \"\\\"\\\"\".equals(s) ? \"\" : s), streamsProperties,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjYyMTk1Ng=="}, "originalCommit": {"oid": "16df4e9ac65e8caf28c7f92ddfed01161fbb2c69"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyMzY0OQ==", "bodyText": "There is no other (or better / smarter) way to pass-in an empty string.\n(that's what I've been told by @dmlloyd )\n\nNo it's not; I definitely never told you that.  If you want a string which can be empty, use Optional<String> with orElse(\"\").  If you want an integer which can be empty, use OptionalInt (int has no native empty representation though, so orElse won't help in this case).\n\nAnd in this case you need to have an empty string, to disable this config/setting.\n\nThen it should be Optional.", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r417423649", "createdAt": "2020-04-29T15:52:04Z", "author": {"login": "dmlloyd"}, "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/KafkaStreamsTopologyManager.java", "diffHunk": "@@ -80,17 +84,90 @@ private static Properties getStreamsProperties(Properties properties, String boo\n         // build-time options\n         streamsProperties.putAll(properties);\n \n+        // dynamic add -- back-compatibility\n+        streamsProperties.putAll(KafkaStreamsPropertiesUtil.quarkusKafkaStreamsProperties());\n+        streamsProperties.putAll(KafkaStreamsPropertiesUtil.appKafkaStreamsProperties());\n+\n         // add runtime options\n         streamsProperties.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig);\n         streamsProperties.put(StreamsConfig.APPLICATION_ID_CONFIG, runtimeConfig.applicationId);\n \n+        // app id\n         if (runtimeConfig.applicationServer.isPresent()) {\n             streamsProperties.put(StreamsConfig.APPLICATION_SERVER_CONFIG, runtimeConfig.applicationServer.get());\n         }\n \n+        // schema registry\n+        if (runtimeConfig.schemaRegistryUrl.isPresent()) {\n+            streamsProperties.put(runtimeConfig.schemaRegistryKey, runtimeConfig.schemaRegistryUrl.get());\n+        }\n+\n+        // sasl\n+        SaslConfig sc = runtimeConfig.sasl;\n+        if (sc != null) {\n+            setProperty(sc.jaasConfig, streamsProperties, SaslConfigs.SASL_JAAS_CONFIG);\n+\n+            setProperty(sc.clientCallbackHandlerClass, streamsProperties, SaslConfigs.SASL_CLIENT_CALLBACK_HANDLER_CLASS);\n+\n+            setProperty(sc.loginCallbackHandlerClass, streamsProperties, SaslConfigs.SASL_LOGIN_CALLBACK_HANDLER_CLASS);\n+            setProperty(sc.loginClass, streamsProperties, SaslConfigs.SASL_LOGIN_CLASS);\n+\n+            setProperty(sc.kerberosServiceName, streamsProperties, SaslConfigs.SASL_KERBEROS_SERVICE_NAME);\n+            setProperty(sc.kerberosKinitCmd, streamsProperties, SaslConfigs.SASL_KERBEROS_KINIT_CMD);\n+            setProperty(sc.kerberosTicketRenewWindowFactor, streamsProperties,\n+                    SaslConfigs.SASL_KERBEROS_TICKET_RENEW_WINDOW_FACTOR);\n+            setProperty(sc.kerberosTicketRenewJitter, streamsProperties, SaslConfigs.SASL_KERBEROS_TICKET_RENEW_JITTER);\n+            setProperty(sc.kerberosMinTimeBeforeRelogin, streamsProperties, SaslConfigs.SASL_KERBEROS_MIN_TIME_BEFORE_RELOGIN);\n+\n+            setProperty(sc.loginRefreshWindowFactor, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_FACTOR);\n+            setProperty(sc.loginRefreshWindowJitter, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_JITTER);\n+\n+            setProperty(sc.loginRefreshMinPeriod, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_MIN_PERIOD_SECONDS,\n+                    DurationToSecondsFunction.INSTANCE);\n+            setProperty(sc.loginRefreshBuffer, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_BUFFER_SECONDS,\n+                    DurationToSecondsFunction.INSTANCE);\n+        }\n+\n+        // ssl\n+        SslConfig ssl = runtimeConfig.ssl;\n+        if (ssl != null) {\n+            setProperty(ssl.protocol, streamsProperties, SslConfigs.SSL_PROTOCOL_CONFIG);\n+            setProperty(ssl.provider, streamsProperties, SslConfigs.SSL_PROVIDER_CONFIG);\n+            setProperty(ssl.cipherSuites, streamsProperties, SslConfigs.SSL_CIPHER_SUITES_CONFIG);\n+            setProperty(ssl.enabledProtocols, streamsProperties, SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG);\n+\n+            setStoreConfig(ssl.truststore, streamsProperties, \"ssl.truststore\");\n+            setStoreConfig(ssl.keystore, streamsProperties, \"ssl.keystore\");\n+            setStoreConfig(ssl.key, streamsProperties, \"ssl.key\");\n+\n+            setProperty(ssl.keymanagerAlgorithm, streamsProperties, SslConfigs.SSL_KEYMANAGER_ALGORITHM_CONFIG);\n+            setProperty(ssl.trustmanagerAlgorithm, streamsProperties, SslConfigs.SSL_TRUSTMANAGER_ALGORITHM_CONFIG);\n+            setProperty(ssl.endpointIdentificationAlgorithm.map(s -> \"\\\"\\\"\".equals(s) ? \"\" : s), streamsProperties,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjYyMTk1Ng=="}, "originalCommit": {"oid": "16df4e9ac65e8caf28c7f92ddfed01161fbb2c69"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMDc1MjQ0OnYy", "diffSide": "RIGHT", "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/KafkaStreamsTopologyManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMjo0NjozNVrOGOnnuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxMToxNDozNlrOGP76-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk4MjM5NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        setProperty(ssl.endpointIdentificationAlgorithm.map(s -> \"\\\"\\\"\".equals(s) ? \"\" : s), streamsProperties,\n          \n          \n            \n                        setProperty(ssl.endpointIdentificationAlgorithm.orElse(\"\"), streamsProperties,", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r417982395", "createdAt": "2020-04-30T12:46:35Z", "author": {"login": "dmlloyd"}, "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/KafkaStreamsTopologyManager.java", "diffHunk": "@@ -80,17 +84,90 @@ private static Properties getStreamsProperties(Properties properties, String boo\n         // build-time options\n         streamsProperties.putAll(properties);\n \n+        // dynamic add -- back-compatibility\n+        streamsProperties.putAll(KafkaStreamsPropertiesUtil.quarkusKafkaStreamsProperties());\n+        streamsProperties.putAll(KafkaStreamsPropertiesUtil.appKafkaStreamsProperties());\n+\n         // add runtime options\n         streamsProperties.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig);\n         streamsProperties.put(StreamsConfig.APPLICATION_ID_CONFIG, runtimeConfig.applicationId);\n \n+        // app id\n         if (runtimeConfig.applicationServer.isPresent()) {\n             streamsProperties.put(StreamsConfig.APPLICATION_SERVER_CONFIG, runtimeConfig.applicationServer.get());\n         }\n \n+        // schema registry\n+        if (runtimeConfig.schemaRegistryUrl.isPresent()) {\n+            streamsProperties.put(runtimeConfig.schemaRegistryKey, runtimeConfig.schemaRegistryUrl.get());\n+        }\n+\n+        // sasl\n+        SaslConfig sc = runtimeConfig.sasl;\n+        if (sc != null) {\n+            setProperty(sc.jaasConfig, streamsProperties, SaslConfigs.SASL_JAAS_CONFIG);\n+\n+            setProperty(sc.clientCallbackHandlerClass, streamsProperties, SaslConfigs.SASL_CLIENT_CALLBACK_HANDLER_CLASS);\n+\n+            setProperty(sc.loginCallbackHandlerClass, streamsProperties, SaslConfigs.SASL_LOGIN_CALLBACK_HANDLER_CLASS);\n+            setProperty(sc.loginClass, streamsProperties, SaslConfigs.SASL_LOGIN_CLASS);\n+\n+            setProperty(sc.kerberosServiceName, streamsProperties, SaslConfigs.SASL_KERBEROS_SERVICE_NAME);\n+            setProperty(sc.kerberosKinitCmd, streamsProperties, SaslConfigs.SASL_KERBEROS_KINIT_CMD);\n+            setProperty(sc.kerberosTicketRenewWindowFactor, streamsProperties,\n+                    SaslConfigs.SASL_KERBEROS_TICKET_RENEW_WINDOW_FACTOR);\n+            setProperty(sc.kerberosTicketRenewJitter, streamsProperties, SaslConfigs.SASL_KERBEROS_TICKET_RENEW_JITTER);\n+            setProperty(sc.kerberosMinTimeBeforeRelogin, streamsProperties, SaslConfigs.SASL_KERBEROS_MIN_TIME_BEFORE_RELOGIN);\n+\n+            setProperty(sc.loginRefreshWindowFactor, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_FACTOR);\n+            setProperty(sc.loginRefreshWindowJitter, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_JITTER);\n+\n+            setProperty(sc.loginRefreshMinPeriod, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_MIN_PERIOD_SECONDS,\n+                    DurationToSecondsFunction.INSTANCE);\n+            setProperty(sc.loginRefreshBuffer, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_BUFFER_SECONDS,\n+                    DurationToSecondsFunction.INSTANCE);\n+        }\n+\n+        // ssl\n+        SslConfig ssl = runtimeConfig.ssl;\n+        if (ssl != null) {\n+            setProperty(ssl.protocol, streamsProperties, SslConfigs.SSL_PROTOCOL_CONFIG);\n+            setProperty(ssl.provider, streamsProperties, SslConfigs.SSL_PROVIDER_CONFIG);\n+            setProperty(ssl.cipherSuites, streamsProperties, SslConfigs.SSL_CIPHER_SUITES_CONFIG);\n+            setProperty(ssl.enabledProtocols, streamsProperties, SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG);\n+\n+            setStoreConfig(ssl.truststore, streamsProperties, \"ssl.truststore\");\n+            setStoreConfig(ssl.keystore, streamsProperties, \"ssl.keystore\");\n+            setStoreConfig(ssl.key, streamsProperties, \"ssl.key\");\n+\n+            setProperty(ssl.keymanagerAlgorithm, streamsProperties, SslConfigs.SSL_KEYMANAGER_ALGORITHM_CONFIG);\n+            setProperty(ssl.trustmanagerAlgorithm, streamsProperties, SslConfigs.SSL_TRUSTMANAGER_ALGORITHM_CONFIG);\n+            setProperty(ssl.endpointIdentificationAlgorithm.map(s -> \"\\\"\\\"\".equals(s) ? \"\" : s), streamsProperties,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "16df4e9ac65e8caf28c7f92ddfed01161fbb2c69"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5ODgzMA==", "bodyText": "How are you gonna get Optional.empty() if default is \"https\" ... ?\nOr it looks like I don't understand how @configitem with defaultValue and Optional work together?", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r419298830", "createdAt": "2020-05-04T09:00:31Z", "author": {"login": "alesj"}, "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/KafkaStreamsTopologyManager.java", "diffHunk": "@@ -80,17 +84,90 @@ private static Properties getStreamsProperties(Properties properties, String boo\n         // build-time options\n         streamsProperties.putAll(properties);\n \n+        // dynamic add -- back-compatibility\n+        streamsProperties.putAll(KafkaStreamsPropertiesUtil.quarkusKafkaStreamsProperties());\n+        streamsProperties.putAll(KafkaStreamsPropertiesUtil.appKafkaStreamsProperties());\n+\n         // add runtime options\n         streamsProperties.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig);\n         streamsProperties.put(StreamsConfig.APPLICATION_ID_CONFIG, runtimeConfig.applicationId);\n \n+        // app id\n         if (runtimeConfig.applicationServer.isPresent()) {\n             streamsProperties.put(StreamsConfig.APPLICATION_SERVER_CONFIG, runtimeConfig.applicationServer.get());\n         }\n \n+        // schema registry\n+        if (runtimeConfig.schemaRegistryUrl.isPresent()) {\n+            streamsProperties.put(runtimeConfig.schemaRegistryKey, runtimeConfig.schemaRegistryUrl.get());\n+        }\n+\n+        // sasl\n+        SaslConfig sc = runtimeConfig.sasl;\n+        if (sc != null) {\n+            setProperty(sc.jaasConfig, streamsProperties, SaslConfigs.SASL_JAAS_CONFIG);\n+\n+            setProperty(sc.clientCallbackHandlerClass, streamsProperties, SaslConfigs.SASL_CLIENT_CALLBACK_HANDLER_CLASS);\n+\n+            setProperty(sc.loginCallbackHandlerClass, streamsProperties, SaslConfigs.SASL_LOGIN_CALLBACK_HANDLER_CLASS);\n+            setProperty(sc.loginClass, streamsProperties, SaslConfigs.SASL_LOGIN_CLASS);\n+\n+            setProperty(sc.kerberosServiceName, streamsProperties, SaslConfigs.SASL_KERBEROS_SERVICE_NAME);\n+            setProperty(sc.kerberosKinitCmd, streamsProperties, SaslConfigs.SASL_KERBEROS_KINIT_CMD);\n+            setProperty(sc.kerberosTicketRenewWindowFactor, streamsProperties,\n+                    SaslConfigs.SASL_KERBEROS_TICKET_RENEW_WINDOW_FACTOR);\n+            setProperty(sc.kerberosTicketRenewJitter, streamsProperties, SaslConfigs.SASL_KERBEROS_TICKET_RENEW_JITTER);\n+            setProperty(sc.kerberosMinTimeBeforeRelogin, streamsProperties, SaslConfigs.SASL_KERBEROS_MIN_TIME_BEFORE_RELOGIN);\n+\n+            setProperty(sc.loginRefreshWindowFactor, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_FACTOR);\n+            setProperty(sc.loginRefreshWindowJitter, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_JITTER);\n+\n+            setProperty(sc.loginRefreshMinPeriod, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_MIN_PERIOD_SECONDS,\n+                    DurationToSecondsFunction.INSTANCE);\n+            setProperty(sc.loginRefreshBuffer, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_BUFFER_SECONDS,\n+                    DurationToSecondsFunction.INSTANCE);\n+        }\n+\n+        // ssl\n+        SslConfig ssl = runtimeConfig.ssl;\n+        if (ssl != null) {\n+            setProperty(ssl.protocol, streamsProperties, SslConfigs.SSL_PROTOCOL_CONFIG);\n+            setProperty(ssl.provider, streamsProperties, SslConfigs.SSL_PROVIDER_CONFIG);\n+            setProperty(ssl.cipherSuites, streamsProperties, SslConfigs.SSL_CIPHER_SUITES_CONFIG);\n+            setProperty(ssl.enabledProtocols, streamsProperties, SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG);\n+\n+            setStoreConfig(ssl.truststore, streamsProperties, \"ssl.truststore\");\n+            setStoreConfig(ssl.keystore, streamsProperties, \"ssl.keystore\");\n+            setStoreConfig(ssl.key, streamsProperties, \"ssl.key\");\n+\n+            setProperty(ssl.keymanagerAlgorithm, streamsProperties, SslConfigs.SSL_KEYMANAGER_ALGORITHM_CONFIG);\n+            setProperty(ssl.trustmanagerAlgorithm, streamsProperties, SslConfigs.SSL_TRUSTMANAGER_ALGORITHM_CONFIG);\n+            setProperty(ssl.endpointIdentificationAlgorithm.map(s -> \"\\\"\\\"\".equals(s) ? \"\" : s), streamsProperties,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk4MjM5NQ=="}, "originalCommit": {"oid": "16df4e9ac65e8caf28c7f92ddfed01161fbb2c69"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM2MzU3OQ==", "bodyText": "An empty Optional means the value was empty - meaning, the user explicitly gave an empty value.  If the user does not give a value, then the default is used, so in this case you'd get an Optional.of(\"https\").", "url": "https://github.com/quarkusio/quarkus/pull/7417#discussion_r419363579", "createdAt": "2020-05-04T11:14:36Z", "author": {"login": "dmlloyd"}, "path": "extensions/kafka-streams/runtime/src/main/java/io/quarkus/kafka/streams/runtime/KafkaStreamsTopologyManager.java", "diffHunk": "@@ -80,17 +84,90 @@ private static Properties getStreamsProperties(Properties properties, String boo\n         // build-time options\n         streamsProperties.putAll(properties);\n \n+        // dynamic add -- back-compatibility\n+        streamsProperties.putAll(KafkaStreamsPropertiesUtil.quarkusKafkaStreamsProperties());\n+        streamsProperties.putAll(KafkaStreamsPropertiesUtil.appKafkaStreamsProperties());\n+\n         // add runtime options\n         streamsProperties.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServersConfig);\n         streamsProperties.put(StreamsConfig.APPLICATION_ID_CONFIG, runtimeConfig.applicationId);\n \n+        // app id\n         if (runtimeConfig.applicationServer.isPresent()) {\n             streamsProperties.put(StreamsConfig.APPLICATION_SERVER_CONFIG, runtimeConfig.applicationServer.get());\n         }\n \n+        // schema registry\n+        if (runtimeConfig.schemaRegistryUrl.isPresent()) {\n+            streamsProperties.put(runtimeConfig.schemaRegistryKey, runtimeConfig.schemaRegistryUrl.get());\n+        }\n+\n+        // sasl\n+        SaslConfig sc = runtimeConfig.sasl;\n+        if (sc != null) {\n+            setProperty(sc.jaasConfig, streamsProperties, SaslConfigs.SASL_JAAS_CONFIG);\n+\n+            setProperty(sc.clientCallbackHandlerClass, streamsProperties, SaslConfigs.SASL_CLIENT_CALLBACK_HANDLER_CLASS);\n+\n+            setProperty(sc.loginCallbackHandlerClass, streamsProperties, SaslConfigs.SASL_LOGIN_CALLBACK_HANDLER_CLASS);\n+            setProperty(sc.loginClass, streamsProperties, SaslConfigs.SASL_LOGIN_CLASS);\n+\n+            setProperty(sc.kerberosServiceName, streamsProperties, SaslConfigs.SASL_KERBEROS_SERVICE_NAME);\n+            setProperty(sc.kerberosKinitCmd, streamsProperties, SaslConfigs.SASL_KERBEROS_KINIT_CMD);\n+            setProperty(sc.kerberosTicketRenewWindowFactor, streamsProperties,\n+                    SaslConfigs.SASL_KERBEROS_TICKET_RENEW_WINDOW_FACTOR);\n+            setProperty(sc.kerberosTicketRenewJitter, streamsProperties, SaslConfigs.SASL_KERBEROS_TICKET_RENEW_JITTER);\n+            setProperty(sc.kerberosMinTimeBeforeRelogin, streamsProperties, SaslConfigs.SASL_KERBEROS_MIN_TIME_BEFORE_RELOGIN);\n+\n+            setProperty(sc.loginRefreshWindowFactor, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_FACTOR);\n+            setProperty(sc.loginRefreshWindowJitter, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_WINDOW_JITTER);\n+\n+            setProperty(sc.loginRefreshMinPeriod, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_MIN_PERIOD_SECONDS,\n+                    DurationToSecondsFunction.INSTANCE);\n+            setProperty(sc.loginRefreshBuffer, streamsProperties, SaslConfigs.SASL_LOGIN_REFRESH_BUFFER_SECONDS,\n+                    DurationToSecondsFunction.INSTANCE);\n+        }\n+\n+        // ssl\n+        SslConfig ssl = runtimeConfig.ssl;\n+        if (ssl != null) {\n+            setProperty(ssl.protocol, streamsProperties, SslConfigs.SSL_PROTOCOL_CONFIG);\n+            setProperty(ssl.provider, streamsProperties, SslConfigs.SSL_PROVIDER_CONFIG);\n+            setProperty(ssl.cipherSuites, streamsProperties, SslConfigs.SSL_CIPHER_SUITES_CONFIG);\n+            setProperty(ssl.enabledProtocols, streamsProperties, SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG);\n+\n+            setStoreConfig(ssl.truststore, streamsProperties, \"ssl.truststore\");\n+            setStoreConfig(ssl.keystore, streamsProperties, \"ssl.keystore\");\n+            setStoreConfig(ssl.key, streamsProperties, \"ssl.key\");\n+\n+            setProperty(ssl.keymanagerAlgorithm, streamsProperties, SslConfigs.SSL_KEYMANAGER_ALGORITHM_CONFIG);\n+            setProperty(ssl.trustmanagerAlgorithm, streamsProperties, SslConfigs.SSL_TRUSTMANAGER_ALGORITHM_CONFIG);\n+            setProperty(ssl.endpointIdentificationAlgorithm.map(s -> \"\\\"\\\"\".equals(s) ? \"\" : s), streamsProperties,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk4MjM5NQ=="}, "originalCommit": {"oid": "16df4e9ac65e8caf28c7f92ddfed01161fbb2c69"}, "originalPosition": 104}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4973, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}