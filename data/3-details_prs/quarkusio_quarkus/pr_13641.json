{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxMjAxMTk1", "number": 13641, "title": "Add oidc-client, oidc-client-filter and oidc-token-propagation extensions", "bodyText": "Fixes #5657\nIt does the following:\n\nadds oidc-common module which keeps the configuration common to both quarkus-oidc and quarkus-oidc-client/ - both need the same connection properties, auto-discovery support, client authentication, etc.\n\nOidcClient\n\nadds quarkus-oidc-client: Uni - reactive, Mutiny Vert.x WebClient based OidcClient which currently supports client-credentials and password grants\nOidcClient authenticates with client_secret_basic, client_secret_post, client_secret_jwt (jwt private key to be added next)\nOidcClient is injectable and returns Tokens which holds Access and Refresh tokens which can also be refreshed\nTokens can be injected as well - the producer will use OidcClient internally to acquire/refresh the tokens - this feature is mainly for those applications which do not want to use quarkus-oidc-rest-client for some reasons\nOidcClients is an injectable container which contains a default OidcClient as well as the named clients. It can also be used to create OidcClient on demand\nOidcClientConfig has a Map to keep various grant properties based on the convention that a grant name acts as a key; I've tried to avoid introducing grant-specific property holders to keep an option for the custom/non-standard grants open\n\nOidcClientRequestFilter\n\nadds quarkus-oidc-client-filter - it provides a JAX-RS OidcClientRequestFilter which sets the access token acquired or refreshed by OidcClient as an HTTP Authorization Bearer scheme value.\nOidcClientRequestFilter can be added to all MP RestClients, or selectively, by using MP REST Client @RegisterProvider(OidcClientRequestFilter.class) or only adding @OidcClientFilter annotation\n\nAccessTokenRequestFilter\n\n\nadds quarkus-oidc-token-propagation - it provides a JAX-RS AccessTokenRequestFilter which sets the current Bearer or Authorization Code Flow access token as an HTTP Authorization Bearer scheme value.\n\n\nAccessTokenRequestFilter can be added to all MP RestClients, or selectively, by using MP REST Client @RegisterProvider(AccessTokenRequestFilter.class) or only adding @AccessToken annotation\n\n\nquarkus-rest-client has been updated to support using annotations like @OidcClientFilter to add an associated provider. quarkus-rest-client will need another simple iteration to support more than one custom annotation but it is beyond the scope of this PR which is becoming quite large already\n\n\ntests, including the dev mode one\n\n\ninitial documentation; some kind of quickstart will follow later once these new extensions have settled a bit\n\n\nCC @pedroigor @stuartwdouglas @gsmet @radcortez", "createdAt": "2020-12-02T18:17:57Z", "url": "https://github.com/quarkusio/quarkus/pull/13641", "merged": true, "mergeCommit": {"oid": "1c0a245b8560e220be780dc821c0475a2d00f630"}, "closed": true, "closedAt": "2021-01-05T16:29:11Z", "author": {"login": "sberyozkin"}, "timelineItems": {"totalCount": 37, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdihZbTABqjQwNjY5NzIzMjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdtKv9qABqjQxNjk3MjU0MjI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "726ddff641759ccaabefcaaf8df06b744be2e17e", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/726ddff641759ccaabefcaaf8df06b744be2e17e", "committedDate": "2020-12-02T18:16:32Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "0812300c4efd836611b341a780e4f9d8bae0108c", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/0812300c4efd836611b341a780e4f9d8bae0108c", "committedDate": "2020-12-03T10:48:16Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0812300c4efd836611b341a780e4f9d8bae0108c", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/0812300c4efd836611b341a780e4f9d8bae0108c", "committedDate": "2020-12-03T10:48:16Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "707f92d67b58d85b9aaf2475b99da11c53686a14", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/707f92d67b58d85b9aaf2475b99da11c53686a14", "committedDate": "2020-12-03T11:26:10Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "707f92d67b58d85b9aaf2475b99da11c53686a14", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/707f92d67b58d85b9aaf2475b99da11c53686a14", "committedDate": "2020-12-03T11:26:10Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "f1e0d6c8561c05ce2472136344868fd69eb0140f", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/f1e0d6c8561c05ce2472136344868fd69eb0140f", "committedDate": "2020-12-06T18:14:05Z", "message": "Load OidcClient filter with a custom annotation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f1e0d6c8561c05ce2472136344868fd69eb0140f", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/f1e0d6c8561c05ce2472136344868fd69eb0140f", "committedDate": "2020-12-06T18:14:05Z", "message": "Load OidcClient filter with a custom annotation"}, "afterCommit": {"oid": "2e0898d96a990bfee805722d65d28078cb1f7d28", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/2e0898d96a990bfee805722d65d28078cb1f7d28", "committedDate": "2020-12-07T16:57:09Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2e0898d96a990bfee805722d65d28078cb1f7d28", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/2e0898d96a990bfee805722d65d28078cb1f7d28", "committedDate": "2020-12-07T16:57:09Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "65ad379c4ec2cad1013002e08ff1f9fc74f88b37", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/65ad379c4ec2cad1013002e08ff1f9fc74f88b37", "committedDate": "2020-12-07T18:04:45Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "65ad379c4ec2cad1013002e08ff1f9fc74f88b37", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/65ad379c4ec2cad1013002e08ff1f9fc74f88b37", "committedDate": "2020-12-07T18:04:45Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "751cdae20a5608a237ce62d58ee66c66603695c8", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/751cdae20a5608a237ce62d58ee66c66603695c8", "committedDate": "2020-12-08T16:18:53Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "751cdae20a5608a237ce62d58ee66c66603695c8", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/751cdae20a5608a237ce62d58ee66c66603695c8", "committedDate": "2020-12-08T16:18:53Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "2422a13b7db944049b6bba2ea349d465d3fd5073", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/2422a13b7db944049b6bba2ea349d465d3fd5073", "committedDate": "2020-12-08T18:41:38Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2422a13b7db944049b6bba2ea349d465d3fd5073", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/2422a13b7db944049b6bba2ea349d465d3fd5073", "committedDate": "2020-12-08T18:41:38Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "cfd565c07074242f9f179b666e957004b873285a", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/cfd565c07074242f9f179b666e957004b873285a", "committedDate": "2020-12-09T14:35:54Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cfd565c07074242f9f179b666e957004b873285a", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/cfd565c07074242f9f179b666e957004b873285a", "committedDate": "2020-12-09T14:35:54Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "912c0ec5069e490b7ee7c52829b3fcf47f13d453", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/912c0ec5069e490b7ee7c52829b3fcf47f13d453", "committedDate": "2020-12-09T17:04:02Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "912c0ec5069e490b7ee7c52829b3fcf47f13d453", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/912c0ec5069e490b7ee7c52829b3fcf47f13d453", "committedDate": "2020-12-09T17:04:02Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "94290cd2810ac5d0fa63f305dfeeb353d41634e2", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/94290cd2810ac5d0fa63f305dfeeb353d41634e2", "committedDate": "2020-12-09T17:11:35Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "94290cd2810ac5d0fa63f305dfeeb353d41634e2", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/94290cd2810ac5d0fa63f305dfeeb353d41634e2", "committedDate": "2020-12-09T17:11:35Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "7c66607041b3e0e3116e6a7fa0f94ed13e84bea2", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/7c66607041b3e0e3116e6a7fa0f94ed13e84bea2", "committedDate": "2020-12-10T10:12:20Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7c66607041b3e0e3116e6a7fa0f94ed13e84bea2", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/7c66607041b3e0e3116e6a7fa0f94ed13e84bea2", "committedDate": "2020-12-10T10:12:20Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "52540c3947f4a824c2454d222cf303839b17485e", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/52540c3947f4a824c2454d222cf303839b17485e", "committedDate": "2020-12-10T11:04:07Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "52540c3947f4a824c2454d222cf303839b17485e", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/52540c3947f4a824c2454d222cf303839b17485e", "committedDate": "2020-12-10T11:04:07Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "113b7339bc427ef5c1e0af04a4e5a8c90b53e57e", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/113b7339bc427ef5c1e0af04a4e5a8c90b53e57e", "committedDate": "2020-12-11T18:02:31Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "113b7339bc427ef5c1e0af04a4e5a8c90b53e57e", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/113b7339bc427ef5c1e0af04a4e5a8c90b53e57e", "committedDate": "2020-12-11T18:02:31Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "ec0c79dc843b29701bd94b83645e17aad807abb7", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/ec0c79dc843b29701bd94b83645e17aad807abb7", "committedDate": "2020-12-13T17:37:14Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ec0c79dc843b29701bd94b83645e17aad807abb7", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/ec0c79dc843b29701bd94b83645e17aad807abb7", "committedDate": "2020-12-13T17:37:14Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "b600f42fc6923d2a92f5398db8a20ec198ee8290", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/b600f42fc6923d2a92f5398db8a20ec198ee8290", "committedDate": "2020-12-14T18:47:38Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b600f42fc6923d2a92f5398db8a20ec198ee8290", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/b600f42fc6923d2a92f5398db8a20ec198ee8290", "committedDate": "2020-12-14T18:47:38Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "16ef1c492c97a8f4a8da00b2eb1348d0c73834de", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/16ef1c492c97a8f4a8da00b2eb1348d0c73834de", "committedDate": "2020-12-14T22:35:08Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "16ef1c492c97a8f4a8da00b2eb1348d0c73834de", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/16ef1c492c97a8f4a8da00b2eb1348d0c73834de", "committedDate": "2020-12-14T22:35:08Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "ab55074a7b2a0765b87ac55db192e4a3b5c9e271", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/ab55074a7b2a0765b87ac55db192e4a3b5c9e271", "committedDate": "2020-12-15T13:06:46Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "60e5f506f46b8e80b479fd06a5ce22960eae2ff4", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/60e5f506f46b8e80b479fd06a5ce22960eae2ff4", "committedDate": "2020-12-15T17:46:21Z", "message": "Minor doc update"}, "afterCommit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/5092b249c039f4376f9602ea6a5e9f18235f9c9e", "committedDate": "2020-12-15T17:51:31Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzMDQwMDQ1", "url": "https://github.com/quarkusio/quarkus/pull/13641#pullrequestreview-553040045", "createdAt": "2020-12-15T22:57:00Z", "commit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMjo1NzowMFrOIGjvkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMzoxNDowMlrOIGkOlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc0Nzk4Ng==", "bodyText": "I would say that quarkus.oidc-client.grant.type=password makes more sense.", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543747986", "createdAt": "2020-12-15T22:57:00Z", "author": {"login": "pedroigor"}, "path": "docs/src/main/asciidoc/security-openid-connect-client.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using OpenID Connect and OAuth2 Client to acquire and refresh access tokens\n+\n+include::./attributes.adoc[]\n+:toc:\n+\n+This guide explains how to use Quarkus `quarkus-oidc-client` and `quarkus-oidc-rest-client` extensions to acquire access tokens from OpenId Connect and OAuth 2.0 compliant Authorization Servers such as https://www.keycloak.org/about.html[Keycloak] and use these tokens as HTTP Authorization Bearer tokens to access the remote services.\n+\n+== Introduction\n+\n+`quarkus-oidc-client` extension provides a reactive `io.quarkus.oidc.client.OidcClient` which can be used to acquire and refresh tokens using Smallrye Mutiny `Uni` and `Vert.x WebClient`.\n+\n+`OidcClient` is initialized at the build time with the IDP token endpoint URL which can be auto-discovered or manually configured and uses this endpoint to acquire access tokens using `client_credentials` or `password` token grants and refresh the tokens using `refresh_token` grant.\n+\n+Here is how `OidcClient` can be configured to use the `client_credentials` grant:\n+\n+```\n+quarkus.oidc.client.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc.client.client-id=quarkus-app\n+quarkus.oidc.client.credentials.secret=secret\n+```\n+\n+Here is how `OidcClient` can be configured to use the `password` grant:\n+\n+```\n+quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc-client.client-id=quarkus-app\n+quarkus.oidc-client.credentials.secret=secret\n+quarkus.oidc-client.grant.type=user\n+quarkus.oidc-client.grant-options.user.name=alice\n+quarkus.oidc-client.grant-options.user.password=alice\n+```\n+\n+Note the OAuth2 `password` grant is enabled with `quarkus.oidc-client.grant.type=user` to avoid duplicating `password` when setting a user password property required by the `password` grant.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1MjM3NA==", "bodyText": "I'm not sure it makes sense to set up the client with user because I'm not sure if that is a valid use case for chaining services. So, refresh tokens should only make sense if the application is a web-app that authenticates using code flow and needs to access downstream services.\nFor service-to-service communication it would makes more sense client credentials where refresh tokens are not supposed to be issued (in Keycloak we are changing this).\nBtw, is it possible to use this filter using a bearer token sent to a service type application ? One thing nice here would be the possibility to automatically exchange tokens depending on the service the application is calling. So that another token is issued by the AS and meant to use in the target service.", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543752374", "createdAt": "2020-12-15T23:06:15Z", "author": {"login": "pedroigor"}, "path": "docs/src/main/asciidoc/security-openid-connect-client.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using OpenID Connect and OAuth2 Client to acquire and refresh access tokens\n+\n+include::./attributes.adoc[]\n+:toc:\n+\n+This guide explains how to use Quarkus `quarkus-oidc-client` and `quarkus-oidc-rest-client` extensions to acquire access tokens from OpenId Connect and OAuth 2.0 compliant Authorization Servers such as https://www.keycloak.org/about.html[Keycloak] and use these tokens as HTTP Authorization Bearer tokens to access the remote services.\n+\n+== Introduction\n+\n+`quarkus-oidc-client` extension provides a reactive `io.quarkus.oidc.client.OidcClient` which can be used to acquire and refresh tokens using Smallrye Mutiny `Uni` and `Vert.x WebClient`.\n+\n+`OidcClient` is initialized at the build time with the IDP token endpoint URL which can be auto-discovered or manually configured and uses this endpoint to acquire access tokens using `client_credentials` or `password` token grants and refresh the tokens using `refresh_token` grant.\n+\n+Here is how `OidcClient` can be configured to use the `client_credentials` grant:\n+\n+```\n+quarkus.oidc.client.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc.client.client-id=quarkus-app\n+quarkus.oidc.client.credentials.secret=secret\n+```\n+\n+Here is how `OidcClient` can be configured to use the `password` grant:\n+\n+```\n+quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc-client.client-id=quarkus-app\n+quarkus.oidc-client.credentials.secret=secret\n+quarkus.oidc-client.grant.type=user\n+quarkus.oidc-client.grant-options.user.name=alice\n+quarkus.oidc-client.grant-options.user.password=alice\n+```\n+\n+Note the OAuth2 `password` grant is enabled with `quarkus.oidc-client.grant.type=user` to avoid duplicating `password` when setting a user password property required by the `password` grant.\n+\n+In both cases `OidcClient` will auto-discover the token endpoint URL and use it to acquire the tokens.\n+\n+== Use OidcClient directly\n+\n+One can use `OidcClient` directly as follows:\n+\n+```\n+import javax.inject.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.GrantTokens;\n+\n+@Path(\"/service\")\n+public class OidcClientResource {\n+\n+    @Inject\n+    OidcClient client;\n+\n+    volatile GrantTokens currentTokens;\n+\n+    @PostConstruct\n+    public init() {\n+        currentTokens = client.getTokens().await().indefinitely();\n+    }\n+\n+    @GET\n+    public String getResponse() {\n+        \n+        GrantTokens tokens = currentTokens;\n+        if (tokens.isAccessTokenExpired) {\n+            tokens = client.refreshTokens(tokens.getRefreshToken().await.indefinitely();\n+            currentTokens = tokens;\n+        } \n+        // use tokens.getAccessToken() to configure MP RestClient Authorization header/etc\n+    }\n+}\n+```\n+\n+== Use OidcClient as Microprofile RestClient client filter\n+\n+`quarkus-oidc-rest-client` extension provides `io.quarkus.oidc.rest.client.OidcClientRequestFilter` JAX-RS ClientRequestFilter which uses `OidcClient` to acquire the access token, refresh it if needed, and set it as an HTTP `Authorization` `Bearer` scheme value.\n+\n+By default this filter will get `OidcClient` to acquire the first pair of access and refresh tokens at its initialization time. If the access tokens are short lived and refresh tokens are not available then the token acquisition should be delayed with `quarkus.oidc-client.early-tokens-acquisition=false`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1MzExOQ==", "bodyText": "Small typo in directly.", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543753119", "createdAt": "2020-12-15T23:07:40Z", "author": {"login": "pedroigor"}, "path": "docs/src/main/asciidoc/security-openid-connect-client.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using OpenID Connect and OAuth2 Client to acquire and refresh access tokens\n+\n+include::./attributes.adoc[]\n+:toc:\n+\n+This guide explains how to use Quarkus `quarkus-oidc-client` and `quarkus-oidc-rest-client` extensions to acquire access tokens from OpenId Connect and OAuth 2.0 compliant Authorization Servers such as https://www.keycloak.org/about.html[Keycloak] and use these tokens as HTTP Authorization Bearer tokens to access the remote services.\n+\n+== Introduction\n+\n+`quarkus-oidc-client` extension provides a reactive `io.quarkus.oidc.client.OidcClient` which can be used to acquire and refresh tokens using Smallrye Mutiny `Uni` and `Vert.x WebClient`.\n+\n+`OidcClient` is initialized at the build time with the IDP token endpoint URL which can be auto-discovered or manually configured and uses this endpoint to acquire access tokens using `client_credentials` or `password` token grants and refresh the tokens using `refresh_token` grant.\n+\n+Here is how `OidcClient` can be configured to use the `client_credentials` grant:\n+\n+```\n+quarkus.oidc.client.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc.client.client-id=quarkus-app\n+quarkus.oidc.client.credentials.secret=secret\n+```\n+\n+Here is how `OidcClient` can be configured to use the `password` grant:\n+\n+```\n+quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc-client.client-id=quarkus-app\n+quarkus.oidc-client.credentials.secret=secret\n+quarkus.oidc-client.grant.type=user\n+quarkus.oidc-client.grant-options.user.name=alice\n+quarkus.oidc-client.grant-options.user.password=alice\n+```\n+\n+Note the OAuth2 `password` grant is enabled with `quarkus.oidc-client.grant.type=user` to avoid duplicating `password` when setting a user password property required by the `password` grant.\n+\n+In both cases `OidcClient` will auto-discover the token endpoint URL and use it to acquire the tokens.\n+\n+== Use OidcClient directly\n+\n+One can use `OidcClient` directly as follows:\n+\n+```\n+import javax.inject.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.GrantTokens;\n+\n+@Path(\"/service\")\n+public class OidcClientResource {\n+\n+    @Inject\n+    OidcClient client;\n+\n+    volatile GrantTokens currentTokens;\n+\n+    @PostConstruct\n+    public init() {\n+        currentTokens = client.getTokens().await().indefinitely();\n+    }\n+\n+    @GET\n+    public String getResponse() {\n+        \n+        GrantTokens tokens = currentTokens;\n+        if (tokens.isAccessTokenExpired) {\n+            tokens = client.refreshTokens(tokens.getRefreshToken().await.indefinitely();\n+            currentTokens = tokens;\n+        } \n+        // use tokens.getAccessToken() to configure MP RestClient Authorization header/etc\n+    }\n+}\n+```\n+\n+== Use OidcClient as Microprofile RestClient client filter\n+\n+`quarkus-oidc-rest-client` extension provides `io.quarkus.oidc.rest.client.OidcClientRequestFilter` JAX-RS ClientRequestFilter which uses `OidcClient` to acquire the access token, refresh it if needed, and set it as an HTTP `Authorization` `Bearer` scheme value.\n+\n+By default this filter will get `OidcClient` to acquire the first pair of access and refresh tokens at its initialization time. If the access tokens are short lived and refresh tokens are not available then the token acquisition should be delayed with `quarkus.oidc-client.early-tokens-acquisition=false`.\n+\n+You can selectively register `OidcClientRequestFilter` by using either `io.quarkus.oidc.rest.client.OidcClientFilter` or `org.eclipse.microprofile.rest.client.annotation.RegisterProvider` annotations:\n+\n+```\n+import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;\n+import io.quarkus.oidc.rest.client.OidcClientFilter;\n+\n+@RegisterRestClient\n+@OidcClientFilter\n+@Path(\"/\")\n+public interface ProtectedResourceService {\n+\n+    @GET\n+    String getUserName();\n+}\n+```\n+\n+or\n+\n+```\n+import org.eclipse.microprofile.rest.client.annotation.RegisterProvider;\n+import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;\n+import io.quarkus.oidc.rest.client.OidcClientRequestFilter;\n+\n+@RegisterRestClient\n+@RegisterProvider(OidcClientRequestFilter.class)\n+@Path(\"/\")\n+public interface ProtectedResourceService {\n+\n+    @GET\n+    String getUserName();\n+}\n+```\n+\n+Alternatively, `OidcClientRequestFilter` can be registered automatically with all MP Rest or JAX-RS clients if `quarkus.oidc.rest.client.register-filter=true` property is set. \n+\n+\n+== Use injected GrantTokens\n+\n+If you prefer you can use your own custom filter and inject `GrantTokens`:\n+\n+```\n+@Provider\n+@Priority(Priorities.AUTHENTICATION)\n+@RequestScoped\n+public class OidcClientRequestCustomFilter implements ClientRequestFilter {\n+\n+    @Inject\n+    GrantTokens grantTokens;\n+\n+    @Override\n+    public void filter(ClientRequestContext requestContext) throws IOException {\n+        requestContext.getHeaders().add(HttpHeaders.AUTHORIZATION, \"Bearer \" + grantTokens.getAccessToken());\n+    }\n+}\n+```\n+\n+The `GrantTokens` producer will acquire and refresh the tokens and the custom filter will decide how and when to use the token.\n+\n+See also the previous section about delaying the token acquisition in some cases.\n+\n+== OidcClients\n+\n+`io.quarkus.oidc.client.OidcClient` is a container of `OidcClient`s - it includes a default `OidcClient` (which can also be injected directrly as described above) and named clients which can be configured like this:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1MzU3NA==", "bodyText": "Maybe this would be nicer if you provide a @OidcClient annotation where you can define a name and have the named  client injected.", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543753574", "createdAt": "2020-12-15T23:08:50Z", "author": {"login": "pedroigor"}, "path": "docs/src/main/asciidoc/security-openid-connect-client.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using OpenID Connect and OAuth2 Client to acquire and refresh access tokens\n+\n+include::./attributes.adoc[]\n+:toc:\n+\n+This guide explains how to use Quarkus `quarkus-oidc-client` and `quarkus-oidc-rest-client` extensions to acquire access tokens from OpenId Connect and OAuth 2.0 compliant Authorization Servers such as https://www.keycloak.org/about.html[Keycloak] and use these tokens as HTTP Authorization Bearer tokens to access the remote services.\n+\n+== Introduction\n+\n+`quarkus-oidc-client` extension provides a reactive `io.quarkus.oidc.client.OidcClient` which can be used to acquire and refresh tokens using Smallrye Mutiny `Uni` and `Vert.x WebClient`.\n+\n+`OidcClient` is initialized at the build time with the IDP token endpoint URL which can be auto-discovered or manually configured and uses this endpoint to acquire access tokens using `client_credentials` or `password` token grants and refresh the tokens using `refresh_token` grant.\n+\n+Here is how `OidcClient` can be configured to use the `client_credentials` grant:\n+\n+```\n+quarkus.oidc.client.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc.client.client-id=quarkus-app\n+quarkus.oidc.client.credentials.secret=secret\n+```\n+\n+Here is how `OidcClient` can be configured to use the `password` grant:\n+\n+```\n+quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc-client.client-id=quarkus-app\n+quarkus.oidc-client.credentials.secret=secret\n+quarkus.oidc-client.grant.type=user\n+quarkus.oidc-client.grant-options.user.name=alice\n+quarkus.oidc-client.grant-options.user.password=alice\n+```\n+\n+Note the OAuth2 `password` grant is enabled with `quarkus.oidc-client.grant.type=user` to avoid duplicating `password` when setting a user password property required by the `password` grant.\n+\n+In both cases `OidcClient` will auto-discover the token endpoint URL and use it to acquire the tokens.\n+\n+== Use OidcClient directly\n+\n+One can use `OidcClient` directly as follows:\n+\n+```\n+import javax.inject.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.GrantTokens;\n+\n+@Path(\"/service\")\n+public class OidcClientResource {\n+\n+    @Inject\n+    OidcClient client;\n+\n+    volatile GrantTokens currentTokens;\n+\n+    @PostConstruct\n+    public init() {\n+        currentTokens = client.getTokens().await().indefinitely();\n+    }\n+\n+    @GET\n+    public String getResponse() {\n+        \n+        GrantTokens tokens = currentTokens;\n+        if (tokens.isAccessTokenExpired) {\n+            tokens = client.refreshTokens(tokens.getRefreshToken().await.indefinitely();\n+            currentTokens = tokens;\n+        } \n+        // use tokens.getAccessToken() to configure MP RestClient Authorization header/etc\n+    }\n+}\n+```\n+\n+== Use OidcClient as Microprofile RestClient client filter\n+\n+`quarkus-oidc-rest-client` extension provides `io.quarkus.oidc.rest.client.OidcClientRequestFilter` JAX-RS ClientRequestFilter which uses `OidcClient` to acquire the access token, refresh it if needed, and set it as an HTTP `Authorization` `Bearer` scheme value.\n+\n+By default this filter will get `OidcClient` to acquire the first pair of access and refresh tokens at its initialization time. If the access tokens are short lived and refresh tokens are not available then the token acquisition should be delayed with `quarkus.oidc-client.early-tokens-acquisition=false`.\n+\n+You can selectively register `OidcClientRequestFilter` by using either `io.quarkus.oidc.rest.client.OidcClientFilter` or `org.eclipse.microprofile.rest.client.annotation.RegisterProvider` annotations:\n+\n+```\n+import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;\n+import io.quarkus.oidc.rest.client.OidcClientFilter;\n+\n+@RegisterRestClient\n+@OidcClientFilter\n+@Path(\"/\")\n+public interface ProtectedResourceService {\n+\n+    @GET\n+    String getUserName();\n+}\n+```\n+\n+or\n+\n+```\n+import org.eclipse.microprofile.rest.client.annotation.RegisterProvider;\n+import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;\n+import io.quarkus.oidc.rest.client.OidcClientRequestFilter;\n+\n+@RegisterRestClient\n+@RegisterProvider(OidcClientRequestFilter.class)\n+@Path(\"/\")\n+public interface ProtectedResourceService {\n+\n+    @GET\n+    String getUserName();\n+}\n+```\n+\n+Alternatively, `OidcClientRequestFilter` can be registered automatically with all MP Rest or JAX-RS clients if `quarkus.oidc.rest.client.register-filter=true` property is set. \n+\n+\n+== Use injected GrantTokens\n+\n+If you prefer you can use your own custom filter and inject `GrantTokens`:\n+\n+```\n+@Provider\n+@Priority(Priorities.AUTHENTICATION)\n+@RequestScoped\n+public class OidcClientRequestCustomFilter implements ClientRequestFilter {\n+\n+    @Inject\n+    GrantTokens grantTokens;\n+\n+    @Override\n+    public void filter(ClientRequestContext requestContext) throws IOException {\n+        requestContext.getHeaders().add(HttpHeaders.AUTHORIZATION, \"Bearer \" + grantTokens.getAccessToken());\n+    }\n+}\n+```\n+\n+The `GrantTokens` producer will acquire and refresh the tokens and the custom filter will decide how and when to use the token.\n+\n+See also the previous section about delaying the token acquisition in some cases.\n+\n+== OidcClients\n+\n+`io.quarkus.oidc.client.OidcClient` is a container of `OidcClient`s - it includes a default `OidcClient` (which can also be injected directrly as described above) and named clients which can be configured like this:\n+\n+```\n+quarkus.oidc-client.client-enabled=false\n+\n+quarkus.oidc-client.jwt-secret.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc-client.jwt-secret.client-id=quarkus-app\n+quarkus.oidc-client.jwt-secret.credentials.jwt.secret=AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow\n+```\n+\n+Note in this case the default client is disabled with a `client-enabled=false` property. The `jwt-secret` client can be accessed like this:\n+\n+[source,java]\n+----\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.OidcClients;\n+\n+@Path(\"/clients\")\n+public class OidcClientResource {\n+\n+    @Inject\n+    OidcClients clients;\n+\n+    @GET\n+    public String getResponse() {\n+        OidcClient client = clients.getClient(\"jwt-secret\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1NDk1Mg==", "bodyText": "You probably have a reason for that ... Wouldn't be better Tokens ?", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543754952", "createdAt": "2020-12-15T23:11:56Z", "author": {"login": "pedroigor"}, "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/GrantTokens.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package io.quarkus.oidc.client;\n+\n+/**\n+ * Access and Refresh tokens returned from a token grant request\n+ */\n+public class GrantTokens {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc1NTkyNw==", "bodyText": "Maybe a no-arg refreshTokens would help to avoid boilerplate code to get refresh token and then call this method?", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543755927", "createdAt": "2020-12-15T23:14:02Z", "author": {"login": "pedroigor"}, "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/OidcClient.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package io.quarkus.oidc.client;\n+\n+import java.io.Closeable;\n+\n+import io.smallrye.mutiny.Uni;\n+\n+/**\n+ * Token grant client\n+ */\n+public interface OidcClient extends Closeable {\n+\n+    /**\n+     * Returns the grant tokens\n+     */\n+    Uni<GrantTokens> getTokens();\n+\n+    /**\n+     * Refreshes the grant tokens\n+     */\n+    Uni<GrantTokens> refreshTokens(String refreshToken);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzMTEzNDI1", "url": "https://github.com/quarkusio/quarkus/pull/13641#pullrequestreview-553113425", "createdAt": "2020-12-15T23:46:49Z", "commit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e"}, "state": "DISMISSED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMzo0Njo0OVrOIGlFvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMDowOTozM1rOIGlqQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MDA0Nw==", "bodyText": "Shouldn't this guard against concurrent refresh? If you send off multiple client requests at once (e.g. when using a reactive client), you need to track if there is an operation in progress and piggy back on the existing operation rather than attempting another concurrent refresh.", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543770047", "createdAt": "2020-12-15T23:46:49Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/GrantTokensHelper.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.smallrye.mutiny.Uni;\n+\n+public class GrantTokensHelper {\n+\n+    private volatile GrantTokens grantTokens;\n+\n+    public GrantTokens prepareTokens(OidcClient oidcClient) {\n+        if (grantTokens == null) {\n+            grantTokens = oidcClient.getTokens().await().indefinitely();\n+        }\n+        return grantTokens;\n+    }\n+\n+    public Uni<GrantTokens> getTokens(OidcClient oidcClient) {\n+\n+        GrantTokens currentTokens = prepareTokens(oidcClient);\n+\n+        if (currentTokens.isAccessTokenExpired()) {\n+            // Particularly, a client_credentials response is not guaranteed to return a refresh token\n+            Uni<GrantTokens> newTokensUni = currentTokens.getRefreshToken() != null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MTExNw==", "bodyText": "I don't think this is the correct scope? It means you will be getting a new token for every request?", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543771117", "createdAt": "2020-12-15T23:49:27Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/GrantTokensProducer.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import javax.enterprise.context.RequestScoped;\n+import javax.enterprise.inject.Produces;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+\n+@RequestScoped\n+public class GrantTokensProducer extends AbstractGrantTokensProducer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MTU2Ng==", "bodyText": "These tokens are dependent scoped, so they will have the same lifecycle as the object they are injected into. If you inject them into an @ApplicationScoped bean or a singleton they will never be refreshed.", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543771566", "createdAt": "2020-12-15T23:50:30Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/GrantTokensProducer.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import javax.enterprise.context.RequestScoped;\n+import javax.enterprise.inject.Produces;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+\n+@RequestScoped\n+public class GrantTokensProducer extends AbstractGrantTokensProducer {\n+\n+    @Produces\n+    public GrantTokens produceTokens() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MjEwMg==", "bodyText": "I think a lot of these should be final.", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543772102", "createdAt": "2020-12-15T23:51:35Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/OidcClientImpl.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Key;\n+import java.util.Base64;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.microprofile.jwt.Claims;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.OidcClientException;\n+import io.quarkus.oidc.client.runtime.OidcClientConfig.Grant;\n+import io.quarkus.oidc.common.runtime.OidcCommonUtils;\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.mutiny.subscription.UniEmitter;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.mutiny.core.MultiMap;\n+import io.vertx.mutiny.core.buffer.Buffer;\n+import io.vertx.mutiny.ext.web.client.HttpRequest;\n+import io.vertx.mutiny.ext.web.client.HttpResponse;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+\n+public class OidcClientImpl implements OidcClient {\n+\n+    private static final Logger LOG = Logger.getLogger(OidcClientImpl.class);\n+\n+    private static final String ACCESS_TOKEN = \"access_token\";\n+    private static final String REFRESH_TOKEN = \"refresh_token\";\n+    private static final String EXPIRES_AT = \"expires_at\";\n+\n+    private static final String CLIENT_ASSERTION = \"client_assertion\";\n+    private static final String CLIENT_ASSERTION_TYPE = \"client_assertion_type\";\n+    private static final String JWT_BEARER_CLIENT_ASSERTION_TYPE = \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\";\n+\n+    private static final String AUTHORIZATION_HEADER = String.valueOf(HttpHeaders.AUTHORIZATION);\n+\n+    private WebClient client;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MzY4Mg==", "bodyText": "I think you can just use transform rather than transformToUni here, as emitGrantTokens does not do anything async.", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543773682", "createdAt": "2020-12-15T23:55:07Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/OidcClientImpl.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Key;\n+import java.util.Base64;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.microprofile.jwt.Claims;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.OidcClientException;\n+import io.quarkus.oidc.client.runtime.OidcClientConfig.Grant;\n+import io.quarkus.oidc.common.runtime.OidcCommonUtils;\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.mutiny.subscription.UniEmitter;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.mutiny.core.MultiMap;\n+import io.vertx.mutiny.core.buffer.Buffer;\n+import io.vertx.mutiny.ext.web.client.HttpRequest;\n+import io.vertx.mutiny.ext.web.client.HttpResponse;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+\n+public class OidcClientImpl implements OidcClient {\n+\n+    private static final Logger LOG = Logger.getLogger(OidcClientImpl.class);\n+\n+    private static final String ACCESS_TOKEN = \"access_token\";\n+    private static final String REFRESH_TOKEN = \"refresh_token\";\n+    private static final String EXPIRES_AT = \"expires_at\";\n+\n+    private static final String CLIENT_ASSERTION = \"client_assertion\";\n+    private static final String CLIENT_ASSERTION_TYPE = \"client_assertion_type\";\n+    private static final String JWT_BEARER_CLIENT_ASSERTION_TYPE = \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\";\n+\n+    private static final String AUTHORIZATION_HEADER = String.valueOf(HttpHeaders.AUTHORIZATION);\n+\n+    private WebClient client;\n+    private String tokenRequestUri;\n+    private MultiMap tokenGrantParams;\n+    private MultiMap commonRefreshGrantParams;\n+    private String grantType;\n+    private String clientSecretBasicAuthScheme;\n+    private Key clientJwtKey;\n+    private OidcClientConfig oidcConfig;\n+\n+    public OidcClientImpl() {\n+    }\n+\n+    public OidcClientImpl(WebClient client, String tokenRequestUri,\n+            MultiMap tokenGrantParams, MultiMap commonRefreshGrantParams, OidcClientConfig oidcClientConfig) {\n+        this.client = client;\n+        this.tokenRequestUri = tokenRequestUri;\n+        this.tokenGrantParams = tokenGrantParams;\n+        this.commonRefreshGrantParams = commonRefreshGrantParams;\n+        this.grantType = oidcClientConfig.grant.type == Grant.Type.CLIENT ? \"client_credentials\" : \"password\";\n+        this.oidcConfig = oidcClientConfig;\n+        initClientSecretBasicAuth();\n+    }\n+\n+    private void initClientSecretBasicAuth() {\n+        if (OidcCommonUtils.isClientSecretBasicAuthRequired(oidcConfig.credentials)) {\n+            clientSecretBasicAuthScheme = \"Basic \"\n+                    + Base64.getEncoder().encodeToString(\n+                            (oidcConfig.getClientId().get() + \":\" + OidcCommonUtils.clientSecret(oidcConfig.credentials))\n+                                    .getBytes(StandardCharsets.UTF_8));\n+        } else if (OidcCommonUtils.isClientJwtAuthRequired(oidcConfig.credentials)) {\n+            // if it is a refresh then a map has already been copied\n+            clientJwtKey = OidcCommonUtils.clientJwtKey(oidcConfig.credentials);\n+        }\n+    }\n+\n+    @Override\n+    public Uni<GrantTokens> getTokens() {\n+        return getJsonResponse(tokenGrantParams, false);\n+    }\n+\n+    @Override\n+    public Uni<GrantTokens> refreshTokens(String refreshToken) {\n+        if (refreshToken == null) {\n+            throw new OidcClientException(\"Refresh token is null\");\n+        }\n+        MultiMap refreshGrantParams = copyMultiMap(commonRefreshGrantParams);\n+        refreshGrantParams.add(REFRESH_TOKEN, refreshToken);\n+        return getJsonResponse(refreshGrantParams, true);\n+    }\n+\n+    private Uni<GrantTokens> getJsonResponse(MultiMap body, boolean refresh) {\n+        HttpRequest<Buffer> request = client.post(tokenRequestUri);\n+        if (clientSecretBasicAuthScheme != null) {\n+            request.putHeader(AUTHORIZATION_HEADER, clientSecretBasicAuthScheme);\n+        } else if (clientJwtKey != null) {\n+            // if it is a refresh then a map has already been copied\n+            body = !refresh ? copyMultiMap(body) : body;\n+            body.add(CLIENT_ASSERTION_TYPE, JWT_BEARER_CLIENT_ASSERTION_TYPE);\n+            body.add(CLIENT_ASSERTION, OidcCommonUtils.signJwtWithKey(oidcConfig, clientJwtKey));\n+        }\n+        return request.sendForm(body).onItem()\n+                .transformToUni(resp -> emitGrantTokens(resp, refresh));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MzkyOA==", "bodyText": "Why would this happen? Shouldn't this give some kind of user feedback?", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543773928", "createdAt": "2020-12-15T23:55:46Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/OidcClientImpl.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Key;\n+import java.util.Base64;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.microprofile.jwt.Claims;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.OidcClientException;\n+import io.quarkus.oidc.client.runtime.OidcClientConfig.Grant;\n+import io.quarkus.oidc.common.runtime.OidcCommonUtils;\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.mutiny.subscription.UniEmitter;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.mutiny.core.MultiMap;\n+import io.vertx.mutiny.core.buffer.Buffer;\n+import io.vertx.mutiny.ext.web.client.HttpRequest;\n+import io.vertx.mutiny.ext.web.client.HttpResponse;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+\n+public class OidcClientImpl implements OidcClient {\n+\n+    private static final Logger LOG = Logger.getLogger(OidcClientImpl.class);\n+\n+    private static final String ACCESS_TOKEN = \"access_token\";\n+    private static final String REFRESH_TOKEN = \"refresh_token\";\n+    private static final String EXPIRES_AT = \"expires_at\";\n+\n+    private static final String CLIENT_ASSERTION = \"client_assertion\";\n+    private static final String CLIENT_ASSERTION_TYPE = \"client_assertion_type\";\n+    private static final String JWT_BEARER_CLIENT_ASSERTION_TYPE = \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\";\n+\n+    private static final String AUTHORIZATION_HEADER = String.valueOf(HttpHeaders.AUTHORIZATION);\n+\n+    private WebClient client;\n+    private String tokenRequestUri;\n+    private MultiMap tokenGrantParams;\n+    private MultiMap commonRefreshGrantParams;\n+    private String grantType;\n+    private String clientSecretBasicAuthScheme;\n+    private Key clientJwtKey;\n+    private OidcClientConfig oidcConfig;\n+\n+    public OidcClientImpl() {\n+    }\n+\n+    public OidcClientImpl(WebClient client, String tokenRequestUri,\n+            MultiMap tokenGrantParams, MultiMap commonRefreshGrantParams, OidcClientConfig oidcClientConfig) {\n+        this.client = client;\n+        this.tokenRequestUri = tokenRequestUri;\n+        this.tokenGrantParams = tokenGrantParams;\n+        this.commonRefreshGrantParams = commonRefreshGrantParams;\n+        this.grantType = oidcClientConfig.grant.type == Grant.Type.CLIENT ? \"client_credentials\" : \"password\";\n+        this.oidcConfig = oidcClientConfig;\n+        initClientSecretBasicAuth();\n+    }\n+\n+    private void initClientSecretBasicAuth() {\n+        if (OidcCommonUtils.isClientSecretBasicAuthRequired(oidcConfig.credentials)) {\n+            clientSecretBasicAuthScheme = \"Basic \"\n+                    + Base64.getEncoder().encodeToString(\n+                            (oidcConfig.getClientId().get() + \":\" + OidcCommonUtils.clientSecret(oidcConfig.credentials))\n+                                    .getBytes(StandardCharsets.UTF_8));\n+        } else if (OidcCommonUtils.isClientJwtAuthRequired(oidcConfig.credentials)) {\n+            // if it is a refresh then a map has already been copied\n+            clientJwtKey = OidcCommonUtils.clientJwtKey(oidcConfig.credentials);\n+        }\n+    }\n+\n+    @Override\n+    public Uni<GrantTokens> getTokens() {\n+        return getJsonResponse(tokenGrantParams, false);\n+    }\n+\n+    @Override\n+    public Uni<GrantTokens> refreshTokens(String refreshToken) {\n+        if (refreshToken == null) {\n+            throw new OidcClientException(\"Refresh token is null\");\n+        }\n+        MultiMap refreshGrantParams = copyMultiMap(commonRefreshGrantParams);\n+        refreshGrantParams.add(REFRESH_TOKEN, refreshToken);\n+        return getJsonResponse(refreshGrantParams, true);\n+    }\n+\n+    private Uni<GrantTokens> getJsonResponse(MultiMap body, boolean refresh) {\n+        HttpRequest<Buffer> request = client.post(tokenRequestUri);\n+        if (clientSecretBasicAuthScheme != null) {\n+            request.putHeader(AUTHORIZATION_HEADER, clientSecretBasicAuthScheme);\n+        } else if (clientJwtKey != null) {\n+            // if it is a refresh then a map has already been copied\n+            body = !refresh ? copyMultiMap(body) : body;\n+            body.add(CLIENT_ASSERTION_TYPE, JWT_BEARER_CLIENT_ASSERTION_TYPE);\n+            body.add(CLIENT_ASSERTION, OidcCommonUtils.signJwtWithKey(oidcConfig, clientJwtKey));\n+        }\n+        return request.sendForm(body).onItem()\n+                .transformToUni(resp -> emitGrantTokens(resp, refresh));\n+    }\n+\n+    private Uni<GrantTokens> emitGrantTokens(HttpResponse<Buffer> resp, boolean refresh) {\n+        return Uni.createFrom().emitter(new Consumer<UniEmitter<? super GrantTokens>>() {\n+            @Override\n+            public void accept(UniEmitter<? super GrantTokens> emitter) {\n+                if (resp.statusCode() == 200) {\n+                    LOG.debugf(\"Tokens have been %s\", refresh ? \"refreshed\" : \"acquired\");\n+                    JsonObject json = resp.bodyAsJsonObject();\n+                    final String accessToken = json.getString(ACCESS_TOKEN);\n+                    final String refreshToken = json.getString(REFRESH_TOKEN);\n+                    Long accessTokenExpiresAt = json.getLong(EXPIRES_AT);\n+                    if (accessTokenExpiresAt == null) {\n+                        accessTokenExpiresAt = getExpiresJwtClaim(accessToken);\n+                    }\n+                    emitter.complete(new GrantTokens(accessToken, accessTokenExpiresAt, refreshToken));\n+                } else {\n+                    LOG.errorf(\"%s token grant request has failed: %s\", (refresh ? \"refresh\" : grantType), resp.bodyAsString());\n+                    emitter.fail(new OidcClientException());\n+                }\n+            }\n+        });\n+    }\n+\n+    private static Long getExpiresJwtClaim(String accessToken) {\n+        String[] parts = accessToken.split(\"\\\\.\");\n+        if (parts.length == 3) {\n+            try {\n+                JsonObject claims = new JsonObject(new String(Base64.getUrlDecoder().decode(parts[1]), StandardCharsets.UTF_8));\n+                return claims.getLong(Claims.exp.name());\n+            } catch (IllegalArgumentException ex) {\n+                return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3NDM2MA==", "bodyText": "It does not really matter, but you don't have to use RuntimeValue unless the item can't be proxied. OidcClients is an interface so it is not really needed.", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543774360", "createdAt": "2020-12-15T23:56:52Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/OidcClientRecorder.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.OidcClientException;\n+import io.quarkus.oidc.client.OidcClients;\n+import io.quarkus.oidc.client.runtime.OidcClientConfig.Grant;\n+import io.quarkus.oidc.common.runtime.OidcCommonConfig.Credentials;\n+import io.quarkus.oidc.common.runtime.OidcCommonUtils;\n+import io.quarkus.runtime.RuntimeValue;\n+import io.quarkus.runtime.TlsConfig;\n+import io.quarkus.runtime.annotations.Recorder;\n+import io.quarkus.runtime.configuration.ConfigurationException;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.mutiny.core.MultiMap;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+\n+@Recorder\n+public class OidcClientRecorder {\n+\n+    private static final Logger LOG = Logger.getLogger(OidcClientRecorder.class);\n+\n+    public RuntimeValue<OidcClients> setup(OidcClientsConfig oidcClientsConfig, TlsConfig tlsConfig, Supplier<Vertx> vertx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3NTAxMw==", "bodyText": "There are lots of these 'magic constants' everywhere. I think we should add an OIDCConstants class somewhere with constants for all these.", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543775013", "createdAt": "2020-12-15T23:58:33Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/OidcClientRecorder.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.OidcClientException;\n+import io.quarkus.oidc.client.OidcClients;\n+import io.quarkus.oidc.client.runtime.OidcClientConfig.Grant;\n+import io.quarkus.oidc.common.runtime.OidcCommonConfig.Credentials;\n+import io.quarkus.oidc.common.runtime.OidcCommonUtils;\n+import io.quarkus.runtime.RuntimeValue;\n+import io.quarkus.runtime.TlsConfig;\n+import io.quarkus.runtime.annotations.Recorder;\n+import io.quarkus.runtime.configuration.ConfigurationException;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.mutiny.core.MultiMap;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+\n+@Recorder\n+public class OidcClientRecorder {\n+\n+    private static final Logger LOG = Logger.getLogger(OidcClientRecorder.class);\n+\n+    public RuntimeValue<OidcClients> setup(OidcClientsConfig oidcClientsConfig, TlsConfig tlsConfig, Supplier<Vertx> vertx) {\n+        OidcClient defaultClient = createOidcClient(oidcClientsConfig.defaultClient, \"Default\", tlsConfig, vertx);\n+\n+        Map<String, OidcClient> staticOidcClients = new HashMap<>();\n+\n+        for (Map.Entry<String, OidcClientConfig> clientConfig : oidcClientsConfig.namedClients.entrySet()) {\n+            staticOidcClients.put(clientConfig.getKey(),\n+                    createOidcClient(clientConfig.getValue(), clientConfig.getKey(), tlsConfig, vertx));\n+        }\n+\n+        return new RuntimeValue<>(new OidcClientsImpl(defaultClient, staticOidcClients));\n+    }\n+\n+    public Supplier<OidcClient> createOidcClientBean(RuntimeValue<OidcClients> clients) {\n+        return new Supplier<OidcClient>() {\n+\n+            @Override\n+            public OidcClient get() {\n+                return clients.getValue().getClient();\n+            }\n+        };\n+    }\n+\n+    public Supplier<OidcClients> createOidcClientsBean(RuntimeValue<OidcClients> clients) {\n+        return new Supplier<OidcClients>() {\n+\n+            @Override\n+            public OidcClients get() {\n+                return clients.getValue();\n+            }\n+        };\n+    }\n+\n+    protected static OidcClient createOidcClient(OidcClientConfig oidcConfig, String oidcClientId,\n+            TlsConfig tlsConfig, Supplier<Vertx> vertx) {\n+        if (!oidcConfig.clientEnabled) {\n+            String message = String.format(\"'%s' client configuration is disabled\", oidcClientId);\n+            LOG.debug(message);\n+            return new OidcClient() {\n+\n+                @Override\n+                public Uni<GrantTokens> getTokens() {\n+                    throw new OidcClientException(message);\n+                }\n+\n+                @Override\n+                public Uni<GrantTokens> refreshTokens(String refreshToken) {\n+                    throw new OidcClientException(message);\n+                }\n+\n+                @Override\n+                public void close() throws IOException {\n+                }\n+            };\n+        }\n+\n+        OidcCommonUtils.verifyCommonConfiguration(oidcConfig);\n+\n+        String authServerUriString = OidcCommonUtils.getAuthServerUrl(oidcConfig);\n+\n+        WebClientOptions options = new WebClientOptions();\n+\n+        URI authServerUri = URI.create(authServerUriString);\n+        if (authServerUri.getPort() != -1) {\n+            options.setDefaultPort(authServerUri.getPort());\n+        }\n+        OidcCommonUtils.setHttpClientOptions(oidcConfig, tlsConfig, options);\n+\n+        WebClient client = WebClient.create(new io.vertx.mutiny.core.Vertx(vertx.get()), options);\n+\n+        String tokenRequestUri = null;\n+        if (!oidcConfig.discoveryEnabled) {\n+            tokenRequestUri = OidcCommonUtils.getOidcEndpointUrl(authServerUriString, oidcConfig.tokenPath);\n+        } else {\n+            tokenRequestUri = discoverTokenRequestUri(client, authServerUriString, oidcConfig);\n+        }\n+        if (tokenRequestUri == null) {\n+            throw new ConfigurationException(\n+                    \"OpenId Connect Provider token endpoint URL is not configured and can not be discovered\");\n+        }\n+\n+        MultiMap tokenGrantParams = new MultiMap(io.vertx.core.MultiMap.caseInsensitiveMultiMap());\n+        setGrantClientParams(oidcConfig, tokenGrantParams,\n+                oidcConfig.grant.type == Grant.Type.CLIENT ? \"client_credentials\" : \"password\");\n+        if (oidcConfig.grant.type == Grant.Type.USER) {\n+            Map<String, String> passwordGrantOptions = oidcConfig.grantOptions.get(\"user\");\n+            tokenGrantParams.add(\"username\", passwordGrantOptions.get(\"name\"));\n+            tokenGrantParams.add(\"password\", passwordGrantOptions.get(\"password\"));\n+        }\n+\n+        MultiMap commonRefreshGrantParams = new MultiMap(io.vertx.core.MultiMap.caseInsensitiveMultiMap());\n+        setGrantClientParams(oidcConfig, commonRefreshGrantParams, \"refresh_token\");\n+\n+        return new OidcClientImpl(client, tokenRequestUri, tokenGrantParams, commonRefreshGrantParams, oidcConfig);\n+    }\n+\n+    private static void setGrantClientParams(OidcClientConfig oidcConfig, MultiMap grantParams, String grantType) {\n+        grantParams.add(\"grant_type\", grantType);\n+        Credentials creds = oidcConfig.getCredentials();\n+        if (OidcCommonUtils.isClientSecretPostAuthRequired(creds)) {\n+            grantParams.add(\"client_id\", oidcConfig.clientId.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3NTU5Nw==", "bodyText": "Shouldn't this throw an exception to trigger the retry code above?", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543775597", "createdAt": "2020-12-15T23:59:58Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/OidcClientRecorder.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.OidcClientException;\n+import io.quarkus.oidc.client.OidcClients;\n+import io.quarkus.oidc.client.runtime.OidcClientConfig.Grant;\n+import io.quarkus.oidc.common.runtime.OidcCommonConfig.Credentials;\n+import io.quarkus.oidc.common.runtime.OidcCommonUtils;\n+import io.quarkus.runtime.RuntimeValue;\n+import io.quarkus.runtime.TlsConfig;\n+import io.quarkus.runtime.annotations.Recorder;\n+import io.quarkus.runtime.configuration.ConfigurationException;\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.mutiny.core.MultiMap;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+\n+@Recorder\n+public class OidcClientRecorder {\n+\n+    private static final Logger LOG = Logger.getLogger(OidcClientRecorder.class);\n+\n+    public RuntimeValue<OidcClients> setup(OidcClientsConfig oidcClientsConfig, TlsConfig tlsConfig, Supplier<Vertx> vertx) {\n+        OidcClient defaultClient = createOidcClient(oidcClientsConfig.defaultClient, \"Default\", tlsConfig, vertx);\n+\n+        Map<String, OidcClient> staticOidcClients = new HashMap<>();\n+\n+        for (Map.Entry<String, OidcClientConfig> clientConfig : oidcClientsConfig.namedClients.entrySet()) {\n+            staticOidcClients.put(clientConfig.getKey(),\n+                    createOidcClient(clientConfig.getValue(), clientConfig.getKey(), tlsConfig, vertx));\n+        }\n+\n+        return new RuntimeValue<>(new OidcClientsImpl(defaultClient, staticOidcClients));\n+    }\n+\n+    public Supplier<OidcClient> createOidcClientBean(RuntimeValue<OidcClients> clients) {\n+        return new Supplier<OidcClient>() {\n+\n+            @Override\n+            public OidcClient get() {\n+                return clients.getValue().getClient();\n+            }\n+        };\n+    }\n+\n+    public Supplier<OidcClients> createOidcClientsBean(RuntimeValue<OidcClients> clients) {\n+        return new Supplier<OidcClients>() {\n+\n+            @Override\n+            public OidcClients get() {\n+                return clients.getValue();\n+            }\n+        };\n+    }\n+\n+    protected static OidcClient createOidcClient(OidcClientConfig oidcConfig, String oidcClientId,\n+            TlsConfig tlsConfig, Supplier<Vertx> vertx) {\n+        if (!oidcConfig.clientEnabled) {\n+            String message = String.format(\"'%s' client configuration is disabled\", oidcClientId);\n+            LOG.debug(message);\n+            return new OidcClient() {\n+\n+                @Override\n+                public Uni<GrantTokens> getTokens() {\n+                    throw new OidcClientException(message);\n+                }\n+\n+                @Override\n+                public Uni<GrantTokens> refreshTokens(String refreshToken) {\n+                    throw new OidcClientException(message);\n+                }\n+\n+                @Override\n+                public void close() throws IOException {\n+                }\n+            };\n+        }\n+\n+        OidcCommonUtils.verifyCommonConfiguration(oidcConfig);\n+\n+        String authServerUriString = OidcCommonUtils.getAuthServerUrl(oidcConfig);\n+\n+        WebClientOptions options = new WebClientOptions();\n+\n+        URI authServerUri = URI.create(authServerUriString);\n+        if (authServerUri.getPort() != -1) {\n+            options.setDefaultPort(authServerUri.getPort());\n+        }\n+        OidcCommonUtils.setHttpClientOptions(oidcConfig, tlsConfig, options);\n+\n+        WebClient client = WebClient.create(new io.vertx.mutiny.core.Vertx(vertx.get()), options);\n+\n+        String tokenRequestUri = null;\n+        if (!oidcConfig.discoveryEnabled) {\n+            tokenRequestUri = OidcCommonUtils.getOidcEndpointUrl(authServerUriString, oidcConfig.tokenPath);\n+        } else {\n+            tokenRequestUri = discoverTokenRequestUri(client, authServerUriString, oidcConfig);\n+        }\n+        if (tokenRequestUri == null) {\n+            throw new ConfigurationException(\n+                    \"OpenId Connect Provider token endpoint URL is not configured and can not be discovered\");\n+        }\n+\n+        MultiMap tokenGrantParams = new MultiMap(io.vertx.core.MultiMap.caseInsensitiveMultiMap());\n+        setGrantClientParams(oidcConfig, tokenGrantParams,\n+                oidcConfig.grant.type == Grant.Type.CLIENT ? \"client_credentials\" : \"password\");\n+        if (oidcConfig.grant.type == Grant.Type.USER) {\n+            Map<String, String> passwordGrantOptions = oidcConfig.grantOptions.get(\"user\");\n+            tokenGrantParams.add(\"username\", passwordGrantOptions.get(\"name\"));\n+            tokenGrantParams.add(\"password\", passwordGrantOptions.get(\"password\"));\n+        }\n+\n+        MultiMap commonRefreshGrantParams = new MultiMap(io.vertx.core.MultiMap.caseInsensitiveMultiMap());\n+        setGrantClientParams(oidcConfig, commonRefreshGrantParams, \"refresh_token\");\n+\n+        return new OidcClientImpl(client, tokenRequestUri, tokenGrantParams, commonRefreshGrantParams, oidcConfig);\n+    }\n+\n+    private static void setGrantClientParams(OidcClientConfig oidcConfig, MultiMap grantParams, String grantType) {\n+        grantParams.add(\"grant_type\", grantType);\n+        Credentials creds = oidcConfig.getCredentials();\n+        if (OidcCommonUtils.isClientSecretPostAuthRequired(creds)) {\n+            grantParams.add(\"client_id\", oidcConfig.clientId.get());\n+            grantParams.add(\"client_secret\", OidcCommonUtils.clientSecret(creds));\n+        }\n+        if (oidcConfig.scopes.isPresent()) {\n+            grantParams.add(\"scope\", oidcConfig.scopes.get().stream().collect(Collectors.joining(\" \")));\n+        }\n+    }\n+\n+    private static String discoverTokenRequestUri(WebClient client, String authServerUrl, OidcClientConfig oidcConfig) {\n+        final long connectionRetryCount = OidcCommonUtils.getConnectionRetryCount(oidcConfig);\n+        if (connectionRetryCount > 1) {\n+            LOG.infof(\"Connecting to IDP for up to %d times every 2 seconds\", connectionRetryCount);\n+        }\n+\n+        for (long i = 0; i < connectionRetryCount; i++) {\n+            try {\n+                if (oidcConfig.discoveryEnabled) {\n+                    return discoverTokenEndpoint(client, authServerUrl);\n+                }\n+                break;\n+            } catch (Throwable throwable) {\n+                while (throwable instanceof CompletionException && throwable.getCause() != null) {\n+                    throwable = throwable.getCause();\n+                }\n+                if (throwable instanceof OidcClientException) {\n+                    if (i + 1 < connectionRetryCount) {\n+                        try {\n+                            Thread.sleep(2000);\n+                        } catch (InterruptedException iex) {\n+                            // continue connecting\n+                        }\n+                    } else {\n+                        throw (OidcClientException) throwable;\n+                    }\n+                } else {\n+                    throw new OidcClientException(throwable);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static String discoverTokenEndpoint(WebClient client, String authServerUrl) {\n+        String discoveryUrl = authServerUrl + \"/.well-known/openid-configuration\";\n+        return client.get(discoveryUrl).send().onItem().transform(resp -> {\n+            if (resp.statusCode() == 200) {\n+                JsonObject json = resp.bodyAsJsonObject();\n+                return json.getString(\"token_endpoint\");\n+            } else {\n+                LOG.tracef(\"Discovery has failed, status code: %d\", resp.statusCode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3Njg3Nw==", "bodyText": "At some point we should look at consolidating these into some kind of common utility. It could actually be useful for end users as well to have an easy way to setup keycloak for tests.", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543776877", "createdAt": "2020-12-16T00:03:08Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/oidc-rest-client/deployment/src/test/java/io/quarkus/oidc/rest/client/KeycloakRealmResourceManager.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package io.quarkus.oidc.rest.client;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.keycloak.representations.AccessTokenResponse;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.representations.idm.CredentialRepresentation;\n+import org.keycloak.representations.idm.RealmRepresentation;\n+import org.keycloak.representations.idm.RoleRepresentation;\n+import org.keycloak.representations.idm.RolesRepresentation;\n+import org.keycloak.representations.idm.UserRepresentation;\n+import org.keycloak.util.JsonSerialization;\n+\n+import io.quarkus.test.common.QuarkusTestResourceLifecycleManager;\n+import io.restassured.RestAssured;\n+\n+public class KeycloakRealmResourceManager implements QuarkusTestResourceLifecycleManager {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3OTM5Mg==", "bodyText": "I don't think you should allow direct injection of the GrantTokens, as there is no CDI scope that this maps to. It would be very easy to accidentally inject them into a long lived object, which will appear to work for a while until the tokens expire (e.g. likely work in tests and staging, then fail once the production env has been up for a while). This example only works because you have made the filter @RequestScoped, which is not something we really encourage.\nI think you should instead inject a GrantTokensProducer, which as a get() and getAsync() method. This object can be application scoped and actually manage the tokens in a thread safe manner so that new tokens don't need to be acquired per request.", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r543779392", "createdAt": "2020-12-16T00:09:33Z", "author": {"login": "stuartwdouglas"}, "path": "docs/src/main/asciidoc/security-openid-connect-client.adoc", "diffHunk": "@@ -0,0 +1,218 @@\n+////\n+This guide is maintained in the main Quarkus repository\n+and pull requests should be submitted there:\n+https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc\n+////\n+= Quarkus - Using OpenID Connect and OAuth2 Client to acquire and refresh access tokens\n+\n+include::./attributes.adoc[]\n+:toc:\n+\n+This guide explains how to use Quarkus `quarkus-oidc-client` and `quarkus-oidc-rest-client` extensions to acquire access tokens from OpenId Connect and OAuth 2.0 compliant Authorization Servers such as https://www.keycloak.org/about.html[Keycloak] and use these tokens as HTTP Authorization Bearer tokens to access the remote services.\n+\n+== Introduction\n+\n+`quarkus-oidc-client` extension provides a reactive `io.quarkus.oidc.client.OidcClient` which can be used to acquire and refresh tokens using Smallrye Mutiny `Uni` and `Vert.x WebClient`.\n+\n+`OidcClient` is initialized at the build time with the IDP token endpoint URL which can be auto-discovered or manually configured and uses this endpoint to acquire access tokens using `client_credentials` or `password` token grants and refresh the tokens using `refresh_token` grant.\n+\n+Here is how `OidcClient` can be configured to use the `client_credentials` grant:\n+\n+```\n+quarkus.oidc.client.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc.client.client-id=quarkus-app\n+quarkus.oidc.client.credentials.secret=secret\n+```\n+\n+Here is how `OidcClient` can be configured to use the `password` grant:\n+\n+```\n+quarkus.oidc-client.auth-server-url=${keycloak.url}/realms/quarkus2/\n+quarkus.oidc-client.client-id=quarkus-app\n+quarkus.oidc-client.credentials.secret=secret\n+quarkus.oidc-client.grant.type=user\n+quarkus.oidc-client.grant-options.user.name=alice\n+quarkus.oidc-client.grant-options.user.password=alice\n+```\n+\n+Note the OAuth2 `password` grant is enabled with `quarkus.oidc-client.grant.type=user` to avoid duplicating `password` when setting a user password property required by the `password` grant.\n+\n+In both cases `OidcClient` will auto-discover the token endpoint URL and use it to acquire the tokens.\n+\n+== Use OidcClient directly\n+\n+One can use `OidcClient` directly as follows:\n+\n+```\n+import javax.inject.PostConstruct;\n+import javax.inject.Inject;\n+import javax.ws.rs.GET;\n+\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.GrantTokens;\n+\n+@Path(\"/service\")\n+public class OidcClientResource {\n+\n+    @Inject\n+    OidcClient client;\n+\n+    volatile GrantTokens currentTokens;\n+\n+    @PostConstruct\n+    public init() {\n+        currentTokens = client.getTokens().await().indefinitely();\n+    }\n+\n+    @GET\n+    public String getResponse() {\n+        \n+        GrantTokens tokens = currentTokens;\n+        if (tokens.isAccessTokenExpired) {\n+            tokens = client.refreshTokens(tokens.getRefreshToken().await.indefinitely();\n+            currentTokens = tokens;\n+        } \n+        // use tokens.getAccessToken() to configure MP RestClient Authorization header/etc\n+    }\n+}\n+```\n+\n+== Use OidcClient as Microprofile RestClient client filter\n+\n+`quarkus-oidc-rest-client` extension provides `io.quarkus.oidc.rest.client.OidcClientRequestFilter` JAX-RS ClientRequestFilter which uses `OidcClient` to acquire the access token, refresh it if needed, and set it as an HTTP `Authorization` `Bearer` scheme value.\n+\n+By default this filter will get `OidcClient` to acquire the first pair of access and refresh tokens at its initialization time. If the access tokens are short lived and refresh tokens are not available then the token acquisition should be delayed with `quarkus.oidc-client.early-tokens-acquisition=false`.\n+\n+You can selectively register `OidcClientRequestFilter` by using either `io.quarkus.oidc.rest.client.OidcClientFilter` or `org.eclipse.microprofile.rest.client.annotation.RegisterProvider` annotations:\n+\n+```\n+import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;\n+import io.quarkus.oidc.rest.client.OidcClientFilter;\n+\n+@RegisterRestClient\n+@OidcClientFilter\n+@Path(\"/\")\n+public interface ProtectedResourceService {\n+\n+    @GET\n+    String getUserName();\n+}\n+```\n+\n+or\n+\n+```\n+import org.eclipse.microprofile.rest.client.annotation.RegisterProvider;\n+import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;\n+import io.quarkus.oidc.rest.client.OidcClientRequestFilter;\n+\n+@RegisterRestClient\n+@RegisterProvider(OidcClientRequestFilter.class)\n+@Path(\"/\")\n+public interface ProtectedResourceService {\n+\n+    @GET\n+    String getUserName();\n+}\n+```\n+\n+Alternatively, `OidcClientRequestFilter` can be registered automatically with all MP Rest or JAX-RS clients if `quarkus.oidc.rest.client.register-filter=true` property is set. \n+\n+\n+== Use injected GrantTokens\n+\n+If you prefer you can use your own custom filter and inject `GrantTokens`:\n+\n+```\n+@Provider\n+@Priority(Priorities.AUTHENTICATION)\n+@RequestScoped\n+public class OidcClientRequestCustomFilter implements ClientRequestFilter {\n+\n+    @Inject\n+    GrantTokens grantTokens;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e"}, "originalPosition": 133}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/5092b249c039f4376f9602ea6a5e9f18235f9c9e", "committedDate": "2020-12-15T17:51:31Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "37c86c2405c6ea7ae8021dea17c8827ac20d8377", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/37c86c2405c6ea7ae8021dea17c8827ac20d8377", "committedDate": "2020-12-16T21:41:37Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "37c86c2405c6ea7ae8021dea17c8827ac20d8377", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/37c86c2405c6ea7ae8021dea17c8827ac20d8377", "committedDate": "2020-12-16T21:41:37Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "5eff91f5a8f7f4b4109e25a6ba60f2509459db65", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/5eff91f5a8f7f4b4109e25a6ba60f2509459db65", "committedDate": "2020-12-16T21:46:52Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5eff91f5a8f7f4b4109e25a6ba60f2509459db65", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/5eff91f5a8f7f4b4109e25a6ba60f2509459db65", "committedDate": "2020-12-16T21:46:52Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "b910a9e70b2690f6ca594f7efc4453e0ac282f92", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/b910a9e70b2690f6ca594f7efc4453e0ac282f92", "committedDate": "2020-12-17T11:39:33Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b910a9e70b2690f6ca594f7efc4453e0ac282f92", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/b910a9e70b2690f6ca594f7efc4453e0ac282f92", "committedDate": "2020-12-17T11:39:33Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "f3f12eb0a773169a92ce1c9d00e46df49785efe2", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/f3f12eb0a773169a92ce1c9d00e46df49785efe2", "committedDate": "2020-12-17T18:00:08Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f3f12eb0a773169a92ce1c9d00e46df49785efe2", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/f3f12eb0a773169a92ce1c9d00e46df49785efe2", "committedDate": "2020-12-17T18:00:08Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "b474c40b2c37ffdb9b79471e235be7f53532f510", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/b474c40b2c37ffdb9b79471e235be7f53532f510", "committedDate": "2020-12-18T17:07:05Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b474c40b2c37ffdb9b79471e235be7f53532f510", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/b474c40b2c37ffdb9b79471e235be7f53532f510", "committedDate": "2020-12-18T17:07:05Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "1250071f3f142be3eac4f7ab81f3488a4f4c788a", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/1250071f3f142be3eac4f7ab81f3488a4f4c788a", "committedDate": "2020-12-20T17:33:14Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1250071f3f142be3eac4f7ab81f3488a4f4c788a", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/1250071f3f142be3eac4f7ab81f3488a4f4c788a", "committedDate": "2020-12-20T17:33:14Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "d4da4b8dfc367f396fb9fb508a9bcc451509eba7", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/d4da4b8dfc367f396fb9fb508a9bcc451509eba7", "committedDate": "2020-12-21T18:21:47Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2NzA0Nzg3", "url": "https://github.com/quarkusio/quarkus/pull/13641#pullrequestreview-556704787", "createdAt": "2020-12-21T22:32:59Z", "commit": {"oid": "d4da4b8dfc367f396fb9fb508a9bcc451509eba7"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMjozMjo1OVrOIJn8uA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMVQyMjo0MTozNFrOIJoHvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2MjYxNg==", "bodyText": "This still needs to be addressed.", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r546962616", "createdAt": "2020-12-21T22:32:59Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/OidcClientImpl.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Key;\n+import java.util.Base64;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.microprofile.jwt.Claims;\n+import org.jboss.logging.Logger;\n+\n+import io.quarkus.oidc.client.GrantTokens;\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.OidcClientException;\n+import io.quarkus.oidc.client.runtime.OidcClientConfig.Grant;\n+import io.quarkus.oidc.common.runtime.OidcCommonUtils;\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.mutiny.subscription.UniEmitter;\n+import io.vertx.core.http.HttpHeaders;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.mutiny.core.MultiMap;\n+import io.vertx.mutiny.core.buffer.Buffer;\n+import io.vertx.mutiny.ext.web.client.HttpRequest;\n+import io.vertx.mutiny.ext.web.client.HttpResponse;\n+import io.vertx.mutiny.ext.web.client.WebClient;\n+\n+public class OidcClientImpl implements OidcClient {\n+\n+    private static final Logger LOG = Logger.getLogger(OidcClientImpl.class);\n+\n+    private static final String ACCESS_TOKEN = \"access_token\";\n+    private static final String REFRESH_TOKEN = \"refresh_token\";\n+    private static final String EXPIRES_AT = \"expires_at\";\n+\n+    private static final String CLIENT_ASSERTION = \"client_assertion\";\n+    private static final String CLIENT_ASSERTION_TYPE = \"client_assertion_type\";\n+    private static final String JWT_BEARER_CLIENT_ASSERTION_TYPE = \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\";\n+\n+    private static final String AUTHORIZATION_HEADER = String.valueOf(HttpHeaders.AUTHORIZATION);\n+\n+    private WebClient client;\n+    private String tokenRequestUri;\n+    private MultiMap tokenGrantParams;\n+    private MultiMap commonRefreshGrantParams;\n+    private String grantType;\n+    private String clientSecretBasicAuthScheme;\n+    private Key clientJwtKey;\n+    private OidcClientConfig oidcConfig;\n+\n+    public OidcClientImpl() {\n+    }\n+\n+    public OidcClientImpl(WebClient client, String tokenRequestUri,\n+            MultiMap tokenGrantParams, MultiMap commonRefreshGrantParams, OidcClientConfig oidcClientConfig) {\n+        this.client = client;\n+        this.tokenRequestUri = tokenRequestUri;\n+        this.tokenGrantParams = tokenGrantParams;\n+        this.commonRefreshGrantParams = commonRefreshGrantParams;\n+        this.grantType = oidcClientConfig.grant.type == Grant.Type.CLIENT ? \"client_credentials\" : \"password\";\n+        this.oidcConfig = oidcClientConfig;\n+        initClientSecretBasicAuth();\n+    }\n+\n+    private void initClientSecretBasicAuth() {\n+        if (OidcCommonUtils.isClientSecretBasicAuthRequired(oidcConfig.credentials)) {\n+            clientSecretBasicAuthScheme = \"Basic \"\n+                    + Base64.getEncoder().encodeToString(\n+                            (oidcConfig.getClientId().get() + \":\" + OidcCommonUtils.clientSecret(oidcConfig.credentials))\n+                                    .getBytes(StandardCharsets.UTF_8));\n+        } else if (OidcCommonUtils.isClientJwtAuthRequired(oidcConfig.credentials)) {\n+            // if it is a refresh then a map has already been copied\n+            clientJwtKey = OidcCommonUtils.clientJwtKey(oidcConfig.credentials);\n+        }\n+    }\n+\n+    @Override\n+    public Uni<GrantTokens> getTokens() {\n+        return getJsonResponse(tokenGrantParams, false);\n+    }\n+\n+    @Override\n+    public Uni<GrantTokens> refreshTokens(String refreshToken) {\n+        if (refreshToken == null) {\n+            throw new OidcClientException(\"Refresh token is null\");\n+        }\n+        MultiMap refreshGrantParams = copyMultiMap(commonRefreshGrantParams);\n+        refreshGrantParams.add(REFRESH_TOKEN, refreshToken);\n+        return getJsonResponse(refreshGrantParams, true);\n+    }\n+\n+    private Uni<GrantTokens> getJsonResponse(MultiMap body, boolean refresh) {\n+        HttpRequest<Buffer> request = client.post(tokenRequestUri);\n+        if (clientSecretBasicAuthScheme != null) {\n+            request.putHeader(AUTHORIZATION_HEADER, clientSecretBasicAuthScheme);\n+        } else if (clientJwtKey != null) {\n+            // if it is a refresh then a map has already been copied\n+            body = !refresh ? copyMultiMap(body) : body;\n+            body.add(CLIENT_ASSERTION_TYPE, JWT_BEARER_CLIENT_ASSERTION_TYPE);\n+            body.add(CLIENT_ASSERTION, OidcCommonUtils.signJwtWithKey(oidcConfig, clientJwtKey));\n+        }\n+        return request.sendForm(body).onItem()\n+                .transformToUni(resp -> emitGrantTokens(resp, refresh));\n+    }\n+\n+    private Uni<GrantTokens> emitGrantTokens(HttpResponse<Buffer> resp, boolean refresh) {\n+        return Uni.createFrom().emitter(new Consumer<UniEmitter<? super GrantTokens>>() {\n+            @Override\n+            public void accept(UniEmitter<? super GrantTokens> emitter) {\n+                if (resp.statusCode() == 200) {\n+                    LOG.debugf(\"Tokens have been %s\", refresh ? \"refreshed\" : \"acquired\");\n+                    JsonObject json = resp.bodyAsJsonObject();\n+                    final String accessToken = json.getString(ACCESS_TOKEN);\n+                    final String refreshToken = json.getString(REFRESH_TOKEN);\n+                    Long accessTokenExpiresAt = json.getLong(EXPIRES_AT);\n+                    if (accessTokenExpiresAt == null) {\n+                        accessTokenExpiresAt = getExpiresJwtClaim(accessToken);\n+                    }\n+                    emitter.complete(new GrantTokens(accessToken, accessTokenExpiresAt, refreshToken));\n+                } else {\n+                    LOG.errorf(\"%s token grant request has failed: %s\", (refresh ? \"refresh\" : grantType), resp.bodyAsString());\n+                    emitter.fail(new OidcClientException());\n+                }\n+            }\n+        });\n+    }\n+\n+    private static Long getExpiresJwtClaim(String accessToken) {\n+        String[] parts = accessToken.split(\"\\\\.\");\n+        if (parts.length == 3) {\n+            try {\n+                JsonObject claims = new JsonObject(new String(Base64.getUrlDecoder().decode(parts[1]), StandardCharsets.UTF_8));\n+                return claims.getLong(Claims.exp.name());\n+            } catch (IllegalArgumentException ex) {\n+                return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc3MzkyOA=="}, "originalCommit": {"oid": "5092b249c039f4376f9602ea6a5e9f18235f9c9e"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk2NTQzNw==", "bodyText": "We can't really do this via locks when you are dealing with reactive code. getTokens() can be called by the same thread for reactive code, but for different requests. The logic below also has a few issues.", "url": "https://github.com/quarkusio/quarkus/pull/13641#discussion_r546965437", "createdAt": "2020-12-21T22:41:34Z", "author": {"login": "stuartwdouglas"}, "path": "extensions/oidc-client/runtime/src/main/java/io/quarkus/oidc/client/runtime/TokensHelper.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package io.quarkus.oidc.client.runtime;\n+\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import io.quarkus.oidc.client.OidcClient;\n+import io.quarkus.oidc.client.Tokens;\n+import io.smallrye.mutiny.Uni;\n+\n+public class TokensHelper {\n+\n+    private volatile Tokens tokens;\n+    private ReentrantLock tokenAcquisitionLock = new ReentrantLock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4da4b8dfc367f396fb9fb508a9bcc451509eba7"}, "originalPosition": 12}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f639b8fbe8e54a4f08e3b88f8683dd65c39ae0e0", "author": {"user": {"login": "stuartwdouglas", "name": "Stuart Douglas"}}, "url": "https://github.com/quarkusio/quarkus/commit/f639b8fbe8e54a4f08e3b88f8683dd65c39ae0e0", "committedDate": "2020-12-21T23:18:07Z", "message": "Update TokensHelper state management\n\nAlso make the client use lazy Uni's so\nthe request will only be sent if the Uni\nis used."}, "afterCommit": {"oid": "267932b6873b65d1ff8a4fd6e39455035912c8b8", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/267932b6873b65d1ff8a4fd6e39455035912c8b8", "committedDate": "2020-12-22T11:44:32Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "267932b6873b65d1ff8a4fd6e39455035912c8b8", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/267932b6873b65d1ff8a4fd6e39455035912c8b8", "committedDate": "2020-12-22T11:44:32Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "e60427e1941a788757c7e92851b0b401d0c4beea", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/e60427e1941a788757c7e92851b0b401d0c4beea", "committedDate": "2020-12-22T17:27:00Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e60427e1941a788757c7e92851b0b401d0c4beea", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/e60427e1941a788757c7e92851b0b401d0c4beea", "committedDate": "2020-12-22T17:27:00Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "3050a142d3d65fa8819744ead91007c7bd6e61a6", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/3050a142d3d65fa8819744ead91007c7bd6e61a6", "committedDate": "2020-12-22T17:42:57Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3050a142d3d65fa8819744ead91007c7bd6e61a6", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/3050a142d3d65fa8819744ead91007c7bd6e61a6", "committedDate": "2020-12-22T17:42:57Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "43c33ba285b5dbb6e7dd21b926fe38cb9b01dd87", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/43c33ba285b5dbb6e7dd21b926fe38cb9b01dd87", "committedDate": "2020-12-24T12:15:56Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "43c33ba285b5dbb6e7dd21b926fe38cb9b01dd87", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/43c33ba285b5dbb6e7dd21b926fe38cb9b01dd87", "committedDate": "2020-12-24T12:15:56Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "981960220cc86d2a7763b601d9a9ceaed04118b5", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/981960220cc86d2a7763b601d9a9ceaed04118b5", "committedDate": "2020-12-24T14:52:45Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwOTYyNDAw", "url": "https://github.com/quarkusio/quarkus/pull/13641#pullrequestreview-560962400", "createdAt": "2021-01-04T11:33:06Z", "commit": {"oid": "981960220cc86d2a7763b601d9a9ceaed04118b5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "981960220cc86d2a7763b601d9a9ceaed04118b5", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/981960220cc86d2a7763b601d9a9ceaed04118b5", "committedDate": "2020-12-24T14:52:45Z", "message": "Create oidc-client and oidc-rest-client extensions"}, "afterCommit": {"oid": "879348a03ebdd576caab0938ffa3b9db8c1b7331", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/879348a03ebdd576caab0938ffa3b9db8c1b7331", "committedDate": "2021-01-05T12:11:38Z", "message": "Update the runtime pom descriptions and extension resources"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3c6b25759011c6623fa93fea296821d963de36d", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/d3c6b25759011c6623fa93fea296821d963de36d", "committedDate": "2021-01-05T13:15:06Z", "message": "Create oidc-client and oidc-rest-client extensions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "879348a03ebdd576caab0938ffa3b9db8c1b7331", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/879348a03ebdd576caab0938ffa3b9db8c1b7331", "committedDate": "2021-01-05T12:11:38Z", "message": "Update the runtime pom descriptions and extension resources"}, "afterCommit": {"oid": "d3c6b25759011c6623fa93fea296821d963de36d", "author": {"user": {"login": "sberyozkin", "name": null}}, "url": "https://github.com/quarkusio/quarkus/commit/d3c6b25759011c6623fa93fea296821d963de36d", "committedDate": "2021-01-05T13:15:06Z", "message": "Create oidc-client and oidc-rest-client extensions"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1203, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}