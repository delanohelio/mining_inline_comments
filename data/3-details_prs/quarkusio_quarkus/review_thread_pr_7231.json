{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2MTc5MjY2", "number": 7231, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxNTo0ODo0MFrODhHNXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxNTo1MjozOVrODhHTmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MDQ3NzA4OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/vertx.adoc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxNTo0ODo0MVrOFrsZwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxMDoxMTozN1rOFsNenQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM2MDU3Ng==", "bodyText": "It should quite easy to deploy those verticles automatically.\nSomething like:\nvoid deploy(@Observes StartupEvent event, Vertx vertx, Instance<AbstractVerticle> verticles) {\n   for (AbstractVerticle verticle : verticles) {\n     vertx.deployVerticle(verticle).await().indefinitely();\n   }\n}", "url": "https://github.com/quarkusio/quarkus/pull/7231#discussion_r381360576", "createdAt": "2020-02-19T15:48:41Z", "author": {"login": "mkouba"}, "path": "docs/src/main/asciidoc/vertx.adoc", "diffHunk": "@@ -498,6 +498,86 @@ Then, create the native executable with:\n ./mvnw package -Pnative\n ----\n \n+== Deploying verticles\n+\n+https://vertx.io/docs/vertx-core/java/#_verticles[Verticles] is \"a simple, scalable, actor-like deployment and concurrency model\" provided by _Vert.x_.\n+This model does not claim to be a strict actor-model implementation, but it does share similarities especially with respect to concurrency, scaling and deployment.\n+To use this model, you write and _deploy_ verticles, communicating with each other by sending messages on the event bus.\n+\n+You can deploy _verticles_ in Quarkus.\n+It supports:\n+\n+* _bare_ verticle - Java classes extending `io.vertx.core.AbstractVerticle`\n+* _Mutiny_ verticle - Java classes extending `io.smallrye.mutiny.vertx.core.AbstractVerticle`\n+\n+To deploy verticles, use the regular Vert.x API:\n+\n+[source, java]\n+====\n+@Inject Vertx vertx;\n+\n+// ...\n+vertx.deployVerticle(MyVerticle.class.getName(), ar -> { });\n+vertx.deployVerticle(new MyVerticle(), ar -> { });\n+====\n+\n+You can also pass deployment options to configure the verticle as well as set the number of instances.\n+\n+Verticles are not _beans_ by default.\n+However, you can implement them as _ApplicationScoped_ beans and get injection support:\n+\n+[source, java]\n+====\n+package io.quarkus.vertx.verticles;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.mutiny.vertx.core.AbstractVerticle;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+@ApplicationScoped\n+public class MyBeanVerticle extends AbstractVerticle {\n+\n+    @ConfigProperty(name = \"address\") String address;\n+\n+    @Override\n+    public Uni<Void> asyncStart() {\n+        return vertx.eventBus().consumer(address)\n+                .handler(m -> m.replyAndForget(\"hello\"))\n+                .completionHandler();\n+    }\n+}\n+====\n+\n+Don't inject the `vertx` instance in an injected verticle.\n+Access the `vertx` instance using the `vertx` file in your `start` / `asyncStart` method.\n+\n+Then, deploy the verticle instance with:\n+\n+[source, java]\n+====\n+package io.quarkus.vertx.verticles;\n+\n+import io.quarkus.runtime.StartupEvent;\n+import io.vertx.mutiny.core.Vertx;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+import javax.inject.Inject;\n+\n+@ApplicationScoped\n+public class VerticleDeployer {\n+\n+    @Inject Vertx vertx;\n+    @Inject MyBeanVerticle verticle;\n+\n+    public void init(@Observes StartupEvent e) {\n+         vertx.deployVerticle(verticle).await().indefinitely();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "085d0955bf716c5114f4b6a78d5797c1e8e691b0"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQyODQyMg==", "bodyText": "ah ah! I didn't know this! Let me update the documentation.", "url": "https://github.com/quarkusio/quarkus/pull/7231#discussion_r381428422", "createdAt": "2020-02-19T17:28:18Z", "author": {"login": "cescoffier"}, "path": "docs/src/main/asciidoc/vertx.adoc", "diffHunk": "@@ -498,6 +498,86 @@ Then, create the native executable with:\n ./mvnw package -Pnative\n ----\n \n+== Deploying verticles\n+\n+https://vertx.io/docs/vertx-core/java/#_verticles[Verticles] is \"a simple, scalable, actor-like deployment and concurrency model\" provided by _Vert.x_.\n+This model does not claim to be a strict actor-model implementation, but it does share similarities especially with respect to concurrency, scaling and deployment.\n+To use this model, you write and _deploy_ verticles, communicating with each other by sending messages on the event bus.\n+\n+You can deploy _verticles_ in Quarkus.\n+It supports:\n+\n+* _bare_ verticle - Java classes extending `io.vertx.core.AbstractVerticle`\n+* _Mutiny_ verticle - Java classes extending `io.smallrye.mutiny.vertx.core.AbstractVerticle`\n+\n+To deploy verticles, use the regular Vert.x API:\n+\n+[source, java]\n+====\n+@Inject Vertx vertx;\n+\n+// ...\n+vertx.deployVerticle(MyVerticle.class.getName(), ar -> { });\n+vertx.deployVerticle(new MyVerticle(), ar -> { });\n+====\n+\n+You can also pass deployment options to configure the verticle as well as set the number of instances.\n+\n+Verticles are not _beans_ by default.\n+However, you can implement them as _ApplicationScoped_ beans and get injection support:\n+\n+[source, java]\n+====\n+package io.quarkus.vertx.verticles;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.mutiny.vertx.core.AbstractVerticle;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+@ApplicationScoped\n+public class MyBeanVerticle extends AbstractVerticle {\n+\n+    @ConfigProperty(name = \"address\") String address;\n+\n+    @Override\n+    public Uni<Void> asyncStart() {\n+        return vertx.eventBus().consumer(address)\n+                .handler(m -> m.replyAndForget(\"hello\"))\n+                .completionHandler();\n+    }\n+}\n+====\n+\n+Don't inject the `vertx` instance in an injected verticle.\n+Access the `vertx` instance using the `vertx` file in your `start` / `asyncStart` method.\n+\n+Then, deploy the verticle instance with:\n+\n+[source, java]\n+====\n+package io.quarkus.vertx.verticles;\n+\n+import io.quarkus.runtime.StartupEvent;\n+import io.vertx.mutiny.core.Vertx;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+import javax.inject.Inject;\n+\n+@ApplicationScoped\n+public class VerticleDeployer {\n+\n+    @Inject Vertx vertx;\n+    @Inject MyBeanVerticle verticle;\n+\n+    public void init(@Observes StartupEvent e) {\n+         vertx.deployVerticle(verticle).await().indefinitely();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM2MDU3Ng=="}, "originalCommit": {"oid": "085d0955bf716c5114f4b6a78d5797c1e8e691b0"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTkwMjQ5Mw==", "bodyText": "Updated the doc and the test!\nSoon I will be a CDI master... soon", "url": "https://github.com/quarkusio/quarkus/pull/7231#discussion_r381902493", "createdAt": "2020-02-20T10:11:37Z", "author": {"login": "cescoffier"}, "path": "docs/src/main/asciidoc/vertx.adoc", "diffHunk": "@@ -498,6 +498,86 @@ Then, create the native executable with:\n ./mvnw package -Pnative\n ----\n \n+== Deploying verticles\n+\n+https://vertx.io/docs/vertx-core/java/#_verticles[Verticles] is \"a simple, scalable, actor-like deployment and concurrency model\" provided by _Vert.x_.\n+This model does not claim to be a strict actor-model implementation, but it does share similarities especially with respect to concurrency, scaling and deployment.\n+To use this model, you write and _deploy_ verticles, communicating with each other by sending messages on the event bus.\n+\n+You can deploy _verticles_ in Quarkus.\n+It supports:\n+\n+* _bare_ verticle - Java classes extending `io.vertx.core.AbstractVerticle`\n+* _Mutiny_ verticle - Java classes extending `io.smallrye.mutiny.vertx.core.AbstractVerticle`\n+\n+To deploy verticles, use the regular Vert.x API:\n+\n+[source, java]\n+====\n+@Inject Vertx vertx;\n+\n+// ...\n+vertx.deployVerticle(MyVerticle.class.getName(), ar -> { });\n+vertx.deployVerticle(new MyVerticle(), ar -> { });\n+====\n+\n+You can also pass deployment options to configure the verticle as well as set the number of instances.\n+\n+Verticles are not _beans_ by default.\n+However, you can implement them as _ApplicationScoped_ beans and get injection support:\n+\n+[source, java]\n+====\n+package io.quarkus.vertx.verticles;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.mutiny.vertx.core.AbstractVerticle;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+@ApplicationScoped\n+public class MyBeanVerticle extends AbstractVerticle {\n+\n+    @ConfigProperty(name = \"address\") String address;\n+\n+    @Override\n+    public Uni<Void> asyncStart() {\n+        return vertx.eventBus().consumer(address)\n+                .handler(m -> m.replyAndForget(\"hello\"))\n+                .completionHandler();\n+    }\n+}\n+====\n+\n+Don't inject the `vertx` instance in an injected verticle.\n+Access the `vertx` instance using the `vertx` file in your `start` / `asyncStart` method.\n+\n+Then, deploy the verticle instance with:\n+\n+[source, java]\n+====\n+package io.quarkus.vertx.verticles;\n+\n+import io.quarkus.runtime.StartupEvent;\n+import io.vertx.mutiny.core.Vertx;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+import javax.inject.Inject;\n+\n+@ApplicationScoped\n+public class VerticleDeployer {\n+\n+    @Inject Vertx vertx;\n+    @Inject MyBeanVerticle verticle;\n+\n+    public void init(@Observes StartupEvent e) {\n+         vertx.deployVerticle(verticle).await().indefinitely();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM2MDU3Ng=="}, "originalCommit": {"oid": "085d0955bf716c5114f4b6a78d5797c1e8e691b0"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MDQ5MzA1OnYy", "diffSide": "RIGHT", "path": "docs/src/main/asciidoc/vertx.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxNTo1MjozOVrOFrskPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxNzoyODozNFrOFrwjYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM2MzI2Mg==", "bodyText": "I'd reword this sentence. Maybe something like \"You don't have to inject the Vertx instance but instead leverage the instance stored in the protected field of AbstractVerticle\"...", "url": "https://github.com/quarkusio/quarkus/pull/7231#discussion_r381363262", "createdAt": "2020-02-19T15:52:39Z", "author": {"login": "mkouba"}, "path": "docs/src/main/asciidoc/vertx.adoc", "diffHunk": "@@ -498,6 +498,86 @@ Then, create the native executable with:\n ./mvnw package -Pnative\n ----\n \n+== Deploying verticles\n+\n+https://vertx.io/docs/vertx-core/java/#_verticles[Verticles] is \"a simple, scalable, actor-like deployment and concurrency model\" provided by _Vert.x_.\n+This model does not claim to be a strict actor-model implementation, but it does share similarities especially with respect to concurrency, scaling and deployment.\n+To use this model, you write and _deploy_ verticles, communicating with each other by sending messages on the event bus.\n+\n+You can deploy _verticles_ in Quarkus.\n+It supports:\n+\n+* _bare_ verticle - Java classes extending `io.vertx.core.AbstractVerticle`\n+* _Mutiny_ verticle - Java classes extending `io.smallrye.mutiny.vertx.core.AbstractVerticle`\n+\n+To deploy verticles, use the regular Vert.x API:\n+\n+[source, java]\n+====\n+@Inject Vertx vertx;\n+\n+// ...\n+vertx.deployVerticle(MyVerticle.class.getName(), ar -> { });\n+vertx.deployVerticle(new MyVerticle(), ar -> { });\n+====\n+\n+You can also pass deployment options to configure the verticle as well as set the number of instances.\n+\n+Verticles are not _beans_ by default.\n+However, you can implement them as _ApplicationScoped_ beans and get injection support:\n+\n+[source, java]\n+====\n+package io.quarkus.vertx.verticles;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.mutiny.vertx.core.AbstractVerticle;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+@ApplicationScoped\n+public class MyBeanVerticle extends AbstractVerticle {\n+\n+    @ConfigProperty(name = \"address\") String address;\n+\n+    @Override\n+    public Uni<Void> asyncStart() {\n+        return vertx.eventBus().consumer(address)\n+                .handler(m -> m.replyAndForget(\"hello\"))\n+                .completionHandler();\n+    }\n+}\n+====\n+\n+Don't inject the `vertx` instance in an injected verticle.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "085d0955bf716c5114f4b6a78d5797c1e8e691b0"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQyODU3Ng==", "bodyText": "Yes, that's better.", "url": "https://github.com/quarkusio/quarkus/pull/7231#discussion_r381428576", "createdAt": "2020-02-19T17:28:34Z", "author": {"login": "cescoffier"}, "path": "docs/src/main/asciidoc/vertx.adoc", "diffHunk": "@@ -498,6 +498,86 @@ Then, create the native executable with:\n ./mvnw package -Pnative\n ----\n \n+== Deploying verticles\n+\n+https://vertx.io/docs/vertx-core/java/#_verticles[Verticles] is \"a simple, scalable, actor-like deployment and concurrency model\" provided by _Vert.x_.\n+This model does not claim to be a strict actor-model implementation, but it does share similarities especially with respect to concurrency, scaling and deployment.\n+To use this model, you write and _deploy_ verticles, communicating with each other by sending messages on the event bus.\n+\n+You can deploy _verticles_ in Quarkus.\n+It supports:\n+\n+* _bare_ verticle - Java classes extending `io.vertx.core.AbstractVerticle`\n+* _Mutiny_ verticle - Java classes extending `io.smallrye.mutiny.vertx.core.AbstractVerticle`\n+\n+To deploy verticles, use the regular Vert.x API:\n+\n+[source, java]\n+====\n+@Inject Vertx vertx;\n+\n+// ...\n+vertx.deployVerticle(MyVerticle.class.getName(), ar -> { });\n+vertx.deployVerticle(new MyVerticle(), ar -> { });\n+====\n+\n+You can also pass deployment options to configure the verticle as well as set the number of instances.\n+\n+Verticles are not _beans_ by default.\n+However, you can implement them as _ApplicationScoped_ beans and get injection support:\n+\n+[source, java]\n+====\n+package io.quarkus.vertx.verticles;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.mutiny.vertx.core.AbstractVerticle;\n+import org.eclipse.microprofile.config.inject.ConfigProperty;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+@ApplicationScoped\n+public class MyBeanVerticle extends AbstractVerticle {\n+\n+    @ConfigProperty(name = \"address\") String address;\n+\n+    @Override\n+    public Uni<Void> asyncStart() {\n+        return vertx.eventBus().consumer(address)\n+                .handler(m -> m.replyAndForget(\"hello\"))\n+                .completionHandler();\n+    }\n+}\n+====\n+\n+Don't inject the `vertx` instance in an injected verticle.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM2MzI2Mg=="}, "originalCommit": {"oid": "085d0955bf716c5114f4b6a78d5797c1e8e691b0"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1038, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}