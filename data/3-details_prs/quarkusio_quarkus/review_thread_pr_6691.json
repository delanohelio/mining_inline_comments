{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1MzU2NTUx", "number": 6691, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwNjo1OTozMVrODZuvJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwNjoxMDoxNVrODbHDPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MzA2NzI1OnYy", "diffSide": "RIGHT", "path": "integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwNjo1OTozMVrOFgSI3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwNjo1OTozMVrOFgSI3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM5NTkzMg==", "bodyText": "How about this get changed to Objects.requireNonNull?", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369395932", "createdAt": "2020-01-22T06:59:31Z", "author": {"login": "geoand"}, "path": "integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookResource.java", "diffHunk": "@@ -58,4 +60,54 @@ public Response findByPublicationYear(@PathParam(\"year\") Integer year) {\n         Optional<Book> book = bookRepository.findByPublicationYear(year);\n         return book.map(b -> Response.ok(book).build()).orElse(Response.noContent().build());\n     }\n+\n+    @GET\n+    @Path(\"/count/year\")\n+    @Produces(\"application/json\")\n+    public List<BookRepository.BookCountByYear> countAllByPublicationYear() {\n+        List<BookRepository.BookCountByYear> list = bookRepository.findAllByPublicationYear();\n+\n+        // #6205 - Make sure elements in list have been properly cast to the target object type.\n+        // If the type is wrong (Object array), this will throw a ClassNotFoundException\n+        BookRepository.BookCountByYear first = list.get(0);\n+        assert (first != null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MzA4MDM5OnYy", "diffSide": "RIGHT", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/SpringDataJPAProcessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwNzowODozM1rOFgSRFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwNzowODozM1rOFgSRFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM5ODAzOQ==", "bodyText": "How about we move generatedClasses right after generatedBeans instead of next to additionalBeans. It will make things a tad more consistent I believe.", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369398039", "createdAt": "2020-01-22T07:08:33Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/SpringDataJPAProcessor.java", "diffHunk": "@@ -58,7 +61,8 @@ void build(CombinedIndexBuildItem index,\n                 indexIndex);\n \n         removeNoRepositoryBeanClasses(interfacesExtendingCrudRepository);\n-        implementCrudRepositories(generatedBeans, additionalBeans, interfacesExtendingCrudRepository, indexIndex);\n+        implementCrudRepositories(generatedBeans, additionalBeans, generatedClasses,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MzA4NTI3OnYy", "diffSide": "RIGHT", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwNzoxMTo1MlrOFgSUDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwNzoxMTo1MlrOFgSUDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM5ODc5OQ==", "bodyText": "The IDE is telling warning me about Redundant group nesting for (([\\w\\.]+))", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369398799", "createdAt": "2020-01-22T07:11:52Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java", "diffHunk": "@@ -2,21 +2,28 @@\n \n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n \n import org.jboss.jandex.ClassInfo;\n import org.jboss.jandex.DotName;\n import org.jboss.jandex.IndexView;\n import org.jboss.jandex.MethodInfo;\n import org.jboss.jandex.Type;\n \n+import io.quarkus.deployment.util.HashUtil;\n import io.quarkus.gizmo.MethodDescriptor;\n import io.quarkus.spring.data.deployment.DotNames;\n \n public final class GenerationUtil {\n \n+    private static final Pattern SELECT_CLAUSE = Pattern.compile(\"select\\\\s+(.+)\\\\s+from\", Pattern.CASE_INSENSITIVE);\n+    private static final Pattern FIELD_ALIAS = Pattern.compile(\"\\\\s+[as|AS]+\\\\s+(([\\\\w\\\\.]+))\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MzA5MDI2OnYy", "diffSide": "RIGHT", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwNzoxNDo1NlrOFgSXMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwNzoxNDo1NlrOFgSXMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM5OTYwMA==", "bodyText": "I think this method is unused", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369399600", "createdAt": "2020-01-22T07:14:56Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java", "diffHunk": "@@ -53,4 +60,51 @@ static MethodDescriptor toMethodDescriptor(String generatedClassName, MethodInfo\n         return MethodDescriptor.ofMethod(generatedClassName, methodInfo.name(), methodInfo.returnType().name().toString(),\n                 parameterTypesStr.toArray(new String[0]));\n     }\n+\n+    static String getSimpleName(DotName ifaceName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MzA5MDk3OnYy", "diffSide": "RIGHT", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwNzoxNToyOFrOFgSXpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNTowOTo1OVrOFgfm7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM5OTcxOA==", "bodyText": "Perhaps this and the other newly added methods should be moved to a different utility class that is more aptly named?", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369399718", "createdAt": "2020-01-22T07:15:28Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java", "diffHunk": "@@ -53,4 +60,51 @@ static MethodDescriptor toMethodDescriptor(String generatedClassName, MethodInfo\n         return MethodDescriptor.ofMethod(generatedClassName, methodInfo.name(), methodInfo.returnType().name().toString(),\n                 parameterTypesStr.toArray(new String[0]));\n     }\n+\n+    static String getSimpleName(DotName ifaceName) {\n+        return (ifaceName.isInner() ? ifaceName.local() : ifaceName.withoutPackagePrefix());\n+    }\n+\n+    static DotName createImplDotName(DotName ifaceName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3Njg0NQ==", "bodyText": "This only seems to be used in one class, so could also stay as a private method there.", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369476845", "createdAt": "2020-01-22T10:22:50Z", "author": {"login": "gytis"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java", "diffHunk": "@@ -53,4 +60,51 @@ static MethodDescriptor toMethodDescriptor(String generatedClassName, MethodInfo\n         return MethodDescriptor.ofMethod(generatedClassName, methodInfo.name(), methodInfo.returnType().name().toString(),\n                 parameterTypesStr.toArray(new String[0]));\n     }\n+\n+    static String getSimpleName(DotName ifaceName) {\n+        return (ifaceName.isInner() ? ifaceName.local() : ifaceName.withoutPackagePrefix());\n+    }\n+\n+    static DotName createImplDotName(DotName ifaceName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM5OTcxOA=="}, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxNjYyMw==", "bodyText": "Moved to private methods re: other feedback from @gytis", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369616623", "createdAt": "2020-01-22T15:09:59Z", "author": {"login": "ebullient"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java", "diffHunk": "@@ -53,4 +60,51 @@ static MethodDescriptor toMethodDescriptor(String generatedClassName, MethodInfo\n         return MethodDescriptor.ofMethod(generatedClassName, methodInfo.name(), methodInfo.returnType().name().toString(),\n                 parameterTypesStr.toArray(new String[0]));\n     }\n+\n+    static String getSimpleName(DotName ifaceName) {\n+        return (ifaceName.isInner() ? ifaceName.local() : ifaceName.withoutPackagePrefix());\n+    }\n+\n+    static DotName createImplDotName(DotName ifaceName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM5OTcxOA=="}, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MzA5OTY3OnYy", "diffSide": "RIGHT", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwNzoyMDozMlrOFgSc5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzo0NjoyMlrOFiDHvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTA2MQ==", "bodyText": "What happens if it's not an interface?\nIn other places we do have code that can deal with this situation (by instantiating a JavaBean for example), but does Spring Data support that?", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369401061", "createdAt": "2020-01-22T07:20:32Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -218,6 +229,32 @@ public void add(ClassCreator classCreator, FieldDescriptor entityClassFieldDescr\n                         }\n                     }\n \n+                    // Find the type of data used in the result\n+                    // e.g. method.returnType() is List, but it can contain custom/non-entity elements\n+                    Type resultType = verifyQueryResultType(method.returnType());\n+                    DotName customResultTypeName = resultType.name();\n+\n+                    if (customResultTypeName.equals(entityClassInfo.name())\n+                            || customResultTypeName.equals(DotNames.OBJECT)) {\n+                        // Result is using standard entity or Object result type \n+                        customResultTypeName = null;\n+                    } else {\n+                        // The result is using a custom type.\n+                        List<String> fieldNames = GenerationUtil.getFieldNames(queryString);\n+                        if (fieldNames.isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Custom Query annotations must specify field aliases when used with a custom type. \"\n+                                            + \"Offending query string is \\\"\" + queryString + \"\\\" on method \" + methodName\n+                                            + \" of Repository \" + repositoryName);\n+                        }\n+\n+                        // If the custom type is an interface, we may need to generate the implementation\n+                        ClassInfo resultClassInfo = index.getClassByName(customResultTypeName);\n+                        if (Modifier.isInterface(resultClassInfo.flags())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3Mjc0Nw==", "bodyText": "I don't know that Spring supports it, I can test. I'll also see if the newInstance works, though I imagine we'll also miss the field ordering.", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369572747", "createdAt": "2020-01-22T13:57:27Z", "author": {"login": "ebullient"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -218,6 +229,32 @@ public void add(ClassCreator classCreator, FieldDescriptor entityClassFieldDescr\n                         }\n                     }\n \n+                    // Find the type of data used in the result\n+                    // e.g. method.returnType() is List, but it can contain custom/non-entity elements\n+                    Type resultType = verifyQueryResultType(method.returnType());\n+                    DotName customResultTypeName = resultType.name();\n+\n+                    if (customResultTypeName.equals(entityClassInfo.name())\n+                            || customResultTypeName.equals(DotNames.OBJECT)) {\n+                        // Result is using standard entity or Object result type \n+                        customResultTypeName = null;\n+                    } else {\n+                        // The result is using a custom type.\n+                        List<String> fieldNames = GenerationUtil.getFieldNames(queryString);\n+                        if (fieldNames.isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Custom Query annotations must specify field aliases when used with a custom type. \"\n+                                            + \"Offending query string is \\\"\" + queryString + \"\\\" on method \" + methodName\n+                                            + \" of Repository \" + repositoryName);\n+                        }\n+\n+                        // If the custom type is an interface, we may need to generate the implementation\n+                        ClassInfo resultClassInfo = index.getClassByName(customResultTypeName);\n+                        if (Modifier.isInterface(resultClassInfo.flags())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTA2MQ=="}, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0MjM5MA==", "bodyText": "I throw an exception here. I could check to ensure the fields exist, but the code that attempts to convert from one type to the other depends on a method in the generated impl.", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r371242390", "createdAt": "2020-01-27T13:36:21Z", "author": {"login": "ebullient"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -218,6 +229,32 @@ public void add(ClassCreator classCreator, FieldDescriptor entityClassFieldDescr\n                         }\n                     }\n \n+                    // Find the type of data used in the result\n+                    // e.g. method.returnType() is List, but it can contain custom/non-entity elements\n+                    Type resultType = verifyQueryResultType(method.returnType());\n+                    DotName customResultTypeName = resultType.name();\n+\n+                    if (customResultTypeName.equals(entityClassInfo.name())\n+                            || customResultTypeName.equals(DotNames.OBJECT)) {\n+                        // Result is using standard entity or Object result type \n+                        customResultTypeName = null;\n+                    } else {\n+                        // The result is using a custom type.\n+                        List<String> fieldNames = GenerationUtil.getFieldNames(queryString);\n+                        if (fieldNames.isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Custom Query annotations must specify field aliases when used with a custom type. \"\n+                                            + \"Offending query string is \\\"\" + queryString + \"\\\" on method \" + methodName\n+                                            + \" of Repository \" + repositoryName);\n+                        }\n+\n+                        // If the custom type is an interface, we may need to generate the implementation\n+                        ClassInfo resultClassInfo = index.getClassByName(customResultTypeName);\n+                        if (Modifier.isInterface(resultClassInfo.flags())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTA2MQ=="}, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0NzAzOQ==", "bodyText": "Looks good", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r371247039", "createdAt": "2020-01-27T13:46:22Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -218,6 +229,32 @@ public void add(ClassCreator classCreator, FieldDescriptor entityClassFieldDescr\n                         }\n                     }\n \n+                    // Find the type of data used in the result\n+                    // e.g. method.returnType() is List, but it can contain custom/non-entity elements\n+                    Type resultType = verifyQueryResultType(method.returnType());\n+                    DotName customResultTypeName = resultType.name();\n+\n+                    if (customResultTypeName.equals(entityClassInfo.name())\n+                            || customResultTypeName.equals(DotNames.OBJECT)) {\n+                        // Result is using standard entity or Object result type \n+                        customResultTypeName = null;\n+                    } else {\n+                        // The result is using a custom type.\n+                        List<String> fieldNames = GenerationUtil.getFieldNames(queryString);\n+                        if (fieldNames.isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Custom Query annotations must specify field aliases when used with a custom type. \"\n+                                            + \"Offending query string is \\\"\" + queryString + \"\\\" on method \" + methodName\n+                                            + \" of Repository \" + repositoryName);\n+                        }\n+\n+                        // If the custom type is an interface, we may need to generate the implementation\n+                        ClassInfo resultClassInfo = index.getClassByName(customResultTypeName);\n+                        if (Modifier.isInterface(resultClassInfo.flags())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTA2MQ=="}, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MzEwMTgwOnYy", "diffSide": "RIGHT", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwNzoyMTozNFrOFgSeIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMzo1Mjo0NFrOFgcxsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTM3Ng==", "bodyText": "It seems like this is unused", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369401376", "createdAt": "2020-01-22T07:21:34Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -31,13 +36,18 @@\n \n public class CustomQueryMethodsAdder extends AbstractMethodsAdder {\n \n+    private static final Logger log = Logger.getLogger(CustomQueryMethodsAdder.class.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3MDIyNQ==", "bodyText": "Woops! Yes. I had plans to use it..", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369570225", "createdAt": "2020-01-22T13:52:44Z", "author": {"login": "ebullient"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -31,13 +36,18 @@\n \n public class CustomQueryMethodsAdder extends AbstractMethodsAdder {\n \n+    private static final Logger log = Logger.getLogger(CustomQueryMethodsAdder.class.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTM3Ng=="}, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MzEwNDMyOnYy", "diffSide": "RIGHT", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwNzoyMzowNVrOFgSfqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMzo1MzoxNlrOFgcy6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTc3MA==", "bodyText": "for each loop perhaps would be nicer?", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369401770", "createdAt": "2020-01-22T07:23:05Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -298,4 +336,119 @@ private ResultHandle generateSort(Integer sortParameterIndex, MethodCreator meth\n         }\n         return sort;\n     }\n+\n+    // Make sure the return type is referencing a class we have indexed \n+    // somewhere along the way (e.g. non-entity return types in @Query methods)\n+    // Unless it is some kind of collection containing multiple types, \n+    // return the type used in the query result.\n+    private Type verifyQueryResultType(Type t) {\n+        if (t.kind() == Kind.ARRAY) {\n+            return verifyQueryResultType(t.asArrayType().component());\n+        } else if (t.kind() == Kind.PARAMETERIZED_TYPE) {\n+            List<Type> list = t.asParameterizedType().arguments();\n+            if (list.size() == 1) {\n+                return verifyQueryResultType(list.get(0));\n+            } else {\n+                for (Type x : list) {\n+                    verifyQueryResultType(x);\n+                }\n+                return t;\n+            }\n+        } else if (!DotNames.OBJECT.equals(t.name())) {\n+            ClassInfo typeClassInfo = index.getClassByName(t.name());\n+            if (typeClassInfo == null) {\n+                throw new IllegalStateException(t.name() + \" was not part of the Quarkus index\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    // Verify the implementation class exists (generate it if necessary)\n+    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n+        DotName interfaceName = interfaceInfo.name();\n+        DotName customImplName = customReturnTypes.get(interfaceName);\n+\n+        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n+        if (customImplName == null) {\n+            customImplName = GenerationUtil.createImplDotName(interfaceName);\n+            try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n+                    .interfaces(interfaceName.toString()).className(customImplName.toString())\n+                    .build()) {\n+\n+                List<MethodInfo> methods = interfaceInfo.methods();\n+\n+                // Work with methods in declared order\n+                for (int i = 0; i < methods.size(); i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3MDUzNg==", "bodyText": "I can go to a foreach loop now, yes. Remember that thing where I was dependent on order? That's from then. ;) I'll fix", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369570536", "createdAt": "2020-01-22T13:53:16Z", "author": {"login": "ebullient"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -298,4 +336,119 @@ private ResultHandle generateSort(Integer sortParameterIndex, MethodCreator meth\n         }\n         return sort;\n     }\n+\n+    // Make sure the return type is referencing a class we have indexed \n+    // somewhere along the way (e.g. non-entity return types in @Query methods)\n+    // Unless it is some kind of collection containing multiple types, \n+    // return the type used in the query result.\n+    private Type verifyQueryResultType(Type t) {\n+        if (t.kind() == Kind.ARRAY) {\n+            return verifyQueryResultType(t.asArrayType().component());\n+        } else if (t.kind() == Kind.PARAMETERIZED_TYPE) {\n+            List<Type> list = t.asParameterizedType().arguments();\n+            if (list.size() == 1) {\n+                return verifyQueryResultType(list.get(0));\n+            } else {\n+                for (Type x : list) {\n+                    verifyQueryResultType(x);\n+                }\n+                return t;\n+            }\n+        } else if (!DotNames.OBJECT.equals(t.name())) {\n+            ClassInfo typeClassInfo = index.getClassByName(t.name());\n+            if (typeClassInfo == null) {\n+                throw new IllegalStateException(t.name() + \" was not part of the Quarkus index\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    // Verify the implementation class exists (generate it if necessary)\n+    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n+        DotName interfaceName = interfaceInfo.name();\n+        DotName customImplName = customReturnTypes.get(interfaceName);\n+\n+        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n+        if (customImplName == null) {\n+            customImplName = GenerationUtil.createImplDotName(interfaceName);\n+            try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n+                    .interfaces(interfaceName.toString()).className(customImplName.toString())\n+                    .build()) {\n+\n+                List<MethodInfo> methods = interfaceInfo.methods();\n+\n+                // Work with methods in declared order\n+                for (int i = 0; i < methods.size(); i++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTc3MA=="}, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MzEwNjU5OnYy", "diffSide": "RIGHT", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwNzoyNDowN1rOFgSg2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxMzoxODo1N1rOFhdXzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMjA3NA==", "bodyText": "I think we also need to be checking for default methods and skip over those", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369402074", "createdAt": "2020-01-22T07:24:07Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -298,4 +336,119 @@ private ResultHandle generateSort(Integer sortParameterIndex, MethodCreator meth\n         }\n         return sort;\n     }\n+\n+    // Make sure the return type is referencing a class we have indexed \n+    // somewhere along the way (e.g. non-entity return types in @Query methods)\n+    // Unless it is some kind of collection containing multiple types, \n+    // return the type used in the query result.\n+    private Type verifyQueryResultType(Type t) {\n+        if (t.kind() == Kind.ARRAY) {\n+            return verifyQueryResultType(t.asArrayType().component());\n+        } else if (t.kind() == Kind.PARAMETERIZED_TYPE) {\n+            List<Type> list = t.asParameterizedType().arguments();\n+            if (list.size() == 1) {\n+                return verifyQueryResultType(list.get(0));\n+            } else {\n+                for (Type x : list) {\n+                    verifyQueryResultType(x);\n+                }\n+                return t;\n+            }\n+        } else if (!DotNames.OBJECT.equals(t.name())) {\n+            ClassInfo typeClassInfo = index.getClassByName(t.name());\n+            if (typeClassInfo == null) {\n+                throw new IllegalStateException(t.name() + \" was not part of the Quarkus index\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    // Verify the implementation class exists (generate it if necessary)\n+    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n+        DotName interfaceName = interfaceInfo.name();\n+        DotName customImplName = customReturnTypes.get(interfaceName);\n+\n+        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n+        if (customImplName == null) {\n+            customImplName = GenerationUtil.createImplDotName(interfaceName);\n+            try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n+                    .interfaces(interfaceName.toString()).className(customImplName.toString())\n+                    .build()) {\n+\n+                List<MethodInfo> methods = interfaceInfo.methods();\n+\n+                // Work with methods in declared order\n+                for (int i = 0; i < methods.size(); i++) {\n+                    MethodInfo method = methods.get(i);\n+\n+                    if (!method.parameters().isEmpty()) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method since it defined parameters\");\n+                    }\n+                    Type returnType = method.returnType();\n+                    if (returnType.kind() == Type.Kind.VOID) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method since it returns void\");\n+                    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYyNzA3OA==", "bodyText": "I've changed it a bit to only look for getters .. Given the impl has to be generated, it can't do/won't build anything else. I will follow-up and ask what is allowed, now that I know what question to ask. ;)", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r370627078", "createdAt": "2020-01-24T13:15:02Z", "author": {"login": "ebullient"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -298,4 +336,119 @@ private ResultHandle generateSort(Integer sortParameterIndex, MethodCreator meth\n         }\n         return sort;\n     }\n+\n+    // Make sure the return type is referencing a class we have indexed \n+    // somewhere along the way (e.g. non-entity return types in @Query methods)\n+    // Unless it is some kind of collection containing multiple types, \n+    // return the type used in the query result.\n+    private Type verifyQueryResultType(Type t) {\n+        if (t.kind() == Kind.ARRAY) {\n+            return verifyQueryResultType(t.asArrayType().component());\n+        } else if (t.kind() == Kind.PARAMETERIZED_TYPE) {\n+            List<Type> list = t.asParameterizedType().arguments();\n+            if (list.size() == 1) {\n+                return verifyQueryResultType(list.get(0));\n+            } else {\n+                for (Type x : list) {\n+                    verifyQueryResultType(x);\n+                }\n+                return t;\n+            }\n+        } else if (!DotNames.OBJECT.equals(t.name())) {\n+            ClassInfo typeClassInfo = index.getClassByName(t.name());\n+            if (typeClassInfo == null) {\n+                throw new IllegalStateException(t.name() + \" was not part of the Quarkus index\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    // Verify the implementation class exists (generate it if necessary)\n+    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n+        DotName interfaceName = interfaceInfo.name();\n+        DotName customImplName = customReturnTypes.get(interfaceName);\n+\n+        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n+        if (customImplName == null) {\n+            customImplName = GenerationUtil.createImplDotName(interfaceName);\n+            try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n+                    .interfaces(interfaceName.toString()).className(customImplName.toString())\n+                    .build()) {\n+\n+                List<MethodInfo> methods = interfaceInfo.methods();\n+\n+                // Work with methods in declared order\n+                for (int i = 0; i < methods.size(); i++) {\n+                    MethodInfo method = methods.get(i);\n+\n+                    if (!method.parameters().isEmpty()) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method since it defined parameters\");\n+                    }\n+                    Type returnType = method.returnType();\n+                    if (returnType.kind() == Type.Kind.VOID) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method since it returns void\");\n+                    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMjA3NA=="}, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYyODU1Nw==", "bodyText": "Sounds good", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r370628557", "createdAt": "2020-01-24T13:18:57Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -298,4 +336,119 @@ private ResultHandle generateSort(Integer sortParameterIndex, MethodCreator meth\n         }\n         return sort;\n     }\n+\n+    // Make sure the return type is referencing a class we have indexed \n+    // somewhere along the way (e.g. non-entity return types in @Query methods)\n+    // Unless it is some kind of collection containing multiple types, \n+    // return the type used in the query result.\n+    private Type verifyQueryResultType(Type t) {\n+        if (t.kind() == Kind.ARRAY) {\n+            return verifyQueryResultType(t.asArrayType().component());\n+        } else if (t.kind() == Kind.PARAMETERIZED_TYPE) {\n+            List<Type> list = t.asParameterizedType().arguments();\n+            if (list.size() == 1) {\n+                return verifyQueryResultType(list.get(0));\n+            } else {\n+                for (Type x : list) {\n+                    verifyQueryResultType(x);\n+                }\n+                return t;\n+            }\n+        } else if (!DotNames.OBJECT.equals(t.name())) {\n+            ClassInfo typeClassInfo = index.getClassByName(t.name());\n+            if (typeClassInfo == null) {\n+                throw new IllegalStateException(t.name() + \" was not part of the Quarkus index\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    // Verify the implementation class exists (generate it if necessary)\n+    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n+        DotName interfaceName = interfaceInfo.name();\n+        DotName customImplName = customReturnTypes.get(interfaceName);\n+\n+        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n+        if (customImplName == null) {\n+            customImplName = GenerationUtil.createImplDotName(interfaceName);\n+            try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n+                    .interfaces(interfaceName.toString()).className(customImplName.toString())\n+                    .build()) {\n+\n+                List<MethodInfo> methods = interfaceInfo.methods();\n+\n+                // Work with methods in declared order\n+                for (int i = 0; i < methods.size(); i++) {\n+                    MethodInfo method = methods.get(i);\n+\n+                    if (!method.parameters().isEmpty()) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method since it defined parameters\");\n+                    }\n+                    Type returnType = method.returnType();\n+                    if (returnType.kind() == Type.Kind.VOID) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method since it returns void\");\n+                    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMjA3NA=="}, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MzEzMDM4OnYy", "diffSide": "RIGHT", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwNzozNzoxMFrOFgSu4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNDowMDoyNlrOFgdCbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwNTY2Ng==", "bodyText": "Although this does do what it's intended to do, I suspect however that it will be problematic when the same Class is returned from multiple repository methods that don't use the same ordering for fields.\nIn you test you have:\n    @Query(value = \"SELECT publicationYear as publicationYear, COUNT(*) as count FROM Book GROUP BY publicationYear\")\n    List<BookCountByYear> findAllByPublicationYear();\n\nWhat happens if I do this:\n    @Query(value = \"SELECT COUNT(*) as count, publicationYear as publicationYear FROM Book GROUP BY publicationYear\")\n    List<BookCountByYear> findAllByPublicationYear2();\n\nI actually did try this and it failed :(", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369405666", "createdAt": "2020-01-22T07:37:10Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -298,4 +336,119 @@ private ResultHandle generateSort(Integer sortParameterIndex, MethodCreator meth\n         }\n         return sort;\n     }\n+\n+    // Make sure the return type is referencing a class we have indexed \n+    // somewhere along the way (e.g. non-entity return types in @Query methods)\n+    // Unless it is some kind of collection containing multiple types, \n+    // return the type used in the query result.\n+    private Type verifyQueryResultType(Type t) {\n+        if (t.kind() == Kind.ARRAY) {\n+            return verifyQueryResultType(t.asArrayType().component());\n+        } else if (t.kind() == Kind.PARAMETERIZED_TYPE) {\n+            List<Type> list = t.asParameterizedType().arguments();\n+            if (list.size() == 1) {\n+                return verifyQueryResultType(list.get(0));\n+            } else {\n+                for (Type x : list) {\n+                    verifyQueryResultType(x);\n+                }\n+                return t;\n+            }\n+        } else if (!DotNames.OBJECT.equals(t.name())) {\n+            ClassInfo typeClassInfo = index.getClassByName(t.name());\n+            if (typeClassInfo == null) {\n+                throw new IllegalStateException(t.name() + \" was not part of the Quarkus index\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    // Verify the implementation class exists (generate it if necessary)\n+    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n+        DotName interfaceName = interfaceInfo.name();\n+        DotName customImplName = customReturnTypes.get(interfaceName);\n+\n+        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n+        if (customImplName == null) {\n+            customImplName = GenerationUtil.createImplDotName(interfaceName);\n+            try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n+                    .interfaces(interfaceName.toString()).className(customImplName.toString())\n+                    .build()) {\n+\n+                List<MethodInfo> methods = interfaceInfo.methods();\n+\n+                // Work with methods in declared order\n+                for (int i = 0; i < methods.size(); i++) {\n+                    MethodInfo method = methods.get(i);\n+\n+                    if (!method.parameters().isEmpty()) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method since it defined parameters\");\n+                    }\n+                    Type returnType = method.returnType();\n+                    if (returnType.kind() == Type.Kind.VOID) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method since it returns void\");\n+                    }\n+\n+                    String getterName = method.name();\n+                    String propertyName = JavaBeanUtil.getPropertyNameFromGetter(getterName);\n+                    DotName returnTypeName = method.returnType().name();\n+                    DotName fieldTypeName = GenerationUtil.getPrimitiveTypeName(returnTypeName);\n+\n+                    if (!fieldNames.contains(propertyName)) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method for a field defined in the original query \" + fieldNames);\n+                    }\n+\n+                    FieldDescriptor field = implClassCreator.getFieldCreator(propertyName, fieldTypeName.toString())\n+                            .getFieldDescriptor();\n+                    fields.put(propertyName, field);\n+\n+                    // create getter (based on the interface)\n+                    try (MethodCreator getter = implClassCreator.getMethodCreator(getterName, returnType.toString())) {\n+                        getter.setModifiers(Modifier.PUBLIC);\n+                        getter.returnValue(getter.readInstanceField(field, getter.getThis()));\n+                    }\n+                }\n+\n+                // Generate a static 'convert' method, to convert Object[] to field values\n+                try (MethodCreator convert = implClassCreator.getMethodCreator(\"convert\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwNzA0Ng==", "bodyText": "What I think you'll need to do is take into account the fieldNames in the convert method by adding it as a parameter and then doing some magic to work out the proper order", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369407046", "createdAt": "2020-01-22T07:42:02Z", "author": {"login": "geoand"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -298,4 +336,119 @@ private ResultHandle generateSort(Integer sortParameterIndex, MethodCreator meth\n         }\n         return sort;\n     }\n+\n+    // Make sure the return type is referencing a class we have indexed \n+    // somewhere along the way (e.g. non-entity return types in @Query methods)\n+    // Unless it is some kind of collection containing multiple types, \n+    // return the type used in the query result.\n+    private Type verifyQueryResultType(Type t) {\n+        if (t.kind() == Kind.ARRAY) {\n+            return verifyQueryResultType(t.asArrayType().component());\n+        } else if (t.kind() == Kind.PARAMETERIZED_TYPE) {\n+            List<Type> list = t.asParameterizedType().arguments();\n+            if (list.size() == 1) {\n+                return verifyQueryResultType(list.get(0));\n+            } else {\n+                for (Type x : list) {\n+                    verifyQueryResultType(x);\n+                }\n+                return t;\n+            }\n+        } else if (!DotNames.OBJECT.equals(t.name())) {\n+            ClassInfo typeClassInfo = index.getClassByName(t.name());\n+            if (typeClassInfo == null) {\n+                throw new IllegalStateException(t.name() + \" was not part of the Quarkus index\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    // Verify the implementation class exists (generate it if necessary)\n+    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n+        DotName interfaceName = interfaceInfo.name();\n+        DotName customImplName = customReturnTypes.get(interfaceName);\n+\n+        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n+        if (customImplName == null) {\n+            customImplName = GenerationUtil.createImplDotName(interfaceName);\n+            try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n+                    .interfaces(interfaceName.toString()).className(customImplName.toString())\n+                    .build()) {\n+\n+                List<MethodInfo> methods = interfaceInfo.methods();\n+\n+                // Work with methods in declared order\n+                for (int i = 0; i < methods.size(); i++) {\n+                    MethodInfo method = methods.get(i);\n+\n+                    if (!method.parameters().isEmpty()) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method since it defined parameters\");\n+                    }\n+                    Type returnType = method.returnType();\n+                    if (returnType.kind() == Type.Kind.VOID) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method since it returns void\");\n+                    }\n+\n+                    String getterName = method.name();\n+                    String propertyName = JavaBeanUtil.getPropertyNameFromGetter(getterName);\n+                    DotName returnTypeName = method.returnType().name();\n+                    DotName fieldTypeName = GenerationUtil.getPrimitiveTypeName(returnTypeName);\n+\n+                    if (!fieldNames.contains(propertyName)) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method for a field defined in the original query \" + fieldNames);\n+                    }\n+\n+                    FieldDescriptor field = implClassCreator.getFieldCreator(propertyName, fieldTypeName.toString())\n+                            .getFieldDescriptor();\n+                    fields.put(propertyName, field);\n+\n+                    // create getter (based on the interface)\n+                    try (MethodCreator getter = implClassCreator.getMethodCreator(getterName, returnType.toString())) {\n+                        getter.setModifiers(Modifier.PUBLIC);\n+                        getter.returnValue(getter.readInstanceField(field, getter.getThis()));\n+                    }\n+                }\n+\n+                // Generate a static 'convert' method, to convert Object[] to field values\n+                try (MethodCreator convert = implClassCreator.getMethodCreator(\"convert\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwNTY2Ng=="}, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3NDUxMA==", "bodyText": "I think I'd have to mark the query uniquely, and include that in a separate convert method. The order of the columns is significant, so while those have the same custom return type, it is probably safer to treat as two separate implementations. .. maybe. I will have to see if I still have the field order available when calling convert later.", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369574510", "createdAt": "2020-01-22T14:00:26Z", "author": {"login": "ebullient"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -298,4 +336,119 @@ private ResultHandle generateSort(Integer sortParameterIndex, MethodCreator meth\n         }\n         return sort;\n     }\n+\n+    // Make sure the return type is referencing a class we have indexed \n+    // somewhere along the way (e.g. non-entity return types in @Query methods)\n+    // Unless it is some kind of collection containing multiple types, \n+    // return the type used in the query result.\n+    private Type verifyQueryResultType(Type t) {\n+        if (t.kind() == Kind.ARRAY) {\n+            return verifyQueryResultType(t.asArrayType().component());\n+        } else if (t.kind() == Kind.PARAMETERIZED_TYPE) {\n+            List<Type> list = t.asParameterizedType().arguments();\n+            if (list.size() == 1) {\n+                return verifyQueryResultType(list.get(0));\n+            } else {\n+                for (Type x : list) {\n+                    verifyQueryResultType(x);\n+                }\n+                return t;\n+            }\n+        } else if (!DotNames.OBJECT.equals(t.name())) {\n+            ClassInfo typeClassInfo = index.getClassByName(t.name());\n+            if (typeClassInfo == null) {\n+                throw new IllegalStateException(t.name() + \" was not part of the Quarkus index\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    // Verify the implementation class exists (generate it if necessary)\n+    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n+        DotName interfaceName = interfaceInfo.name();\n+        DotName customImplName = customReturnTypes.get(interfaceName);\n+\n+        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n+        if (customImplName == null) {\n+            customImplName = GenerationUtil.createImplDotName(interfaceName);\n+            try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n+                    .interfaces(interfaceName.toString()).className(customImplName.toString())\n+                    .build()) {\n+\n+                List<MethodInfo> methods = interfaceInfo.methods();\n+\n+                // Work with methods in declared order\n+                for (int i = 0; i < methods.size(); i++) {\n+                    MethodInfo method = methods.get(i);\n+\n+                    if (!method.parameters().isEmpty()) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method since it defined parameters\");\n+                    }\n+                    Type returnType = method.returnType();\n+                    if (returnType.kind() == Type.Kind.VOID) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method since it returns void\");\n+                    }\n+\n+                    String getterName = method.name();\n+                    String propertyName = JavaBeanUtil.getPropertyNameFromGetter(getterName);\n+                    DotName returnTypeName = method.returnType().name();\n+                    DotName fieldTypeName = GenerationUtil.getPrimitiveTypeName(returnTypeName);\n+\n+                    if (!fieldNames.contains(propertyName)) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method for a field defined in the original query \" + fieldNames);\n+                    }\n+\n+                    FieldDescriptor field = implClassCreator.getFieldCreator(propertyName, fieldTypeName.toString())\n+                            .getFieldDescriptor();\n+                    fields.put(propertyName, field);\n+\n+                    // create getter (based on the interface)\n+                    try (MethodCreator getter = implClassCreator.getMethodCreator(getterName, returnType.toString())) {\n+                        getter.setModifiers(Modifier.PUBLIC);\n+                        getter.returnValue(getter.readInstanceField(field, getter.getThis()));\n+                    }\n+                }\n+\n+                // Generate a static 'convert' method, to convert Object[] to field values\n+                try (MethodCreator convert = implClassCreator.getMethodCreator(\"convert\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwNTY2Ng=="}, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MzU2MjUwOnYy", "diffSide": "RIGHT", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMDoxNDo0MVrOFgW1Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMDoxNjoyOVrOFgW4vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3Mjc5NA==", "bodyText": "Content of this block could be a private method e.g. generateInterfaceImplementation(...)", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369472794", "createdAt": "2020-01-22T10:14:41Z", "author": {"login": "gytis"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -298,4 +336,119 @@ private ResultHandle generateSort(Integer sortParameterIndex, MethodCreator meth\n         }\n         return sort;\n     }\n+\n+    // Make sure the return type is referencing a class we have indexed \n+    // somewhere along the way (e.g. non-entity return types in @Query methods)\n+    // Unless it is some kind of collection containing multiple types, \n+    // return the type used in the query result.\n+    private Type verifyQueryResultType(Type t) {\n+        if (t.kind() == Kind.ARRAY) {\n+            return verifyQueryResultType(t.asArrayType().component());\n+        } else if (t.kind() == Kind.PARAMETERIZED_TYPE) {\n+            List<Type> list = t.asParameterizedType().arguments();\n+            if (list.size() == 1) {\n+                return verifyQueryResultType(list.get(0));\n+            } else {\n+                for (Type x : list) {\n+                    verifyQueryResultType(x);\n+                }\n+                return t;\n+            }\n+        } else if (!DotNames.OBJECT.equals(t.name())) {\n+            ClassInfo typeClassInfo = index.getClassByName(t.name());\n+            if (typeClassInfo == null) {\n+                throw new IllegalStateException(t.name() + \" was not part of the Quarkus index\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    // Verify the implementation class exists (generate it if necessary)\n+    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n+        DotName interfaceName = interfaceInfo.name();\n+        DotName customImplName = customReturnTypes.get(interfaceName);\n+\n+        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n+        if (customImplName == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3MzcyNA==", "bodyText": "Same for further blocks: generateMethod, generateField, generateConverter etc.. I think it might improve readability.", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369473724", "createdAt": "2020-01-22T10:16:29Z", "author": {"login": "gytis"}, "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -298,4 +336,119 @@ private ResultHandle generateSort(Integer sortParameterIndex, MethodCreator meth\n         }\n         return sort;\n     }\n+\n+    // Make sure the return type is referencing a class we have indexed \n+    // somewhere along the way (e.g. non-entity return types in @Query methods)\n+    // Unless it is some kind of collection containing multiple types, \n+    // return the type used in the query result.\n+    private Type verifyQueryResultType(Type t) {\n+        if (t.kind() == Kind.ARRAY) {\n+            return verifyQueryResultType(t.asArrayType().component());\n+        } else if (t.kind() == Kind.PARAMETERIZED_TYPE) {\n+            List<Type> list = t.asParameterizedType().arguments();\n+            if (list.size() == 1) {\n+                return verifyQueryResultType(list.get(0));\n+            } else {\n+                for (Type x : list) {\n+                    verifyQueryResultType(x);\n+                }\n+                return t;\n+            }\n+        } else if (!DotNames.OBJECT.equals(t.name())) {\n+            ClassInfo typeClassInfo = index.getClassByName(t.name());\n+            if (typeClassInfo == null) {\n+                throw new IllegalStateException(t.name() + \" was not part of the Quarkus index\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    // Verify the implementation class exists (generate it if necessary)\n+    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n+        DotName interfaceName = interfaceInfo.name();\n+        DotName customImplName = customReturnTypes.get(interfaceName);\n+\n+        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n+        if (customImplName == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3Mjc5NA=="}, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MzYxNTMzOnYy", "diffSide": "RIGHT", "path": "integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookRepository.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMDozMDo0NVrOFgXU_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNToxMToxMFrOFgfpxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4MDk1OA==", "bodyText": "I don't know how it's done in Spring Data, but why can't field name without alias be treated as is? Now publicationYear as publicationYear seems redundant.", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369480958", "createdAt": "2020-01-22T10:30:45Z", "author": {"login": "gytis"}, "path": "integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookRepository.java", "diffHunk": "@@ -22,4 +23,14 @@\n     boolean existsBookByPublicationYearBetween(Integer start, Integer end);\n \n     Optional<Book> findByPublicationYear(Integer year);\n+\n+    // issue 6205\n+    @Query(value = \"SELECT publicationYear as publicationYear, COUNT(*) as count FROM Book GROUP BY publicationYear\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3NTY0NA==", "bodyText": "I can try using the original name if it is otherwise missing. Will see where that gets me", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369575644", "createdAt": "2020-01-22T14:02:28Z", "author": {"login": "ebullient"}, "path": "integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookRepository.java", "diffHunk": "@@ -22,4 +23,14 @@\n     boolean existsBookByPublicationYearBetween(Integer start, Integer end);\n \n     Optional<Book> findByPublicationYear(Integer year);\n+\n+    // issue 6205\n+    @Query(value = \"SELECT publicationYear as publicationYear, COUNT(*) as count FROM Book GROUP BY publicationYear\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4MDk1OA=="}, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3NzYzNg==", "bodyText": "Yeah I agree with @gytis . From an implementation perspective it shouldn't be any harder (except probably for a more complex regex)", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369577636", "createdAt": "2020-01-22T14:06:12Z", "author": {"login": "geoand"}, "path": "integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookRepository.java", "diffHunk": "@@ -22,4 +23,14 @@\n     boolean existsBookByPublicationYearBetween(Integer start, Integer end);\n \n     Optional<Book> findByPublicationYear(Integer year);\n+\n+    // issue 6205\n+    @Query(value = \"SELECT publicationYear as publicationYear, COUNT(*) as count FROM Book GROUP BY publicationYear\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4MDk1OA=="}, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxNzM0OA==", "bodyText": "agree", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369617348", "createdAt": "2020-01-22T15:11:10Z", "author": {"login": "ebullient"}, "path": "integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookRepository.java", "diffHunk": "@@ -22,4 +23,14 @@\n     boolean existsBookByPublicationYearBetween(Integer start, Integer end);\n \n     Optional<Book> findByPublicationYear(Integer year);\n+\n+    // issue 6205\n+    @Query(value = \"SELECT publicationYear as publicationYear, COUNT(*) as count FROM Book GROUP BY publicationYear\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4MDk1OA=="}, "originalCommit": {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MDY0MzMyOnYy", "diffSide": "RIGHT", "path": "integration-tests/spring-data-jpa/src/main/resources/application.properties", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxMTowNjowMFrOFhaeBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxMzoxODoxOFrOFikl_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4MDk5OQ==", "bodyText": "I doubt we want this :)", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r370580999", "createdAt": "2020-01-24T11:06:00Z", "author": {"login": "geoand"}, "path": "integration-tests/spring-data-jpa/src/main/resources/application.properties", "diffHunk": "@@ -8,3 +8,5 @@ quarkus.hibernate-orm.database.generation=drop-and-create\n #quarkus.hibernate-orm.log.sql=true\n \n %prod.quarkus.hibernate-orm.sql-load-script=import.sql\n+\n+quarkus.log.category.\\\"io.quarkus.spring.data\\\".level=TRACE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34b49e7911dee65b5f4a6f5c3f784e5c7120cdf5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYyNzI1Nw==", "bodyText": "woops!", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r370627257", "createdAt": "2020-01-24T13:15:30Z", "author": {"login": "ebullient"}, "path": "integration-tests/spring-data-jpa/src/main/resources/application.properties", "diffHunk": "@@ -8,3 +8,5 @@ quarkus.hibernate-orm.database.generation=drop-and-create\n #quarkus.hibernate-orm.log.sql=true\n \n %prod.quarkus.hibernate-orm.sql-load-script=import.sql\n+\n+quarkus.log.category.\\\"io.quarkus.spring.data\\\".level=TRACE", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4MDk5OQ=="}, "originalCommit": {"oid": "34b49e7911dee65b5f4a6f5c3f784e5c7120cdf5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYyMzQzOA==", "bodyText": "It seems to still be there, can you remove it please?", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r371623438", "createdAt": "2020-01-28T06:09:28Z", "author": {"login": "geoand"}, "path": "integration-tests/spring-data-jpa/src/main/resources/application.properties", "diffHunk": "@@ -8,3 +8,5 @@ quarkus.hibernate-orm.database.generation=drop-and-create\n #quarkus.hibernate-orm.log.sql=true\n \n %prod.quarkus.hibernate-orm.sql-load-script=import.sql\n+\n+quarkus.log.category.\\\"io.quarkus.spring.data\\\".level=TRACE", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4MDk5OQ=="}, "originalCommit": {"oid": "34b49e7911dee65b5f4a6f5c3f784e5c7120cdf5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc5NTQ1Mw==", "bodyText": "Crap. I thought I had. I bet it got lost when I got frustrated with messy attempts and just reset things back to what I'd pushed already in a fit of pique.", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r371795453", "createdAt": "2020-01-28T13:18:18Z", "author": {"login": "ebullient"}, "path": "integration-tests/spring-data-jpa/src/main/resources/application.properties", "diffHunk": "@@ -8,3 +8,5 @@ quarkus.hibernate-orm.database.generation=drop-and-create\n #quarkus.hibernate-orm.log.sql=true\n \n %prod.quarkus.hibernate-orm.sql-load-script=import.sql\n+\n+quarkus.log.category.\\\"io.quarkus.spring.data\\\".level=TRACE", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDU4MDk5OQ=="}, "originalCommit": {"oid": "34b49e7911dee65b5f4a6f5c3f784e5c7120cdf5"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NzUzNjYxOnYy", "diffSide": "RIGHT", "path": "integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookResource.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwNjoxMDoxNVrOFiaGlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxMzozNjoxNlrOFilKSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYyMzU3NA==", "bodyText": "I am also thinking that the tests should include another custom type as well, just to be sure nothing weird gets tripped", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r371623574", "createdAt": "2020-01-28T06:10:15Z", "author": {"login": "geoand"}, "path": "integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookResource.java", "diffHunk": "@@ -58,4 +59,33 @@ public Response findByPublicationYear(@PathParam(\"year\") Integer year) {\n         Optional<Book> book = bookRepository.findByPublicationYear(year);\n         return book.map(b -> Response.ok(book).build()).orElse(Response.noContent().build());\n     }\n+\n+    @GET\n+    @Path(\"/count/year\")\n+    @Produces(\"application/json\")\n+    public List<BookRepository.BookCountByYear> countAllByPublicationYear() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78c2767d8440f23a01399b9a31bfaff360fb2389"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgwMTE5NA==", "bodyText": "Will add another. Give me a few. Will use at least one different attribute type. I'm afraid my brain fails at anything useful for a Join query.", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r371801194", "createdAt": "2020-01-28T13:29:32Z", "author": {"login": "ebullient"}, "path": "integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookResource.java", "diffHunk": "@@ -58,4 +59,33 @@ public Response findByPublicationYear(@PathParam(\"year\") Integer year) {\n         Optional<Book> book = bookRepository.findByPublicationYear(year);\n         return book.map(b -> Response.ok(book).build()).orElse(Response.noContent().build());\n     }\n+\n+    @GET\n+    @Path(\"/count/year\")\n+    @Produces(\"application/json\")\n+    public List<BookRepository.BookCountByYear> countAllByPublicationYear() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYyMzU3NA=="}, "originalCommit": {"oid": "78c2767d8440f23a01399b9a31bfaff360fb2389"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgwNDc0NA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r371804744", "createdAt": "2020-01-28T13:36:16Z", "author": {"login": "geoand"}, "path": "integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookResource.java", "diffHunk": "@@ -58,4 +59,33 @@ public Response findByPublicationYear(@PathParam(\"year\") Integer year) {\n         Optional<Book> book = bookRepository.findByPublicationYear(year);\n         return book.map(b -> Response.ok(book).build()).orElse(Response.noContent().build());\n     }\n+\n+    @GET\n+    @Path(\"/count/year\")\n+    @Produces(\"application/json\")\n+    public List<BookRepository.BookCountByYear> countAllByPublicationYear() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYyMzU3NA=="}, "originalCommit": {"oid": "78c2767d8440f23a01399b9a31bfaff360fb2389"}, "originalPosition": 16}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1262, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}