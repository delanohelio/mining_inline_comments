{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg2MTg4MTMx", "number": 1182, "title": "datatable/java: Support for Optional<T>", "bodyText": "Summary\nAbility to use a tables with Optional types.\nDetails\nI've added a new TableCellTransformers.\nMotivation and Context\n#1091\nHow Has This Been Tested?\n\n\n\n\nScreenshots (if appropriate):\nTypes of changes\n\n\n Bug fix (non-breaking change which fixes an issue).\n New feature (non-breaking change which adds functionality).\n Breaking change (fix or feature that would cause existing functionality to not work as expected).\n\nChecklist:\n\n\n\n The change has been ported to Java.\n The change has been ported to Ruby.\n The change has been ported to JavaScript.\n The change has been ported to Go.\n The change has been ported to .NET.\n I've added tests for my code.\n My change requires a change to the documentation.\n I have updated the documentation accordingly.\n I have updated the CHANGELOG accordingly.", "createdAt": "2020-09-13T14:14:30Z", "url": "https://github.com/cucumber/common/pull/1182", "merged": true, "mergeCommit": {"oid": "d0f6307796911ecf87069d599173e43a3abaea01"}, "closed": true, "closedAt": "2020-09-26T19:48:07Z", "author": {"login": "rasklaad"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdIfILQgH2gAyNDg2MTg4MTMxOmIwNzk4ZjM0OGMyNDUzOThkZjA4NmYwYzExNTI2YzA1OWZkNDkyNGY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdMvbxeAH2gAyNDg2MTg4MTMxOjg4YjQzYjRiNWU1NmJiYTg5YzgyMjQ3MDUwOGY2ZDllYmU1MWY0ZTc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b0798f348c245398df086f0c11526c059fd4924f", "author": {"user": {"login": "rasklaad", "name": "Anton Deriabin"}}, "url": "https://github.com/cucumber/common/commit/b0798f348c245398df086f0c11526c059fd4924f", "committedDate": "2020-09-13T14:04:37Z", "message": "Support for Optional"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MzMxNjE5", "url": "https://github.com/cucumber/common/pull/1182#pullrequestreview-487331619", "createdAt": "2020-09-13T19:00:31Z", "commit": {"oid": "b0798f348c245398df086f0c11526c059fd4924f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxOTowMDozMVrOHQ-ljQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xM1QxOTowNDoyNFrOHQ-nXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NDY4NQ==", "bodyText": "The pattern s == null || s.isEmpty() ? Optional.empty() : Optional.of(do-something-transformer-specific) is very repetitive. Have a look at the way applyIfPresent is used to see if you can remove this repetition.", "url": "https://github.com/cucumber/common/pull/1182#discussion_r487564685", "createdAt": "2020-09-13T19:00:31Z", "author": {"login": "mpkorstanje"}, "path": "datatable/java/datatable/src/main/java/io/cucumber/datatable/DataTableTypeRegistry.java", "diffHunk": "@@ -57,6 +58,44 @@ public DataTableTypeRegistry(Locale locale) {\n         TableCellTransformer<Double> doubleTableCellTransformer = applyIfPresent(numberParser::parseDouble);\n         defineDataTableType(new DataTableType(Double.class, doubleTableCellTransformer));\n         defineDataTableType(new DataTableType(double.class, doubleTableCellTransformer));\n+\n+        TableCellTransformer<Optional<Object>> optionalTableCellTransformer =\n+                (String s) -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(s);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0798f348c245398df086f0c11526c059fd4924f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NTA1OQ==", "bodyText": "The transformer specific function (e.g. numberParser.parseFloat) for both the optional and non-optional transformer should be the same. However it is very hard to verify that this is the case. By moving the definition of the optional and non-optional transformer closer together you can resolve this.\nAdditionally, in combination with my previous comment you can possibly also make it easier to verify that the transformer specific part is indeed the same.", "url": "https://github.com/cucumber/common/pull/1182#discussion_r487565059", "createdAt": "2020-09-13T19:03:27Z", "author": {"login": "mpkorstanje"}, "path": "datatable/java/datatable/src/main/java/io/cucumber/datatable/DataTableTypeRegistry.java", "diffHunk": "@@ -57,6 +58,44 @@ public DataTableTypeRegistry(Locale locale) {\n         TableCellTransformer<Double> doubleTableCellTransformer = applyIfPresent(numberParser::parseDouble);\n         defineDataTableType(new DataTableType(Double.class, doubleTableCellTransformer));\n         defineDataTableType(new DataTableType(double.class, doubleTableCellTransformer));\n+\n+        TableCellTransformer<Optional<Object>> optionalTableCellTransformer =\n+                (String s) -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(s);\n+        defineDataTableType(new DataTableType(Optional.class, optionalTableCellTransformer));\n+\n+        Type optionalString = new TypeReference<Optional<String>>() { }.getType();\n+        defineDataTableType(new DataTableType(optionalString, optionalTableCellTransformer));\n+\n+        Type optionalDouble = new TypeReference<Optional<Double>>() { }.getType();\n+        TableCellTransformer<Optional<Double>> optionalDoubleTableCellTransformer =\n+                (String s) -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(numberParser.parseDouble(s));\n+        defineDataTableType(new DataTableType(optionalDouble, optionalDoubleTableCellTransformer));\n+\n+        Type optionalFloat = new TypeReference<Optional<Float>>() { }.getType();\n+        TableCellTransformer<Optional<Float>> optionalFloatTableCellTransformer =\n+                (String s) -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(numberParser.parseFloat(s));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0798f348c245398df086f0c11526c059fd4924f"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NTE1MA==", "bodyText": "optionalBigInt -> optionalBigInteger. It's  okay to spell things out.", "url": "https://github.com/cucumber/common/pull/1182#discussion_r487565150", "createdAt": "2020-09-13T19:04:24Z", "author": {"login": "mpkorstanje"}, "path": "datatable/java/datatable/src/main/java/io/cucumber/datatable/DataTableTypeRegistry.java", "diffHunk": "@@ -57,6 +58,44 @@ public DataTableTypeRegistry(Locale locale) {\n         TableCellTransformer<Double> doubleTableCellTransformer = applyIfPresent(numberParser::parseDouble);\n         defineDataTableType(new DataTableType(Double.class, doubleTableCellTransformer));\n         defineDataTableType(new DataTableType(double.class, doubleTableCellTransformer));\n+\n+        TableCellTransformer<Optional<Object>> optionalTableCellTransformer =\n+                (String s) -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(s);\n+        defineDataTableType(new DataTableType(Optional.class, optionalTableCellTransformer));\n+\n+        Type optionalString = new TypeReference<Optional<String>>() { }.getType();\n+        defineDataTableType(new DataTableType(optionalString, optionalTableCellTransformer));\n+\n+        Type optionalDouble = new TypeReference<Optional<Double>>() { }.getType();\n+        TableCellTransformer<Optional<Double>> optionalDoubleTableCellTransformer =\n+                (String s) -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(numberParser.parseDouble(s));\n+        defineDataTableType(new DataTableType(optionalDouble, optionalDoubleTableCellTransformer));\n+\n+        Type optionalFloat = new TypeReference<Optional<Float>>() { }.getType();\n+        TableCellTransformer<Optional<Float>> optionalFloatTableCellTransformer =\n+                (String s) -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(numberParser.parseFloat(s));\n+        defineDataTableType(new DataTableType(optionalFloat, optionalFloatTableCellTransformer));\n+\n+        Type optionalLong = new TypeReference<Optional<Long>>() { }.getType();\n+        TableCellTransformer<Optional<Long>> optionalLongTableCellTransformer =\n+                (String s) -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(Long.decode(s));\n+        defineDataTableType(new DataTableType(optionalLong, optionalLongTableCellTransformer));\n+\n+        Type optionalByte = new TypeReference<Optional<Byte>>() { }.getType();\n+        TableCellTransformer<Optional<Byte>> optionalByteTableCellTransformer =\n+                (String s) -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(Byte.decode(s));\n+        defineDataTableType(new DataTableType(optionalByte, optionalByteTableCellTransformer));\n+\n+        Type optionalBigDecimal = new TypeReference<Optional<BigDecimal>>() { }.getType();\n+        TableCellTransformer<Optional<BigDecimal>> optionalBigDecimalTableCellTransformer =\n+                (String s) -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(numberParser.parseBigDecimal(s));\n+        defineDataTableType(new DataTableType(optionalBigDecimal, optionalBigDecimalTableCellTransformer));\n+\n+\n+        Type optionalBigInt = new TypeReference<Optional<BigInteger>>() { }.getType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0798f348c245398df086f0c11526c059fd4924f"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ffecd5d9f49b5cff462431dd5e5b963c8957b6d", "author": {"user": {"login": "aslakhellesoy", "name": "Aslak Helles\u00f8y"}}, "url": "https://github.com/cucumber/common/commit/6ffecd5d9f49b5cff462431dd5e5b963c8957b6d", "committedDate": "2020-09-13T19:45:07Z", "message": "Merge branch 'master' into datatable-java-optional-type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea24c2ebeda482bf9cc70d8bf7f172a436c8f09e", "author": {"user": {"login": "rasklaad", "name": "Anton Deriabin"}}, "url": "https://github.com/cucumber/common/commit/ea24c2ebeda482bf9cc70d8bf7f172a436c8f09e", "committedDate": "2020-09-20T15:57:41Z", "message": "Review fixes:\n  - Removed duplicate code\n  - Optional trasnformers now use same functions as regular\n  transformers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fa58df8ce11379c8bd5a0e8911428a12428a1ac", "author": {"user": {"login": "rasklaad", "name": "Anton Deriabin"}}, "url": "https://github.com/cucumber/common/commit/1fa58df8ce11379c8bd5a0e8911428a12428a1ac", "committedDate": "2020-09-20T15:59:33Z", "message": "Merge branch 'datatable-java-optional-type' of github.com:cucumber/cucumber into datatable-java-optional-type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf1a84a65d29181aa5852f970d3a248da0a0919a", "author": {"user": {"login": "rasklaad", "name": "Anton Deriabin"}}, "url": "https://github.com/cucumber/common/commit/cf1a84a65d29181aa5852f970d3a248da0a0919a", "committedDate": "2020-09-20T16:00:36Z", "message": "Merge remote-tracking branch 'origin/master' into datatable-java-optional-type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55bcd793d074fd7559a9df4a1b079fa3c6c13a8c", "author": {"user": {"login": "mpkorstanje", "name": "M.P. Korstanje"}}, "url": "https://github.com/cucumber/common/commit/55bcd793d074fd7559a9df4a1b079fa3c6c13a8c", "committedDate": "2020-09-20T19:13:14Z", "message": "More review fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyMjE2NDE2", "url": "https://github.com/cucumber/common/pull/1182#pullrequestreview-492216416", "createdAt": "2020-09-20T19:16:52Z", "commit": {"oid": "55bcd793d074fd7559a9df4a1b079fa3c6c13a8c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxOToxNjo1MlrOHU8dZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxOToxNjo1MlrOHU8dZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcyNDEzMg==", "bodyText": "While it would be unexpected the function returned by applyIfPresent will return null when f.appy returns null. So ofNullable should be used here.", "url": "https://github.com/cucumber/common/pull/1182#discussion_r491724132", "createdAt": "2020-09-20T19:16:52Z", "author": {"login": "mpkorstanje"}, "path": "datatable/java/datatable/src/main/java/io/cucumber/datatable/DataTableTypeRegistry.java", "diffHunk": "@@ -26,69 +26,79 @@\n     public DataTableTypeRegistry(Locale locale) {\n         final NumberParser numberParser = new NumberParser(locale);\n \n-        TableCellTransformer<Object> objectTableCellTransformer = applyIfPresent(s -> s);\n-        defineDataTableType(new DataTableType(Object.class, objectTableCellTransformer, true));\n-        defineDataTableType(new DataTableType(String.class, objectTableCellTransformer, true));\n-\n-        TableCellTransformer<BigInteger> bigIntegerTableCellTransformer = applyIfPresent(BigInteger::new);\n-        defineDataTableType(new DataTableType(BigInteger.class, bigIntegerTableCellTransformer));\n-\n-        TableCellTransformer<BigDecimal> bigDecimalTableCellTransformer = applyIfPresent(numberParser::parseBigDecimal);\n-        defineDataTableType(new DataTableType(BigDecimal.class, bigDecimalTableCellTransformer));\n-        TableCellTransformer<Byte> byteTableCellTransformer = applyIfPresent(Byte::decode);\n-        defineDataTableType(new DataTableType(Byte.class, byteTableCellTransformer));\n-        defineDataTableType(new DataTableType(byte.class, byteTableCellTransformer));\n-\n-        TableCellTransformer<Short> shortTableCellTransformer = applyIfPresent(Short::decode);\n-        defineDataTableType(new DataTableType(Short.class, shortTableCellTransformer));\n-        defineDataTableType(new DataTableType(short.class, shortTableCellTransformer));\n-\n-        TableCellTransformer<Integer> integerTableCellTransformer = applyIfPresent(Integer::decode);\n-        defineDataTableType(new DataTableType(Integer.class, integerTableCellTransformer));\n-        defineDataTableType(new DataTableType(int.class, integerTableCellTransformer));\n-\n-        TableCellTransformer<Long> longTableCellTransformer = applyIfPresent(Long::decode);\n-        defineDataTableType(new DataTableType(Long.class, longTableCellTransformer));\n-        defineDataTableType(new DataTableType(long.class, longTableCellTransformer));\n-\n-        TableCellTransformer<Float> floatTableCellTransformer = applyIfPresent(numberParser::parseFloat);\n-        defineDataTableType(new DataTableType(Float.class, floatTableCellTransformer));\n-        defineDataTableType(new DataTableType(float.class, floatTableCellTransformer));\n-\n-        TableCellTransformer<Double> doubleTableCellTransformer = applyIfPresent(numberParser::parseDouble);\n-        defineDataTableType(new DataTableType(Double.class, doubleTableCellTransformer));\n-        defineDataTableType(new DataTableType(double.class, doubleTableCellTransformer));\n-\n-        defineDataTableType(new DataTableType(Optional.class, transformAsOptional(objectTableCellTransformer)));\n-\n-        Type optionalString = new TypeReference<Optional<String>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalString, transformAsOptional(objectTableCellTransformer)));\n-\n-        Type optionalDouble = new TypeReference<Optional<Double>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalDouble, transformAsOptional(doubleTableCellTransformer)));\n-\n-        Type optionalFloat = new TypeReference<Optional<Float>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalFloat, transformAsOptional(floatTableCellTransformer)));\n-\n-        Type optionalLong = new TypeReference<Optional<Long>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalLong, transformAsOptional(longTableCellTransformer)));\n-\n-        Type optionalByte = new TypeReference<Optional<Byte>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalByte, transformAsOptional(byteTableCellTransformer)));\n-\n-        Type optionalBigDecimal = new TypeReference<Optional<BigDecimal>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalBigDecimal, transformAsOptional(bigDecimalTableCellTransformer)));\n-\n-        Type optionalBigInteger = new TypeReference<Optional<BigInteger>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalBigInteger, transformAsOptional(bigIntegerTableCellTransformer)));\n+        {\n+            TableCellTransformer<Object> objectTableCellTransformer = applyIfPresent(s -> s);\n+            defineDataTableType(new DataTableType(Object.class, objectTableCellTransformer, true));\n+            defineDataTableType(new DataTableType(Optional.class, optionalIfAbsent(objectTableCellTransformer), true));\n+        }\n+        {\n+            TableCellTransformer<Object> stringTableCellTransformer = applyIfPresent(s -> s);\n+            defineDataTableType(new DataTableType(String.class, stringTableCellTransformer, true));\n+            Type optionalString = new TypeReference<Optional<String>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalString, optionalIfAbsent(stringTableCellTransformer), true));\n+        }\n+        {\n+            TableCellTransformer<BigInteger> bigIntegerTableCellTransformer = applyIfPresent(BigInteger::new);\n+            defineDataTableType(new DataTableType(BigInteger.class, bigIntegerTableCellTransformer));\n+            Type optionalBigInteger = new TypeReference<Optional<BigInteger>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalBigInteger, optionalIfAbsent(bigIntegerTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<BigDecimal> bigDecimalTableCellTransformer = applyIfPresent(numberParser::parseBigDecimal);\n+            defineDataTableType(new DataTableType(BigDecimal.class, bigDecimalTableCellTransformer));\n+            Type optionalBigDecimal = new TypeReference<Optional<BigDecimal>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalBigDecimal, optionalIfAbsent(bigDecimalTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Byte> byteTableCellTransformer = applyIfPresent(Byte::decode);\n+            defineDataTableType(new DataTableType(Byte.class, byteTableCellTransformer));\n+            defineDataTableType(new DataTableType(byte.class, byteTableCellTransformer));\n+            Type optionalByte = new TypeReference<Optional<Byte>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalByte, optionalIfAbsent(byteTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Short> shortTableCellTransformer = applyIfPresent(Short::decode);\n+            defineDataTableType(new DataTableType(Short.class, shortTableCellTransformer));\n+            defineDataTableType(new DataTableType(short.class, shortTableCellTransformer));\n+            Type optionalShort = new TypeReference<Optional<Short>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalShort, optionalIfAbsent(shortTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Integer> integerTableCellTransformer = applyIfPresent(Integer::decode);\n+            defineDataTableType(new DataTableType(Integer.class, integerTableCellTransformer));\n+            defineDataTableType(new DataTableType(int.class, integerTableCellTransformer));\n+            Type optionalInteger = new TypeReference<Optional<Integer>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalInteger, optionalIfAbsent(integerTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Long> longTableCellTransformer = applyIfPresent(Long::decode);\n+            defineDataTableType(new DataTableType(Long.class, longTableCellTransformer));\n+            defineDataTableType(new DataTableType(long.class, longTableCellTransformer));\n+            Type optionalLong = new TypeReference<Optional<Long>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalLong, optionalIfAbsent(longTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Float> floatTableCellTransformer = applyIfPresent(numberParser::parseFloat);\n+            defineDataTableType(new DataTableType(Float.class, floatTableCellTransformer));\n+            defineDataTableType(new DataTableType(float.class, floatTableCellTransformer));\n+            Type optionalFloat = new TypeReference<Optional<Float>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalFloat, optionalIfAbsent(floatTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Double> doubleTableCellTransformer = applyIfPresent(numberParser::parseDouble);\n+            defineDataTableType(new DataTableType(Double.class, doubleTableCellTransformer));\n+            defineDataTableType(new DataTableType(double.class, doubleTableCellTransformer));\n+            Type optionalDouble = new TypeReference<Optional<Double>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalDouble, optionalIfAbsent(doubleTableCellTransformer)));\n+        }\n     }\n \n     private static <R> TableCellTransformer<R> applyIfPresent(Function<String, R> f) {\n         return s -> s == null ? null : f.apply(s);\n     }\n \n-    private static <T> TableCellTransformer<Optional<T>> transformAsOptional(TableCellTransformer<T> tableCellTransformer) {\n-        return s -> s == null || s.isEmpty() ? Optional.empty() : Optional.of(tableCellTransformer.transform(s));\n+    private static <R> TableCellTransformer<Optional<R>> optionalIfAbsent(TableCellTransformer<R> t) {\n+        return s -> s == null || s.isEmpty() ? Optional.empty() : Optional.ofNullable(t.transform(s));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55bcd793d074fd7559a9df4a1b079fa3c6c13a8c"}, "originalPosition": 133}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyMjE2NDYx", "url": "https://github.com/cucumber/common/pull/1182#pullrequestreview-492216461", "createdAt": "2020-09-20T19:17:31Z", "commit": {"oid": "55bcd793d074fd7559a9df4a1b079fa3c6c13a8c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxOToxNzozMlrOHU8dkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxOToxNzozMlrOHU8dkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcyNDE3OA==", "bodyText": "I've moved the optional transformers next to their non-optional counter parts. This allowed me to see that the transformer for integer was missing.", "url": "https://github.com/cucumber/common/pull/1182#discussion_r491724178", "createdAt": "2020-09-20T19:17:32Z", "author": {"login": "mpkorstanje"}, "path": "datatable/java/datatable/src/main/java/io/cucumber/datatable/DataTableTypeRegistry.java", "diffHunk": "@@ -26,69 +26,79 @@\n     public DataTableTypeRegistry(Locale locale) {\n         final NumberParser numberParser = new NumberParser(locale);\n \n-        TableCellTransformer<Object> objectTableCellTransformer = applyIfPresent(s -> s);\n-        defineDataTableType(new DataTableType(Object.class, objectTableCellTransformer, true));\n-        defineDataTableType(new DataTableType(String.class, objectTableCellTransformer, true));\n-\n-        TableCellTransformer<BigInteger> bigIntegerTableCellTransformer = applyIfPresent(BigInteger::new);\n-        defineDataTableType(new DataTableType(BigInteger.class, bigIntegerTableCellTransformer));\n-\n-        TableCellTransformer<BigDecimal> bigDecimalTableCellTransformer = applyIfPresent(numberParser::parseBigDecimal);\n-        defineDataTableType(new DataTableType(BigDecimal.class, bigDecimalTableCellTransformer));\n-        TableCellTransformer<Byte> byteTableCellTransformer = applyIfPresent(Byte::decode);\n-        defineDataTableType(new DataTableType(Byte.class, byteTableCellTransformer));\n-        defineDataTableType(new DataTableType(byte.class, byteTableCellTransformer));\n-\n-        TableCellTransformer<Short> shortTableCellTransformer = applyIfPresent(Short::decode);\n-        defineDataTableType(new DataTableType(Short.class, shortTableCellTransformer));\n-        defineDataTableType(new DataTableType(short.class, shortTableCellTransformer));\n-\n-        TableCellTransformer<Integer> integerTableCellTransformer = applyIfPresent(Integer::decode);\n-        defineDataTableType(new DataTableType(Integer.class, integerTableCellTransformer));\n-        defineDataTableType(new DataTableType(int.class, integerTableCellTransformer));\n-\n-        TableCellTransformer<Long> longTableCellTransformer = applyIfPresent(Long::decode);\n-        defineDataTableType(new DataTableType(Long.class, longTableCellTransformer));\n-        defineDataTableType(new DataTableType(long.class, longTableCellTransformer));\n-\n-        TableCellTransformer<Float> floatTableCellTransformer = applyIfPresent(numberParser::parseFloat);\n-        defineDataTableType(new DataTableType(Float.class, floatTableCellTransformer));\n-        defineDataTableType(new DataTableType(float.class, floatTableCellTransformer));\n-\n-        TableCellTransformer<Double> doubleTableCellTransformer = applyIfPresent(numberParser::parseDouble);\n-        defineDataTableType(new DataTableType(Double.class, doubleTableCellTransformer));\n-        defineDataTableType(new DataTableType(double.class, doubleTableCellTransformer));\n-\n-        defineDataTableType(new DataTableType(Optional.class, transformAsOptional(objectTableCellTransformer)));\n-\n-        Type optionalString = new TypeReference<Optional<String>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalString, transformAsOptional(objectTableCellTransformer)));\n-\n-        Type optionalDouble = new TypeReference<Optional<Double>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalDouble, transformAsOptional(doubleTableCellTransformer)));\n-\n-        Type optionalFloat = new TypeReference<Optional<Float>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalFloat, transformAsOptional(floatTableCellTransformer)));\n-\n-        Type optionalLong = new TypeReference<Optional<Long>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalLong, transformAsOptional(longTableCellTransformer)));\n-\n-        Type optionalByte = new TypeReference<Optional<Byte>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalByte, transformAsOptional(byteTableCellTransformer)));\n-\n-        Type optionalBigDecimal = new TypeReference<Optional<BigDecimal>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalBigDecimal, transformAsOptional(bigDecimalTableCellTransformer)));\n-\n-        Type optionalBigInteger = new TypeReference<Optional<BigInteger>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalBigInteger, transformAsOptional(bigIntegerTableCellTransformer)));\n+        {\n+            TableCellTransformer<Object> objectTableCellTransformer = applyIfPresent(s -> s);\n+            defineDataTableType(new DataTableType(Object.class, objectTableCellTransformer, true));\n+            defineDataTableType(new DataTableType(Optional.class, optionalIfAbsent(objectTableCellTransformer), true));\n+        }\n+        {\n+            TableCellTransformer<Object> stringTableCellTransformer = applyIfPresent(s -> s);\n+            defineDataTableType(new DataTableType(String.class, stringTableCellTransformer, true));\n+            Type optionalString = new TypeReference<Optional<String>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalString, optionalIfAbsent(stringTableCellTransformer), true));\n+        }\n+        {\n+            TableCellTransformer<BigInteger> bigIntegerTableCellTransformer = applyIfPresent(BigInteger::new);\n+            defineDataTableType(new DataTableType(BigInteger.class, bigIntegerTableCellTransformer));\n+            Type optionalBigInteger = new TypeReference<Optional<BigInteger>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalBigInteger, optionalIfAbsent(bigIntegerTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<BigDecimal> bigDecimalTableCellTransformer = applyIfPresent(numberParser::parseBigDecimal);\n+            defineDataTableType(new DataTableType(BigDecimal.class, bigDecimalTableCellTransformer));\n+            Type optionalBigDecimal = new TypeReference<Optional<BigDecimal>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalBigDecimal, optionalIfAbsent(bigDecimalTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Byte> byteTableCellTransformer = applyIfPresent(Byte::decode);\n+            defineDataTableType(new DataTableType(Byte.class, byteTableCellTransformer));\n+            defineDataTableType(new DataTableType(byte.class, byteTableCellTransformer));\n+            Type optionalByte = new TypeReference<Optional<Byte>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalByte, optionalIfAbsent(byteTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Short> shortTableCellTransformer = applyIfPresent(Short::decode);\n+            defineDataTableType(new DataTableType(Short.class, shortTableCellTransformer));\n+            defineDataTableType(new DataTableType(short.class, shortTableCellTransformer));\n+            Type optionalShort = new TypeReference<Optional<Short>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalShort, optionalIfAbsent(shortTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Integer> integerTableCellTransformer = applyIfPresent(Integer::decode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55bcd793d074fd7559a9df4a1b079fa3c6c13a8c"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyMjE2NTAw", "url": "https://github.com/cucumber/common/pull/1182#pullrequestreview-492216500", "createdAt": "2020-09-20T19:18:11Z", "commit": {"oid": "55bcd793d074fd7559a9df4a1b079fa3c6c13a8c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxOToxODoxMVrOHU8dxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxOToxODoxMVrOHU8dxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcyNDIyOQ==", "bodyText": "For consistency I've split Object and String.", "url": "https://github.com/cucumber/common/pull/1182#discussion_r491724229", "createdAt": "2020-09-20T19:18:11Z", "author": {"login": "mpkorstanje"}, "path": "datatable/java/datatable/src/main/java/io/cucumber/datatable/DataTableTypeRegistry.java", "diffHunk": "@@ -26,69 +26,79 @@\n     public DataTableTypeRegistry(Locale locale) {\n         final NumberParser numberParser = new NumberParser(locale);\n \n-        TableCellTransformer<Object> objectTableCellTransformer = applyIfPresent(s -> s);\n-        defineDataTableType(new DataTableType(Object.class, objectTableCellTransformer, true));\n-        defineDataTableType(new DataTableType(String.class, objectTableCellTransformer, true));\n-\n-        TableCellTransformer<BigInteger> bigIntegerTableCellTransformer = applyIfPresent(BigInteger::new);\n-        defineDataTableType(new DataTableType(BigInteger.class, bigIntegerTableCellTransformer));\n-\n-        TableCellTransformer<BigDecimal> bigDecimalTableCellTransformer = applyIfPresent(numberParser::parseBigDecimal);\n-        defineDataTableType(new DataTableType(BigDecimal.class, bigDecimalTableCellTransformer));\n-        TableCellTransformer<Byte> byteTableCellTransformer = applyIfPresent(Byte::decode);\n-        defineDataTableType(new DataTableType(Byte.class, byteTableCellTransformer));\n-        defineDataTableType(new DataTableType(byte.class, byteTableCellTransformer));\n-\n-        TableCellTransformer<Short> shortTableCellTransformer = applyIfPresent(Short::decode);\n-        defineDataTableType(new DataTableType(Short.class, shortTableCellTransformer));\n-        defineDataTableType(new DataTableType(short.class, shortTableCellTransformer));\n-\n-        TableCellTransformer<Integer> integerTableCellTransformer = applyIfPresent(Integer::decode);\n-        defineDataTableType(new DataTableType(Integer.class, integerTableCellTransformer));\n-        defineDataTableType(new DataTableType(int.class, integerTableCellTransformer));\n-\n-        TableCellTransformer<Long> longTableCellTransformer = applyIfPresent(Long::decode);\n-        defineDataTableType(new DataTableType(Long.class, longTableCellTransformer));\n-        defineDataTableType(new DataTableType(long.class, longTableCellTransformer));\n-\n-        TableCellTransformer<Float> floatTableCellTransformer = applyIfPresent(numberParser::parseFloat);\n-        defineDataTableType(new DataTableType(Float.class, floatTableCellTransformer));\n-        defineDataTableType(new DataTableType(float.class, floatTableCellTransformer));\n-\n-        TableCellTransformer<Double> doubleTableCellTransformer = applyIfPresent(numberParser::parseDouble);\n-        defineDataTableType(new DataTableType(Double.class, doubleTableCellTransformer));\n-        defineDataTableType(new DataTableType(double.class, doubleTableCellTransformer));\n-\n-        defineDataTableType(new DataTableType(Optional.class, transformAsOptional(objectTableCellTransformer)));\n-\n-        Type optionalString = new TypeReference<Optional<String>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalString, transformAsOptional(objectTableCellTransformer)));\n-\n-        Type optionalDouble = new TypeReference<Optional<Double>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalDouble, transformAsOptional(doubleTableCellTransformer)));\n-\n-        Type optionalFloat = new TypeReference<Optional<Float>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalFloat, transformAsOptional(floatTableCellTransformer)));\n-\n-        Type optionalLong = new TypeReference<Optional<Long>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalLong, transformAsOptional(longTableCellTransformer)));\n-\n-        Type optionalByte = new TypeReference<Optional<Byte>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalByte, transformAsOptional(byteTableCellTransformer)));\n-\n-        Type optionalBigDecimal = new TypeReference<Optional<BigDecimal>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalBigDecimal, transformAsOptional(bigDecimalTableCellTransformer)));\n-\n-        Type optionalBigInteger = new TypeReference<Optional<BigInteger>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalBigInteger, transformAsOptional(bigIntegerTableCellTransformer)));\n+        {\n+            TableCellTransformer<Object> objectTableCellTransformer = applyIfPresent(s -> s);\n+            defineDataTableType(new DataTableType(Object.class, objectTableCellTransformer, true));\n+            defineDataTableType(new DataTableType(Optional.class, optionalIfAbsent(objectTableCellTransformer), true));\n+        }\n+        {\n+            TableCellTransformer<Object> stringTableCellTransformer = applyIfPresent(s -> s);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55bcd793d074fd7559a9df4a1b079fa3c6c13a8c"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyMjE2NTMw", "url": "https://github.com/cucumber/common/pull/1182#pullrequestreview-492216530", "createdAt": "2020-09-20T19:18:35Z", "commit": {"oid": "55bcd793d074fd7559a9df4a1b079fa3c6c13a8c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxOToxODozNlrOHU8d5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxOToxODozNlrOHU8d5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcyNDI2MA==", "bodyText": "I'm wondering why we're not checking for the empty string here.", "url": "https://github.com/cucumber/common/pull/1182#discussion_r491724260", "createdAt": "2020-09-20T19:18:36Z", "author": {"login": "mpkorstanje"}, "path": "datatable/java/datatable/src/main/java/io/cucumber/datatable/DataTableTypeRegistry.java", "diffHunk": "@@ -26,69 +26,79 @@\n     public DataTableTypeRegistry(Locale locale) {\n         final NumberParser numberParser = new NumberParser(locale);\n \n-        TableCellTransformer<Object> objectTableCellTransformer = applyIfPresent(s -> s);\n-        defineDataTableType(new DataTableType(Object.class, objectTableCellTransformer, true));\n-        defineDataTableType(new DataTableType(String.class, objectTableCellTransformer, true));\n-\n-        TableCellTransformer<BigInteger> bigIntegerTableCellTransformer = applyIfPresent(BigInteger::new);\n-        defineDataTableType(new DataTableType(BigInteger.class, bigIntegerTableCellTransformer));\n-\n-        TableCellTransformer<BigDecimal> bigDecimalTableCellTransformer = applyIfPresent(numberParser::parseBigDecimal);\n-        defineDataTableType(new DataTableType(BigDecimal.class, bigDecimalTableCellTransformer));\n-        TableCellTransformer<Byte> byteTableCellTransformer = applyIfPresent(Byte::decode);\n-        defineDataTableType(new DataTableType(Byte.class, byteTableCellTransformer));\n-        defineDataTableType(new DataTableType(byte.class, byteTableCellTransformer));\n-\n-        TableCellTransformer<Short> shortTableCellTransformer = applyIfPresent(Short::decode);\n-        defineDataTableType(new DataTableType(Short.class, shortTableCellTransformer));\n-        defineDataTableType(new DataTableType(short.class, shortTableCellTransformer));\n-\n-        TableCellTransformer<Integer> integerTableCellTransformer = applyIfPresent(Integer::decode);\n-        defineDataTableType(new DataTableType(Integer.class, integerTableCellTransformer));\n-        defineDataTableType(new DataTableType(int.class, integerTableCellTransformer));\n-\n-        TableCellTransformer<Long> longTableCellTransformer = applyIfPresent(Long::decode);\n-        defineDataTableType(new DataTableType(Long.class, longTableCellTransformer));\n-        defineDataTableType(new DataTableType(long.class, longTableCellTransformer));\n-\n-        TableCellTransformer<Float> floatTableCellTransformer = applyIfPresent(numberParser::parseFloat);\n-        defineDataTableType(new DataTableType(Float.class, floatTableCellTransformer));\n-        defineDataTableType(new DataTableType(float.class, floatTableCellTransformer));\n-\n-        TableCellTransformer<Double> doubleTableCellTransformer = applyIfPresent(numberParser::parseDouble);\n-        defineDataTableType(new DataTableType(Double.class, doubleTableCellTransformer));\n-        defineDataTableType(new DataTableType(double.class, doubleTableCellTransformer));\n-\n-        defineDataTableType(new DataTableType(Optional.class, transformAsOptional(objectTableCellTransformer)));\n-\n-        Type optionalString = new TypeReference<Optional<String>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalString, transformAsOptional(objectTableCellTransformer)));\n-\n-        Type optionalDouble = new TypeReference<Optional<Double>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalDouble, transformAsOptional(doubleTableCellTransformer)));\n-\n-        Type optionalFloat = new TypeReference<Optional<Float>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalFloat, transformAsOptional(floatTableCellTransformer)));\n-\n-        Type optionalLong = new TypeReference<Optional<Long>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalLong, transformAsOptional(longTableCellTransformer)));\n-\n-        Type optionalByte = new TypeReference<Optional<Byte>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalByte, transformAsOptional(byteTableCellTransformer)));\n-\n-        Type optionalBigDecimal = new TypeReference<Optional<BigDecimal>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalBigDecimal, transformAsOptional(bigDecimalTableCellTransformer)));\n-\n-        Type optionalBigInteger = new TypeReference<Optional<BigInteger>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalBigInteger, transformAsOptional(bigIntegerTableCellTransformer)));\n+        {\n+            TableCellTransformer<Object> objectTableCellTransformer = applyIfPresent(s -> s);\n+            defineDataTableType(new DataTableType(Object.class, objectTableCellTransformer, true));\n+            defineDataTableType(new DataTableType(Optional.class, optionalIfAbsent(objectTableCellTransformer), true));\n+        }\n+        {\n+            TableCellTransformer<Object> stringTableCellTransformer = applyIfPresent(s -> s);\n+            defineDataTableType(new DataTableType(String.class, stringTableCellTransformer, true));\n+            Type optionalString = new TypeReference<Optional<String>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalString, optionalIfAbsent(stringTableCellTransformer), true));\n+        }\n+        {\n+            TableCellTransformer<BigInteger> bigIntegerTableCellTransformer = applyIfPresent(BigInteger::new);\n+            defineDataTableType(new DataTableType(BigInteger.class, bigIntegerTableCellTransformer));\n+            Type optionalBigInteger = new TypeReference<Optional<BigInteger>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalBigInteger, optionalIfAbsent(bigIntegerTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<BigDecimal> bigDecimalTableCellTransformer = applyIfPresent(numberParser::parseBigDecimal);\n+            defineDataTableType(new DataTableType(BigDecimal.class, bigDecimalTableCellTransformer));\n+            Type optionalBigDecimal = new TypeReference<Optional<BigDecimal>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalBigDecimal, optionalIfAbsent(bigDecimalTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Byte> byteTableCellTransformer = applyIfPresent(Byte::decode);\n+            defineDataTableType(new DataTableType(Byte.class, byteTableCellTransformer));\n+            defineDataTableType(new DataTableType(byte.class, byteTableCellTransformer));\n+            Type optionalByte = new TypeReference<Optional<Byte>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalByte, optionalIfAbsent(byteTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Short> shortTableCellTransformer = applyIfPresent(Short::decode);\n+            defineDataTableType(new DataTableType(Short.class, shortTableCellTransformer));\n+            defineDataTableType(new DataTableType(short.class, shortTableCellTransformer));\n+            Type optionalShort = new TypeReference<Optional<Short>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalShort, optionalIfAbsent(shortTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Integer> integerTableCellTransformer = applyIfPresent(Integer::decode);\n+            defineDataTableType(new DataTableType(Integer.class, integerTableCellTransformer));\n+            defineDataTableType(new DataTableType(int.class, integerTableCellTransformer));\n+            Type optionalInteger = new TypeReference<Optional<Integer>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalInteger, optionalIfAbsent(integerTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Long> longTableCellTransformer = applyIfPresent(Long::decode);\n+            defineDataTableType(new DataTableType(Long.class, longTableCellTransformer));\n+            defineDataTableType(new DataTableType(long.class, longTableCellTransformer));\n+            Type optionalLong = new TypeReference<Optional<Long>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalLong, optionalIfAbsent(longTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Float> floatTableCellTransformer = applyIfPresent(numberParser::parseFloat);\n+            defineDataTableType(new DataTableType(Float.class, floatTableCellTransformer));\n+            defineDataTableType(new DataTableType(float.class, floatTableCellTransformer));\n+            Type optionalFloat = new TypeReference<Optional<Float>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalFloat, optionalIfAbsent(floatTableCellTransformer)));\n+        }\n+        {\n+            TableCellTransformer<Double> doubleTableCellTransformer = applyIfPresent(numberParser::parseDouble);\n+            defineDataTableType(new DataTableType(Double.class, doubleTableCellTransformer));\n+            defineDataTableType(new DataTableType(double.class, doubleTableCellTransformer));\n+            Type optionalDouble = new TypeReference<Optional<Double>>() {}.getType();\n+            defineDataTableType(new DataTableType(optionalDouble, optionalIfAbsent(doubleTableCellTransformer)));\n+        }\n     }\n \n     private static <R> TableCellTransformer<R> applyIfPresent(Function<String, R> f) {\n         return s -> s == null ? null : f.apply(s);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55bcd793d074fd7559a9df4a1b079fa3c6c13a8c"}, "originalPosition": 127}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyMjE2OTY5", "url": "https://github.com/cucumber/common/pull/1182#pullrequestreview-492216969", "createdAt": "2020-09-20T19:25:45Z", "commit": {"oid": "55bcd793d074fd7559a9df4a1b079fa3c6c13a8c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxOToyNTo0NlrOHU8grQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMFQxOToyNTo0NlrOHU8grQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTcyNDk3Mw==", "bodyText": "true here marks the DataTableType as replaceable. This means that it's possible to register a new transformer that replaces this one. However this means that the optional transformer is not replaced. This seems somewhat inconsistent.\nI would expect that when I replace the objectTableCellTransformer for Object, the Optional<Objec> transformer is used.  And with that in mind would also expect that by registering a transformer for X I would have also registered one for Optional<X>.", "url": "https://github.com/cucumber/common/pull/1182#discussion_r491724973", "createdAt": "2020-09-20T19:25:46Z", "author": {"login": "mpkorstanje"}, "path": "datatable/java/datatable/src/main/java/io/cucumber/datatable/DataTableTypeRegistry.java", "diffHunk": "@@ -26,69 +26,79 @@\n     public DataTableTypeRegistry(Locale locale) {\n         final NumberParser numberParser = new NumberParser(locale);\n \n-        TableCellTransformer<Object> objectTableCellTransformer = applyIfPresent(s -> s);\n-        defineDataTableType(new DataTableType(Object.class, objectTableCellTransformer, true));\n-        defineDataTableType(new DataTableType(String.class, objectTableCellTransformer, true));\n-\n-        TableCellTransformer<BigInteger> bigIntegerTableCellTransformer = applyIfPresent(BigInteger::new);\n-        defineDataTableType(new DataTableType(BigInteger.class, bigIntegerTableCellTransformer));\n-\n-        TableCellTransformer<BigDecimal> bigDecimalTableCellTransformer = applyIfPresent(numberParser::parseBigDecimal);\n-        defineDataTableType(new DataTableType(BigDecimal.class, bigDecimalTableCellTransformer));\n-        TableCellTransformer<Byte> byteTableCellTransformer = applyIfPresent(Byte::decode);\n-        defineDataTableType(new DataTableType(Byte.class, byteTableCellTransformer));\n-        defineDataTableType(new DataTableType(byte.class, byteTableCellTransformer));\n-\n-        TableCellTransformer<Short> shortTableCellTransformer = applyIfPresent(Short::decode);\n-        defineDataTableType(new DataTableType(Short.class, shortTableCellTransformer));\n-        defineDataTableType(new DataTableType(short.class, shortTableCellTransformer));\n-\n-        TableCellTransformer<Integer> integerTableCellTransformer = applyIfPresent(Integer::decode);\n-        defineDataTableType(new DataTableType(Integer.class, integerTableCellTransformer));\n-        defineDataTableType(new DataTableType(int.class, integerTableCellTransformer));\n-\n-        TableCellTransformer<Long> longTableCellTransformer = applyIfPresent(Long::decode);\n-        defineDataTableType(new DataTableType(Long.class, longTableCellTransformer));\n-        defineDataTableType(new DataTableType(long.class, longTableCellTransformer));\n-\n-        TableCellTransformer<Float> floatTableCellTransformer = applyIfPresent(numberParser::parseFloat);\n-        defineDataTableType(new DataTableType(Float.class, floatTableCellTransformer));\n-        defineDataTableType(new DataTableType(float.class, floatTableCellTransformer));\n-\n-        TableCellTransformer<Double> doubleTableCellTransformer = applyIfPresent(numberParser::parseDouble);\n-        defineDataTableType(new DataTableType(Double.class, doubleTableCellTransformer));\n-        defineDataTableType(new DataTableType(double.class, doubleTableCellTransformer));\n-\n-        defineDataTableType(new DataTableType(Optional.class, transformAsOptional(objectTableCellTransformer)));\n-\n-        Type optionalString = new TypeReference<Optional<String>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalString, transformAsOptional(objectTableCellTransformer)));\n-\n-        Type optionalDouble = new TypeReference<Optional<Double>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalDouble, transformAsOptional(doubleTableCellTransformer)));\n-\n-        Type optionalFloat = new TypeReference<Optional<Float>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalFloat, transformAsOptional(floatTableCellTransformer)));\n-\n-        Type optionalLong = new TypeReference<Optional<Long>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalLong, transformAsOptional(longTableCellTransformer)));\n-\n-        Type optionalByte = new TypeReference<Optional<Byte>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalByte, transformAsOptional(byteTableCellTransformer)));\n-\n-        Type optionalBigDecimal = new TypeReference<Optional<BigDecimal>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalBigDecimal, transformAsOptional(bigDecimalTableCellTransformer)));\n-\n-        Type optionalBigInteger = new TypeReference<Optional<BigInteger>>() { }.getType();\n-        defineDataTableType(new DataTableType(optionalBigInteger, transformAsOptional(bigIntegerTableCellTransformer)));\n+        {\n+            TableCellTransformer<Object> objectTableCellTransformer = applyIfPresent(s -> s);\n+            defineDataTableType(new DataTableType(Object.class, objectTableCellTransformer, true));\n+            defineDataTableType(new DataTableType(Optional.class, optionalIfAbsent(objectTableCellTransformer), true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55bcd793d074fd7559a9df4a1b079fa3c6c13a8c"}, "originalPosition": 62}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c619ef9b56a1908ec323ecfd04b1a395ed7b9f5", "author": {"user": {"login": "mpkorstanje", "name": "M.P. Korstanje"}}, "url": "https://github.com/cucumber/common/commit/6c619ef9b56a1908ec323ecfd04b1a395ed7b9f5", "committedDate": "2020-09-20T19:25:57Z", "message": "Naming things."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "181f86854a2bf55fa0fcae8332e51b759f35ccd3", "author": {"user": {"login": "rasklaad", "name": "Anton Deriabin"}}, "url": "https://github.com/cucumber/common/commit/181f86854a2bf55fa0fcae8332e51b759f35ccd3", "committedDate": "2020-09-20T20:16:15Z", "message": "Optional integer tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "360a793a0e198bca446d42c378f960d8cc1ea725", "author": {"user": {"login": "mpkorstanje", "name": "M.P. Korstanje"}}, "url": "https://github.com/cucumber/common/commit/360a793a0e198bca446d42c378f960d8cc1ea725", "committedDate": "2020-09-20T20:50:08Z", "message": "Try some replacement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd018dab6ee514160cf217c5dfcc9363631a9303", "author": {"user": {"login": "mpkorstanje", "name": "M.P. Korstanje"}}, "url": "https://github.com/cucumber/common/commit/cd018dab6ee514160cf217c5dfcc9363631a9303", "committedDate": "2020-09-20T21:08:08Z", "message": "Narrow scope to table cell transformers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c1504ca2a00f1474a6dccf3a5e2c2858295972f", "author": {"user": {"login": "mpkorstanje", "name": "M.P. Korstanje"}}, "url": "https://github.com/cucumber/common/commit/5c1504ca2a00f1474a6dccf3a5e2c2858295972f", "committedDate": "2020-09-20T21:11:22Z", "message": "Narrow scope to table cell transformers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49a9625b85573e9f72ac55fa1cf23b6974bced9f", "author": {"user": {"login": "mpkorstanje", "name": "M.P. Korstanje"}}, "url": "https://github.com/cucumber/common/commit/49a9625b85573e9f72ac55fa1cf23b6974bced9f", "committedDate": "2020-09-25T17:54:27Z", "message": "Use a smart look up to handle with optional"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb1e5b0f3f4ce807e18871ba4cce54d3d800b7ef", "author": {"user": {"login": "mpkorstanje", "name": "M.P. Korstanje"}}, "url": "https://github.com/cucumber/common/commit/cb1e5b0f3f4ce807e18871ba4cce54d3d800b7ef", "committedDate": "2020-09-25T18:31:01Z", "message": "Use sensible error message for optional singletons"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "379e6c536f12faf76f658239d99eb281ab499030", "author": {"user": {"login": "mpkorstanje", "name": "M.P. Korstanje"}}, "url": "https://github.com/cucumber/common/commit/379e6c536f12faf76f658239d99eb281ab499030", "committedDate": "2020-09-25T18:39:22Z", "message": "Better singleton handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2313389397740c0ced8a8ff487b97fb1a150d7e6", "author": {"user": {"login": "mpkorstanje", "name": "M.P. Korstanje"}}, "url": "https://github.com/cucumber/common/commit/2313389397740c0ced8a8ff487b97fb1a150d7e6", "committedDate": "2020-09-25T18:41:22Z", "message": "Merge branch 'master' into datatable-java-optional-type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a8a61a0722549151ccf16f20ead79616b2bc7e8", "author": {"user": {"login": "mpkorstanje", "name": "M.P. Korstanje"}}, "url": "https://github.com/cucumber/common/commit/1a8a61a0722549151ccf16f20ead79616b2bc7e8", "committedDate": "2020-09-26T17:28:16Z", "message": "Naming stuff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4d65b053ca9d6464111096c5a194a1aa045be66", "author": {"user": {"login": "mpkorstanje", "name": "M.P. Korstanje"}}, "url": "https://github.com/cucumber/common/commit/d4d65b053ca9d6464111096c5a194a1aa045be66", "committedDate": "2020-09-26T17:53:31Z", "message": "Add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50ed3c391f23b53be330a1a80813f51bb8cc9a8b", "author": {"user": {"login": "mpkorstanje", "name": "M.P. Korstanje"}}, "url": "https://github.com/cucumber/common/commit/50ed3c391f23b53be330a1a80813f51bb8cc9a8b", "committedDate": "2020-09-26T18:39:13Z", "message": "Update docs; improve tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MDIzNDI0", "url": "https://github.com/cucumber/common/pull/1182#pullrequestreview-497023424", "createdAt": "2020-09-26T18:40:13Z", "commit": {"oid": "50ed3c391f23b53be330a1a80813f51bb8cc9a8b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88b43b4b5e56bba89c822470508f6d9ebe51f4e7", "author": {"user": {"login": "mpkorstanje", "name": "M.P. Korstanje"}}, "url": "https://github.com/cucumber/common/commit/88b43b4b5e56bba89c822470508f6d9ebe51f4e7", "committedDate": "2020-09-26T19:20:12Z", "message": "Update docs; improve tests"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3021, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}