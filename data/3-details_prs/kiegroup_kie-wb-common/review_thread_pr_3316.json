{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1MDQ4OTg0", "number": 3316, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDoyNjozMVrOEBUOMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMTowNDoyMFrOEBsj_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5ODE1MzQ3OnYy", "diffSide": "RIGHT", "path": "kie-wb-common-dmn/kie-wb-common-dmn-client/src/main/java/org/kie/workbench/common/dmn/client/editors/expressions/types/dtable/DecisionTableEditorDefinitionEnricher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDoyNjozMVrOGdFySg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMDo0Nzo1MFrOGdGUGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NjY4Mg==", "bodyText": "I have issue with this method; since it returns an OutputClause that modifies the column collection outside this method; however it adds a LiteralExpression to the DecisionRule inside this method. i.e. IMO the mutations should either both happen inside this method or both outside this method. This is my opinion. If others feel less so; then we can disregard it.", "url": "https://github.com/kiegroup/kie-wb-common/pull/3316#discussion_r433156682", "createdAt": "2020-06-01T10:26:31Z", "author": {"login": "manstis"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-client/src/main/java/org/kie/workbench/common/dmn/client/editors/expressions/types/dtable/DecisionTableEditorDefinitionEnricher.java", "diffHunk": "@@ -152,6 +145,77 @@ public void enrich(final Optional<String> nodeUUID,\n         });\n     }\n \n+    void buildOutputClausesByDataType(final HasExpression hasExpression, final DecisionTable dTable, final DecisionRule decisionRule) {\n+        final HasTypeRef hasTypeRef = TypeRefUtils.getTypeRefOfExpression(dTable, hasExpression);\n+        final QName typeRef = !Objects.isNull(hasTypeRef) ? hasTypeRef.getTypeRef() : BuiltInType.UNDEFINED.asQName();\n+        final String name = DecisionTableDefaultValueUtilities.getNewOutputClauseName(dTable);\n+\n+        final List<ClauseRequirement> outputClausesRequirement = generateOutputClauseRequirements(dmnGraphUtils.getDefinitions(), typeRef, name);\n+\n+        if (outputClausesRequirement.isEmpty()) {\n+            dTable.getOutput().add(\n+                    buildOutputClause(dTable, decisionRule, typeRef, name)\n+            );\n+        } else {\n+            outputClausesRequirement\n+                    .stream()\n+                    .sorted(Comparator.comparing(outputClauseRequirement -> outputClauseRequirement.text))\n+                    .map(outputClauseRequirement -> buildOutputClause(dTable, decisionRule, outputClauseRequirement.typeRef, outputClauseRequirement.text))\n+                    .forEach(dTable.getOutput()::add);\n+        }\n+    }\n+\n+    private List<ClauseRequirement> generateOutputClauseRequirements(final Definitions definitions, final QName typeRef, final String name) {\n+        if (typeRefMatchesBuiltInType(typeRef)) {\n+            return Collections.singletonList(new ClauseRequirement(name, typeRef));\n+        }\n+\n+        return definitions.getItemDefinition()\n+                .stream()\n+                .filter(typeRefIsCustom(typeRef))\n+                .findFirst()\n+                .map(this::generateOutputClauseRequirementsForFirstLevel)\n+                .orElse(Collections.emptyList());\n+    }\n+\n+    private List<ClauseRequirement> generateOutputClauseRequirementsForFirstLevel(final ItemDefinition itemDefinition) {\n+        return itemDefinition.getItemComponent()\n+                .stream()\n+                .map(this::definitionToClauseRequirementMapper)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private ClauseRequirement definitionToClauseRequirementMapper(final ItemDefinition itemDefinition) {\n+        final QName typeRef = itemDefinition.getTypeRef();\n+        final String name = itemDefinition.getName().getValue();\n+\n+        if (Objects.isNull(typeRef) || typeRefDoesNotMatchAnyDefinition(typeRef)) {\n+            return new ClauseRequirement(name, ANY.asQName());\n+        }\n+        return new ClauseRequirement(name, typeRef);\n+    }\n+\n+    private boolean typeRefDoesNotMatchAnyDefinition(final QName typeRef) {\n+        return !typeRefMatchesBuiltInType(typeRef) &&\n+                dmnGraphUtils.getDefinitions().getItemDefinition()\n+                        .stream()\n+                        .noneMatch(typeRefIsCustom(typeRef));\n+    }\n+\n+    private OutputClause buildOutputClause(final DecisionTable dtable, final DecisionRule decisionRule, final QName typeRef, final String text) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5f1b2de9f855271427c21aeaea85907919bcc38"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2NTMzNg==", "bodyText": "You are right. Good catch.", "url": "https://github.com/kiegroup/kie-wb-common/pull/3316#discussion_r433165336", "createdAt": "2020-06-01T10:47:50Z", "author": {"login": "vpellegrino"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-client/src/main/java/org/kie/workbench/common/dmn/client/editors/expressions/types/dtable/DecisionTableEditorDefinitionEnricher.java", "diffHunk": "@@ -152,6 +145,77 @@ public void enrich(final Optional<String> nodeUUID,\n         });\n     }\n \n+    void buildOutputClausesByDataType(final HasExpression hasExpression, final DecisionTable dTable, final DecisionRule decisionRule) {\n+        final HasTypeRef hasTypeRef = TypeRefUtils.getTypeRefOfExpression(dTable, hasExpression);\n+        final QName typeRef = !Objects.isNull(hasTypeRef) ? hasTypeRef.getTypeRef() : BuiltInType.UNDEFINED.asQName();\n+        final String name = DecisionTableDefaultValueUtilities.getNewOutputClauseName(dTable);\n+\n+        final List<ClauseRequirement> outputClausesRequirement = generateOutputClauseRequirements(dmnGraphUtils.getDefinitions(), typeRef, name);\n+\n+        if (outputClausesRequirement.isEmpty()) {\n+            dTable.getOutput().add(\n+                    buildOutputClause(dTable, decisionRule, typeRef, name)\n+            );\n+        } else {\n+            outputClausesRequirement\n+                    .stream()\n+                    .sorted(Comparator.comparing(outputClauseRequirement -> outputClauseRequirement.text))\n+                    .map(outputClauseRequirement -> buildOutputClause(dTable, decisionRule, outputClauseRequirement.typeRef, outputClauseRequirement.text))\n+                    .forEach(dTable.getOutput()::add);\n+        }\n+    }\n+\n+    private List<ClauseRequirement> generateOutputClauseRequirements(final Definitions definitions, final QName typeRef, final String name) {\n+        if (typeRefMatchesBuiltInType(typeRef)) {\n+            return Collections.singletonList(new ClauseRequirement(name, typeRef));\n+        }\n+\n+        return definitions.getItemDefinition()\n+                .stream()\n+                .filter(typeRefIsCustom(typeRef))\n+                .findFirst()\n+                .map(this::generateOutputClauseRequirementsForFirstLevel)\n+                .orElse(Collections.emptyList());\n+    }\n+\n+    private List<ClauseRequirement> generateOutputClauseRequirementsForFirstLevel(final ItemDefinition itemDefinition) {\n+        return itemDefinition.getItemComponent()\n+                .stream()\n+                .map(this::definitionToClauseRequirementMapper)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private ClauseRequirement definitionToClauseRequirementMapper(final ItemDefinition itemDefinition) {\n+        final QName typeRef = itemDefinition.getTypeRef();\n+        final String name = itemDefinition.getName().getValue();\n+\n+        if (Objects.isNull(typeRef) || typeRefDoesNotMatchAnyDefinition(typeRef)) {\n+            return new ClauseRequirement(name, ANY.asQName());\n+        }\n+        return new ClauseRequirement(name, typeRef);\n+    }\n+\n+    private boolean typeRefDoesNotMatchAnyDefinition(final QName typeRef) {\n+        return !typeRefMatchesBuiltInType(typeRef) &&\n+                dmnGraphUtils.getDefinitions().getItemDefinition()\n+                        .stream()\n+                        .noneMatch(typeRefIsCustom(typeRef));\n+    }\n+\n+    private OutputClause buildOutputClause(final DecisionTable dtable, final DecisionRule decisionRule, final QName typeRef, final String text) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NjY4Mg=="}, "originalCommit": {"oid": "f5f1b2de9f855271427c21aeaea85907919bcc38"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjEzNTk4OnYy", "diffSide": "RIGHT", "path": "kie-wb-common-dmn/kie-wb-common-dmn-client/src/main/java/org/kie/workbench/common/dmn/client/editors/expressions/types/dtable/DecisionTableEditorDefinitionEnricher.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMTowMjoyM1rOGdsoGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMTowMjoyM1rOGdsoGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5MzA1MQ==", "bodyText": "This can be simplified:\nprivate boolean typeRefMatchesBuiltInType(final QName typeRef) {\n        return BuiltInTypeUtils.isBuiltInType(typeRef.getLocalPart());\n    }", "url": "https://github.com/kiegroup/kie-wb-common/pull/3316#discussion_r433793051", "createdAt": "2020-06-02T11:02:23Z", "author": {"login": "jomarko"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-client/src/main/java/org/kie/workbench/common/dmn/client/editors/expressions/types/dtable/DecisionTableEditorDefinitionEnricher.java", "diffHunk": "@@ -260,6 +325,21 @@ void addInputClauseRequirement(final ItemDefinition itemDefinition,\n         }\n     }\n \n+    private boolean typeRefMatchesBuiltInType(final QName typeRef) {\n+        for (BuiltInType bi : BuiltInType.values()) {\n+            for (String biName : bi.getNames()) {\n+                if (Objects.equals(biName, typeRef.getLocalPart())) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ca94527d61c0c4dcafa16fe673d2296c5629b66"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjE0MTQzOnYy", "diffSide": "RIGHT", "path": "kie-wb-common-dmn/kie-wb-common-dmn-client/src/main/java/org/kie/workbench/common/dmn/client/editors/expressions/types/dtable/DecisionTableEditorDefinitionEnricher.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMTowNDoyMFrOGdsrog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMTowNDoyMFrOGdsrog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5Mzk1NA==", "bodyText": "Could we please reimplement it using Objects.equals? That will not throw an NPE in case itemDef.GetName().getValue() or typeRef.getLocalPart() are null.\nprivate Predicate<ItemDefinition> typeRefIsCustom(final QName typeRef) {\n        return itemDef -> Objects.equals(itemDef.getName().getValue(), typeRef.getLocalPart());\n    }", "url": "https://github.com/kiegroup/kie-wb-common/pull/3316#discussion_r433793954", "createdAt": "2020-06-02T11:04:20Z", "author": {"login": "jomarko"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-client/src/main/java/org/kie/workbench/common/dmn/client/editors/expressions/types/dtable/DecisionTableEditorDefinitionEnricher.java", "diffHunk": "@@ -260,6 +325,21 @@ void addInputClauseRequirement(final ItemDefinition itemDefinition,\n         }\n     }\n \n+    private boolean typeRefMatchesBuiltInType(final QName typeRef) {\n+        for (BuiltInType bi : BuiltInType.values()) {\n+            for (String biName : bi.getNames()) {\n+                if (Objects.equals(biName, typeRef.getLocalPart())) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private Predicate<ItemDefinition> typeRefIsCustom(final QName typeRef) {\n+        return itemDef -> itemDef.getName().getValue().equals(typeRef.getLocalPart());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ca94527d61c0c4dcafa16fe673d2296c5629b66"}, "originalPosition": 224}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1301, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}