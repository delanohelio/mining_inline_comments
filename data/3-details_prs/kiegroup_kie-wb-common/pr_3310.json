{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxMDI5NDc0", "number": 3310, "title": "KOGITO-1553: [DMN Designer] Open a DMN file with an included model - Included Models tab", "bodyText": "This PR is part of an ensemble:\n#3310\nkiegroup/droolsjbpm-build-bootstrap#1323\nkiegroup/drools-wb#1375\nThis PR is not part of the ensemble, but is required. It have to be merged alone to generate the new Gwt Jsonix Schema Compiler build:\nkiegroup/gwt-jsonix-schema-compiler#8\nThe following JIRAS are included in this PR:\nKOGITO-1553: [DMN Designer] Open a DMN file with an included model - Included Models tab\nKOGITO-1776: [DMN Designer] Create a \"Load Projects From Client\" button\nKOGITO-1552: [DMN Designer] Open a DMN file with an included model - DRG Elements", "createdAt": "2020-05-20T21:29:27Z", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310", "merged": true, "mergeCommit": {"oid": "53cd6e2cd802d4661e3b233e1c198fdf34cc84ee"}, "closed": true, "closedAt": "2020-06-15T13:02:03Z", "author": {"login": "danielzhe"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcje7HMgBqjMzNjEwMTAwNjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcpVhFLgFqTQyNjU0OTk3OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "58592dfa6bc4406df73ec14b99ece445367de77e", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/58592dfa6bc4406df73ec14b99ece445367de77e", "committedDate": "2020-05-20T21:21:06Z", "message": "KOGITO-1553: [DMN Designer] Open a DMN file with an included model - Included Models tab\nKOGITO-1776: [DMN Designer] Create a \"Load Projects From Client\" button\nKOGITO-1552: [DMN Designer] Open a DMN file with an included model - DRG Elements"}, "afterCommit": {"oid": "12fd21075a8743079c629eb51ee636d3b5f148b7", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/12fd21075a8743079c629eb51ee636d3b5f148b7", "committedDate": "2020-05-21T14:54:55Z", "message": "KOGITO-1553: [DMN Designer] Open a DMN file with an included model - Included Models tab\nKOGITO-1776: [DMN Designer] Create a \"Load Projects From Client\" button\nKOGITO-1552: [DMN Designer] Open a DMN file with an included model - DRG Elements"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2Njg0MTc5", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#pullrequestreview-416684179", "createdAt": "2020-05-22T06:48:05Z", "commit": {"oid": "11e910989a5704d04297de8af28607ad4d39211c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwNjo0ODowNVrOGZMd4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwNjo0ODowNVrOGZMd4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA3MTg0Mw==", "bodyText": "Won't this always be false for DMN, since we now provide a map?", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r429071843", "createdAt": "2020-05-22T06:48:05Z", "author": {"login": "manstis"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-marshaller/src/main/resources/org/kie/workbench/common/dmn/webapp/kogito/marshaller/js/MainJs.js", "diffHunk": "@@ -86,21 +86,25 @@ MainJs = {\n         callback(toReturn);\n     },\n \n-    marshall: function (value, defaultNamespace, callback) {\n+    marshall: function (value, namespaces, callback) {\n+        var namespacesValues = {};\n+        if (namespaces instanceof String) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11e910989a5704d04297de8af28607ad4d39211c"}, "originalPosition": 7}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "11e910989a5704d04297de8af28607ad4d39211c", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/11e910989a5704d04297de8af28607ad4d39211c", "committedDate": "2020-05-22T00:14:20Z", "message": "Fixes an codestyle error and compatibility with Scesim."}, "afterCommit": {"oid": "724a7298be7390b832ab2783e5d72a672d9f99d7", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/724a7298be7390b832ab2783e5d72a672d9f99d7", "committedDate": "2020-05-22T19:01:14Z", "message": "Fixes an codestyle error and compatibility with Scesim."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3ODU1MTgx", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#pullrequestreview-417855181", "createdAt": "2020-05-25T19:36:32Z", "commit": {"oid": "385e8dc50ada79a8607d080d801e333cb1a27a4c"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3ODcwNjYx", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#pullrequestreview-417870661", "createdAt": "2020-05-25T20:42:56Z", "commit": {"oid": "385e8dc50ada79a8607d080d801e333cb1a27a4c"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQyMDo0Mjo1NlrOGaJZCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQyMDo0NDoyOVrOGaJaAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3MDAyNg==", "bodyText": "Should this block be removed? Considering: #3287.", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r430070026", "createdAt": "2020-05-25T20:42:56Z", "author": {"login": "karreiro"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerKogitoUnmarshaller.java", "diffHunk": "@@ -559,25 +567,27 @@ private Node getRequiredNode(final Map<String, Entry<JSITDRGElement, Node>> elem\n         final List<JSITDRGElement> importedDRGElements = dmnMarshallerImportsHelper.getImportedDRGElements(importDefinitions);\n \n         // Update IDs with the alias used in this file for the respective imports\n-        final Map<String, String> indexByUri = NameSpaceUtils.extractNamespacesKeyedByUri(dmnXml);\n-        updateIDsWithAlias(indexByUri, importedDRGElements);\n-\n-        return dmnShapes\n-                .stream()\n-                .map(shape -> {\n-                    final String dmnElementRef = getDmnElementRef(shape);\n-                    final Optional<JSITDRGElement> ref = getReference(importedDRGElements, dmnElementRef);\n-                    return ref.orElse(null);\n-                })\n-                .filter(Objects::nonNull)\n-                .collect(toList());\n+        //  final Map<String, String> indexByUri = NameSpaceUtils.extractNamespacesKeyedByUri(dmnXml);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "385e8dc50ada79a8607d080d801e333cb1a27a4c"}, "originalPosition": 684}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3MDI3NA==", "bodyText": "I believe we can remove the non-used updateIDsWithAlias method as well.", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r430070274", "createdAt": "2020-05-25T20:44:29Z", "author": {"login": "karreiro"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerKogitoUnmarshaller.java", "diffHunk": "@@ -559,25 +567,27 @@ private Node getRequiredNode(final Map<String, Entry<JSITDRGElement, Node>> elem\n         final List<JSITDRGElement> importedDRGElements = dmnMarshallerImportsHelper.getImportedDRGElements(importDefinitions);\n \n         // Update IDs with the alias used in this file for the respective imports\n-        final Map<String, String> indexByUri = NameSpaceUtils.extractNamespacesKeyedByUri(dmnXml);\n-        updateIDsWithAlias(indexByUri, importedDRGElements);\n-\n-        return dmnShapes\n-                .stream()\n-                .map(shape -> {\n-                    final String dmnElementRef = getDmnElementRef(shape);\n-                    final Optional<JSITDRGElement> ref = getReference(importedDRGElements, dmnElementRef);\n-                    return ref.orElse(null);\n-                })\n-                .filter(Objects::nonNull)\n-                .collect(toList());\n+        //  final Map<String, String> indexByUri = NameSpaceUtils.extractNamespacesKeyedByUri(dmnXml);\n+        // updateIDsWithAlias(indexByUri, importedDRGElements);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "385e8dc50ada79a8607d080d801e333cb1a27a4c"}, "originalPosition": 685}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5MDc1NTk5", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#pullrequestreview-419075599", "createdAt": "2020-05-27T10:50:38Z", "commit": {"oid": "385e8dc50ada79a8607d080d801e333cb1a27a4c"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMDo1MDozOFrOGbD4ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMTo0NTowMlrOGbFfvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAyODMyNQ==", "bodyText": "Could we please add javadoc, especially the path, is it relative, absolute?", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431028325", "createdAt": "2020-05-27T10:50:38Z", "author": {"login": "jomarko"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNIncludedNodeFactory.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n+\n+import org.kie.workbench.common.dmn.api.definition.HasVariable;\n+import org.kie.workbench.common.dmn.api.definition.model.DRGElement;\n+import org.kie.workbench.common.dmn.api.definition.model.InformationItemPrimary;\n+import org.kie.workbench.common.dmn.api.definition.model.IsInformationItem;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n+import org.kie.workbench.common.dmn.api.property.dmn.Name;\n+import org.kie.workbench.common.dmn.api.property.dmn.QName;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+\n+public class DMNIncludedNodeFactory {\n+\n+    DMNIncludedNode makeDMNIncludeNode(final String path,\n+                                       final IncludedModel includeModel,\n+                                       final DRGElement drgElement) {\n+        return new DMNIncludedNode(FileUtils.getFileName(path), drgElementWithNamespace(drgElement, includeModel));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "385e8dc50ada79a8607d080d801e333cb1a27a4c"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAzODc2Mw==", "bodyText": "Do I understand correctly all these methods works asynchronously?\nWhat is the difference between those suffixed \"Async\" and those not suffixed\nWhat is the reason somewhere we return Promise and somewhere we use Callback", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431038763", "createdAt": "2020-05-27T11:12:02Z", "author": {"login": "jomarko"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogito.java", "diffHunk": "@@ -15,12 +15,33 @@\n  */\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n+import java.util.List;\n+import java.util.Map;\n+\n+import elemental2.promise.Promise;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.marshalling.DMNMarshallerImportsHelper;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Metadata;\n \n public interface DMNMarshallerImportsHelperKogito extends DMNMarshallerImportsHelper<JSITImport, JSITDefinitions, JSITDRGElement, JSITItemDefinition> {\n \n+    Promise<Map<JSITImport, JSITDefinitions>> getImportDefinitionsAsync(final Metadata metadata,\n+                                                                        final List<JSITImport> imports);\n+\n+    void getImportedItemDefinitionsByNamespaceAsync(final String modelName,\n+                                                    final String namespace,\n+                                                    final ServiceCallback<List<ItemDefinition>> callback);\n+\n+    void loadNodesFromModels(final List<DMNIncludedModel> includedModels,\n+                             final ServiceCallback<List<DMNIncludedNode>> callback);\n+\n+    void loadModels(final ServiceCallback<List<IncludedModel>> callback);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "385e8dc50ada79a8607d080d801e333cb1a27a4c"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAzOTgzNA==", "bodyText": "Could you please explain combination of @dependent with @ApplicationScoped? For me the second one represnts singlotene per app while the first multiple instances available per app. I am not sure how we can combine them.", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431039834", "createdAt": "2020-05-27T11:14:22Z", "author": {"login": "jomarko"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogitoImpl.java", "diffHunk": "@@ -16,29 +16,253 @@\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n import java.io.InputStream;\n+import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.Vector;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n \n import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+import javax.xml.namespace.QName;\n \n+import elemental2.promise.IThenable;\n+import elemental2.promise.Promise;\n+import jsinterop.base.Js;\n import org.guvnor.common.services.project.model.WorkspaceProject;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNImportTypes;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.editors.included.PMMLDocumentMetadata;\n+import org.kie.workbench.common.dmn.api.graph.DMNDiagramUtils;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.services.DMNClientDiagramServiceImpl;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDMNElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDecision;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInformationItem;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInputData;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInvocable;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService;\n+import org.kie.workbench.common.stunner.core.client.service.ClientRuntimeError;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Diagram;\n import org.kie.workbench.common.stunner.core.diagram.Metadata;\n+import org.kie.workbench.common.stunner.core.graph.Graph;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+import org.kie.workbench.common.stunner.core.util.StringUtils;\n import org.uberfire.backend.vfs.Path;\n+import org.uberfire.client.promise.Promises;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+import static org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter.withNamespace;\n \n @ApplicationScoped\n+@Dependent", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "385e8dc50ada79a8607d080d801e333cb1a27a4c"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA0Nzg0Mg==", "bodyText": "Shouldn't we say the array size as we know it?\nreturn promises\n                    .all(fileLoadPromises.toArray(new Promise[fileLoadPromises.size()]))\n                    .then(v -> promises.resolve(otherDefinitions));", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431047842", "createdAt": "2020-05-27T11:30:23Z", "author": {"login": "jomarko"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogitoImpl.java", "diffHunk": "@@ -16,29 +16,253 @@\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n import java.io.InputStream;\n+import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.Vector;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n \n import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+import javax.xml.namespace.QName;\n \n+import elemental2.promise.IThenable;\n+import elemental2.promise.Promise;\n+import jsinterop.base.Js;\n import org.guvnor.common.services.project.model.WorkspaceProject;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNImportTypes;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.editors.included.PMMLDocumentMetadata;\n+import org.kie.workbench.common.dmn.api.graph.DMNDiagramUtils;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.services.DMNClientDiagramServiceImpl;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDMNElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDecision;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInformationItem;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInputData;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInvocable;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService;\n+import org.kie.workbench.common.stunner.core.client.service.ClientRuntimeError;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Diagram;\n import org.kie.workbench.common.stunner.core.diagram.Metadata;\n+import org.kie.workbench.common.stunner.core.graph.Graph;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+import org.kie.workbench.common.stunner.core.util.StringUtils;\n import org.uberfire.backend.vfs.Path;\n+import org.uberfire.client.promise.Promises;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+import static org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter.withNamespace;\n \n @ApplicationScoped\n+@Dependent\n public class DMNMarshallerImportsHelperKogitoImpl implements DMNMarshallerImportsHelperKogito {\n \n+    private final KogitoResourceContentService contentService;\n+    private final DMNClientDiagramServiceImpl diagramService;\n+    private final Promises promises;\n+    private final DMNDiagramUtils diagramUtils;\n+    private final DMNIncludedNodeFactory includedModelFactory;\n+\n+    private static final Logger LOGGER = Logger.getLogger(DMNMarshallerImportsHelperKogitoImpl.class.getName());\n+    private static final String DMN_FILES_PATTERN = \"**/*.dmn\";\n+\n+    @Inject\n+    public DMNMarshallerImportsHelperKogitoImpl(final KogitoResourceContentService contentService,\n+                                                final DMNClientDiagramServiceImpl diagramService,\n+                                                final Promises promises,\n+                                                final DMNDiagramUtils diagramUtils,\n+                                                final DMNIncludedNodeFactory includedModelFactory) {\n+        this.contentService = contentService;\n+        this.diagramService = diagramService;\n+        this.promises = promises;\n+        this.diagramUtils = diagramUtils;\n+        this.includedModelFactory = includedModelFactory;\n+    }\n+\n+    @Override\n+    public Promise<Map<JSITImport, JSITDefinitions>> getImportDefinitionsAsync(final Metadata metadata,\n+                                                                               final List<JSITImport> imports) {\n+        if (!imports.isEmpty()) {\n+            return loadDMNDefinitions().then(otherDefinitions -> {\n+                final Map<JSITImport, JSITDefinitions> importDefinitions = new HashMap<>();\n+                for (int i = 0; i < otherDefinitions.size(); i++) {\n+                    final JSITDefinitions def = Js.uncheckedCast(otherDefinitions.get(i));\n+                    findImportByDefinitions(def, imports).ifPresent(anImport -> {\n+                        final JSITImport foundImported = Js.uncheckedCast(anImport);\n+                        importDefinitions.put(foundImported, def);\n+                    });\n+                }\n+                return promises.resolve(importDefinitions);\n+            });\n+        }\n+        return promises.resolve(new HashMap<>());\n+    }\n+\n+    Promise<List<JSITDefinitions>> loadDMNDefinitions() {\n+        final List<JSITDefinitions> otherDefinitions = new Vector<>();\n+        return contentService.getFilteredItems(DMN_FILES_PATTERN).then(list -> {\n+            final List<Promise<JSITDefinitions>> fileLoadPromises = new ArrayList<>();\n+            for (final String file : list) {\n+                final Promise<JSITDefinitions> promise = loadDefinitionFromFile(file, otherDefinitions);\n+                fileLoadPromises.add(promise);\n+            }\n+            return promises.all(fileLoadPromises.toArray(new Promise[]{})).then(v -> promises.resolve(otherDefinitions));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "385e8dc50ada79a8607d080d801e333cb1a27a4c"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1MjQ5OQ==", "bodyText": "Here we can use .orElse(Collections.emptyList()) as we are not manipulating with nodes afterwards.", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431052499", "createdAt": "2020-05-27T11:40:30Z", "author": {"login": "jomarko"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogitoImpl.java", "diffHunk": "@@ -16,29 +16,253 @@\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n import java.io.InputStream;\n+import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.Vector;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n \n import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+import javax.xml.namespace.QName;\n \n+import elemental2.promise.IThenable;\n+import elemental2.promise.Promise;\n+import jsinterop.base.Js;\n import org.guvnor.common.services.project.model.WorkspaceProject;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNImportTypes;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.editors.included.PMMLDocumentMetadata;\n+import org.kie.workbench.common.dmn.api.graph.DMNDiagramUtils;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.services.DMNClientDiagramServiceImpl;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDMNElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDecision;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInformationItem;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInputData;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInvocable;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService;\n+import org.kie.workbench.common.stunner.core.client.service.ClientRuntimeError;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Diagram;\n import org.kie.workbench.common.stunner.core.diagram.Metadata;\n+import org.kie.workbench.common.stunner.core.graph.Graph;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+import org.kie.workbench.common.stunner.core.util.StringUtils;\n import org.uberfire.backend.vfs.Path;\n+import org.uberfire.client.promise.Promises;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+import static org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter.withNamespace;\n \n @ApplicationScoped\n+@Dependent\n public class DMNMarshallerImportsHelperKogitoImpl implements DMNMarshallerImportsHelperKogito {\n \n+    private final KogitoResourceContentService contentService;\n+    private final DMNClientDiagramServiceImpl diagramService;\n+    private final Promises promises;\n+    private final DMNDiagramUtils diagramUtils;\n+    private final DMNIncludedNodeFactory includedModelFactory;\n+\n+    private static final Logger LOGGER = Logger.getLogger(DMNMarshallerImportsHelperKogitoImpl.class.getName());\n+    private static final String DMN_FILES_PATTERN = \"**/*.dmn\";\n+\n+    @Inject\n+    public DMNMarshallerImportsHelperKogitoImpl(final KogitoResourceContentService contentService,\n+                                                final DMNClientDiagramServiceImpl diagramService,\n+                                                final Promises promises,\n+                                                final DMNDiagramUtils diagramUtils,\n+                                                final DMNIncludedNodeFactory includedModelFactory) {\n+        this.contentService = contentService;\n+        this.diagramService = diagramService;\n+        this.promises = promises;\n+        this.diagramUtils = diagramUtils;\n+        this.includedModelFactory = includedModelFactory;\n+    }\n+\n+    @Override\n+    public Promise<Map<JSITImport, JSITDefinitions>> getImportDefinitionsAsync(final Metadata metadata,\n+                                                                               final List<JSITImport> imports) {\n+        if (!imports.isEmpty()) {\n+            return loadDMNDefinitions().then(otherDefinitions -> {\n+                final Map<JSITImport, JSITDefinitions> importDefinitions = new HashMap<>();\n+                for (int i = 0; i < otherDefinitions.size(); i++) {\n+                    final JSITDefinitions def = Js.uncheckedCast(otherDefinitions.get(i));\n+                    findImportByDefinitions(def, imports).ifPresent(anImport -> {\n+                        final JSITImport foundImported = Js.uncheckedCast(anImport);\n+                        importDefinitions.put(foundImported, def);\n+                    });\n+                }\n+                return promises.resolve(importDefinitions);\n+            });\n+        }\n+        return promises.resolve(new HashMap<>());\n+    }\n+\n+    Promise<List<JSITDefinitions>> loadDMNDefinitions() {\n+        final List<JSITDefinitions> otherDefinitions = new Vector<>();\n+        return contentService.getFilteredItems(DMN_FILES_PATTERN).then(list -> {\n+            final List<Promise<JSITDefinitions>> fileLoadPromises = new ArrayList<>();\n+            for (final String file : list) {\n+                final Promise<JSITDefinitions> promise = loadDefinitionFromFile(file, otherDefinitions);\n+                fileLoadPromises.add(promise);\n+            }\n+            return promises.all(fileLoadPromises.toArray(new Promise[]{})).then(v -> promises.resolve(otherDefinitions));\n+        });\n+    }\n+\n+    @Override\n+    public void loadNodesFromModels(final List<DMNIncludedModel> includedModels,\n+                                    final ServiceCallback<List<DMNIncludedNode>> callback) {\n+\n+        final List<DMNIncludedNode> result = new Vector<>();\n+        final List<Promise> fileLoadPromises = new ArrayList<>();\n+        for (final DMNIncludedModel model : includedModels) {\n+            final String path = model.getPath();\n+            final Promise promise = contentService.loadFile(path).then(content -> {\n+                                                                           diagramService.transform(content, new ServiceCallback<Diagram>() {\n+                                                                               @Override\n+                                                                               public void onSuccess(final Diagram item) {\n+                                                                                   final Optional<DMNIncludedModel> diagramImport = getDiagramImport(item, includedModels);\n+                                                                                   final List<DMNIncludedNode> nodes = diagramImport\n+                                                                                           .map(dmn -> diagramUtils\n+                                                                                                   .getDRGElements(item)\n+                                                                                                   .stream()\n+                                                                                                   .map(node -> includedModelFactory.makeDMNIncludeNode(path, dmn, node))\n+                                                                                                   .collect(Collectors.toList()))\n+                                                                                           .orElse(new ArrayList<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "385e8dc50ada79a8607d080d801e333cb1a27a4c"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1MjkwNg==", "bodyText": "Similar question as above . shouldn't we leverage known size of fileLoadPromises during new array creation?", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431052906", "createdAt": "2020-05-27T11:41:23Z", "author": {"login": "jomarko"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogitoImpl.java", "diffHunk": "@@ -16,29 +16,253 @@\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n import java.io.InputStream;\n+import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.Vector;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n \n import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+import javax.xml.namespace.QName;\n \n+import elemental2.promise.IThenable;\n+import elemental2.promise.Promise;\n+import jsinterop.base.Js;\n import org.guvnor.common.services.project.model.WorkspaceProject;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNImportTypes;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.editors.included.PMMLDocumentMetadata;\n+import org.kie.workbench.common.dmn.api.graph.DMNDiagramUtils;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.services.DMNClientDiagramServiceImpl;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDMNElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDecision;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInformationItem;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInputData;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInvocable;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService;\n+import org.kie.workbench.common.stunner.core.client.service.ClientRuntimeError;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Diagram;\n import org.kie.workbench.common.stunner.core.diagram.Metadata;\n+import org.kie.workbench.common.stunner.core.graph.Graph;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+import org.kie.workbench.common.stunner.core.util.StringUtils;\n import org.uberfire.backend.vfs.Path;\n+import org.uberfire.client.promise.Promises;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+import static org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter.withNamespace;\n \n @ApplicationScoped\n+@Dependent\n public class DMNMarshallerImportsHelperKogitoImpl implements DMNMarshallerImportsHelperKogito {\n \n+    private final KogitoResourceContentService contentService;\n+    private final DMNClientDiagramServiceImpl diagramService;\n+    private final Promises promises;\n+    private final DMNDiagramUtils diagramUtils;\n+    private final DMNIncludedNodeFactory includedModelFactory;\n+\n+    private static final Logger LOGGER = Logger.getLogger(DMNMarshallerImportsHelperKogitoImpl.class.getName());\n+    private static final String DMN_FILES_PATTERN = \"**/*.dmn\";\n+\n+    @Inject\n+    public DMNMarshallerImportsHelperKogitoImpl(final KogitoResourceContentService contentService,\n+                                                final DMNClientDiagramServiceImpl diagramService,\n+                                                final Promises promises,\n+                                                final DMNDiagramUtils diagramUtils,\n+                                                final DMNIncludedNodeFactory includedModelFactory) {\n+        this.contentService = contentService;\n+        this.diagramService = diagramService;\n+        this.promises = promises;\n+        this.diagramUtils = diagramUtils;\n+        this.includedModelFactory = includedModelFactory;\n+    }\n+\n+    @Override\n+    public Promise<Map<JSITImport, JSITDefinitions>> getImportDefinitionsAsync(final Metadata metadata,\n+                                                                               final List<JSITImport> imports) {\n+        if (!imports.isEmpty()) {\n+            return loadDMNDefinitions().then(otherDefinitions -> {\n+                final Map<JSITImport, JSITDefinitions> importDefinitions = new HashMap<>();\n+                for (int i = 0; i < otherDefinitions.size(); i++) {\n+                    final JSITDefinitions def = Js.uncheckedCast(otherDefinitions.get(i));\n+                    findImportByDefinitions(def, imports).ifPresent(anImport -> {\n+                        final JSITImport foundImported = Js.uncheckedCast(anImport);\n+                        importDefinitions.put(foundImported, def);\n+                    });\n+                }\n+                return promises.resolve(importDefinitions);\n+            });\n+        }\n+        return promises.resolve(new HashMap<>());\n+    }\n+\n+    Promise<List<JSITDefinitions>> loadDMNDefinitions() {\n+        final List<JSITDefinitions> otherDefinitions = new Vector<>();\n+        return contentService.getFilteredItems(DMN_FILES_PATTERN).then(list -> {\n+            final List<Promise<JSITDefinitions>> fileLoadPromises = new ArrayList<>();\n+            for (final String file : list) {\n+                final Promise<JSITDefinitions> promise = loadDefinitionFromFile(file, otherDefinitions);\n+                fileLoadPromises.add(promise);\n+            }\n+            return promises.all(fileLoadPromises.toArray(new Promise[]{})).then(v -> promises.resolve(otherDefinitions));\n+        });\n+    }\n+\n+    @Override\n+    public void loadNodesFromModels(final List<DMNIncludedModel> includedModels,\n+                                    final ServiceCallback<List<DMNIncludedNode>> callback) {\n+\n+        final List<DMNIncludedNode> result = new Vector<>();\n+        final List<Promise> fileLoadPromises = new ArrayList<>();\n+        for (final DMNIncludedModel model : includedModels) {\n+            final String path = model.getPath();\n+            final Promise promise = contentService.loadFile(path).then(content -> {\n+                                                                           diagramService.transform(content, new ServiceCallback<Diagram>() {\n+                                                                               @Override\n+                                                                               public void onSuccess(final Diagram item) {\n+                                                                                   final Optional<DMNIncludedModel> diagramImport = getDiagramImport(item, includedModels);\n+                                                                                   final List<DMNIncludedNode> nodes = diagramImport\n+                                                                                           .map(dmn -> diagramUtils\n+                                                                                                   .getDRGElements(item)\n+                                                                                                   .stream()\n+                                                                                                   .map(node -> includedModelFactory.makeDMNIncludeNode(path, dmn, node))\n+                                                                                                   .collect(Collectors.toList()))\n+                                                                                           .orElse(new ArrayList<>());\n+\n+                                                                                   result.addAll(nodes);\n+                                                                               }\n+\n+                                                                               @Override\n+                                                                               public void onError(final ClientRuntimeError error) {\n+                                                                                   LOGGER.log(Level.SEVERE, error.getMessage());\n+                                                                               }\n+                                                                           });\n+                                                                           return promises.resolve();\n+                                                                       }\n+            );\n+            fileLoadPromises.add(promise);\n+        }\n+\n+        promises.all(fileLoadPromises.toArray(new Promise[]{})).then(p -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "385e8dc50ada79a8607d080d801e333cb1a27a4c"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1MzczOQ==", "bodyText": "Could we mentions this aslo in javadoc of the added public API?", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431053739", "createdAt": "2020-05-27T11:42:58Z", "author": {"login": "jomarko"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogitoImpl.java", "diffHunk": "@@ -16,29 +16,253 @@\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n import java.io.InputStream;\n+import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.Vector;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n \n import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+import javax.xml.namespace.QName;\n \n+import elemental2.promise.IThenable;\n+import elemental2.promise.Promise;\n+import jsinterop.base.Js;\n import org.guvnor.common.services.project.model.WorkspaceProject;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNImportTypes;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.editors.included.PMMLDocumentMetadata;\n+import org.kie.workbench.common.dmn.api.graph.DMNDiagramUtils;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.services.DMNClientDiagramServiceImpl;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDMNElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDecision;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInformationItem;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInputData;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInvocable;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService;\n+import org.kie.workbench.common.stunner.core.client.service.ClientRuntimeError;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Diagram;\n import org.kie.workbench.common.stunner.core.diagram.Metadata;\n+import org.kie.workbench.common.stunner.core.graph.Graph;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+import org.kie.workbench.common.stunner.core.util.StringUtils;\n import org.uberfire.backend.vfs.Path;\n+import org.uberfire.client.promise.Promises;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+import static org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter.withNamespace;\n \n @ApplicationScoped\n+@Dependent\n public class DMNMarshallerImportsHelperKogitoImpl implements DMNMarshallerImportsHelperKogito {\n \n+    private final KogitoResourceContentService contentService;\n+    private final DMNClientDiagramServiceImpl diagramService;\n+    private final Promises promises;\n+    private final DMNDiagramUtils diagramUtils;\n+    private final DMNIncludedNodeFactory includedModelFactory;\n+\n+    private static final Logger LOGGER = Logger.getLogger(DMNMarshallerImportsHelperKogitoImpl.class.getName());\n+    private static final String DMN_FILES_PATTERN = \"**/*.dmn\";\n+\n+    @Inject\n+    public DMNMarshallerImportsHelperKogitoImpl(final KogitoResourceContentService contentService,\n+                                                final DMNClientDiagramServiceImpl diagramService,\n+                                                final Promises promises,\n+                                                final DMNDiagramUtils diagramUtils,\n+                                                final DMNIncludedNodeFactory includedModelFactory) {\n+        this.contentService = contentService;\n+        this.diagramService = diagramService;\n+        this.promises = promises;\n+        this.diagramUtils = diagramUtils;\n+        this.includedModelFactory = includedModelFactory;\n+    }\n+\n+    @Override\n+    public Promise<Map<JSITImport, JSITDefinitions>> getImportDefinitionsAsync(final Metadata metadata,\n+                                                                               final List<JSITImport> imports) {\n+        if (!imports.isEmpty()) {\n+            return loadDMNDefinitions().then(otherDefinitions -> {\n+                final Map<JSITImport, JSITDefinitions> importDefinitions = new HashMap<>();\n+                for (int i = 0; i < otherDefinitions.size(); i++) {\n+                    final JSITDefinitions def = Js.uncheckedCast(otherDefinitions.get(i));\n+                    findImportByDefinitions(def, imports).ifPresent(anImport -> {\n+                        final JSITImport foundImported = Js.uncheckedCast(anImport);\n+                        importDefinitions.put(foundImported, def);\n+                    });\n+                }\n+                return promises.resolve(importDefinitions);\n+            });\n+        }\n+        return promises.resolve(new HashMap<>());\n+    }\n+\n+    Promise<List<JSITDefinitions>> loadDMNDefinitions() {\n+        final List<JSITDefinitions> otherDefinitions = new Vector<>();\n+        return contentService.getFilteredItems(DMN_FILES_PATTERN).then(list -> {\n+            final List<Promise<JSITDefinitions>> fileLoadPromises = new ArrayList<>();\n+            for (final String file : list) {\n+                final Promise<JSITDefinitions> promise = loadDefinitionFromFile(file, otherDefinitions);\n+                fileLoadPromises.add(promise);\n+            }\n+            return promises.all(fileLoadPromises.toArray(new Promise[]{})).then(v -> promises.resolve(otherDefinitions));\n+        });\n+    }\n+\n+    @Override\n+    public void loadNodesFromModels(final List<DMNIncludedModel> includedModels,\n+                                    final ServiceCallback<List<DMNIncludedNode>> callback) {\n+\n+        final List<DMNIncludedNode> result = new Vector<>();\n+        final List<Promise> fileLoadPromises = new ArrayList<>();\n+        for (final DMNIncludedModel model : includedModels) {\n+            final String path = model.getPath();\n+            final Promise promise = contentService.loadFile(path).then(content -> {\n+                                                                           diagramService.transform(content, new ServiceCallback<Diagram>() {\n+                                                                               @Override\n+                                                                               public void onSuccess(final Diagram item) {\n+                                                                                   final Optional<DMNIncludedModel> diagramImport = getDiagramImport(item, includedModels);\n+                                                                                   final List<DMNIncludedNode> nodes = diagramImport\n+                                                                                           .map(dmn -> diagramUtils\n+                                                                                                   .getDRGElements(item)\n+                                                                                                   .stream()\n+                                                                                                   .map(node -> includedModelFactory.makeDMNIncludeNode(path, dmn, node))\n+                                                                                                   .collect(Collectors.toList()))\n+                                                                                           .orElse(new ArrayList<>());\n+\n+                                                                                   result.addAll(nodes);\n+                                                                               }\n+\n+                                                                               @Override\n+                                                                               public void onError(final ClientRuntimeError error) {\n+                                                                                   LOGGER.log(Level.SEVERE, error.getMessage());\n+                                                                               }\n+                                                                           });\n+                                                                           return promises.resolve();\n+                                                                       }\n+            );\n+            fileLoadPromises.add(promise);\n+        }\n+\n+        promises.all(fileLoadPromises.toArray(new Promise[]{})).then(p -> {\n+            callback.onSuccess(result);\n+            return promises.resolve();\n+        });\n+    }\n+\n+    @Override\n+    public void loadModels(final ServiceCallback<List<IncludedModel>> callback) {\n+\n+        final List<IncludedModel> models = new Vector<>();\n+        contentService.getFilteredItems(DMN_FILES_PATTERN).then(items -> {\n+            final List<Promise> fileLoadPromises = new ArrayList<>();\n+\n+            for (final String file : items) {\n+                final Promise<Object> fileLoad = contentService.loadFile(file).then(fileContent -> {\n+                    diagramService.transform(fileContent, new ServiceCallback<Diagram>() {\n+                        @Override\n+                        public void onSuccess(final Diagram item) {\n+                            final String modelPackage = \"\";\n+                            final Diagram<Graph, Metadata> diagram = (Diagram<Graph, Metadata>) item;\n+                            final String namespace = diagramUtils.getNamespace(diagram);\n+                            final String importType = DMNImportTypes.DMN.getDefaultNamespace();\n+                            final int drgElementCount = diagramUtils.getDRGElements(diagram).size();\n+                            final int itemDefinitionCount = diagramUtils.getDefinitions(diagram).getItemDefinition().size();\n+                            // We get files only from the same folder, so doesn't need relative or full path.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "385e8dc50ada79a8607d080d801e333cb1a27a4c"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1NDc4MQ==", "bodyText": "Array instantiation question as above.", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431054781", "createdAt": "2020-05-27T11:45:02Z", "author": {"login": "jomarko"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogitoImpl.java", "diffHunk": "@@ -16,29 +16,253 @@\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n import java.io.InputStream;\n+import java.util.ArrayList;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.Vector;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n \n import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.Dependent;\n+import javax.inject.Inject;\n+import javax.xml.namespace.QName;\n \n+import elemental2.promise.IThenable;\n+import elemental2.promise.Promise;\n+import jsinterop.base.Js;\n import org.guvnor.common.services.project.model.WorkspaceProject;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNImportTypes;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.editors.included.PMMLDocumentMetadata;\n+import org.kie.workbench.common.dmn.api.graph.DMNDiagramUtils;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.services.DMNClientDiagramServiceImpl;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDMNElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDecision;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInformationItem;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInputData;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInvocable;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService;\n+import org.kie.workbench.common.stunner.core.client.service.ClientRuntimeError;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Diagram;\n import org.kie.workbench.common.stunner.core.diagram.Metadata;\n+import org.kie.workbench.common.stunner.core.graph.Graph;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+import org.kie.workbench.common.stunner.core.util.StringUtils;\n import org.uberfire.backend.vfs.Path;\n+import org.uberfire.client.promise.Promises;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+import static org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter.withNamespace;\n \n @ApplicationScoped\n+@Dependent\n public class DMNMarshallerImportsHelperKogitoImpl implements DMNMarshallerImportsHelperKogito {\n \n+    private final KogitoResourceContentService contentService;\n+    private final DMNClientDiagramServiceImpl diagramService;\n+    private final Promises promises;\n+    private final DMNDiagramUtils diagramUtils;\n+    private final DMNIncludedNodeFactory includedModelFactory;\n+\n+    private static final Logger LOGGER = Logger.getLogger(DMNMarshallerImportsHelperKogitoImpl.class.getName());\n+    private static final String DMN_FILES_PATTERN = \"**/*.dmn\";\n+\n+    @Inject\n+    public DMNMarshallerImportsHelperKogitoImpl(final KogitoResourceContentService contentService,\n+                                                final DMNClientDiagramServiceImpl diagramService,\n+                                                final Promises promises,\n+                                                final DMNDiagramUtils diagramUtils,\n+                                                final DMNIncludedNodeFactory includedModelFactory) {\n+        this.contentService = contentService;\n+        this.diagramService = diagramService;\n+        this.promises = promises;\n+        this.diagramUtils = diagramUtils;\n+        this.includedModelFactory = includedModelFactory;\n+    }\n+\n+    @Override\n+    public Promise<Map<JSITImport, JSITDefinitions>> getImportDefinitionsAsync(final Metadata metadata,\n+                                                                               final List<JSITImport> imports) {\n+        if (!imports.isEmpty()) {\n+            return loadDMNDefinitions().then(otherDefinitions -> {\n+                final Map<JSITImport, JSITDefinitions> importDefinitions = new HashMap<>();\n+                for (int i = 0; i < otherDefinitions.size(); i++) {\n+                    final JSITDefinitions def = Js.uncheckedCast(otherDefinitions.get(i));\n+                    findImportByDefinitions(def, imports).ifPresent(anImport -> {\n+                        final JSITImport foundImported = Js.uncheckedCast(anImport);\n+                        importDefinitions.put(foundImported, def);\n+                    });\n+                }\n+                return promises.resolve(importDefinitions);\n+            });\n+        }\n+        return promises.resolve(new HashMap<>());\n+    }\n+\n+    Promise<List<JSITDefinitions>> loadDMNDefinitions() {\n+        final List<JSITDefinitions> otherDefinitions = new Vector<>();\n+        return contentService.getFilteredItems(DMN_FILES_PATTERN).then(list -> {\n+            final List<Promise<JSITDefinitions>> fileLoadPromises = new ArrayList<>();\n+            for (final String file : list) {\n+                final Promise<JSITDefinitions> promise = loadDefinitionFromFile(file, otherDefinitions);\n+                fileLoadPromises.add(promise);\n+            }\n+            return promises.all(fileLoadPromises.toArray(new Promise[]{})).then(v -> promises.resolve(otherDefinitions));\n+        });\n+    }\n+\n+    @Override\n+    public void loadNodesFromModels(final List<DMNIncludedModel> includedModels,\n+                                    final ServiceCallback<List<DMNIncludedNode>> callback) {\n+\n+        final List<DMNIncludedNode> result = new Vector<>();\n+        final List<Promise> fileLoadPromises = new ArrayList<>();\n+        for (final DMNIncludedModel model : includedModels) {\n+            final String path = model.getPath();\n+            final Promise promise = contentService.loadFile(path).then(content -> {\n+                                                                           diagramService.transform(content, new ServiceCallback<Diagram>() {\n+                                                                               @Override\n+                                                                               public void onSuccess(final Diagram item) {\n+                                                                                   final Optional<DMNIncludedModel> diagramImport = getDiagramImport(item, includedModels);\n+                                                                                   final List<DMNIncludedNode> nodes = diagramImport\n+                                                                                           .map(dmn -> diagramUtils\n+                                                                                                   .getDRGElements(item)\n+                                                                                                   .stream()\n+                                                                                                   .map(node -> includedModelFactory.makeDMNIncludeNode(path, dmn, node))\n+                                                                                                   .collect(Collectors.toList()))\n+                                                                                           .orElse(new ArrayList<>());\n+\n+                                                                                   result.addAll(nodes);\n+                                                                               }\n+\n+                                                                               @Override\n+                                                                               public void onError(final ClientRuntimeError error) {\n+                                                                                   LOGGER.log(Level.SEVERE, error.getMessage());\n+                                                                               }\n+                                                                           });\n+                                                                           return promises.resolve();\n+                                                                       }\n+            );\n+            fileLoadPromises.add(promise);\n+        }\n+\n+        promises.all(fileLoadPromises.toArray(new Promise[]{})).then(p -> {\n+            callback.onSuccess(result);\n+            return promises.resolve();\n+        });\n+    }\n+\n+    @Override\n+    public void loadModels(final ServiceCallback<List<IncludedModel>> callback) {\n+\n+        final List<IncludedModel> models = new Vector<>();\n+        contentService.getFilteredItems(DMN_FILES_PATTERN).then(items -> {\n+            final List<Promise> fileLoadPromises = new ArrayList<>();\n+\n+            for (final String file : items) {\n+                final Promise<Object> fileLoad = contentService.loadFile(file).then(fileContent -> {\n+                    diagramService.transform(fileContent, new ServiceCallback<Diagram>() {\n+                        @Override\n+                        public void onSuccess(final Diagram item) {\n+                            final String modelPackage = \"\";\n+                            final Diagram<Graph, Metadata> diagram = (Diagram<Graph, Metadata>) item;\n+                            final String namespace = diagramUtils.getNamespace(diagram);\n+                            final String importType = DMNImportTypes.DMN.getDefaultNamespace();\n+                            final int drgElementCount = diagramUtils.getDRGElements(diagram).size();\n+                            final int itemDefinitionCount = diagramUtils.getDefinitions(diagram).getItemDefinition().size();\n+                            // We get files only from the same folder, so doesn't need relative or full path.\n+                            final String filename = FileUtils.getFileName(file);\n+                            models.add(new DMNIncludedModel(filename,\n+                                                            modelPackage,\n+                                                            filename,\n+                                                            namespace,\n+                                                            importType,\n+                                                            drgElementCount,\n+                                                            itemDefinitionCount));\n+                        }\n+\n+                        @Override\n+                        public void onError(final ClientRuntimeError error) {\n+                            LOGGER.log(Level.SEVERE, error.getMessage());\n+                        }\n+                    });\n+                    return promises.resolve();\n+                });\n+\n+                fileLoadPromises.add(fileLoad);\n+            }\n+\n+            return promises.all(fileLoadPromises.toArray(new Promise[]{})).then(v -> promises.resolve());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "385e8dc50ada79a8607d080d801e333cb1a27a4c"}, "originalPosition": 195}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NDg1NDky", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#pullrequestreview-419485492", "createdAt": "2020-05-27T18:09:42Z", "commit": {"oid": "385e8dc50ada79a8607d080d801e333cb1a27a4c"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxODowOTo0MlrOGbXMtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxODoyNDoxMlrOGbXsug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0NDgyMA==", "bodyText": "Is this change because we now parse real namespaces form given file?", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431344820", "createdAt": "2020-05-27T18:09:42Z", "author": {"login": "jomarko"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-marshaller/src/main/resources/org/kie/workbench/common/dmn/webapp/kogito/marshaller/js/MainJs.js", "diffHunk": "@@ -86,21 +86,13 @@ MainJs = {\n         callback(toReturn);\n     },\n \n-    marshall: function (value, defaultNamespace, callback) {\n+    marshall: function (value, namespacesValues, callback) {\n         // Create Jsonix context\n-        var namespaces = {};\n-        namespaces[defaultNamespace] = \"\";\n-        namespaces[\"http://www.omg.org/spec/DMN/20180521/MODEL/\"] = \"dmn\";\n-        namespaces[\"http://www.omg.org/spec/DMN/20180521/DI/\"] = \"di\";\n-        namespaces[\"http://www.drools.org/kie/dmn/1.2\"] = \"kie\";\n-        namespaces[\"http://www.omg.org/spec/DMN/20180521/DMNDI/\"] = \"dmndi\";\n-        namespaces[\"http://www.omg.org/spec/DMN/20180521/DC/\"] = \"dc\";\n-        namespaces[\"http://www.omg.org/spec/DMN/20180521/FEEL/\"] = \"feel\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "385e8dc50ada79a8607d080d801e333cb1a27a4c"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0NjYwNA==", "bodyText": "Could we please rename to sucessCallback or something more explicitely saying that is callback in case no issues during computation happened?", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431346604", "createdAt": "2020-05-27T18:12:50Z", "author": {"login": "jomarko"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-testing/src/main/java/org/kie/workbench/common/dmn/showcase/client/alternatives/KogitoResourceContentService.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.workbench.common.dmn.showcase.client.alternatives;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.enterprise.inject.Alternative;\n+import javax.inject.Inject;\n+\n+import elemental2.promise.Promise;\n+import org.appformer.kogito.bridge.client.resource.ResourceContentService;\n+import org.jboss.errai.common.client.api.ErrorCallback;\n+import org.jboss.errai.common.client.api.RemoteCallback;\n+import org.uberfire.client.promise.Promises;\n+\n+@Alternative\n+public class KogitoResourceContentService extends org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService {\n+\n+    final static String BASE_MODEL = \"Base Model.dmn\";\n+    final static String MODEL_WITH_IMPORTS = \"Model With Imports.dmn\";\n+\n+    @Inject\n+    public KogitoResourceContentService(final ResourceContentService resourceContentService,\n+                                        final Promises promises) {\n+        super(resourceContentService, promises);\n+    }\n+\n+    @Override\n+    public void getFilteredItems(final String pattern,\n+                                 final RemoteCallback<List<String>> callback,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "385e8dc50ada79a8607d080d801e333cb1a27a4c"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0ODA1Mw==", "bodyText": "From my point of view in the default else branches it is more 'not supported' or 'illegal state'. because new comer can add his file into DMNClientModels class. In such case message about not found can be confusing. What do you think?", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431348053", "createdAt": "2020-05-27T18:15:10Z", "author": {"login": "jomarko"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-testing/src/main/java/org/kie/workbench/common/dmn/showcase/client/alternatives/KogitoResourceContentService.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.workbench.common.dmn.showcase.client.alternatives;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.enterprise.inject.Alternative;\n+import javax.inject.Inject;\n+\n+import elemental2.promise.Promise;\n+import org.appformer.kogito.bridge.client.resource.ResourceContentService;\n+import org.jboss.errai.common.client.api.ErrorCallback;\n+import org.jboss.errai.common.client.api.RemoteCallback;\n+import org.uberfire.client.promise.Promises;\n+\n+@Alternative\n+public class KogitoResourceContentService extends org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService {\n+\n+    final static String BASE_MODEL = \"Base Model.dmn\";\n+    final static String MODEL_WITH_IMPORTS = \"Model With Imports.dmn\";\n+\n+    @Inject\n+    public KogitoResourceContentService(final ResourceContentService resourceContentService,\n+                                        final Promises promises) {\n+        super(resourceContentService, promises);\n+    }\n+\n+    @Override\n+    public void getFilteredItems(final String pattern,\n+                                 final RemoteCallback<List<String>> callback,\n+                                 final ErrorCallback<Object> errorCallback) {\n+\n+        callback.callback(Arrays.asList(BASE_MODEL, MODEL_WITH_IMPORTS));\n+    }\n+\n+    @Override\n+    public void loadFile(final String fileUri,\n+                         final RemoteCallback<String> callback,\n+                         final ErrorCallback<Object> errorCallback) {\n+        if (BASE_MODEL.equals(fileUri)) {\n+            callback.callback(DMNClientModels.BASE_FILE);\n+        } else if (MODEL_WITH_IMPORTS.equals(fileUri)) {\n+            callback.callback(DMNClientModels.MODEL_WITH_IMPORTS);\n+        } else {\n+            errorCallback.error(\"File '\" + fileUri + \"'not found\", new Throwable(\"File not found: '\" + fileUri + \"'\"));\n+        }\n+    }\n+\n+    @Override\n+    public Promise<String[]> getFilteredItems(final String pattern) {\n+        return Promise.resolve(new String[]{BASE_MODEL, MODEL_WITH_IMPORTS});\n+    }\n+\n+    @Override\n+    public Promise<String> loadFile(final String fileUri) {\n+        if (BASE_MODEL.equals(fileUri)) {\n+            return Promise.resolve(DMNClientModels.BASE_FILE);\n+        } else if (MODEL_WITH_IMPORTS.equals(fileUri)) {\n+            return Promise.resolve(DMNClientModels.MODEL_WITH_IMPORTS);\n+        } else {\n+            return Promise.resolve(\"NOT FOUND!\");\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "385e8dc50ada79a8607d080d801e333cb1a27a4c"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0OTc5Ng==", "bodyText": "Could you please explain what effect has this 'something.dmn' value? I mean is that reflected somehow in UI or just the DMNClientModels.MODEL_WITH_IMPORTS is important?", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431349796", "createdAt": "2020-05-27T18:18:19Z", "author": {"login": "jomarko"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-testing/src/main/java/org/kie/workbench/common/dmn/showcase/client/navigator/DMNDiagramsNavigatorScreen.java", "diffHunk": "@@ -86,6 +96,34 @@ public void edit() {\n         }\n     }\n \n+    @Override\n+    protected MenuFactory.TopLevelMenusBuilder<MenuFactory.MenuBuilder> createMenuBuilder() {\n+        final MenuFactory.TopLevelMenusBuilder<MenuFactory.MenuBuilder> builder = super.createMenuBuilder();\n+        builder.newTopLevelMenu(\"Load diagrams from client\")\n+                .respondsWith(this::loadFromClient)\n+                .order(-1)\n+                .endMenu();\n+        return builder;\n+    }\n+\n+    private void loadFromClient() {\n+        contentService.getFilteredItems(\"**/*.dmn\", getItems(), getErrorCallback());\n+    }\n+\n+    private ErrorCallback<Object> getErrorCallback() {\n+        return null;\n+    }\n+\n+    private RemoteCallback<List<String>> getItems() {\n+        return response -> {\n+            GWT.log(\"PATHS:\");\n+            for (final String s : response) {\n+                GWT.log(s);\n+            }\n+            vfsService.openFile(\"something.dmn\", DMNClientModels.MODEL_WITH_IMPORTS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "385e8dc50ada79a8607d080d801e333cb1a27a4c"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM1MTMwMQ==", "bodyText": "to be consistent, we could add javadoc", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431351301", "createdAt": "2020-05-27T18:21:10Z", "author": {"login": "jomarko"}, "path": "kie-wb-common-kogito/kie-wb-common-kogito-webapp-base/src/main/java/org/kie/workbench/common/kogito/webapp/base/client/workarounds/KogitoResourceContentService.java", "diffHunk": "@@ -104,4 +105,12 @@ public void getFilteredItems(final String pattern,\n                     return null;\n                 });\n     }\n+\n+    public Promise<String[]> getFilteredItems(final String pattern) {\n+        return resourceContentService.list(pattern);\n+    }\n+\n+    public Promise<String> loadFile(final String fileUri) {\n+        return resourceContentService.get(fileUri);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "385e8dc50ada79a8607d080d801e333cb1a27a4c"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM1MzAxOA==", "bodyText": "Is 'Windows' correct in this javadoc?", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r431353018", "createdAt": "2020-05-27T18:24:12Z", "author": {"login": "jomarko"}, "path": "kie-wb-common-stunner/kie-wb-common-stunner-core/kie-wb-common-stunner-api/kie-wb-common-stunner-core-api/src/main/java/org/kie/workbench/common/stunner/core/util/FileUtils.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.workbench.common.stunner.core.util;\n+\n+public class FileUtils {\n+\n+    private static final char UNIX_SEPARATOR = '/';\n+    private static final char WINDOWS_SEPARATOR = '\\\\';\n+\n+    /**\n+     * Gets the file name without the Windows extension.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "385e8dc50ada79a8607d080d801e333cb1a27a4c"}, "originalPosition": 25}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "385e8dc50ada79a8607d080d801e333cb1a27a4c", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/385e8dc50ada79a8607d080d801e333cb1a27a4c", "committedDate": "2020-05-22T20:40:45Z", "message": "Fix condition not valid to DMN."}, "afterCommit": {"oid": "4faa7d39f5c797c8af9fa7c0624aaffb1fb3a5f3", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/4faa7d39f5c797c8af9fa7c0624aaffb1fb3a5f3", "committedDate": "2020-05-28T18:55:59Z", "message": "Fix issue related to DMN files path."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4faa7d39f5c797c8af9fa7c0624aaffb1fb3a5f3", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/4faa7d39f5c797c8af9fa7c0624aaffb1fb3a5f3", "committedDate": "2020-05-28T18:55:59Z", "message": "Fix issue related to DMN files path."}, "afterCommit": {"oid": "511c28d9e8df738452bdf5d7b4100d45a9d09dbb", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/511c28d9e8df738452bdf5d7b4100d45a9d09dbb", "committedDate": "2020-05-29T17:31:30Z", "message": "Changes from code review and improvements in code."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "511c28d9e8df738452bdf5d7b4100d45a9d09dbb", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/511c28d9e8df738452bdf5d7b4100d45a9d09dbb", "committedDate": "2020-05-29T17:31:30Z", "message": "Changes from code review and improvements in code."}, "afterCommit": {"oid": "4ce32e40687d2d15ab17585960d190a29ef2bc5a", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/4ce32e40687d2d15ab17585960d190a29ef2bc5a", "committedDate": "2020-05-29T17:34:27Z", "message": "Changes from code review and improvements in code."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4ce32e40687d2d15ab17585960d190a29ef2bc5a", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/4ce32e40687d2d15ab17585960d190a29ef2bc5a", "committedDate": "2020-05-29T17:34:27Z", "message": "Changes from code review and improvements in code."}, "afterCommit": {"oid": "4c80913917c3d7eb9216e3f044e5e8a94d801896", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/4c80913917c3d7eb9216e3f044e5e8a94d801896", "committedDate": "2020-05-29T17:37:04Z", "message": "Changes from code review and improvements in code."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4c80913917c3d7eb9216e3f044e5e8a94d801896", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/4c80913917c3d7eb9216e3f044e5e8a94d801896", "committedDate": "2020-05-29T17:37:04Z", "message": "Changes from code review and improvements in code."}, "afterCommit": {"oid": "6b1da773f53fdc05bf43f7ee18d1577d44cd34b8", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/6b1da773f53fdc05bf43f7ee18d1577d44cd34b8", "committedDate": "2020-05-29T17:48:31Z", "message": "Changes from code review and improvements in code."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6b1da773f53fdc05bf43f7ee18d1577d44cd34b8", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/6b1da773f53fdc05bf43f7ee18d1577d44cd34b8", "committedDate": "2020-05-29T17:48:31Z", "message": "Changes from code review and improvements in code."}, "afterCommit": {"oid": "31bd5c8b0cd5c16b1354f5088f9e1cc6a8c4fc63", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/31bd5c8b0cd5c16b1354f5088f9e1cc6a8c4fc63", "committedDate": "2020-05-29T20:42:32Z", "message": "Changes from code review and improvements in code."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNzU4OTkx", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#pullrequestreview-421758991", "createdAt": "2020-06-01T11:01:04Z", "commit": {"oid": "31bd5c8b0cd5c16b1354f5088f9e1cc6a8c4fc63"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMTowMTowNFrOGdGofA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMTowMjoxM1rOGdGqdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MDU1Ng==", "bodyText": "Seems to me we can use Colelctions.emptyMap() as the resolved map is just iterated.", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r433170556", "createdAt": "2020-06-01T11:01:04Z", "author": {"login": "jomarko"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogitoImpl.java", "diffHunk": "@@ -16,29 +16,257 @@\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.Vector;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n \n import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.xml.namespace.QName;\n \n+import elemental2.promise.IThenable;\n+import elemental2.promise.Promise;\n+import jsinterop.base.Js;\n+import org.appformer.kogito.bridge.client.resource.interop.ResourceListOptions;\n import org.guvnor.common.services.project.model.WorkspaceProject;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNImportTypes;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.editors.included.PMMLDocumentMetadata;\n+import org.kie.workbench.common.dmn.api.graph.DMNDiagramUtils;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.services.DMNClientDiagramServiceImpl;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDMNElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDecision;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInformationItem;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInputData;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInvocable;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService;\n+import org.kie.workbench.common.stunner.core.client.service.ClientRuntimeError;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Diagram;\n import org.kie.workbench.common.stunner.core.diagram.Metadata;\n+import org.kie.workbench.common.stunner.core.graph.Graph;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+import org.kie.workbench.common.stunner.core.util.StringUtils;\n import org.uberfire.backend.vfs.Path;\n+import org.uberfire.client.promise.Promises;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+import static org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter.withNamespace;\n \n @ApplicationScoped\n public class DMNMarshallerImportsHelperKogitoImpl implements DMNMarshallerImportsHelperKogito {\n \n+    private final KogitoResourceContentService contentService;\n+    private final DMNClientDiagramServiceImpl diagramService;\n+    private final Promises promises;\n+    private final DMNDiagramUtils diagramUtils;\n+    private final DMNIncludedNodeFactory includedModelFactory;\n+\n+    private static final Logger LOGGER = Logger.getLogger(DMNMarshallerImportsHelperKogitoImpl.class.getName());\n+    private static final String DMN_FILES_PATTERN = \"*.dmn\";\n+\n+    @Inject\n+    public DMNMarshallerImportsHelperKogitoImpl(final KogitoResourceContentService contentService,\n+                                                final DMNClientDiagramServiceImpl diagramService,\n+                                                final Promises promises,\n+                                                final DMNDiagramUtils diagramUtils,\n+                                                final DMNIncludedNodeFactory includedModelFactory) {\n+        this.contentService = contentService;\n+        this.diagramService = diagramService;\n+        this.promises = promises;\n+        this.diagramUtils = diagramUtils;\n+        this.includedModelFactory = includedModelFactory;\n+    }\n+\n+    @Override\n+    public Promise<Map<JSITImport, JSITDefinitions>> getImportDefinitionsAsync(final Metadata metadata,\n+                                                                               final List<JSITImport> imports) {\n+        if (!imports.isEmpty()) {\n+            return loadDMNDefinitions().then(otherDefinitions -> {\n+                final Map<JSITImport, JSITDefinitions> importDefinitions = new HashMap<>();\n+                for (final Map.Entry<String, JSITDefinitions> entry : otherDefinitions.entrySet()) {\n+                    final JSITDefinitions def = Js.uncheckedCast(entry.getValue());\n+                    findImportByDefinitions(def, imports).ifPresent(anImport -> {\n+                        final JSITImport foundImported = Js.uncheckedCast(anImport);\n+                        importDefinitions.put(foundImported, def);\n+                    });\n+                }\n+                return promises.resolve(importDefinitions);\n+            });\n+        }\n+        return promises.resolve(new HashMap<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31bd5c8b0cd5c16b1354f5088f9e1cc6a8c4fc63"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MTA2MA==", "bodyText": "maybe also here we could use Collections.emptyMap()", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r433171060", "createdAt": "2020-06-01T11:02:13Z", "author": {"login": "jomarko"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogitoImpl.java", "diffHunk": "@@ -16,29 +16,257 @@\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.Vector;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n \n import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.xml.namespace.QName;\n \n+import elemental2.promise.IThenable;\n+import elemental2.promise.Promise;\n+import jsinterop.base.Js;\n+import org.appformer.kogito.bridge.client.resource.interop.ResourceListOptions;\n import org.guvnor.common.services.project.model.WorkspaceProject;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNImportTypes;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.editors.included.PMMLDocumentMetadata;\n+import org.kie.workbench.common.dmn.api.graph.DMNDiagramUtils;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.services.DMNClientDiagramServiceImpl;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDMNElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDecision;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInformationItem;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInputData;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInvocable;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService;\n+import org.kie.workbench.common.stunner.core.client.service.ClientRuntimeError;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Diagram;\n import org.kie.workbench.common.stunner.core.diagram.Metadata;\n+import org.kie.workbench.common.stunner.core.graph.Graph;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+import org.kie.workbench.common.stunner.core.util.StringUtils;\n import org.uberfire.backend.vfs.Path;\n+import org.uberfire.client.promise.Promises;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+import static org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter.withNamespace;\n \n @ApplicationScoped\n public class DMNMarshallerImportsHelperKogitoImpl implements DMNMarshallerImportsHelperKogito {\n \n+    private final KogitoResourceContentService contentService;\n+    private final DMNClientDiagramServiceImpl diagramService;\n+    private final Promises promises;\n+    private final DMNDiagramUtils diagramUtils;\n+    private final DMNIncludedNodeFactory includedModelFactory;\n+\n+    private static final Logger LOGGER = Logger.getLogger(DMNMarshallerImportsHelperKogitoImpl.class.getName());\n+    private static final String DMN_FILES_PATTERN = \"*.dmn\";\n+\n+    @Inject\n+    public DMNMarshallerImportsHelperKogitoImpl(final KogitoResourceContentService contentService,\n+                                                final DMNClientDiagramServiceImpl diagramService,\n+                                                final Promises promises,\n+                                                final DMNDiagramUtils diagramUtils,\n+                                                final DMNIncludedNodeFactory includedModelFactory) {\n+        this.contentService = contentService;\n+        this.diagramService = diagramService;\n+        this.promises = promises;\n+        this.diagramUtils = diagramUtils;\n+        this.includedModelFactory = includedModelFactory;\n+    }\n+\n+    @Override\n+    public Promise<Map<JSITImport, JSITDefinitions>> getImportDefinitionsAsync(final Metadata metadata,\n+                                                                               final List<JSITImport> imports) {\n+        if (!imports.isEmpty()) {\n+            return loadDMNDefinitions().then(otherDefinitions -> {\n+                final Map<JSITImport, JSITDefinitions> importDefinitions = new HashMap<>();\n+                for (final Map.Entry<String, JSITDefinitions> entry : otherDefinitions.entrySet()) {\n+                    final JSITDefinitions def = Js.uncheckedCast(entry.getValue());\n+                    findImportByDefinitions(def, imports).ifPresent(anImport -> {\n+                        final JSITImport foundImported = Js.uncheckedCast(anImport);\n+                        importDefinitions.put(foundImported, def);\n+                    });\n+                }\n+                return promises.resolve(importDefinitions);\n+            });\n+        }\n+        return promises.resolve(new HashMap<>());\n+    }\n+\n+    Promise<Map<String, JSITDefinitions>> loadDMNDefinitions() {\n+\n+        return contentService.getFilteredItems(DMN_FILES_PATTERN, ResourceListOptions.assetFolder())\n+                .then(list -> {\n+                    if (list.length == 0) {\n+                        return promises.resolve(new HashMap<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31bd5c8b0cd5c16b1354f5088f9e1cc6a8c4fc63"}, "originalPosition": 108}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dab9834cf95491f5a844f6f464bca4e64de177b8", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/dab9834cf95491f5a844f6f464bca4e64de177b8", "committedDate": "2020-06-01T19:10:49Z", "message": "KOGITO-1553: [DMN Designer] Open a DMN file with an included model - Included Models tab\nKOGITO-1776: [DMN Designer] Create a \"Load Projects From Client\" button\nKOGITO-1552: [DMN Designer] Open a DMN file with an included model - DRG Elements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab32293b9a40a0e5346a95332364d9784250fd99", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/ab32293b9a40a0e5346a95332364d9784250fd99", "committedDate": "2020-06-01T19:10:49Z", "message": "Fixes an codestyle error and compatibility with Scesim."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1601d09bf50c03ecab2761c6e46243a16ad56ed6", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/1601d09bf50c03ecab2761c6e46243a16ad56ed6", "committedDate": "2020-06-01T19:10:49Z", "message": "Fix condition not valid to DMN."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ba84cd5211959f68e193968d1dbb77684027966", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/6ba84cd5211959f68e193968d1dbb77684027966", "committedDate": "2020-06-01T19:10:50Z", "message": "Fix issue related to DMN files path."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9452f4efd5fbe590c0a5d8e2ba4125773620ba0b", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/9452f4efd5fbe590c0a5d8e2ba4125773620ba0b", "committedDate": "2020-06-01T19:10:50Z", "message": "Changes from code review and improvements in code."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2fd58226779cee3115a30a7ff6f9c7b1ef91a605", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/2fd58226779cee3115a30a7ff6f9c7b1ef91a605", "committedDate": "2020-06-02T18:48:56Z", "message": "Fixed infinite load issue in some scenarios. Code review improvements."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "31bd5c8b0cd5c16b1354f5088f9e1cc6a8c4fc63", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/31bd5c8b0cd5c16b1354f5088f9e1cc6a8c4fc63", "committedDate": "2020-05-29T20:42:32Z", "message": "Changes from code review and improvements in code."}, "afterCommit": {"oid": "2fd58226779cee3115a30a7ff6f9c7b1ef91a605", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/2fd58226779cee3115a30a7ff6f9c7b1ef91a605", "committedDate": "2020-06-02T18:48:56Z", "message": "Fixed infinite load issue in some scenarios. Code review improvements."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "018a051611374836b26240c975d555ff275ab305", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/018a051611374836b26240c975d555ff275ab305", "committedDate": "2020-06-03T20:59:17Z", "message": "- Order files in alphabetical order\n- Hide Included from other channels, except VSCode and Default (BC)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87a45a256286505a43d3be92c60a66740c538740", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/87a45a256286505a43d3be92c60a66740c538740", "committedDate": "2020-06-04T15:04:03Z", "message": "Fix failing test and added more tests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0NzI1Njg1", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#pullrequestreview-424725685", "createdAt": "2020-06-04T18:34:03Z", "commit": {"oid": "87a45a256286505a43d3be92c60a66740c538740"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxODozNDowNFrOGfS1fQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxOTowMzowMFrOGfT-IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2NzY0NQ==", "bodyText": "Since we're not using the fallbackInput any more, can we do some clean-up KogitoKieAssetsDropdownView as well?", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r435467645", "createdAt": "2020-06-04T18:34:04Z", "author": {"login": "karreiro"}, "path": "kie-wb-common-widgets/kie-wb-common-ui/src/main/java/org/kie/workbench/common/widgets/client/assets/dropdown/KogitoKieAssetsDropdown.java", "diffHunk": "@@ -56,25 +31,11 @@ public void initializeDropdown() {\n         super.initializeDropdown();\n     }\n \n-    protected void initializeInput() {\n-        ((KogitoKieAssetsDropdown.View) view).enableInputMode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87a45a256286505a43d3be92c60a66740c538740"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3NzU1OQ==", "bodyText": "I believe we need a condition here, similar to what we have here: https://github.com/kiegroup/kie-wb-common/pull/3310/files#diff-a1a7c2952428146fc4089821e2271475R216-R219", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r435477559", "createdAt": "2020-06-04T18:47:06Z", "author": {"login": "karreiro"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-runtime/src/main/java/org/kie/workbench/common/dmn/showcase/client/editor/DMNDiagramEditor.java", "diffHunk": "@@ -159,6 +168,7 @@ public void onDiagramLoad() {\n             expressionEditor.setToolbarStateHandler(new DMNProjectToolbarStateHandler(getMenuSessionItems()));\n             decisionNavigatorDock.setupCanvasHandler(c);\n             dataTypesPage.reload();\n+            includedModelsPage.setup(importsPageProvider.withDiagram(c.getDiagram()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87a45a256286505a43d3be92c60a66740c538740"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ4NjAyMA==", "bodyText": "IntelliJ is warning about this method, I think we can solve it by using:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Promise loadNodes(final Map<String, JSITDefinitions> existingDefinitions,\n          \n          \n            \n                private Promise<List<DMNIncludedNode>> loadNodes(final Map<String, JSITDefinitions> existingDefinitions,", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r435486020", "createdAt": "2020-06-04T19:02:36Z", "author": {"login": "karreiro"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogitoImpl.java", "diffHunk": "@@ -16,29 +16,256 @@\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.Vector;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n \n import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.xml.namespace.QName;\n \n+import elemental2.promise.IThenable;\n+import elemental2.promise.Promise;\n+import jsinterop.base.Js;\n+import org.appformer.kogito.bridge.client.resource.interop.ResourceListOptions;\n import org.guvnor.common.services.project.model.WorkspaceProject;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNImportTypes;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.editors.included.PMMLDocumentMetadata;\n+import org.kie.workbench.common.dmn.api.graph.DMNDiagramUtils;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.services.DMNClientDiagramServiceImpl;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDMNElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDecision;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInformationItem;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInputData;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInvocable;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService;\n+import org.kie.workbench.common.stunner.core.client.service.ClientRuntimeError;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Diagram;\n import org.kie.workbench.common.stunner.core.diagram.Metadata;\n+import org.kie.workbench.common.stunner.core.graph.Graph;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+import org.kie.workbench.common.stunner.core.util.StringUtils;\n import org.uberfire.backend.vfs.Path;\n+import org.uberfire.client.promise.Promises;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+import static org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter.withNamespace;\n \n @ApplicationScoped\n public class DMNMarshallerImportsHelperKogitoImpl implements DMNMarshallerImportsHelperKogito {\n \n+    private final KogitoResourceContentService contentService;\n+    private final DMNClientDiagramServiceImpl diagramService;\n+    private final Promises promises;\n+    private final DMNDiagramUtils diagramUtils;\n+    private final DMNIncludedNodeFactory includedModelFactory;\n+\n+    private static final Logger LOGGER = Logger.getLogger(DMNMarshallerImportsHelperKogitoImpl.class.getName());\n+    private static final String DMN_FILES_PATTERN = \"*.dmn\";\n+\n+    @Inject\n+    public DMNMarshallerImportsHelperKogitoImpl(final KogitoResourceContentService contentService,\n+                                                final DMNClientDiagramServiceImpl diagramService,\n+                                                final Promises promises,\n+                                                final DMNDiagramUtils diagramUtils,\n+                                                final DMNIncludedNodeFactory includedModelFactory) {\n+        this.contentService = contentService;\n+        this.diagramService = diagramService;\n+        this.promises = promises;\n+        this.diagramUtils = diagramUtils;\n+        this.includedModelFactory = includedModelFactory;\n+    }\n+\n+    @Override\n+    public Promise<Map<JSITImport, JSITDefinitions>> getImportDefinitionsAsync(final Metadata metadata,\n+                                                                               final List<JSITImport> imports) {\n+        if (!imports.isEmpty()) {\n+            return loadDMNDefinitions().then(otherDefinitions -> {\n+                final Map<JSITImport, JSITDefinitions> importDefinitions = new HashMap<>();\n+                for (final Map.Entry<String, JSITDefinitions> entry : otherDefinitions.entrySet()) {\n+                    final JSITDefinitions def = Js.uncheckedCast(entry.getValue());\n+                    findImportByDefinitions(def, imports).ifPresent(anImport -> {\n+                        final JSITImport foundImported = Js.uncheckedCast(anImport);\n+                        importDefinitions.put(foundImported, def);\n+                    });\n+                }\n+                return promises.resolve(importDefinitions);\n+            });\n+        }\n+        return promises.resolve(Collections.emptyMap());\n+    }\n+\n+    Promise<Map<String, JSITDefinitions>> loadDMNDefinitions() {\n+        return contentService.getFilteredItems(DMN_FILES_PATTERN, ResourceListOptions.assetFolder())\n+                .then(list -> {\n+                    if (list.length == 0) {\n+                        return promises.resolve(Collections.emptyMap());\n+                    } else {\n+                        final Map<String, JSITDefinitions> otherDefinitions = new ConcurrentHashMap<>();\n+                        return promises.all(Arrays.asList(list),\n+                                            (String file) -> loadDefinitionFromFile(file, otherDefinitions))\n+                                .then(v -> promises.resolve(otherDefinitions));\n+                    }\n+                });\n+    }\n+\n+    @Override\n+    public void loadNodesFromModels(final List<DMNIncludedModel> includedModels,\n+                                    final ServiceCallback<List<DMNIncludedNode>> callback) {\n+        final List<DMNIncludedNode> result = new Vector<>();\n+        if (includedModels.isEmpty()) {\n+            callback.onSuccess(result);\n+        } else {\n+            loadDMNDefinitions()\n+                    .then(existingDefinitions -> promises.all(includedModels, model -> loadNodes(existingDefinitions, model, result))\n+                            .then(p ->\n+                                  {\n+                                      callback.onSuccess(result);\n+                                      return promises.resolve();\n+                                  }));\n+        }\n+    }\n+\n+    private Promise loadNodes(final Map<String, JSITDefinitions> existingDefinitions,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87a45a256286505a43d3be92c60a66740c538740"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ4NjI0MA==", "bodyText": "IntelliJ is warning about this method, I think we can solve it by using:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Promise loadDefinitionFromFile(final String file,\n          \n          \n            \n                Promise<Void> loadDefinitionFromFile(final String file,", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#discussion_r435486240", "createdAt": "2020-06-04T19:03:00Z", "author": {"login": "karreiro"}, "path": "kie-wb-common-dmn/kie-wb-common-dmn-webapp-kogito-common/src/main/java/org/kie/workbench/common/dmn/webapp/kogito/common/client/converters/DMNMarshallerImportsHelperKogitoImpl.java", "diffHunk": "@@ -16,29 +16,256 @@\n package org.kie.workbench.common.dmn.webapp.kogito.common.client.converters;\n \n import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.Vector;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n \n import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.xml.namespace.QName;\n \n+import elemental2.promise.IThenable;\n+import elemental2.promise.Promise;\n+import jsinterop.base.Js;\n+import org.appformer.kogito.bridge.client.resource.interop.ResourceListOptions;\n import org.guvnor.common.services.project.model.WorkspaceProject;\n+import org.kie.workbench.common.dmn.api.definition.model.ItemDefinition;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNImportTypes;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedModel;\n+import org.kie.workbench.common.dmn.api.editors.included.DMNIncludedNode;\n+import org.kie.workbench.common.dmn.api.editors.included.IncludedModel;\n import org.kie.workbench.common.dmn.api.editors.included.PMMLDocumentMetadata;\n+import org.kie.workbench.common.dmn.api.graph.DMNDiagramUtils;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter;\n+import org.kie.workbench.common.dmn.webapp.kogito.common.client.services.DMNClientDiagramServiceImpl;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDMNElement;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDRGElement;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDecision;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITDefinitions;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITImport;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInformationItem;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInputData;\n+import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITInvocable;\n import org.kie.workbench.common.dmn.webapp.kogito.marshaller.js.model.dmn12.JSITItemDefinition;\n+import org.kie.workbench.common.kogito.webapp.base.client.workarounds.KogitoResourceContentService;\n+import org.kie.workbench.common.stunner.core.client.service.ClientRuntimeError;\n+import org.kie.workbench.common.stunner.core.client.service.ServiceCallback;\n+import org.kie.workbench.common.stunner.core.diagram.Diagram;\n import org.kie.workbench.common.stunner.core.diagram.Metadata;\n+import org.kie.workbench.common.stunner.core.graph.Graph;\n+import org.kie.workbench.common.stunner.core.util.FileUtils;\n+import org.kie.workbench.common.stunner.core.util.StringUtils;\n import org.uberfire.backend.vfs.Path;\n+import org.uberfire.client.promise.Promises;\n+\n+import static org.kie.workbench.common.dmn.api.editors.types.BuiltInTypeUtils.isBuiltInType;\n+import static org.kie.workbench.common.dmn.webapp.kogito.common.client.converters.model.ImportedItemDefinitionPropertyConverter.withNamespace;\n \n @ApplicationScoped\n public class DMNMarshallerImportsHelperKogitoImpl implements DMNMarshallerImportsHelperKogito {\n \n+    private final KogitoResourceContentService contentService;\n+    private final DMNClientDiagramServiceImpl diagramService;\n+    private final Promises promises;\n+    private final DMNDiagramUtils diagramUtils;\n+    private final DMNIncludedNodeFactory includedModelFactory;\n+\n+    private static final Logger LOGGER = Logger.getLogger(DMNMarshallerImportsHelperKogitoImpl.class.getName());\n+    private static final String DMN_FILES_PATTERN = \"*.dmn\";\n+\n+    @Inject\n+    public DMNMarshallerImportsHelperKogitoImpl(final KogitoResourceContentService contentService,\n+                                                final DMNClientDiagramServiceImpl diagramService,\n+                                                final Promises promises,\n+                                                final DMNDiagramUtils diagramUtils,\n+                                                final DMNIncludedNodeFactory includedModelFactory) {\n+        this.contentService = contentService;\n+        this.diagramService = diagramService;\n+        this.promises = promises;\n+        this.diagramUtils = diagramUtils;\n+        this.includedModelFactory = includedModelFactory;\n+    }\n+\n+    @Override\n+    public Promise<Map<JSITImport, JSITDefinitions>> getImportDefinitionsAsync(final Metadata metadata,\n+                                                                               final List<JSITImport> imports) {\n+        if (!imports.isEmpty()) {\n+            return loadDMNDefinitions().then(otherDefinitions -> {\n+                final Map<JSITImport, JSITDefinitions> importDefinitions = new HashMap<>();\n+                for (final Map.Entry<String, JSITDefinitions> entry : otherDefinitions.entrySet()) {\n+                    final JSITDefinitions def = Js.uncheckedCast(entry.getValue());\n+                    findImportByDefinitions(def, imports).ifPresent(anImport -> {\n+                        final JSITImport foundImported = Js.uncheckedCast(anImport);\n+                        importDefinitions.put(foundImported, def);\n+                    });\n+                }\n+                return promises.resolve(importDefinitions);\n+            });\n+        }\n+        return promises.resolve(Collections.emptyMap());\n+    }\n+\n+    Promise<Map<String, JSITDefinitions>> loadDMNDefinitions() {\n+        return contentService.getFilteredItems(DMN_FILES_PATTERN, ResourceListOptions.assetFolder())\n+                .then(list -> {\n+                    if (list.length == 0) {\n+                        return promises.resolve(Collections.emptyMap());\n+                    } else {\n+                        final Map<String, JSITDefinitions> otherDefinitions = new ConcurrentHashMap<>();\n+                        return promises.all(Arrays.asList(list),\n+                                            (String file) -> loadDefinitionFromFile(file, otherDefinitions))\n+                                .then(v -> promises.resolve(otherDefinitions));\n+                    }\n+                });\n+    }\n+\n+    @Override\n+    public void loadNodesFromModels(final List<DMNIncludedModel> includedModels,\n+                                    final ServiceCallback<List<DMNIncludedNode>> callback) {\n+        final List<DMNIncludedNode> result = new Vector<>();\n+        if (includedModels.isEmpty()) {\n+            callback.onSuccess(result);\n+        } else {\n+            loadDMNDefinitions()\n+                    .then(existingDefinitions -> promises.all(includedModels, model -> loadNodes(existingDefinitions, model, result))\n+                            .then(p ->\n+                                  {\n+                                      callback.onSuccess(result);\n+                                      return promises.resolve();\n+                                  }));\n+        }\n+    }\n+\n+    private Promise loadNodes(final Map<String, JSITDefinitions> existingDefinitions,\n+                              final DMNIncludedModel model,\n+                              final List<DMNIncludedNode> result) {\n+        String filePath = \"\";\n+        for (final Map.Entry<String, JSITDefinitions> entry : existingDefinitions.entrySet()) {\n+            filePath = entry.getKey();\n+            final JSITDefinitions definitions = Js.uncheckedCast(entry.getValue());\n+            if (Objects.equals(model.getNamespace(), definitions.getNamespace())) {\n+                break;\n+            }\n+        }\n+        final String path = filePath;\n+        return contentService.loadFile(path)\n+                .then(content -> {\n+                    return promises.create((success, fail) -> {\n+                        diagramService.transform(content, new ServiceCallback<Diagram>() {\n+                            @Override\n+                            public void onSuccess(final Diagram item) {\n+                                final List<DMNIncludedNode> nodes = diagramUtils\n+                                        .getDRGElements(item)\n+                                        .stream()\n+                                        .map(node -> includedModelFactory.makeDMNIncludeNode(path, model, node))\n+                                        .collect(Collectors.toList());\n+                                result.addAll(nodes);\n+                                success.onInvoke(nodes);\n+                            }\n+\n+                            @Override\n+                            public void onError(final ClientRuntimeError error) {\n+                                LOGGER.log(Level.SEVERE, error.getMessage());\n+                                fail.onInvoke(error);\n+                            }\n+                        });\n+                    });\n+                });\n+    }\n+\n+    @Override\n+    public void loadModels(final ServiceCallback<List<IncludedModel>> callback) {\n+        final List<IncludedModel> models = new Vector<>();\n+        contentService.getFilteredItems(DMN_FILES_PATTERN, ResourceListOptions.assetFolder())\n+                .then(items -> promises.all(Arrays.asList(items), file -> contentService.loadFile(file).then(fileContent -> {\n+                    diagramService.transform(fileContent, new ServiceCallback<Diagram>() {\n+                        @Override\n+                        public void onSuccess(final Diagram item) {\n+                            final String modelPackage = \"\";\n+                            final Diagram<Graph, Metadata> diagram = (Diagram<Graph, Metadata>) item;\n+                            final String namespace = diagramUtils.getNamespace(diagram);\n+                            final String importType = DMNImportTypes.DMN.getDefaultNamespace();\n+                            final int drgElementCount = diagramUtils.getDRGElements(diagram).size();\n+                            final int itemDefinitionCount = diagramUtils.getDefinitions(diagram).getItemDefinition().size();\n+                            final String filename = FileUtils.getFileName(file);\n+                            models.add(new DMNIncludedModel(filename,\n+                                                            modelPackage,\n+                                                            filename,\n+                                                            namespace,\n+                                                            importType,\n+                                                            drgElementCount,\n+                                                            itemDefinitionCount));\n+                        }\n+\n+                        @Override\n+                        public void onError(final ClientRuntimeError error) {\n+                            LOGGER.log(Level.SEVERE, error.getMessage());\n+                        }\n+                    });\n+                    return promises.resolve();\n+                })).then(v -> {\n+                    callback.onSuccess(models);\n+                    return promises.resolve();\n+                }));\n+    }\n+\n+    Promise loadDefinitionFromFile(final String file,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87a45a256286505a43d3be92c60a66740c538740"}, "originalPosition": 208}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79184b641a1fe162591f34809d717ff24b458823", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/79184b641a1fe162591f34809d717ff24b458823", "committedDate": "2020-06-04T20:26:01Z", "message": "Tests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0OTgyNzk5", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#pullrequestreview-424982799", "createdAt": "2020-06-05T04:07:15Z", "commit": {"oid": "79184b641a1fe162591f34809d717ff24b458823"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b1db49415efff482c37eeb5b046cc120f5e4d6a", "author": {"user": {"login": "danielzhe", "name": "Daniel J dos Santos"}}, "url": "https://github.com/kiegroup/kie-wb-common/commit/1b1db49415efff482c37eeb5b046cc120f5e4d6a", "committedDate": "2020-06-05T23:29:58Z", "message": "Code review."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NTQ5OTc5", "url": "https://github.com/kiegroup/kie-wb-common/pull/3310#pullrequestreview-426549979", "createdAt": "2020-06-08T19:21:07Z", "commit": {"oid": "1b1db49415efff482c37eeb5b046cc120f5e4d6a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 393, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}