{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzMjg1MDMw", "number": 3329, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMjowNjo0OFrOEE3ZLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMjowNjo0OFrOEE3ZLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTM3MzI2OnYy", "diffSide": "RIGHT", "path": "kie-wb-common-stunner/kie-wb-common-stunner-sets/kie-wb-common-stunner-bpmn/kie-wb-common-stunner-bpmn-api/src/main/java/org/kie/workbench/common/stunner/bpmn/forms/validation/timerEditor/TimerSettingsValueValidator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMjowNjo0OFrOGiwbEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQyMTozOTowMVrOGjfipQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA5ODEzMQ==", "bodyText": "I understand that the key point is the use of the DateTimeFormat.parseStrict method. Once calling it, if an execptoin occurs, we can assume that the given date is not valid. But maybe we can be more specific on the exception type being catched on this assumption - does it makes sense assuming once any \"generic\" exception occurs is due to the date is not valid (eg: leap days)? Is there any other Exception subtype we could use for the catch block instead? Just brainstorming, just asking :)", "url": "https://github.com/kiegroup/kie-wb-common/pull/3329#discussion_r439098131", "createdAt": "2020-06-11T22:06:48Z", "author": {"login": "romartin"}, "path": "kie-wb-common-stunner/kie-wb-common-stunner-sets/kie-wb-common-stunner-bpmn/kie-wb-common-stunner-bpmn-api/src/main/java/org/kie/workbench/common/stunner/bpmn/forms/validation/timerEditor/TimerSettingsValueValidator.java", "diffHunk": "@@ -172,10 +181,36 @@ private static boolean isValidQuartzExpression(final String value) {\n     }\n \n     private static boolean isValidTimeDate(final String value) {\n-        return hasSomething(value) && dateTimeExpr.test(value);\n+        return hasSomething(value) && dateTimeExpr.test(value) && mayHaveValidDate(value);\n     }\n \n     private static boolean hasSomething(final String value) {\n         return value != null && !value.trim().isEmpty();\n     }\n+\n+    private static List<String> fetchDateStrings(final String value) {\n+        List<String> matches = new ArrayList<>();\n+        MatchResult matcher = datePattern.exec(value);\n+\n+        while (null != matcher) {\n+            matches.add(matcher.getGroup(1));\n+            matcher = datePattern.exec(value);\n+        }\n+\n+        return matches;\n+    }\n+\n+    // if the ISO expression has dates, they must be valid ones\n+    private static boolean mayHaveValidDate(final String value) {\n+        List<String> matches = fetchDateStrings(value);\n+        if (!matches.isEmpty()) {\n+            try {\n+                DateTimeFormat dateTimeFormat = DateTimeFormat.getFormat(\"yyyy-MM-dd\");\n+                matches.forEach(dateTimeFormat::parseStrict);\n+            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c29a7bfa7c05abeb6ee383dd65efbdee5df2a15a"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg3MDExNw==", "bodyText": "Hey @romartin, The parseStrict throws only one kind of exception \"IllegalArgumentException\", so I thought it was ok implementing this way. However, looking back at the code I agree it is not clear without checking the API.\nI've already changed the code to make this exception catching more specific.\nThanks", "url": "https://github.com/kiegroup/kie-wb-common/pull/3329#discussion_r439870117", "createdAt": "2020-06-14T21:39:01Z", "author": {"login": "handreyrc"}, "path": "kie-wb-common-stunner/kie-wb-common-stunner-sets/kie-wb-common-stunner-bpmn/kie-wb-common-stunner-bpmn-api/src/main/java/org/kie/workbench/common/stunner/bpmn/forms/validation/timerEditor/TimerSettingsValueValidator.java", "diffHunk": "@@ -172,10 +181,36 @@ private static boolean isValidQuartzExpression(final String value) {\n     }\n \n     private static boolean isValidTimeDate(final String value) {\n-        return hasSomething(value) && dateTimeExpr.test(value);\n+        return hasSomething(value) && dateTimeExpr.test(value) && mayHaveValidDate(value);\n     }\n \n     private static boolean hasSomething(final String value) {\n         return value != null && !value.trim().isEmpty();\n     }\n+\n+    private static List<String> fetchDateStrings(final String value) {\n+        List<String> matches = new ArrayList<>();\n+        MatchResult matcher = datePattern.exec(value);\n+\n+        while (null != matcher) {\n+            matches.add(matcher.getGroup(1));\n+            matcher = datePattern.exec(value);\n+        }\n+\n+        return matches;\n+    }\n+\n+    // if the ISO expression has dates, they must be valid ones\n+    private static boolean mayHaveValidDate(final String value) {\n+        List<String> matches = fetchDateStrings(value);\n+        if (!matches.isEmpty()) {\n+            try {\n+                DateTimeFormat dateTimeFormat = DateTimeFormat.getFormat(\"yyyy-MM-dd\");\n+                matches.forEach(dateTimeFormat::parseStrict);\n+            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA5ODEzMQ=="}, "originalCommit": {"oid": "c29a7bfa7c05abeb6ee383dd65efbdee5df2a15a"}, "originalPosition": 83}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1317, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}