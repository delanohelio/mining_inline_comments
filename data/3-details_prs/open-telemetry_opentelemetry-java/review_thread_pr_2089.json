{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIyOTI1Mjk3", "number": 2089, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNjo0OToxMVrOE6qOTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwNDo1Nzo0MVrOE64EAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5OTQ0NjU0OnYy", "diffSide": "RIGHT", "path": "context/src/main/java/io/opentelemetry/context/propagation/ContextPropagatorsBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNjo0OToxMVrOH13Scw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMTozNzowM1rOH2JIsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI0MjQxOQ==", "bodyText": "Having an interface for a builder, which is just a list of propagators and a constructor call feels like overkill to me. Is the rationale here to make the agent more easily able to bridge the builder?\nCould we ditch the builder entirely and use a pattern like in #2091 where we just have a static method on the ContextPropagators that takes the list of TextMapPropagators?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2089#discussion_r526242419", "createdAt": "2020-11-18T16:49:11Z", "author": {"login": "jkwatson"}, "path": "context/src/main/java/io/opentelemetry/context/propagation/ContextPropagatorsBuilder.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.context.propagation;\n+\n+/**\n+ * A builder of a default {@link ContextPropagators} which can have multiple {@link\n+ * TextMapPropagator} added, and extraction and injection will execute every {@link\n+ * TextMapPropagator} in order.\n+ */\n+public interface ContextPropagatorsBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7565f9fbef92a01deb3ca0857b146d1eac384c61"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUzNDgzNA==", "bodyText": "Yup - it came to mind after sending the PR but before also having the idea of killing ContextPropagators completely :) Will do so since now I see the binary propagation idea is probably the main reason for this interface.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2089#discussion_r526534834", "createdAt": "2020-11-19T01:37:03Z", "author": {"login": "anuraaga"}, "path": "context/src/main/java/io/opentelemetry/context/propagation/ContextPropagatorsBuilder.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.context.propagation;\n+\n+/**\n+ * A builder of a default {@link ContextPropagators} which can have multiple {@link\n+ * TextMapPropagator} added, and extraction and injection will execute every {@link\n+ * TextMapPropagator} in order.\n+ */\n+public interface ContextPropagatorsBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI0MjQxOQ=="}, "originalCommit": {"oid": "7565f9fbef92a01deb3ca0857b146d1eac384c61"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTcxMzk0OnYy", "diffSide": "RIGHT", "path": "context/src/main/java/io/opentelemetry/context/propagation/ContextPropagators.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwNDo1Nzo0MVrOH2Mx4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwMTo1ODoyN1rOH26mdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU5NDUyOA==", "bodyText": "this usage looks really good to me.  \ud83d\udc4d", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2089#discussion_r526594528", "createdAt": "2020-11-19T04:57:41Z", "author": {"login": "jkwatson"}, "path": "context/src/main/java/io/opentelemetry/context/propagation/ContextPropagators.java", "diffHunk": "@@ -71,25 +73,29 @@\n public interface ContextPropagators {\n \n   /**\n-   * Returns a {@link ContextPropagatorsBuilder} used to construct a new {@code ContextPropagators}\n-   * object with the specified propagators.\n-   *\n-   * <p>Invocation order of {@code TextMapPropagator#inject()} and {@code\n-   * TextMapPropagator#extract()} for registered trace propagators is undefined.\n-   *\n-   * <p>This is a example of a {@code ContextPropagators} object being created:\n+   * Returns a {@link ContextPropagators} which can be used to extract and inject context in text\n+   * payloads with the given {@link TextMapPropagator}. Use {@link\n+   * TextMapPropagator#composite(TextMapPropagator...)} to register multiple propagators, which will\n+   * all be executed when extracting or injecting.\n    *\n    * <pre>{@code\n-   * ContextPropagators propagators = DefaultContextPropagators.builder()\n-   *     .addTextMapPropagator(new HttpTraceContext())\n-   *     .addTextMapPropagator(new HttpBaggage())\n-   *     .addTextMapPropagator(new MyCustomContextPropagator())\n-   *     .build();\n+   * ContextPropagators propagators = ContextPropagators.create(\n+   *   TextMapPropagator.composite(\n+   *     HttpTraceContext.getInstance(),\n+   *     W3CBaggagePropagator.getInstance(),\n+   *     new MyCustomContextPropagator()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94adc4e0d4bfb06686b8e5b285128e391c124c63"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzMwNjk1Nw==", "bodyText": "I preferred the Builder but hiding the default instance looks great. On that note, TraceMultiPropagator may need to be lifted too, i.e. no Builder.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2089#discussion_r527306957", "createdAt": "2020-11-20T00:34:48Z", "author": {"login": "carlosalberto"}, "path": "context/src/main/java/io/opentelemetry/context/propagation/ContextPropagators.java", "diffHunk": "@@ -71,25 +73,29 @@\n public interface ContextPropagators {\n \n   /**\n-   * Returns a {@link ContextPropagatorsBuilder} used to construct a new {@code ContextPropagators}\n-   * object with the specified propagators.\n-   *\n-   * <p>Invocation order of {@code TextMapPropagator#inject()} and {@code\n-   * TextMapPropagator#extract()} for registered trace propagators is undefined.\n-   *\n-   * <p>This is a example of a {@code ContextPropagators} object being created:\n+   * Returns a {@link ContextPropagators} which can be used to extract and inject context in text\n+   * payloads with the given {@link TextMapPropagator}. Use {@link\n+   * TextMapPropagator#composite(TextMapPropagator...)} to register multiple propagators, which will\n+   * all be executed when extracting or injecting.\n    *\n    * <pre>{@code\n-   * ContextPropagators propagators = DefaultContextPropagators.builder()\n-   *     .addTextMapPropagator(new HttpTraceContext())\n-   *     .addTextMapPropagator(new HttpBaggage())\n-   *     .addTextMapPropagator(new MyCustomContextPropagator())\n-   *     .build();\n+   * ContextPropagators propagators = ContextPropagators.create(\n+   *   TextMapPropagator.composite(\n+   *     HttpTraceContext.getInstance(),\n+   *     W3CBaggagePropagator.getInstance(),\n+   *     new MyCustomContextPropagator()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU5NDUyOA=="}, "originalCommit": {"oid": "94adc4e0d4bfb06686b8e5b285128e391c124c63"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM0NTI2OQ==", "bodyText": "Thanks for calling out - let me followup with consistency in TraceMultiPropagator in a bit", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2089#discussion_r527345269", "createdAt": "2020-11-20T01:58:27Z", "author": {"login": "anuraaga"}, "path": "context/src/main/java/io/opentelemetry/context/propagation/ContextPropagators.java", "diffHunk": "@@ -71,25 +73,29 @@\n public interface ContextPropagators {\n \n   /**\n-   * Returns a {@link ContextPropagatorsBuilder} used to construct a new {@code ContextPropagators}\n-   * object with the specified propagators.\n-   *\n-   * <p>Invocation order of {@code TextMapPropagator#inject()} and {@code\n-   * TextMapPropagator#extract()} for registered trace propagators is undefined.\n-   *\n-   * <p>This is a example of a {@code ContextPropagators} object being created:\n+   * Returns a {@link ContextPropagators} which can be used to extract and inject context in text\n+   * payloads with the given {@link TextMapPropagator}. Use {@link\n+   * TextMapPropagator#composite(TextMapPropagator...)} to register multiple propagators, which will\n+   * all be executed when extracting or injecting.\n    *\n    * <pre>{@code\n-   * ContextPropagators propagators = DefaultContextPropagators.builder()\n-   *     .addTextMapPropagator(new HttpTraceContext())\n-   *     .addTextMapPropagator(new HttpBaggage())\n-   *     .addTextMapPropagator(new MyCustomContextPropagator())\n-   *     .build();\n+   * ContextPropagators propagators = ContextPropagators.create(\n+   *   TextMapPropagator.composite(\n+   *     HttpTraceContext.getInstance(),\n+   *     W3CBaggagePropagator.getInstance(),\n+   *     new MyCustomContextPropagator()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU5NDUyOA=="}, "originalCommit": {"oid": "94adc4e0d4bfb06686b8e5b285128e391c124c63"}, "originalPosition": 35}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1953, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}