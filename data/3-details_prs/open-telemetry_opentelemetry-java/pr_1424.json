{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUwNDA5MjEx", "number": 1424, "title": "Added unit tests for SpanBucket", "bodyText": "Issue #1415", "createdAt": "2020-07-16T18:29:44Z", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424", "merged": true, "mergeCommit": {"oid": "a938166a07a5ab732ee7b07b3090a724239f47b4"}, "closed": true, "closedAt": "2020-07-17T15:20:25Z", "author": {"login": "williamhu99"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc1iwVVAH2gAyNDUwNDA5MjExOmE3Yzc1MGUzOTJlYTBmMmFkNThjYTRlNzMzN2QyOWY3ZjE2NzI1OWE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc11cozgFqTQ1MDc0NjY5Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a7c750e392ea0f2ad58ca4e7337d29f7f167259a", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/a7c750e392ea0f2ad58ca4e7337d29f7f167259a", "committedDate": "2020-07-16T17:33:38Z", "message": "Added unit tests for SpanBucket"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62f9dfbd11770b14ab425d2ca7baf0bd7efd0420", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/62f9dfbd11770b14ab425d2ca7baf0bd7efd0420", "committedDate": "2020-07-16T18:10:28Z", "message": "Included a comment to make the last test more clear"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMTc3MzI2", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#pullrequestreview-450177326", "createdAt": "2020-07-16T20:06:10Z", "commit": {"oid": "62f9dfbd11770b14ab425d2ca7baf0bd7efd0420"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMDowNjoxMFrOGy638g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMDowNjoxMFrOGy638g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA0NjU3OA==", "bodyText": "shouldn't we wait on the countDownLatch before starting the work? Right now, the latch isn't being used to ensure concurrency at all.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#discussion_r456046578", "createdAt": "2020-07-16T20:06:10Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/SpanBucketTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Unit tests for {@link SpanBucket}. */\n+@RunWith(JUnit4.class)\n+public final class SpanBucketTest {\n+  private static final String SPAN_NAME = \"span\";\n+  private static final int LATENCY_BUCKET_SIZE = 16;\n+  private static final int ERROR_BUCKET_SIZE = 8;\n+  private final TracerSdkProvider tracerSdkProvider = TracerSdkProvider.builder().build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"SpanBucketTest\");\n+\n+  @Test\n+  public void verifyLatencyBucketSizeLimit() {\n+    SpanBucket latencyBucket = new SpanBucket(true);\n+    Span[] spans = new Span[LATENCY_BUCKET_SIZE + 1];\n+    for (int i = 0; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      latencyBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    latencyBucket.addTo(bucketSpans);\n+    /* The latency SpanBucket should have the most recent LATENCY_BUCKET_SIZE spans */\n+    assertThat(latencyBucket.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyErrorBucketSizeLimit() {\n+    SpanBucket errorBucket = new SpanBucket(false);\n+    Span[] spans = new Span[ERROR_BUCKET_SIZE + 1];\n+    for (int i = 0; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      errorBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    errorBucket.addTo(bucketSpans);\n+    /* The error SpanBucket should have the most recent ERROR_BUCKET_SIZE spans */\n+    assertThat(errorBucket.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyThreadSafety() throws InterruptedException {\n+    int numberOfThreads = 4;\n+    final int numberOfSpans = 4;\n+    SpanBucket spanBucket = new SpanBucket(true);\n+    final CountDownLatch countDownLatch = new CountDownLatch(numberOfThreads);\n+    List<Thread> workers = new ArrayList<>();\n+    for (int i = 0; i < numberOfThreads; i++) {\n+      workers.add(\n+          new Thread(\n+              () -> {\n+                for (int j = 0; j < numberOfSpans; j++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62f9dfbd11770b14ab425d2ca7baf0bd7efd0420"}, "originalPosition": 92}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14ccbcce2d5d452552e9ceff407059258f248b3e", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/14ccbcce2d5d452552e9ceff407059258f248b3e", "committedDate": "2020-07-16T22:50:50Z", "message": "Rewrote the concurrency test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMjY5MDgy", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#pullrequestreview-450269082", "createdAt": "2020-07-16T22:53:57Z", "commit": {"oid": "14ccbcce2d5d452552e9ceff407059258f248b3e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMjo1Mzo1N1rOGy_f-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMjo1Mzo1N1rOGy_f-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyMjM2Mg==", "bodyText": "I don't know if this line would ever be visible inside a background thread.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#discussion_r456122362", "createdAt": "2020-07-16T22:53:57Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/SpanBucketTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Unit tests for {@link SpanBucket}. */\n+@RunWith(JUnit4.class)\n+public final class SpanBucketTest {\n+  private static final String SPAN_NAME = \"span\";\n+  private static final int LATENCY_BUCKET_SIZE = 16;\n+  private static final int ERROR_BUCKET_SIZE = 8;\n+  private final TracerSdkProvider tracerSdkProvider = TracerSdkProvider.builder().build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"SpanBucketTest\");\n+\n+  @Test\n+  public void verifyLatencyBucketSizeLimit() {\n+    SpanBucket latencyBucket = new SpanBucket(true);\n+    Span[] spans = new Span[LATENCY_BUCKET_SIZE + 1];\n+    for (int i = 0; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      latencyBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    latencyBucket.addTo(bucketSpans);\n+    /* The latency SpanBucket should have the most recent LATENCY_BUCKET_SIZE spans */\n+    assertThat(latencyBucket.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyErrorBucketSizeLimit() {\n+    SpanBucket errorBucket = new SpanBucket(false);\n+    Span[] spans = new Span[ERROR_BUCKET_SIZE + 1];\n+    for (int i = 0; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      errorBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    errorBucket.addTo(bucketSpans);\n+    /* The error SpanBucket should have the most recent ERROR_BUCKET_SIZE spans */\n+    assertThat(errorBucket.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyThreadSafety() throws InterruptedException {\n+    int numberOfThreads = 4;\n+    int numberOfSpans = 4;\n+    SpanBucket spanBucket = new SpanBucket(true);\n+    final CountDownLatch startSignal = new CountDownLatch(1);\n+    final CountDownLatch endSignal = new CountDownLatch(numberOfThreads);\n+    for (int i = 0; i < numberOfThreads; i++) {\n+      new Thread(\n+              () -> {\n+                try {\n+                  startSignal.await();\n+                  for (int j = 0; j < numberOfSpans; j++) {\n+                    Span span = tracer.spanBuilder(SPAN_NAME).startSpan();\n+                    spanBucket.add((ReadableSpan) span);\n+                    span.end();\n+                  }\n+                  endSignal.countDown();\n+                } catch (InterruptedException e) {\n+                  Assert.fail(e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14ccbcce2d5d452552e9ceff407059258f248b3e"}, "originalPosition": 101}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMjY5MzIw", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#pullrequestreview-450269320", "createdAt": "2020-07-16T22:54:31Z", "commit": {"oid": "14ccbcce2d5d452552e9ceff407059258f248b3e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMjo1NDozMVrOGy_g1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMjo1NDozMVrOGy_g1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyMjU4Mg==", "bodyText": "because we're relying on this, we should put a timeout on the test annotation, just in case things go badly awry. That way, we won't hang indefinitely waiting for things to finish.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#discussion_r456122582", "createdAt": "2020-07-16T22:54:31Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/SpanBucketTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Unit tests for {@link SpanBucket}. */\n+@RunWith(JUnit4.class)\n+public final class SpanBucketTest {\n+  private static final String SPAN_NAME = \"span\";\n+  private static final int LATENCY_BUCKET_SIZE = 16;\n+  private static final int ERROR_BUCKET_SIZE = 8;\n+  private final TracerSdkProvider tracerSdkProvider = TracerSdkProvider.builder().build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"SpanBucketTest\");\n+\n+  @Test\n+  public void verifyLatencyBucketSizeLimit() {\n+    SpanBucket latencyBucket = new SpanBucket(true);\n+    Span[] spans = new Span[LATENCY_BUCKET_SIZE + 1];\n+    for (int i = 0; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      latencyBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    latencyBucket.addTo(bucketSpans);\n+    /* The latency SpanBucket should have the most recent LATENCY_BUCKET_SIZE spans */\n+    assertThat(latencyBucket.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(LATENCY_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < LATENCY_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyErrorBucketSizeLimit() {\n+    SpanBucket errorBucket = new SpanBucket(false);\n+    Span[] spans = new Span[ERROR_BUCKET_SIZE + 1];\n+    for (int i = 0; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      spans[i] = tracer.spanBuilder(SPAN_NAME).startSpan();\n+      errorBucket.add((ReadableSpan) spans[i]);\n+      spans[i].end();\n+    }\n+    List<ReadableSpan> bucketSpans = new ArrayList<>();\n+    errorBucket.addTo(bucketSpans);\n+    /* The error SpanBucket should have the most recent ERROR_BUCKET_SIZE spans */\n+    assertThat(errorBucket.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans.size()).isEqualTo(ERROR_BUCKET_SIZE);\n+    assertThat(bucketSpans).doesNotContain(spans[0]);\n+    for (int i = 1; i < ERROR_BUCKET_SIZE + 1; i++) {\n+      assertThat(bucketSpans).contains(spans[i]);\n+    }\n+  }\n+\n+  @Test\n+  public void verifyThreadSafety() throws InterruptedException {\n+    int numberOfThreads = 4;\n+    int numberOfSpans = 4;\n+    SpanBucket spanBucket = new SpanBucket(true);\n+    final CountDownLatch startSignal = new CountDownLatch(1);\n+    final CountDownLatch endSignal = new CountDownLatch(numberOfThreads);\n+    for (int i = 0; i < numberOfThreads; i++) {\n+      new Thread(\n+              () -> {\n+                try {\n+                  startSignal.await();\n+                  for (int j = 0; j < numberOfSpans; j++) {\n+                    Span span = tracer.spanBuilder(SPAN_NAME).startSpan();\n+                    spanBucket.add((ReadableSpan) span);\n+                    span.end();\n+                  }\n+                  endSignal.countDown();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14ccbcce2d5d452552e9ceff407059258f248b3e"}, "originalPosition": 99}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "612f851266d6dc1c21936e40a65e9d4881509596", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/612f851266d6dc1c21936e40a65e9d4881509596", "committedDate": "2020-07-16T23:35:34Z", "message": "Removed assertion from exception and added a time limit for the concurrency test case"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMjg0NDEw", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#pullrequestreview-450284410", "createdAt": "2020-07-16T23:36:32Z", "commit": {"oid": "612f851266d6dc1c21936e40a65e9d4881509596"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNjYzNzA3", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#pullrequestreview-450663707", "createdAt": "2020-07-17T13:37:21Z", "commit": {"oid": "612f851266d6dc1c21936e40a65e9d4881509596"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNzQ2Njkz", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1424#pullrequestreview-450746693", "createdAt": "2020-07-17T15:20:19Z", "commit": {"oid": "612f851266d6dc1c21936e40a65e9d4881509596"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2566, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}