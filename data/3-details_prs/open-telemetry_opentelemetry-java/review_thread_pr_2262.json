{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM1Njk1MjU5", "number": 2262, "reviewThreads": {"totalCount": 49, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNjozNTo0NlrOFDTbYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDozODo0MFrOFG5W2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDA4MzU0OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNjozNTo0NlrOIC4mhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzo0ODo1OVrOIC7s5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTg5NTQyOQ==", "bodyText": "At least in Brave", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539895429", "createdAt": "2020-12-10T06:35:46Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 270}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzNDU5Ng==", "bodyText": "So there is no world outside Spring? :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539934596", "createdAt": "2020-12-10T07:25:27Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTg5NTQyOQ=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 270}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0NjIxMg==", "bodyText": "I mention Brave since I have the most experience with it. I would expect OT and OC to have come to similar conclusion but I don't know. But no Spring involved here.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539946212", "createdAt": "2020-12-10T07:48:59Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTg5NTQyOQ=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 270}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDMwNDUzOnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzoxODo1MFrOIC6xkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzoxODo1MFrOIC6xkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzMTAyNw==", "bodyText": "s/cafe/care?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539931027", "createdAt": "2020-12-10T07:18:50Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDMxNDk0OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzoyMToxM1rOIC63qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxOTozMDoyMlrOIDZ0TQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzMjU4Nw==", "bodyText": "How can I set https://github.com/open-telemetry/opentelemetry-java/tree/master/sdk-extensions/async-processor to be used instead of the normal batch span processor?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539932587", "createdAt": "2020-12-10T07:21:13Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAxNjMxNw==", "bodyText": "For extensions, I guess it has to wrap. Perhaps it means a fluent config isn't great but we do have a problem right now that BSP and similar are difficult concepts for just registering an exporter.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540016317", "createdAt": "2020-12-10T09:38:08Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzMjU4Nw=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQzOTYyOQ==", "bodyText": "I think there's been some thought that maybe we should swap the responsibility and have the exporter be created with a processor (if the specific exporter allows for more than one option), rather than the other way around. That would definitely be a change to our processor/exporter APIs, but maybe now is a good time to think about it.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540439629", "createdAt": "2020-12-10T19:30:22Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzMjU4Nw=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDMyMDUyOnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzoyMjo0NFrOIC66sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzoyMjo0NFrOIC66sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzMzM2Mw==", "bodyText": "s/tracerProvider/meterProvider?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539933363", "createdAt": "2020-12-10T07:22:44Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDMyNjgyOnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzoyNDo0NFrOIC6-Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzo0ODoyMFrOIC7rug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzNDI3OA==", "bodyText": "I would encourage passing Otel instance always. So if we add more functionality to the otel instance we don't break the API.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539934278", "createdAt": "2020-12-10T07:24:44Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0NTkxNA==", "bodyText": "I'm not sure what difference it makes for this example - the reason I pass both is just illustrative, but it may be more common to only have one of them. If you need tracing, just depend on TracerProvider - though nothing would prevent OpenTelemetry either and this is mostly up to what the framework author wants to present here.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539945914", "createdAt": "2020-12-10T07:48:20Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzNDI3OA=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 235}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDMzNjExOnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzoyNzoyM1rOIC7DSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxOTo1NTozNlrOIDawaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzNTU2Mw==", "bodyText": "I think this is a very unexpected behavior....", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539935563", "createdAt": "2020-12-10T07:27:23Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk1MzM4Mg==", "bodyText": "It could also be reasonable to leave this up to frameworks - but it will almost always be required.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539953382", "createdAt": "2020-12-10T08:01:52Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzNTU2Mw=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5NjI2MQ==", "bodyText": "I agree with Bogdan. Let it be explicit.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539996261", "createdAt": "2020-12-10T09:10:07Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzNTU2Mw=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ1NTAxOQ==", "bodyText": "By \"Let it be explicit\" you mean \"require the SDK user to explicitly assign the global\"? Does this mean that the operator/app developer will need to understand the internals of all the instrumentation that happens to be included with the project?\nI'm not necessarily arguing in favor of auto-setting the global instance, but I wanted to bring up a problem with the alternative.\nMy opinion would probably be: get rid of the global altogether and make instrumentation authors work around it in some way [I'm definitely not an expert here...just trying to optimize for simplicity as much as possible].", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540455019", "createdAt": "2020-12-10T19:55:36Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzNTU2Mw=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 262}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDM0NzY4OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzozMToxMVrOIC7KGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzo0OTozOFrOIC7uIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzNzMwNg==", "bodyText": "What if someone is very strict and want to actually use a different sdk instance + pipeline to monitor the main monitoring sdk?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539937306", "createdAt": "2020-12-10T07:31:11Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 323}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0NjUzMQ==", "bodyText": "This is an example of how we might do it more automatically. But we could just leave it to being wired manually, and then it could be wired to any SDK.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539946531", "createdAt": "2020-12-10T07:49:38Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzNzMwNg=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 323}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDM1NTA2OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzozMzoxNFrOIC7OOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzo1MTowOVrOIC7xTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzODM2MQ==", "bodyText": "So if I am not using Spring I am not a \"framework\" author? :)\nI would rewrite with something like:\nWhen using a framework that supports dependency injection and lazy initialization ....", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539938361", "createdAt": "2020-12-10T07:33:14Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 328}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0NzM0MA==", "bodyText": "I didn't use the word Spring here - I use Spring in my examples expecting it to be most familiar to readers, for me Dagger would have been easier to write. It's just replacing @Component -> @Module, @Bean -> @Provides though, Lazy happens to be the same.\nI don't see much wrong with claiming that most frameworks use dependency injection in Java since they do.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539947340", "createdAt": "2020-12-10T07:51:09Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzODM2MQ=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 328}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDM2MDM5OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzozNDo1NlrOIC7ROg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwODoxOTowN1rOIDtzQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzOTEzMA==", "bodyText": "If TraceConfig is not \"immutable\" you have hard time and undefined behaviors. What does it happen if we decide to call sampler twice and gets changed between the calls? Or any other property that we use?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539939130", "createdAt": "2020-12-10T07:34:56Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 375}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0MTk2Nw==", "bodyText": "By making immutable we can guarantee that one config is applied for the entire lifetime of one span, and you cannot do this with a mutable config.\nYou may say that you add a \"Factory\" that returns an immutable TraceConfig, that is a lot of unnecessary allocations (you may cache the result). But if there is a factory why someone cannot do the same thing and update the Factory?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539941967", "createdAt": "2020-12-10T07:40:35Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzOTEzMA=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 375}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0OTgwMg==", "bodyText": "Yeah makes sense - a factory seems reasonable though, mental model could actually be more clear, a factory of trace configs for spans, not a global thing that's always referenced. For static config, it'll just return itself, for dynamic, caching in a volatile until changed again seems like a very common approach.\nIf the factory is initialized when building the SDK, the implementation could be private to the framework. I think it does make it very hard to do a strange update of the SDK (would have to just ignore the framework-provided SDK completely).", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539949802", "createdAt": "2020-12-10T07:55:37Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzOTEzMA=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 375}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAwMjgwNQ==", "bodyText": "How are we going to support dynamic Samplers?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540002805", "createdAt": "2020-12-10T09:19:41Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzOTEzMA=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 375}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAyMzA2NQ==", "bodyText": "Sampler is already an interface I was always expecting them to be a dynamic implementation of it.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540023065", "createdAt": "2020-12-10T09:47:14Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzOTEzMA=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 375}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA0NzgyMw==", "bodyText": "All current Samplers are immutable and are changed by swapping instances.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540047823", "createdAt": "2020-12-10T10:20:39Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzOTEzMA=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 375}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2OTMxNQ==", "bodyText": "sure, but that doesn't mean that other Samplers could be more dynamic (or we could even update our existing Samplers to be dynamic without altering the interface, I think).", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540569315", "createdAt": "2020-12-10T23:11:58Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzOTEzMA=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 375}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc2NzA0MA==", "bodyText": "Yeah - there are probably many types of dynamic samplers, but one that x-ray uses for example would poll rules from a server and process rule updates on-the-fly, this is all a part of the Sampler and I wouldn't expect an instance swap. I'd swap the instance to swap completely different ways of sampling, not to tweak a sampler - at least this seems more natural with how interfaces / implementations work IMO.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540767040", "createdAt": "2020-12-11T08:19:07Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzOTEzMA=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 375}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDM3MDYyOnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzozNzo0MFrOIC7W3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzoxNToxMFrOIDh0eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0MDU3NQ==", "bodyText": "Who is the author of this line? Only one person should configure or control the SDK config. Any random \"service\" running in an application service should be able to affect only their instance of SDK if any, otherwise should not be able to control the config.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539940575", "createdAt": "2020-12-10T07:37:40Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk1MTI2Mw==", "bodyText": "Yeah - it's demonstrating something very buggy, but it's to illustrate that I think having mutation APIs does open this sort of thing up, giving up control from the framework author. Though for use cases that are common for raw-SDK users, we could also add extensions with e.g., dynamic trace config providers.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539951263", "createdAt": "2020-12-10T07:58:08Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0MDU3NQ=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3MDc0NA==", "bodyText": "It seems like this might be an argument against exposing a global where anyone could muck about with it and effect everything running in the current classloader (or JVM itself depending on where the global is class loaded first).", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540570744", "createdAt": "2020-12-10T23:15:10Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0MDU3NQ=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 388}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDQwMzgwOnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzo0NzoxN1rOIC7pnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzo0NzoxN1rOIC7pnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0NTM3Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n          \n          \n            \n            inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539945372", "createdAt": "2020-12-10T07:47:17Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDQwNDY2OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzo0NzozMVrOIC7qCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzo0NzozMVrOIC7qCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0NTQ4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n          \n          \n            \n              public MeterProvider meterProvider(OpenTelemetry openTelemetry) {", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539945483", "createdAt": "2020-12-10T07:47:31Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDY5OTY0OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwODo1OTowOVrOIC-S-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwODoxMjo1NVrOIDtmiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4ODczMA==", "bodyText": "Do we want to have default exporter?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539988730", "createdAt": "2020-12-10T08:59:09Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQyMzkxOA==", "bodyText": "My opinion: no. But, I'm certainly up to being convinced otherwise.\nMy reasoning is: people are going to try out the SDK on their local laptops first (probably), and if the default is to point at Otlp, they'll just get a bunch of errors in their logs.\nI could be convinced that the default could be the logging exporter...that seems like an option that wouldn't break anybody and make it clear what's happening.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540423918", "createdAt": "2020-12-10T19:05:36Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4ODczMA=="}, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc2Mzc4NA==", "bodyText": "Agree with @jkwatson on either no default, or default to logging, no real opinion on either though. I think a default for the agent (or any auto configuration layer) makes more sense than in the SDK proper.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540763784", "createdAt": "2020-12-11T08:12:55Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4ODczMA=="}, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDcwMjU3OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwODo1OTozNVrOIC-Ugg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwODo1OTozNVrOIC-Ugg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4OTEyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - Exports spans using OTLP to spans-service\n          \n          \n            \n            - Exports spans using OTLP to `spans-service`", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539989122", "createdAt": "2020-12-10T08:59:35Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDcwNjIxOnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOTowMDoyN1rOIC-WxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOTozNDoxM1rOIC_zjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4OTcwMQ==", "bodyText": "What about propagation?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539989701", "createdAt": "2020-12-10T09:00:27Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAxMzQ1NA==", "bodyText": "Thanks for reminder, forgot about it :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540013454", "createdAt": "2020-12-10T09:34:13Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4OTcwMQ=="}, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDcwOTU0OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOTowMToxMlrOIC-YxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOTozNjoxNFrOIC_5Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5MDIxMw==", "bodyText": "batching becomes the property of exporters?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539990213", "createdAt": "2020-12-10T09:01:12Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAxNDg5MA==", "bodyText": "It's a random idea - more that batching configuration is the job of exporter configuration. One goal was to make it more obvious when an exporter is tied to a batching (or not) strategy. Another is that it really hurts right now that we have to set timeout settings on two objects - a good way of getting rid of that would be a huge win!\nBut as with the comment about async processor this might be too limiting so not sure about it.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540014890", "createdAt": "2020-12-10T09:36:14Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5MDIxMw=="}, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDcxMTkzOnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOTowMTo0M1rOIC-aJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOTowMTo0M1rOIC-aJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5MDU2Nw==", "bodyText": "I like this", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539990567", "createdAt": "2020-12-10T09:01:43Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDcxODI1OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOTowMzoxNFrOIC-d7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwODoxNTo1NFrOIDtssA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5MTUzNA==", "bodyText": "How do you plan to chain SpanProcessor.end() calls?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539991534", "createdAt": "2020-12-10T09:03:14Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAxOTgwMQ==", "bodyText": "This proposal doesn't address the issue of not being able to have branching SpanProcessor. It just calls the processors in order, but trying to help with the exporter gotcha by making sure it comes at the end.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540019801", "createdAt": "2020-12-10T09:42:43Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5MTUzNA=="}, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAyMzA1NA==", "bodyText": "This seems to be as violating spec, et least formally", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540023054", "createdAt": "2020-12-10T09:47:14Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5MTUzNA=="}, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc2NTM2MA==", "bodyText": "Just to confirm my understanding, are we already violating the spec or did something change with this proposal?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540765360", "createdAt": "2020-12-11T08:15:54Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5MTUzNA=="}, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDcyODA5OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOTowNToyNFrOIC-jww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1Mzo1NVrOIDYZ9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5MzAyNw==", "bodyText": "I think we bundle two types here: authors of custom exporters/samplers and frameworks authors. The latter will handle configuration, but the former will just write a component according to an interface.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539993027", "createdAt": "2020-12-10T09:05:24Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxNjUwMA==", "bodyText": "the framework authors might need to do both (see Sleuth), but your point is still a good one.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540416500", "createdAt": "2020-12-10T18:53:55Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5MzAyNw=="}, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDc0MTU5OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOTowODoyM1rOIC-rwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOTowODoyM1rOIC-rwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5NTA3Mw==", "bodyText": "I agree with this section, but not with \"easy-to-reason lifecycle\". Shared instance kept in a field will break if somebody somewhere calls shutdown on the same shared instance.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539995073", "createdAt": "2020-12-10T09:08:23Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 254}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDc2MjI2OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOToxMzowMVrOIC-3xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOToxMzowMVrOIC-3xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5ODE1MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            See special note with Java Agent below though.\n          \n          \n            \n            See special note about Java Agent below though.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539998151", "createdAt": "2020-12-10T09:13:01Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 273}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDc3NTQ4OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOToxNTo1NlrOIC-_jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOToxNTo1NlrOIC-_jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAwMDE0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n          \n          \n            \n                tracer = openTelemetry.getTracerProvider().get(\"spanexporter\");", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540000140", "createdAt": "2020-12-10T09:15:56Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 299}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDc5NjY2OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOToyMDoyM1rOIC_L6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOToyMDoyM1rOIC_L6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAwMzMwNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The above presents programmatic configuration for the SDK and proposeds that the core SDK has no\n          \n          \n            \n            The above presents programmatic configuration for the SDK and proposes that the core SDK has no", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540003305", "createdAt": "2020-12-10T09:20:23Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+\n+## Auto-configuration\n+\n+The above presents programmatic configuration for the SDK and proposeds that the core SDK has no", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 399}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDgwNTI5OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOToyMjowNVrOIC_RCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOTo0ODoyNlrOIDAcsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAwNDYxNg==", "bodyText": "Wait :) I understand your purpose and mostly support it, but configuration from environment is useful. If core SDK does not support (which is fine), we may need an example of how one can achieve it.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540004616", "createdAt": "2020-12-10T09:22:05Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+\n+## Auto-configuration\n+\n+The above presents programmatic configuration for the SDK and proposeds that the core SDK has no\n+other mechanism for configuration. There is no SPI nor processing of environment variables or", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 400}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAyMzk4NA==", "bodyText": "Agree it is a decision on whether we prioritize the \"wrapper artifact\" I mentioned below. But do want to move it to a different layer.\nFor a while I thought this sort of wrapper is very important. But after imagining integrating OTel into my framework I realized I wouldn't use it I need to own the configuration mechanism. But maybe just me (and javaagent) :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540023984", "createdAt": "2020-12-10T09:48:26Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+\n+## Auto-configuration\n+\n+The above presents programmatic configuration for the SDK and proposeds that the core SDK has no\n+other mechanism for configuration. There is no SPI nor processing of environment variables or", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAwNDYxNg=="}, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 400}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MDgyOTE5OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOToyNzowOFrOIC_fGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwODoyMTo0NVrOIDt5CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAwODIxOA==", "bodyText": "I got very confused by this section. It seems like configuration duplication. What if I by mistake do both OpenTelemetrySdk.builder().xxxxx as above and DefaultOpenTelemetry.builder().xxxx as below?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540008218", "createdAt": "2020-12-10T09:27:08Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+\n+## Auto-configuration\n+\n+The above presents programmatic configuration for the SDK and proposeds that the core SDK has no\n+other mechanism for configuration. There is no SPI nor processing of environment variables or\n+system properties. There are many mechanisms for configuration, for example Spring Boot. \n+Integration with these systems becomes easier to reason about if we consider auto-configuration at\n+a layer above the core SDK.\n+\n+### Java Auto-Instrumentation Agent\n+\n+Java Auto-Instrumentation Agent is the primary means of automatically configuring the SDK. It\n+contains system properties, environment variables, and SPIs for allowing a user to have a fully\n+setup tracing configuration just by applying the agent. In fact, the agent does not even allow a\n+user to use the SDK directly, actively blocking it. Instead of having a situation where some\n+configuration is automatic in the core SDK and some in the agent, we can move it all to the agent.\n+The agent already exposes exporter SPIs - it can also expose SPIs for customization of the SDK\n+components that are manually configured above.\n+\n+- We could consider having a very similar autoconfiguration wrapper artifact as an SDK extension too.\n+But we would assume the core SDK is always manually configured.\n+\n+To allow users of the agent to apply tracing to their own code, the agent should attempt to\n+instrument dependency injection to provide an instance of `OpenTelemetry` using the agent-configured\n+SDK, for example it should add it to the Spring `ApplicationContext`. For cases where dependency\n+injection is not available, though, there is no option but to provide access to the SDK through a\n+global variable. We can expect such usage to still function correctly even if the agent is removed\n+and a different configuration mechanism is used, such as manual configuration as above, or Spring\n+Sleuth.\n+\n+### Spring Sleuth\n+\n+[Spring Sleuth](https://spring.io/projects/spring-cloud-sleuth) (or any similar observability-aware server framework such as \n+[curio-server-framework](https://github.com/curioswitch/curiostack/blob/master/common/server/framework/src/main/java/org/curioswitch/common/server/framework/monitoring/MonitoringModule.java)\n+or internal frameworks developed by devops teams at companies) is also a mechanism for automatically\n+configuring the SDK. In general, we would expect Sleuth users to not be using the java agent.\n+\n+Examples of how Sleuth could work are presented above in examples using `@Bean`. In particular, we\n+expect it to have its own set of configuration properties - by making sure we don't implement\n+configuration properties in the core SDK, only configuration layers like the agent or a possible\n+configuration wrapper, we avoid the possibility of confusion by having duplicate variables (in\n+practice, OpenTelemetry naming would likely be ignored and overwritten by Spring naming).\n+\n+## Partial SDKs", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 439}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAyOTMyMw==", "bodyText": "OpenTelwetrySdk is only present in the full SDK artifact (-all). So I guess it won't be there with a partial SDK? If this was the source of confusion would adding that point here help?\nOr is it potential confusion for full SDK users having both entry points? I don't think our repo should have any documentation related to DefaultOpenTelemetry. Maybe even hide it from JavaDoc. Full SDK users use OpenTelemetrySdk that's it, and it's all we support. Supporting partial SDK is up to the authors of partial SDK components IMO.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540029323", "createdAt": "2020-12-10T09:56:05Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+\n+## Auto-configuration\n+\n+The above presents programmatic configuration for the SDK and proposeds that the core SDK has no\n+other mechanism for configuration. There is no SPI nor processing of environment variables or\n+system properties. There are many mechanisms for configuration, for example Spring Boot. \n+Integration with these systems becomes easier to reason about if we consider auto-configuration at\n+a layer above the core SDK.\n+\n+### Java Auto-Instrumentation Agent\n+\n+Java Auto-Instrumentation Agent is the primary means of automatically configuring the SDK. It\n+contains system properties, environment variables, and SPIs for allowing a user to have a fully\n+setup tracing configuration just by applying the agent. In fact, the agent does not even allow a\n+user to use the SDK directly, actively blocking it. Instead of having a situation where some\n+configuration is automatic in the core SDK and some in the agent, we can move it all to the agent.\n+The agent already exposes exporter SPIs - it can also expose SPIs for customization of the SDK\n+components that are manually configured above.\n+\n+- We could consider having a very similar autoconfiguration wrapper artifact as an SDK extension too.\n+But we would assume the core SDK is always manually configured.\n+\n+To allow users of the agent to apply tracing to their own code, the agent should attempt to\n+instrument dependency injection to provide an instance of `OpenTelemetry` using the agent-configured\n+SDK, for example it should add it to the Spring `ApplicationContext`. For cases where dependency\n+injection is not available, though, there is no option but to provide access to the SDK through a\n+global variable. We can expect such usage to still function correctly even if the agent is removed\n+and a different configuration mechanism is used, such as manual configuration as above, or Spring\n+Sleuth.\n+\n+### Spring Sleuth\n+\n+[Spring Sleuth](https://spring.io/projects/spring-cloud-sleuth) (or any similar observability-aware server framework such as \n+[curio-server-framework](https://github.com/curioswitch/curiostack/blob/master/common/server/framework/src/main/java/org/curioswitch/common/server/framework/monitoring/MonitoringModule.java)\n+or internal frameworks developed by devops teams at companies) is also a mechanism for automatically\n+configuring the SDK. In general, we would expect Sleuth users to not be using the java agent.\n+\n+Examples of how Sleuth could work are presented above in examples using `@Bean`. In particular, we\n+expect it to have its own set of configuration properties - by making sure we don't implement\n+configuration properties in the core SDK, only configuration layers like the agent or a possible\n+configuration wrapper, we avoid the possibility of confusion by having duplicate variables (in\n+practice, OpenTelemetry naming would likely be ignored and overwritten by Spring naming).\n+\n+## Partial SDKs", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAwODIxOA=="}, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 439}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA0OTE4Mw==", "bodyText": "The second part, yes. So you are talking here about some other (partial) implementation of the SDK, not this one?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540049183", "createdAt": "2020-12-10T10:22:28Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+\n+## Auto-configuration\n+\n+The above presents programmatic configuration for the SDK and proposeds that the core SDK has no\n+other mechanism for configuration. There is no SPI nor processing of environment variables or\n+system properties. There are many mechanisms for configuration, for example Spring Boot. \n+Integration with these systems becomes easier to reason about if we consider auto-configuration at\n+a layer above the core SDK.\n+\n+### Java Auto-Instrumentation Agent\n+\n+Java Auto-Instrumentation Agent is the primary means of automatically configuring the SDK. It\n+contains system properties, environment variables, and SPIs for allowing a user to have a fully\n+setup tracing configuration just by applying the agent. In fact, the agent does not even allow a\n+user to use the SDK directly, actively blocking it. Instead of having a situation where some\n+configuration is automatic in the core SDK and some in the agent, we can move it all to the agent.\n+The agent already exposes exporter SPIs - it can also expose SPIs for customization of the SDK\n+components that are manually configured above.\n+\n+- We could consider having a very similar autoconfiguration wrapper artifact as an SDK extension too.\n+But we would assume the core SDK is always manually configured.\n+\n+To allow users of the agent to apply tracing to their own code, the agent should attempt to\n+instrument dependency injection to provide an instance of `OpenTelemetry` using the agent-configured\n+SDK, for example it should add it to the Spring `ApplicationContext`. For cases where dependency\n+injection is not available, though, there is no option but to provide access to the SDK through a\n+global variable. We can expect such usage to still function correctly even if the agent is removed\n+and a different configuration mechanism is used, such as manual configuration as above, or Spring\n+Sleuth.\n+\n+### Spring Sleuth\n+\n+[Spring Sleuth](https://spring.io/projects/spring-cloud-sleuth) (or any similar observability-aware server framework such as \n+[curio-server-framework](https://github.com/curioswitch/curiostack/blob/master/common/server/framework/src/main/java/org/curioswitch/common/server/framework/monitoring/MonitoringModule.java)\n+or internal frameworks developed by devops teams at companies) is also a mechanism for automatically\n+configuring the SDK. In general, we would expect Sleuth users to not be using the java agent.\n+\n+Examples of how Sleuth could work are presented above in examples using `@Bean`. In particular, we\n+expect it to have its own set of configuration properties - by making sure we don't implement\n+configuration properties in the core SDK, only configuration layers like the agent or a possible\n+configuration wrapper, we avoid the possibility of confusion by having duplicate variables (in\n+practice, OpenTelemetry naming would likely be ignored and overwritten by Spring naming).\n+\n+## Partial SDKs", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAwODIxOA=="}, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 439}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA4MDgyNw==", "bodyText": "Not sure what you're referring to with \"this one\" - my hypothetical micrometer SDK?\nSo I am imagining an app with dependencies on opentelemetry-sdk-trace and opentelemetry-micrometer and use DefaultOpenTelemetry.\nOr there might be a opentelemetry-sdk-with-micrometer which depends on the above and provides OpenTelemetrySdkWithMicrometerBuilder. Obtuse but just an example of what I was thinking thinking here.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540080827", "createdAt": "2020-12-10T11:09:39Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+\n+## Auto-configuration\n+\n+The above presents programmatic configuration for the SDK and proposeds that the core SDK has no\n+other mechanism for configuration. There is no SPI nor processing of environment variables or\n+system properties. There are many mechanisms for configuration, for example Spring Boot. \n+Integration with these systems becomes easier to reason about if we consider auto-configuration at\n+a layer above the core SDK.\n+\n+### Java Auto-Instrumentation Agent\n+\n+Java Auto-Instrumentation Agent is the primary means of automatically configuring the SDK. It\n+contains system properties, environment variables, and SPIs for allowing a user to have a fully\n+setup tracing configuration just by applying the agent. In fact, the agent does not even allow a\n+user to use the SDK directly, actively blocking it. Instead of having a situation where some\n+configuration is automatic in the core SDK and some in the agent, we can move it all to the agent.\n+The agent already exposes exporter SPIs - it can also expose SPIs for customization of the SDK\n+components that are manually configured above.\n+\n+- We could consider having a very similar autoconfiguration wrapper artifact as an SDK extension too.\n+But we would assume the core SDK is always manually configured.\n+\n+To allow users of the agent to apply tracing to their own code, the agent should attempt to\n+instrument dependency injection to provide an instance of `OpenTelemetry` using the agent-configured\n+SDK, for example it should add it to the Spring `ApplicationContext`. For cases where dependency\n+injection is not available, though, there is no option but to provide access to the SDK through a\n+global variable. We can expect such usage to still function correctly even if the agent is removed\n+and a different configuration mechanism is used, such as manual configuration as above, or Spring\n+Sleuth.\n+\n+### Spring Sleuth\n+\n+[Spring Sleuth](https://spring.io/projects/spring-cloud-sleuth) (or any similar observability-aware server framework such as \n+[curio-server-framework](https://github.com/curioswitch/curiostack/blob/master/common/server/framework/src/main/java/org/curioswitch/common/server/framework/monitoring/MonitoringModule.java)\n+or internal frameworks developed by devops teams at companies) is also a mechanism for automatically\n+configuring the SDK. In general, we would expect Sleuth users to not be using the java agent.\n+\n+Examples of how Sleuth could work are presented above in examples using `@Bean`. In particular, we\n+expect it to have its own set of configuration properties - by making sure we don't implement\n+configuration properties in the core SDK, only configuration layers like the agent or a possible\n+configuration wrapper, we avoid the possibility of confusion by having duplicate variables (in\n+practice, OpenTelemetry naming would likely be ignored and overwritten by Spring naming).\n+\n+## Partial SDKs", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAwODIxOA=="}, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 439}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA4NjcwOQ==", "bodyText": "\"this one\" is \"this repo\". I mean, we provide full SDK and we don't plan to provide partial SDKs, right? Partial SDKs come from outside, right?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540086709", "createdAt": "2020-12-10T11:18:58Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+\n+## Auto-configuration\n+\n+The above presents programmatic configuration for the SDK and proposeds that the core SDK has no\n+other mechanism for configuration. There is no SPI nor processing of environment variables or\n+system properties. There are many mechanisms for configuration, for example Spring Boot. \n+Integration with these systems becomes easier to reason about if we consider auto-configuration at\n+a layer above the core SDK.\n+\n+### Java Auto-Instrumentation Agent\n+\n+Java Auto-Instrumentation Agent is the primary means of automatically configuring the SDK. It\n+contains system properties, environment variables, and SPIs for allowing a user to have a fully\n+setup tracing configuration just by applying the agent. In fact, the agent does not even allow a\n+user to use the SDK directly, actively blocking it. Instead of having a situation where some\n+configuration is automatic in the core SDK and some in the agent, we can move it all to the agent.\n+The agent already exposes exporter SPIs - it can also expose SPIs for customization of the SDK\n+components that are manually configured above.\n+\n+- We could consider having a very similar autoconfiguration wrapper artifact as an SDK extension too.\n+But we would assume the core SDK is always manually configured.\n+\n+To allow users of the agent to apply tracing to their own code, the agent should attempt to\n+instrument dependency injection to provide an instance of `OpenTelemetry` using the agent-configured\n+SDK, for example it should add it to the Spring `ApplicationContext`. For cases where dependency\n+injection is not available, though, there is no option but to provide access to the SDK through a\n+global variable. We can expect such usage to still function correctly even if the agent is removed\n+and a different configuration mechanism is used, such as manual configuration as above, or Spring\n+Sleuth.\n+\n+### Spring Sleuth\n+\n+[Spring Sleuth](https://spring.io/projects/spring-cloud-sleuth) (or any similar observability-aware server framework such as \n+[curio-server-framework](https://github.com/curioswitch/curiostack/blob/master/common/server/framework/src/main/java/org/curioswitch/common/server/framework/monitoring/MonitoringModule.java)\n+or internal frameworks developed by devops teams at companies) is also a mechanism for automatically\n+configuring the SDK. In general, we would expect Sleuth users to not be using the java agent.\n+\n+Examples of how Sleuth could work are presented above in examples using `@Bean`. In particular, we\n+expect it to have its own set of configuration properties - by making sure we don't implement\n+configuration properties in the core SDK, only configuration layers like the agent or a possible\n+configuration wrapper, we avoid the possibility of confusion by having duplicate variables (in\n+practice, OpenTelemetry naming would likely be ignored and overwritten by Spring naming).\n+\n+## Partial SDKs", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAwODIxOA=="}, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 439}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE3MDY0MQ==", "bodyText": "Ah yeah that's what I'm thinking", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540170641", "createdAt": "2020-12-10T13:32:23Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+\n+## Auto-configuration\n+\n+The above presents programmatic configuration for the SDK and proposeds that the core SDK has no\n+other mechanism for configuration. There is no SPI nor processing of environment variables or\n+system properties. There are many mechanisms for configuration, for example Spring Boot. \n+Integration with these systems becomes easier to reason about if we consider auto-configuration at\n+a layer above the core SDK.\n+\n+### Java Auto-Instrumentation Agent\n+\n+Java Auto-Instrumentation Agent is the primary means of automatically configuring the SDK. It\n+contains system properties, environment variables, and SPIs for allowing a user to have a fully\n+setup tracing configuration just by applying the agent. In fact, the agent does not even allow a\n+user to use the SDK directly, actively blocking it. Instead of having a situation where some\n+configuration is automatic in the core SDK and some in the agent, we can move it all to the agent.\n+The agent already exposes exporter SPIs - it can also expose SPIs for customization of the SDK\n+components that are manually configured above.\n+\n+- We could consider having a very similar autoconfiguration wrapper artifact as an SDK extension too.\n+But we would assume the core SDK is always manually configured.\n+\n+To allow users of the agent to apply tracing to their own code, the agent should attempt to\n+instrument dependency injection to provide an instance of `OpenTelemetry` using the agent-configured\n+SDK, for example it should add it to the Spring `ApplicationContext`. For cases where dependency\n+injection is not available, though, there is no option but to provide access to the SDK through a\n+global variable. We can expect such usage to still function correctly even if the agent is removed\n+and a different configuration mechanism is used, such as manual configuration as above, or Spring\n+Sleuth.\n+\n+### Spring Sleuth\n+\n+[Spring Sleuth](https://spring.io/projects/spring-cloud-sleuth) (or any similar observability-aware server framework such as \n+[curio-server-framework](https://github.com/curioswitch/curiostack/blob/master/common/server/framework/src/main/java/org/curioswitch/common/server/framework/monitoring/MonitoringModule.java)\n+or internal frameworks developed by devops teams at companies) is also a mechanism for automatically\n+configuring the SDK. In general, we would expect Sleuth users to not be using the java agent.\n+\n+Examples of how Sleuth could work are presented above in examples using `@Bean`. In particular, we\n+expect it to have its own set of configuration properties - by making sure we don't implement\n+configuration properties in the core SDK, only configuration layers like the agent or a possible\n+configuration wrapper, we avoid the possibility of confusion by having duplicate variables (in\n+practice, OpenTelemetry naming would likely be ignored and overwritten by Spring naming).\n+\n+## Partial SDKs", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAwODIxOA=="}, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 439}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3MzUyOQ==", "bodyText": "not true, though, since we'll be pulling metrics out of the \"main\" SDK and only providing that piece as an \"experimental\" signal until it's ready to go. We'll have a \"partial\" SDK for metrics, at least in some sense.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540573529", "createdAt": "2020-12-10T23:21:20Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+\n+## Auto-configuration\n+\n+The above presents programmatic configuration for the SDK and proposeds that the core SDK has no\n+other mechanism for configuration. There is no SPI nor processing of environment variables or\n+system properties. There are many mechanisms for configuration, for example Spring Boot. \n+Integration with these systems becomes easier to reason about if we consider auto-configuration at\n+a layer above the core SDK.\n+\n+### Java Auto-Instrumentation Agent\n+\n+Java Auto-Instrumentation Agent is the primary means of automatically configuring the SDK. It\n+contains system properties, environment variables, and SPIs for allowing a user to have a fully\n+setup tracing configuration just by applying the agent. In fact, the agent does not even allow a\n+user to use the SDK directly, actively blocking it. Instead of having a situation where some\n+configuration is automatic in the core SDK and some in the agent, we can move it all to the agent.\n+The agent already exposes exporter SPIs - it can also expose SPIs for customization of the SDK\n+components that are manually configured above.\n+\n+- We could consider having a very similar autoconfiguration wrapper artifact as an SDK extension too.\n+But we would assume the core SDK is always manually configured.\n+\n+To allow users of the agent to apply tracing to their own code, the agent should attempt to\n+instrument dependency injection to provide an instance of `OpenTelemetry` using the agent-configured\n+SDK, for example it should add it to the Spring `ApplicationContext`. For cases where dependency\n+injection is not available, though, there is no option but to provide access to the SDK through a\n+global variable. We can expect such usage to still function correctly even if the agent is removed\n+and a different configuration mechanism is used, such as manual configuration as above, or Spring\n+Sleuth.\n+\n+### Spring Sleuth\n+\n+[Spring Sleuth](https://spring.io/projects/spring-cloud-sleuth) (or any similar observability-aware server framework such as \n+[curio-server-framework](https://github.com/curioswitch/curiostack/blob/master/common/server/framework/src/main/java/org/curioswitch/common/server/framework/monitoring/MonitoringModule.java)\n+or internal frameworks developed by devops teams at companies) is also a mechanism for automatically\n+configuring the SDK. In general, we would expect Sleuth users to not be using the java agent.\n+\n+Examples of how Sleuth could work are presented above in examples using `@Bean`. In particular, we\n+expect it to have its own set of configuration properties - by making sure we don't implement\n+configuration properties in the core SDK, only configuration layers like the agent or a possible\n+configuration wrapper, we avoid the possibility of confusion by having duplicate variables (in\n+practice, OpenTelemetry naming would likely be ignored and overwritten by Spring naming).\n+\n+## Partial SDKs", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAwODIxOA=="}, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 439}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc2ODUyMQ==", "bodyText": "Hmm - I guess one difference with the experimental signals is the API won't have them either, so DefaultOpenTelemetry.builder() also wouldn't be used, they really just live completely by themselves.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540768521", "createdAt": "2020-12-11T08:21:45Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+\n+## Auto-configuration\n+\n+The above presents programmatic configuration for the SDK and proposeds that the core SDK has no\n+other mechanism for configuration. There is no SPI nor processing of environment variables or\n+system properties. There are many mechanisms for configuration, for example Spring Boot. \n+Integration with these systems becomes easier to reason about if we consider auto-configuration at\n+a layer above the core SDK.\n+\n+### Java Auto-Instrumentation Agent\n+\n+Java Auto-Instrumentation Agent is the primary means of automatically configuring the SDK. It\n+contains system properties, environment variables, and SPIs for allowing a user to have a fully\n+setup tracing configuration just by applying the agent. In fact, the agent does not even allow a\n+user to use the SDK directly, actively blocking it. Instead of having a situation where some\n+configuration is automatic in the core SDK and some in the agent, we can move it all to the agent.\n+The agent already exposes exporter SPIs - it can also expose SPIs for customization of the SDK\n+components that are manually configured above.\n+\n+- We could consider having a very similar autoconfiguration wrapper artifact as an SDK extension too.\n+But we would assume the core SDK is always manually configured.\n+\n+To allow users of the agent to apply tracing to their own code, the agent should attempt to\n+instrument dependency injection to provide an instance of `OpenTelemetry` using the agent-configured\n+SDK, for example it should add it to the Spring `ApplicationContext`. For cases where dependency\n+injection is not available, though, there is no option but to provide access to the SDK through a\n+global variable. We can expect such usage to still function correctly even if the agent is removed\n+and a different configuration mechanism is used, such as manual configuration as above, or Spring\n+Sleuth.\n+\n+### Spring Sleuth\n+\n+[Spring Sleuth](https://spring.io/projects/spring-cloud-sleuth) (or any similar observability-aware server framework such as \n+[curio-server-framework](https://github.com/curioswitch/curiostack/blob/master/common/server/framework/src/main/java/org/curioswitch/common/server/framework/monitoring/MonitoringModule.java)\n+or internal frameworks developed by devops teams at companies) is also a mechanism for automatically\n+configuring the SDK. In general, we would expect Sleuth users to not be using the java agent.\n+\n+Examples of how Sleuth could work are presented above in examples using `@Bean`. In particular, we\n+expect it to have its own set of configuration properties - by making sure we don't implement\n+configuration properties in the core SDK, only configuration layers like the agent or a possible\n+configuration wrapper, we avoid the possibility of confusion by having duplicate variables (in\n+practice, OpenTelemetry naming would likely be ignored and overwritten by Spring naming).\n+\n+## Partial SDKs", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAwODIxOA=="}, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 439}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzUyMjI2OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1MzowNlrOIDYX-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1MzowNlrOIDYX-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxNTk5Mw==", "bodyText": "this is an excellent call-out, and something we all definitely need to keep in mind. Sometimes this will mean we add \"more than one way to do things\" because it will make app developers lives easier, even if it makes our jobs as maintainers more annoying/painful.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540415993", "createdAt": "2020-12-10T18:53:06Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzUyOTcyOnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1NDo1MVrOIDYcbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1NDo1MVrOIDYcbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxNzEzNA==", "bodyText": "is performance at configuration time really much of an issue and something we should worry about?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540417134", "createdAt": "2020-12-10T18:54:51Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzUzMTU1OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1NToyMVrOIDYdkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1NToyMVrOIDYdkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxNzQyNQ==", "bodyText": "is this a \"single entrypoint\" per use-case, or only a single entrypoint, period?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540417425", "createdAt": "2020-12-10T18:55:21Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzU0ODI1OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1OToxNFrOIDYndw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1OToxNFrOIDYndw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxOTk1OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The SDK consists of configuration options for all the signals it supports. Users all have different\n          \n          \n            \n            The SDK exposes configuration options for all the signals it supports. Users all have different", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540419959", "createdAt": "2020-12-10T18:59:14Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzU0OTg1OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1OTozNFrOIDYoVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1OTozNFrOIDYoVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQyMDE4Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            requirements for how they use the SDK, for example they may use different exporters depending on\n          \n          \n            \n            requirements for how they use the SDK; for example they may use different exporters depending on", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540420182", "createdAt": "2020-12-10T18:59:34Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzY0MzE1OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxOToyMjoyMVrOIDZfkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwODoxNDowNVrOIDto4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQzNDMyMg==", "bodyText": "This example mixes two signals, which is good. The question is: are we likely to end up with an unwieldy builder if it contains the configuration for multiple signals, especially when we (eventually) add logs in here as well.\nWould we be better off (as I think Bogdan has suggested) requiring the SDK components for each signal to be configured indivually, then have the OpenTelemetrySdk builder only compose the other components? I can see pros and cons.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540434322", "createdAt": "2020-12-10T19:22:21Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc2NDM4NQ==", "bodyText": "It's unfortunate that the same setting has to be specified multiple times, but I think we have found reasons to stick with the signal-independent knobs.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540764385", "createdAt": "2020-12-11T08:14:05Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQzNDMyMg=="}, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzcyNzA1OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxOTo0MjoxNVrOIDaQnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwNzoxNDo0NVrOIDr_Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ0Njg3Ng==", "bodyText": "Here is a sticking point that I see with the omnibus build-everything-at-the-OpenTelemetrySdk-level: For 1.0, we need to remove metrics from the OpenTelemetrySdk, which will mean that we must provide a way to build the pre-release MeterSdkProvider in a stand-alone manner. And, there may (probably will) be people who only want to use one of the signals, without the omnibus OpenTelemetrySdk, so we'll need to provide individual builders for each of the signals.\nIf we need to provide individual builders for each SDK signal, then are we ok with having both ways of building things? If so, then \ud83d\udc4d . This does seem to be a case where we should favor the end-user and make sure that they can do it either way.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540446876", "createdAt": "2020-12-10T19:42:15Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDczNzI4Nw==", "bodyText": "If we need to provide a way to configure and use just some of the signals, then I think that we should go this way:\n\nrequiring the SDK components for each signal to be configured indivually, then have the OpenTelemetrySdk builder only compose the other components\n\nThe problem with supporting mix and match is this piece of code: #2231 (comment) .", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540737287", "createdAt": "2020-12-11T07:14:45Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ0Njg3Ng=="}, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NDUyODY4OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzowNDo0OFrOIDhgmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzowNDo0OFrOIDhgmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2NTY1OA==", "bodyText": "obviously would need a null check here for the tracer, but that's a nit, obviously", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540565658", "createdAt": "2020-12-10T23:04:48Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 304}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NDU4OTUwOnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzoyMjo0OVrOIDiB_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzoyMjo0OVrOIDiB_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3NDIwNA==", "bodyText": "this is definitely something I hadn't pondered. This wouldn't work with pre-release signals, though, unless the pre-release metrics SDK (for instance) also provided an extension to the OpenTelemetry interface, too. \ud83e\udd14", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540574204", "createdAt": "2020-12-10T23:22:49Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+\n+## Auto-configuration\n+\n+The above presents programmatic configuration for the SDK and proposeds that the core SDK has no\n+other mechanism for configuration. There is no SPI nor processing of environment variables or\n+system properties. There are many mechanisms for configuration, for example Spring Boot. \n+Integration with these systems becomes easier to reason about if we consider auto-configuration at\n+a layer above the core SDK.\n+\n+### Java Auto-Instrumentation Agent\n+\n+Java Auto-Instrumentation Agent is the primary means of automatically configuring the SDK. It\n+contains system properties, environment variables, and SPIs for allowing a user to have a fully\n+setup tracing configuration just by applying the agent. In fact, the agent does not even allow a\n+user to use the SDK directly, actively blocking it. Instead of having a situation where some\n+configuration is automatic in the core SDK and some in the agent, we can move it all to the agent.\n+The agent already exposes exporter SPIs - it can also expose SPIs for customization of the SDK\n+components that are manually configured above.\n+\n+- We could consider having a very similar autoconfiguration wrapper artifact as an SDK extension too.\n+But we would assume the core SDK is always manually configured.\n+\n+To allow users of the agent to apply tracing to their own code, the agent should attempt to\n+instrument dependency injection to provide an instance of `OpenTelemetry` using the agent-configured\n+SDK, for example it should add it to the Spring `ApplicationContext`. For cases where dependency\n+injection is not available, though, there is no option but to provide access to the SDK through a\n+global variable. We can expect such usage to still function correctly even if the agent is removed\n+and a different configuration mechanism is used, such as manual configuration as above, or Spring\n+Sleuth.\n+\n+### Spring Sleuth\n+\n+[Spring Sleuth](https://spring.io/projects/spring-cloud-sleuth) (or any similar observability-aware server framework such as \n+[curio-server-framework](https://github.com/curioswitch/curiostack/blob/master/common/server/framework/src/main/java/org/curioswitch/common/server/framework/monitoring/MonitoringModule.java)\n+or internal frameworks developed by devops teams at companies) is also a mechanism for automatically\n+configuring the SDK. In general, we would expect Sleuth users to not be using the java agent.\n+\n+Examples of how Sleuth could work are presented above in examples using `@Bean`. In particular, we\n+expect it to have its own set of configuration properties - by making sure we don't implement\n+configuration properties in the core SDK, only configuration layers like the agent or a possible\n+configuration wrapper, we avoid the possibility of confusion by having duplicate variables (in\n+practice, OpenTelemetry naming would likely be ignored and overwritten by Spring naming).\n+\n+## Partial SDKs\n+\n+We allow implementing particular signals of the OpenTelemetry API without using our SDK. For example,\n+a MeterProvider may be implemented with micrometer. For this reason, each signal must also present\n+all of its options in the form of, e.g., `TracerSdkProviderBuilder`. We expect the vast majority of\n+users to use `OpenTelemetrySdkBuilder` - while there is some duplication with the signal provider\n+builder, it is work maintainers can do to present the simplest interface for the most common use\n+case of using the whole SDK.\n+\n+Without SPI, the way to initialize a partial SDK would be to use `DefaultOpenTelemetry`.\n+\n+```java\n+@Bean\n+public OpenTelemetry openTelemetry() {\n+  return DefaultOpenTelemetry.builder()\n+    .setTraceProvider(TracerSdkProvider.builder().build())\n+    .setMeterProvider(MicrometerProvider.builder().build())\n+    .build();\n+}\n+``` \n+\n+As this should be a fairly minor use case, and commonly handled by framework developers, this seems\n+reasonable. We can also hope that where it is important, it is the author of partial SDKs that\n+provide a one-stop-shop entrypoint.\n+\n+```java\n+@Bean\n+public OpenTelemetry openTelemetry() {\n+  return OpenTelemetrySdkWithMicrometer.builder()\n+    .addSpanExporter()\n+    .setMeterRegistry()\n+    .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 470}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NjIwOTA5OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwOToxMDo1OVrOIDvoXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwOToxMDo1OVrOIDvoXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5NzAyMg==", "bodyText": "Realized there's probably no point for this class, it could only help if it coordinates Resource sharing, etc.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540797022", "createdAt": "2020-12-11T09:10:59Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26e344b7711bab9ab03fd41a3170b70de81a436b"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwMDg1NTI2OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMlQwNDozMjo1N1rOIEadAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDozMzowOVrOIIHtdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ5ODYyNw==", "bodyText": "@jkwatson I had removed the auto-set as global due to controversy, but do think it's the best option in most cases. If the problem is mystery and surprise, then this naming, while obtuse, can make it clear. I would not have a normal build() method as that would reduce the discoverability of this mechanism - it has to be buildWithoutSetting or something similar to make sure a user makes a conscious decision without just assuming to use build().", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541498627", "createdAt": "2020-12-12T04:32:57Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjYzNjE4Nw==", "bodyText": "the only bit that might be confusing is that the 2nd user wouldn't set it as global, right?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r542636187", "createdAt": "2020-12-14T18:48:24Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ5ODYyNw=="}, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzODI0NA==", "bodyText": "Yeah - I think you're saying we need to document these methods well?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r543038244", "createdAt": "2020-12-15T04:31:26Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ5ODYyNw=="}, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM4NTg0Nw==", "bodyText": "lol. yes, and maybe the 2nd call to buildAndSetAsGlobal() would fail? Not sure what the should be, but that can be decided at a later date.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r545385847", "createdAt": "2020-12-17T20:33:09Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ5ODYyNw=="}, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwMDg1OTYwOnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMlQwNDozNjoyMlrOIEae1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMlQwNDozNjoyMlrOIEae1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ5OTA5Mw==", "bodyText": "@jkwatson I realized it could make sense to remove shutdown from the TracerSdkProvider. It seems like it could make some lifecycle woes simpler to reason about, maybe even enable toBuilder()?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541499093", "createdAt": "2020-12-12T04:36:22Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.\n+An alternative is to flatten all settings onto `OpenTelemetrySdkBuilder` - this has a downside that\n+it makes it very natural to create new tracer / meter providers for each configuration of the SDK,\n+which could result in a lot of duplication of resources like threads, workers, TCP connections. So\n+instead, this can make it clearer that those signals themselves are full-featured, and \n+`OpenTelemetry` is just a bag of signals.\n+\n+Keep in mind, reconfiguring `Clock` is expected to be an extremely uncommon operation.\n+\n+Another thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+    @Bean\n+    public Resource resource() {\n+        return Resource.getDefault().merge(CoolResource.getDefault());\n+    }\n+    \n+    @Bean\n+    public Clock otelClock() {\n+        return AtomicClock.create();\n+    }\n+\n+    @Bean\n+    public TracerSdkProvider tracerProvider(Resource resource, Clock clock, MonitoringConfig config) {\n+        return TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(config.getOtlpExporter().getEndpoint())\n+                    .setTimeout(config.getOtlpExporter().getTimeout())\n+                    .build())\n+                .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+                .setTimeout(config.getOtlpExporter().getTimeout())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(config.getZipkinExporter().getEndpoint())\n+                    .build())\n+                .build())\n+            .setTraceSampler(config.getSamplingRate() != 0 \n+               ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+    }\n+  \n+    @Bean\n+    public MeterSdkProvider meterProvider(Resource resource, Clock clock) {\n+        return MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public IntervalMetricReader metricReader(MeterSdkProvider meterProvider) {\n+        return IntervalMetricReader.builder()\n+            .addMetricProducer(meterProvider.getMetricProducer())\n+            .addMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public OpenTelemetry openTelemetry(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+           .addPropagator(B3Propagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+\n+    @Bean\n+    @ForJaeger\n+    public OpenTelemetry openTelemetryJaeger(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+  \n+    @Bean\n+    public AuthServiceStub authService(@ForJaeger OpenTelemetry openTelemetry, AuthConfig config) {\n+        return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+          .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+    }\n+    \n+    @Bean\n+    public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+        return TracingServletFilter.create(openTelemetry);\n+    }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason initialization ordering, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. It is expected that frameworks or end-users will set the SDK as the global to support\n+instrumentation that requires this.\n+\n+Before an SDK has been set, access to the global `OpenTelemetry` will return a no-op \n+`DefaultOpenTelemetry`. This is because it is possible library instrumentation is using the global,\n+and it may even use it during the processing of a request (rather than only at initialization time).\n+For this reason, we cannot throw an exception. Instead, if the SDK is detected on the classpath, we\n+will log a `SEVERE` warning once-only indicating the API has been accessed before the SDK configured\n+with directions on how a user could solve the problem. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note about Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+        tracer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+        Tracer tracer = this.tracer;\n+        if (tracer != null) {\n+          tracer.spanBuilder(\"export\").startSpan();\n+        }\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+    public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+        tracerProvider.addSpanExporter(exporter);\n+        components.add(exporter);\n+    }\n+    \n+    public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+        tracerProvider.setSampler(sampler);\n+        components.add(sampler);\n+    }\n+    \n+    public OpenTelemetry build() {\n+        OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+        for (OpenTelemetryComponent component : components) {\n+          component.setOpenTelemetry(sdk);\n+        }\n+    }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+    @Bean\n+    @ForSpanExporter\n+    public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+    }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+    private Lazy<Tracer> tracer;\n+    \n+    @Inject\n+    public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+    }\n+    \n+    @Override\n+    public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+    }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+## TracerSdkManagement\n+\n+With the proposal to make a configured SDK fully built rather than allowing configuration\n+mutability, the SDK management interface would only have `shutdown` and `forceFlush`. It seems\n+reasonable to actually remove `shutdown` from the `TracerSdkProvider` - the SDK provider is mostly\n+a bag of parts and has no intrinsic component, if instead components like `BatchSpanProcessor` and\n+`SpanExporter` implement `Closeable`, we can model shutdown as the responsibility of the creator of\n+the resources, which is idiomatic. In DI frameworks, this would generally be automatic. This would\n+prevent the case where two `TracerProvider` share an exporter and one of them is shutdown - when\n+shutting down the exporter, shut down the exporter.\n+\n+```java\n+public class MyApp {\n+ \n+    public static void main(String[] args) {\n+        try (OtlpGrpcSpanExporter otlpExporter = OtlpGrpcSpanExporter.builder().build();\n+              BatchSpanProcessor otlpProcessor = BatchSpanProcessor.builder(otlpExporter).build()) {\n+            OpenTelemetrySdk sdk = OpenTelemetrySdk.builder()\n+                .setTracerProvider(TracerSdkProvider.builder()\n+                                        .addSpanProcessor(otlpProcessor)\n+                                        .build())\n+                .build();\n+ \n+            Server server = Server.builder().setOpenTelemetry(sdk).build();\n+            server.listenAndServe();\n+        }\n+    }\n+\n+}\n+```\n+\n+```java\n+@Component\n+public class MyModule {\n+\n+    @Bean\n+    // If SpanExporter extends Closeable, it's automatically closed\n+    OtlpGrpcSpanExporter otlpExporter() {\n+        return OtlpGrpcSpanExporter.builder().build()\n+    }\n+   \n+    @Bean\n+    // If BatchSpanProcessor extends Closeable, it's automatically closed\n+    BatchSpanProcessor otlpSpanProcessor(OtlpGrpcSpanExporter otlpExporter) {\n+        return BatchSpanProcessor.builder(otlpExporter).build();\n+    }\n+ \n+    @Bean\n+    TracerSdkProvider tracerProvider(BatchSpanProcessor otlpSpanProcessor) {\n+        return TracerSdkProvider.builder().addSpanProcessor(otlpSpanProcessor).build();\n+    }\n+\n+    @Bean\n+    OpenTelemetrySdk openTelemetry(TracerSdkProvider tracerProvider) {\n+        return OpenTelemetrySdk.builder().setTracerProvider(tracerProvider).build();\n+    }\n+}\n+```\n+\n+The `OpenTelemetrySdk` and `TracerSdkProvider` are still exposed to provide access to `forceFlush`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 557}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwMDg2MDg0OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMlQwNDozNzowM1rOIEafWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxODo1NTo0MVrOIFgYzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ5OTIyNQ==", "bodyText": "@jkwatson API-only case", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541499225", "createdAt": "2020-12-12T04:37:03Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.\n+An alternative is to flatten all settings onto `OpenTelemetrySdkBuilder` - this has a downside that\n+it makes it very natural to create new tracer / meter providers for each configuration of the SDK,\n+which could result in a lot of duplication of resources like threads, workers, TCP connections. So\n+instead, this can make it clearer that those signals themselves are full-featured, and \n+`OpenTelemetry` is just a bag of signals.\n+\n+Keep in mind, reconfiguring `Clock` is expected to be an extremely uncommon operation.\n+\n+Another thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+    @Bean\n+    public Resource resource() {\n+        return Resource.getDefault().merge(CoolResource.getDefault());\n+    }\n+    \n+    @Bean\n+    public Clock otelClock() {\n+        return AtomicClock.create();\n+    }\n+\n+    @Bean\n+    public TracerSdkProvider tracerProvider(Resource resource, Clock clock, MonitoringConfig config) {\n+        return TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(config.getOtlpExporter().getEndpoint())\n+                    .setTimeout(config.getOtlpExporter().getTimeout())\n+                    .build())\n+                .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+                .setTimeout(config.getOtlpExporter().getTimeout())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(config.getZipkinExporter().getEndpoint())\n+                    .build())\n+                .build())\n+            .setTraceSampler(config.getSamplingRate() != 0 \n+               ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+    }\n+  \n+    @Bean\n+    public MeterSdkProvider meterProvider(Resource resource, Clock clock) {\n+        return MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public IntervalMetricReader metricReader(MeterSdkProvider meterProvider) {\n+        return IntervalMetricReader.builder()\n+            .addMetricProducer(meterProvider.getMetricProducer())\n+            .addMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public OpenTelemetry openTelemetry(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+           .addPropagator(B3Propagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+\n+    @Bean\n+    @ForJaeger\n+    public OpenTelemetry openTelemetryJaeger(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+  \n+    @Bean\n+    public AuthServiceStub authService(@ForJaeger OpenTelemetry openTelemetry, AuthConfig config) {\n+        return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+          .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+    }\n+    \n+    @Bean\n+    public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+        return TracingServletFilter.create(openTelemetry);\n+    }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason initialization ordering, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. It is expected that frameworks or end-users will set the SDK as the global to support\n+instrumentation that requires this.\n+\n+Before an SDK has been set, access to the global `OpenTelemetry` will return a no-op \n+`DefaultOpenTelemetry`. This is because it is possible library instrumentation is using the global,\n+and it may even use it during the processing of a request (rather than only at initialization time).\n+For this reason, we cannot throw an exception. Instead, if the SDK is detected on the classpath, we", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 363}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY0NDQyOQ==", "bodyText": "Thanks. This logging I think will be very helpful at finding where people are waiting until too late to set up their SDK. \ud83d\udc4d", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r542644429", "createdAt": "2020-12-14T18:55:41Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.\n+An alternative is to flatten all settings onto `OpenTelemetrySdkBuilder` - this has a downside that\n+it makes it very natural to create new tracer / meter providers for each configuration of the SDK,\n+which could result in a lot of duplication of resources like threads, workers, TCP connections. So\n+instead, this can make it clearer that those signals themselves are full-featured, and \n+`OpenTelemetry` is just a bag of signals.\n+\n+Keep in mind, reconfiguring `Clock` is expected to be an extremely uncommon operation.\n+\n+Another thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+    @Bean\n+    public Resource resource() {\n+        return Resource.getDefault().merge(CoolResource.getDefault());\n+    }\n+    \n+    @Bean\n+    public Clock otelClock() {\n+        return AtomicClock.create();\n+    }\n+\n+    @Bean\n+    public TracerSdkProvider tracerProvider(Resource resource, Clock clock, MonitoringConfig config) {\n+        return TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(config.getOtlpExporter().getEndpoint())\n+                    .setTimeout(config.getOtlpExporter().getTimeout())\n+                    .build())\n+                .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+                .setTimeout(config.getOtlpExporter().getTimeout())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(config.getZipkinExporter().getEndpoint())\n+                    .build())\n+                .build())\n+            .setTraceSampler(config.getSamplingRate() != 0 \n+               ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+    }\n+  \n+    @Bean\n+    public MeterSdkProvider meterProvider(Resource resource, Clock clock) {\n+        return MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public IntervalMetricReader metricReader(MeterSdkProvider meterProvider) {\n+        return IntervalMetricReader.builder()\n+            .addMetricProducer(meterProvider.getMetricProducer())\n+            .addMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public OpenTelemetry openTelemetry(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+           .addPropagator(B3Propagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+\n+    @Bean\n+    @ForJaeger\n+    public OpenTelemetry openTelemetryJaeger(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+  \n+    @Bean\n+    public AuthServiceStub authService(@ForJaeger OpenTelemetry openTelemetry, AuthConfig config) {\n+        return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+          .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+    }\n+    \n+    @Bean\n+    public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+        return TracingServletFilter.create(openTelemetry);\n+    }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason initialization ordering, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. It is expected that frameworks or end-users will set the SDK as the global to support\n+instrumentation that requires this.\n+\n+Before an SDK has been set, access to the global `OpenTelemetry` will return a no-op \n+`DefaultOpenTelemetry`. This is because it is possible library instrumentation is using the global,\n+and it may even use it during the processing of a request (rather than only at initialization time).\n+For this reason, we cannot throw an exception. Instead, if the SDK is detected on the classpath, we", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ5OTIyNQ=="}, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 363}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwMzgwNjAwOnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QwODoyOTo1OFrOIExfjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QwODoyOTo1OFrOIExfjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3NjEwOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Verify familiar with telemetry.\n          \n          \n            \n            Very familiar with telemetry.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541876109", "createdAt": "2020-12-13T08:29:58Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwMzgxMTQzOnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QwODozNDowNlrOIExh6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QwODozNDowNlrOIExh6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3NjcxMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The SDK builder will simply allow accept its components as builder parameters. It only allows\n          \n          \n            \n            The SDK builder will simply accept its components as builder parameters. It only allows", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541876712", "createdAt": "2020-12-13T08:34:06Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwMzgxMzk5OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QwODozNjowMlrOIExjAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QwODozNjowMlrOIExjAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3Njk5Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n          \n          \n            \n                      .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n          \n          \n            \n                          .setEndpoint(\"spans-service:4317\")\n          \n          \n            \n                          .build())\n          \n          \n            \n                      .build();\n          \n          \n            \n                    TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n          \n          \n            \n                      .addSpanProcessor(BatchSpanProcessor.builder(\n          \n          \n            \n                          OtlpGrpcSpanExporter.builder().setEndpoint(\"spans-service:4317\").build())\n          \n          \n            \n                        .build())\n          \n          \n            \n                      .build();", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541876992", "createdAt": "2020-12-13T08:36:02Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwMzgxNzE3OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QwODozODoxNFrOIExkbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QwODozODoxNFrOIExkbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3NzM1Ng==", "bodyText": "You don't have OpenTelemetrySdkBuilder.build() method anymore", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541877356", "createdAt": "2020-12-13T08:38:14Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwMzgxNzMyOnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QwODozODoyM1rOIExkfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QwODozODoyM1rOIExkfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3NzM3NQ==", "bodyText": "You don't have OpenTelemetrySdkBuilder.build() method anymore", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541877375", "createdAt": "2020-12-13T08:38:23Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwMzgxODYwOnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QwODozOToyMFrOIExlDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxODo1MzowMVrOIFgM6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3NzUxOQ==", "bodyText": "I don't see a problem here.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541877519", "createdAt": "2020-12-13T08:39:20Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY0MTM4NA==", "bodyText": "@bogdandrutu has (I think) a use-case where sharing a Resource across MeterProviders will be prolematic. I'll let him explain.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r542641384", "createdAt": "2020-12-14T18:53:01Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3NzUxOQ=="}, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwMzgzNjk3OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QwODo1MToxMVrOIExtFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwMTo0OTozM1rOIE8uKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3OTU3NA==", "bodyText": "I am still somewhat confused by this section", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541879574", "createdAt": "2020-12-13T08:51:11Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.\n+An alternative is to flatten all settings onto `OpenTelemetrySdkBuilder` - this has a downside that\n+it makes it very natural to create new tracer / meter providers for each configuration of the SDK,\n+which could result in a lot of duplication of resources like threads, workers, TCP connections. So\n+instead, this can make it clearer that those signals themselves are full-featured, and \n+`OpenTelemetry` is just a bag of signals.\n+\n+Keep in mind, reconfiguring `Clock` is expected to be an extremely uncommon operation.\n+\n+Another thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+    @Bean\n+    public Resource resource() {\n+        return Resource.getDefault().merge(CoolResource.getDefault());\n+    }\n+    \n+    @Bean\n+    public Clock otelClock() {\n+        return AtomicClock.create();\n+    }\n+\n+    @Bean\n+    public TracerSdkProvider tracerProvider(Resource resource, Clock clock, MonitoringConfig config) {\n+        return TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(config.getOtlpExporter().getEndpoint())\n+                    .setTimeout(config.getOtlpExporter().getTimeout())\n+                    .build())\n+                .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+                .setTimeout(config.getOtlpExporter().getTimeout())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(config.getZipkinExporter().getEndpoint())\n+                    .build())\n+                .build())\n+            .setTraceSampler(config.getSamplingRate() != 0 \n+               ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+    }\n+  \n+    @Bean\n+    public MeterSdkProvider meterProvider(Resource resource, Clock clock) {\n+        return MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public IntervalMetricReader metricReader(MeterSdkProvider meterProvider) {\n+        return IntervalMetricReader.builder()\n+            .addMetricProducer(meterProvider.getMetricProducer())\n+            .addMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public OpenTelemetry openTelemetry(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+           .addPropagator(B3Propagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+\n+    @Bean\n+    @ForJaeger\n+    public OpenTelemetry openTelemetryJaeger(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+  \n+    @Bean\n+    public AuthServiceStub authService(@ForJaeger OpenTelemetry openTelemetry, AuthConfig config) {\n+        return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+          .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+    }\n+    \n+    @Bean\n+    public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+        return TracingServletFilter.create(openTelemetry);\n+    }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason initialization ordering, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. It is expected that frameworks or end-users will set the SDK as the global to support\n+instrumentation that requires this.\n+\n+Before an SDK has been set, access to the global `OpenTelemetry` will return a no-op \n+`DefaultOpenTelemetry`. This is because it is possible library instrumentation is using the global,\n+and it may even use it during the processing of a request (rather than only at initialization time).\n+For this reason, we cannot throw an exception. Instead, if the SDK is detected on the classpath, we\n+will log a `SEVERE` warning once-only indicating the API has been accessed before the SDK configured\n+with directions on how a user could solve the problem. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note about Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+        tracer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+        Tracer tracer = this.tracer;\n+        if (tracer != null) {\n+          tracer.spanBuilder(\"export\").startSpan();\n+        }\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+    public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+        tracerProvider.addSpanExporter(exporter);\n+        components.add(exporter);\n+    }\n+    \n+    public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+        tracerProvider.setSampler(sampler);\n+        components.add(sampler);\n+    }\n+    \n+    public OpenTelemetry build() {\n+        OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+        for (OpenTelemetryComponent component : components) {\n+          component.setOpenTelemetry(sdk);\n+        }\n+    }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+    @Bean\n+    @ForSpanExporter\n+    public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+    }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+    private Lazy<Tracer> tracer;\n+    \n+    @Inject\n+    public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+    }\n+    \n+    @Override\n+    public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+    }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 461}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkwNjE0Mw==", "bodyText": "Please let me know what's confusing since I want to clarify it :) Is it still about dynamic sampling?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541906143", "createdAt": "2020-12-13T11:33:08Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.\n+An alternative is to flatten all settings onto `OpenTelemetrySdkBuilder` - this has a downside that\n+it makes it very natural to create new tracer / meter providers for each configuration of the SDK,\n+which could result in a lot of duplication of resources like threads, workers, TCP connections. So\n+instead, this can make it clearer that those signals themselves are full-featured, and \n+`OpenTelemetry` is just a bag of signals.\n+\n+Keep in mind, reconfiguring `Clock` is expected to be an extremely uncommon operation.\n+\n+Another thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+    @Bean\n+    public Resource resource() {\n+        return Resource.getDefault().merge(CoolResource.getDefault());\n+    }\n+    \n+    @Bean\n+    public Clock otelClock() {\n+        return AtomicClock.create();\n+    }\n+\n+    @Bean\n+    public TracerSdkProvider tracerProvider(Resource resource, Clock clock, MonitoringConfig config) {\n+        return TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(config.getOtlpExporter().getEndpoint())\n+                    .setTimeout(config.getOtlpExporter().getTimeout())\n+                    .build())\n+                .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+                .setTimeout(config.getOtlpExporter().getTimeout())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(config.getZipkinExporter().getEndpoint())\n+                    .build())\n+                .build())\n+            .setTraceSampler(config.getSamplingRate() != 0 \n+               ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+    }\n+  \n+    @Bean\n+    public MeterSdkProvider meterProvider(Resource resource, Clock clock) {\n+        return MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public IntervalMetricReader metricReader(MeterSdkProvider meterProvider) {\n+        return IntervalMetricReader.builder()\n+            .addMetricProducer(meterProvider.getMetricProducer())\n+            .addMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public OpenTelemetry openTelemetry(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+           .addPropagator(B3Propagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+\n+    @Bean\n+    @ForJaeger\n+    public OpenTelemetry openTelemetryJaeger(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+  \n+    @Bean\n+    public AuthServiceStub authService(@ForJaeger OpenTelemetry openTelemetry, AuthConfig config) {\n+        return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+          .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+    }\n+    \n+    @Bean\n+    public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+        return TracingServletFilter.create(openTelemetry);\n+    }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason initialization ordering, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. It is expected that frameworks or end-users will set the SDK as the global to support\n+instrumentation that requires this.\n+\n+Before an SDK has been set, access to the global `OpenTelemetry` will return a no-op \n+`DefaultOpenTelemetry`. This is because it is possible library instrumentation is using the global,\n+and it may even use it during the processing of a request (rather than only at initialization time).\n+For this reason, we cannot throw an exception. Instead, if the SDK is detected on the classpath, we\n+will log a `SEVERE` warning once-only indicating the API has been accessed before the SDK configured\n+with directions on how a user could solve the problem. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note about Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+        tracer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+        Tracer tracer = this.tracer;\n+        if (tracer != null) {\n+          tracer.spanBuilder(\"export\").startSpan();\n+        }\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+    public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+        tracerProvider.addSpanExporter(exporter);\n+        components.add(exporter);\n+    }\n+    \n+    public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+        tracerProvider.setSampler(sampler);\n+        components.add(sampler);\n+    }\n+    \n+    public OpenTelemetry build() {\n+        OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+        for (OpenTelemetryComponent component : components) {\n+          component.setOpenTelemetry(sdk);\n+        }\n+    }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+    @Bean\n+    @ForSpanExporter\n+    public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+    }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+    private Lazy<Tracer> tracer;\n+    \n+    @Inject\n+    public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+    }\n+    \n+    @Override\n+    public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+    }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3OTU3NA=="}, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 461}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk1Mzg3OA==", "bodyText": "E.g. I don't understand the connection between addSpanProcessor method (on which class, btw?) and telemetry within telemetry (btw, is this the same as what you called \"telemetry within SDK components\" above?).\n\"the SDK default implementation is static\" - do you mean \"immutable\"? And in general, sorry Anuraag, this section reads much sloppier than the preceding document :)\nAlso, I understand that Bogdan suggests having immutable SDK. As this does make total case on the first glance, may be this section better address those cases, when we potentially need mutability. E.g. \"why obvious choice of immutable SDK is not that simple?\"", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541953878", "createdAt": "2020-12-13T16:06:22Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.\n+An alternative is to flatten all settings onto `OpenTelemetrySdkBuilder` - this has a downside that\n+it makes it very natural to create new tracer / meter providers for each configuration of the SDK,\n+which could result in a lot of duplication of resources like threads, workers, TCP connections. So\n+instead, this can make it clearer that those signals themselves are full-featured, and \n+`OpenTelemetry` is just a bag of signals.\n+\n+Keep in mind, reconfiguring `Clock` is expected to be an extremely uncommon operation.\n+\n+Another thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+    @Bean\n+    public Resource resource() {\n+        return Resource.getDefault().merge(CoolResource.getDefault());\n+    }\n+    \n+    @Bean\n+    public Clock otelClock() {\n+        return AtomicClock.create();\n+    }\n+\n+    @Bean\n+    public TracerSdkProvider tracerProvider(Resource resource, Clock clock, MonitoringConfig config) {\n+        return TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(config.getOtlpExporter().getEndpoint())\n+                    .setTimeout(config.getOtlpExporter().getTimeout())\n+                    .build())\n+                .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+                .setTimeout(config.getOtlpExporter().getTimeout())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(config.getZipkinExporter().getEndpoint())\n+                    .build())\n+                .build())\n+            .setTraceSampler(config.getSamplingRate() != 0 \n+               ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+    }\n+  \n+    @Bean\n+    public MeterSdkProvider meterProvider(Resource resource, Clock clock) {\n+        return MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public IntervalMetricReader metricReader(MeterSdkProvider meterProvider) {\n+        return IntervalMetricReader.builder()\n+            .addMetricProducer(meterProvider.getMetricProducer())\n+            .addMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public OpenTelemetry openTelemetry(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+           .addPropagator(B3Propagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+\n+    @Bean\n+    @ForJaeger\n+    public OpenTelemetry openTelemetryJaeger(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+  \n+    @Bean\n+    public AuthServiceStub authService(@ForJaeger OpenTelemetry openTelemetry, AuthConfig config) {\n+        return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+          .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+    }\n+    \n+    @Bean\n+    public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+        return TracingServletFilter.create(openTelemetry);\n+    }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason initialization ordering, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. It is expected that frameworks or end-users will set the SDK as the global to support\n+instrumentation that requires this.\n+\n+Before an SDK has been set, access to the global `OpenTelemetry` will return a no-op \n+`DefaultOpenTelemetry`. This is because it is possible library instrumentation is using the global,\n+and it may even use it during the processing of a request (rather than only at initialization time).\n+For this reason, we cannot throw an exception. Instead, if the SDK is detected on the classpath, we\n+will log a `SEVERE` warning once-only indicating the API has been accessed before the SDK configured\n+with directions on how a user could solve the problem. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note about Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+        tracer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+        Tracer tracer = this.tracer;\n+        if (tracer != null) {\n+          tracer.spanBuilder(\"export\").startSpan();\n+        }\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+    public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+        tracerProvider.addSpanExporter(exporter);\n+        components.add(exporter);\n+    }\n+    \n+    public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+        tracerProvider.setSampler(sampler);\n+        components.add(sampler);\n+    }\n+    \n+    public OpenTelemetry build() {\n+        OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+        for (OpenTelemetryComponent component : components) {\n+          component.setOpenTelemetry(sdk);\n+        }\n+    }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+    @Bean\n+    @ForSpanExporter\n+    public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+    }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+    private Lazy<Tracer> tracer;\n+    \n+    @Inject\n+    public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+    }\n+    \n+    @Override\n+    public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+    }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3OTU3NA=="}, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 461}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA2MDA3Mg==", "bodyText": "Thanks will try to rewrite it - one thing that's always tricky for me is talking about immutability. The SDK isn't immutable in the strictest sense since, e.g., BatchSpanProcessor has a mutable queue of spans. I guess the word to use is shallow-immutable which is what I meant by configuration being static. Let me see what I can do.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r542060072", "createdAt": "2020-12-14T01:49:33Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.\n+An alternative is to flatten all settings onto `OpenTelemetrySdkBuilder` - this has a downside that\n+it makes it very natural to create new tracer / meter providers for each configuration of the SDK,\n+which could result in a lot of duplication of resources like threads, workers, TCP connections. So\n+instead, this can make it clearer that those signals themselves are full-featured, and \n+`OpenTelemetry` is just a bag of signals.\n+\n+Keep in mind, reconfiguring `Clock` is expected to be an extremely uncommon operation.\n+\n+Another thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+    @Bean\n+    public Resource resource() {\n+        return Resource.getDefault().merge(CoolResource.getDefault());\n+    }\n+    \n+    @Bean\n+    public Clock otelClock() {\n+        return AtomicClock.create();\n+    }\n+\n+    @Bean\n+    public TracerSdkProvider tracerProvider(Resource resource, Clock clock, MonitoringConfig config) {\n+        return TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(config.getOtlpExporter().getEndpoint())\n+                    .setTimeout(config.getOtlpExporter().getTimeout())\n+                    .build())\n+                .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+                .setTimeout(config.getOtlpExporter().getTimeout())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(config.getZipkinExporter().getEndpoint())\n+                    .build())\n+                .build())\n+            .setTraceSampler(config.getSamplingRate() != 0 \n+               ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+    }\n+  \n+    @Bean\n+    public MeterSdkProvider meterProvider(Resource resource, Clock clock) {\n+        return MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public IntervalMetricReader metricReader(MeterSdkProvider meterProvider) {\n+        return IntervalMetricReader.builder()\n+            .addMetricProducer(meterProvider.getMetricProducer())\n+            .addMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public OpenTelemetry openTelemetry(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+           .addPropagator(B3Propagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+\n+    @Bean\n+    @ForJaeger\n+    public OpenTelemetry openTelemetryJaeger(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+  \n+    @Bean\n+    public AuthServiceStub authService(@ForJaeger OpenTelemetry openTelemetry, AuthConfig config) {\n+        return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+          .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+    }\n+    \n+    @Bean\n+    public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+        return TracingServletFilter.create(openTelemetry);\n+    }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason initialization ordering, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. It is expected that frameworks or end-users will set the SDK as the global to support\n+instrumentation that requires this.\n+\n+Before an SDK has been set, access to the global `OpenTelemetry` will return a no-op \n+`DefaultOpenTelemetry`. This is because it is possible library instrumentation is using the global,\n+and it may even use it during the processing of a request (rather than only at initialization time).\n+For this reason, we cannot throw an exception. Instead, if the SDK is detected on the classpath, we\n+will log a `SEVERE` warning once-only indicating the API has been accessed before the SDK configured\n+with directions on how a user could solve the problem. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note about Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+        tracer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+        Tracer tracer = this.tracer;\n+        if (tracer != null) {\n+          tracer.spanBuilder(\"export\").startSpan();\n+        }\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+    public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+        tracerProvider.addSpanExporter(exporter);\n+        components.add(exporter);\n+    }\n+    \n+    public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+        tracerProvider.setSampler(sampler);\n+        components.add(sampler);\n+    }\n+    \n+    public OpenTelemetry build() {\n+        OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+        for (OpenTelemetryComponent component : components) {\n+          component.setOpenTelemetry(sdk);\n+        }\n+    }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+    @Bean\n+    @ForSpanExporter\n+    public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+    }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+    private Lazy<Tracer> tracer;\n+    \n+    @Inject\n+    public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+    }\n+    \n+    @Override\n+    public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+    }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3OTU3NA=="}, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 461}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwMzgzNzI2OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QwODo1MToyMFrOIExtNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwMjowMjowNVrOIE86xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3OTYwNA==", "bodyText": "I am still somewhat confused by this section", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541879604", "createdAt": "2020-12-13T08:51:20Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.\n+An alternative is to flatten all settings onto `OpenTelemetrySdkBuilder` - this has a downside that\n+it makes it very natural to create new tracer / meter providers for each configuration of the SDK,\n+which could result in a lot of duplication of resources like threads, workers, TCP connections. So\n+instead, this can make it clearer that those signals themselves are full-featured, and \n+`OpenTelemetry` is just a bag of signals.\n+\n+Keep in mind, reconfiguring `Clock` is expected to be an extremely uncommon operation.\n+\n+Another thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+    @Bean\n+    public Resource resource() {\n+        return Resource.getDefault().merge(CoolResource.getDefault());\n+    }\n+    \n+    @Bean\n+    public Clock otelClock() {\n+        return AtomicClock.create();\n+    }\n+\n+    @Bean\n+    public TracerSdkProvider tracerProvider(Resource resource, Clock clock, MonitoringConfig config) {\n+        return TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(config.getOtlpExporter().getEndpoint())\n+                    .setTimeout(config.getOtlpExporter().getTimeout())\n+                    .build())\n+                .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+                .setTimeout(config.getOtlpExporter().getTimeout())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(config.getZipkinExporter().getEndpoint())\n+                    .build())\n+                .build())\n+            .setTraceSampler(config.getSamplingRate() != 0 \n+               ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+    }\n+  \n+    @Bean\n+    public MeterSdkProvider meterProvider(Resource resource, Clock clock) {\n+        return MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public IntervalMetricReader metricReader(MeterSdkProvider meterProvider) {\n+        return IntervalMetricReader.builder()\n+            .addMetricProducer(meterProvider.getMetricProducer())\n+            .addMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public OpenTelemetry openTelemetry(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+           .addPropagator(B3Propagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+\n+    @Bean\n+    @ForJaeger\n+    public OpenTelemetry openTelemetryJaeger(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+  \n+    @Bean\n+    public AuthServiceStub authService(@ForJaeger OpenTelemetry openTelemetry, AuthConfig config) {\n+        return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+          .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+    }\n+    \n+    @Bean\n+    public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+        return TracingServletFilter.create(openTelemetry);\n+    }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason initialization ordering, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. It is expected that frameworks or end-users will set the SDK as the global to support\n+instrumentation that requires this.\n+\n+Before an SDK has been set, access to the global `OpenTelemetry` will return a no-op \n+`DefaultOpenTelemetry`. This is because it is possible library instrumentation is using the global,\n+and it may even use it during the processing of a request (rather than only at initialization time).\n+For this reason, we cannot throw an exception. Instead, if the SDK is detected on the classpath, we\n+will log a `SEVERE` warning once-only indicating the API has been accessed before the SDK configured\n+with directions on how a user could solve the problem. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note about Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+        tracer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+        Tracer tracer = this.tracer;\n+        if (tracer != null) {\n+          tracer.spanBuilder(\"export\").startSpan();\n+        }\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+    public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+        tracerProvider.addSpanExporter(exporter);\n+        components.add(exporter);\n+    }\n+    \n+    public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+        tracerProvider.setSampler(sampler);\n+        components.add(sampler);\n+    }\n+    \n+    public OpenTelemetry build() {\n+        OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+        for (OpenTelemetryComponent component : components) {\n+          component.setOpenTelemetry(sdk);\n+        }\n+    }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+    @Bean\n+    @ForSpanExporter\n+    public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+    }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+    private Lazy<Tracer> tracer;\n+    \n+    @Inject\n+    public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+    }\n+    \n+    @Override\n+    public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+    }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+## TracerSdkManagement", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 498}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk1NDI1Mg==", "bodyText": "And now I understand why :) This section does not talk about SDK configuration at all :) But some completely separate concerns of public interfaces of the SDK. Should this section be in document at all?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541954252", "createdAt": "2020-12-13T16:08:15Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.\n+An alternative is to flatten all settings onto `OpenTelemetrySdkBuilder` - this has a downside that\n+it makes it very natural to create new tracer / meter providers for each configuration of the SDK,\n+which could result in a lot of duplication of resources like threads, workers, TCP connections. So\n+instead, this can make it clearer that those signals themselves are full-featured, and \n+`OpenTelemetry` is just a bag of signals.\n+\n+Keep in mind, reconfiguring `Clock` is expected to be an extremely uncommon operation.\n+\n+Another thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+    @Bean\n+    public Resource resource() {\n+        return Resource.getDefault().merge(CoolResource.getDefault());\n+    }\n+    \n+    @Bean\n+    public Clock otelClock() {\n+        return AtomicClock.create();\n+    }\n+\n+    @Bean\n+    public TracerSdkProvider tracerProvider(Resource resource, Clock clock, MonitoringConfig config) {\n+        return TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(config.getOtlpExporter().getEndpoint())\n+                    .setTimeout(config.getOtlpExporter().getTimeout())\n+                    .build())\n+                .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+                .setTimeout(config.getOtlpExporter().getTimeout())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(config.getZipkinExporter().getEndpoint())\n+                    .build())\n+                .build())\n+            .setTraceSampler(config.getSamplingRate() != 0 \n+               ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+    }\n+  \n+    @Bean\n+    public MeterSdkProvider meterProvider(Resource resource, Clock clock) {\n+        return MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public IntervalMetricReader metricReader(MeterSdkProvider meterProvider) {\n+        return IntervalMetricReader.builder()\n+            .addMetricProducer(meterProvider.getMetricProducer())\n+            .addMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public OpenTelemetry openTelemetry(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+           .addPropagator(B3Propagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+\n+    @Bean\n+    @ForJaeger\n+    public OpenTelemetry openTelemetryJaeger(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+  \n+    @Bean\n+    public AuthServiceStub authService(@ForJaeger OpenTelemetry openTelemetry, AuthConfig config) {\n+        return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+          .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+    }\n+    \n+    @Bean\n+    public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+        return TracingServletFilter.create(openTelemetry);\n+    }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason initialization ordering, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. It is expected that frameworks or end-users will set the SDK as the global to support\n+instrumentation that requires this.\n+\n+Before an SDK has been set, access to the global `OpenTelemetry` will return a no-op \n+`DefaultOpenTelemetry`. This is because it is possible library instrumentation is using the global,\n+and it may even use it during the processing of a request (rather than only at initialization time).\n+For this reason, we cannot throw an exception. Instead, if the SDK is detected on the classpath, we\n+will log a `SEVERE` warning once-only indicating the API has been accessed before the SDK configured\n+with directions on how a user could solve the problem. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note about Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+        tracer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+        Tracer tracer = this.tracer;\n+        if (tracer != null) {\n+          tracer.spanBuilder(\"export\").startSpan();\n+        }\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+    public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+        tracerProvider.addSpanExporter(exporter);\n+        components.add(exporter);\n+    }\n+    \n+    public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+        tracerProvider.setSampler(sampler);\n+        components.add(sampler);\n+    }\n+    \n+    public OpenTelemetry build() {\n+        OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+        for (OpenTelemetryComponent component : components) {\n+          component.setOpenTelemetry(sdk);\n+        }\n+    }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+    @Bean\n+    @ForSpanExporter\n+    public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+    }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+    private Lazy<Tracer> tracer;\n+    \n+    @Inject\n+    public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+    }\n+    \n+    @Override\n+    public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+    }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+## TracerSdkManagement", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3OTYwNA=="}, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 498}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA2MzMwMA==", "bodyText": "This came to mind while considering what's left after removing the mutability methods from management interface, since ideally we don't have a management interface at all. But agree it's not really related with others, happy to have it just in commit history.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r542063300", "createdAt": "2020-12-14T02:02:05Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.\n+An alternative is to flatten all settings onto `OpenTelemetrySdkBuilder` - this has a downside that\n+it makes it very natural to create new tracer / meter providers for each configuration of the SDK,\n+which could result in a lot of duplication of resources like threads, workers, TCP connections. So\n+instead, this can make it clearer that those signals themselves are full-featured, and \n+`OpenTelemetry` is just a bag of signals.\n+\n+Keep in mind, reconfiguring `Clock` is expected to be an extremely uncommon operation.\n+\n+Another thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+    @Bean\n+    public Resource resource() {\n+        return Resource.getDefault().merge(CoolResource.getDefault());\n+    }\n+    \n+    @Bean\n+    public Clock otelClock() {\n+        return AtomicClock.create();\n+    }\n+\n+    @Bean\n+    public TracerSdkProvider tracerProvider(Resource resource, Clock clock, MonitoringConfig config) {\n+        return TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(config.getOtlpExporter().getEndpoint())\n+                    .setTimeout(config.getOtlpExporter().getTimeout())\n+                    .build())\n+                .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+                .setTimeout(config.getOtlpExporter().getTimeout())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(config.getZipkinExporter().getEndpoint())\n+                    .build())\n+                .build())\n+            .setTraceSampler(config.getSamplingRate() != 0 \n+               ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+    }\n+  \n+    @Bean\n+    public MeterSdkProvider meterProvider(Resource resource, Clock clock) {\n+        return MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public IntervalMetricReader metricReader(MeterSdkProvider meterProvider) {\n+        return IntervalMetricReader.builder()\n+            .addMetricProducer(meterProvider.getMetricProducer())\n+            .addMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public OpenTelemetry openTelemetry(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+           .addPropagator(B3Propagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+\n+    @Bean\n+    @ForJaeger\n+    public OpenTelemetry openTelemetryJaeger(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+  \n+    @Bean\n+    public AuthServiceStub authService(@ForJaeger OpenTelemetry openTelemetry, AuthConfig config) {\n+        return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+          .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+    }\n+    \n+    @Bean\n+    public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+        return TracingServletFilter.create(openTelemetry);\n+    }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason initialization ordering, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. It is expected that frameworks or end-users will set the SDK as the global to support\n+instrumentation that requires this.\n+\n+Before an SDK has been set, access to the global `OpenTelemetry` will return a no-op \n+`DefaultOpenTelemetry`. This is because it is possible library instrumentation is using the global,\n+and it may even use it during the processing of a request (rather than only at initialization time).\n+For this reason, we cannot throw an exception. Instead, if the SDK is detected on the classpath, we\n+will log a `SEVERE` warning once-only indicating the API has been accessed before the SDK configured\n+with directions on how a user could solve the problem. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note about Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+        tracer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+        Tracer tracer = this.tracer;\n+        if (tracer != null) {\n+          tracer.spanBuilder(\"export\").startSpan();\n+        }\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+    public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+        tracerProvider.addSpanExporter(exporter);\n+        components.add(exporter);\n+    }\n+    \n+    public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+        tracerProvider.setSampler(sampler);\n+        components.add(sampler);\n+    }\n+    \n+    public OpenTelemetry build() {\n+        OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+        for (OpenTelemetryComponent component : components) {\n+          component.setOpenTelemetry(sdk);\n+        }\n+    }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+    @Bean\n+    @ForSpanExporter\n+    public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+    }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+    private Lazy<Tracer> tracer;\n+    \n+    @Inject\n+    public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+    }\n+    \n+    @Override\n+    public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+    }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+## TracerSdkManagement", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3OTYwNA=="}, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 498}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwMzg0MzIxOnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QwODo1NToyNVrOIExv5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwODoyMTowNFrOIFErEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg4MDI5NQ==", "bodyText": "I still think that we have to de-emphasize global instance of OpenTelemetry more. The common way of using OpenTelemetry should be via instance. Global should be something special and a conscious choice. Even requiring a separate explicit Global.set(OpenTelemetry)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541880295", "createdAt": "2020-12-13T08:55:25Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.\n+An alternative is to flatten all settings onto `OpenTelemetrySdkBuilder` - this has a downside that\n+it makes it very natural to create new tracer / meter providers for each configuration of the SDK,\n+which could result in a lot of duplication of resources like threads, workers, TCP connections. So\n+instead, this can make it clearer that those signals themselves are full-featured, and \n+`OpenTelemetry` is just a bag of signals.\n+\n+Keep in mind, reconfiguring `Clock` is expected to be an extremely uncommon operation.\n+\n+Another thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+    @Bean\n+    public Resource resource() {\n+        return Resource.getDefault().merge(CoolResource.getDefault());\n+    }\n+    \n+    @Bean\n+    public Clock otelClock() {\n+        return AtomicClock.create();\n+    }\n+\n+    @Bean\n+    public TracerSdkProvider tracerProvider(Resource resource, Clock clock, MonitoringConfig config) {\n+        return TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(config.getOtlpExporter().getEndpoint())\n+                    .setTimeout(config.getOtlpExporter().getTimeout())\n+                    .build())\n+                .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+                .setTimeout(config.getOtlpExporter().getTimeout())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(config.getZipkinExporter().getEndpoint())\n+                    .build())\n+                .build())\n+            .setTraceSampler(config.getSamplingRate() != 0 \n+               ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+    }\n+  \n+    @Bean\n+    public MeterSdkProvider meterProvider(Resource resource, Clock clock) {\n+        return MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public IntervalMetricReader metricReader(MeterSdkProvider meterProvider) {\n+        return IntervalMetricReader.builder()\n+            .addMetricProducer(meterProvider.getMetricProducer())\n+            .addMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public OpenTelemetry openTelemetry(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+           .addPropagator(B3Propagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+\n+    @Bean\n+    @ForJaeger\n+    public OpenTelemetry openTelemetryJaeger(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+  \n+    @Bean\n+    public AuthServiceStub authService(@ForJaeger OpenTelemetry openTelemetry, AuthConfig config) {\n+        return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+          .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+    }\n+    \n+    @Bean\n+    public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+        return TracingServletFilter.create(openTelemetry);\n+    }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason initialization ordering, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. It is expected that frameworks or end-users will set the SDK as the global to support\n+instrumentation that requires this.\n+\n+Before an SDK has been set, access to the global `OpenTelemetry` will return a no-op \n+`DefaultOpenTelemetry`. This is because it is possible library instrumentation is using the global,\n+and it may even use it during the processing of a request (rather than only at initialization time).\n+For this reason, we cannot throw an exception. Instead, if the SDK is detected on the classpath, we\n+will log a `SEVERE` warning once-only indicating the API has been accessed before the SDK configured\n+with directions on how a user could solve the problem. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note about Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+        tracer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+        Tracer tracer = this.tracer;\n+        if (tracer != null) {\n+          tracer.spanBuilder(\"export\").startSpan();\n+        }\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+    public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+        tracerProvider.addSpanExporter(exporter);\n+        components.add(exporter);\n+    }\n+    \n+    public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+        tracerProvider.setSampler(sampler);\n+        components.add(sampler);\n+    }\n+    \n+    public OpenTelemetry build() {\n+        OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+        for (OpenTelemetryComponent component : components) {\n+          component.setOpenTelemetry(sdk);\n+        }\n+    }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+    @Bean\n+    @ForSpanExporter\n+    public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+    }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+    private Lazy<Tracer> tracer;\n+    \n+    @Inject\n+    public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+    }\n+    \n+    @Override\n+    public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+    }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+## TracerSdkManagement\n+\n+With the proposal to make a configured SDK fully built rather than allowing configuration\n+mutability, the SDK management interface would only have `shutdown` and `forceFlush`. It seems\n+reasonable to actually remove `shutdown` from the `TracerSdkProvider` - the SDK provider is mostly\n+a bag of parts and has no intrinsic component, if instead components like `BatchSpanProcessor` and\n+`SpanExporter` implement `Closeable`, we can model shutdown as the responsibility of the creator of\n+the resources, which is idiomatic. In DI frameworks, this would generally be automatic. This would\n+prevent the case where two `TracerProvider` share an exporter and one of them is shutdown - when\n+shutting down the exporter, shut down the exporter.\n+\n+```java\n+public class MyApp {\n+ \n+    public static void main(String[] args) {\n+        try (OtlpGrpcSpanExporter otlpExporter = OtlpGrpcSpanExporter.builder().build();\n+              BatchSpanProcessor otlpProcessor = BatchSpanProcessor.builder(otlpExporter).build()) {\n+            OpenTelemetrySdk sdk = OpenTelemetrySdk.builder()\n+                .setTracerProvider(TracerSdkProvider.builder()\n+                                        .addSpanProcessor(otlpProcessor)\n+                                        .build())\n+                .build();\n+ \n+            Server server = Server.builder().setOpenTelemetry(sdk).build();\n+            server.listenAndServe();\n+        }\n+    }\n+\n+}\n+```\n+\n+```java\n+@Component\n+public class MyModule {\n+\n+    @Bean\n+    // If SpanExporter extends Closeable, it's automatically closed\n+    OtlpGrpcSpanExporter otlpExporter() {\n+        return OtlpGrpcSpanExporter.builder().build()\n+    }\n+   \n+    @Bean\n+    // If BatchSpanProcessor extends Closeable, it's automatically closed\n+    BatchSpanProcessor otlpSpanProcessor(OtlpGrpcSpanExporter otlpExporter) {\n+        return BatchSpanProcessor.builder(otlpExporter).build();\n+    }\n+ \n+    @Bean\n+    TracerSdkProvider tracerProvider(BatchSpanProcessor otlpSpanProcessor) {\n+        return TracerSdkProvider.builder().addSpanProcessor(otlpSpanProcessor).build();\n+    }\n+\n+    @Bean\n+    OpenTelemetrySdk openTelemetry(TracerSdkProvider tracerProvider) {\n+        return OpenTelemetrySdk.builder().setTracerProvider(tracerProvider).build();\n+    }\n+}\n+```\n+\n+The `OpenTelemetrySdk` and `TracerSdkProvider` are still exposed to provide access to `forceFlush`.\n+This makes it seem like `forceFlush`, though implemented in the SDK, may be more appropriate for the\n+API as it's an end-user API - it could make the separation of concerns of the initialization of the\n+SDK and the end-user tracing API complete. But the spec currently does not allow it.\n+\n+## Library instrumentation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 562}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjA2MzgxNQ==", "bodyText": "Hmm - was I too nice to allow library authors an option of starting with global? I was imagining Bogdan's use case where some codebases may just want to make everything global, even in their instrumentation. But maybe it's too unclear in the context of this doc. Should I remove everything from An alternative method...?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r542063815", "createdAt": "2020-12-14T02:04:07Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.\n+An alternative is to flatten all settings onto `OpenTelemetrySdkBuilder` - this has a downside that\n+it makes it very natural to create new tracer / meter providers for each configuration of the SDK,\n+which could result in a lot of duplication of resources like threads, workers, TCP connections. So\n+instead, this can make it clearer that those signals themselves are full-featured, and \n+`OpenTelemetry` is just a bag of signals.\n+\n+Keep in mind, reconfiguring `Clock` is expected to be an extremely uncommon operation.\n+\n+Another thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+    @Bean\n+    public Resource resource() {\n+        return Resource.getDefault().merge(CoolResource.getDefault());\n+    }\n+    \n+    @Bean\n+    public Clock otelClock() {\n+        return AtomicClock.create();\n+    }\n+\n+    @Bean\n+    public TracerSdkProvider tracerProvider(Resource resource, Clock clock, MonitoringConfig config) {\n+        return TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(config.getOtlpExporter().getEndpoint())\n+                    .setTimeout(config.getOtlpExporter().getTimeout())\n+                    .build())\n+                .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+                .setTimeout(config.getOtlpExporter().getTimeout())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(config.getZipkinExporter().getEndpoint())\n+                    .build())\n+                .build())\n+            .setTraceSampler(config.getSamplingRate() != 0 \n+               ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+    }\n+  \n+    @Bean\n+    public MeterSdkProvider meterProvider(Resource resource, Clock clock) {\n+        return MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public IntervalMetricReader metricReader(MeterSdkProvider meterProvider) {\n+        return IntervalMetricReader.builder()\n+            .addMetricProducer(meterProvider.getMetricProducer())\n+            .addMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public OpenTelemetry openTelemetry(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+           .addPropagator(B3Propagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+\n+    @Bean\n+    @ForJaeger\n+    public OpenTelemetry openTelemetryJaeger(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+  \n+    @Bean\n+    public AuthServiceStub authService(@ForJaeger OpenTelemetry openTelemetry, AuthConfig config) {\n+        return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+          .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+    }\n+    \n+    @Bean\n+    public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+        return TracingServletFilter.create(openTelemetry);\n+    }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason initialization ordering, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. It is expected that frameworks or end-users will set the SDK as the global to support\n+instrumentation that requires this.\n+\n+Before an SDK has been set, access to the global `OpenTelemetry` will return a no-op \n+`DefaultOpenTelemetry`. This is because it is possible library instrumentation is using the global,\n+and it may even use it during the processing of a request (rather than only at initialization time).\n+For this reason, we cannot throw an exception. Instead, if the SDK is detected on the classpath, we\n+will log a `SEVERE` warning once-only indicating the API has been accessed before the SDK configured\n+with directions on how a user could solve the problem. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note about Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+        tracer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+        Tracer tracer = this.tracer;\n+        if (tracer != null) {\n+          tracer.spanBuilder(\"export\").startSpan();\n+        }\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+    public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+        tracerProvider.addSpanExporter(exporter);\n+        components.add(exporter);\n+    }\n+    \n+    public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+        tracerProvider.setSampler(sampler);\n+        components.add(sampler);\n+    }\n+    \n+    public OpenTelemetry build() {\n+        OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+        for (OpenTelemetryComponent component : components) {\n+          component.setOpenTelemetry(sdk);\n+        }\n+    }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+    @Bean\n+    @ForSpanExporter\n+    public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+    }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+    private Lazy<Tracer> tracer;\n+    \n+    @Inject\n+    public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+    }\n+    \n+    @Override\n+    public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+    }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+## TracerSdkManagement\n+\n+With the proposal to make a configured SDK fully built rather than allowing configuration\n+mutability, the SDK management interface would only have `shutdown` and `forceFlush`. It seems\n+reasonable to actually remove `shutdown` from the `TracerSdkProvider` - the SDK provider is mostly\n+a bag of parts and has no intrinsic component, if instead components like `BatchSpanProcessor` and\n+`SpanExporter` implement `Closeable`, we can model shutdown as the responsibility of the creator of\n+the resources, which is idiomatic. In DI frameworks, this would generally be automatic. This would\n+prevent the case where two `TracerProvider` share an exporter and one of them is shutdown - when\n+shutting down the exporter, shut down the exporter.\n+\n+```java\n+public class MyApp {\n+ \n+    public static void main(String[] args) {\n+        try (OtlpGrpcSpanExporter otlpExporter = OtlpGrpcSpanExporter.builder().build();\n+              BatchSpanProcessor otlpProcessor = BatchSpanProcessor.builder(otlpExporter).build()) {\n+            OpenTelemetrySdk sdk = OpenTelemetrySdk.builder()\n+                .setTracerProvider(TracerSdkProvider.builder()\n+                                        .addSpanProcessor(otlpProcessor)\n+                                        .build())\n+                .build();\n+ \n+            Server server = Server.builder().setOpenTelemetry(sdk).build();\n+            server.listenAndServe();\n+        }\n+    }\n+\n+}\n+```\n+\n+```java\n+@Component\n+public class MyModule {\n+\n+    @Bean\n+    // If SpanExporter extends Closeable, it's automatically closed\n+    OtlpGrpcSpanExporter otlpExporter() {\n+        return OtlpGrpcSpanExporter.builder().build()\n+    }\n+   \n+    @Bean\n+    // If BatchSpanProcessor extends Closeable, it's automatically closed\n+    BatchSpanProcessor otlpSpanProcessor(OtlpGrpcSpanExporter otlpExporter) {\n+        return BatchSpanProcessor.builder(otlpExporter).build();\n+    }\n+ \n+    @Bean\n+    TracerSdkProvider tracerProvider(BatchSpanProcessor otlpSpanProcessor) {\n+        return TracerSdkProvider.builder().addSpanProcessor(otlpSpanProcessor).build();\n+    }\n+\n+    @Bean\n+    OpenTelemetrySdk openTelemetry(TracerSdkProvider tracerProvider) {\n+        return OpenTelemetrySdk.builder().setTracerProvider(tracerProvider).build();\n+    }\n+}\n+```\n+\n+The `OpenTelemetrySdk` and `TracerSdkProvider` are still exposed to provide access to `forceFlush`.\n+This makes it seem like `forceFlush`, though implemented in the SDK, may be more appropriate for the\n+API as it's an end-user API - it could make the separation of concerns of the initialization of the\n+SDK and the end-user tracing API complete. But the spec currently does not allow it.\n+\n+## Library instrumentation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg4MDI5NQ=="}, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 562}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE5MDM1NQ==", "bodyText": "I think so, yes.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r542190355", "createdAt": "2020-12-14T08:21:04Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.\n+An alternative is to flatten all settings onto `OpenTelemetrySdkBuilder` - this has a downside that\n+it makes it very natural to create new tracer / meter providers for each configuration of the SDK,\n+which could result in a lot of duplication of resources like threads, workers, TCP connections. So\n+instead, this can make it clearer that those signals themselves are full-featured, and \n+`OpenTelemetry` is just a bag of signals.\n+\n+Keep in mind, reconfiguring `Clock` is expected to be an extremely uncommon operation.\n+\n+Another thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+    @Bean\n+    public Resource resource() {\n+        return Resource.getDefault().merge(CoolResource.getDefault());\n+    }\n+    \n+    @Bean\n+    public Clock otelClock() {\n+        return AtomicClock.create();\n+    }\n+\n+    @Bean\n+    public TracerSdkProvider tracerProvider(Resource resource, Clock clock, MonitoringConfig config) {\n+        return TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(config.getOtlpExporter().getEndpoint())\n+                    .setTimeout(config.getOtlpExporter().getTimeout())\n+                    .build())\n+                .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+                .setTimeout(config.getOtlpExporter().getTimeout())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(config.getZipkinExporter().getEndpoint())\n+                    .build())\n+                .build())\n+            .setTraceSampler(config.getSamplingRate() != 0 \n+               ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+    }\n+  \n+    @Bean\n+    public MeterSdkProvider meterProvider(Resource resource, Clock clock) {\n+        return MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public IntervalMetricReader metricReader(MeterSdkProvider meterProvider) {\n+        return IntervalMetricReader.builder()\n+            .addMetricProducer(meterProvider.getMetricProducer())\n+            .addMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public OpenTelemetry openTelemetry(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+           .addPropagator(B3Propagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+\n+    @Bean\n+    @ForJaeger\n+    public OpenTelemetry openTelemetryJaeger(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+  \n+    @Bean\n+    public AuthServiceStub authService(@ForJaeger OpenTelemetry openTelemetry, AuthConfig config) {\n+        return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+          .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+    }\n+    \n+    @Bean\n+    public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+        return TracingServletFilter.create(openTelemetry);\n+    }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason initialization ordering, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. It is expected that frameworks or end-users will set the SDK as the global to support\n+instrumentation that requires this.\n+\n+Before an SDK has been set, access to the global `OpenTelemetry` will return a no-op \n+`DefaultOpenTelemetry`. This is because it is possible library instrumentation is using the global,\n+and it may even use it during the processing of a request (rather than only at initialization time).\n+For this reason, we cannot throw an exception. Instead, if the SDK is detected on the classpath, we\n+will log a `SEVERE` warning once-only indicating the API has been accessed before the SDK configured\n+with directions on how a user could solve the problem. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note about Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+        tracer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+        Tracer tracer = this.tracer;\n+        if (tracer != null) {\n+          tracer.spanBuilder(\"export\").startSpan();\n+        }\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+    public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+        tracerProvider.addSpanExporter(exporter);\n+        components.add(exporter);\n+    }\n+    \n+    public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+        tracerProvider.setSampler(sampler);\n+        components.add(sampler);\n+    }\n+    \n+    public OpenTelemetry build() {\n+        OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+        for (OpenTelemetryComponent component : components) {\n+          component.setOpenTelemetry(sdk);\n+        }\n+    }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+    @Bean\n+    @ForSpanExporter\n+    public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+    }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+    private Lazy<Tracer> tracer;\n+    \n+    @Inject\n+    public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+    }\n+    \n+    @Override\n+    public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+    }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+## TracerSdkManagement\n+\n+With the proposal to make a configured SDK fully built rather than allowing configuration\n+mutability, the SDK management interface would only have `shutdown` and `forceFlush`. It seems\n+reasonable to actually remove `shutdown` from the `TracerSdkProvider` - the SDK provider is mostly\n+a bag of parts and has no intrinsic component, if instead components like `BatchSpanProcessor` and\n+`SpanExporter` implement `Closeable`, we can model shutdown as the responsibility of the creator of\n+the resources, which is idiomatic. In DI frameworks, this would generally be automatic. This would\n+prevent the case where two `TracerProvider` share an exporter and one of them is shutdown - when\n+shutting down the exporter, shut down the exporter.\n+\n+```java\n+public class MyApp {\n+ \n+    public static void main(String[] args) {\n+        try (OtlpGrpcSpanExporter otlpExporter = OtlpGrpcSpanExporter.builder().build();\n+              BatchSpanProcessor otlpProcessor = BatchSpanProcessor.builder(otlpExporter).build()) {\n+            OpenTelemetrySdk sdk = OpenTelemetrySdk.builder()\n+                .setTracerProvider(TracerSdkProvider.builder()\n+                                        .addSpanProcessor(otlpProcessor)\n+                                        .build())\n+                .build();\n+ \n+            Server server = Server.builder().setOpenTelemetry(sdk).build();\n+            server.listenAndServe();\n+        }\n+    }\n+\n+}\n+```\n+\n+```java\n+@Component\n+public class MyModule {\n+\n+    @Bean\n+    // If SpanExporter extends Closeable, it's automatically closed\n+    OtlpGrpcSpanExporter otlpExporter() {\n+        return OtlpGrpcSpanExporter.builder().build()\n+    }\n+   \n+    @Bean\n+    // If BatchSpanProcessor extends Closeable, it's automatically closed\n+    BatchSpanProcessor otlpSpanProcessor(OtlpGrpcSpanExporter otlpExporter) {\n+        return BatchSpanProcessor.builder(otlpExporter).build();\n+    }\n+ \n+    @Bean\n+    TracerSdkProvider tracerProvider(BatchSpanProcessor otlpSpanProcessor) {\n+        return TracerSdkProvider.builder().addSpanProcessor(otlpSpanProcessor).build();\n+    }\n+\n+    @Bean\n+    OpenTelemetrySdk openTelemetry(TracerSdkProvider tracerProvider) {\n+        return OpenTelemetrySdk.builder().setTracerProvider(tracerProvider).build();\n+    }\n+}\n+```\n+\n+The `OpenTelemetrySdk` and `TracerSdkProvider` are still exposed to provide access to `forceFlush`.\n+This makes it seem like `forceFlush`, though implemented in the SDK, may be more appropriate for the\n+API as it's an end-user API - it could make the separation of concerns of the initialization of the\n+SDK and the end-user tracing API complete. But the spec currently does not allow it.\n+\n+## Library instrumentation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg4MDI5NQ=="}, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 562}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwMzg1MTExOnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QwOTowMDo1NlrOIExzdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QxMTozMjoyM1rOIEzUTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg4MTIwNg==", "bodyText": "So what is the essential difference between this case and the \"full\" OpenTelemetrySdkBuilder above?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541881206", "createdAt": "2020-12-13T09:00:56Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.\n+An alternative is to flatten all settings onto `OpenTelemetrySdkBuilder` - this has a downside that\n+it makes it very natural to create new tracer / meter providers for each configuration of the SDK,\n+which could result in a lot of duplication of resources like threads, workers, TCP connections. So\n+instead, this can make it clearer that those signals themselves are full-featured, and \n+`OpenTelemetry` is just a bag of signals.\n+\n+Keep in mind, reconfiguring `Clock` is expected to be an extremely uncommon operation.\n+\n+Another thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+    @Bean\n+    public Resource resource() {\n+        return Resource.getDefault().merge(CoolResource.getDefault());\n+    }\n+    \n+    @Bean\n+    public Clock otelClock() {\n+        return AtomicClock.create();\n+    }\n+\n+    @Bean\n+    public TracerSdkProvider tracerProvider(Resource resource, Clock clock, MonitoringConfig config) {\n+        return TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(config.getOtlpExporter().getEndpoint())\n+                    .setTimeout(config.getOtlpExporter().getTimeout())\n+                    .build())\n+                .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+                .setTimeout(config.getOtlpExporter().getTimeout())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(config.getZipkinExporter().getEndpoint())\n+                    .build())\n+                .build())\n+            .setTraceSampler(config.getSamplingRate() != 0 \n+               ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+    }\n+  \n+    @Bean\n+    public MeterSdkProvider meterProvider(Resource resource, Clock clock) {\n+        return MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public IntervalMetricReader metricReader(MeterSdkProvider meterProvider) {\n+        return IntervalMetricReader.builder()\n+            .addMetricProducer(meterProvider.getMetricProducer())\n+            .addMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public OpenTelemetry openTelemetry(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+           .addPropagator(B3Propagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+\n+    @Bean\n+    @ForJaeger\n+    public OpenTelemetry openTelemetryJaeger(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+  \n+    @Bean\n+    public AuthServiceStub authService(@ForJaeger OpenTelemetry openTelemetry, AuthConfig config) {\n+        return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+          .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+    }\n+    \n+    @Bean\n+    public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+        return TracingServletFilter.create(openTelemetry);\n+    }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason initialization ordering, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. It is expected that frameworks or end-users will set the SDK as the global to support\n+instrumentation that requires this.\n+\n+Before an SDK has been set, access to the global `OpenTelemetry` will return a no-op \n+`DefaultOpenTelemetry`. This is because it is possible library instrumentation is using the global,\n+and it may even use it during the processing of a request (rather than only at initialization time).\n+For this reason, we cannot throw an exception. Instead, if the SDK is detected on the classpath, we\n+will log a `SEVERE` warning once-only indicating the API has been accessed before the SDK configured\n+with directions on how a user could solve the problem. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note about Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+        tracer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+        Tracer tracer = this.tracer;\n+        if (tracer != null) {\n+          tracer.spanBuilder(\"export\").startSpan();\n+        }\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+    public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+        tracerProvider.addSpanExporter(exporter);\n+        components.add(exporter);\n+    }\n+    \n+    public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+        tracerProvider.setSampler(sampler);\n+        components.add(sampler);\n+    }\n+    \n+    public OpenTelemetry build() {\n+        OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+        for (OpenTelemetryComponent component : components) {\n+          component.setOpenTelemetry(sdk);\n+        }\n+    }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+    @Bean\n+    @ForSpanExporter\n+    public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+    }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+    private Lazy<Tracer> tracer;\n+    \n+    @Inject\n+    public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+    }\n+    \n+    @Override\n+    public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+    }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+## TracerSdkManagement\n+\n+With the proposal to make a configured SDK fully built rather than allowing configuration\n+mutability, the SDK management interface would only have `shutdown` and `forceFlush`. It seems\n+reasonable to actually remove `shutdown` from the `TracerSdkProvider` - the SDK provider is mostly\n+a bag of parts and has no intrinsic component, if instead components like `BatchSpanProcessor` and\n+`SpanExporter` implement `Closeable`, we can model shutdown as the responsibility of the creator of\n+the resources, which is idiomatic. In DI frameworks, this would generally be automatic. This would\n+prevent the case where two `TracerProvider` share an exporter and one of them is shutdown - when\n+shutting down the exporter, shut down the exporter.\n+\n+```java\n+public class MyApp {\n+ \n+    public static void main(String[] args) {\n+        try (OtlpGrpcSpanExporter otlpExporter = OtlpGrpcSpanExporter.builder().build();\n+              BatchSpanProcessor otlpProcessor = BatchSpanProcessor.builder(otlpExporter).build()) {\n+            OpenTelemetrySdk sdk = OpenTelemetrySdk.builder()\n+                .setTracerProvider(TracerSdkProvider.builder()\n+                                        .addSpanProcessor(otlpProcessor)\n+                                        .build())\n+                .build();\n+ \n+            Server server = Server.builder().setOpenTelemetry(sdk).build();\n+            server.listenAndServe();\n+        }\n+    }\n+\n+}\n+```\n+\n+```java\n+@Component\n+public class MyModule {\n+\n+    @Bean\n+    // If SpanExporter extends Closeable, it's automatically closed\n+    OtlpGrpcSpanExporter otlpExporter() {\n+        return OtlpGrpcSpanExporter.builder().build()\n+    }\n+   \n+    @Bean\n+    // If BatchSpanProcessor extends Closeable, it's automatically closed\n+    BatchSpanProcessor otlpSpanProcessor(OtlpGrpcSpanExporter otlpExporter) {\n+        return BatchSpanProcessor.builder(otlpExporter).build();\n+    }\n+ \n+    @Bean\n+    TracerSdkProvider tracerProvider(BatchSpanProcessor otlpSpanProcessor) {\n+        return TracerSdkProvider.builder().addSpanProcessor(otlpSpanProcessor).build();\n+    }\n+\n+    @Bean\n+    OpenTelemetrySdk openTelemetry(TracerSdkProvider tracerProvider) {\n+        return OpenTelemetrySdk.builder().setTracerProvider(tracerProvider).build();\n+    }\n+}\n+```\n+\n+The `OpenTelemetrySdk` and `TracerSdkProvider` are still exposed to provide access to `forceFlush`.\n+This makes it seem like `forceFlush`, though implemented in the SDK, may be more appropriate for the\n+API as it's an end-user API - it could make the separation of concerns of the initialization of the\n+SDK and the end-user tracing API complete. But the spec currently does not allow it.\n+\n+## Library instrumentation\n+\n+As the configuration of observability is contained on `OpenTelemetry` instances, it is expected that\n+library instrumentation accept an `OpenTelemetry` instance, often as a builder for their e.g.,\n+tracing interceptor, when configuring observability. An alternative method that leaves out the\n+parameter and falls back to the global can be added as well. Library authors would still have the\n+choice of starting with using the global and adding configurability by accepting `OpenTelemetry` if\n+users request it - we would expect official `OpenTelemetry` maintained library instrumentation to\n+follow our pattern though.\n+\n+## Auto-configuration\n+\n+The above presents programmatic configuration for the SDK and proposes that the core SDK has no\n+other mechanism for configuration. There is no SPI nor processing of environment variables or\n+system properties. There are many mechanisms for configuration, for example Spring Boot. \n+Integration with these systems becomes easier to reason about if we consider auto-configuration at\n+a layer above the core SDK.\n+\n+### Java Auto-Instrumentation Agent\n+\n+Java Auto-Instrumentation Agent is the primary means of automatically configuring the SDK. It\n+contains system properties, environment variables, and SPIs for allowing a user to have a fully\n+setup tracing configuration just by applying the agent. In fact, the agent does not even allow a\n+user to use the SDK directly, actively blocking it. Instead of having a situation where some\n+configuration is automatic in the core SDK and some in the agent, we can move it all to the agent.\n+The agent already exposes exporter SPIs - it can also expose SPIs for customization of the SDK\n+components that are manually configured above.\n+\n+- We could consider having a very similar autoconfiguration wrapper artifact as an SDK extension too.\n+But we would assume the core SDK is always manually configured.\n+\n+To allow users of the agent to apply tracing to their own code, the agent should attempt to\n+instrument dependency injection to provide an instance of `OpenTelemetry` using the agent-configured\n+SDK, for example it should add it to the Spring `ApplicationContext`. For cases where dependency\n+injection is not available, though, there is no option but to provide access to the SDK through a\n+global variable. We can expect such usage to still function correctly even if the agent is removed\n+and a different configuration mechanism is used, such as manual configuration as above, or Spring\n+Sleuth.\n+\n+### SDK Auto-Configuration Wrapper\n+\n+For non-agent users, we can still provide a non-programmatic solution for configuring the SDK -\n+it can be a different artifact which contains SPIs similar to what we have currently, supports\n+environment variables and other auto-configuration. A single entrypoint method, `initialize()` could\n+determine the configuration, initialize `OpenTelemetry`, and set it as the global. As this artifact\n+is in our control, it would be reasonable for `opentelemetry-api` to check the classpath for the\n+presence of the wrapper and invoke it automatically.\n+\n+### Spring Sleuth\n+\n+[Spring Sleuth](https://spring.io/projects/spring-cloud-sleuth) (or any similar observability-aware server framework such as \n+[curio-server-framework](https://github.com/curioswitch/curiostack/blob/master/common/server/framework/src/main/java/org/curioswitch/common/server/framework/monitoring/MonitoringModule.java)\n+or internal frameworks developed by devops teams at companies) is also a mechanism for automatically\n+configuring the SDK. In general, we would expect Sleuth users to not be using the java agent.\n+\n+Examples of how Sleuth could work are presented above in examples using `@Bean`. In particular, we\n+expect it to have its own set of configuration properties - by making sure we don't implement\n+configuration properties in the core SDK, only configuration layers like the agent or a possible\n+configuration wrapper, we avoid the possibility of confusion by having duplicate variables (in\n+practice, OpenTelemetry naming would likely be ignored and overwritten by Spring naming).\n+\n+## Partial SDKs\n+\n+We allow implementing particular signals of the OpenTelemetry API without using our SDK. For example,\n+a MeterProvider may be implemented with micrometer. For this reason, each signal must also present\n+all of its options in the form of, e.g., `TracerSdkProviderBuilder`. We expect the vast majority of\n+users to use `OpenTelemetrySdkBuilder` - while there is some duplication with the signal provider\n+builder, it is work maintainers can do to present the simplest interface for the most common use\n+case of using the whole SDK.\n+\n+Without SPI, the way to initialize a partial SDK would be to use `DefaultOpenTelemetry`.\n+\n+```java\n+@Bean\n+public OpenTelemetry openTelemetry() {\n+  return DefaultOpenTelemetry.builder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 637}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkwNTk5OA==", "bodyText": "The SDK builder returns types that expose forceFlush and shutdown as required by the spec. Hence me filing issues to try to get rid of those :-)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541905998", "createdAt": "2020-12-13T11:32:23Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.\n+An alternative is to flatten all settings onto `OpenTelemetrySdkBuilder` - this has a downside that\n+it makes it very natural to create new tracer / meter providers for each configuration of the SDK,\n+which could result in a lot of duplication of resources like threads, workers, TCP connections. So\n+instead, this can make it clearer that those signals themselves are full-featured, and \n+`OpenTelemetry` is just a bag of signals.\n+\n+Keep in mind, reconfiguring `Clock` is expected to be an extremely uncommon operation.\n+\n+Another thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+    @Bean\n+    public Resource resource() {\n+        return Resource.getDefault().merge(CoolResource.getDefault());\n+    }\n+    \n+    @Bean\n+    public Clock otelClock() {\n+        return AtomicClock.create();\n+    }\n+\n+    @Bean\n+    public TracerSdkProvider tracerProvider(Resource resource, Clock clock, MonitoringConfig config) {\n+        return TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(config.getOtlpExporter().getEndpoint())\n+                    .setTimeout(config.getOtlpExporter().getTimeout())\n+                    .build())\n+                .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+                .setTimeout(config.getOtlpExporter().getTimeout())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(config.getZipkinExporter().getEndpoint())\n+                    .build())\n+                .build())\n+            .setTraceSampler(config.getSamplingRate() != 0 \n+               ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+    }\n+  \n+    @Bean\n+    public MeterSdkProvider meterProvider(Resource resource, Clock clock) {\n+        return MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public IntervalMetricReader metricReader(MeterSdkProvider meterProvider) {\n+        return IntervalMetricReader.builder()\n+            .addMetricProducer(meterProvider.getMetricProducer())\n+            .addMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public OpenTelemetry openTelemetry(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+           .addPropagator(B3Propagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+\n+    @Bean\n+    @ForJaeger\n+    public OpenTelemetry openTelemetryJaeger(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+  \n+    @Bean\n+    public AuthServiceStub authService(@ForJaeger OpenTelemetry openTelemetry, AuthConfig config) {\n+        return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+          .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+    }\n+    \n+    @Bean\n+    public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+        return TracingServletFilter.create(openTelemetry);\n+    }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason initialization ordering, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. It is expected that frameworks or end-users will set the SDK as the global to support\n+instrumentation that requires this.\n+\n+Before an SDK has been set, access to the global `OpenTelemetry` will return a no-op \n+`DefaultOpenTelemetry`. This is because it is possible library instrumentation is using the global,\n+and it may even use it during the processing of a request (rather than only at initialization time).\n+For this reason, we cannot throw an exception. Instead, if the SDK is detected on the classpath, we\n+will log a `SEVERE` warning once-only indicating the API has been accessed before the SDK configured\n+with directions on how a user could solve the problem. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note about Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+        tracer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+        Tracer tracer = this.tracer;\n+        if (tracer != null) {\n+          tracer.spanBuilder(\"export\").startSpan();\n+        }\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+    public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+        tracerProvider.addSpanExporter(exporter);\n+        components.add(exporter);\n+    }\n+    \n+    public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+        tracerProvider.setSampler(sampler);\n+        components.add(sampler);\n+    }\n+    \n+    public OpenTelemetry build() {\n+        OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+        for (OpenTelemetryComponent component : components) {\n+          component.setOpenTelemetry(sdk);\n+        }\n+    }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+    @Bean\n+    @ForSpanExporter\n+    public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+    }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+    private Lazy<Tracer> tracer;\n+    \n+    @Inject\n+    public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+    }\n+    \n+    @Override\n+    public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+    }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+## TracerSdkManagement\n+\n+With the proposal to make a configured SDK fully built rather than allowing configuration\n+mutability, the SDK management interface would only have `shutdown` and `forceFlush`. It seems\n+reasonable to actually remove `shutdown` from the `TracerSdkProvider` - the SDK provider is mostly\n+a bag of parts and has no intrinsic component, if instead components like `BatchSpanProcessor` and\n+`SpanExporter` implement `Closeable`, we can model shutdown as the responsibility of the creator of\n+the resources, which is idiomatic. In DI frameworks, this would generally be automatic. This would\n+prevent the case where two `TracerProvider` share an exporter and one of them is shutdown - when\n+shutting down the exporter, shut down the exporter.\n+\n+```java\n+public class MyApp {\n+ \n+    public static void main(String[] args) {\n+        try (OtlpGrpcSpanExporter otlpExporter = OtlpGrpcSpanExporter.builder().build();\n+              BatchSpanProcessor otlpProcessor = BatchSpanProcessor.builder(otlpExporter).build()) {\n+            OpenTelemetrySdk sdk = OpenTelemetrySdk.builder()\n+                .setTracerProvider(TracerSdkProvider.builder()\n+                                        .addSpanProcessor(otlpProcessor)\n+                                        .build())\n+                .build();\n+ \n+            Server server = Server.builder().setOpenTelemetry(sdk).build();\n+            server.listenAndServe();\n+        }\n+    }\n+\n+}\n+```\n+\n+```java\n+@Component\n+public class MyModule {\n+\n+    @Bean\n+    // If SpanExporter extends Closeable, it's automatically closed\n+    OtlpGrpcSpanExporter otlpExporter() {\n+        return OtlpGrpcSpanExporter.builder().build()\n+    }\n+   \n+    @Bean\n+    // If BatchSpanProcessor extends Closeable, it's automatically closed\n+    BatchSpanProcessor otlpSpanProcessor(OtlpGrpcSpanExporter otlpExporter) {\n+        return BatchSpanProcessor.builder(otlpExporter).build();\n+    }\n+ \n+    @Bean\n+    TracerSdkProvider tracerProvider(BatchSpanProcessor otlpSpanProcessor) {\n+        return TracerSdkProvider.builder().addSpanProcessor(otlpSpanProcessor).build();\n+    }\n+\n+    @Bean\n+    OpenTelemetrySdk openTelemetry(TracerSdkProvider tracerProvider) {\n+        return OpenTelemetrySdk.builder().setTracerProvider(tracerProvider).build();\n+    }\n+}\n+```\n+\n+The `OpenTelemetrySdk` and `TracerSdkProvider` are still exposed to provide access to `forceFlush`.\n+This makes it seem like `forceFlush`, though implemented in the SDK, may be more appropriate for the\n+API as it's an end-user API - it could make the separation of concerns of the initialization of the\n+SDK and the end-user tracing API complete. But the spec currently does not allow it.\n+\n+## Library instrumentation\n+\n+As the configuration of observability is contained on `OpenTelemetry` instances, it is expected that\n+library instrumentation accept an `OpenTelemetry` instance, often as a builder for their e.g.,\n+tracing interceptor, when configuring observability. An alternative method that leaves out the\n+parameter and falls back to the global can be added as well. Library authors would still have the\n+choice of starting with using the global and adding configurability by accepting `OpenTelemetry` if\n+users request it - we would expect official `OpenTelemetry` maintained library instrumentation to\n+follow our pattern though.\n+\n+## Auto-configuration\n+\n+The above presents programmatic configuration for the SDK and proposes that the core SDK has no\n+other mechanism for configuration. There is no SPI nor processing of environment variables or\n+system properties. There are many mechanisms for configuration, for example Spring Boot. \n+Integration with these systems becomes easier to reason about if we consider auto-configuration at\n+a layer above the core SDK.\n+\n+### Java Auto-Instrumentation Agent\n+\n+Java Auto-Instrumentation Agent is the primary means of automatically configuring the SDK. It\n+contains system properties, environment variables, and SPIs for allowing a user to have a fully\n+setup tracing configuration just by applying the agent. In fact, the agent does not even allow a\n+user to use the SDK directly, actively blocking it. Instead of having a situation where some\n+configuration is automatic in the core SDK and some in the agent, we can move it all to the agent.\n+The agent already exposes exporter SPIs - it can also expose SPIs for customization of the SDK\n+components that are manually configured above.\n+\n+- We could consider having a very similar autoconfiguration wrapper artifact as an SDK extension too.\n+But we would assume the core SDK is always manually configured.\n+\n+To allow users of the agent to apply tracing to their own code, the agent should attempt to\n+instrument dependency injection to provide an instance of `OpenTelemetry` using the agent-configured\n+SDK, for example it should add it to the Spring `ApplicationContext`. For cases where dependency\n+injection is not available, though, there is no option but to provide access to the SDK through a\n+global variable. We can expect such usage to still function correctly even if the agent is removed\n+and a different configuration mechanism is used, such as manual configuration as above, or Spring\n+Sleuth.\n+\n+### SDK Auto-Configuration Wrapper\n+\n+For non-agent users, we can still provide a non-programmatic solution for configuring the SDK -\n+it can be a different artifact which contains SPIs similar to what we have currently, supports\n+environment variables and other auto-configuration. A single entrypoint method, `initialize()` could\n+determine the configuration, initialize `OpenTelemetry`, and set it as the global. As this artifact\n+is in our control, it would be reasonable for `opentelemetry-api` to check the classpath for the\n+presence of the wrapper and invoke it automatically.\n+\n+### Spring Sleuth\n+\n+[Spring Sleuth](https://spring.io/projects/spring-cloud-sleuth) (or any similar observability-aware server framework such as \n+[curio-server-framework](https://github.com/curioswitch/curiostack/blob/master/common/server/framework/src/main/java/org/curioswitch/common/server/framework/monitoring/MonitoringModule.java)\n+or internal frameworks developed by devops teams at companies) is also a mechanism for automatically\n+configuring the SDK. In general, we would expect Sleuth users to not be using the java agent.\n+\n+Examples of how Sleuth could work are presented above in examples using `@Bean`. In particular, we\n+expect it to have its own set of configuration properties - by making sure we don't implement\n+configuration properties in the core SDK, only configuration layers like the agent or a possible\n+configuration wrapper, we avoid the possibility of confusion by having duplicate variables (in\n+practice, OpenTelemetry naming would likely be ignored and overwritten by Spring naming).\n+\n+## Partial SDKs\n+\n+We allow implementing particular signals of the OpenTelemetry API without using our SDK. For example,\n+a MeterProvider may be implemented with micrometer. For this reason, each signal must also present\n+all of its options in the form of, e.g., `TracerSdkProviderBuilder`. We expect the vast majority of\n+users to use `OpenTelemetrySdkBuilder` - while there is some duplication with the signal provider\n+builder, it is work maintainers can do to present the simplest interface for the most common use\n+case of using the whole SDK.\n+\n+Without SPI, the way to initialize a partial SDK would be to use `DefaultOpenTelemetry`.\n+\n+```java\n+@Bean\n+public OpenTelemetry openTelemetry() {\n+  return DefaultOpenTelemetry.builder()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg4MTIwNg=="}, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 637}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyNzc1NTE1OnYy", "diffSide": "RIGHT", "path": "docs/sdk-configuration.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDozODo0MFrOIIH4jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwMDoxOTozOVrOIIOJaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM4ODY4NA==", "bodyText": "I might just call this one build().  ;)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r545388684", "createdAt": "2020-12-17T20:38:40Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,612 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Very familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7139fe83fde9863e4db48bb39a616c5fcba391ef"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ5MTMwNQ==", "bodyText": "See my note that I think this needs to be a conscious decision, though admittedly don't like the name much either :P", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r545491305", "createdAt": "2020-12-18T00:19:39Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,612 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Very familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM4ODY4NA=="}, "originalCommit": {"oid": "7139fe83fde9863e4db48bb39a616c5fcba391ef"}, "originalPosition": 83}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1690, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}