{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwODAzMDkw", "number": 815, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDo1MTo1NlrODdH7Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMToxNjo0NFrODeJ01w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxODY1MDk1OnYy", "diffSide": "RIGHT", "path": "jmh.gradle", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDo1MTo1NlrOFljCaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQwNzoxNToxNlrOFlttYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkxNTY4OA==", "bodyText": "any idea why all these reformats happened?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/815#discussion_r374915688", "createdAt": "2020-02-04T20:51:56Z", "author": {"login": "jkwatson"}, "path": "jmh.gradle", "diffHunk": "@@ -52,10 +52,10 @@\n \n sourceSets {\n     jmh {\n-\tjava.srcDir 'src/jmh/java'\n-\tresources.srcDir 'src/jmh/resources'\n-\tcompileClasspath += main.output\n-\truntimeClasspath += main.output\n+        java.srcDir 'src/jmh/java'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5de141cba53cb97161c1fa7e5573d165cc12ef"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1MzA3MA==", "bodyText": "If these are expected reformats consider to send a quick PR to do only the reformat and will merge that asap.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/815#discussion_r374953070", "createdAt": "2020-02-04T22:13:30Z", "author": {"login": "bogdandrutu"}, "path": "jmh.gradle", "diffHunk": "@@ -52,10 +52,10 @@\n \n sourceSets {\n     jmh {\n-\tjava.srcDir 'src/jmh/java'\n-\tresources.srcDir 'src/jmh/resources'\n-\tcompileClasspath += main.output\n-\truntimeClasspath += main.output\n+        java.srcDir 'src/jmh/java'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkxNTY4OA=="}, "originalCommit": {"oid": "ad5de141cba53cb97161c1fa7e5573d165cc12ef"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA5MDUyOA==", "bodyText": "yeap i reformat it according to others *.gradle files and also change deprecated method, will do in another PR as suggested", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/815#discussion_r375090528", "createdAt": "2020-02-05T07:15:16Z", "author": {"login": "vladislav-kiva"}, "path": "jmh.gradle", "diffHunk": "@@ -52,10 +52,10 @@\n \n sourceSets {\n     jmh {\n-\tjava.srcDir 'src/jmh/java'\n-\tresources.srcDir 'src/jmh/resources'\n-\tcompileClasspath += main.output\n-\truntimeClasspath += main.output\n+        java.srcDir 'src/jmh/java'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkxNTY4OA=="}, "originalCommit": {"oid": "ad5de141cba53cb97161c1fa7e5573d165cc12ef"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxODgzNjAwOnYy", "diffSide": "RIGHT", "path": "api/src/jmh/java/io/opentelemetry/trace/propagation/HttpTraceContextExtractBenchmark.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMTo1NDo1MVrOFlk0rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMTowMjoxOFrOFmHDWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk0NDk0MA==", "bodyText": "Wondering if it would be useful to use more 'complex' ids.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/815#discussion_r374944940", "createdAt": "2020-02-04T21:54:51Z", "author": {"login": "carlosalberto"}, "path": "api/src/jmh/java/io/opentelemetry/trace/propagation/HttpTraceContextExtractBenchmark.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat.Getter;\n+import io.opentelemetry.trace.SpanContext;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@State(Scope.Thread)\n+public class HttpTraceContextExtractBenchmark {\n+\n+  private String traceIdBase16 = \"ff000000000000000000000000000041\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad5de141cba53cb97161c1fa7e5573d165cc12ef"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA5MTI0Mg==", "bodyText": "@carlosalberto it depend what do u mean by more 'complex', if u can provide me some examples i can include them", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/815#discussion_r375091242", "createdAt": "2020-02-05T07:17:34Z", "author": {"login": "DotSpy"}, "path": "api/src/jmh/java/io/opentelemetry/trace/propagation/HttpTraceContextExtractBenchmark.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat.Getter;\n+import io.opentelemetry.trace.SpanContext;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@State(Scope.Thread)\n+public class HttpTraceContextExtractBenchmark {\n+\n+  private String traceIdBase16 = \"ff000000000000000000000000000041\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk0NDk0MA=="}, "originalCommit": {"oid": "ad5de141cba53cb97161c1fa7e5573d165cc12ef"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUwNTc1Mg==", "bodyText": "we could pre-generate a bunch of random trace/span ids and use them for the benchmarks.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/815#discussion_r375505752", "createdAt": "2020-02-05T21:02:18Z", "author": {"login": "jkwatson"}, "path": "api/src/jmh/java/io/opentelemetry/trace/propagation/HttpTraceContextExtractBenchmark.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat.Getter;\n+import io.opentelemetry.trace.SpanContext;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@State(Scope.Thread)\n+public class HttpTraceContextExtractBenchmark {\n+\n+  private String traceIdBase16 = \"ff000000000000000000000000000041\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk0NDk0MA=="}, "originalCommit": {"oid": "ad5de141cba53cb97161c1fa7e5573d165cc12ef"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTQ0ODU1OnYy", "diffSide": "RIGHT", "path": "api/src/jmh/java/io/opentelemetry/trace/propagation/HttpTraceContextInjectBenchmark.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMToxNjo0NFrOFnKiiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMTo0ODoxM1rOFnLQ4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxMTQ2NQ==", "bodyText": "Curious about the usage of a Linked hashmap here. Why not just a plain HashMap?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/815#discussion_r376611465", "createdAt": "2020-02-07T21:16:44Z", "author": {"login": "jkwatson"}, "path": "api/src/jmh/java/io/opentelemetry/trace/propagation/HttpTraceContextInjectBenchmark.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat.Setter;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@State(Scope.Thread)\n+public class HttpTraceContextInjectBenchmark {\n+\n+  @Param({\n+    \"905734c59b913b4a905734c59b913b4a\",\n+    \"21196a77f299580e21196a77f299580e\",\n+    \"2e7d0ad2390617702e7d0ad239061770\",\n+    \"905734c59b913b4a905734c59b913b4a\",\n+    \"68ec932c33b3f2ee68ec932c33b3f2ee\"\n+  })\n+  public static String traceIdBase16;\n+\n+  @Param({\n+    \"9909983295041501\",\n+    \"993a97ee3691eb26\",\n+    \"d49582a2de984b86\",\n+    \"776ff807b787538a\",\n+    \"68ec932c33b3f2ee\"\n+  })\n+  public static String spanIdBase16;\n+\n+  private byte sampledTraceOptionsBytes = 1;\n+  private TraceFlags sampledTraceOptions = TraceFlags.fromByte(sampledTraceOptionsBytes);\n+  private TraceState traceStateDefault = TraceState.builder().build();\n+\n+  private HttpTraceContext httpTraceContext;\n+  private Map<String, String> carrier;\n+  private Setter<Map<String, String>> setter =\n+      new Setter<Map<String, String>>() {\n+        @Override\n+        public void set(Map<String, String> carrier, String key, String value) {\n+          carrier.put(key, value);\n+        }\n+      };\n+\n+  @State(Scope.Thread)\n+  public static class HttpTraceContextInjectState {\n+\n+    public TraceId traceId;\n+    public SpanId spanId;\n+\n+    @Setup\n+    public void setup() {\n+      this.traceId = TraceId.fromLowerBase16(traceIdBase16, 0);\n+      this.spanId = SpanId.fromLowerBase16(spanIdBase16, 0);\n+    }\n+  }\n+\n+  @Setup\n+  public void setup() {\n+    this.httpTraceContext = new HttpTraceContext();\n+    this.carrier = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb518d0f5bb285fcd4bc185cd9f2d14b60c4afd9"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxMzgwNA==", "bodyText": "Since we adding\\removing only one value i don't think it have any difference at all with usual HashMap, i used linked because saw it here HttpTraceContextTest", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/815#discussion_r376613804", "createdAt": "2020-02-07T21:23:14Z", "author": {"login": "DotSpy"}, "path": "api/src/jmh/java/io/opentelemetry/trace/propagation/HttpTraceContextInjectBenchmark.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat.Setter;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@State(Scope.Thread)\n+public class HttpTraceContextInjectBenchmark {\n+\n+  @Param({\n+    \"905734c59b913b4a905734c59b913b4a\",\n+    \"21196a77f299580e21196a77f299580e\",\n+    \"2e7d0ad2390617702e7d0ad239061770\",\n+    \"905734c59b913b4a905734c59b913b4a\",\n+    \"68ec932c33b3f2ee68ec932c33b3f2ee\"\n+  })\n+  public static String traceIdBase16;\n+\n+  @Param({\n+    \"9909983295041501\",\n+    \"993a97ee3691eb26\",\n+    \"d49582a2de984b86\",\n+    \"776ff807b787538a\",\n+    \"68ec932c33b3f2ee\"\n+  })\n+  public static String spanIdBase16;\n+\n+  private byte sampledTraceOptionsBytes = 1;\n+  private TraceFlags sampledTraceOptions = TraceFlags.fromByte(sampledTraceOptionsBytes);\n+  private TraceState traceStateDefault = TraceState.builder().build();\n+\n+  private HttpTraceContext httpTraceContext;\n+  private Map<String, String> carrier;\n+  private Setter<Map<String, String>> setter =\n+      new Setter<Map<String, String>>() {\n+        @Override\n+        public void set(Map<String, String> carrier, String key, String value) {\n+          carrier.put(key, value);\n+        }\n+      };\n+\n+  @State(Scope.Thread)\n+  public static class HttpTraceContextInjectState {\n+\n+    public TraceId traceId;\n+    public SpanId spanId;\n+\n+    @Setup\n+    public void setup() {\n+      this.traceId = TraceId.fromLowerBase16(traceIdBase16, 0);\n+      this.spanId = SpanId.fromLowerBase16(spanIdBase16, 0);\n+    }\n+  }\n+\n+  @Setup\n+  public void setup() {\n+    this.httpTraceContext = new HttpTraceContext();\n+    this.carrier = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxMTQ2NQ=="}, "originalCommit": {"oid": "fb518d0f5bb285fcd4bc185cd9f2d14b60c4afd9"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxNTE4OA==", "bodyText": "I believe that the Linked version has slightly higher overhead than the plain HashMap, so for benchmarks, I think we should prefer a HashMap over a LinkedHashMap, unless we have a need to preserve order (which it sounds like we don't).", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/815#discussion_r376615188", "createdAt": "2020-02-07T21:26:46Z", "author": {"login": "jkwatson"}, "path": "api/src/jmh/java/io/opentelemetry/trace/propagation/HttpTraceContextInjectBenchmark.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat.Setter;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@State(Scope.Thread)\n+public class HttpTraceContextInjectBenchmark {\n+\n+  @Param({\n+    \"905734c59b913b4a905734c59b913b4a\",\n+    \"21196a77f299580e21196a77f299580e\",\n+    \"2e7d0ad2390617702e7d0ad239061770\",\n+    \"905734c59b913b4a905734c59b913b4a\",\n+    \"68ec932c33b3f2ee68ec932c33b3f2ee\"\n+  })\n+  public static String traceIdBase16;\n+\n+  @Param({\n+    \"9909983295041501\",\n+    \"993a97ee3691eb26\",\n+    \"d49582a2de984b86\",\n+    \"776ff807b787538a\",\n+    \"68ec932c33b3f2ee\"\n+  })\n+  public static String spanIdBase16;\n+\n+  private byte sampledTraceOptionsBytes = 1;\n+  private TraceFlags sampledTraceOptions = TraceFlags.fromByte(sampledTraceOptionsBytes);\n+  private TraceState traceStateDefault = TraceState.builder().build();\n+\n+  private HttpTraceContext httpTraceContext;\n+  private Map<String, String> carrier;\n+  private Setter<Map<String, String>> setter =\n+      new Setter<Map<String, String>>() {\n+        @Override\n+        public void set(Map<String, String> carrier, String key, String value) {\n+          carrier.put(key, value);\n+        }\n+      };\n+\n+  @State(Scope.Thread)\n+  public static class HttpTraceContextInjectState {\n+\n+    public TraceId traceId;\n+    public SpanId spanId;\n+\n+    @Setup\n+    public void setup() {\n+      this.traceId = TraceId.fromLowerBase16(traceIdBase16, 0);\n+      this.spanId = SpanId.fromLowerBase16(spanIdBase16, 0);\n+    }\n+  }\n+\n+  @Setup\n+  public void setup() {\n+    this.httpTraceContext = new HttpTraceContext();\n+    this.carrier = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxMTQ2NQ=="}, "originalCommit": {"oid": "fb518d0f5bb285fcd4bc185cd9f2d14b60c4afd9"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyMzMyOA==", "bodyText": "agree", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/815#discussion_r376623328", "createdAt": "2020-02-07T21:48:13Z", "author": {"login": "DotSpy"}, "path": "api/src/jmh/java/io/opentelemetry/trace/propagation/HttpTraceContextInjectBenchmark.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat.Setter;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@State(Scope.Thread)\n+public class HttpTraceContextInjectBenchmark {\n+\n+  @Param({\n+    \"905734c59b913b4a905734c59b913b4a\",\n+    \"21196a77f299580e21196a77f299580e\",\n+    \"2e7d0ad2390617702e7d0ad239061770\",\n+    \"905734c59b913b4a905734c59b913b4a\",\n+    \"68ec932c33b3f2ee68ec932c33b3f2ee\"\n+  })\n+  public static String traceIdBase16;\n+\n+  @Param({\n+    \"9909983295041501\",\n+    \"993a97ee3691eb26\",\n+    \"d49582a2de984b86\",\n+    \"776ff807b787538a\",\n+    \"68ec932c33b3f2ee\"\n+  })\n+  public static String spanIdBase16;\n+\n+  private byte sampledTraceOptionsBytes = 1;\n+  private TraceFlags sampledTraceOptions = TraceFlags.fromByte(sampledTraceOptionsBytes);\n+  private TraceState traceStateDefault = TraceState.builder().build();\n+\n+  private HttpTraceContext httpTraceContext;\n+  private Map<String, String> carrier;\n+  private Setter<Map<String, String>> setter =\n+      new Setter<Map<String, String>>() {\n+        @Override\n+        public void set(Map<String, String> carrier, String key, String value) {\n+          carrier.put(key, value);\n+        }\n+      };\n+\n+  @State(Scope.Thread)\n+  public static class HttpTraceContextInjectState {\n+\n+    public TraceId traceId;\n+    public SpanId spanId;\n+\n+    @Setup\n+    public void setup() {\n+      this.traceId = TraceId.fromLowerBase16(traceIdBase16, 0);\n+      this.spanId = SpanId.fromLowerBase16(spanIdBase16, 0);\n+    }\n+  }\n+\n+  @Setup\n+  public void setup() {\n+    this.httpTraceContext = new HttpTraceContext();\n+    this.carrier = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxMTQ2NQ=="}, "originalCommit": {"oid": "fb518d0f5bb285fcd4bc185cd9f2d14b60c4afd9"}, "originalPosition": 92}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1062, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}