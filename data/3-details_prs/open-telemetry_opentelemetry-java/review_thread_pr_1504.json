{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzMDQyODcy", "number": 1504, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNjozNDoyMVrOEVRxow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMTowODozNFrOEVoS0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzQ2Nzg3OnYy", "diffSide": "RIGHT", "path": "sdk_extensions/zpages/README.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNjozNDoyMVrOG78FZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDoxNzoyOFrOG8ZGOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwMzU5MA==", "bodyText": "I would add a sentence that describes the hardware (CPU/RAM/OS) used to obtain these results.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1504#discussion_r465503590", "createdAt": "2020-08-05T06:34:21Z", "author": {"login": "thisthat"}, "path": "sdk_extensions/zpages/README.md", "diffHunk": "@@ -98,4 +98,123 @@ details. For example, here are the details of the `ChildSpan` latency sample (ro\n The /traceconfigz zPage displays information about the currently active tracing configuration and \n provides an interface for users to modify relevant parameters. Here is what the web page looks like:\n \n-![traceconfigz](img/traceconfigz.png)\n\\ No newline at end of file\n+![traceconfigz](img/traceconfigz.png)\n+\n+## Benchmark Testing\n+\n+This module contains two sets of benchmark tests: one for adding spans to an instance of\n+TracezSpanBuckets and another for retrieving counts and spans with TracezDataAggregator. You can run\n+the tests yourself with the following commands:\n+\n+```\n+./gradlew -PjmhIncludeSingleClass=TracezSpanBucketsBenchmark clean :opentelemetry-sdk-extension-zpages:jmh\n+./gradlew -PjmhIncludeSingleClass=TracezDataAggregatorBenchmark clean :opentelemetry-sdk-extension-zpages:jmh\n+```\n+\n+The expected results for `TracezSpanBucketsBenchmark` are as follows:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f714b4397ad69538999336a4283c08c7a1b0e0a9"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwNjM3Ng==", "bodyText": "Yeah I'd personally leave these out of READMEs and paste them in PR to provide some history along with code changes. Especially, it's too hard to repro even with specs about the CPU (except if using a cloud VM) that we couldn't call them expected results.\nHaving JMH to measure future code changes in a relative way is great.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1504#discussion_r465506376", "createdAt": "2020-08-05T06:41:12Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/README.md", "diffHunk": "@@ -98,4 +98,123 @@ details. For example, here are the details of the `ChildSpan` latency sample (ro\n The /traceconfigz zPage displays information about the currently active tracing configuration and \n provides an interface for users to modify relevant parameters. Here is what the web page looks like:\n \n-![traceconfigz](img/traceconfigz.png)\n\\ No newline at end of file\n+![traceconfigz](img/traceconfigz.png)\n+\n+## Benchmark Testing\n+\n+This module contains two sets of benchmark tests: one for adding spans to an instance of\n+TracezSpanBuckets and another for retrieving counts and spans with TracezDataAggregator. You can run\n+the tests yourself with the following commands:\n+\n+```\n+./gradlew -PjmhIncludeSingleClass=TracezSpanBucketsBenchmark clean :opentelemetry-sdk-extension-zpages:jmh\n+./gradlew -PjmhIncludeSingleClass=TracezDataAggregatorBenchmark clean :opentelemetry-sdk-extension-zpages:jmh\n+```\n+\n+The expected results for `TracezSpanBucketsBenchmark` are as follows:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwMzU5MA=="}, "originalCommit": {"oid": "f714b4397ad69538999336a4283c08c7a1b0e0a9"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg5Nzk5OA==", "bodyText": "I agree. Leave them out of the README and keep them in the PR description, along with some indication of JVM version and hardware that they were run on.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1504#discussion_r465897998", "createdAt": "2020-08-05T17:45:55Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/README.md", "diffHunk": "@@ -98,4 +98,123 @@ details. For example, here are the details of the `ChildSpan` latency sample (ro\n The /traceconfigz zPage displays information about the currently active tracing configuration and \n provides an interface for users to modify relevant parameters. Here is what the web page looks like:\n \n-![traceconfigz](img/traceconfigz.png)\n\\ No newline at end of file\n+![traceconfigz](img/traceconfigz.png)\n+\n+## Benchmark Testing\n+\n+This module contains two sets of benchmark tests: one for adding spans to an instance of\n+TracezSpanBuckets and another for retrieving counts and spans with TracezDataAggregator. You can run\n+the tests yourself with the following commands:\n+\n+```\n+./gradlew -PjmhIncludeSingleClass=TracezSpanBucketsBenchmark clean :opentelemetry-sdk-extension-zpages:jmh\n+./gradlew -PjmhIncludeSingleClass=TracezDataAggregatorBenchmark clean :opentelemetry-sdk-extension-zpages:jmh\n+```\n+\n+The expected results for `TracezSpanBucketsBenchmark` are as follows:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwMzU5MA=="}, "originalCommit": {"oid": "f714b4397ad69538999336a4283c08c7a1b0e0a9"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk3ODkzNw==", "bodyText": "Updated the top level comment.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1504#discussion_r465978937", "createdAt": "2020-08-05T20:17:28Z", "author": {"login": "williamhu99"}, "path": "sdk_extensions/zpages/README.md", "diffHunk": "@@ -98,4 +98,123 @@ details. For example, here are the details of the `ChildSpan` latency sample (ro\n The /traceconfigz zPage displays information about the currently active tracing configuration and \n provides an interface for users to modify relevant parameters. Here is what the web page looks like:\n \n-![traceconfigz](img/traceconfigz.png)\n\\ No newline at end of file\n+![traceconfigz](img/traceconfigz.png)\n+\n+## Benchmark Testing\n+\n+This module contains two sets of benchmark tests: one for adding spans to an instance of\n+TracezSpanBuckets and another for retrieving counts and spans with TracezDataAggregator. You can run\n+the tests yourself with the following commands:\n+\n+```\n+./gradlew -PjmhIncludeSingleClass=TracezSpanBucketsBenchmark clean :opentelemetry-sdk-extension-zpages:jmh\n+./gradlew -PjmhIncludeSingleClass=TracezDataAggregatorBenchmark clean :opentelemetry-sdk-extension-zpages:jmh\n+```\n+\n+The expected results for `TracezSpanBucketsBenchmark` are as follows:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwMzU5MA=="}, "originalCommit": {"oid": "f714b4397ad69538999336a4283c08c7a1b0e0a9"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzQ4ODk3OnYy", "diffSide": "RIGHT", "path": "sdk_extensions/zpages/src/jmh/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorBenchmark.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNjo0MjozMlrOG78Saw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDowMDowNFrOG8YivA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwNjkyMw==", "bodyText": "Can you add an @Param for this size?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1504#discussion_r465506923", "createdAt": "2020-08-05T06:42:32Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/jmh/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorBenchmark.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+/** Benchmark class for {@link TracezDataAggregator}. */\n+@State(Scope.Benchmark)\n+public class TracezDataAggregatorBenchmark {\n+\n+  private static final String runningSpan = \"RUNNING_SPAN\";\n+  private static final String latencySpan = \"LATENCY_SPAN\";\n+  private static final String errorSpan = \"ERROR_SPAN\";\n+  private final Tracer tracer =\n+      OpenTelemetrySdk.getTracerProvider().get(\"TracezDataAggregatorBenchmark\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+\n+  @Setup(Level.Trial)\n+  public final void setup() {\n+    // Generate 1 million running spans, span latencies, and error spans\n+    for (int i = 0; i < 1000000; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f714b4397ad69538999336a4283c08c7a1b0e0a9"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwODU5Mw==", "bodyText": "Actually I guess we could use a constant for completed spans and a param for running spans, that seems to have more variable overhead. The main observation here is 1 million concurrent requests in a single app is probably not possible for almost all apps!", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1504#discussion_r465508593", "createdAt": "2020-08-05T06:46:39Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/jmh/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorBenchmark.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+/** Benchmark class for {@link TracezDataAggregator}. */\n+@State(Scope.Benchmark)\n+public class TracezDataAggregatorBenchmark {\n+\n+  private static final String runningSpan = \"RUNNING_SPAN\";\n+  private static final String latencySpan = \"LATENCY_SPAN\";\n+  private static final String errorSpan = \"ERROR_SPAN\";\n+  private final Tracer tracer =\n+      OpenTelemetrySdk.getTracerProvider().get(\"TracezDataAggregatorBenchmark\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+\n+  @Setup(Level.Trial)\n+  public final void setup() {\n+    // Generate 1 million running spans, span latencies, and error spans\n+    for (int i = 0; i < 1000000; i++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwNjkyMw=="}, "originalCommit": {"oid": "f714b4397ad69538999336a4283c08c7a1b0e0a9"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk2OTg1Mg==", "bodyText": "What should the constant be and what values should the param take? I left them as 1 million for now.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1504#discussion_r465969852", "createdAt": "2020-08-05T20:00:04Z", "author": {"login": "williamhu99"}, "path": "sdk_extensions/zpages/src/jmh/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorBenchmark.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+/** Benchmark class for {@link TracezDataAggregator}. */\n+@State(Scope.Benchmark)\n+public class TracezDataAggregatorBenchmark {\n+\n+  private static final String runningSpan = \"RUNNING_SPAN\";\n+  private static final String latencySpan = \"LATENCY_SPAN\";\n+  private static final String errorSpan = \"ERROR_SPAN\";\n+  private final Tracer tracer =\n+      OpenTelemetrySdk.getTracerProvider().get(\"TracezDataAggregatorBenchmark\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+\n+  @Setup(Level.Trial)\n+  public final void setup() {\n+    // Generate 1 million running spans, span latencies, and error spans\n+    for (int i = 0; i < 1000000; i++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwNjkyMw=="}, "originalCommit": {"oid": "f714b4397ad69538999336a4283c08c7a1b0e0a9"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzQ5MzI5OnYy", "diffSide": "RIGHT", "path": "sdk_extensions/zpages/src/jmh/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorBenchmark.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNjo0NDoxNlrOG78VHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMTowNjowNVrOG8fqNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwNzYxNA==", "bodyText": "I think it should be possible to pass this as a Gradle parameter if we need to tweak it, we don't need to copy the same benchmark over and over just to check many threads. On the flip side, it's probably nicer to just have a benchmark for each method that's a more important axis for comparison.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1504#discussion_r465507614", "createdAt": "2020-08-05T06:44:16Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/jmh/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorBenchmark.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+/** Benchmark class for {@link TracezDataAggregator}. */\n+@State(Scope.Benchmark)\n+public class TracezDataAggregatorBenchmark {\n+\n+  private static final String runningSpan = \"RUNNING_SPAN\";\n+  private static final String latencySpan = \"LATENCY_SPAN\";\n+  private static final String errorSpan = \"ERROR_SPAN\";\n+  private final Tracer tracer =\n+      OpenTelemetrySdk.getTracerProvider().get(\"TracezDataAggregatorBenchmark\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+\n+  @Setup(Level.Trial)\n+  public final void setup() {\n+    // Generate 1 million running spans, span latencies, and error spans\n+    for (int i = 0; i < 1000000; i++) {\n+      tracer.spanBuilder(runningSpan).startSpan();\n+      tracer.spanBuilder(latencySpan).startSpan().end();\n+      Span error = tracer.spanBuilder(errorSpan).startSpan();\n+      error.setStatus(Status.UNKNOWN);\n+      error.end();\n+    }\n+  }\n+\n+  /** Get span counts with 1 thread. */\n+  @Benchmark\n+  @Threads(value = 1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f714b4397ad69538999336a4283c08c7a1b0e0a9"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg5NjMxMg==", "bodyText": "Does JMH support this? I think this is one of the major limitations of the framework right now.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1504#discussion_r465896312", "createdAt": "2020-08-05T17:43:00Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/jmh/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorBenchmark.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+/** Benchmark class for {@link TracezDataAggregator}. */\n+@State(Scope.Benchmark)\n+public class TracezDataAggregatorBenchmark {\n+\n+  private static final String runningSpan = \"RUNNING_SPAN\";\n+  private static final String latencySpan = \"LATENCY_SPAN\";\n+  private static final String errorSpan = \"ERROR_SPAN\";\n+  private final Tracer tracer =\n+      OpenTelemetrySdk.getTracerProvider().get(\"TracezDataAggregatorBenchmark\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+\n+  @Setup(Level.Trial)\n+  public final void setup() {\n+    // Generate 1 million running spans, span latencies, and error spans\n+    for (int i = 0; i < 1000000; i++) {\n+      tracer.spanBuilder(runningSpan).startSpan();\n+      tracer.spanBuilder(latencySpan).startSpan().end();\n+      Span error = tracer.spanBuilder(errorSpan).startSpan();\n+      error.setStatus(Status.UNKNOWN);\n+      error.end();\n+    }\n+  }\n+\n+  /** Get span counts with 1 thread. */\n+  @Benchmark\n+  @Threads(value = 1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwNzYxNA=="}, "originalCommit": {"oid": "f714b4397ad69538999336a4283c08c7a1b0e0a9"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4NjQ1Mg==", "bodyText": "Ah I didn't think about wanting to generate the numbers for all the thread counts in one go. It seems fine then", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1504#discussion_r466086452", "createdAt": "2020-08-06T01:06:05Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/jmh/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorBenchmark.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+/** Benchmark class for {@link TracezDataAggregator}. */\n+@State(Scope.Benchmark)\n+public class TracezDataAggregatorBenchmark {\n+\n+  private static final String runningSpan = \"RUNNING_SPAN\";\n+  private static final String latencySpan = \"LATENCY_SPAN\";\n+  private static final String errorSpan = \"ERROR_SPAN\";\n+  private final Tracer tracer =\n+      OpenTelemetrySdk.getTracerProvider().get(\"TracezDataAggregatorBenchmark\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+\n+  @Setup(Level.Trial)\n+  public final void setup() {\n+    // Generate 1 million running spans, span latencies, and error spans\n+    for (int i = 0; i < 1000000; i++) {\n+      tracer.spanBuilder(runningSpan).startSpan();\n+      tracer.spanBuilder(latencySpan).startSpan().end();\n+      Span error = tracer.spanBuilder(errorSpan).startSpan();\n+      error.setStatus(Status.UNKNOWN);\n+      error.end();\n+    }\n+  }\n+\n+  /** Get span counts with 1 thread. */\n+  @Benchmark\n+  @Threads(value = 1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwNzYxNA=="}, "originalCommit": {"oid": "f714b4397ad69538999336a4283c08c7a1b0e0a9"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzUwMjI2OnYy", "diffSide": "RIGHT", "path": "sdk_extensions/zpages/src/jmh/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBucketsBenchmark.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwNjo0NzozMFrOG78abg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzo0ODoxMFrOG8UOzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwODk3NA==", "bodyText": "Ditto thread can be passed in with a Gradle command, so we don't need to duplicate benchmarks for it.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1504#discussion_r465508974", "createdAt": "2020-08-05T06:47:30Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/jmh/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBucketsBenchmark.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+/** Benchmark class for {@link TracezSpanBuckets}. */\n+@State(Scope.Benchmark)\n+public class TracezSpanBucketsBenchmark {\n+\n+  private static final String spanName = \"BENCHMARK_SPAN\";\n+  private static ReadableSpan readableSpan;\n+  private TracezSpanBuckets bucket;\n+\n+  @Setup(Level.Trial)\n+  public final void setup() {\n+    bucket = new TracezSpanBuckets();\n+    Tracer tracer = OpenTelemetrySdk.getTracerProvider().get(\"TracezZPageBenchmark\");\n+    Span span = tracer.spanBuilder(spanName).startSpan();\n+    span.end();\n+    readableSpan = (ReadableSpan) span;\n+  }\n+\n+  @Benchmark\n+  @Threads(value = 1)\n+  @Fork(1)\n+  @Warmup(iterations = 5, time = 1)\n+  @Measurement(iterations = 10, time = 1)\n+  @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+  public void addToBucket_01Thread() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f714b4397ad69538999336a4283c08c7a1b0e0a9"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg5OTIxNA==", "bodyText": "I actually disagree. Having all the thread options in one benchmark result is better than having to run them over and over again and collate the results from all the runs. If JMH supported passing in a range of thread values to test with, and it would do the collating, then I'd be more in favor of this approach.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1504#discussion_r465899214", "createdAt": "2020-08-05T17:48:10Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/jmh/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBucketsBenchmark.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+/** Benchmark class for {@link TracezSpanBuckets}. */\n+@State(Scope.Benchmark)\n+public class TracezSpanBucketsBenchmark {\n+\n+  private static final String spanName = \"BENCHMARK_SPAN\";\n+  private static ReadableSpan readableSpan;\n+  private TracezSpanBuckets bucket;\n+\n+  @Setup(Level.Trial)\n+  public final void setup() {\n+    bucket = new TracezSpanBuckets();\n+    Tracer tracer = OpenTelemetrySdk.getTracerProvider().get(\"TracezZPageBenchmark\");\n+    Span span = tracer.spanBuilder(spanName).startSpan();\n+    span.end();\n+    readableSpan = (ReadableSpan) span;\n+  }\n+\n+  @Benchmark\n+  @Threads(value = 1)\n+  @Fork(1)\n+  @Warmup(iterations = 5, time = 1)\n+  @Measurement(iterations = 10, time = 1)\n+  @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+  public void addToBucket_01Thread() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwODk3NA=="}, "originalCommit": {"oid": "f714b4397ad69538999336a4283c08c7a1b0e0a9"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMTE1Njg5OnYy", "diffSide": "RIGHT", "path": "sdk_extensions/zpages/src/jmh/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorBenchmark.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMTowODoyNFrOG8fshA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMTowODoyNFrOG8fshA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4NzA0NA==", "bodyText": "Can just pick some \"by feeling\" tiny, small, medium, large, huge numbers, maybe 1, 10, 1000, 1000000", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1504#discussion_r466087044", "createdAt": "2020-08-06T01:08:24Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/jmh/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorBenchmark.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+/** Benchmark class for {@link TracezDataAggregator}. */\n+@State(Scope.Benchmark)\n+public class TracezDataAggregatorBenchmark {\n+\n+  private static final String runningSpan = \"RUNNING_SPAN\";\n+  private static final String latencySpan = \"LATENCY_SPAN\";\n+  private static final String errorSpan = \"ERROR_SPAN\";\n+  private final Tracer tracer =\n+      OpenTelemetrySdk.getTracerProvider().get(\"TracezDataAggregatorBenchmark\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+\n+  @Param({\"1000000\"})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "922e95059d3616de987e26e7b127d7924cca8358"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMTE1NzI4OnYy", "diffSide": "RIGHT", "path": "sdk_extensions/zpages/src/jmh/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorBenchmark.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMTowODozNFrOG8fsuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMTowODozNFrOG8fsuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4NzA5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Generate 1 million running spans, span latencies, and error spans", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1504#discussion_r466087099", "createdAt": "2020-08-06T01:08:34Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/jmh/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorBenchmark.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+/** Benchmark class for {@link TracezDataAggregator}. */\n+@State(Scope.Benchmark)\n+public class TracezDataAggregatorBenchmark {\n+\n+  private static final String runningSpan = \"RUNNING_SPAN\";\n+  private static final String latencySpan = \"LATENCY_SPAN\";\n+  private static final String errorSpan = \"ERROR_SPAN\";\n+  private final Tracer tracer =\n+      OpenTelemetrySdk.getTracerProvider().get(\"TracezDataAggregatorBenchmark\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+\n+  @Param({\"1000000\"})\n+  private int numberOfSpans;\n+\n+  @Setup(Level.Trial)\n+  public final void setup() {\n+    // Generate 1 million running spans, span latencies, and error spans", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "922e95059d3616de987e26e7b127d7924cca8358"}, "originalPosition": 54}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1302, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}