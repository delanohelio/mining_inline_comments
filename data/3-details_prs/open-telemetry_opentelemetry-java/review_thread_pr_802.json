{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3NjUzMDYz", "number": 802, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjowNzowM1rODbCjoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjowNzowM1rODbCjoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NjgwMDMyOnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/internal/ComponentRegistry.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMjowNzowM1rOFiTJtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxNTo1OTozM1rOFiqmjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwOTY4Nw==", "bodyText": "I think all of this code can be replaced with a call to registry.putIfAbsent(instrumentationLibraryInfo, newComponent(instrumentationLibraryInfo)) if you declare the registry as a ConcurrentMap and then the additional lock will be unnecessary.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/802#discussion_r371509687", "createdAt": "2020-01-27T22:07:03Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/internal/ComponentRegistry.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.internal;\n+\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Base class for all the registry classes (Tracer, Meter, etc.).\n+ *\n+ * @param <V> the type of the registered value.\n+ */\n+public abstract class ComponentRegistry<V> {\n+  private final Object lock = new Object();\n+  private final Map<InstrumentationLibraryInfo, V> registry = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Returns the registered value associated with this name and {@code null} version if any,\n+   * otherwise creates a new instance and associates it with the given name and {@code null}\n+   * version.\n+   *\n+   * @param instrumentationName the name of the instrumentation library.\n+   * @return the registered value associated with this name and {@code null} version.\n+   */\n+  public V get(String instrumentationName) {\n+    return get(instrumentationName, null);\n+  }\n+\n+  /**\n+   * Returns the registered value associated with this name and version if any, otherwise creates a\n+   * new instance and associates it with the given name and version.\n+   *\n+   * @param instrumentationName the name of the instrumentation library.\n+   * @param instrumentationVersion the version of the instrumentation library.\n+   * @return the registered value associated with this name and version.\n+   */\n+  public V get(String instrumentationName, @Nullable String instrumentationVersion) {\n+    InstrumentationLibraryInfo instrumentationLibraryInfo =\n+        InstrumentationLibraryInfo.create(instrumentationName, instrumentationVersion);\n+    V tracer = registry.get(instrumentationLibraryInfo);\n+    if (tracer == null) {\n+      synchronized (lock) {\n+        // Re-check if the value was added since the previous check, this can happen if multiple\n+        // threads try to access the same named tracer during the same time. This way we ensure that\n+        // we create only one TracerSdk per name.\n+        tracer = registry.get(instrumentationLibraryInfo);\n+        if (tracer != null) {\n+          // A different thread already added the named Tracer, just reuse.\n+          return tracer;\n+        }\n+        tracer = newComponent(instrumentationLibraryInfo);\n+        registry.put(instrumentationLibraryInfo, tracer);\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b55211d749a422788b284fe12fc00b680fd40a96"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUzMDc2MA==", "bodyText": "note: You have to return registry.get(instrumentationLibraryInfo); as the result. ;)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/802#discussion_r371530760", "createdAt": "2020-01-27T23:00:54Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/internal/ComponentRegistry.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.internal;\n+\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Base class for all the registry classes (Tracer, Meter, etc.).\n+ *\n+ * @param <V> the type of the registered value.\n+ */\n+public abstract class ComponentRegistry<V> {\n+  private final Object lock = new Object();\n+  private final Map<InstrumentationLibraryInfo, V> registry = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Returns the registered value associated with this name and {@code null} version if any,\n+   * otherwise creates a new instance and associates it with the given name and {@code null}\n+   * version.\n+   *\n+   * @param instrumentationName the name of the instrumentation library.\n+   * @return the registered value associated with this name and {@code null} version.\n+   */\n+  public V get(String instrumentationName) {\n+    return get(instrumentationName, null);\n+  }\n+\n+  /**\n+   * Returns the registered value associated with this name and version if any, otherwise creates a\n+   * new instance and associates it with the given name and version.\n+   *\n+   * @param instrumentationName the name of the instrumentation library.\n+   * @param instrumentationVersion the version of the instrumentation library.\n+   * @return the registered value associated with this name and version.\n+   */\n+  public V get(String instrumentationName, @Nullable String instrumentationVersion) {\n+    InstrumentationLibraryInfo instrumentationLibraryInfo =\n+        InstrumentationLibraryInfo.create(instrumentationName, instrumentationVersion);\n+    V tracer = registry.get(instrumentationLibraryInfo);\n+    if (tracer == null) {\n+      synchronized (lock) {\n+        // Re-check if the value was added since the previous check, this can happen if multiple\n+        // threads try to access the same named tracer during the same time. This way we ensure that\n+        // we create only one TracerSdk per name.\n+        tracer = registry.get(instrumentationLibraryInfo);\n+        if (tracer != null) {\n+          // A different thread already added the named Tracer, just reuse.\n+          return tracer;\n+        }\n+        tracer = newComponent(instrumentationLibraryInfo);\n+        registry.put(instrumentationLibraryInfo, tracer);\n+      }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwOTY4Nw=="}, "originalCommit": {"oid": "b55211d749a422788b284fe12fc00b680fd40a96"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1ODgzMQ==", "bodyText": "So I'd personally prefer to\n\nNot having to create a new InstrumentationLibraryInfo object per get() call.\nNot to do registry.putIfAbsent(instrumentationLibraryInfo, newComponent(instrumentationLibraryInfo)) as we would also be creating a new component (I wish putIfAbsent() took a lambda ;) )\n\nProbably by doing so we would need to do more work, but we would avoid a few allocations ;)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/802#discussion_r371558831", "createdAt": "2020-01-28T00:36:02Z", "author": {"login": "carlosalberto"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/internal/ComponentRegistry.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.internal;\n+\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Base class for all the registry classes (Tracer, Meter, etc.).\n+ *\n+ * @param <V> the type of the registered value.\n+ */\n+public abstract class ComponentRegistry<V> {\n+  private final Object lock = new Object();\n+  private final Map<InstrumentationLibraryInfo, V> registry = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Returns the registered value associated with this name and {@code null} version if any,\n+   * otherwise creates a new instance and associates it with the given name and {@code null}\n+   * version.\n+   *\n+   * @param instrumentationName the name of the instrumentation library.\n+   * @return the registered value associated with this name and {@code null} version.\n+   */\n+  public V get(String instrumentationName) {\n+    return get(instrumentationName, null);\n+  }\n+\n+  /**\n+   * Returns the registered value associated with this name and version if any, otherwise creates a\n+   * new instance and associates it with the given name and version.\n+   *\n+   * @param instrumentationName the name of the instrumentation library.\n+   * @param instrumentationVersion the version of the instrumentation library.\n+   * @return the registered value associated with this name and version.\n+   */\n+  public V get(String instrumentationName, @Nullable String instrumentationVersion) {\n+    InstrumentationLibraryInfo instrumentationLibraryInfo =\n+        InstrumentationLibraryInfo.create(instrumentationName, instrumentationVersion);\n+    V tracer = registry.get(instrumentationLibraryInfo);\n+    if (tracer == null) {\n+      synchronized (lock) {\n+        // Re-check if the value was added since the previous check, this can happen if multiple\n+        // threads try to access the same named tracer during the same time. This way we ensure that\n+        // we create only one TracerSdk per name.\n+        tracer = registry.get(instrumentationLibraryInfo);\n+        if (tracer != null) {\n+          // A different thread already added the named Tracer, just reuse.\n+          return tracer;\n+        }\n+        tracer = newComponent(instrumentationLibraryInfo);\n+        registry.put(instrumentationLibraryInfo, tracer);\n+      }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwOTY4Nw=="}, "originalCommit": {"oid": "b55211d749a422788b284fe12fc00b680fd40a96"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU3ODQwNg==", "bodyText": "Something something java 8!!\nThe trade-off is with putIfAbsent we don't block. I'd personally prefer non blocking, but that's me.\nMaybe a hybrid where we putIfAbsent if the first one returns null?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/802#discussion_r371578406", "createdAt": "2020-01-28T01:59:54Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/internal/ComponentRegistry.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.internal;\n+\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Base class for all the registry classes (Tracer, Meter, etc.).\n+ *\n+ * @param <V> the type of the registered value.\n+ */\n+public abstract class ComponentRegistry<V> {\n+  private final Object lock = new Object();\n+  private final Map<InstrumentationLibraryInfo, V> registry = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Returns the registered value associated with this name and {@code null} version if any,\n+   * otherwise creates a new instance and associates it with the given name and {@code null}\n+   * version.\n+   *\n+   * @param instrumentationName the name of the instrumentation library.\n+   * @return the registered value associated with this name and {@code null} version.\n+   */\n+  public V get(String instrumentationName) {\n+    return get(instrumentationName, null);\n+  }\n+\n+  /**\n+   * Returns the registered value associated with this name and version if any, otherwise creates a\n+   * new instance and associates it with the given name and version.\n+   *\n+   * @param instrumentationName the name of the instrumentation library.\n+   * @param instrumentationVersion the version of the instrumentation library.\n+   * @return the registered value associated with this name and version.\n+   */\n+  public V get(String instrumentationName, @Nullable String instrumentationVersion) {\n+    InstrumentationLibraryInfo instrumentationLibraryInfo =\n+        InstrumentationLibraryInfo.create(instrumentationName, instrumentationVersion);\n+    V tracer = registry.get(instrumentationLibraryInfo);\n+    if (tracer == null) {\n+      synchronized (lock) {\n+        // Re-check if the value was added since the previous check, this can happen if multiple\n+        // threads try to access the same named tracer during the same time. This way we ensure that\n+        // we create only one TracerSdk per name.\n+        tracer = registry.get(instrumentationLibraryInfo);\n+        if (tracer != null) {\n+          // A different thread already added the named Tracer, just reuse.\n+          return tracer;\n+        }\n+        tracer = newComponent(instrumentationLibraryInfo);\n+        registry.put(instrumentationLibraryInfo, tracer);\n+      }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwOTY4Nw=="}, "originalCommit": {"oid": "b55211d749a422788b284fe12fc00b680fd40a96"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5OTU1OA==", "bodyText": "@carlosalberto if we use the InstrumentationLibraryInfo as the key, how do you prevent creation of one? You could create a String key from the pieces, but that ends up creating a StringBuffer instead of the key object. Either way, if you have named tracers like this, then you'll have to create something for the key, no?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/802#discussion_r371599558", "createdAt": "2020-01-28T03:57:10Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/internal/ComponentRegistry.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.internal;\n+\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Base class for all the registry classes (Tracer, Meter, etc.).\n+ *\n+ * @param <V> the type of the registered value.\n+ */\n+public abstract class ComponentRegistry<V> {\n+  private final Object lock = new Object();\n+  private final Map<InstrumentationLibraryInfo, V> registry = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Returns the registered value associated with this name and {@code null} version if any,\n+   * otherwise creates a new instance and associates it with the given name and {@code null}\n+   * version.\n+   *\n+   * @param instrumentationName the name of the instrumentation library.\n+   * @return the registered value associated with this name and {@code null} version.\n+   */\n+  public V get(String instrumentationName) {\n+    return get(instrumentationName, null);\n+  }\n+\n+  /**\n+   * Returns the registered value associated with this name and version if any, otherwise creates a\n+   * new instance and associates it with the given name and version.\n+   *\n+   * @param instrumentationName the name of the instrumentation library.\n+   * @param instrumentationVersion the version of the instrumentation library.\n+   * @return the registered value associated with this name and version.\n+   */\n+  public V get(String instrumentationName, @Nullable String instrumentationVersion) {\n+    InstrumentationLibraryInfo instrumentationLibraryInfo =\n+        InstrumentationLibraryInfo.create(instrumentationName, instrumentationVersion);\n+    V tracer = registry.get(instrumentationLibraryInfo);\n+    if (tracer == null) {\n+      synchronized (lock) {\n+        // Re-check if the value was added since the previous check, this can happen if multiple\n+        // threads try to access the same named tracer during the same time. This way we ensure that\n+        // we create only one TracerSdk per name.\n+        tracer = registry.get(instrumentationLibraryInfo);\n+        if (tracer != null) {\n+          // A different thread already added the named Tracer, just reuse.\n+          return tracer;\n+        }\n+        tracer = newComponent(instrumentationLibraryInfo);\n+        registry.put(instrumentationLibraryInfo, tracer);\n+      }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwOTY4Nw=="}, "originalCommit": {"oid": "b55211d749a422788b284fe12fc00b680fd40a96"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5MjU3MQ==", "bodyText": "This PR does not change the logic, it just moves it to be shared. I think all observations are good and having this library shared helps us doing the improvements once.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/802#discussion_r371892571", "createdAt": "2020-01-28T15:57:31Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/internal/ComponentRegistry.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.internal;\n+\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Base class for all the registry classes (Tracer, Meter, etc.).\n+ *\n+ * @param <V> the type of the registered value.\n+ */\n+public abstract class ComponentRegistry<V> {\n+  private final Object lock = new Object();\n+  private final Map<InstrumentationLibraryInfo, V> registry = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Returns the registered value associated with this name and {@code null} version if any,\n+   * otherwise creates a new instance and associates it with the given name and {@code null}\n+   * version.\n+   *\n+   * @param instrumentationName the name of the instrumentation library.\n+   * @return the registered value associated with this name and {@code null} version.\n+   */\n+  public V get(String instrumentationName) {\n+    return get(instrumentationName, null);\n+  }\n+\n+  /**\n+   * Returns the registered value associated with this name and version if any, otherwise creates a\n+   * new instance and associates it with the given name and version.\n+   *\n+   * @param instrumentationName the name of the instrumentation library.\n+   * @param instrumentationVersion the version of the instrumentation library.\n+   * @return the registered value associated with this name and version.\n+   */\n+  public V get(String instrumentationName, @Nullable String instrumentationVersion) {\n+    InstrumentationLibraryInfo instrumentationLibraryInfo =\n+        InstrumentationLibraryInfo.create(instrumentationName, instrumentationVersion);\n+    V tracer = registry.get(instrumentationLibraryInfo);\n+    if (tracer == null) {\n+      synchronized (lock) {\n+        // Re-check if the value was added since the previous check, this can happen if multiple\n+        // threads try to access the same named tracer during the same time. This way we ensure that\n+        // we create only one TracerSdk per name.\n+        tracer = registry.get(instrumentationLibraryInfo);\n+        if (tracer != null) {\n+          // A different thread already added the named Tracer, just reuse.\n+          return tracer;\n+        }\n+        tracer = newComponent(instrumentationLibraryInfo);\n+        registry.put(instrumentationLibraryInfo, tracer);\n+      }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwOTY4Nw=="}, "originalCommit": {"oid": "b55211d749a422788b284fe12fc00b680fd40a96"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5MzkwMA==", "bodyText": "That's fair. When this gets merged, I'll put in a quick PR to simplify the logic and make it less blocking.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/802#discussion_r371893900", "createdAt": "2020-01-28T15:59:33Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/internal/ComponentRegistry.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.internal;\n+\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Base class for all the registry classes (Tracer, Meter, etc.).\n+ *\n+ * @param <V> the type of the registered value.\n+ */\n+public abstract class ComponentRegistry<V> {\n+  private final Object lock = new Object();\n+  private final Map<InstrumentationLibraryInfo, V> registry = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Returns the registered value associated with this name and {@code null} version if any,\n+   * otherwise creates a new instance and associates it with the given name and {@code null}\n+   * version.\n+   *\n+   * @param instrumentationName the name of the instrumentation library.\n+   * @return the registered value associated with this name and {@code null} version.\n+   */\n+  public V get(String instrumentationName) {\n+    return get(instrumentationName, null);\n+  }\n+\n+  /**\n+   * Returns the registered value associated with this name and version if any, otherwise creates a\n+   * new instance and associates it with the given name and version.\n+   *\n+   * @param instrumentationName the name of the instrumentation library.\n+   * @param instrumentationVersion the version of the instrumentation library.\n+   * @return the registered value associated with this name and version.\n+   */\n+  public V get(String instrumentationName, @Nullable String instrumentationVersion) {\n+    InstrumentationLibraryInfo instrumentationLibraryInfo =\n+        InstrumentationLibraryInfo.create(instrumentationName, instrumentationVersion);\n+    V tracer = registry.get(instrumentationLibraryInfo);\n+    if (tracer == null) {\n+      synchronized (lock) {\n+        // Re-check if the value was added since the previous check, this can happen if multiple\n+        // threads try to access the same named tracer during the same time. This way we ensure that\n+        // we create only one TracerSdk per name.\n+        tracer = registry.get(instrumentationLibraryInfo);\n+        if (tracer != null) {\n+          // A different thread already added the named Tracer, just reuse.\n+          return tracer;\n+        }\n+        tracer = newComponent(instrumentationLibraryInfo);\n+        registry.put(instrumentationLibraryInfo, tracer);\n+      }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTUwOTY4Nw=="}, "originalCommit": {"oid": "b55211d749a422788b284fe12fc00b680fd40a96"}, "originalPosition": 70}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1034, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}