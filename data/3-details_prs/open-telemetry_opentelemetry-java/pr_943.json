{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxMDc3MTQ3", "number": 943, "title": "Add aggregators for double & long MinMaxSumCount aggregations", "bodyText": "And, simple benchmarks for them.", "createdAt": "2020-02-27T21:15:46Z", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943", "merged": true, "mergeCommit": {"oid": "a21adeb45f7d8df3a6d15899bbd362bf6c26561f"}, "closed": true, "closedAt": "2020-02-28T18:30:48Z", "author": {"login": "jkwatson"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcIh_OSAH2gAyMzgxMDc3MTQ3OjQzNTk4OWU5ZDg3Y2FkYTdlNWFkYjhkOTg0MGRiYWY0ZDY1ZWY5NjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcI0QoFAFqTM2NjU5OTI2MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "435989e9d87cada7e5adb8d9840dbaf4d65ef966", "author": {"user": null}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/435989e9d87cada7e5adb8d9840dbaf4d65ef966", "committedDate": "2020-02-27T21:13:24Z", "message": "Add aggregators for double & long MinMaxSumCount aggregations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MDU3NTQz", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#pullrequestreview-366057543", "createdAt": "2020-02-27T22:53:50Z", "commit": {"oid": "435989e9d87cada7e5adb8d9840dbaf4d65ef966"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMjo1Mzo1MVrOFvkDuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMzowMToxM1rOFvkN8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxODE2OA==", "bodyText": "I think we can use min/max as primitives and rely on the count == 0 to know if any event was recorded. This removes couple of boxing operations.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#discussion_r385418168", "createdAt": "2020-02-27T22:53:51Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/DoubleMinMaxSumCount.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics.aggregator;\n+\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+@ThreadSafe\n+public final class DoubleMinMaxSumCount extends AbstractAggregator {\n+\n+  private static final AggregatorFactory AGGREGATOR_FACTORY =\n+      new AggregatorFactory() {\n+        @Override\n+        public Aggregator getAggregator() {\n+          return new DoubleMinMaxSumCount();\n+        }\n+      };\n+\n+  // The current value. This controls its own internal thread-safety via method access. Don't\n+  // try to use its fields directly.\n+  private final DoubleSummary current = new DoubleSummary();\n+\n+  public static AggregatorFactory getFactory() {\n+    return AGGREGATOR_FACTORY;\n+  }\n+\n+  @Override\n+  void doMergeAndReset(Aggregator target) {\n+    DoubleMinMaxSumCount other = (DoubleMinMaxSumCount) target;\n+\n+    DoubleSummary copy = current.copyAndReset();\n+    other.current.update(copy);\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Point toPoint(long startEpochNanos, long epochNanos, Map<String, String> labels) {\n+    return current.toPoint(startEpochNanos, epochNanos, labels);\n+  }\n+\n+  @Override\n+  public void recordDouble(double value) {\n+    current.record(value);\n+  }\n+\n+  private static final class DoubleSummary {\n+\n+    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+    @GuardedBy(\"lock\")\n+    private double sum = 0;\n+\n+    @GuardedBy(\"lock\")\n+    private long count = 0;\n+\n+    @Nullable\n+    @GuardedBy(\"lock\")\n+    private Double min = null;\n+\n+    @Nullable\n+    @GuardedBy(\"lock\")\n+    private Double max = null;\n+\n+    private void update(DoubleSummary summary) {\n+      lock.writeLock().lock();\n+      try {\n+        this.count += summary.count;\n+        this.sum += summary.sum;\n+        if (this.min == null) {\n+          this.min = summary.min;\n+        } else if (summary.min != null) {\n+          this.min = Math.min(summary.min, this.min);\n+        }\n+        if (this.max == null) {\n+          this.max = summary.max;\n+        } else if (summary.max != null) {\n+          this.max = Math.max(summary.max, this.max);\n+        }\n+      } finally {\n+        lock.writeLock().unlock();\n+      }\n+    }\n+\n+    private void record(double value) {\n+      lock.writeLock().lock();\n+      try {\n+        count++;\n+        sum += value;\n+        min = min == null ? value : Math.min(value, min);\n+        max = max == null ? value : Math.max(value, max);\n+      } finally {\n+        lock.writeLock().unlock();\n+      }\n+    }\n+\n+    private DoubleSummary copyAndReset() {\n+      DoubleSummary copy = new DoubleSummary();\n+      lock.writeLock().lock();\n+      try {\n+        copy.count = count;\n+        copy.sum = sum;\n+        copy.min = min;\n+        copy.max = max;\n+        count = 0;\n+        sum = 0;\n+        min = null;\n+        max = null;\n+      } finally {\n+        lock.writeLock().unlock();\n+      }\n+      return copy;\n+    }\n+\n+    private SummaryPoint toPoint(\n+        long startEpochNanos, long epochNanos, Map<String, String> labels) {\n+      lock.readLock().lock();\n+      try {\n+        return SummaryPoint.create(\n+            startEpochNanos,\n+            epochNanos,\n+            labels,\n+            count,\n+            sum,\n+            min == null || max == null // note: min & max will be null or not null together.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "435989e9d87cada7e5adb8d9840dbaf4d65ef966"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyMDc4Ng==", "bodyText": "what about just:\ncurrent.mergeAndReset(other.current)\n    private void mergeAndReset(DoubleSummary target) {\n      long count;\n      double sum;\n      double min;\n      double max;\n      lock.writeLock().lock();\n      try {\n        count = this.count;\n        sum = this.sum;\n        min = this.min;\n        max = this.max;\n        this.count = 0;\n        this.sum = 0;\n        this.min = 0;\n        this.max = 0;\n      } finally {\n        lock.writeLock().unlock();\n      }\n      target.update(count, sum, min, max);\n    }\n\n    private void update(long count, double sum, double min, double max) {\n      if (count == 0) {\n        return;  // nothing to do\n      }\n      lock.writeLock().lock();\n      try {\n        this.count += count;\n        this.sum += sum;\n        this.min = Math.min(min, this.min);\n        this.max = Math.max(max, this.max);\n      } finally {\n        lock.writeLock().unlock();\n      }\n    }", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#discussion_r385420786", "createdAt": "2020-02-27T23:01:13Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/DoubleMinMaxSumCount.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics.aggregator;\n+\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+@ThreadSafe\n+public final class DoubleMinMaxSumCount extends AbstractAggregator {\n+\n+  private static final AggregatorFactory AGGREGATOR_FACTORY =\n+      new AggregatorFactory() {\n+        @Override\n+        public Aggregator getAggregator() {\n+          return new DoubleMinMaxSumCount();\n+        }\n+      };\n+\n+  // The current value. This controls its own internal thread-safety via method access. Don't\n+  // try to use its fields directly.\n+  private final DoubleSummary current = new DoubleSummary();\n+\n+  public static AggregatorFactory getFactory() {\n+    return AGGREGATOR_FACTORY;\n+  }\n+\n+  @Override\n+  void doMergeAndReset(Aggregator target) {\n+    DoubleMinMaxSumCount other = (DoubleMinMaxSumCount) target;\n+\n+    DoubleSummary copy = current.copyAndReset();\n+    other.current.update(copy);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "435989e9d87cada7e5adb8d9840dbaf4d65ef966"}, "originalPosition": 54}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0251c1eea19855938d357bdb6b59a9871f7aa0ca", "author": {"user": null}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/0251c1eea19855938d357bdb6b59a9871f7aa0ca", "committedDate": "2020-02-28T15:39:30Z", "message": "use the count to signal un-set min/max values"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NDk0Njc2", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#pullrequestreview-366494676", "createdAt": "2020-02-28T15:47:00Z", "commit": {"oid": "0251c1eea19855938d357bdb6b59a9871f7aa0ca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTo0NzowMFrOFv5i1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTo0NzowMFrOFv5i1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3MDE5Ng==", "bodyText": "Return null if no values?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#discussion_r385770196", "createdAt": "2020-02-28T15:47:00Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/DoubleMinMaxSumCount.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics.aggregator;\n+\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+@ThreadSafe\n+public final class DoubleMinMaxSumCount extends AbstractAggregator {\n+\n+  private static final AggregatorFactory AGGREGATOR_FACTORY =\n+      new AggregatorFactory() {\n+        @Override\n+        public Aggregator getAggregator() {\n+          return new DoubleMinMaxSumCount();\n+        }\n+      };\n+\n+  // The current value. This controls its own internal thread-safety via method access. Don't\n+  // try to use its fields directly.\n+  private final DoubleSummary current = new DoubleSummary();\n+\n+  public static AggregatorFactory getFactory() {\n+    return AGGREGATOR_FACTORY;\n+  }\n+\n+  @Override\n+  void doMergeAndReset(Aggregator target) {\n+    DoubleMinMaxSumCount other = (DoubleMinMaxSumCount) target;\n+\n+    DoubleSummary copy = current.copyAndReset();\n+    other.current.update(copy);\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Point toPoint(long startEpochNanos, long epochNanos, Map<String, String> labels) {\n+    return current.toPoint(startEpochNanos, epochNanos, labels);\n+  }\n+\n+  @Override\n+  public void recordDouble(double value) {\n+    current.record(value);\n+  }\n+\n+  private static final class DoubleSummary {\n+\n+    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+    @GuardedBy(\"lock\")\n+    private double sum = 0;\n+\n+    @GuardedBy(\"lock\")\n+    private long count = 0;\n+\n+    @GuardedBy(\"lock\")\n+    private double min = Double.POSITIVE_INFINITY;\n+\n+    @GuardedBy(\"lock\")\n+    private double max = Double.NEGATIVE_INFINITY;\n+\n+    private void update(DoubleSummary summary) {\n+      lock.writeLock().lock();\n+      try {\n+        this.count += summary.count;\n+        this.sum += summary.sum;\n+        this.min = Math.min(summary.min, this.min);\n+        this.max = Math.max(summary.max, this.max);\n+      } finally {\n+        lock.writeLock().unlock();\n+      }\n+    }\n+\n+    private void record(double value) {\n+      lock.writeLock().lock();\n+      try {\n+        count++;\n+        sum += value;\n+        min = Math.min(value, min);\n+        max = Math.max(value, max);\n+      } finally {\n+        lock.writeLock().unlock();\n+      }\n+    }\n+\n+    private DoubleSummary copyAndReset() {\n+      DoubleSummary copy = new DoubleSummary();\n+      lock.writeLock().lock();\n+      try {\n+        copy.count = count;\n+        copy.sum = sum;\n+        copy.min = min;\n+        copy.max = max;\n+        count = 0;\n+        sum = 0;\n+        min = Double.POSITIVE_INFINITY;\n+        max = Double.NEGATIVE_INFINITY;\n+      } finally {\n+        lock.writeLock().unlock();\n+      }\n+      return copy;\n+    }\n+\n+    private SummaryPoint toPoint(\n+        long startEpochNanos, long epochNanos, Map<String, String> labels) {\n+      lock.readLock().lock();\n+      try {\n+        return SummaryPoint.create(\n+            startEpochNanos,\n+            epochNanos,\n+            labels,\n+            count,\n+            sum,\n+            count == 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0251c1eea19855938d357bdb6b59a9871f7aa0ca"}, "originalPosition": 136}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NDk4NjMy", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#pullrequestreview-366498632", "createdAt": "2020-02-28T15:52:29Z", "commit": {"oid": "0251c1eea19855938d357bdb6b59a9871f7aa0ca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTo1MjoyOVrOFv5vCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTo1MjoyOVrOFv5vCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3MzMyMw==", "bodyText": "Get the instance via the factory and add a private ctor to the class, so to enforce usage of the factory :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#discussion_r385773323", "createdAt": "2020-02-28T15:52:29Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/jmh/java/io/opentelemetry/sdk/metrics/aggregator/DoubleMinMaxSumCountBenchmark.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics.aggregator;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@State(Scope.Benchmark)\n+public class DoubleMinMaxSumCountBenchmark {\n+\n+  private DoubleMinMaxSumCount aggregator;\n+\n+  @Setup(Level.Trial)\n+  public final void setup() {\n+    aggregator = new DoubleMinMaxSumCount();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0251c1eea19855938d357bdb6b59a9871f7aa0ca"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "463eec111868dcebfbbd356c5c2d36c660cf9c1d", "author": {"user": null}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/463eec111868dcebfbbd356c5c2d36c660cf9c1d", "committedDate": "2020-02-28T16:29:19Z", "message": "make the aggregator constructors private; use the factories for access"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25e023b642d83f1044ee89a0782793cd2e750a13", "author": {"user": null}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/25e023b642d83f1044ee89a0782793cd2e750a13", "committedDate": "2020-02-28T17:13:04Z", "message": "simplify the merge and reset"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NTU4MzEx", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#pullrequestreview-366558311", "createdAt": "2020-02-28T17:19:09Z", "commit": {"oid": "25e023b642d83f1044ee89a0782793cd2e750a13"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNzoxOTowOVrOFv8qqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNzoxOTowOVrOFv8qqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgyMTM1Mg==", "bodyText": "if this.count == 0 you can return immediately.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#discussion_r385821352", "createdAt": "2020-02-28T17:19:09Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/DoubleMinMaxSumCount.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics.aggregator;\n+\n+import com.google.errorprone.annotations.concurrent.GuardedBy;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+@ThreadSafe\n+public final class DoubleMinMaxSumCount extends AbstractAggregator {\n+\n+  private static final AggregatorFactory AGGREGATOR_FACTORY =\n+      new AggregatorFactory() {\n+        @Override\n+        public Aggregator getAggregator() {\n+          return new DoubleMinMaxSumCount();\n+        }\n+      };\n+\n+  // The current value. This controls its own internal thread-safety via method access. Don't\n+  // try to use its fields directly.\n+  private final DoubleSummary current = new DoubleSummary();\n+\n+  public static AggregatorFactory getFactory() {\n+    return AGGREGATOR_FACTORY;\n+  }\n+\n+  private DoubleMinMaxSumCount() {}\n+\n+  @Override\n+  void doMergeAndReset(Aggregator target) {\n+    DoubleMinMaxSumCount other = (DoubleMinMaxSumCount) target;\n+    current.mergeAndReset(other.current);\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Point toPoint(long startEpochNanos, long epochNanos, Map<String, String> labels) {\n+    return current.toPoint(startEpochNanos, epochNanos, labels);\n+  }\n+\n+  @Override\n+  public void recordDouble(double value) {\n+    current.record(value);\n+  }\n+\n+  private static final class DoubleSummary {\n+\n+    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+    @GuardedBy(\"lock\")\n+    private double sum = 0;\n+\n+    @GuardedBy(\"lock\")\n+    private long count = 0;\n+\n+    @GuardedBy(\"lock\")\n+    private double min = Double.POSITIVE_INFINITY;\n+\n+    @GuardedBy(\"lock\")\n+    private double max = Double.NEGATIVE_INFINITY;\n+\n+    private void record(double value) {\n+      lock.writeLock().lock();\n+      try {\n+        count++;\n+        sum += value;\n+        min = Math.min(value, min);\n+        max = Math.max(value, max);\n+      } finally {\n+        lock.writeLock().unlock();\n+      }\n+    }\n+\n+    public void mergeAndReset(DoubleSummary other) {\n+      long myCount;\n+      double mySum;\n+      double myMin;\n+      double myMax;\n+      lock.writeLock().lock();\n+      try {\n+        myCount = this.count;\n+        mySum = this.sum;\n+        myMin = this.min;\n+        myMax = this.max;\n+        this.count = 0;\n+        this.sum = 0;\n+        this.min = Long.MAX_VALUE;\n+        this.max = Long.MIN_VALUE;\n+      } finally {\n+        lock.writeLock().unlock();\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25e023b642d83f1044ee89a0782793cd2e750a13"}, "originalPosition": 112}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a7b895fc1abbb531fef0794b5046e462e8fddb2", "author": {"user": null}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/5a7b895fc1abbb531fef0794b5046e462e8fddb2", "committedDate": "2020-02-28T17:27:32Z", "message": "early return & fix the default double values."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NTk5MjYw", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/943#pullrequestreview-366599260", "createdAt": "2020-02-28T18:30:42Z", "commit": {"oid": "5a7b895fc1abbb531fef0794b5046e462e8fddb2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3117, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}