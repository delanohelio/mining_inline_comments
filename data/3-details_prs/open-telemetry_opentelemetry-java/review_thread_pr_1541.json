{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY4NDI3MDQ3", "number": 1541, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwNToxOTozN1rOEY5OFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwNTozMTowNlrOEY5WsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NTM4NzcyOnYy", "diffSide": "RIGHT", "path": "examples/prometheus/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwNToxOTozN1rOHBZ_eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwNToxOTozN1rOHBZ_eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzNjQ3NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            These are collected by a Prometheus instance which is configured to pull these  metrics via HTTP. \n          \n          \n            \n            These are collected by a Prometheus instance which is configured to pull these metrics via HTTP.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1541#discussion_r471236474", "createdAt": "2020-08-17T05:19:37Z", "author": {"login": "thisthat"}, "path": "examples/prometheus/README.md", "diffHunk": "@@ -0,0 +1,44 @@\n+# Prometheus Example\n+\n+This example demonstrates how to use the OpenTelemetry SDK \n+to instrument a simple application using Prometheus as the metric exporter and expose the metrics via HTTP. \n+\n+These are collected by a Prometheus instance which is configured to pull these  metrics via HTTP. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1eb7157dc71f673cf4637165f9d60e62a36ddb1"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NTM4ODg4OnYy", "diffSide": "RIGHT", "path": "examples/prometheus/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwNToyMDoxNVrOHBaAGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwNToyMDoxNVrOHBaAGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzNjYzMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1541#discussion_r471236632", "createdAt": "2020-08-17T05:20:15Z", "author": {"login": "thisthat"}, "path": "examples/prometheus/README.md", "diffHunk": "@@ -0,0 +1,44 @@\n+# Prometheus Example\n+\n+This example demonstrates how to use the OpenTelemetry SDK \n+to instrument a simple application using Prometheus as the metric exporter and expose the metrics via HTTP. \n+\n+These are collected by a Prometheus instance which is configured to pull these  metrics via HTTP. \n+\n+# How to run\n+\n+## Prerequisites\n+* Java 1.7\n+* Docker 19.03\n+\n+## 1 - Compile \n+```shell script\n+../gradlew fatJar\n+```\n+## 2 - Run Prometheus\n+\n+Start Prometheus instance with a configuration that sets up a HTTP collection job for  ```127.0.0.1:19090```\n+`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1eb7157dc71f673cf4637165f9d60e62a36ddb1"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NTQwNTMzOnYy", "diffSide": "RIGHT", "path": "examples/prometheus/README.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwNToyODozMlrOHBaJDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwNzoxNTowM1rOHBc-gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzODkyNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                prom/prometheus \n          \n          \n            \n                -p 9090:9090 \\\n          \n          \n            \n                prom/prometheus", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1541#discussion_r471238927", "createdAt": "2020-08-17T05:28:32Z", "author": {"login": "thisthat"}, "path": "examples/prometheus/README.md", "diffHunk": "@@ -0,0 +1,44 @@\n+# Prometheus Example\n+\n+This example demonstrates how to use the OpenTelemetry SDK \n+to instrument a simple application using Prometheus as the metric exporter and expose the metrics via HTTP. \n+\n+These are collected by a Prometheus instance which is configured to pull these  metrics via HTTP. \n+\n+# How to run\n+\n+## Prerequisites\n+* Java 1.7\n+* Docker 19.03\n+\n+## 1 - Compile \n+```shell script\n+../gradlew fatJar\n+```\n+## 2 - Run Prometheus\n+\n+Start Prometheus instance with a configuration that sets up a HTTP collection job for  ```127.0.0.1:19090```\n+`\n+\n+See [prometheus.yml](prometheus.yml)\n+\n+```shell script\n+docker run --network=\"host\" --rm -it \\\n+    --name prometheus \\\n+    -v $(pwd)/prometheus.yml:/etc/prometheus/prometheus.yml \\\n+    prom/prometheus ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1eb7157dc71f673cf4637165f9d60e62a36ddb1"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI4MzE1Nw==", "bodyText": "I left the published ports out of the run command as these are ignored, as the container is run using --network=\"host\" mode.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1541#discussion_r471283157", "createdAt": "2020-08-17T07:10:56Z", "author": {"login": "jarebudev"}, "path": "examples/prometheus/README.md", "diffHunk": "@@ -0,0 +1,44 @@\n+# Prometheus Example\n+\n+This example demonstrates how to use the OpenTelemetry SDK \n+to instrument a simple application using Prometheus as the metric exporter and expose the metrics via HTTP. \n+\n+These are collected by a Prometheus instance which is configured to pull these  metrics via HTTP. \n+\n+# How to run\n+\n+## Prerequisites\n+* Java 1.7\n+* Docker 19.03\n+\n+## 1 - Compile \n+```shell script\n+../gradlew fatJar\n+```\n+## 2 - Run Prometheus\n+\n+Start Prometheus instance with a configuration that sets up a HTTP collection job for  ```127.0.0.1:19090```\n+`\n+\n+See [prometheus.yml](prometheus.yml)\n+\n+```shell script\n+docker run --network=\"host\" --rm -it \\\n+    --name prometheus \\\n+    -v $(pwd)/prometheus.yml:/etc/prometheus/prometheus.yml \\\n+    prom/prometheus ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzODkyNw=="}, "originalCommit": {"oid": "a1eb7157dc71f673cf4637165f9d60e62a36ddb1"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI4NTM3OA==", "bodyText": "Oh, I miss that! You are right! :D", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1541#discussion_r471285378", "createdAt": "2020-08-17T07:15:03Z", "author": {"login": "thisthat"}, "path": "examples/prometheus/README.md", "diffHunk": "@@ -0,0 +1,44 @@\n+# Prometheus Example\n+\n+This example demonstrates how to use the OpenTelemetry SDK \n+to instrument a simple application using Prometheus as the metric exporter and expose the metrics via HTTP. \n+\n+These are collected by a Prometheus instance which is configured to pull these  metrics via HTTP. \n+\n+# How to run\n+\n+## Prerequisites\n+* Java 1.7\n+* Docker 19.03\n+\n+## 1 - Compile \n+```shell script\n+../gradlew fatJar\n+```\n+## 2 - Run Prometheus\n+\n+Start Prometheus instance with a configuration that sets up a HTTP collection job for  ```127.0.0.1:19090```\n+`\n+\n+See [prometheus.yml](prometheus.yml)\n+\n+```shell script\n+docker run --network=\"host\" --rm -it \\\n+    --name prometheus \\\n+    -v $(pwd)/prometheus.yml:/etc/prometheus/prometheus.yml \\\n+    prom/prometheus ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzODkyNw=="}, "originalCommit": {"oid": "a1eb7157dc71f673cf4637165f9d60e62a36ddb1"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NTQwOTc2OnYy", "diffSide": "RIGHT", "path": "examples/prometheus/src/main/java/io/opentelemetry/example/PrometheusExample.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwNTozMTowNlrOHBaLgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwNzoyOTo1NlrOHBdasg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzOTU1Mw==", "bodyText": "I would add a simple check that verifies the port is passed as an argument and prints a message if it is missing.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1541#discussion_r471239553", "createdAt": "2020-08-17T05:31:06Z", "author": {"login": "thisthat"}, "path": "examples/prometheus/src/main/java/io/opentelemetry/example/PrometheusExample.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package io.opentelemetry.example;\n+\n+import io.opentelemetry.common.Labels;\n+import io.opentelemetry.exporters.prometheus.PrometheusCollector;\n+import io.opentelemetry.metrics.AsynchronousInstrument;\n+import io.opentelemetry.metrics.LongValueObserver;\n+import io.opentelemetry.metrics.Meter;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.metrics.MeterSdkProvider;\n+import io.prometheus.client.exporter.HTTPServer;\n+import java.io.IOException;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Example of using the {@link PrometheusCollector} to convert OTel metrics to Prometheus format and\n+ * expose these to a Prometheus instance via a {@link HTTPServer} exporter.\n+ *\n+ * <p>A {@link LongValueObserver} is used to periodically measure how many incoming messages are\n+ * awaiting processing. The {@link LongValueObserver.Callback} gets executed every collection\n+ * interval.\n+ */\n+public class PrometheusExample {\n+\n+  private final MeterSdkProvider meterSdkProvider = OpenTelemetrySdk.getMeterProvider();\n+  private final Meter meter = meterSdkProvider.get(\"PrometheusExample\", \"0.7\");\n+  private final HTTPServer server;\n+  private long incomingMessageCount;\n+\n+  public PrometheusExample(int port) throws IOException {\n+\n+    LongValueObserver observer =\n+        meter\n+            .longValueObserverBuilder(\"incoming.messages\")\n+            .setDescription(\"No of incoming messages awaiting processing\")\n+            .setUnit(\"message\")\n+            .build();\n+\n+    observer.setCallback(\n+        new LongValueObserver.Callback<LongValueObserver.LongResult>() {\n+          @Override\n+          public void update(AsynchronousInstrument.LongResult result) {\n+            result.observe(incomingMessageCount, Labels.empty());\n+          }\n+        });\n+\n+    PrometheusCollector.newBuilder()\n+        .setMetricProducer(meterSdkProvider.getMetricProducer())\n+        .buildAndRegister();\n+\n+    server = new HTTPServer(port);\n+  }\n+\n+  void shutdown() {\n+    server.stop();\n+  }\n+\n+  void simulate() {\n+    for (int i = 300; i > 0; i--) {\n+      try {\n+        System.out.println(\n+            i + \" Iterations to go, current incomingMessageCount is:  \" + incomingMessageCount);\n+        incomingMessageCount = ThreadLocalRandom.current().nextLong(100);\n+        Thread.sleep(1000);\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+\n+    int port = Integer.parseInt(args[0]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1eb7157dc71f673cf4637165f9d60e62a36ddb1"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI4Njk2OA==", "bodyText": "Done!", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1541#discussion_r471286968", "createdAt": "2020-08-17T07:18:29Z", "author": {"login": "jarebudev"}, "path": "examples/prometheus/src/main/java/io/opentelemetry/example/PrometheusExample.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package io.opentelemetry.example;\n+\n+import io.opentelemetry.common.Labels;\n+import io.opentelemetry.exporters.prometheus.PrometheusCollector;\n+import io.opentelemetry.metrics.AsynchronousInstrument;\n+import io.opentelemetry.metrics.LongValueObserver;\n+import io.opentelemetry.metrics.Meter;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.metrics.MeterSdkProvider;\n+import io.prometheus.client.exporter.HTTPServer;\n+import java.io.IOException;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Example of using the {@link PrometheusCollector} to convert OTel metrics to Prometheus format and\n+ * expose these to a Prometheus instance via a {@link HTTPServer} exporter.\n+ *\n+ * <p>A {@link LongValueObserver} is used to periodically measure how many incoming messages are\n+ * awaiting processing. The {@link LongValueObserver.Callback} gets executed every collection\n+ * interval.\n+ */\n+public class PrometheusExample {\n+\n+  private final MeterSdkProvider meterSdkProvider = OpenTelemetrySdk.getMeterProvider();\n+  private final Meter meter = meterSdkProvider.get(\"PrometheusExample\", \"0.7\");\n+  private final HTTPServer server;\n+  private long incomingMessageCount;\n+\n+  public PrometheusExample(int port) throws IOException {\n+\n+    LongValueObserver observer =\n+        meter\n+            .longValueObserverBuilder(\"incoming.messages\")\n+            .setDescription(\"No of incoming messages awaiting processing\")\n+            .setUnit(\"message\")\n+            .build();\n+\n+    observer.setCallback(\n+        new LongValueObserver.Callback<LongValueObserver.LongResult>() {\n+          @Override\n+          public void update(AsynchronousInstrument.LongResult result) {\n+            result.observe(incomingMessageCount, Labels.empty());\n+          }\n+        });\n+\n+    PrometheusCollector.newBuilder()\n+        .setMetricProducer(meterSdkProvider.getMetricProducer())\n+        .buildAndRegister();\n+\n+    server = new HTTPServer(port);\n+  }\n+\n+  void shutdown() {\n+    server.stop();\n+  }\n+\n+  void simulate() {\n+    for (int i = 300; i > 0; i--) {\n+      try {\n+        System.out.println(\n+            i + \" Iterations to go, current incomingMessageCount is:  \" + incomingMessageCount);\n+        incomingMessageCount = ThreadLocalRandom.current().nextLong(100);\n+        Thread.sleep(1000);\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+\n+    int port = Integer.parseInt(args[0]);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzOTU1Mw=="}, "originalCommit": {"oid": "a1eb7157dc71f673cf4637165f9d60e62a36ddb1"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI5MjU5NA==", "bodyText": "Thank you :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1541#discussion_r471292594", "createdAt": "2020-08-17T07:29:56Z", "author": {"login": "thisthat"}, "path": "examples/prometheus/src/main/java/io/opentelemetry/example/PrometheusExample.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package io.opentelemetry.example;\n+\n+import io.opentelemetry.common.Labels;\n+import io.opentelemetry.exporters.prometheus.PrometheusCollector;\n+import io.opentelemetry.metrics.AsynchronousInstrument;\n+import io.opentelemetry.metrics.LongValueObserver;\n+import io.opentelemetry.metrics.Meter;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.metrics.MeterSdkProvider;\n+import io.prometheus.client.exporter.HTTPServer;\n+import java.io.IOException;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Example of using the {@link PrometheusCollector} to convert OTel metrics to Prometheus format and\n+ * expose these to a Prometheus instance via a {@link HTTPServer} exporter.\n+ *\n+ * <p>A {@link LongValueObserver} is used to periodically measure how many incoming messages are\n+ * awaiting processing. The {@link LongValueObserver.Callback} gets executed every collection\n+ * interval.\n+ */\n+public class PrometheusExample {\n+\n+  private final MeterSdkProvider meterSdkProvider = OpenTelemetrySdk.getMeterProvider();\n+  private final Meter meter = meterSdkProvider.get(\"PrometheusExample\", \"0.7\");\n+  private final HTTPServer server;\n+  private long incomingMessageCount;\n+\n+  public PrometheusExample(int port) throws IOException {\n+\n+    LongValueObserver observer =\n+        meter\n+            .longValueObserverBuilder(\"incoming.messages\")\n+            .setDescription(\"No of incoming messages awaiting processing\")\n+            .setUnit(\"message\")\n+            .build();\n+\n+    observer.setCallback(\n+        new LongValueObserver.Callback<LongValueObserver.LongResult>() {\n+          @Override\n+          public void update(AsynchronousInstrument.LongResult result) {\n+            result.observe(incomingMessageCount, Labels.empty());\n+          }\n+        });\n+\n+    PrometheusCollector.newBuilder()\n+        .setMetricProducer(meterSdkProvider.getMetricProducer())\n+        .buildAndRegister();\n+\n+    server = new HTTPServer(port);\n+  }\n+\n+  void shutdown() {\n+    server.stop();\n+  }\n+\n+  void simulate() {\n+    for (int i = 300; i > 0; i--) {\n+      try {\n+        System.out.println(\n+            i + \" Iterations to go, current incomingMessageCount is:  \" + incomingMessageCount);\n+        incomingMessageCount = ThreadLocalRandom.current().nextLong(100);\n+        Thread.sleep(1000);\n+      } catch (InterruptedException e) {\n+      }\n+    }\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+\n+    int port = Integer.parseInt(args[0]);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzOTU1Mw=="}, "originalCommit": {"oid": "a1eb7157dc71f673cf4637165f9d60e62a36ddb1"}, "originalPosition": 71}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1338, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}