{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1NzE3NzEw", "number": 979, "title": "Add B3 propagator", "bodyText": "Fixes #853.\nAdds support for B3 propagation, including both single and multi header formats.", "createdAt": "2020-03-09T17:24:31Z", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979", "merged": true, "mergeCommit": {"oid": "438ea8d24a96646d906be8ee90aac347e5de913f"}, "closed": true, "closedAt": "2020-03-12T15:53:25Z", "author": {"login": "MikeGoldsmith"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcMAN3TgH2gAyMzg1NzE3NzEwOjUyYzYyMGYzOTMzZTI3YWM0ODhiZjI5NjUzMTVkYjllMGM4ZGUwNDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcMpxMkgH2gAyMzg1NzE3NzEwOjdkNzU1ZTk0YzExNmQ0MDRlOGQ0NTJmYWIzYTY1YjIyNGVkMjE1Njk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "52c620f3933e27ac488bf2965315db9e0c8de040", "author": {"user": {"login": "MikeGoldsmith", "name": "Mike Goldsmith"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/52c620f3933e27ac488bf2965315db9e0c8de040", "committedDate": "2020-03-09T16:08:19Z", "message": "add b3 propagator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d7718d859c184ea1ca3b052a56a1e2b71d15ca0", "author": {"user": {"login": "MikeGoldsmith", "name": "Mike Goldsmith"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/1d7718d859c184ea1ca3b052a56a1e2b71d15ca0", "committedDate": "2020-03-09T16:38:20Z", "message": "add support for single combined b3 header"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2b59aca43fe7ec28ad6d4131ad0c0df67b8292c", "author": {"user": {"login": "MikeGoldsmith", "name": "Mike Goldsmith"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b2b59aca43fe7ec28ad6d4131ad0c0df67b8292c", "committedDate": "2020-03-09T17:22:16Z", "message": "add logging, refactor to add isValid methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b16ef35aa27ec57b3ea8d734e4391e9faa2df4e1", "author": {"user": {"login": "MikeGoldsmith", "name": "Mike Goldsmith"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b16ef35aa27ec57b3ea8d734e4391e9faa2df4e1", "committedDate": "2020-03-09T17:33:55Z", "message": "add more tests for single header bounds"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e463b1234a03e7269096a5b062d11e372da102a", "author": {"user": {"login": "MikeGoldsmith", "name": "Mike Goldsmith"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/5e463b1234a03e7269096a5b062d11e372da102a", "committedDate": "2020-03-09T19:42:46Z", "message": "add tests for sampled flag using true/false"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNDgwNjky", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#pullrequestreview-371480692", "createdAt": "2020-03-09T19:50:12Z", "commit": {"oid": "5e463b1234a03e7269096a5b062d11e372da102a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTo1MDoxMlrOFz3BaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTo1MDoxMlrOFz3BaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyMzE3Ng==", "bodyText": "does this need to be a nullable big-b Boolean? Can't it just be a primitive boolean?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r389923176", "createdAt": "2020-03-09T19:50:12Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(Boolean singleHeader) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e463b1234a03e7269096a5b062d11e372da102a"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNDgyNTUy", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#pullrequestreview-371482552", "createdAt": "2020-03-09T19:53:05Z", "commit": {"oid": "5e463b1234a03e7269096a5b062d11e372da102a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTo1MzowNlrOFz3Hdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTo1MzowNlrOFz3Hdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyNDcyNg==", "bodyText": "This should be broken up into at least 2 separate methods. This method is definitely too long. One method for the single header case that returns the context, and one for the multi-header case that returns the context will make this code much easier to read. Thanks!", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r389924726", "createdAt": "2020-03-09T19:53:06Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(Boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"StringSplitter\")\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    String traceId;\n+    String spanId;\n+    String sampled;\n+    if (singleHeader) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e463b1234a03e7269096a5b062d11e372da102a"}, "originalPosition": 110}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNzI0ODM0", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#pullrequestreview-371724834", "createdAt": "2020-03-10T07:28:05Z", "commit": {"oid": "5e463b1234a03e7269096a5b062d11e372da102a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwNzoyODowNVrOF0DvzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwNzoyODowNVrOF0DvzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEzMTY2MA==", "bodyText": "The first two checks could leverage the StringUtils.isNullOrEmpty(value) method", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390131660", "createdAt": "2020-03-10T07:28:05Z", "author": {"login": "thisthat"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(Boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"StringSplitter\")\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    String traceId;\n+    String spanId;\n+    String sampled;\n+    if (singleHeader) {\n+      String value = getter.get(carrier, COMBINED_HEADER);\n+      if (value == null || value.isEmpty()) {\n+        logger.info(\n+            \"Missing or empty combined header: \"\n+                + COMBINED_HEADER\n+                + \". Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      // must have between 2 and 4 hyphen delimieted parts:\n+      //   traceId-spanId-sampled-parentSpanId (last two are optional)\n+      // NOTE: we do not use parentSpanId\n+      String[] parts = value.split(COMBINED_HEADER_DELIMITER);\n+      if (parts.length < 2 || parts.length > 4) {\n+        logger.info(\n+            \"Invalid combined header '\" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      traceId = parts[0];\n+      if (!isTraceIdValid(traceId)) {\n+        logger.info(\n+            \"Invalid TraceId in B3 header: \"\n+                + COMBINED_HEADER\n+                + \". Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      spanId = parts[1];\n+      if (!isSpanIdValid(spanId)) {\n+        logger.info(\n+            \"Invalid SpanId in B3 header: \"\n+                + COMBINED_HEADER\n+                + \". Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      sampled = parts.length == 3 ? parts[2] : null;\n+    } else {\n+      traceId = getter.get(carrier, TRACE_ID_HEADER);\n+      if (!isTraceIdValid(traceId)) {\n+        logger.info(\n+            \"Invalid TraceId in B3 header: \"\n+                + TRACE_ID_HEADER\n+                + \"'. Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      spanId = getter.get(carrier, SPAN_ID_HEADER);\n+      if (!isSpanIdValid(spanId)) {\n+        logger.info(\n+            \"Invalid SpanId in B3 header: \"\n+                + SPAN_ID_HEADER\n+                + \"'. Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      sampled = getter.get(carrier, SAMPLED_HEADER);\n+    }\n+\n+    return buildSpanContext(traceId, spanId, sampled);\n+  }\n+\n+  private static SpanContext buildSpanContext(String traceId, String spanId, String sampled) {\n+    try {\n+      TraceFlags traceFlags =\n+          TraceFlags.builder()\n+              .setIsSampled(\n+                  TRUE_INT.equals(sampled)\n+                      || Boolean.parseBoolean(sampled)) // accept either \"1\" or \"true\"\n+              .build();\n+\n+      return SpanContext.createFromRemoteParent(\n+          TraceId.fromLowerBase16(traceId, 0),\n+          SpanId.fromLowerBase16(spanId, 0),\n+          traceFlags,\n+          TraceState.getDefault());\n+    } catch (Exception e) {\n+      logger.log(Level.INFO, \"Error parsing B3 header. Returning INVALID span context.\", e);\n+      return SpanContext.getInvalid();\n+    }\n+  }\n+\n+  private static boolean isTraceIdValid(String value) {\n+    return !(value == null || value.isEmpty() || value.length() > MAX_TRACE_ID_LENGTH);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e463b1234a03e7269096a5b062d11e372da102a"}, "originalPosition": 195}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e84180529a39a0f559ff61f98d096e1ebbd032ba", "author": {"user": {"login": "MikeGoldsmith", "name": "Mike Goldsmith"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/e84180529a39a0f559ff61f98d096e1ebbd032ba", "committedDate": "2020-03-10T10:19:42Z", "message": "prefer StringUtils.isNullOrEmpty over indivudual checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04c47c6988a24ec479ce286d731a2dcb71777af7", "author": {"user": {"login": "MikeGoldsmith", "name": "Mike Goldsmith"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/04c47c6988a24ec479ce286d731a2dcb71777af7", "committedDate": "2020-03-10T10:21:23Z", "message": "update constructor to take primitive boolean parameter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d519f84264ae7cd82d5997b8e19259bbf2cf12a", "author": {"user": {"login": "MikeGoldsmith", "name": "Mike Goldsmith"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/0d519f84264ae7cd82d5997b8e19259bbf2cf12a", "committedDate": "2020-03-10T10:35:35Z", "message": "refactor extract into single and multi header methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad", "author": {"user": {"login": "MikeGoldsmith", "name": "Mike Goldsmith"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/685bc9c6229509dd0d9b6322bb862ac12aa9b3ad", "committedDate": "2020-03-10T11:13:11Z", "message": "move supporession warning to new method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyMDE2Mzk5", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#pullrequestreview-372016399", "createdAt": "2020-03-10T14:41:22Z", "commit": {"oid": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyMTU2Nzc3", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#pullrequestreview-372156777", "createdAt": "2020-03-10T17:12:44Z", "commit": {"oid": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyMzc2ODM5", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#pullrequestreview-372376839", "createdAt": "2020-03-10T22:57:07Z", "commit": {"oid": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMjo1NzowN1rOF0j5Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMzowMzo0MVrOF0kBcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1ODM1NA==", "bodyText": "We don't use checker framework so no need to add the comment about non-null.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390658354", "createdAt": "2020-03-10T22:57:07Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1OTM5OQ==", "bodyText": "You can construct a sampled/notSampled TraceFlags and reuse them.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390659399", "createdAt": "2020-03-10T23:00:27Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    if (singleHeader) {\n+      return getSpanContextFromSingleHeader(carrier, getter);\n+    } else {\n+      return getSpanContextFromMultipleHeaders(carrier, getter);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C /*>>> extends @NonNull Object*/> SpanContext getSpanContextFromSingleHeader(\n+      C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, COMBINED_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      logger.info(\n+          \"Missing or empty combined header: \"\n+              + COMBINED_HEADER\n+              + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    // must have between 2 and 4 hyphen delimieted parts:\n+    //   traceId-spanId-sampled-parentSpanId (last two are optional)\n+    // NOTE: we do not use parentSpanId\n+    String[] parts = value.split(COMBINED_HEADER_DELIMITER);\n+    if (parts.length < 2 || parts.length > 4) {\n+      logger.info(\n+          \"Invalid combined header '\" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String traceId = parts[0];\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String spanId = parts[1];\n+    if (!isSpanIdValid(spanId)) {\n+      logger.info(\n+          \"Invalid SpanId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String sampled = parts.length == 3 ? parts[2] : null;\n+\n+    return buildSpanContext(traceId, spanId, sampled);\n+  }\n+\n+  private static <C /*>>> extends @NonNull Object*/> SpanContext getSpanContextFromMultipleHeaders(\n+      C carrier, Getter<C> getter) {\n+    String traceId = getter.get(carrier, TRACE_ID_HEADER);\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in B3 header: \"\n+              + TRACE_ID_HEADER\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String spanId = getter.get(carrier, SPAN_ID_HEADER);\n+    if (!isSpanIdValid(spanId)) {\n+      logger.info(\n+          \"Invalid SpanId in B3 header: \" + SPAN_ID_HEADER + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String sampled = getter.get(carrier, SAMPLED_HEADER);\n+    return buildSpanContext(traceId, spanId, sampled);\n+  }\n+\n+  private static SpanContext buildSpanContext(String traceId, String spanId, String sampled) {\n+    try {\n+      TraceFlags traceFlags =\n+          TraceFlags.builder()\n+              .setIsSampled(\n+                  TRUE_INT.equals(sampled)\n+                      || Boolean.parseBoolean(sampled)) // accept either \"1\" or \"true\"\n+              .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1OTc4OA==", "bodyText": "This requires traceId (string) to be 32 hex characters and we only check that the size is not greater than MAX_TRACE_ID_LENGTH.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390659788", "createdAt": "2020-03-10T23:01:35Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    if (singleHeader) {\n+      return getSpanContextFromSingleHeader(carrier, getter);\n+    } else {\n+      return getSpanContextFromMultipleHeaders(carrier, getter);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C /*>>> extends @NonNull Object*/> SpanContext getSpanContextFromSingleHeader(\n+      C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, COMBINED_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      logger.info(\n+          \"Missing or empty combined header: \"\n+              + COMBINED_HEADER\n+              + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    // must have between 2 and 4 hyphen delimieted parts:\n+    //   traceId-spanId-sampled-parentSpanId (last two are optional)\n+    // NOTE: we do not use parentSpanId\n+    String[] parts = value.split(COMBINED_HEADER_DELIMITER);\n+    if (parts.length < 2 || parts.length > 4) {\n+      logger.info(\n+          \"Invalid combined header '\" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String traceId = parts[0];\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String spanId = parts[1];\n+    if (!isSpanIdValid(spanId)) {\n+      logger.info(\n+          \"Invalid SpanId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String sampled = parts.length == 3 ? parts[2] : null;\n+\n+    return buildSpanContext(traceId, spanId, sampled);\n+  }\n+\n+  private static <C /*>>> extends @NonNull Object*/> SpanContext getSpanContextFromMultipleHeaders(\n+      C carrier, Getter<C> getter) {\n+    String traceId = getter.get(carrier, TRACE_ID_HEADER);\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in B3 header: \"\n+              + TRACE_ID_HEADER\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String spanId = getter.get(carrier, SPAN_ID_HEADER);\n+    if (!isSpanIdValid(spanId)) {\n+      logger.info(\n+          \"Invalid SpanId in B3 header: \" + SPAN_ID_HEADER + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String sampled = getter.get(carrier, SAMPLED_HEADER);\n+    return buildSpanContext(traceId, spanId, sampled);\n+  }\n+\n+  private static SpanContext buildSpanContext(String traceId, String spanId, String sampled) {\n+    try {\n+      TraceFlags traceFlags =\n+          TraceFlags.builder()\n+              .setIsSampled(\n+                  TRUE_INT.equals(sampled)\n+                      || Boolean.parseBoolean(sampled)) // accept either \"1\" or \"true\"\n+              .build();\n+\n+      return SpanContext.createFromRemoteParent(\n+          TraceId.fromLowerBase16(traceId, 0),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2MDAyNQ==", "bodyText": "Should we have 2 propagators: legacy + single-header? I think that simplifies the code. We can do it later.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390660025", "createdAt": "2020-03-10T23:02:20Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2MDQ2NQ==", "bodyText": "Based on my understanding sampled is present if parts.length is 3 or 4 :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390660465", "createdAt": "2020-03-10T23:03:41Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    if (singleHeader) {\n+      return getSpanContextFromSingleHeader(carrier, getter);\n+    } else {\n+      return getSpanContextFromMultipleHeaders(carrier, getter);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C /*>>> extends @NonNull Object*/> SpanContext getSpanContextFromSingleHeader(\n+      C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, COMBINED_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      logger.info(\n+          \"Missing or empty combined header: \"\n+              + COMBINED_HEADER\n+              + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    // must have between 2 and 4 hyphen delimieted parts:\n+    //   traceId-spanId-sampled-parentSpanId (last two are optional)\n+    // NOTE: we do not use parentSpanId\n+    String[] parts = value.split(COMBINED_HEADER_DELIMITER);\n+    if (parts.length < 2 || parts.length > 4) {\n+      logger.info(\n+          \"Invalid combined header '\" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String traceId = parts[0];\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String spanId = parts[1];\n+    if (!isSpanIdValid(spanId)) {\n+      logger.info(\n+          \"Invalid SpanId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String sampled = parts.length == 3 ? parts[2] : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad"}, "originalPosition": 150}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8265db69379df1067ba45f0ba04adc628095249", "author": {"user": {"login": "MikeGoldsmith", "name": "Mike Goldsmith"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/c8265db69379df1067ba45f0ba04adc628095249", "committedDate": "2020-03-11T15:01:27Z", "message": "use constant sampled/not sampled TraceFalgs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b586a07ae100c38f5827a4fc0f340d3a421d59ae", "author": {"user": {"login": "MikeGoldsmith", "name": "Mike Goldsmith"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b586a07ae100c38f5827a4fc0f340d3a421d59ae", "committedDate": "2020-03-11T15:02:43Z", "message": "remove unnecessary generic type checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84d15f37376e442e03b8975f0e2a899aa8c2588f", "author": {"user": {"login": "MikeGoldsmith", "name": "Mike Goldsmith"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/84d15f37376e442e03b8975f0e2a899aa8c2588f", "committedDate": "2020-03-11T15:22:38Z", "message": "use sampled string if there are 3 or 4 items in the array"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "194ba936639b44ac2d2beb8fd8270e3851d91fd2", "author": {"user": {"login": "MikeGoldsmith", "name": "Mike Goldsmith"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/194ba936639b44ac2d2beb8fd8270e3851d91fd2", "committedDate": "2020-03-11T16:20:55Z", "message": "pad traceID upto 32 chars if needed\n\n- adds StringUtils.padString and tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd1a041f43bb7bdeba1a695eadee4e8728e10d43", "author": {"user": {"login": "MikeGoldsmith", "name": "Mike Goldsmith"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/fd1a041f43bb7bdeba1a695eadee4e8728e10d43", "committedDate": "2020-03-11T16:30:53Z", "message": "fix padLeft unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d755e94c116d404e8d452fab3a65b224ed21569", "author": {"user": {"login": "MikeGoldsmith", "name": "Mike Goldsmith"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/7d755e94c116d404e8d452fab3a65b224ed21569", "committedDate": "2020-03-11T16:33:01Z", "message": "update padLeft method & param descriptions"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3170, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}