{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2ODcyNDc1", "number": 2037, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNDoyNDo0NlrOE3jGTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMjoxNjozMFrOE4cNog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NjgyMTkwOnYy", "diffSide": "RIGHT", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/ViewRegistry.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNDoyNDo0NlrOHw9qbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwNTozOTozMVrOHw-54g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEwMzk4Mg==", "bodyText": "Mostly makes sense but I'm wondering why is this a best match? Shouldn't the aggregation configuration be more precise?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r521103982", "createdAt": "2020-11-11T04:24:46Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/ViewRegistry.java", "diffHunk": "@@ -36,39 +54,70 @@ Batcher createBatcher(\n       MeterSharedState meterSharedState,\n       InstrumentDescriptor descriptor) {\n \n-    Aggregation aggregation = getRegisteredAggregation(descriptor);\n+    AggregationConfiguration specification = findBestMatch(descriptor);\n \n-    // todo: don't just use the defaults!\n-    switch (descriptor.getType()) {\n-      case COUNTER:\n-      case UP_DOWN_COUNTER:\n-      case SUM_OBSERVER:\n-      case UP_DOWN_SUM_OBSERVER:\n-        return Batchers.getCumulativeAllLabels(\n-            descriptor, meterProviderSharedState, meterSharedState, aggregation);\n-      case VALUE_RECORDER:\n-        // TODO: Revisit the batcher used here for value observers,\n-        // currently this does not remove duplicate records in the same cycle.\n-      case VALUE_OBSERVER:\n-        return Batchers.getDeltaAllLabels(\n-            descriptor, meterProviderSharedState, meterSharedState, aggregation);\n+    Aggregation aggregation = specification.aggregation();\n+\n+    if (Temporality.CUMULATIVE == specification.temporality()) {\n+      return Batchers.getCumulativeAllLabels(\n+          descriptor, meterProviderSharedState, meterSharedState, aggregation);\n+    } else if (Temporality.DELTA == specification.temporality()) {\n+      return Batchers.getDeltaAllLabels(\n+          descriptor, meterProviderSharedState, meterSharedState, aggregation);\n     }\n-    throw new IllegalArgumentException(\"Unknown descriptor type: \" + descriptor.getType());\n+    throw new IllegalStateException(\"unsupported Temporality: \" + specification.temporality());\n   }\n \n-  private static Aggregation getRegisteredAggregation(InstrumentDescriptor descriptor) {\n-    // todo look up based on fields of the descriptor.\n+  // todo: consider moving this method to its own class, for more targeted testing.\n+  private AggregationConfiguration findBestMatch(InstrumentDescriptor descriptor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89937a904c1fca5ce76ba43e4e46cd7812ed0a0c"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTExNDE3Ng==", "bodyText": "Well, I can imagine someone saying\n\nBy default, aggregate all ValueRecorders with MinMaxSumCount.\nThis particular ValueRecorder, named \"http.request.latency\"...that one I want Histograms for\n\nSo, \"best match\" will find the most precise selection and choose that, falling back to less precise ones. Is there a better name I could use?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r521114176", "createdAt": "2020-11-11T05:00:00Z", "author": {"login": "jkwatson"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/ViewRegistry.java", "diffHunk": "@@ -36,39 +54,70 @@ Batcher createBatcher(\n       MeterSharedState meterSharedState,\n       InstrumentDescriptor descriptor) {\n \n-    Aggregation aggregation = getRegisteredAggregation(descriptor);\n+    AggregationConfiguration specification = findBestMatch(descriptor);\n \n-    // todo: don't just use the defaults!\n-    switch (descriptor.getType()) {\n-      case COUNTER:\n-      case UP_DOWN_COUNTER:\n-      case SUM_OBSERVER:\n-      case UP_DOWN_SUM_OBSERVER:\n-        return Batchers.getCumulativeAllLabels(\n-            descriptor, meterProviderSharedState, meterSharedState, aggregation);\n-      case VALUE_RECORDER:\n-        // TODO: Revisit the batcher used here for value observers,\n-        // currently this does not remove duplicate records in the same cycle.\n-      case VALUE_OBSERVER:\n-        return Batchers.getDeltaAllLabels(\n-            descriptor, meterProviderSharedState, meterSharedState, aggregation);\n+    Aggregation aggregation = specification.aggregation();\n+\n+    if (Temporality.CUMULATIVE == specification.temporality()) {\n+      return Batchers.getCumulativeAllLabels(\n+          descriptor, meterProviderSharedState, meterSharedState, aggregation);\n+    } else if (Temporality.DELTA == specification.temporality()) {\n+      return Batchers.getDeltaAllLabels(\n+          descriptor, meterProviderSharedState, meterSharedState, aggregation);\n     }\n-    throw new IllegalArgumentException(\"Unknown descriptor type: \" + descriptor.getType());\n+    throw new IllegalStateException(\"unsupported Temporality: \" + specification.temporality());\n   }\n \n-  private static Aggregation getRegisteredAggregation(InstrumentDescriptor descriptor) {\n-    // todo look up based on fields of the descriptor.\n+  // todo: consider moving this method to its own class, for more targeted testing.\n+  private AggregationConfiguration findBestMatch(InstrumentDescriptor descriptor) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEwMzk4Mg=="}, "originalCommit": {"oid": "89937a904c1fca5ce76ba43e4e46cd7812ed0a0c"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEyNDMyMg==", "bodyText": "I'd just name the method getAggregation and the loop can have a comment // See if user defined a specific configuration for this descriptor, the definition itself seems precise, not best-effort.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r521124322", "createdAt": "2020-11-11T05:39:31Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/ViewRegistry.java", "diffHunk": "@@ -36,39 +54,70 @@ Batcher createBatcher(\n       MeterSharedState meterSharedState,\n       InstrumentDescriptor descriptor) {\n \n-    Aggregation aggregation = getRegisteredAggregation(descriptor);\n+    AggregationConfiguration specification = findBestMatch(descriptor);\n \n-    // todo: don't just use the defaults!\n-    switch (descriptor.getType()) {\n-      case COUNTER:\n-      case UP_DOWN_COUNTER:\n-      case SUM_OBSERVER:\n-      case UP_DOWN_SUM_OBSERVER:\n-        return Batchers.getCumulativeAllLabels(\n-            descriptor, meterProviderSharedState, meterSharedState, aggregation);\n-      case VALUE_RECORDER:\n-        // TODO: Revisit the batcher used here for value observers,\n-        // currently this does not remove duplicate records in the same cycle.\n-      case VALUE_OBSERVER:\n-        return Batchers.getDeltaAllLabels(\n-            descriptor, meterProviderSharedState, meterSharedState, aggregation);\n+    Aggregation aggregation = specification.aggregation();\n+\n+    if (Temporality.CUMULATIVE == specification.temporality()) {\n+      return Batchers.getCumulativeAllLabels(\n+          descriptor, meterProviderSharedState, meterSharedState, aggregation);\n+    } else if (Temporality.DELTA == specification.temporality()) {\n+      return Batchers.getDeltaAllLabels(\n+          descriptor, meterProviderSharedState, meterSharedState, aggregation);\n     }\n-    throw new IllegalArgumentException(\"Unknown descriptor type: \" + descriptor.getType());\n+    throw new IllegalStateException(\"unsupported Temporality: \" + specification.temporality());\n   }\n \n-  private static Aggregation getRegisteredAggregation(InstrumentDescriptor descriptor) {\n-    // todo look up based on fields of the descriptor.\n+  // todo: consider moving this method to its own class, for more targeted testing.\n+  private AggregationConfiguration findBestMatch(InstrumentDescriptor descriptor) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTEwMzk4Mg=="}, "originalCommit": {"oid": "89937a904c1fca5ce76ba43e4e46cd7812ed0a0c"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MTYzMDYxOnYy", "diffSide": "RIGHT", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/AggregationConfiguration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNTo0OToxMlrOHxreKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMDowNTowOFrOHyMCyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg1NDUwNA==", "bodyText": "Needs some javadoc for a few of the classes", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r521854504", "createdAt": "2020-11-12T05:49:12Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/AggregationConfiguration.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.api.metrics.Instrument;\n+import javax.annotation.concurrent.Immutable;\n+\n+@AutoValue\n+@Immutable\n+public abstract class AggregationConfiguration {\n+\n+  public static AggregationConfiguration create(Aggregation aggregation, Temporality temporality) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ff19d1829b8763dac266f54127a79867d0a7074"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM4ODE3MQ==", "bodyText": "javadoc added. I think this is ready for a final look-see if anyone wants to do that.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522388171", "createdAt": "2020-11-12T20:05:08Z", "author": {"login": "jkwatson"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/AggregationConfiguration.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.api.metrics.Instrument;\n+import javax.annotation.concurrent.Immutable;\n+\n+@AutoValue\n+@Immutable\n+public abstract class AggregationConfiguration {\n+\n+  public static AggregationConfiguration create(Aggregation aggregation, Temporality temporality) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg1NDUwNA=="}, "originalCommit": {"oid": "9ff19d1829b8763dac266f54127a79867d0a7074"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTg3MzY2OnYy", "diffSide": "RIGHT", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/Batcher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxMjo0NVrOHyUKXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDo0MTowMVrOHyUuHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMTE4Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /** Does this batcher generate \"delta\" style metrics. The alternative is \"cumulative\". */\n          \n          \n            \n              /** Returns whether this batcher generate \"delta\" style metrics. The alternative is \"cumulative\". */", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522521182", "createdAt": "2020-11-13T00:12:45Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/Batcher.java", "diffHunk": "@@ -51,4 +51,7 @@\n    * @return the list of metrics batched in this Batcher.\n    */\n   List<MetricData> completeCollectionCycle();\n+\n+  /** Does this batcher generate \"delta\" style metrics. The alternative is \"cumulative\". */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "778a8a318a0d2aaf2f80e5c2301a6948f6abf4e9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUzMDMzNQ==", "bodyText": "I'm going to accept your changes, then regret it when the formatter check fails.  ;)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522530335", "createdAt": "2020-11-13T00:41:01Z", "author": {"login": "jkwatson"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/Batcher.java", "diffHunk": "@@ -51,4 +51,7 @@\n    * @return the list of metrics batched in this Batcher.\n    */\n   List<MetricData> completeCollectionCycle();\n+\n+  /** Does this batcher generate \"delta\" style metrics. The alternative is \"cumulative\". */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMTE4Mg=="}, "originalCommit": {"oid": "778a8a318a0d2aaf2f80e5c2301a6948f6abf4e9"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTg3NDgwOnYy", "diffSide": "RIGHT", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/Batchers.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxMzoyN1rOHyULFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDozOTo1N1rOHyUs4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMTM2NQ==", "bodyText": "Think you can use Objects.hashCode instead of your own null checks", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522521365", "createdAt": "2020-11-13T00:13:27Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/Batchers.java", "diffHunk": "@@ -155,6 +160,75 @@ public final void batch(Labels labelSet, Aggregator aggregator, boolean unmapped\n               aggregation.getDescriptorType(descriptor.getType(), descriptor.getValueType()),\n               points));\n     }\n+\n+    @Override\n+    public boolean generatesDeltas() {\n+      return delta;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+\n+      AllLabels allLabels = (AllLabels) o;\n+\n+      if (startEpochNanos != allLabels.startEpochNanos) {\n+        return false;\n+      }\n+      if (delta != allLabels.delta) {\n+        return false;\n+      }\n+      if (descriptor != null\n+          ? !descriptor.equals(allLabels.descriptor)\n+          : allLabels.descriptor != null) {\n+        return false;\n+      }\n+      if (aggregation != null\n+          ? !aggregation.equals(allLabels.aggregation)\n+          : allLabels.aggregation != null) {\n+        return false;\n+      }\n+      if (resource != null ? !resource.equals(allLabels.resource) : allLabels.resource != null) {\n+        return false;\n+      }\n+      if (instrumentationLibraryInfo != null\n+          ? !instrumentationLibraryInfo.equals(allLabels.instrumentationLibraryInfo)\n+          : allLabels.instrumentationLibraryInfo != null) {\n+        return false;\n+      }\n+      if (clock != null ? !clock.equals(allLabels.clock) : allLabels.clock != null) {\n+        return false;\n+      }\n+      if (aggregatorFactory != null\n+          ? !aggregatorFactory.equals(allLabels.aggregatorFactory)\n+          : allLabels.aggregatorFactory != null) {\n+        return false;\n+      }\n+      return aggregatorMap != null\n+          ? aggregatorMap.equals(allLabels.aggregatorMap)\n+          : allLabels.aggregatorMap == null;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      int result = descriptor != null ? descriptor.hashCode() : 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "778a8a318a0d2aaf2f80e5c2301a6948f6abf4e9"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUzMDAxNg==", "bodyText": "I just had IDEA generate this code. Hate to mess with generated code in general.\nWe should document what we want to do with generated equals/hashcode/toString implementations, so we don't have to discuss it. :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522530016", "createdAt": "2020-11-13T00:39:57Z", "author": {"login": "jkwatson"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/Batchers.java", "diffHunk": "@@ -155,6 +160,75 @@ public final void batch(Labels labelSet, Aggregator aggregator, boolean unmapped\n               aggregation.getDescriptorType(descriptor.getType(), descriptor.getValueType()),\n               points));\n     }\n+\n+    @Override\n+    public boolean generatesDeltas() {\n+      return delta;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+\n+      AllLabels allLabels = (AllLabels) o;\n+\n+      if (startEpochNanos != allLabels.startEpochNanos) {\n+        return false;\n+      }\n+      if (delta != allLabels.delta) {\n+        return false;\n+      }\n+      if (descriptor != null\n+          ? !descriptor.equals(allLabels.descriptor)\n+          : allLabels.descriptor != null) {\n+        return false;\n+      }\n+      if (aggregation != null\n+          ? !aggregation.equals(allLabels.aggregation)\n+          : allLabels.aggregation != null) {\n+        return false;\n+      }\n+      if (resource != null ? !resource.equals(allLabels.resource) : allLabels.resource != null) {\n+        return false;\n+      }\n+      if (instrumentationLibraryInfo != null\n+          ? !instrumentationLibraryInfo.equals(allLabels.instrumentationLibraryInfo)\n+          : allLabels.instrumentationLibraryInfo != null) {\n+        return false;\n+      }\n+      if (clock != null ? !clock.equals(allLabels.clock) : allLabels.clock != null) {\n+        return false;\n+      }\n+      if (aggregatorFactory != null\n+          ? !aggregatorFactory.equals(allLabels.aggregatorFactory)\n+          : allLabels.aggregatorFactory != null) {\n+        return false;\n+      }\n+      return aggregatorMap != null\n+          ? aggregatorMap.equals(allLabels.aggregatorMap)\n+          : allLabels.aggregatorMap == null;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      int result = descriptor != null ? descriptor.hashCode() : 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMTM2NQ=="}, "originalCommit": {"oid": "778a8a318a0d2aaf2f80e5c2301a6948f6abf4e9"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTg3NTI4OnYy", "diffSide": "RIGHT", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/AggregationConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxMzo0MlrOHyULWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxMzo0MlrOHyULWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMTQzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /** Create a new configuration with the provided options. */\n          \n          \n            \n              /** Returns a new configuration with the provided options. */", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522521435", "createdAt": "2020-11-13T00:13:42Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/AggregationConfiguration.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.api.metrics.Instrument;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An AggregationConfiguration describes how an aggregation should be performed. It includes both an\n+ * {@link Aggregation} which implements what shape of aggregation is created (i.e. histogram, sum,\n+ * minMaxSumCount, etc), and a {@link AggregationConfiguration.Temporality} which describes whether\n+ * aggregations should be reset with every collection interval, or continue to accumulate across\n+ * collection intervals.\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class AggregationConfiguration {\n+\n+  /** Create a new configuration with the provided options. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "778a8a318a0d2aaf2f80e5c2301a6948f6abf4e9"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTg3NTY2OnYy", "diffSide": "RIGHT", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/AggregationConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxMzo1MVrOHyULkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxMzo1MVrOHyULkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMTQ4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /** Which {@link Aggregation} should be used for this View. */\n          \n          \n            \n              /** Returns the {@link Aggregation} that should be used for this View. */", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522521488", "createdAt": "2020-11-13T00:13:51Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/AggregationConfiguration.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.api.metrics.Instrument;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An AggregationConfiguration describes how an aggregation should be performed. It includes both an\n+ * {@link Aggregation} which implements what shape of aggregation is created (i.e. histogram, sum,\n+ * minMaxSumCount, etc), and a {@link AggregationConfiguration.Temporality} which describes whether\n+ * aggregations should be reset with every collection interval, or continue to accumulate across\n+ * collection intervals.\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class AggregationConfiguration {\n+\n+  /** Create a new configuration with the provided options. */\n+  public static AggregationConfiguration create(Aggregation aggregation, Temporality temporality) {\n+    return new AutoValue_AggregationConfiguration(aggregation, temporality);\n+  }\n+\n+  /** Which {@link Aggregation} should be used for this View. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "778a8a318a0d2aaf2f80e5c2301a6948f6abf4e9"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTg3NTk1OnYy", "diffSide": "RIGHT", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/AggregationConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNDowMFrOHyULvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNDowMFrOHyULvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMTUzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /** What {@link Temporality} should be used for this View (delta vs. cumulative). */\n          \n          \n            \n              /** Returns the {@link Temporality} that should be used for this View (delta vs. cumulative). */", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522521533", "createdAt": "2020-11-13T00:14:00Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/AggregationConfiguration.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.api.metrics.Instrument;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An AggregationConfiguration describes how an aggregation should be performed. It includes both an\n+ * {@link Aggregation} which implements what shape of aggregation is created (i.e. histogram, sum,\n+ * minMaxSumCount, etc), and a {@link AggregationConfiguration.Temporality} which describes whether\n+ * aggregations should be reset with every collection interval, or continue to accumulate across\n+ * collection intervals.\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class AggregationConfiguration {\n+\n+  /** Create a new configuration with the provided options. */\n+  public static AggregationConfiguration create(Aggregation aggregation, Temporality temporality) {\n+    return new AutoValue_AggregationConfiguration(aggregation, temporality);\n+  }\n+\n+  /** Which {@link Aggregation} should be used for this View. */\n+  public abstract Aggregation aggregation();\n+\n+  /** What {@link Temporality} should be used for this View (delta vs. cumulative). */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "778a8a318a0d2aaf2f80e5c2301a6948f6abf4e9"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTg3NjU5OnYy", "diffSide": "RIGHT", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNDoxN1rOHyUMFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNDoxN1rOHyUMFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMTYyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * What {@link InstrumentType} should be selected. If null, then this specifier will not be used.\n          \n          \n            \n               * Returns {@link InstrumentType} that should be selected. If null, then this specifier will not be used.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522521620", "createdAt": "2020-11-13T00:14:17Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import com.google.auto.value.AutoValue;\n+import com.google.auto.value.extension.memoized.Memoized;\n+import io.opentelemetry.sdk.metrics.common.InstrumentType;\n+import java.util.regex.Pattern;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Provides means for selecting one ore more {@link io.opentelemetry.api.metrics.Instrument}s. Used\n+ * for configuring a aggregations for the specified instruments.\n+ *\n+ * <p>There are two options for selecting instruments: by instrument name and by instrument type.\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class InstrumentSelector {\n+  public static Builder newBuilder() {\n+    return new AutoValue_InstrumentSelector.Builder();\n+  }\n+\n+  /**\n+   * What {@link InstrumentType} should be selected. If null, then this specifier will not be used.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "778a8a318a0d2aaf2f80e5c2301a6948f6abf4e9"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTg3NzYxOnYy", "diffSide": "RIGHT", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNDozOVrOHyUMpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNDozOVrOHyUMpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMTc2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * What instrument names should be selected. This is a regex. If null, then this specifier will\n          \n          \n            \n               * Returns which instrument names should be selected. This is a regex. If null, then this specifier will", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522521767", "createdAt": "2020-11-13T00:14:39Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import com.google.auto.value.AutoValue;\n+import com.google.auto.value.extension.memoized.Memoized;\n+import io.opentelemetry.sdk.metrics.common.InstrumentType;\n+import java.util.regex.Pattern;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Provides means for selecting one ore more {@link io.opentelemetry.api.metrics.Instrument}s. Used\n+ * for configuring a aggregations for the specified instruments.\n+ *\n+ * <p>There are two options for selecting instruments: by instrument name and by instrument type.\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class InstrumentSelector {\n+  public static Builder newBuilder() {\n+    return new AutoValue_InstrumentSelector.Builder();\n+  }\n+\n+  /**\n+   * What {@link InstrumentType} should be selected. If null, then this specifier will not be used.\n+   */\n+  @Nullable\n+  public abstract InstrumentType instrumentType();\n+\n+  /**\n+   * What instrument names should be selected. This is a regex. If null, then this specifier will", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "778a8a318a0d2aaf2f80e5c2301a6948f6abf4e9"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTg3ODE4OnYy", "diffSide": "RIGHT", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNDo0N1rOHyUM8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNDo0N1rOHyUM8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMTg0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * The {@link Pattern} generated by the provided {@link #instrumentNameRegex()}, or null if none\n          \n          \n            \n               * Returns the {@link Pattern} generated by the provided {@link #instrumentNameRegex()}, or null if none", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522521843", "createdAt": "2020-11-13T00:14:47Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import com.google.auto.value.AutoValue;\n+import com.google.auto.value.extension.memoized.Memoized;\n+import io.opentelemetry.sdk.metrics.common.InstrumentType;\n+import java.util.regex.Pattern;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Provides means for selecting one ore more {@link io.opentelemetry.api.metrics.Instrument}s. Used\n+ * for configuring a aggregations for the specified instruments.\n+ *\n+ * <p>There are two options for selecting instruments: by instrument name and by instrument type.\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class InstrumentSelector {\n+  public static Builder newBuilder() {\n+    return new AutoValue_InstrumentSelector.Builder();\n+  }\n+\n+  /**\n+   * What {@link InstrumentType} should be selected. If null, then this specifier will not be used.\n+   */\n+  @Nullable\n+  public abstract InstrumentType instrumentType();\n+\n+  /**\n+   * What instrument names should be selected. This is a regex. If null, then this specifier will\n+   * not be used.\n+   */\n+  @Nullable\n+  public abstract String instrumentNameRegex();\n+\n+  /**\n+   * The {@link Pattern} generated by the provided {@link #instrumentNameRegex()}, or null if none", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "778a8a318a0d2aaf2f80e5c2301a6948f6abf4e9"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTg3ODM2OnYy", "diffSide": "RIGHT", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNDo1NFrOHyUNEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNDo1NFrOHyUNEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMTg3NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /** Whether the InstrumentType been specified. */\n          \n          \n            \n              /** Returns whether the InstrumentType been specified. */", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522521874", "createdAt": "2020-11-13T00:14:54Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import com.google.auto.value.AutoValue;\n+import com.google.auto.value.extension.memoized.Memoized;\n+import io.opentelemetry.sdk.metrics.common.InstrumentType;\n+import java.util.regex.Pattern;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Provides means for selecting one ore more {@link io.opentelemetry.api.metrics.Instrument}s. Used\n+ * for configuring a aggregations for the specified instruments.\n+ *\n+ * <p>There are two options for selecting instruments: by instrument name and by instrument type.\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class InstrumentSelector {\n+  public static Builder newBuilder() {\n+    return new AutoValue_InstrumentSelector.Builder();\n+  }\n+\n+  /**\n+   * What {@link InstrumentType} should be selected. If null, then this specifier will not be used.\n+   */\n+  @Nullable\n+  public abstract InstrumentType instrumentType();\n+\n+  /**\n+   * What instrument names should be selected. This is a regex. If null, then this specifier will\n+   * not be used.\n+   */\n+  @Nullable\n+  public abstract String instrumentNameRegex();\n+\n+  /**\n+   * The {@link Pattern} generated by the provided {@link #instrumentNameRegex()}, or null if none\n+   * was specified.\n+   */\n+  @Nullable\n+  @Memoized\n+  public Pattern instrumentNamePattern() {\n+    return instrumentNameRegex() == null ? null : Pattern.compile(instrumentNameRegex());\n+  }\n+\n+  /** Whether the InstrumentType been specified. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "778a8a318a0d2aaf2f80e5c2301a6948f6abf4e9"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTg3ODc1OnYy", "diffSide": "RIGHT", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNTowMFrOHyUNRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNTowMFrOHyUNRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMTkyNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /** Whether the instrument name regex been specified. */\n          \n          \n            \n              /** Returns whether the instrument name regex been specified. */", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522521925", "createdAt": "2020-11-13T00:15:00Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import com.google.auto.value.AutoValue;\n+import com.google.auto.value.extension.memoized.Memoized;\n+import io.opentelemetry.sdk.metrics.common.InstrumentType;\n+import java.util.regex.Pattern;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Provides means for selecting one ore more {@link io.opentelemetry.api.metrics.Instrument}s. Used\n+ * for configuring a aggregations for the specified instruments.\n+ *\n+ * <p>There are two options for selecting instruments: by instrument name and by instrument type.\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class InstrumentSelector {\n+  public static Builder newBuilder() {\n+    return new AutoValue_InstrumentSelector.Builder();\n+  }\n+\n+  /**\n+   * What {@link InstrumentType} should be selected. If null, then this specifier will not be used.\n+   */\n+  @Nullable\n+  public abstract InstrumentType instrumentType();\n+\n+  /**\n+   * What instrument names should be selected. This is a regex. If null, then this specifier will\n+   * not be used.\n+   */\n+  @Nullable\n+  public abstract String instrumentNameRegex();\n+\n+  /**\n+   * The {@link Pattern} generated by the provided {@link #instrumentNameRegex()}, or null if none\n+   * was specified.\n+   */\n+  @Nullable\n+  @Memoized\n+  public Pattern instrumentNamePattern() {\n+    return instrumentNameRegex() == null ? null : Pattern.compile(instrumentNameRegex());\n+  }\n+\n+  /** Whether the InstrumentType been specified. */\n+  public boolean hasInstrumentType() {\n+    return instrumentType() != null;\n+  }\n+\n+  /** Whether the instrument name regex been specified. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "778a8a318a0d2aaf2f80e5c2301a6948f6abf4e9"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTg3OTI3OnYy", "diffSide": "RIGHT", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNToxM1rOHyUNig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNToxM1rOHyUNig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMTk5NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /** Provide a specifier for {@link InstrumentType}. */\n          \n          \n            \n                /** Sets a specifier for {@link InstrumentType}. */", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522521994", "createdAt": "2020-11-13T00:15:13Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import com.google.auto.value.AutoValue;\n+import com.google.auto.value.extension.memoized.Memoized;\n+import io.opentelemetry.sdk.metrics.common.InstrumentType;\n+import java.util.regex.Pattern;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Provides means for selecting one ore more {@link io.opentelemetry.api.metrics.Instrument}s. Used\n+ * for configuring a aggregations for the specified instruments.\n+ *\n+ * <p>There are two options for selecting instruments: by instrument name and by instrument type.\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class InstrumentSelector {\n+  public static Builder newBuilder() {\n+    return new AutoValue_InstrumentSelector.Builder();\n+  }\n+\n+  /**\n+   * What {@link InstrumentType} should be selected. If null, then this specifier will not be used.\n+   */\n+  @Nullable\n+  public abstract InstrumentType instrumentType();\n+\n+  /**\n+   * What instrument names should be selected. This is a regex. If null, then this specifier will\n+   * not be used.\n+   */\n+  @Nullable\n+  public abstract String instrumentNameRegex();\n+\n+  /**\n+   * The {@link Pattern} generated by the provided {@link #instrumentNameRegex()}, or null if none\n+   * was specified.\n+   */\n+  @Nullable\n+  @Memoized\n+  public Pattern instrumentNamePattern() {\n+    return instrumentNameRegex() == null ? null : Pattern.compile(instrumentNameRegex());\n+  }\n+\n+  /** Whether the InstrumentType been specified. */\n+  public boolean hasInstrumentType() {\n+    return instrumentType() != null;\n+  }\n+\n+  /** Whether the instrument name regex been specified. */\n+  public boolean hasInstrumentNameRegex() {\n+    return instrumentNameRegex() != null;\n+  }\n+\n+  /** Builder for {@link InstrumentSelector} instances. */\n+  @AutoValue.Builder\n+  public interface Builder {\n+    /** Provide a specifier for {@link InstrumentType}. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "778a8a318a0d2aaf2f80e5c2301a6948f6abf4e9"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTg3OTU4OnYy", "diffSide": "RIGHT", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNToyMFrOHyUNuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNToyMFrOHyUNuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMjA0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /** Provide a specifier for selecting Instruments by name. */\n          \n          \n            \n                /** Sets a specifier for selecting Instruments by name. */", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522522040", "createdAt": "2020-11-13T00:15:20Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import com.google.auto.value.AutoValue;\n+import com.google.auto.value.extension.memoized.Memoized;\n+import io.opentelemetry.sdk.metrics.common.InstrumentType;\n+import java.util.regex.Pattern;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Provides means for selecting one ore more {@link io.opentelemetry.api.metrics.Instrument}s. Used\n+ * for configuring a aggregations for the specified instruments.\n+ *\n+ * <p>There are two options for selecting instruments: by instrument name and by instrument type.\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class InstrumentSelector {\n+  public static Builder newBuilder() {\n+    return new AutoValue_InstrumentSelector.Builder();\n+  }\n+\n+  /**\n+   * What {@link InstrumentType} should be selected. If null, then this specifier will not be used.\n+   */\n+  @Nullable\n+  public abstract InstrumentType instrumentType();\n+\n+  /**\n+   * What instrument names should be selected. This is a regex. If null, then this specifier will\n+   * not be used.\n+   */\n+  @Nullable\n+  public abstract String instrumentNameRegex();\n+\n+  /**\n+   * The {@link Pattern} generated by the provided {@link #instrumentNameRegex()}, or null if none\n+   * was specified.\n+   */\n+  @Nullable\n+  @Memoized\n+  public Pattern instrumentNamePattern() {\n+    return instrumentNameRegex() == null ? null : Pattern.compile(instrumentNameRegex());\n+  }\n+\n+  /** Whether the InstrumentType been specified. */\n+  public boolean hasInstrumentType() {\n+    return instrumentType() != null;\n+  }\n+\n+  /** Whether the instrument name regex been specified. */\n+  public boolean hasInstrumentNameRegex() {\n+    return instrumentNameRegex() != null;\n+  }\n+\n+  /** Builder for {@link InstrumentSelector} instances. */\n+  @AutoValue.Builder\n+  public interface Builder {\n+    /** Provide a specifier for {@link InstrumentType}. */\n+    Builder instrumentType(InstrumentType instrumentType);\n+\n+    /** Provide a specifier for selecting Instruments by name. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "778a8a318a0d2aaf2f80e5c2301a6948f6abf4e9"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTg4MDEwOnYy", "diffSide": "RIGHT", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNTozMFrOHyUN-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNTozMFrOHyUN-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMjEwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /** Create an InstrumentSelector instance. */\n          \n          \n            \n                /** Returns an InstrumentSelector instance with the content of this builder. */", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522522106", "createdAt": "2020-11-13T00:15:30Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import com.google.auto.value.AutoValue;\n+import com.google.auto.value.extension.memoized.Memoized;\n+import io.opentelemetry.sdk.metrics.common.InstrumentType;\n+import java.util.regex.Pattern;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Provides means for selecting one ore more {@link io.opentelemetry.api.metrics.Instrument}s. Used\n+ * for configuring a aggregations for the specified instruments.\n+ *\n+ * <p>There are two options for selecting instruments: by instrument name and by instrument type.\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class InstrumentSelector {\n+  public static Builder newBuilder() {\n+    return new AutoValue_InstrumentSelector.Builder();\n+  }\n+\n+  /**\n+   * What {@link InstrumentType} should be selected. If null, then this specifier will not be used.\n+   */\n+  @Nullable\n+  public abstract InstrumentType instrumentType();\n+\n+  /**\n+   * What instrument names should be selected. This is a regex. If null, then this specifier will\n+   * not be used.\n+   */\n+  @Nullable\n+  public abstract String instrumentNameRegex();\n+\n+  /**\n+   * The {@link Pattern} generated by the provided {@link #instrumentNameRegex()}, or null if none\n+   * was specified.\n+   */\n+  @Nullable\n+  @Memoized\n+  public Pattern instrumentNamePattern() {\n+    return instrumentNameRegex() == null ? null : Pattern.compile(instrumentNameRegex());\n+  }\n+\n+  /** Whether the InstrumentType been specified. */\n+  public boolean hasInstrumentType() {\n+    return instrumentType() != null;\n+  }\n+\n+  /** Whether the instrument name regex been specified. */\n+  public boolean hasInstrumentNameRegex() {\n+    return instrumentNameRegex() != null;\n+  }\n+\n+  /** Builder for {@link InstrumentSelector} instances. */\n+  @AutoValue.Builder\n+  public interface Builder {\n+    /** Provide a specifier for {@link InstrumentType}. */\n+    Builder instrumentType(InstrumentType instrumentType);\n+\n+    /** Provide a specifier for selecting Instruments by name. */\n+    Builder instrumentNameRegex(String regex);\n+\n+    /** Create an InstrumentSelector instance. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "778a8a318a0d2aaf2f80e5c2301a6948f6abf4e9"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTg4MDQwOnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNTo0MVrOHyUOLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMjowMzoyN1rOHyWoXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMjE1OQ==", "bodyText": "javadoc?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522522159", "createdAt": "2020-11-13T00:15:41Z", "author": {"login": "anuraaga"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import com.google.auto.value.AutoValue;\n+import com.google.auto.value.extension.memoized.Memoized;\n+import io.opentelemetry.sdk.metrics.common.InstrumentType;\n+import java.util.regex.Pattern;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+\n+@AutoValue\n+@Immutable\n+public abstract class InstrumentSelector {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "778a8a318a0d2aaf2f80e5c2301a6948f6abf4e9"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUzMzc2Mg==", "bodyText": "It has javadoc...  I've been seeing some real issue with GH not showing the latest version of the code today. Maybe you got hit by that, too?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522533762", "createdAt": "2020-11-13T00:48:10Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import com.google.auto.value.AutoValue;\n+import com.google.auto.value.extension.memoized.Memoized;\n+import io.opentelemetry.sdk.metrics.common.InstrumentType;\n+import java.util.regex.Pattern;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+\n+@AutoValue\n+@Immutable\n+public abstract class InstrumentSelector {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMjE1OQ=="}, "originalCommit": {"oid": "778a8a318a0d2aaf2f80e5c2301a6948f6abf4e9"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU2MTYyOA==", "bodyText": "Checked the PR locally and indeed - weirdest thing I've seen.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522561628", "createdAt": "2020-11-13T02:03:27Z", "author": {"login": "anuraaga"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import com.google.auto.value.AutoValue;\n+import com.google.auto.value.extension.memoized.Memoized;\n+import io.opentelemetry.sdk.metrics.common.InstrumentType;\n+import java.util.regex.Pattern;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+\n+@AutoValue\n+@Immutable\n+public abstract class InstrumentSelector {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMjE1OQ=="}, "originalCommit": {"oid": "778a8a318a0d2aaf2f80e5c2301a6948f6abf4e9"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTg4MDk0OnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/view/AggregationConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNTo1OFrOHyUOgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNTo1OFrOHyUOgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMjI0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /** Which {@link Aggregation} should be used for this View. */\n          \n          \n            \n              /** Returns the {@link Aggregation} that should be used for this View. */", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522522243", "createdAt": "2020-11-13T00:15:58Z", "author": {"login": "anuraaga"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/view/AggregationConfiguration.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.metrics.Instrument;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+\n+@AutoValue\n+@Immutable\n+public abstract class AggregationConfiguration {\n+\n+  public static AggregationConfiguration create(Aggregation aggregation, Temporality temporality) {\n+    return new AutoValue_AggregationConfiguration(aggregation, temporality);\n+  }\n+\n+  /** Which {@link Aggregation} should be used for this View. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "778a8a318a0d2aaf2f80e5c2301a6948f6abf4e9"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTg4MTE3OnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/view/AggregationConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNjowNVrOHyUOpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMDoxNjowNVrOHyUOpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMjI3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /** What {@link Temporality} should be used for this View (delta vs. cumulative). */\n          \n          \n            \n              /** Returns the {@link Temporality} that should be used for this View (delta vs. cumulative). */", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522522279", "createdAt": "2020-11-13T00:16:05Z", "author": {"login": "anuraaga"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/view/AggregationConfiguration.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.metrics.Instrument;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+\n+@AutoValue\n+@Immutable\n+public abstract class AggregationConfiguration {\n+\n+  public static AggregationConfiguration create(Aggregation aggregation, Temporality temporality) {\n+    return new AutoValue_AggregationConfiguration(aggregation, temporality);\n+  }\n+\n+  /** Which {@link Aggregation} should be used for this View. */\n+  @Nullable\n+  public abstract Aggregation aggregation();\n+\n+  /** What {@link Temporality} should be used for this View (delta vs. cumulative). */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "778a8a318a0d2aaf2f80e5c2301a6948f6abf4e9"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NjE3OTU0OnYy", "diffSide": "RIGHT", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMjoxNjozMFrOHyXCzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwMjoxNjozMFrOHyXCzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU2ODM5OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * for configuring a aggregations for the specified instruments.\n          \n          \n            \n             * for configuring aggregations for the specified instruments.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2037#discussion_r522568398", "createdAt": "2020-11-13T02:16:30Z", "author": {"login": "jkwatson"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/view/InstrumentSelector.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import com.google.auto.value.AutoValue;\n+import com.google.auto.value.extension.memoized.Memoized;\n+import io.opentelemetry.sdk.metrics.common.InstrumentType;\n+import java.util.regex.Pattern;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Provides means for selecting one ore more {@link io.opentelemetry.api.metrics.Instrument}s. Used\n+ * for configuring a aggregations for the specified instruments.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "816c35cfa9217f02ede1e2630f1c30358dffcd2f"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1912, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}