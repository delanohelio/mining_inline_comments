{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1NjQ3Nzk3", "number": 2007, "title": "Make the BatchRecorderSdk actually batch the recordings", "bodyText": "Rather than just forwarding them immediately.\nResolves #1621", "createdAt": "2020-11-04T21:23:32Z", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2007", "merged": true, "mergeCommit": {"oid": "5ea50d3104cae3007ebd7a8dbe7aad445f6f00fd"}, "closed": true, "closedAt": "2020-11-10T17:44:17Z", "author": {"login": "jkwatson"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZUjRPAH2gAyNTE1NjQ3Nzk3Ojc0M2VjODIzZTVmYWFlOWYyMGY5ZGViMWYyYmJlYjI4NmVhM2MyODE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABda-Zi8gFqTUyNjc2NjEwNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "743ec823e5faae9f20f9deb1f2bbeb286ea3c281", "author": {"user": {"login": "jkwatson", "name": "John Watson"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/743ec823e5faae9f20f9deb1f2bbeb286ea3c281", "committedDate": "2020-11-04T21:21:58Z", "message": "Make the BatchRecorderSdk actually batch the recordings\nRather than just forwarding them immediately."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzOTE5OTE5", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2007#pullrequestreview-523919919", "createdAt": "2020-11-05T04:37:19Z", "commit": {"oid": "743ec823e5faae9f20f9deb1f2bbeb286ea3c281"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNDozNzoxOVrOHtzQuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNDo0MzoxOVrOHtzWTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc4NzgzNQ==", "bodyText": "If I'm reading this right, I think there's less code duplication if we have the loop on the outside of the instanceof checks", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2007#discussion_r517787835", "createdAt": "2020-11-05T04:37:19Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/BatchRecorderSdk.java", "diffHunk": "@@ -10,61 +10,105 @@\n import io.opentelemetry.api.metrics.DoubleCounter;\n import io.opentelemetry.api.metrics.DoubleUpDownCounter;\n import io.opentelemetry.api.metrics.DoubleValueRecorder;\n+import io.opentelemetry.api.metrics.Instrument;\n import io.opentelemetry.api.metrics.LongCounter;\n import io.opentelemetry.api.metrics.LongUpDownCounter;\n import io.opentelemetry.api.metrics.LongValueRecorder;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n /**\n  * Minimal implementation of the {@link BatchRecorder} that simply redirects the calls to the\n  * instruments.\n- *\n- * <p>TODO: Add an async queue processing to process batch records.\n  */\n final class BatchRecorderSdk implements BatchRecorder {\n   private final Labels labelSet;\n \n+  private volatile Map<Instrument, List<Number>> recordings = new HashMap<>();\n+  private volatile Map<Instrument, List<Number>> previousRecordings = new HashMap<>();\n+\n   BatchRecorderSdk(String... keyValuePairs) {\n     this.labelSet = Labels.of(keyValuePairs);\n   }\n \n   @Override\n   public BatchRecorder put(LongValueRecorder valueRecorder, long value) {\n-    valueRecorder.record(value, labelSet);\n+    recordings.computeIfAbsent(valueRecorder, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(DoubleValueRecorder valueRecorder, double value) {\n-    valueRecorder.record(value, labelSet);\n+    recordings.computeIfAbsent(valueRecorder, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(LongCounter counter, long value) {\n-    counter.add(value, labelSet);\n+    recordings.computeIfAbsent(counter, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(DoubleCounter counter, double value) {\n-    counter.add(value, labelSet);\n+    recordings.computeIfAbsent(counter, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(LongUpDownCounter upDownCounter, long value) {\n-    upDownCounter.add(value, labelSet);\n+    recordings.computeIfAbsent(upDownCounter, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(DoubleUpDownCounter upDownCounter, double value) {\n-    upDownCounter.add(value, labelSet);\n+    recordings.computeIfAbsent(upDownCounter, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public void record() {\n-    // No-op in this minimal implementation.\n+    previousRecordings.clear();\n+\n+    Map<Instrument, List<Number>> temp = recordings;\n+    recordings = previousRecordings;\n+    previousRecordings = temp;\n+\n+    previousRecordings.forEach(\n+        (instrument, numbers) -> {\n+          if (instrument instanceof DoubleUpDownCounter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "743ec823e5faae9f20f9deb1f2bbeb286ea3c281"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc4ODQ1NQ==", "bodyText": "I'm guessing this can be called concurrently - so the maps need to be ConcurrentHashMap and the value something synchronized, probably BlockingQueue.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2007#discussion_r517788455", "createdAt": "2020-11-05T04:39:59Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/BatchRecorderSdk.java", "diffHunk": "@@ -10,61 +10,105 @@\n import io.opentelemetry.api.metrics.DoubleCounter;\n import io.opentelemetry.api.metrics.DoubleUpDownCounter;\n import io.opentelemetry.api.metrics.DoubleValueRecorder;\n+import io.opentelemetry.api.metrics.Instrument;\n import io.opentelemetry.api.metrics.LongCounter;\n import io.opentelemetry.api.metrics.LongUpDownCounter;\n import io.opentelemetry.api.metrics.LongValueRecorder;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n /**\n  * Minimal implementation of the {@link BatchRecorder} that simply redirects the calls to the\n  * instruments.\n- *\n- * <p>TODO: Add an async queue processing to process batch records.\n  */\n final class BatchRecorderSdk implements BatchRecorder {\n   private final Labels labelSet;\n \n+  private volatile Map<Instrument, List<Number>> recordings = new HashMap<>();\n+  private volatile Map<Instrument, List<Number>> previousRecordings = new HashMap<>();\n+\n   BatchRecorderSdk(String... keyValuePairs) {\n     this.labelSet = Labels.of(keyValuePairs);\n   }\n \n   @Override\n   public BatchRecorder put(LongValueRecorder valueRecorder, long value) {\n-    valueRecorder.record(value, labelSet);\n+    recordings.computeIfAbsent(valueRecorder, instrument -> new ArrayList<>()).add(value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "743ec823e5faae9f20f9deb1f2bbeb286ea3c281"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc4OTI2Mw==", "bodyText": "Though given the primitive types have to be boxed anyways, I think wrapping in our own type would have very low overhead. So instead of two maps, I guess we can use a single queue? Would be easier to reason about.\nprivate static class LongRecording implements Recording {\n  private final Instrument instrument;\n  private final long value;\n}\n\nBlockingQueue<Recoding> recordings;\n\nrecord() {\n  recordings.drainTo(buffer);\n  for (Recording recording : buffer) {\n    ...\n  }", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2007#discussion_r517789263", "createdAt": "2020-11-05T04:43:19Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/BatchRecorderSdk.java", "diffHunk": "@@ -10,61 +10,105 @@\n import io.opentelemetry.api.metrics.DoubleCounter;\n import io.opentelemetry.api.metrics.DoubleUpDownCounter;\n import io.opentelemetry.api.metrics.DoubleValueRecorder;\n+import io.opentelemetry.api.metrics.Instrument;\n import io.opentelemetry.api.metrics.LongCounter;\n import io.opentelemetry.api.metrics.LongUpDownCounter;\n import io.opentelemetry.api.metrics.LongValueRecorder;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n /**\n  * Minimal implementation of the {@link BatchRecorder} that simply redirects the calls to the\n  * instruments.\n- *\n- * <p>TODO: Add an async queue processing to process batch records.\n  */\n final class BatchRecorderSdk implements BatchRecorder {\n   private final Labels labelSet;\n \n+  private volatile Map<Instrument, List<Number>> recordings = new HashMap<>();\n+  private volatile Map<Instrument, List<Number>> previousRecordings = new HashMap<>();\n+\n   BatchRecorderSdk(String... keyValuePairs) {\n     this.labelSet = Labels.of(keyValuePairs);\n   }\n \n   @Override\n   public BatchRecorder put(LongValueRecorder valueRecorder, long value) {\n-    valueRecorder.record(value, labelSet);\n+    recordings.computeIfAbsent(valueRecorder, instrument -> new ArrayList<>()).add(value);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc4ODQ1NQ=="}, "originalCommit": {"oid": "743ec823e5faae9f20f9deb1f2bbeb286ea3c281"}, "originalPosition": 32}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f84bda9aa993a49b7b2035dab8cbade3f729d0f4", "author": {"user": {"login": "jkwatson", "name": "John Watson"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/f84bda9aa993a49b7b2035dab8cbade3f729d0f4", "committedDate": "2020-11-05T18:56:34Z", "message": "rework the batch recorder to use a queue of recordings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24c90576b8c208f22e964660ae0a8fb0af6186cf", "author": {"user": {"login": "jkwatson", "name": "John Watson"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/24c90576b8c208f22e964660ae0a8fb0af6186cf", "committedDate": "2020-11-05T19:07:03Z", "message": "remove an allocation per recording by introducing some typed classes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzY2MTA3", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2007#pullrequestreview-526766107", "createdAt": "2020-11-10T00:41:17Z", "commit": {"oid": "24c90576b8c208f22e964660ae0a8fb0af6186cf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3941, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}