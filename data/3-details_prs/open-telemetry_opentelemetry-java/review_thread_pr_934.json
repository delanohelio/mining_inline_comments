{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwNDE3NDM5", "number": 934, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzo1MDozNlrODjLWrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzo1NTo1MVrODjLdeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjEyNzgyOnYy", "diffSide": "RIGHT", "path": "sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzo1MDozNlrOFu1zEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMDozMToxNVrOFu7H2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY2MDI0MA==", "bodyText": "this is duplicated code. can it be moved to a method?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/934#discussion_r384660240", "createdAt": "2020-02-26T17:50:36Z", "author": {"login": "jkwatson"}, "path": "sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java", "diffHunk": "@@ -102,73 +102,82 @@ public DisruptorEvent newInstance() {\n     this.blocking = blocking;\n   }\n \n-  void enqueue(ReadableSpan readableSpan, EventType eventType) {\n-    enqueue(readableSpan, eventType, null);\n-  }\n-\n-  // Enqueues an event on the {@link DisruptorEventQueue}.\n-  void enqueue(ReadableSpan readableSpan, EventType eventType, CountDownLatch flushLatch) {\n+  void enqueueStartEvent(ReadableSpan span) {\n     if (isShutdown) {\n       if (!loggedShutdownMessage.getAndSet(true)) {\n         logger.info(\"Attempted to enqueue entry after Disruptor shutdown.\");\n       }\n       return;\n     }\n+    enqueue(EventType.ON_START, span, null);\n+  }\n \n-    if (blocking) {\n-      ringBuffer.publishEvent(TRANSLATOR_THREE_ARG, eventType, readableSpan, flushLatch);\n-    } else {\n-      // TODO: Record metrics if element not added.\n-      ringBuffer.tryPublishEvent(TRANSLATOR_THREE_ARG, eventType, readableSpan, flushLatch);\n+  void enqueueEndEvent(ReadableSpan span) {\n+    if (isShutdown) {\n+      if (!loggedShutdownMessage.getAndSet(true)) {\n+        logger.info(\"Attempted to enqueue entry after Disruptor shutdown.\");\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a14489025ead6072043d16ecff0155edca74114f"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc0NzQ4MQ==", "bodyText": "Customized the messages to be more relevant.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/934#discussion_r384747481", "createdAt": "2020-02-26T20:31:15Z", "author": {"login": "bogdandrutu"}, "path": "sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java", "diffHunk": "@@ -102,73 +102,82 @@ public DisruptorEvent newInstance() {\n     this.blocking = blocking;\n   }\n \n-  void enqueue(ReadableSpan readableSpan, EventType eventType) {\n-    enqueue(readableSpan, eventType, null);\n-  }\n-\n-  // Enqueues an event on the {@link DisruptorEventQueue}.\n-  void enqueue(ReadableSpan readableSpan, EventType eventType, CountDownLatch flushLatch) {\n+  void enqueueStartEvent(ReadableSpan span) {\n     if (isShutdown) {\n       if (!loggedShutdownMessage.getAndSet(true)) {\n         logger.info(\"Attempted to enqueue entry after Disruptor shutdown.\");\n       }\n       return;\n     }\n+    enqueue(EventType.ON_START, span, null);\n+  }\n \n-    if (blocking) {\n-      ringBuffer.publishEvent(TRANSLATOR_THREE_ARG, eventType, readableSpan, flushLatch);\n-    } else {\n-      // TODO: Record metrics if element not added.\n-      ringBuffer.tryPublishEvent(TRANSLATOR_THREE_ARG, eventType, readableSpan, flushLatch);\n+  void enqueueEndEvent(ReadableSpan span) {\n+    if (isShutdown) {\n+      if (!loggedShutdownMessage.getAndSet(true)) {\n+        logger.info(\"Attempted to enqueue entry after Disruptor shutdown.\");\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY2MDI0MA=="}, "originalCommit": {"oid": "a14489025ead6072043d16ecff0155edca74114f"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjE0NTIxOnYy", "diffSide": "RIGHT", "path": "sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzo1NTo1MVrOFu1-Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwMDoyNDoxMFrOFvlyuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY2MzA5NQ==", "bodyText": "synchronizing on this is potentially dangerous, as you don't have control over who else might try to grab your monitor and keep this from ever executing.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/934#discussion_r384663095", "createdAt": "2020-02-26T17:55:51Z", "author": {"login": "jkwatson"}, "path": "sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java", "diffHunk": "@@ -102,73 +102,82 @@ public DisruptorEvent newInstance() {\n     this.blocking = blocking;\n   }\n \n-  void enqueue(ReadableSpan readableSpan, EventType eventType) {\n-    enqueue(readableSpan, eventType, null);\n-  }\n-\n-  // Enqueues an event on the {@link DisruptorEventQueue}.\n-  void enqueue(ReadableSpan readableSpan, EventType eventType, CountDownLatch flushLatch) {\n+  void enqueueStartEvent(ReadableSpan span) {\n     if (isShutdown) {\n       if (!loggedShutdownMessage.getAndSet(true)) {\n         logger.info(\"Attempted to enqueue entry after Disruptor shutdown.\");\n       }\n       return;\n     }\n+    enqueue(EventType.ON_START, span, null);\n+  }\n \n-    if (blocking) {\n-      ringBuffer.publishEvent(TRANSLATOR_THREE_ARG, eventType, readableSpan, flushLatch);\n-    } else {\n-      // TODO: Record metrics if element not added.\n-      ringBuffer.tryPublishEvent(TRANSLATOR_THREE_ARG, eventType, readableSpan, flushLatch);\n+  void enqueueEndEvent(ReadableSpan span) {\n+    if (isShutdown) {\n+      if (!loggedShutdownMessage.getAndSet(true)) {\n+        logger.info(\"Attempted to enqueue entry after Disruptor shutdown.\");\n+      }\n+      return;\n     }\n+    enqueue(EventType.ON_END, span, null);\n   }\n \n-  // Shuts down the underlying disruptor.\n+  // Shuts down the underlying disruptor. Ensures that when this method returns the disruptor is\n+  // shutdown.\n   void shutdown() {\n-    enqueueAndLock(EventType.ON_SHUTDOWN);\n+    synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a14489025ead6072043d16ecff0155edca74114f"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4NDc5NA==", "bodyText": "This is an internal class so I would not worry that much about that.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/934#discussion_r384784794", "createdAt": "2020-02-26T21:43:57Z", "author": {"login": "bogdandrutu"}, "path": "sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java", "diffHunk": "@@ -102,73 +102,82 @@ public DisruptorEvent newInstance() {\n     this.blocking = blocking;\n   }\n \n-  void enqueue(ReadableSpan readableSpan, EventType eventType) {\n-    enqueue(readableSpan, eventType, null);\n-  }\n-\n-  // Enqueues an event on the {@link DisruptorEventQueue}.\n-  void enqueue(ReadableSpan readableSpan, EventType eventType, CountDownLatch flushLatch) {\n+  void enqueueStartEvent(ReadableSpan span) {\n     if (isShutdown) {\n       if (!loggedShutdownMessage.getAndSet(true)) {\n         logger.info(\"Attempted to enqueue entry after Disruptor shutdown.\");\n       }\n       return;\n     }\n+    enqueue(EventType.ON_START, span, null);\n+  }\n \n-    if (blocking) {\n-      ringBuffer.publishEvent(TRANSLATOR_THREE_ARG, eventType, readableSpan, flushLatch);\n-    } else {\n-      // TODO: Record metrics if element not added.\n-      ringBuffer.tryPublishEvent(TRANSLATOR_THREE_ARG, eventType, readableSpan, flushLatch);\n+  void enqueueEndEvent(ReadableSpan span) {\n+    if (isShutdown) {\n+      if (!loggedShutdownMessage.getAndSet(true)) {\n+        logger.info(\"Attempted to enqueue entry after Disruptor shutdown.\");\n+      }\n+      return;\n     }\n+    enqueue(EventType.ON_END, span, null);\n   }\n \n-  // Shuts down the underlying disruptor.\n+  // Shuts down the underlying disruptor. Ensures that when this method returns the disruptor is\n+  // shutdown.\n   void shutdown() {\n-    enqueueAndLock(EventType.ON_SHUTDOWN);\n+    synchronized (this) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY2MzA5NQ=="}, "originalCommit": {"oid": "a14489025ead6072043d16ecff0155edca74114f"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQyMjAzNQ==", "bodyText": "@jkwatson are you ok with my comment?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/934#discussion_r385422035", "createdAt": "2020-02-27T23:04:41Z", "author": {"login": "bogdandrutu"}, "path": "sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java", "diffHunk": "@@ -102,73 +102,82 @@ public DisruptorEvent newInstance() {\n     this.blocking = blocking;\n   }\n \n-  void enqueue(ReadableSpan readableSpan, EventType eventType) {\n-    enqueue(readableSpan, eventType, null);\n-  }\n-\n-  // Enqueues an event on the {@link DisruptorEventQueue}.\n-  void enqueue(ReadableSpan readableSpan, EventType eventType, CountDownLatch flushLatch) {\n+  void enqueueStartEvent(ReadableSpan span) {\n     if (isShutdown) {\n       if (!loggedShutdownMessage.getAndSet(true)) {\n         logger.info(\"Attempted to enqueue entry after Disruptor shutdown.\");\n       }\n       return;\n     }\n+    enqueue(EventType.ON_START, span, null);\n+  }\n \n-    if (blocking) {\n-      ringBuffer.publishEvent(TRANSLATOR_THREE_ARG, eventType, readableSpan, flushLatch);\n-    } else {\n-      // TODO: Record metrics if element not added.\n-      ringBuffer.tryPublishEvent(TRANSLATOR_THREE_ARG, eventType, readableSpan, flushLatch);\n+  void enqueueEndEvent(ReadableSpan span) {\n+    if (isShutdown) {\n+      if (!loggedShutdownMessage.getAndSet(true)) {\n+        logger.info(\"Attempted to enqueue entry after Disruptor shutdown.\");\n+      }\n+      return;\n     }\n+    enqueue(EventType.ON_END, span, null);\n   }\n \n-  // Shuts down the underlying disruptor.\n+  // Shuts down the underlying disruptor. Ensures that when this method returns the disruptor is\n+  // shutdown.\n   void shutdown() {\n-    enqueueAndLock(EventType.ON_SHUTDOWN);\n+    synchronized (this) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY2MzA5NQ=="}, "originalCommit": {"oid": "a14489025ead6072043d16ecff0155edca74114f"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ0NjU4Nw==", "bodyText": "yeah, I'm not convinced that it's a pattern we want to perpetuate, but it's ok for now.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/934#discussion_r385446587", "createdAt": "2020-02-28T00:24:10Z", "author": {"login": "jkwatson"}, "path": "sdk_contrib/async_processor/src/main/java/io/opentelemetry/sdk/contrib/trace/export/DisruptorEventQueue.java", "diffHunk": "@@ -102,73 +102,82 @@ public DisruptorEvent newInstance() {\n     this.blocking = blocking;\n   }\n \n-  void enqueue(ReadableSpan readableSpan, EventType eventType) {\n-    enqueue(readableSpan, eventType, null);\n-  }\n-\n-  // Enqueues an event on the {@link DisruptorEventQueue}.\n-  void enqueue(ReadableSpan readableSpan, EventType eventType, CountDownLatch flushLatch) {\n+  void enqueueStartEvent(ReadableSpan span) {\n     if (isShutdown) {\n       if (!loggedShutdownMessage.getAndSet(true)) {\n         logger.info(\"Attempted to enqueue entry after Disruptor shutdown.\");\n       }\n       return;\n     }\n+    enqueue(EventType.ON_START, span, null);\n+  }\n \n-    if (blocking) {\n-      ringBuffer.publishEvent(TRANSLATOR_THREE_ARG, eventType, readableSpan, flushLatch);\n-    } else {\n-      // TODO: Record metrics if element not added.\n-      ringBuffer.tryPublishEvent(TRANSLATOR_THREE_ARG, eventType, readableSpan, flushLatch);\n+  void enqueueEndEvent(ReadableSpan span) {\n+    if (isShutdown) {\n+      if (!loggedShutdownMessage.getAndSet(true)) {\n+        logger.info(\"Attempted to enqueue entry after Disruptor shutdown.\");\n+      }\n+      return;\n     }\n+    enqueue(EventType.ON_END, span, null);\n   }\n \n-  // Shuts down the underlying disruptor.\n+  // Shuts down the underlying disruptor. Ensures that when this method returns the disruptor is\n+  // shutdown.\n   void shutdown() {\n-    enqueueAndLock(EventType.ON_SHUTDOWN);\n+    synchronized (this) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY2MzA5NQ=="}, "originalCommit": {"oid": "a14489025ead6072043d16ecff0155edca74114f"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 927, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}