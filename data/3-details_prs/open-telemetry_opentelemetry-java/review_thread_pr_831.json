{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyMjA1MDky", "number": 831, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwODo1Nzo1MVrODd88-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMzowNzozMVrODhQVgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNzMzOTQ1OnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractBoundInstrument.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwODo1Nzo1MVrOFm2Meg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxODoyMjo1MVrOFnF_Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI3ODEzOA==", "bodyText": "Nit: 2020", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r376278138", "createdAt": "2020-02-07T08:57:51Z", "author": {"login": "thisthat"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractBoundInstrument.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUzNjg1NA==", "bodyText": "This file was moved, and merged in a separate PR. So no problems with year here.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r376536854", "createdAt": "2020-02-07T18:22:51Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractBoundInstrument.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI3ODEzOA=="}, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNzU0MDUyOnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/Aggregator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMDowNjo1MFrOFm4IIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNjo0ODo0M1rOFntg6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwOTc5Mg==", "bodyText": "From your other PR #833, methods recordLong(long) and recordDouble(double) are introduced with the same Javadoc. Correct me if I am wrong: these two methods are for \"Measures\" metrics while the methods in the other PR are for \"Counters\". If so, I would update the doc to make this explicit", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r376309792", "createdAt": "2020-02-07T10:06:50Z", "author": {"login": "thisthat"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/Aggregator.java", "diffHunk": "@@ -30,31 +30,22 @@\n   void merge(T aggregator);\n \n   /**\n-   * LongAggregator represents the base class for all the available aggregations that work with long\n-   * values.\n+   * Checkpoints this aggregator by saving the previous value and resetting it. The old value is\n+   * available to \"merge\".\n    */\n-  @ThreadSafe\n-  interface LongAggregator<T extends LongAggregator<?>> extends Aggregator<T> {\n+  void checkpoint();\n \n-    /**\n-     * Updates the current aggregator with a newly recorded value.\n-     *\n-     * @param value the new {@code long} value to be added.\n-     */\n-    void update(long value);\n-  }\n+  /**\n+   * Updates the current aggregator with a newly recorded long value.\n+   *\n+   * @param value the new {@code long} value to be added.\n+   */\n+  void updateLong(long value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE4NDQ5MA==", "bodyText": "Done.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r377184490", "createdAt": "2020-02-10T16:48:43Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/Aggregator.java", "diffHunk": "@@ -30,31 +30,22 @@\n   void merge(T aggregator);\n \n   /**\n-   * LongAggregator represents the base class for all the available aggregations that work with long\n-   * values.\n+   * Checkpoints this aggregator by saving the previous value and resetting it. The old value is\n+   * available to \"merge\".\n    */\n-  @ThreadSafe\n-  interface LongAggregator<T extends LongAggregator<?>> extends Aggregator<T> {\n+  void checkpoint();\n \n-    /**\n-     * Updates the current aggregator with a newly recorded value.\n-     *\n-     * @param value the new {@code long} value to be added.\n-     */\n-    void update(long value);\n-  }\n+  /**\n+   * Updates the current aggregator with a newly recorded long value.\n+   *\n+   * @param value the new {@code long} value to be added.\n+   */\n+  void updateLong(long value);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwOTc5Mg=="}, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNzU5MTc0OnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/BoundRegistry.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxMDoyNDowN1rOFm4nDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoxNToyNVrOFn0FXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMxNzcwOQ==", "bodyText": "I am not a huge fan of while(true) loops. I would use a defensive programming design, capping the max exec time of the while. Something like:\ndo {\n...\n} while(timer > 0)\nI am not sold on this, though. What is your opinion?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r376317709", "createdAt": "2020-02-07T10:24:07Z", "author": {"login": "thisthat"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/BoundRegistry.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+abstract class BoundRegistry<B extends AbstractBoundInstrument> {\n+  private final ConcurrentHashMap<LabelSet, B> bounds;\n+  private final ReentrantLock collectLock;\n+\n+  BoundRegistry() {\n+    bounds = new ConcurrentHashMap<>();\n+    collectLock = new ReentrantLock();\n+  }\n+\n+  B acquire(LabelSet labelSet) {\n+    B bound = bounds.get(labelSet);\n+    if (bound != null && bound.ref()) {\n+      // At this moment it is guaranteed that the Bound is in the map and will not be removed.\n+      return bound;\n+    }\n+\n+    // Missing entry or no longer mapped, try to add a new entry.\n+    bound = newBound(labelSet);\n+    while (true) {\n+      B oldBound = bounds.putIfAbsent(labelSet, bound);\n+      if (oldBound != null) {\n+        if (oldBound.ref()) {\n+          // At this moment it is guaranteed that the Bound is in the map and will not be removed.\n+          return oldBound;\n+        }\n+        // Try to remove the oldBound. This will race with the collect method, but only one will\n+        // succeed.\n+        bounds.remove(labelSet, oldBound);\n+        continue;\n+      }\n+      return bound;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4ODY2MA==", "bodyText": "I am not worried, as you can see we try to remove the value on the critical path if an unmapped value is still in the map, so the while loop is not going to spin more than twice.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r377288660", "createdAt": "2020-02-10T20:07:52Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/BoundRegistry.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+abstract class BoundRegistry<B extends AbstractBoundInstrument> {\n+  private final ConcurrentHashMap<LabelSet, B> bounds;\n+  private final ReentrantLock collectLock;\n+\n+  BoundRegistry() {\n+    bounds = new ConcurrentHashMap<>();\n+    collectLock = new ReentrantLock();\n+  }\n+\n+  B acquire(LabelSet labelSet) {\n+    B bound = bounds.get(labelSet);\n+    if (bound != null && bound.ref()) {\n+      // At this moment it is guaranteed that the Bound is in the map and will not be removed.\n+      return bound;\n+    }\n+\n+    // Missing entry or no longer mapped, try to add a new entry.\n+    bound = newBound(labelSet);\n+    while (true) {\n+      B oldBound = bounds.putIfAbsent(labelSet, bound);\n+      if (oldBound != null) {\n+        if (oldBound.ref()) {\n+          // At this moment it is guaranteed that the Bound is in the map and will not be removed.\n+          return oldBound;\n+        }\n+        // Try to remove the oldBound. This will race with the collect method, but only one will\n+        // succeed.\n+        bounds.remove(labelSet, oldBound);\n+        continue;\n+      }\n+      return bound;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMxNzcwOQ=="}, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5MjEyNw==", "bodyText": "I'd definitely like to avoid putting in a timer as well. I'm ok with the spin loop. Is there a way to write tests the various scenarios here? Maybe a small stress test would help to alleviate concerns.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r377292127", "createdAt": "2020-02-10T20:15:25Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/BoundRegistry.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+abstract class BoundRegistry<B extends AbstractBoundInstrument> {\n+  private final ConcurrentHashMap<LabelSet, B> bounds;\n+  private final ReentrantLock collectLock;\n+\n+  BoundRegistry() {\n+    bounds = new ConcurrentHashMap<>();\n+    collectLock = new ReentrantLock();\n+  }\n+\n+  B acquire(LabelSet labelSet) {\n+    B bound = bounds.get(labelSet);\n+    if (bound != null && bound.ref()) {\n+      // At this moment it is guaranteed that the Bound is in the map and will not be removed.\n+      return bound;\n+    }\n+\n+    // Missing entry or no longer mapped, try to add a new entry.\n+    bound = newBound(labelSet);\n+    while (true) {\n+      B oldBound = bounds.putIfAbsent(labelSet, bound);\n+      if (oldBound != null) {\n+        if (oldBound.ref()) {\n+          // At this moment it is guaranteed that the Bound is in the map and will not be removed.\n+          return oldBound;\n+        }\n+        // Try to remove the oldBound. This will race with the collect method, but only one will\n+        // succeed.\n+        bounds.remove(labelSet, oldBound);\n+        continue;\n+      }\n+      return bound;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMxNzcwOQ=="}, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyODQ1ODkwOnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractBoundInstrument.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxNTozMDoyMFrOFnA1kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwMToxMjoyMlrOFpEDTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1MjQ5OQ==", "bodyText": "2?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r376452499", "createdAt": "2020-02-07T15:30:20Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractBoundInstrument.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+abstract class AbstractBoundInstrument {\n+  private final LabelSet labels;\n+  // Atomically counts the number of references (usages) while also keeping a state of\n+  // mapped/unmapped into a registry map.\n+  private final AtomicLong refCountMapped;\n+  private final Aggregator<?> aggregator;\n+\n+  AbstractBoundInstrument(LabelSet labels, Aggregator<?> aggregator) {\n+    this.labels = labels;\n+    this.aggregator = aggregator;\n+    refCountMapped = new AtomicLong(0);\n+  }\n+\n+  /**\n+   * Returns {@code true} if the entry is still mapped and increases the reference usages, if\n+   * unmapped returns {@code false}.\n+   *\n+   * @return {@code true} if successful.\n+   */\n+  boolean ref() {\n+    return (refCountMapped.addAndGet(2L) & 1L) == 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU0NzY4OQ==", "bodyText": "I kinda see what's going on here, but cleverness like this needs some very clear documentation in the code.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r376547689", "createdAt": "2020-02-07T18:46:25Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractBoundInstrument.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+abstract class AbstractBoundInstrument {\n+  private final LabelSet labels;\n+  // Atomically counts the number of references (usages) while also keeping a state of\n+  // mapped/unmapped into a registry map.\n+  private final AtomicLong refCountMapped;\n+  private final Aggregator<?> aggregator;\n+\n+  AbstractBoundInstrument(LabelSet labels, Aggregator<?> aggregator) {\n+    this.labels = labels;\n+    this.aggregator = aggregator;\n+    refCountMapped = new AtomicLong(0);\n+  }\n+\n+  /**\n+   * Returns {@code true} if the entry is still mapped and increases the reference usages, if\n+   * unmapped returns {@code false}.\n+   *\n+   * @return {@code true} if successful.\n+   */\n+  boolean ref() {\n+    return (refCountMapped.addAndGet(2L) & 1L) == 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1MjQ5OQ=="}, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU0ODUyNA==", "bodyText": "will do, sorry this is still work in progress as the PR description says.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r376548524", "createdAt": "2020-02-07T18:48:06Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractBoundInstrument.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+abstract class AbstractBoundInstrument {\n+  private final LabelSet labels;\n+  // Atomically counts the number of references (usages) while also keeping a state of\n+  // mapped/unmapped into a registry map.\n+  private final AtomicLong refCountMapped;\n+  private final Aggregator<?> aggregator;\n+\n+  AbstractBoundInstrument(LabelSet labels, Aggregator<?> aggregator) {\n+    this.labels = labels;\n+    this.aggregator = aggregator;\n+    refCountMapped = new AtomicLong(0);\n+  }\n+\n+  /**\n+   * Returns {@code true} if the entry is still mapped and increases the reference usages, if\n+   * unmapped returns {@code false}.\n+   *\n+   * @return {@code true} if successful.\n+   */\n+  boolean ref() {\n+    return (refCountMapped.addAndGet(2L) & 1L) == 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1MjQ5OQ=="}, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU0ODkzOA==", "bodyText": "yep! no worries, just trying to capture my thoughts so we don't lose them.  :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r376548938", "createdAt": "2020-02-07T18:49:00Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractBoundInstrument.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+abstract class AbstractBoundInstrument {\n+  private final LabelSet labels;\n+  // Atomically counts the number of references (usages) while also keeping a state of\n+  // mapped/unmapped into a registry map.\n+  private final AtomicLong refCountMapped;\n+  private final Aggregator<?> aggregator;\n+\n+  AbstractBoundInstrument(LabelSet labels, Aggregator<?> aggregator) {\n+    this.labels = labels;\n+    this.aggregator = aggregator;\n+    refCountMapped = new AtomicLong(0);\n+  }\n+\n+  /**\n+   * Returns {@code true} if the entry is still mapped and increases the reference usages, if\n+   * unmapped returns {@code false}.\n+   *\n+   * @return {@code true} if successful.\n+   */\n+  boolean ref() {\n+    return (refCountMapped.addAndGet(2L) & 1L) == 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1MjQ5OQ=="}, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwMjMxOA==", "bodyText": "done.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r378602318", "createdAt": "2020-02-13T01:12:22Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractBoundInstrument.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+abstract class AbstractBoundInstrument {\n+  private final LabelSet labels;\n+  // Atomically counts the number of references (usages) while also keeping a state of\n+  // mapped/unmapped into a registry map.\n+  private final AtomicLong refCountMapped;\n+  private final Aggregator<?> aggregator;\n+\n+  AbstractBoundInstrument(LabelSet labels, Aggregator<?> aggregator) {\n+    this.labels = labels;\n+    this.aggregator = aggregator;\n+    refCountMapped = new AtomicLong(0);\n+  }\n+\n+  /**\n+   * Returns {@code true} if the entry is still mapped and increases the reference usages, if\n+   * unmapped returns {@code false}.\n+   *\n+   * @return {@code true} if successful.\n+   */\n+  boolean ref() {\n+    return (refCountMapped.addAndGet(2L) & 1L) == 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1MjQ5OQ=="}, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyODQ2MDE2OnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractBoundInstrument.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxNTozMDo0MlrOFnA2aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMzowOToyN1rOFr7CwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1MjcxMw==", "bodyText": "I would guess that an AtomicInteger would be plenty for this.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r376452713", "createdAt": "2020-02-07T15:30:42Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractBoundInstrument.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+abstract class AbstractBoundInstrument {\n+  private final LabelSet labels;\n+  // Atomically counts the number of references (usages) while also keeping a state of\n+  // mapped/unmapped into a registry map.\n+  private final AtomicLong refCountMapped;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYzMjk2OA==", "bodyText": "Are you worried about performance/memory?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r376632968", "createdAt": "2020-02-07T22:15:36Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractBoundInstrument.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+abstract class AbstractBoundInstrument {\n+  private final LabelSet labels;\n+  // Atomically counts the number of references (usages) while also keeping a state of\n+  // mapped/unmapped into a registry map.\n+  private final AtomicLong refCountMapped;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1MjcxMw=="}, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYzNjI0Nw==", "bodyText": "A tiny bit, yes. atomic integer updates are much easier, since they don't require multiple words on a 32 bit JVM. I don't know how much we care about that, but it's something to consider. And, I sure hope we don't have more than MAX_INT instruments in a single process.  :)\nIt's a very small thing though; I wouldn't hold up the PR for it.  ;)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r376636247", "createdAt": "2020-02-07T22:24:43Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractBoundInstrument.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+abstract class AbstractBoundInstrument {\n+  private final LabelSet labels;\n+  // Atomically counts the number of references (usages) while also keeping a state of\n+  // mapped/unmapped into a registry map.\n+  private final AtomicLong refCountMapped;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1MjcxMw=="}, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5MzcwMA==", "bodyText": "Please file an issue if this is still a concern :) That change is already merged.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r381593700", "createdAt": "2020-02-19T22:51:56Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractBoundInstrument.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+abstract class AbstractBoundInstrument {\n+  private final LabelSet labels;\n+  // Atomically counts the number of references (usages) while also keeping a state of\n+  // mapped/unmapped into a registry map.\n+  private final AtomicLong refCountMapped;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1MjcxMw=="}, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYwMDQ0OA==", "bodyText": "I'm not overly concerned. Just thought I'd mention it.  :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r381600448", "createdAt": "2020-02-19T23:09:27Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractBoundInstrument.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+abstract class AbstractBoundInstrument {\n+  private final LabelSet labels;\n+  // Atomically counts the number of references (usages) while also keeping a state of\n+  // mapped/unmapped into a registry map.\n+  private final AtomicLong refCountMapped;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1MjcxMw=="}, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyODQ2ODk1OnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/BoundRegistry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxNTozMzowN1rOFnA7zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNjo1MDoyN1rOFntluA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1NDA5NA==", "bodyText": "rather than using ref counting, can we instead use a map with weak references for values? This ref counting seems like an overly baroque way to deal with this issue, and adds a significant amount of complexity to this code.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r376454094", "createdAt": "2020-02-07T15:33:07Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/BoundRegistry.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+abstract class BoundRegistry<B extends AbstractBoundInstrument> {\n+  private final ConcurrentHashMap<LabelSet, B> bounds;\n+  private final ReentrantLock collectLock;\n+\n+  BoundRegistry() {\n+    bounds = new ConcurrentHashMap<>();\n+    collectLock = new ReentrantLock();\n+  }\n+\n+  B acquire(LabelSet labelSet) {\n+    B bound = bounds.get(labelSet);\n+    if (bound != null && bound.ref()) {\n+      // At this moment it is guaranteed that the Bound is in the map and will not be removed.\n+      return bound;\n+    }\n+\n+    // Missing entry or no longer mapped, try to add a new entry.\n+    bound = newBound(labelSet);\n+    while (true) {\n+      B oldBound = bounds.putIfAbsent(labelSet, bound);\n+      if (oldBound != null) {\n+        if (oldBound.ref()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE4NTcyMA==", "bodyText": "I hope now it is clearer why I used this, we have threads on critical path adding bounds, then the collector needs to collect them then remove them from the bounds, using weak references may cause uncollected data.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r377185720", "createdAt": "2020-02-10T16:50:27Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/BoundRegistry.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+abstract class BoundRegistry<B extends AbstractBoundInstrument> {\n+  private final ConcurrentHashMap<LabelSet, B> bounds;\n+  private final ReentrantLock collectLock;\n+\n+  BoundRegistry() {\n+    bounds = new ConcurrentHashMap<>();\n+    collectLock = new ReentrantLock();\n+  }\n+\n+  B acquire(LabelSet labelSet) {\n+    B bound = bounds.get(labelSet);\n+    if (bound != null && bound.ref()) {\n+      // At this moment it is guaranteed that the Bound is in the map and will not be removed.\n+      return bound;\n+    }\n+\n+    // Missing entry or no longer mapped, try to add a new entry.\n+    bound = newBound(labelSet);\n+    while (true) {\n+      B oldBound = bounds.putIfAbsent(labelSet, bound);\n+      if (oldBound != null) {\n+        if (oldBound.ref()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1NDA5NA=="}, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyODQ3Mzg2OnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/BoundRegistry.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxNTozNDoxOFrOFnA-sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxODozNzo0OFrOFnGZzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1NDgzNA==", "bodyText": "I really think we need to find a lockless way of handling this, as this will be a major source of contention in high-throughput situations.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r376454834", "createdAt": "2020-02-07T15:34:18Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/BoundRegistry.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+abstract class BoundRegistry<B extends AbstractBoundInstrument> {\n+  private final ConcurrentHashMap<LabelSet, B> bounds;\n+  private final ReentrantLock collectLock;\n+\n+  BoundRegistry() {\n+    bounds = new ConcurrentHashMap<>();\n+    collectLock = new ReentrantLock();\n+  }\n+\n+  B acquire(LabelSet labelSet) {\n+    B bound = bounds.get(labelSet);\n+    if (bound != null && bound.ref()) {\n+      // At this moment it is guaranteed that the Bound is in the map and will not be removed.\n+      return bound;\n+    }\n+\n+    // Missing entry or no longer mapped, try to add a new entry.\n+    bound = newBound(labelSet);\n+    while (true) {\n+      B oldBound = bounds.putIfAbsent(labelSet, bound);\n+      if (oldBound != null) {\n+        if (oldBound.ref()) {\n+          // At this moment it is guaranteed that the Bound is in the map and will not be removed.\n+          return oldBound;\n+        }\n+        // Try to remove the oldBound. This will race with the collect method, but only one will\n+        // succeed.\n+        bounds.remove(labelSet, oldBound);\n+        continue;\n+      }\n+      return bound;\n+    }\n+  }\n+\n+  void release(B bound) {\n+    bound.unref();\n+  }\n+\n+  /**\n+   * Collects records from all the entries (labelSet, Bound) that changed since the last collect()\n+   * call.\n+   *\n+   * <p>It is possible that some entries\n+   */\n+  void collect(RecordProcessor recordProcessor) {\n+    collectLock.lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ3MDYyNA==", "bodyText": "Collect is called async, the only reason to have the lock is to ensure one collect call at any moment.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r376470624", "createdAt": "2020-02-07T16:02:30Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/BoundRegistry.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+abstract class BoundRegistry<B extends AbstractBoundInstrument> {\n+  private final ConcurrentHashMap<LabelSet, B> bounds;\n+  private final ReentrantLock collectLock;\n+\n+  BoundRegistry() {\n+    bounds = new ConcurrentHashMap<>();\n+    collectLock = new ReentrantLock();\n+  }\n+\n+  B acquire(LabelSet labelSet) {\n+    B bound = bounds.get(labelSet);\n+    if (bound != null && bound.ref()) {\n+      // At this moment it is guaranteed that the Bound is in the map and will not be removed.\n+      return bound;\n+    }\n+\n+    // Missing entry or no longer mapped, try to add a new entry.\n+    bound = newBound(labelSet);\n+    while (true) {\n+      B oldBound = bounds.putIfAbsent(labelSet, bound);\n+      if (oldBound != null) {\n+        if (oldBound.ref()) {\n+          // At this moment it is guaranteed that the Bound is in the map and will not be removed.\n+          return oldBound;\n+        }\n+        // Try to remove the oldBound. This will race with the collect method, but only one will\n+        // succeed.\n+        bounds.remove(labelSet, oldBound);\n+        continue;\n+      }\n+      return bound;\n+    }\n+  }\n+\n+  void release(B bound) {\n+    bound.unref();\n+  }\n+\n+  /**\n+   * Collects records from all the entries (labelSet, Bound) that changed since the last collect()\n+   * call.\n+   *\n+   * <p>It is possible that some entries\n+   */\n+  void collect(RecordProcessor recordProcessor) {\n+    collectLock.lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1NDgzNA=="}, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU0MzY5NQ==", "bodyText": "fair enough.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r376543695", "createdAt": "2020-02-07T18:37:48Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/BoundRegistry.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+abstract class BoundRegistry<B extends AbstractBoundInstrument> {\n+  private final ConcurrentHashMap<LabelSet, B> bounds;\n+  private final ReentrantLock collectLock;\n+\n+  BoundRegistry() {\n+    bounds = new ConcurrentHashMap<>();\n+    collectLock = new ReentrantLock();\n+  }\n+\n+  B acquire(LabelSet labelSet) {\n+    B bound = bounds.get(labelSet);\n+    if (bound != null && bound.ref()) {\n+      // At this moment it is guaranteed that the Bound is in the map and will not be removed.\n+      return bound;\n+    }\n+\n+    // Missing entry or no longer mapped, try to add a new entry.\n+    bound = newBound(labelSet);\n+    while (true) {\n+      B oldBound = bounds.putIfAbsent(labelSet, bound);\n+      if (oldBound != null) {\n+        if (oldBound.ref()) {\n+          // At this moment it is guaranteed that the Bound is in the map and will not be removed.\n+          return oldBound;\n+        }\n+        // Try to remove the oldBound. This will race with the collect method, but only one will\n+        // succeed.\n+        bounds.remove(labelSet, oldBound);\n+        continue;\n+      }\n+      return bound;\n+    }\n+  }\n+\n+  void release(B bound) {\n+    bound.unref();\n+  }\n+\n+  /**\n+   * Collects records from all the entries (labelSet, Bound) that changed since the last collect()\n+   * call.\n+   *\n+   * <p>It is possible that some entries\n+   */\n+  void collect(RecordProcessor recordProcessor) {\n+    collectLock.lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1NDgzNA=="}, "originalCommit": {"oid": "ac039e05188056919bcd5de466d6159c3f9253ba"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTAzNzIyOnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/BoundRegistry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxODo0MToyM1rOFnGgSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMjoxMTowM1rOFnLwNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU0NTM1NA==", "bodyText": "Call this \"boundLabels\"", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r376545354", "createdAt": "2020-02-07T18:41:23Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/BoundRegistry.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+abstract class BoundRegistry<B extends AbstractBoundInstrument> {\n+  private final ConcurrentHashMap<LabelSet, B> bounds;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68c76f6dcb0e314064f86f7f31be308495e72b50"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYzMTM0OQ==", "bodyText": "done.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r376631349", "createdAt": "2020-02-07T22:11:03Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/BoundRegistry.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+abstract class BoundRegistry<B extends AbstractBoundInstrument> {\n+  private final ConcurrentHashMap<LabelSet, B> bounds;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU0NTM1NA=="}, "originalCommit": {"oid": "68c76f6dcb0e314064f86f7f31be308495e72b50"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTA0NDE3OnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractBoundInstrument.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxODo0Mzo0OFrOFnGkmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMjoxNTo0MlrOFnL2qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU0NjQ1Ng==", "bodyText": "how about \"bind\" and \"release\" as names, rather than ref/unref? Cryptically short method names make me sad.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r376546456", "createdAt": "2020-02-07T18:43:48Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractBoundInstrument.java", "diffHunk": "@@ -16,32 +16,57 @@\n \n package io.opentelemetry.sdk.metrics;\n \n-import io.opentelemetry.metrics.LabelSet;\n+import java.util.concurrent.atomic.AtomicLong;\n \n-class AbstractBoundInstrument {\n-  private final LabelSet labels;\n+abstract class AbstractBoundInstrument {\n+  // Atomically counts the number of references (usages) while also keeping a state of\n+  // mapped/unmapped into a registry map.\n+  private final AtomicLong refCountMapped;\n+  private final Aggregator<?> aggregator;\n \n-  AbstractBoundInstrument(LabelSet labels) {\n-    this.labels = labels;\n-    // todo: associate with an aggregator/accumulator\n+  AbstractBoundInstrument(Aggregator<?> aggregator) {\n+    this.aggregator = aggregator;\n+    this.refCountMapped = new AtomicLong(0);\n   }\n \n-  @Override\n-  public boolean equals(Object o) {\n-    if (this == o) {\n-      return true;\n-    }\n-    if (!(o instanceof AbstractBoundInstrument)) {\n+  /**\n+   * Returns {@code true} if the entry is still mapped and increases the reference usages, if\n+   * unmapped returns {@code false}.\n+   *\n+   * @return {@code true} if successful.\n+   */\n+  boolean ref() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68c76f6dcb0e314064f86f7f31be308495e72b50"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU0OTgzNA==", "bodyText": "you Java person :))", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r376549834", "createdAt": "2020-02-07T18:50:58Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractBoundInstrument.java", "diffHunk": "@@ -16,32 +16,57 @@\n \n package io.opentelemetry.sdk.metrics;\n \n-import io.opentelemetry.metrics.LabelSet;\n+import java.util.concurrent.atomic.AtomicLong;\n \n-class AbstractBoundInstrument {\n-  private final LabelSet labels;\n+abstract class AbstractBoundInstrument {\n+  // Atomically counts the number of references (usages) while also keeping a state of\n+  // mapped/unmapped into a registry map.\n+  private final AtomicLong refCountMapped;\n+  private final Aggregator<?> aggregator;\n \n-  AbstractBoundInstrument(LabelSet labels) {\n-    this.labels = labels;\n-    // todo: associate with an aggregator/accumulator\n+  AbstractBoundInstrument(Aggregator<?> aggregator) {\n+    this.aggregator = aggregator;\n+    this.refCountMapped = new AtomicLong(0);\n   }\n \n-  @Override\n-  public boolean equals(Object o) {\n-    if (this == o) {\n-      return true;\n-    }\n-    if (!(o instanceof AbstractBoundInstrument)) {\n+  /**\n+   * Returns {@code true} if the entry is still mapped and increases the reference usages, if\n+   * unmapped returns {@code false}.\n+   *\n+   * @return {@code true} if successful.\n+   */\n+  boolean ref() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU0NjQ1Ng=="}, "originalCommit": {"oid": "68c76f6dcb0e314064f86f7f31be308495e72b50"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYzMTM4OA==", "bodyText": "done.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r376631388", "createdAt": "2020-02-07T22:11:10Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractBoundInstrument.java", "diffHunk": "@@ -16,32 +16,57 @@\n \n package io.opentelemetry.sdk.metrics;\n \n-import io.opentelemetry.metrics.LabelSet;\n+import java.util.concurrent.atomic.AtomicLong;\n \n-class AbstractBoundInstrument {\n-  private final LabelSet labels;\n+abstract class AbstractBoundInstrument {\n+  // Atomically counts the number of references (usages) while also keeping a state of\n+  // mapped/unmapped into a registry map.\n+  private final AtomicLong refCountMapped;\n+  private final Aggregator<?> aggregator;\n \n-  AbstractBoundInstrument(LabelSet labels) {\n-    this.labels = labels;\n-    // todo: associate with an aggregator/accumulator\n+  AbstractBoundInstrument(Aggregator<?> aggregator) {\n+    this.aggregator = aggregator;\n+    this.refCountMapped = new AtomicLong(0);\n   }\n \n-  @Override\n-  public boolean equals(Object o) {\n-    if (this == o) {\n-      return true;\n-    }\n-    if (!(o instanceof AbstractBoundInstrument)) {\n+  /**\n+   * Returns {@code true} if the entry is still mapped and increases the reference usages, if\n+   * unmapped returns {@code false}.\n+   *\n+   * @return {@code true} if successful.\n+   */\n+  boolean ref() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU0NjQ1Ng=="}, "originalCommit": {"oid": "68c76f6dcb0e314064f86f7f31be308495e72b50"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYzMzAwMw==", "bodyText": "done.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r376633003", "createdAt": "2020-02-07T22:15:42Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractBoundInstrument.java", "diffHunk": "@@ -16,32 +16,57 @@\n \n package io.opentelemetry.sdk.metrics;\n \n-import io.opentelemetry.metrics.LabelSet;\n+import java.util.concurrent.atomic.AtomicLong;\n \n-class AbstractBoundInstrument {\n-  private final LabelSet labels;\n+abstract class AbstractBoundInstrument {\n+  // Atomically counts the number of references (usages) while also keeping a state of\n+  // mapped/unmapped into a registry map.\n+  private final AtomicLong refCountMapped;\n+  private final Aggregator<?> aggregator;\n \n-  AbstractBoundInstrument(LabelSet labels) {\n-    this.labels = labels;\n-    // todo: associate with an aggregator/accumulator\n+  AbstractBoundInstrument(Aggregator<?> aggregator) {\n+    this.aggregator = aggregator;\n+    this.refCountMapped = new AtomicLong(0);\n   }\n \n-  @Override\n-  public boolean equals(Object o) {\n-    if (this == o) {\n-      return true;\n-    }\n-    if (!(o instanceof AbstractBoundInstrument)) {\n+  /**\n+   * Returns {@code true} if the entry is still mapped and increases the reference usages, if\n+   * unmapped returns {@code false}.\n+   *\n+   * @return {@code true} if successful.\n+   */\n+  boolean ref() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU0NjQ1Ng=="}, "originalCommit": {"oid": "68c76f6dcb0e314064f86f7f31be308495e72b50"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDA0NTA5OnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractInstrumentWithBinding.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoxNzowMFrOFn0IhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwMToxMDozM1rOFpEBgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5MjkzMw==", "bodyText": "rename variable to binding", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r377292933", "createdAt": "2020-02-10T20:17:00Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractInstrumentWithBinding.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+abstract class AbstractInstrumentWithBinding<B extends AbstractBoundInstrument>\n+    extends AbstractInstrument {\n+  private final ConcurrentHashMap<LabelSet, B> boundLabels;\n+  private final ReentrantLock collectLock;\n+\n+  AbstractInstrumentWithBinding(\n+      String name,\n+      String description,\n+      String unit,\n+      Map<String, String> constantLabels,\n+      List<String> labelKeys) {\n+    super(name, description, unit, constantLabels, labelKeys);\n+    boundLabels = new ConcurrentHashMap<>();\n+    collectLock = new ReentrantLock();\n+  }\n+\n+  // Cannot make this \"bind\" because of a Java problem if we make this class also implement the\n+  // InstrumentWithBinding then the subclass will fail to compile because of different \"bind\"\n+  // signature. This is a good trade-off.\n+  final B bindInternal(LabelSet labelSet) {\n+    B bound = boundLabels.get(labelSet);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da8de26bcee520ea080acbf9ba53b55c28ed979a"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwMTg1Ng==", "bodyText": "done.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r378601856", "createdAt": "2020-02-13T01:10:33Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractInstrumentWithBinding.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+abstract class AbstractInstrumentWithBinding<B extends AbstractBoundInstrument>\n+    extends AbstractInstrument {\n+  private final ConcurrentHashMap<LabelSet, B> boundLabels;\n+  private final ReentrantLock collectLock;\n+\n+  AbstractInstrumentWithBinding(\n+      String name,\n+      String description,\n+      String unit,\n+      Map<String, String> constantLabels,\n+      List<String> labelKeys) {\n+    super(name, description, unit, constantLabels, labelKeys);\n+    boundLabels = new ConcurrentHashMap<>();\n+    collectLock = new ReentrantLock();\n+  }\n+\n+  // Cannot make this \"bind\" because of a Java problem if we make this class also implement the\n+  // InstrumentWithBinding then the subclass will fail to compile because of different \"bind\"\n+  // signature. This is a good trade-off.\n+  final B bindInternal(LabelSet labelSet) {\n+    B bound = boundLabels.get(labelSet);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5MjkzMw=="}, "originalCommit": {"oid": "da8de26bcee520ea080acbf9ba53b55c28ed979a"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDA0NjQwOnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractInstrumentWithBinding.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMDoxNzoyNVrOFn0JTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwMToxMjowOVrOFpEDJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5MzEzNA==", "bodyText": "rename to newBinding()", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r377293134", "createdAt": "2020-02-10T20:17:25Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractInstrumentWithBinding.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+abstract class AbstractInstrumentWithBinding<B extends AbstractBoundInstrument>\n+    extends AbstractInstrument {\n+  private final ConcurrentHashMap<LabelSet, B> boundLabels;\n+  private final ReentrantLock collectLock;\n+\n+  AbstractInstrumentWithBinding(\n+      String name,\n+      String description,\n+      String unit,\n+      Map<String, String> constantLabels,\n+      List<String> labelKeys) {\n+    super(name, description, unit, constantLabels, labelKeys);\n+    boundLabels = new ConcurrentHashMap<>();\n+    collectLock = new ReentrantLock();\n+  }\n+\n+  // Cannot make this \"bind\" because of a Java problem if we make this class also implement the\n+  // InstrumentWithBinding then the subclass will fail to compile because of different \"bind\"\n+  // signature. This is a good trade-off.\n+  final B bindInternal(LabelSet labelSet) {\n+    B bound = boundLabels.get(labelSet);\n+    if (bound != null && bound.bind()) {\n+      // At this moment it is guaranteed that the Bound is in the map and will not be removed.\n+      return bound;\n+    }\n+\n+    // Missing entry or no longer mapped, try to add a new entry.\n+    bound = newBound();\n+    while (true) {\n+      B oldBound = boundLabels.putIfAbsent(labelSet, bound);\n+      if (oldBound != null) {\n+        if (oldBound.bind()) {\n+          // At this moment it is guaranteed that the Bound is in the map and will not be removed.\n+          return oldBound;\n+        }\n+        // Try to remove the oldBound. This will race with the collect method, but only one will\n+        // succeed.\n+        boundLabels.remove(labelSet, oldBound);\n+        continue;\n+      }\n+      return bound;\n+    }\n+  }\n+\n+  /**\n+   * Collects records from all the entries (labelSet, Bound) that changed since the last collect()\n+   * call.\n+   */\n+  @Override\n+  final void collect(RecordProcessor recordProcessor) {\n+    collectLock.lock();\n+    try {\n+      for (Map.Entry<LabelSet, B> entry : boundLabels.entrySet()) {\n+        if (entry.getValue().tryUnmap()) {\n+          // If able to unmap then remove the record from the current Map. This can race with the\n+          // acquire but because we requested a specific value only one will succeed.\n+          boundLabels.remove(entry.getKey(), entry.getValue());\n+        }\n+\n+        entry.getValue().checkpoint();\n+      }\n+    } finally {\n+      collectLock.unlock();\n+    }\n+  }\n+\n+  abstract B newBound();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da8de26bcee520ea080acbf9ba53b55c28ed979a"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwMjI3Nw==", "bodyText": "done.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r378602277", "createdAt": "2020-02-13T01:12:09Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AbstractInstrumentWithBinding.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+abstract class AbstractInstrumentWithBinding<B extends AbstractBoundInstrument>\n+    extends AbstractInstrument {\n+  private final ConcurrentHashMap<LabelSet, B> boundLabels;\n+  private final ReentrantLock collectLock;\n+\n+  AbstractInstrumentWithBinding(\n+      String name,\n+      String description,\n+      String unit,\n+      Map<String, String> constantLabels,\n+      List<String> labelKeys) {\n+    super(name, description, unit, constantLabels, labelKeys);\n+    boundLabels = new ConcurrentHashMap<>();\n+    collectLock = new ReentrantLock();\n+  }\n+\n+  // Cannot make this \"bind\" because of a Java problem if we make this class also implement the\n+  // InstrumentWithBinding then the subclass will fail to compile because of different \"bind\"\n+  // signature. This is a good trade-off.\n+  final B bindInternal(LabelSet labelSet) {\n+    B bound = boundLabels.get(labelSet);\n+    if (bound != null && bound.bind()) {\n+      // At this moment it is guaranteed that the Bound is in the map and will not be removed.\n+      return bound;\n+    }\n+\n+    // Missing entry or no longer mapped, try to add a new entry.\n+    bound = newBound();\n+    while (true) {\n+      B oldBound = boundLabels.putIfAbsent(labelSet, bound);\n+      if (oldBound != null) {\n+        if (oldBound.bind()) {\n+          // At this moment it is guaranteed that the Bound is in the map and will not be removed.\n+          return oldBound;\n+        }\n+        // Try to remove the oldBound. This will race with the collect method, but only one will\n+        // succeed.\n+        boundLabels.remove(labelSet, oldBound);\n+        continue;\n+      }\n+      return bound;\n+    }\n+  }\n+\n+  /**\n+   * Collects records from all the entries (labelSet, Bound) that changed since the last collect()\n+   * call.\n+   */\n+  @Override\n+  final void collect(RecordProcessor recordProcessor) {\n+    collectLock.lock();\n+    try {\n+      for (Map.Entry<LabelSet, B> entry : boundLabels.entrySet()) {\n+        if (entry.getValue().tryUnmap()) {\n+          // If able to unmap then remove the record from the current Map. This can race with the\n+          // acquire but because we requested a specific value only one will succeed.\n+          boundLabels.remove(entry.getKey(), entry.getValue());\n+        }\n+\n+        entry.getValue().checkpoint();\n+      }\n+    } finally {\n+      collectLock.unlock();\n+    }\n+  }\n+\n+  abstract B newBound();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI5MzEzNA=="}, "originalCommit": {"oid": "da8de26bcee520ea080acbf9ba53b55c28ed979a"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MzE0MTA3OnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/ActiveViewAggregator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwODo0NDowMVrOFpLJ_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNjoxMzoyNlrOFp74zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODcxODcxOQ==", "bodyText": "I think this should be stopCollection()", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r378718719", "createdAt": "2020-02-13T08:44:01Z", "author": {"login": "thisthat"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/ActiveViewAggregator.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import io.opentelemetry.sdk.metrics.aggregator.Aggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.AggregatorFactory;\n+import io.opentelemetry.sdk.metrics.aggregator.NoopAggregator;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+// The current implementation allows only to change the active ViewAggregator only before any record\n+// or binding happens. This is good for the moment to support default aggregation for all the\n+// instruments but needs to support adding/removing views at any moment, as well as support for\n+// multiple views in the same time.\n+final class ActiveViewAggregator {\n+  private AggregatorMap aggregatorMap;\n+  private volatile ViewAggregator currentViewAggregator;\n+\n+  ActiveViewAggregator() {\n+    currentViewAggregator = new NoopViewAggregator(null, NoopAggregator.getFactory());\n+  }\n+\n+  void addViewAggregator(Descriptor descriptor, AggregatorFactory aggregatorFactory) {\n+    // TODO: Add support to reduce labels.\n+    this.currentViewAggregator = new AllLabelsViewAggregator(descriptor, aggregatorFactory);\n+  }\n+\n+  // Caller needs to call these methods in the following order (while holding a lock):\n+  //  * startCollection();\n+  //  * collect();  // May be called multiple times.\n+  //  * startCollection()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "424ac24fdc1df91fd9f939282899e98ba2095aea"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUxNzEzNA==", "bodyText": "done.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r379517134", "createdAt": "2020-02-14T16:13:26Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/ActiveViewAggregator.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import io.opentelemetry.sdk.metrics.aggregator.Aggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.AggregatorFactory;\n+import io.opentelemetry.sdk.metrics.aggregator.NoopAggregator;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+// The current implementation allows only to change the active ViewAggregator only before any record\n+// or binding happens. This is good for the moment to support default aggregation for all the\n+// instruments but needs to support adding/removing views at any moment, as well as support for\n+// multiple views in the same time.\n+final class ActiveViewAggregator {\n+  private AggregatorMap aggregatorMap;\n+  private volatile ViewAggregator currentViewAggregator;\n+\n+  ActiveViewAggregator() {\n+    currentViewAggregator = new NoopViewAggregator(null, NoopAggregator.getFactory());\n+  }\n+\n+  void addViewAggregator(Descriptor descriptor, AggregatorFactory aggregatorFactory) {\n+    // TODO: Add support to reduce labels.\n+    this.currentViewAggregator = new AllLabelsViewAggregator(descriptor, aggregatorFactory);\n+  }\n+\n+  // Caller needs to call these methods in the following order (while holding a lock):\n+  //  * startCollection();\n+  //  * collect();  // May be called multiple times.\n+  //  * startCollection()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODcxODcxOQ=="}, "originalCommit": {"oid": "424ac24fdc1df91fd9f939282899e98ba2095aea"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MzE5ODk1OnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/DoubleMeasureSdk.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwOTowMjoxMlrOFpLs9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMTowOTo0OFrOFpjoqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODcyNzY2OA==", "bodyText": "I know it is a WIP, but should the constructor initialize an Aggregation?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r378727668", "createdAt": "2020-02-13T09:02:12Z", "author": {"login": "thisthat"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/DoubleMeasureSdk.java", "diffHunk": "@@ -46,7 +48,12 @@ public void record(double value, LabelSet labelSet) {\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "424ac24fdc1df91fd9f939282899e98ba2095aea"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExOTc4Nw==", "bodyText": "The goal for the moment is to get Counters working :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r379119787", "createdAt": "2020-02-13T21:09:48Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/DoubleMeasureSdk.java", "diffHunk": "@@ -46,7 +48,12 @@ public void record(double value, LabelSet labelSet) {\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODcyNzY2OA=="}, "originalCommit": {"oid": "424ac24fdc1df91fd9f939282899e98ba2095aea"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MzIwOTQwOnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/LongSumAggregator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwOTowNTozNlrOFpLziA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNzowNDoyMVrOFpcEZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODcyOTM1Mg==", "bodyText": "With #744 I guess this TODO can be removed", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r378729352", "createdAt": "2020-02-13T09:05:36Z", "author": {"login": "thisthat"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/LongSumAggregator.java", "diffHunk": "@@ -16,14 +16,25 @@\n \n package io.opentelemetry.sdk.metrics.aggregator;\n \n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import java.util.Map;\n import java.util.concurrent.atomic.AtomicLong;\n \n public final class LongSumAggregator implements Aggregator {\n+  private static final AggregatorFactory AGGREGATOR_FACTORY =\n+      new AggregatorFactory() {\n+        @Override\n+        public Aggregator getAggregator() {\n+          return new LongSumAggregator();\n+        }\n+      };\n+\n   // TODO: Change to use LongAdder when changed to java8.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "424ac24fdc1df91fd9f939282899e98ba2095aea"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5NTgxMg==", "bodyText": "LongAdder is from java8 not java7 (sad face)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r378995812", "createdAt": "2020-02-13T17:04:21Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/LongSumAggregator.java", "diffHunk": "@@ -16,14 +16,25 @@\n \n package io.opentelemetry.sdk.metrics.aggregator;\n \n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import java.util.Map;\n import java.util.concurrent.atomic.AtomicLong;\n \n public final class LongSumAggregator implements Aggregator {\n+  private static final AggregatorFactory AGGREGATOR_FACTORY =\n+      new AggregatorFactory() {\n+        @Override\n+        public Aggregator getAggregator() {\n+          return new LongSumAggregator();\n+        }\n+      };\n+\n   // TODO: Change to use LongAdder when changed to java8.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODcyOTM1Mg=="}, "originalCommit": {"oid": "424ac24fdc1df91fd9f939282899e98ba2095aea"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODI1OTk1OnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AggregatorMap.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNjozMDo1M1rOFp8dJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxOTowNjoyMVrOFqAs3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUyNjQzOA==", "bodyText": "This class name is confusing. Why Map ?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r379526438", "createdAt": "2020-02-14T16:30:53Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AggregatorMap.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.aggregator.Aggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.AggregatorFactory;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+abstract class AggregatorMap {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d93ffa390dbdc6d82e04a191493f0d70867644a6"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzNTY4OQ==", "bodyText": "Maybe \"AggregationStrategy\" would be better?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r379535689", "createdAt": "2020-02-14T16:48:17Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AggregatorMap.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.aggregator.Aggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.AggregatorFactory;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+abstract class AggregatorMap {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUyNjQzOA=="}, "originalCommit": {"oid": "d93ffa390dbdc6d82e04a191493f0d70867644a6"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzNzM1Ng==", "bodyText": "Also, I think this would be better as an interface, since it's internal and we don't need to worry about breaking things by adding new methods.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r379537356", "createdAt": "2020-02-14T16:51:42Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AggregatorMap.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.aggregator.Aggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.AggregatorFactory;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+abstract class AggregatorMap {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUyNjQzOA=="}, "originalCommit": {"oid": "d93ffa390dbdc6d82e04a191493f0d70867644a6"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU5Mjk4MQ==", "bodyText": "I am very annoyed with interfaces since I cannot have some implementations in the same file and require an extra file like Aggregator/Aggregators :(.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r379592981", "createdAt": "2020-02-14T18:59:09Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AggregatorMap.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.aggregator.Aggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.AggregatorFactory;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+abstract class AggregatorMap {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUyNjQzOA=="}, "originalCommit": {"oid": "d93ffa390dbdc6d82e04a191493f0d70867644a6"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU5NTk5OA==", "bodyText": "yeah, java 7 is a problem. this is all fixed in java 8. Anyway, an abstract class is fine for now.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r379595998", "createdAt": "2020-02-14T19:06:21Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AggregatorMap.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.aggregator.Aggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.AggregatorFactory;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+abstract class AggregatorMap {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUyNjQzOA=="}, "originalCommit": {"oid": "d93ffa390dbdc6d82e04a191493f0d70867644a6"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODI3MzU2OnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AggregatorMap.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNjozNTozMFrOFp8l6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNjozNTozMFrOFp8l6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUyODY4Mg==", "bodyText": "I think we can use LabelSetSdk as the key to this map, since it has a well-defined equals/hashcode via autovalue.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r379528682", "createdAt": "2020-02-14T16:35:30Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/AggregatorMap.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import io.opentelemetry.metrics.LabelSet;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.aggregator.Aggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.AggregatorFactory;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+abstract class AggregatorMap {\n+  static AggregatorMap getNoop() {\n+    return Noop.INSTANCE;\n+  }\n+\n+  static AggregatorMap getAllLabels(\n+      Descriptor descriptor,\n+      Resource resource,\n+      InstrumentationLibraryInfo instrumentationLibraryInfo,\n+      AggregatorFactory aggregatorFactory,\n+      long startEpochNanos) {\n+    return new AllLabels(\n+        descriptor, resource, instrumentationLibraryInfo, aggregatorFactory, startEpochNanos);\n+  }\n+\n+  abstract void collect(LabelSet labelSet, Aggregator aggregator);\n+\n+  abstract List<MetricData> stopCollection(long epochNanos);\n+\n+  private static final class Noop extends AggregatorMap {\n+    private static final AggregatorMap INSTANCE = new Noop();\n+\n+    @Override\n+    void collect(LabelSet labelSet, Aggregator aggregator) {\n+      // Noop.\n+    }\n+\n+    @Override\n+    List<MetricData> stopCollection(long epochNanos) {\n+      return Collections.emptyList();\n+    }\n+  }\n+\n+  private static final class AllLabels extends AggregatorMap {\n+    private final Descriptor descriptor;\n+    private final Resource resource;\n+    private final InstrumentationLibraryInfo instrumentationLibraryInfo;\n+    private final AggregatorFactory aggregatorFactory;\n+    private final Map<Map<String, String>, Aggregator> aggregatorMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d93ffa390dbdc6d82e04a191493f0d70867644a6"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTk3MjQ5OnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/Batchers.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMzowNzozMVrOFr7AAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMzoxMToyOFrOFr7Fwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5OTc0NA==", "bodyText": "I think there's a risk of a ConcurrentModificationException happening during this iteration, since the map can be mutated during this method call.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r381599744", "createdAt": "2020-02-19T23:07:31Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/Batchers.java", "diffHunk": "@@ -47,5 +86,69 @@ public void batch(LabelSet labelSet, Aggregator aggregator, boolean mappedAggreg\n     }\n   }\n \n+  private static final class AllLabels implements Batcher {\n+    private final Descriptor descriptor;\n+    private final Resource resource;\n+    private final InstrumentationLibraryInfo instrumentationLibraryInfo;\n+    private final Clock clock;\n+    private final AggregatorFactory aggregatorFactory;\n+    private Map<Map<String, String>, Aggregator> aggregatorMap;\n+    private long startEpochNanos;\n+    private final boolean delta;\n+\n+    private AllLabels(\n+        Descriptor descriptor,\n+        Resource resource,\n+        InstrumentationLibraryInfo instrumentationLibraryInfo,\n+        AggregatorFactory aggregatorFactory,\n+        Clock clock,\n+        boolean delta) {\n+      this.descriptor = descriptor;\n+      this.resource = resource;\n+      this.instrumentationLibraryInfo = instrumentationLibraryInfo;\n+      this.clock = clock;\n+      this.aggregatorFactory = aggregatorFactory;\n+      this.delta = delta;\n+      this.aggregatorMap = new HashMap<>();\n+      startEpochNanos = clock.now();\n+    }\n+\n+    @Override\n+    public final Aggregator getAggregator() {\n+      return aggregatorFactory.getAggregator();\n+    }\n+\n+    @Override\n+    public final void batch(LabelSet labelSet, Aggregator aggregator, boolean unmappedAggregator) {\n+      Map<String, String> labels = ((LabelSetSdk) labelSet).getLabels();\n+      Aggregator currentAggregator = aggregatorMap.get(labels);\n+      if (currentAggregator == null) {\n+        // This aggregator is not mapped, we can use this instance.\n+        if (unmappedAggregator) {\n+          aggregatorMap.put(labels, aggregator);\n+          return;\n+        }\n+        currentAggregator = aggregatorFactory.getAggregator();\n+        aggregatorMap.put(labels, currentAggregator);\n+      }\n+      aggregator.mergeToAndReset(currentAggregator);\n+    }\n+\n+    @Override\n+    public final List<MetricData> completeCollectionCycle() {\n+      List<Point> points = new ArrayList<>(aggregatorMap.size());\n+      long epochNanos = clock.now();\n+      for (Map.Entry<Map<String, String>, Aggregator> entry : aggregatorMap.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3871f6a71641228fb3c49b651b7c0c22bf5f97d3"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYwMDc3MQ==", "bodyText": "It is guaranteed that only one thread calls into a Batcher collection at a time by the collectLock in the AbstractInstrumentWithBindings", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r381600771", "createdAt": "2020-02-19T23:10:20Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/Batchers.java", "diffHunk": "@@ -47,5 +86,69 @@ public void batch(LabelSet labelSet, Aggregator aggregator, boolean mappedAggreg\n     }\n   }\n \n+  private static final class AllLabels implements Batcher {\n+    private final Descriptor descriptor;\n+    private final Resource resource;\n+    private final InstrumentationLibraryInfo instrumentationLibraryInfo;\n+    private final Clock clock;\n+    private final AggregatorFactory aggregatorFactory;\n+    private Map<Map<String, String>, Aggregator> aggregatorMap;\n+    private long startEpochNanos;\n+    private final boolean delta;\n+\n+    private AllLabels(\n+        Descriptor descriptor,\n+        Resource resource,\n+        InstrumentationLibraryInfo instrumentationLibraryInfo,\n+        AggregatorFactory aggregatorFactory,\n+        Clock clock,\n+        boolean delta) {\n+      this.descriptor = descriptor;\n+      this.resource = resource;\n+      this.instrumentationLibraryInfo = instrumentationLibraryInfo;\n+      this.clock = clock;\n+      this.aggregatorFactory = aggregatorFactory;\n+      this.delta = delta;\n+      this.aggregatorMap = new HashMap<>();\n+      startEpochNanos = clock.now();\n+    }\n+\n+    @Override\n+    public final Aggregator getAggregator() {\n+      return aggregatorFactory.getAggregator();\n+    }\n+\n+    @Override\n+    public final void batch(LabelSet labelSet, Aggregator aggregator, boolean unmappedAggregator) {\n+      Map<String, String> labels = ((LabelSetSdk) labelSet).getLabels();\n+      Aggregator currentAggregator = aggregatorMap.get(labels);\n+      if (currentAggregator == null) {\n+        // This aggregator is not mapped, we can use this instance.\n+        if (unmappedAggregator) {\n+          aggregatorMap.put(labels, aggregator);\n+          return;\n+        }\n+        currentAggregator = aggregatorFactory.getAggregator();\n+        aggregatorMap.put(labels, currentAggregator);\n+      }\n+      aggregator.mergeToAndReset(currentAggregator);\n+    }\n+\n+    @Override\n+    public final List<MetricData> completeCollectionCycle() {\n+      List<Point> points = new ArrayList<>(aggregatorMap.size());\n+      long epochNanos = clock.now();\n+      for (Map.Entry<Map<String, String>, Aggregator> entry : aggregatorMap.entrySet()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5OTc0NA=="}, "originalCommit": {"oid": "3871f6a71641228fb3c49b651b7c0c22bf5f97d3"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYwMTIxOA==", "bodyText": "please add a comment in here to that effect. thanks!", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/831#discussion_r381601218", "createdAt": "2020-02-19T23:11:28Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/Batchers.java", "diffHunk": "@@ -47,5 +86,69 @@ public void batch(LabelSet labelSet, Aggregator aggregator, boolean mappedAggreg\n     }\n   }\n \n+  private static final class AllLabels implements Batcher {\n+    private final Descriptor descriptor;\n+    private final Resource resource;\n+    private final InstrumentationLibraryInfo instrumentationLibraryInfo;\n+    private final Clock clock;\n+    private final AggregatorFactory aggregatorFactory;\n+    private Map<Map<String, String>, Aggregator> aggregatorMap;\n+    private long startEpochNanos;\n+    private final boolean delta;\n+\n+    private AllLabels(\n+        Descriptor descriptor,\n+        Resource resource,\n+        InstrumentationLibraryInfo instrumentationLibraryInfo,\n+        AggregatorFactory aggregatorFactory,\n+        Clock clock,\n+        boolean delta) {\n+      this.descriptor = descriptor;\n+      this.resource = resource;\n+      this.instrumentationLibraryInfo = instrumentationLibraryInfo;\n+      this.clock = clock;\n+      this.aggregatorFactory = aggregatorFactory;\n+      this.delta = delta;\n+      this.aggregatorMap = new HashMap<>();\n+      startEpochNanos = clock.now();\n+    }\n+\n+    @Override\n+    public final Aggregator getAggregator() {\n+      return aggregatorFactory.getAggregator();\n+    }\n+\n+    @Override\n+    public final void batch(LabelSet labelSet, Aggregator aggregator, boolean unmappedAggregator) {\n+      Map<String, String> labels = ((LabelSetSdk) labelSet).getLabels();\n+      Aggregator currentAggregator = aggregatorMap.get(labels);\n+      if (currentAggregator == null) {\n+        // This aggregator is not mapped, we can use this instance.\n+        if (unmappedAggregator) {\n+          aggregatorMap.put(labels, aggregator);\n+          return;\n+        }\n+        currentAggregator = aggregatorFactory.getAggregator();\n+        aggregatorMap.put(labels, currentAggregator);\n+      }\n+      aggregator.mergeToAndReset(currentAggregator);\n+    }\n+\n+    @Override\n+    public final List<MetricData> completeCollectionCycle() {\n+      List<Point> points = new ArrayList<>(aggregatorMap.size());\n+      long epochNanos = clock.now();\n+      for (Map.Entry<Map<String, String>, Aggregator> entry : aggregatorMap.entrySet()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5OTc0NA=="}, "originalCommit": {"oid": "3871f6a71641228fb3c49b651b7c0c22bf5f97d3"}, "originalPosition": 114}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1068, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}