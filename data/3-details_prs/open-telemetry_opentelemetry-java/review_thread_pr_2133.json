{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3NDE3MTAz", "number": 2133, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTowNTozN1rOE9RQow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTozOTozNFrOE9XkdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNjgxMzc5OnYy", "diffSide": "RIGHT", "path": "opentracing-shim/src/main/java/io/opentelemetry/opentracingshim/Propagation.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTowNTozN1rOH53kWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNToyNjoyN1rOH54fCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ0MTMwNw==", "bodyText": "If we plan to iterate over all the values per get() call, we should get rid of the intermediate temporary Map.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2133#discussion_r530441307", "createdAt": "2020-11-25T15:05:37Z", "author": {"login": "carlosalberto"}, "path": "opentracing-shim/src/main/java/io/opentelemetry/opentracingshim/Propagation.java", "diffHunk": "@@ -73,7 +73,12 @@ private TextMapGetter() {}\n \n     @Override\n     public String get(Map<String, String> carrier, String key) {\n-      return carrier.get(key);\n+      for (Map.Entry<String, String> entry : carrier.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e40517a4ce049a7b7e6012fad539029bc4f78e3e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ1NjMzMA==", "bodyText": "I didn't remove temporary map because we need to implement\n@Override\npublic Iterable<String> keys(Map<String, String> carrier) {\n      return carrier.keySet();\n}\n\nif carrier will be TextMapExtract then to get keys I will need to create something temporal...", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2133#discussion_r530456330", "createdAt": "2020-11-25T15:26:27Z", "author": {"login": "malafeev"}, "path": "opentracing-shim/src/main/java/io/opentelemetry/opentracingshim/Propagation.java", "diffHunk": "@@ -73,7 +73,12 @@ private TextMapGetter() {}\n \n     @Override\n     public String get(Map<String, String> carrier, String key) {\n-      return carrier.get(key);\n+      for (Map.Entry<String, String> entry : carrier.entrySet()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ0MTMwNw=="}, "originalCommit": {"oid": "e40517a4ce049a7b7e6012fad539029bc4f78e3e"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzg0NzU2OnYy", "diffSide": "RIGHT", "path": "opentracing-shim/src/test/java/io/opentelemetry/opentracingshim/testbed/clientserver/TestClientServerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxOTozOTozNFrOH6Bhpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwMjoyOTo1MFrOH6Ju3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNDQ1NQ==", "bodyText": "do we need to sortByStartTime any more if we're not going to rely on the order? Also, why did this change make the times change?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2133#discussion_r530604455", "createdAt": "2020-11-25T19:39:34Z", "author": {"login": "jkwatson"}, "path": "opentracing-shim/src/test/java/io/opentelemetry/opentracingshim/testbed/clientserver/TestClientServerTest.java", "diffHunk": "@@ -47,17 +48,33 @@ void after() throws InterruptedException {\n   @Test\n   void test() throws Exception {\n     Client client = new Client(queue, tracer);\n-    client.send();\n+    client.send(false);\n+    verify();\n+  }\n+\n+  @Test\n+  public void testUpperCaseKeys() throws Exception {\n+    Client client = new Client(queue, tracer);\n+    client.send(true);\n+    verify();\n+  }\n \n+  private void verify() {\n     await().atMost(Duration.ofSeconds(15)).until(finishedSpansSize(otelTesting), equalTo(2));\n \n     List<SpanData> finished = otelTesting.getSpans();\n     assertThat(finished).hasSize(2);\n \n     finished = sortByStartTime(finished);\n     assertThat(finished.get(1).getTraceId()).isEqualTo(finished.get(0).getTraceId());\n-    assertThat(finished.get(0).getKind()).isEqualTo(Kind.CLIENT);\n-    assertThat(finished.get(1).getKind()).isEqualTo(Kind.SERVER);\n+    Kind firstSpanKind = finished.get(0).getKind();\n+    if (firstSpanKind == Kind.CLIENT) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e40517a4ce049a7b7e6012fad539029bc4f78e3e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDczODkwOA==", "bodyText": "I removed sorting. I guess that client and server spans are created too fast and we have kind of floating of nano seconds. If I put sleep(100) in the client then sorted order is client->server, but I prefer to avoid adding sleep.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2133#discussion_r530738908", "createdAt": "2020-11-26T02:29:50Z", "author": {"login": "malafeev"}, "path": "opentracing-shim/src/test/java/io/opentelemetry/opentracingshim/testbed/clientserver/TestClientServerTest.java", "diffHunk": "@@ -47,17 +48,33 @@ void after() throws InterruptedException {\n   @Test\n   void test() throws Exception {\n     Client client = new Client(queue, tracer);\n-    client.send();\n+    client.send(false);\n+    verify();\n+  }\n+\n+  @Test\n+  public void testUpperCaseKeys() throws Exception {\n+    Client client = new Client(queue, tracer);\n+    client.send(true);\n+    verify();\n+  }\n \n+  private void verify() {\n     await().atMost(Duration.ofSeconds(15)).until(finishedSpansSize(otelTesting), equalTo(2));\n \n     List<SpanData> finished = otelTesting.getSpans();\n     assertThat(finished).hasSize(2);\n \n     finished = sortByStartTime(finished);\n     assertThat(finished.get(1).getTraceId()).isEqualTo(finished.get(0).getTraceId());\n-    assertThat(finished.get(0).getKind()).isEqualTo(Kind.CLIENT);\n-    assertThat(finished.get(1).getKind()).isEqualTo(Kind.SERVER);\n+    Kind firstSpanKind = finished.get(0).getKind();\n+    if (firstSpanKind == Kind.CLIENT) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYwNDQ1NQ=="}, "originalCommit": {"oid": "e40517a4ce049a7b7e6012fad539029bc4f78e3e"}, "originalPosition": 35}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1772, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}