{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1NzE3NzEw", "number": 979, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTo1MDoxMlrODmcKGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMzowMzo0MVrODm4twg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjMzODE4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTo1MDoxMlrOFz3BaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMDoyMjo0MlrOF0I78Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyMzE3Ng==", "bodyText": "does this need to be a nullable big-b Boolean? Can't it just be a primitive boolean?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r389923176", "createdAt": "2020-03-09T19:50:12Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(Boolean singleHeader) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e463b1234a03e7269096a5b062d11e372da102a"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIxNjY4OQ==", "bodyText": "Pushed an update - there is no need for a Boolean in this case.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390216689", "createdAt": "2020-03-10T10:22:42Z", "author": {"login": "MikeGoldsmith"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(Boolean singleHeader) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyMzE3Ng=="}, "originalCommit": {"oid": "5e463b1234a03e7269096a5b062d11e372da102a"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjM0ODAzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxOTo1MzowNlrOFz3Hdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMDozNTo1MlrOFz4b7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyNDcyNg==", "bodyText": "This should be broken up into at least 2 separate methods. This method is definitely too long. One method for the single header case that returns the context, and one for the multi-header case that returns the context will make this code much easier to read. Thanks!", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r389924726", "createdAt": "2020-03-09T19:53:06Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(Boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"StringSplitter\")\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    String traceId;\n+    String spanId;\n+    String sampled;\n+    if (singleHeader) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e463b1234a03e7269096a5b062d11e372da102a"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk0NjM1MA==", "bodyText": "I support this. The TraceContext one is refactored as it was too long and it was (relatively) hard to read.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r389946350", "createdAt": "2020-03-09T20:35:52Z", "author": {"login": "carlosalberto"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(Boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"StringSplitter\")\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    String traceId;\n+    String spanId;\n+    String sampled;\n+    if (singleHeader) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyNDcyNg=="}, "originalCommit": {"oid": "5e463b1234a03e7269096a5b062d11e372da102a"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNzY4ODg5OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwNzoyODowNVrOF0DvzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMDoyMjowMVrOF0I6iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEzMTY2MA==", "bodyText": "The first two checks could leverage the StringUtils.isNullOrEmpty(value) method", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390131660", "createdAt": "2020-03-10T07:28:05Z", "author": {"login": "thisthat"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(Boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"StringSplitter\")\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    String traceId;\n+    String spanId;\n+    String sampled;\n+    if (singleHeader) {\n+      String value = getter.get(carrier, COMBINED_HEADER);\n+      if (value == null || value.isEmpty()) {\n+        logger.info(\n+            \"Missing or empty combined header: \"\n+                + COMBINED_HEADER\n+                + \". Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      // must have between 2 and 4 hyphen delimieted parts:\n+      //   traceId-spanId-sampled-parentSpanId (last two are optional)\n+      // NOTE: we do not use parentSpanId\n+      String[] parts = value.split(COMBINED_HEADER_DELIMITER);\n+      if (parts.length < 2 || parts.length > 4) {\n+        logger.info(\n+            \"Invalid combined header '\" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      traceId = parts[0];\n+      if (!isTraceIdValid(traceId)) {\n+        logger.info(\n+            \"Invalid TraceId in B3 header: \"\n+                + COMBINED_HEADER\n+                + \". Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      spanId = parts[1];\n+      if (!isSpanIdValid(spanId)) {\n+        logger.info(\n+            \"Invalid SpanId in B3 header: \"\n+                + COMBINED_HEADER\n+                + \". Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      sampled = parts.length == 3 ? parts[2] : null;\n+    } else {\n+      traceId = getter.get(carrier, TRACE_ID_HEADER);\n+      if (!isTraceIdValid(traceId)) {\n+        logger.info(\n+            \"Invalid TraceId in B3 header: \"\n+                + TRACE_ID_HEADER\n+                + \"'. Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      spanId = getter.get(carrier, SPAN_ID_HEADER);\n+      if (!isSpanIdValid(spanId)) {\n+        logger.info(\n+            \"Invalid SpanId in B3 header: \"\n+                + SPAN_ID_HEADER\n+                + \"'. Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      sampled = getter.get(carrier, SAMPLED_HEADER);\n+    }\n+\n+    return buildSpanContext(traceId, spanId, sampled);\n+  }\n+\n+  private static SpanContext buildSpanContext(String traceId, String spanId, String sampled) {\n+    try {\n+      TraceFlags traceFlags =\n+          TraceFlags.builder()\n+              .setIsSampled(\n+                  TRUE_INT.equals(sampled)\n+                      || Boolean.parseBoolean(sampled)) // accept either \"1\" or \"true\"\n+              .build();\n+\n+      return SpanContext.createFromRemoteParent(\n+          TraceId.fromLowerBase16(traceId, 0),\n+          SpanId.fromLowerBase16(spanId, 0),\n+          traceFlags,\n+          TraceState.getDefault());\n+    } catch (Exception e) {\n+      logger.log(Level.INFO, \"Error parsing B3 header. Returning INVALID span context.\", e);\n+      return SpanContext.getInvalid();\n+    }\n+  }\n+\n+  private static boolean isTraceIdValid(String value) {\n+    return !(value == null || value.isEmpty() || value.length() > MAX_TRACE_ID_LENGTH);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e463b1234a03e7269096a5b062d11e372da102a"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIxNjMyOQ==", "bodyText": "Thanks - I've pushed an update to use StringUtils.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390216329", "createdAt": "2020-03-10T10:22:01Z", "author": {"login": "MikeGoldsmith"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(Boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"StringSplitter\")\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    String traceId;\n+    String spanId;\n+    String sampled;\n+    if (singleHeader) {\n+      String value = getter.get(carrier, COMBINED_HEADER);\n+      if (value == null || value.isEmpty()) {\n+        logger.info(\n+            \"Missing or empty combined header: \"\n+                + COMBINED_HEADER\n+                + \". Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      // must have between 2 and 4 hyphen delimieted parts:\n+      //   traceId-spanId-sampled-parentSpanId (last two are optional)\n+      // NOTE: we do not use parentSpanId\n+      String[] parts = value.split(COMBINED_HEADER_DELIMITER);\n+      if (parts.length < 2 || parts.length > 4) {\n+        logger.info(\n+            \"Invalid combined header '\" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      traceId = parts[0];\n+      if (!isTraceIdValid(traceId)) {\n+        logger.info(\n+            \"Invalid TraceId in B3 header: \"\n+                + COMBINED_HEADER\n+                + \". Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      spanId = parts[1];\n+      if (!isSpanIdValid(spanId)) {\n+        logger.info(\n+            \"Invalid SpanId in B3 header: \"\n+                + COMBINED_HEADER\n+                + \". Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      sampled = parts.length == 3 ? parts[2] : null;\n+    } else {\n+      traceId = getter.get(carrier, TRACE_ID_HEADER);\n+      if (!isTraceIdValid(traceId)) {\n+        logger.info(\n+            \"Invalid TraceId in B3 header: \"\n+                + TRACE_ID_HEADER\n+                + \"'. Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      spanId = getter.get(carrier, SPAN_ID_HEADER);\n+      if (!isSpanIdValid(spanId)) {\n+        logger.info(\n+            \"Invalid SpanId in B3 header: \"\n+                + SPAN_ID_HEADER\n+                + \"'. Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      sampled = getter.get(carrier, SAMPLED_HEADER);\n+    }\n+\n+    return buildSpanContext(traceId, spanId, sampled);\n+  }\n+\n+  private static SpanContext buildSpanContext(String traceId, String spanId, String sampled) {\n+    try {\n+      TraceFlags traceFlags =\n+          TraceFlags.builder()\n+              .setIsSampled(\n+                  TRUE_INT.equals(sampled)\n+                      || Boolean.parseBoolean(sampled)) // accept either \"1\" or \"true\"\n+              .build();\n+\n+      return SpanContext.createFromRemoteParent(\n+          TraceId.fromLowerBase16(traceId, 0),\n+          SpanId.fromLowerBase16(spanId, 0),\n+          traceFlags,\n+          TraceState.getDefault());\n+    } catch (Exception e) {\n+      logger.log(Level.INFO, \"Error parsing B3 header. Returning INVALID span context.\", e);\n+      return SpanContext.getInvalid();\n+    }\n+  }\n+\n+  private static boolean isTraceIdValid(String value) {\n+    return !(value == null || value.isEmpty() || value.length() > MAX_TRACE_ID_LENGTH);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEzMTY2MA=="}, "originalCommit": {"oid": "5e463b1234a03e7269096a5b062d11e372da102a"}, "originalPosition": 195}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTAwMzkyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMjo1NzowN1rOF0j5Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNTowMjo1N1rOF07Avw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1ODM1NA==", "bodyText": "We don't use checker framework so no need to add the comment about non-null.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390658354", "createdAt": "2020-03-10T22:57:07Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAzNzExOQ==", "bodyText": "Removed \ud83d\udc4d", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r391037119", "createdAt": "2020-03-11T15:02:57Z", "author": {"login": "MikeGoldsmith"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1ODM1NA=="}, "originalCommit": {"oid": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTAwOTk5OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMzowMDoyN1rOF0j9Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMzowMDoyN1rOF0j9Rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1OTM5OQ==", "bodyText": "You can construct a sampled/notSampled TraceFlags and reuse them.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390659399", "createdAt": "2020-03-10T23:00:27Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    if (singleHeader) {\n+      return getSpanContextFromSingleHeader(carrier, getter);\n+    } else {\n+      return getSpanContextFromMultipleHeaders(carrier, getter);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C /*>>> extends @NonNull Object*/> SpanContext getSpanContextFromSingleHeader(\n+      C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, COMBINED_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      logger.info(\n+          \"Missing or empty combined header: \"\n+              + COMBINED_HEADER\n+              + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    // must have between 2 and 4 hyphen delimieted parts:\n+    //   traceId-spanId-sampled-parentSpanId (last two are optional)\n+    // NOTE: we do not use parentSpanId\n+    String[] parts = value.split(COMBINED_HEADER_DELIMITER);\n+    if (parts.length < 2 || parts.length > 4) {\n+      logger.info(\n+          \"Invalid combined header '\" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String traceId = parts[0];\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String spanId = parts[1];\n+    if (!isSpanIdValid(spanId)) {\n+      logger.info(\n+          \"Invalid SpanId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String sampled = parts.length == 3 ? parts[2] : null;\n+\n+    return buildSpanContext(traceId, spanId, sampled);\n+  }\n+\n+  private static <C /*>>> extends @NonNull Object*/> SpanContext getSpanContextFromMultipleHeaders(\n+      C carrier, Getter<C> getter) {\n+    String traceId = getter.get(carrier, TRACE_ID_HEADER);\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in B3 header: \"\n+              + TRACE_ID_HEADER\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String spanId = getter.get(carrier, SPAN_ID_HEADER);\n+    if (!isSpanIdValid(spanId)) {\n+      logger.info(\n+          \"Invalid SpanId in B3 header: \" + SPAN_ID_HEADER + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String sampled = getter.get(carrier, SAMPLED_HEADER);\n+    return buildSpanContext(traceId, spanId, sampled);\n+  }\n+\n+  private static SpanContext buildSpanContext(String traceId, String spanId, String sampled) {\n+    try {\n+      TraceFlags traceFlags =\n+          TraceFlags.builder()\n+              .setIsSampled(\n+                  TRUE_INT.equals(sampled)\n+                      || Boolean.parseBoolean(sampled)) // accept either \"1\" or \"true\"\n+              .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad"}, "originalPosition": 184}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTAxMjcwOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMzowMTozNVrOF0j-zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNTo1MzowNlrOF1kjKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1OTc4OA==", "bodyText": "This requires traceId (string) to be 32 hex characters and we only check that the size is not greater than MAX_TRACE_ID_LENGTH.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390659788", "createdAt": "2020-03-10T23:01:35Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    if (singleHeader) {\n+      return getSpanContextFromSingleHeader(carrier, getter);\n+    } else {\n+      return getSpanContextFromMultipleHeaders(carrier, getter);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C /*>>> extends @NonNull Object*/> SpanContext getSpanContextFromSingleHeader(\n+      C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, COMBINED_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      logger.info(\n+          \"Missing or empty combined header: \"\n+              + COMBINED_HEADER\n+              + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    // must have between 2 and 4 hyphen delimieted parts:\n+    //   traceId-spanId-sampled-parentSpanId (last two are optional)\n+    // NOTE: we do not use parentSpanId\n+    String[] parts = value.split(COMBINED_HEADER_DELIMITER);\n+    if (parts.length < 2 || parts.length > 4) {\n+      logger.info(\n+          \"Invalid combined header '\" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String traceId = parts[0];\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String spanId = parts[1];\n+    if (!isSpanIdValid(spanId)) {\n+      logger.info(\n+          \"Invalid SpanId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String sampled = parts.length == 3 ? parts[2] : null;\n+\n+    return buildSpanContext(traceId, spanId, sampled);\n+  }\n+\n+  private static <C /*>>> extends @NonNull Object*/> SpanContext getSpanContextFromMultipleHeaders(\n+      C carrier, Getter<C> getter) {\n+    String traceId = getter.get(carrier, TRACE_ID_HEADER);\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in B3 header: \"\n+              + TRACE_ID_HEADER\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String spanId = getter.get(carrier, SPAN_ID_HEADER);\n+    if (!isSpanIdValid(spanId)) {\n+      logger.info(\n+          \"Invalid SpanId in B3 header: \" + SPAN_ID_HEADER + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String sampled = getter.get(carrier, SAMPLED_HEADER);\n+    return buildSpanContext(traceId, spanId, sampled);\n+  }\n+\n+  private static SpanContext buildSpanContext(String traceId, String spanId, String sampled) {\n+    try {\n+      TraceFlags traceFlags =\n+          TraceFlags.builder()\n+              .setIsSampled(\n+                  TRUE_INT.equals(sampled)\n+                      || Boolean.parseBoolean(sampled)) // accept either \"1\" or \"true\"\n+              .build();\n+\n+      return SpanContext.createFromRemoteParent(\n+          TraceId.fromLowerBase16(traceId, 0),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5NjIyMg==", "bodyText": "Pushed change to left pad TraceIds upto max with leading 0's. I added padLeft to StringUtils. Let me know what you think.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r391096222", "createdAt": "2020-03-11T16:22:21Z", "author": {"login": "MikeGoldsmith"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    if (singleHeader) {\n+      return getSpanContextFromSingleHeader(carrier, getter);\n+    } else {\n+      return getSpanContextFromMultipleHeaders(carrier, getter);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C /*>>> extends @NonNull Object*/> SpanContext getSpanContextFromSingleHeader(\n+      C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, COMBINED_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      logger.info(\n+          \"Missing or empty combined header: \"\n+              + COMBINED_HEADER\n+              + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    // must have between 2 and 4 hyphen delimieted parts:\n+    //   traceId-spanId-sampled-parentSpanId (last two are optional)\n+    // NOTE: we do not use parentSpanId\n+    String[] parts = value.split(COMBINED_HEADER_DELIMITER);\n+    if (parts.length < 2 || parts.length > 4) {\n+      logger.info(\n+          \"Invalid combined header '\" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String traceId = parts[0];\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String spanId = parts[1];\n+    if (!isSpanIdValid(spanId)) {\n+      logger.info(\n+          \"Invalid SpanId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String sampled = parts.length == 3 ? parts[2] : null;\n+\n+    return buildSpanContext(traceId, spanId, sampled);\n+  }\n+\n+  private static <C /*>>> extends @NonNull Object*/> SpanContext getSpanContextFromMultipleHeaders(\n+      C carrier, Getter<C> getter) {\n+    String traceId = getter.get(carrier, TRACE_ID_HEADER);\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in B3 header: \"\n+              + TRACE_ID_HEADER\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String spanId = getter.get(carrier, SPAN_ID_HEADER);\n+    if (!isSpanIdValid(spanId)) {\n+      logger.info(\n+          \"Invalid SpanId in B3 header: \" + SPAN_ID_HEADER + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String sampled = getter.get(carrier, SAMPLED_HEADER);\n+    return buildSpanContext(traceId, spanId, sampled);\n+  }\n+\n+  private static SpanContext buildSpanContext(String traceId, String spanId, String sampled) {\n+    try {\n+      TraceFlags traceFlags =\n+          TraceFlags.builder()\n+              .setIsSampled(\n+                  TRUE_INT.equals(sampled)\n+                      || Boolean.parseBoolean(sampled)) // accept either \"1\" or \"true\"\n+              .build();\n+\n+      return SpanContext.createFromRemoteParent(\n+          TraceId.fromLowerBase16(traceId, 0),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1OTc4OA=="}, "originalCommit": {"oid": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcxNzY3Mw==", "bodyText": "As this was fixed along with a test (see https://github.com/open-telemetry/opentelemetry-java/pull/979/files#diff-004fb9fadd7caedae3844dfe8b040186R137) I'm marking this as resolved.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r391717673", "createdAt": "2020-03-12T15:53:06Z", "author": {"login": "carlosalberto"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    if (singleHeader) {\n+      return getSpanContextFromSingleHeader(carrier, getter);\n+    } else {\n+      return getSpanContextFromMultipleHeaders(carrier, getter);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C /*>>> extends @NonNull Object*/> SpanContext getSpanContextFromSingleHeader(\n+      C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, COMBINED_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      logger.info(\n+          \"Missing or empty combined header: \"\n+              + COMBINED_HEADER\n+              + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    // must have between 2 and 4 hyphen delimieted parts:\n+    //   traceId-spanId-sampled-parentSpanId (last two are optional)\n+    // NOTE: we do not use parentSpanId\n+    String[] parts = value.split(COMBINED_HEADER_DELIMITER);\n+    if (parts.length < 2 || parts.length > 4) {\n+      logger.info(\n+          \"Invalid combined header '\" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String traceId = parts[0];\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String spanId = parts[1];\n+    if (!isSpanIdValid(spanId)) {\n+      logger.info(\n+          \"Invalid SpanId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String sampled = parts.length == 3 ? parts[2] : null;\n+\n+    return buildSpanContext(traceId, spanId, sampled);\n+  }\n+\n+  private static <C /*>>> extends @NonNull Object*/> SpanContext getSpanContextFromMultipleHeaders(\n+      C carrier, Getter<C> getter) {\n+    String traceId = getter.get(carrier, TRACE_ID_HEADER);\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in B3 header: \"\n+              + TRACE_ID_HEADER\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String spanId = getter.get(carrier, SPAN_ID_HEADER);\n+    if (!isSpanIdValid(spanId)) {\n+      logger.info(\n+          \"Invalid SpanId in B3 header: \" + SPAN_ID_HEADER + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String sampled = getter.get(carrier, SAMPLED_HEADER);\n+    return buildSpanContext(traceId, spanId, sampled);\n+  }\n+\n+  private static SpanContext buildSpanContext(String traceId, String spanId, String sampled) {\n+    try {\n+      TraceFlags traceFlags =\n+          TraceFlags.builder()\n+              .setIsSampled(\n+                  TRUE_INT.equals(sampled)\n+                      || Boolean.parseBoolean(sampled)) // accept either \"1\" or \"true\"\n+              .build();\n+\n+      return SpanContext.createFromRemoteParent(\n+          TraceId.fromLowerBase16(traceId, 0),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1OTc4OA=="}, "originalCommit": {"oid": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTAxNDA4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMzowMjoyMFrOF0j_uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNTowNToxNlrOF07Hbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2MDAyNQ==", "bodyText": "Should we have 2 propagators: legacy + single-header? I think that simplifies the code. We can do it later.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390660025", "createdAt": "2020-03-10T23:02:20Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAzODgzMA==", "bodyText": "Created #999 to track breaking single and multiple header implementations.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r391038830", "createdAt": "2020-03-11T15:05:16Z", "author": {"login": "MikeGoldsmith"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2MDAyNQ=="}, "originalCommit": {"oid": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTAxNjk4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMzowMzo0MVrOF0kBcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNTowODoxNVrOF07P5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2MDQ2NQ==", "bodyText": "Based on my understanding sampled is present if parts.length is 3 or 4 :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r390660465", "createdAt": "2020-03-10T23:03:41Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    if (singleHeader) {\n+      return getSpanContextFromSingleHeader(carrier, getter);\n+    } else {\n+      return getSpanContextFromMultipleHeaders(carrier, getter);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C /*>>> extends @NonNull Object*/> SpanContext getSpanContextFromSingleHeader(\n+      C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, COMBINED_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      logger.info(\n+          \"Missing or empty combined header: \"\n+              + COMBINED_HEADER\n+              + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    // must have between 2 and 4 hyphen delimieted parts:\n+    //   traceId-spanId-sampled-parentSpanId (last two are optional)\n+    // NOTE: we do not use parentSpanId\n+    String[] parts = value.split(COMBINED_HEADER_DELIMITER);\n+    if (parts.length < 2 || parts.length > 4) {\n+      logger.info(\n+          \"Invalid combined header '\" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String traceId = parts[0];\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String spanId = parts[1];\n+    if (!isSpanIdValid(spanId)) {\n+      logger.info(\n+          \"Invalid SpanId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String sampled = parts.length == 3 ? parts[2] : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0MDk5Nw==", "bodyText": "You're correct. We need to check the sampled string if we have three or more items in the array.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/979#discussion_r391040997", "createdAt": "2020-03-11T15:08:15Z", "author": {"login": "MikeGoldsmith"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/B3Propagator.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the B3 propagation protocol. See <a\n+ * href=https://github.com/openzipkin/b3-propagation>openzipkin/b3-propagation</a>.\n+ */\n+@Immutable\n+public class B3Propagator implements HttpTextFormat<SpanContext> {\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"X-B3-TraceId\";\n+  static final String SPAN_ID_HEADER = \"X-B3-SpanId\";\n+  static final String SAMPLED_HEADER = \"X-B3-Sampled\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String COMBINED_HEADER = \"b3\";\n+  static final String COMBINED_HEADER_DELIMITER = \"-\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+\n+  private static final List<String> FIELDS =\n+      Collections.unmodifiableList(Arrays.asList(TRACE_ID_HEADER, SPAN_ID_HEADER, SAMPLED_HEADER));\n+\n+  private final boolean singleHeader;\n+\n+  /** Creates a new instance of {@link B3Propagator}. Defaults to use multiple headers. */\n+  public B3Propagator() {\n+    this(false);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link B3Propagator}.\n+   *\n+   * @param singleHeader whether to use single or multiple headers.\n+   */\n+  public B3Propagator(boolean singleHeader) {\n+    this.singleHeader = singleHeader;\n+  }\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(SpanContext spanContext, C carrier, Setter<C> setter) {\n+    checkNotNull(spanContext, \"spanContext\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    if (singleHeader) {\n+      setter.set(\n+          carrier,\n+          COMBINED_HEADER,\n+          spanContext.getTraceId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + spanContext.getSpanId().toLowerBase16()\n+              + COMBINED_HEADER_DELIMITER\n+              + sampled);\n+    } else {\n+      setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n+      setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+      setter.set(carrier, SAMPLED_HEADER, sampled);\n+    }\n+  }\n+\n+  @Override\n+  public <C /*>>> extends @NonNull Object*/> SpanContext extract(C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    if (singleHeader) {\n+      return getSpanContextFromSingleHeader(carrier, getter);\n+    } else {\n+      return getSpanContextFromMultipleHeaders(carrier, getter);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C /*>>> extends @NonNull Object*/> SpanContext getSpanContextFromSingleHeader(\n+      C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, COMBINED_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      logger.info(\n+          \"Missing or empty combined header: \"\n+              + COMBINED_HEADER\n+              + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    // must have between 2 and 4 hyphen delimieted parts:\n+    //   traceId-spanId-sampled-parentSpanId (last two are optional)\n+    // NOTE: we do not use parentSpanId\n+    String[] parts = value.split(COMBINED_HEADER_DELIMITER);\n+    if (parts.length < 2 || parts.length > 4) {\n+      logger.info(\n+          \"Invalid combined header '\" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String traceId = parts[0];\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String spanId = parts[1];\n+    if (!isSpanIdValid(spanId)) {\n+      logger.info(\n+          \"Invalid SpanId in B3 header: \" + COMBINED_HEADER + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String sampled = parts.length == 3 ? parts[2] : null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2MDQ2NQ=="}, "originalCommit": {"oid": "685bc9c6229509dd0d9b6322bb862ac12aa9b3ad"}, "originalPosition": 150}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 956, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}