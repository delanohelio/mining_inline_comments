{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1NjQ3Nzk3", "number": 2007, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNDozNzoxOVrOE1fs8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNDozOTo1OVrOE1funw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NTI5Mzk0OnYy", "diffSide": "RIGHT", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/BatchRecorderSdk.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNDozNzoxOVrOHtzQuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxOTowODoxMlrOHuSL_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc4NzgzNQ==", "bodyText": "If I'm reading this right, I think there's less code duplication if we have the loop on the outside of the instanceof checks", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2007#discussion_r517787835", "createdAt": "2020-11-05T04:37:19Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/BatchRecorderSdk.java", "diffHunk": "@@ -10,61 +10,105 @@\n import io.opentelemetry.api.metrics.DoubleCounter;\n import io.opentelemetry.api.metrics.DoubleUpDownCounter;\n import io.opentelemetry.api.metrics.DoubleValueRecorder;\n+import io.opentelemetry.api.metrics.Instrument;\n import io.opentelemetry.api.metrics.LongCounter;\n import io.opentelemetry.api.metrics.LongUpDownCounter;\n import io.opentelemetry.api.metrics.LongValueRecorder;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n /**\n  * Minimal implementation of the {@link BatchRecorder} that simply redirects the calls to the\n  * instruments.\n- *\n- * <p>TODO: Add an async queue processing to process batch records.\n  */\n final class BatchRecorderSdk implements BatchRecorder {\n   private final Labels labelSet;\n \n+  private volatile Map<Instrument, List<Number>> recordings = new HashMap<>();\n+  private volatile Map<Instrument, List<Number>> previousRecordings = new HashMap<>();\n+\n   BatchRecorderSdk(String... keyValuePairs) {\n     this.labelSet = Labels.of(keyValuePairs);\n   }\n \n   @Override\n   public BatchRecorder put(LongValueRecorder valueRecorder, long value) {\n-    valueRecorder.record(value, labelSet);\n+    recordings.computeIfAbsent(valueRecorder, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(DoubleValueRecorder valueRecorder, double value) {\n-    valueRecorder.record(value, labelSet);\n+    recordings.computeIfAbsent(valueRecorder, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(LongCounter counter, long value) {\n-    counter.add(value, labelSet);\n+    recordings.computeIfAbsent(counter, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(DoubleCounter counter, double value) {\n-    counter.add(value, labelSet);\n+    recordings.computeIfAbsent(counter, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(LongUpDownCounter upDownCounter, long value) {\n-    upDownCounter.add(value, labelSet);\n+    recordings.computeIfAbsent(upDownCounter, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(DoubleUpDownCounter upDownCounter, double value) {\n-    upDownCounter.add(value, labelSet);\n+    recordings.computeIfAbsent(upDownCounter, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public void record() {\n-    // No-op in this minimal implementation.\n+    previousRecordings.clear();\n+\n+    Map<Instrument, List<Number>> temp = recordings;\n+    recordings = previousRecordings;\n+    previousRecordings = temp;\n+\n+    previousRecordings.forEach(\n+        (instrument, numbers) -> {\n+          if (instrument instanceof DoubleUpDownCounter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "743ec823e5faae9f20f9deb1f2bbeb286ea3c281"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc5MzMyMA==", "bodyText": "another thing I went back and forth on a couple times. I doubt it makes much difference performance-wise, so if you think it's clearer the other way, happy to change it.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2007#discussion_r517793320", "createdAt": "2020-11-05T04:59:48Z", "author": {"login": "jkwatson"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/BatchRecorderSdk.java", "diffHunk": "@@ -10,61 +10,105 @@\n import io.opentelemetry.api.metrics.DoubleCounter;\n import io.opentelemetry.api.metrics.DoubleUpDownCounter;\n import io.opentelemetry.api.metrics.DoubleValueRecorder;\n+import io.opentelemetry.api.metrics.Instrument;\n import io.opentelemetry.api.metrics.LongCounter;\n import io.opentelemetry.api.metrics.LongUpDownCounter;\n import io.opentelemetry.api.metrics.LongValueRecorder;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n /**\n  * Minimal implementation of the {@link BatchRecorder} that simply redirects the calls to the\n  * instruments.\n- *\n- * <p>TODO: Add an async queue processing to process batch records.\n  */\n final class BatchRecorderSdk implements BatchRecorder {\n   private final Labels labelSet;\n \n+  private volatile Map<Instrument, List<Number>> recordings = new HashMap<>();\n+  private volatile Map<Instrument, List<Number>> previousRecordings = new HashMap<>();\n+\n   BatchRecorderSdk(String... keyValuePairs) {\n     this.labelSet = Labels.of(keyValuePairs);\n   }\n \n   @Override\n   public BatchRecorder put(LongValueRecorder valueRecorder, long value) {\n-    valueRecorder.record(value, labelSet);\n+    recordings.computeIfAbsent(valueRecorder, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(DoubleValueRecorder valueRecorder, double value) {\n-    valueRecorder.record(value, labelSet);\n+    recordings.computeIfAbsent(valueRecorder, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(LongCounter counter, long value) {\n-    counter.add(value, labelSet);\n+    recordings.computeIfAbsent(counter, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(DoubleCounter counter, double value) {\n-    counter.add(value, labelSet);\n+    recordings.computeIfAbsent(counter, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(LongUpDownCounter upDownCounter, long value) {\n-    upDownCounter.add(value, labelSet);\n+    recordings.computeIfAbsent(upDownCounter, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(DoubleUpDownCounter upDownCounter, double value) {\n-    upDownCounter.add(value, labelSet);\n+    recordings.computeIfAbsent(upDownCounter, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public void record() {\n-    // No-op in this minimal implementation.\n+    previousRecordings.clear();\n+\n+    Map<Instrument, List<Number>> temp = recordings;\n+    recordings = previousRecordings;\n+    previousRecordings = temp;\n+\n+    previousRecordings.forEach(\n+        (instrument, numbers) -> {\n+          if (instrument instanceof DoubleUpDownCounter) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc4NzgzNQ=="}, "originalCommit": {"oid": "743ec823e5faae9f20f9deb1f2bbeb286ea3c281"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NDUyNg==", "bodyText": "done", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2007#discussion_r518294526", "createdAt": "2020-11-05T19:08:12Z", "author": {"login": "jkwatson"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/BatchRecorderSdk.java", "diffHunk": "@@ -10,61 +10,105 @@\n import io.opentelemetry.api.metrics.DoubleCounter;\n import io.opentelemetry.api.metrics.DoubleUpDownCounter;\n import io.opentelemetry.api.metrics.DoubleValueRecorder;\n+import io.opentelemetry.api.metrics.Instrument;\n import io.opentelemetry.api.metrics.LongCounter;\n import io.opentelemetry.api.metrics.LongUpDownCounter;\n import io.opentelemetry.api.metrics.LongValueRecorder;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n /**\n  * Minimal implementation of the {@link BatchRecorder} that simply redirects the calls to the\n  * instruments.\n- *\n- * <p>TODO: Add an async queue processing to process batch records.\n  */\n final class BatchRecorderSdk implements BatchRecorder {\n   private final Labels labelSet;\n \n+  private volatile Map<Instrument, List<Number>> recordings = new HashMap<>();\n+  private volatile Map<Instrument, List<Number>> previousRecordings = new HashMap<>();\n+\n   BatchRecorderSdk(String... keyValuePairs) {\n     this.labelSet = Labels.of(keyValuePairs);\n   }\n \n   @Override\n   public BatchRecorder put(LongValueRecorder valueRecorder, long value) {\n-    valueRecorder.record(value, labelSet);\n+    recordings.computeIfAbsent(valueRecorder, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(DoubleValueRecorder valueRecorder, double value) {\n-    valueRecorder.record(value, labelSet);\n+    recordings.computeIfAbsent(valueRecorder, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(LongCounter counter, long value) {\n-    counter.add(value, labelSet);\n+    recordings.computeIfAbsent(counter, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(DoubleCounter counter, double value) {\n-    counter.add(value, labelSet);\n+    recordings.computeIfAbsent(counter, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(LongUpDownCounter upDownCounter, long value) {\n-    upDownCounter.add(value, labelSet);\n+    recordings.computeIfAbsent(upDownCounter, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(DoubleUpDownCounter upDownCounter, double value) {\n-    upDownCounter.add(value, labelSet);\n+    recordings.computeIfAbsent(upDownCounter, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public void record() {\n-    // No-op in this minimal implementation.\n+    previousRecordings.clear();\n+\n+    Map<Instrument, List<Number>> temp = recordings;\n+    recordings = previousRecordings;\n+    previousRecordings = temp;\n+\n+    previousRecordings.forEach(\n+        (instrument, numbers) -> {\n+          if (instrument instanceof DoubleUpDownCounter) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc4NzgzNQ=="}, "originalCommit": {"oid": "743ec823e5faae9f20f9deb1f2bbeb286ea3c281"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0NTI5ODIzOnYy", "diffSide": "RIGHT", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/BatchRecorderSdk.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwNDozOTo1OVrOHtzTJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxOTowNzo0OVrOHuSLHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc4ODQ1NQ==", "bodyText": "I'm guessing this can be called concurrently - so the maps need to be ConcurrentHashMap and the value something synchronized, probably BlockingQueue.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2007#discussion_r517788455", "createdAt": "2020-11-05T04:39:59Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/BatchRecorderSdk.java", "diffHunk": "@@ -10,61 +10,105 @@\n import io.opentelemetry.api.metrics.DoubleCounter;\n import io.opentelemetry.api.metrics.DoubleUpDownCounter;\n import io.opentelemetry.api.metrics.DoubleValueRecorder;\n+import io.opentelemetry.api.metrics.Instrument;\n import io.opentelemetry.api.metrics.LongCounter;\n import io.opentelemetry.api.metrics.LongUpDownCounter;\n import io.opentelemetry.api.metrics.LongValueRecorder;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n /**\n  * Minimal implementation of the {@link BatchRecorder} that simply redirects the calls to the\n  * instruments.\n- *\n- * <p>TODO: Add an async queue processing to process batch records.\n  */\n final class BatchRecorderSdk implements BatchRecorder {\n   private final Labels labelSet;\n \n+  private volatile Map<Instrument, List<Number>> recordings = new HashMap<>();\n+  private volatile Map<Instrument, List<Number>> previousRecordings = new HashMap<>();\n+\n   BatchRecorderSdk(String... keyValuePairs) {\n     this.labelSet = Labels.of(keyValuePairs);\n   }\n \n   @Override\n   public BatchRecorder put(LongValueRecorder valueRecorder, long value) {\n-    valueRecorder.record(value, labelSet);\n+    recordings.computeIfAbsent(valueRecorder, instrument -> new ArrayList<>()).add(value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "743ec823e5faae9f20f9deb1f2bbeb286ea3c281"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc4OTI2Mw==", "bodyText": "Though given the primitive types have to be boxed anyways, I think wrapping in our own type would have very low overhead. So instead of two maps, I guess we can use a single queue? Would be easier to reason about.\nprivate static class LongRecording implements Recording {\n  private final Instrument instrument;\n  private final long value;\n}\n\nBlockingQueue<Recoding> recordings;\n\nrecord() {\n  recordings.drainTo(buffer);\n  for (Recording recording : buffer) {\n    ...\n  }", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2007#discussion_r517789263", "createdAt": "2020-11-05T04:43:19Z", "author": {"login": "anuraaga"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/BatchRecorderSdk.java", "diffHunk": "@@ -10,61 +10,105 @@\n import io.opentelemetry.api.metrics.DoubleCounter;\n import io.opentelemetry.api.metrics.DoubleUpDownCounter;\n import io.opentelemetry.api.metrics.DoubleValueRecorder;\n+import io.opentelemetry.api.metrics.Instrument;\n import io.opentelemetry.api.metrics.LongCounter;\n import io.opentelemetry.api.metrics.LongUpDownCounter;\n import io.opentelemetry.api.metrics.LongValueRecorder;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n /**\n  * Minimal implementation of the {@link BatchRecorder} that simply redirects the calls to the\n  * instruments.\n- *\n- * <p>TODO: Add an async queue processing to process batch records.\n  */\n final class BatchRecorderSdk implements BatchRecorder {\n   private final Labels labelSet;\n \n+  private volatile Map<Instrument, List<Number>> recordings = new HashMap<>();\n+  private volatile Map<Instrument, List<Number>> previousRecordings = new HashMap<>();\n+\n   BatchRecorderSdk(String... keyValuePairs) {\n     this.labelSet = Labels.of(keyValuePairs);\n   }\n \n   @Override\n   public BatchRecorder put(LongValueRecorder valueRecorder, long value) {\n-    valueRecorder.record(value, labelSet);\n+    recordings.computeIfAbsent(valueRecorder, instrument -> new ArrayList<>()).add(value);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc4ODQ1NQ=="}, "originalCommit": {"oid": "743ec823e5faae9f20f9deb1f2bbeb286ea3c281"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc5MzM3Mg==", "bodyText": "yeah, I went back and forth about this. I'd be happy to change it to something like that. And, yes, you're totally right about the concurrent hashmap bit.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2007#discussion_r517793372", "createdAt": "2020-11-05T04:59:56Z", "author": {"login": "jkwatson"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/BatchRecorderSdk.java", "diffHunk": "@@ -10,61 +10,105 @@\n import io.opentelemetry.api.metrics.DoubleCounter;\n import io.opentelemetry.api.metrics.DoubleUpDownCounter;\n import io.opentelemetry.api.metrics.DoubleValueRecorder;\n+import io.opentelemetry.api.metrics.Instrument;\n import io.opentelemetry.api.metrics.LongCounter;\n import io.opentelemetry.api.metrics.LongUpDownCounter;\n import io.opentelemetry.api.metrics.LongValueRecorder;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n /**\n  * Minimal implementation of the {@link BatchRecorder} that simply redirects the calls to the\n  * instruments.\n- *\n- * <p>TODO: Add an async queue processing to process batch records.\n  */\n final class BatchRecorderSdk implements BatchRecorder {\n   private final Labels labelSet;\n \n+  private volatile Map<Instrument, List<Number>> recordings = new HashMap<>();\n+  private volatile Map<Instrument, List<Number>> previousRecordings = new HashMap<>();\n+\n   BatchRecorderSdk(String... keyValuePairs) {\n     this.labelSet = Labels.of(keyValuePairs);\n   }\n \n   @Override\n   public BatchRecorder put(LongValueRecorder valueRecorder, long value) {\n-    valueRecorder.record(value, labelSet);\n+    recordings.computeIfAbsent(valueRecorder, instrument -> new ArrayList<>()).add(value);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc4ODQ1NQ=="}, "originalCommit": {"oid": "743ec823e5faae9f20f9deb1f2bbeb286ea3c281"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NDMwMw==", "bodyText": "@anuraaga take a look now.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2007#discussion_r518294303", "createdAt": "2020-11-05T19:07:49Z", "author": {"login": "jkwatson"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/BatchRecorderSdk.java", "diffHunk": "@@ -10,61 +10,105 @@\n import io.opentelemetry.api.metrics.DoubleCounter;\n import io.opentelemetry.api.metrics.DoubleUpDownCounter;\n import io.opentelemetry.api.metrics.DoubleValueRecorder;\n+import io.opentelemetry.api.metrics.Instrument;\n import io.opentelemetry.api.metrics.LongCounter;\n import io.opentelemetry.api.metrics.LongUpDownCounter;\n import io.opentelemetry.api.metrics.LongValueRecorder;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n /**\n  * Minimal implementation of the {@link BatchRecorder} that simply redirects the calls to the\n  * instruments.\n- *\n- * <p>TODO: Add an async queue processing to process batch records.\n  */\n final class BatchRecorderSdk implements BatchRecorder {\n   private final Labels labelSet;\n \n+  private volatile Map<Instrument, List<Number>> recordings = new HashMap<>();\n+  private volatile Map<Instrument, List<Number>> previousRecordings = new HashMap<>();\n+\n   BatchRecorderSdk(String... keyValuePairs) {\n     this.labelSet = Labels.of(keyValuePairs);\n   }\n \n   @Override\n   public BatchRecorder put(LongValueRecorder valueRecorder, long value) {\n-    valueRecorder.record(value, labelSet);\n+    recordings.computeIfAbsent(valueRecorder, instrument -> new ArrayList<>()).add(value);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc4ODQ1NQ=="}, "originalCommit": {"oid": "743ec823e5faae9f20f9deb1f2bbeb286ea3c281"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1887, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}