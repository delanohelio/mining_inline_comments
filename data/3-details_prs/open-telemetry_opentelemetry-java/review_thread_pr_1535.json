{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3MDQ4Mjk4", "number": 1535, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMjo0NzoyMlrOEYUPmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMjo0OTowN1rOEYUQxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzOTMyOTU0OnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/AbstractAggregator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMjo0NzoyMlrOHAluMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxODo0MDo1MFrOHA_idA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4MDA4Mw==", "bodyText": "Since we're not using CAS, this can just be volatile boolean.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1535#discussion_r470380083", "createdAt": "2020-08-14T02:47:22Z", "author": {"login": "anuraaga"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/AbstractAggregator.java", "diffHunk": "@@ -16,14 +16,22 @@\n \n package io.opentelemetry.sdk.metrics.aggregator;\n \n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n abstract class AbstractAggregator implements Aggregator {\n+  // Note: This is not 100% thread-safe. There is a race condition where recordings can\n+  // be made in the moment between the reset and the setting of this field's value. In those\n+  // cases, it is possible that a recording could be missed in a given recording interval, but\n+  // it should be picked up in the next, assuming that more recordings are being made.\n+  private final AtomicBoolean hasRecordings = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "915b9d8d8809401bf2b92919f8171fe4d56bf8a8"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc5NTYzMQ==", "bodyText": "true enough. I tend to usually not use volatile, rather than the Atomics, but I don't have a really strong feeling either way. I think the performance is pretty much equal, IIRC. Although I have this feeling that that changed with java 14 and Atomics got much worse (/me goes to read his Java Specialists newsletters).", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1535#discussion_r470795631", "createdAt": "2020-08-14T18:32:09Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/AbstractAggregator.java", "diffHunk": "@@ -16,14 +16,22 @@\n \n package io.opentelemetry.sdk.metrics.aggregator;\n \n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n abstract class AbstractAggregator implements Aggregator {\n+  // Note: This is not 100% thread-safe. There is a race condition where recordings can\n+  // be made in the moment between the reset and the setting of this field's value. In those\n+  // cases, it is possible that a recording could be missed in a given recording interval, but\n+  // it should be picked up in the next, assuming that more recordings are being made.\n+  private final AtomicBoolean hasRecordings = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4MDA4Mw=="}, "originalCommit": {"oid": "915b9d8d8809401bf2b92919f8171fe4d56bf8a8"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgwMzA2MA==", "bodyText": "updated.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1535#discussion_r470803060", "createdAt": "2020-08-14T18:40:50Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/AbstractAggregator.java", "diffHunk": "@@ -16,14 +16,22 @@\n \n package io.opentelemetry.sdk.metrics.aggregator;\n \n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n abstract class AbstractAggregator implements Aggregator {\n+  // Note: This is not 100% thread-safe. There is a race condition where recordings can\n+  // be made in the moment between the reset and the setting of this field's value. In those\n+  // cases, it is possible that a recording could be missed in a given recording interval, but\n+  // it should be picked up in the next, assuming that more recordings are being made.\n+  private final AtomicBoolean hasRecordings = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4MDA4Mw=="}, "originalCommit": {"oid": "915b9d8d8809401bf2b92919f8171fe4d56bf8a8"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzOTMyOTkxOnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/AbstractAggregator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMjo0NzozNlrOHAlucg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxODo0MDozN1rOHA_hxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4MDE0Ng==", "bodyText": "Isn't it better to set after recording since that's when it actually \"has recordings\"?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1535#discussion_r470380146", "createdAt": "2020-08-14T02:47:36Z", "author": {"login": "anuraaga"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/AbstractAggregator.java", "diffHunk": "@@ -38,12 +46,37 @@ public void mergeToAndReset(Aggregator other) {\n   abstract void doMergeAndReset(Aggregator aggregator);\n \n   @Override\n-  public void recordLong(long value) {\n-    throw new UnsupportedOperationException(\"This Aggregator does not support long values\");\n+  public final void recordLong(long value) {\n+    hasRecordings.set(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "915b9d8d8809401bf2b92919f8171fe4d56bf8a8"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc5MTg1Mg==", "bodyText": "I've gone back and forth several times on this, trying to figure out which leads to the least-bad race condition when it happens. I think you're right, though; I'll swap it around.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1535#discussion_r470791852", "createdAt": "2020-08-14T18:27:40Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/AbstractAggregator.java", "diffHunk": "@@ -38,12 +46,37 @@ public void mergeToAndReset(Aggregator other) {\n   abstract void doMergeAndReset(Aggregator aggregator);\n \n   @Override\n-  public void recordLong(long value) {\n-    throw new UnsupportedOperationException(\"This Aggregator does not support long values\");\n+  public final void recordLong(long value) {\n+    hasRecordings.set(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4MDE0Ng=="}, "originalCommit": {"oid": "915b9d8d8809401bf2b92919f8171fe4d56bf8a8"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgwMjg4NA==", "bodyText": "done. thanks for the close look!", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1535#discussion_r470802884", "createdAt": "2020-08-14T18:40:37Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/AbstractAggregator.java", "diffHunk": "@@ -38,12 +46,37 @@ public void mergeToAndReset(Aggregator other) {\n   abstract void doMergeAndReset(Aggregator aggregator);\n \n   @Override\n-  public void recordLong(long value) {\n-    throw new UnsupportedOperationException(\"This Aggregator does not support long values\");\n+  public final void recordLong(long value) {\n+    hasRecordings.set(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4MDE0Ng=="}, "originalCommit": {"oid": "915b9d8d8809401bf2b92919f8171fe4d56bf8a8"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzOTMzMjUyOnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/Aggregator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMjo0OTowN1rOHAlv5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxODozNDoxNlrOHA_MYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4MDUxNw==", "bodyText": "No particular preference but wondered if isEmpty is more idiomatic", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1535#discussion_r470380517", "createdAt": "2020-08-14T02:49:07Z", "author": {"login": "anuraaga"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/Aggregator.java", "diffHunk": "@@ -57,4 +57,7 @@\n    * @param value the new {@code double} value to be added.\n    */\n   void recordDouble(double value);\n+\n+  /** Whether there have been any recordings since this aggregator has been reset. */\n+  boolean hasRecordings();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "915b9d8d8809401bf2b92919f8171fe4d56bf8a8"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc5NzQwOQ==", "bodyText": "In this case, I don't know that aggregators necessarily have a universal concept of \"emptiness\", so I went with something very semantically clear and domain-specific.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1535#discussion_r470797409", "createdAt": "2020-08-14T18:34:16Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/aggregator/Aggregator.java", "diffHunk": "@@ -57,4 +57,7 @@\n    * @param value the new {@code double} value to be added.\n    */\n   void recordDouble(double value);\n+\n+  /** Whether there have been any recordings since this aggregator has been reset. */\n+  boolean hasRecordings();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4MDUxNw=="}, "originalCommit": {"oid": "915b9d8d8809401bf2b92919f8171fe4d56bf8a8"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1334, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}