{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg4NTM2MjEy", "number": 1658, "title": "Add an OpenTelemetry context mechanism.", "bodyText": "We have had an open issue, #575, to find an alternative to an external dependency for context propagation. As the spec states that for languages with no built in mechanism, like Go, or no obviously popular library, like JS's cls-hooked, we should create our own. So let's follow the spec and move on.\nThe API is heavily inspired by gRPC and Armeria. Much code / docs are borrowed too and I kept license headers in tact to reflect that.\n\nContext is immutable. However, ContextStorage.rootContext() is customizable to allow storing a mutable value at the very earliest point possible, effectively making context mutable if that is needed by a user. One reason someone may do this is to store their context in ours\nattach returns a try-with-resources Scope instead of having a detach\nGetting values is from the context, not from the key (personally find more natural)\nWrappers for pretty much any callback-like type in JDK. If targeting JDK8 could add even more for the completable stuff\nContext storage can be customized using SPI with normal mechanisms, with less of the trickiness of mechanisms like gRPC\n\nI'm thinking of adding line/armeria#2723 to allow customizing at app startup without SPI too, but deferring for now (we're deferring our other stuff too I guess)\n\n\n\nOne key point is that because storage is customizable, this can be used fine with any other context mechanism, it is just the API OpenTelemetry happens to use. If a user prefers a different mechanism, it is not that difficult to delegate our API to them and users can keep on using what they're used to. We can provide extensions implementing using other context propagation libraries anytime.\nGive it a first look to see if it generally looks ok, and I'll add tests, etc.\n/cc @zoercai", "createdAt": "2020-09-17T09:34:45Z", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658", "merged": true, "mergeCommit": {"oid": "21fbb36d81c79d81d63abf0a7a64bc8c4124b941"}, "closed": true, "closedAt": "2020-10-05T08:03:12Z", "author": {"login": "anuraaga"}, "timelineItems": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdJtfPIAH2gAyNDg4NTM2MjEyOjg2MTFlZDk1OThlYjUzMGVmODFmOGU3MzdmOTNmYzI2NWNiMGM1NDQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdPe1isAH2gAyNDg4NTM2MjEyOjYyMTMxZTJmZGRjYjk3Mjc2YmFiZTNjNWIyMjYyYzQyNTkxMDIyMjM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8611ed9598eb530ef81f8e737f93fc265cb0c544", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/8611ed9598eb530ef81f8e737f93fc265cb0c544", "committedDate": "2020-09-17T09:22:24Z", "message": "Add an OpenTelemetry context mechanism."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwODQ3MjEy", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#pullrequestreview-490847212", "createdAt": "2020-09-17T17:50:17Z", "commit": {"oid": "8611ed9598eb530ef81f8e737f93fc265cb0c544"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzo1MDoxN1rOHTujlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzo1MDoxN1rOHTujlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0Nzc2Ng==", "bodyText": "Nice work.\nWhat is the motivation for exposing the root?  When is this useful?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r490447766", "createdAt": "2020-09-17T17:50:17Z", "author": {"login": "tylerbenson"}, "path": "extensions/context/src/main/java/io/opentelemetry/context/Context.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2015 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.context;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A context propagation mechanism which can carry scoped-values across API boundaries and between\n+ * threads.\n+ *\n+ * <p>A Context object can be {@link #attach attached} to the {@link ContextStorage}, which\n+ * effectively forms a <b>scope</b> for the context. The scope is bound to the current thread.\n+ * Within a scope, its Context is accessible even across API boundaries, through {@link #current}.\n+ * The scope is later exited by {@link Scope#close()} closing} the scope.\n+ *\n+ * <p>Context objects are immutable and inherit state from their parent. To add or overwrite the\n+ * current state a new context object must be created and then attached, replacing the previously\n+ * bound context. For example:\n+ *\n+ * <pre>\n+ *   Context withCredential = Context.current().withValue(CRED_KEY, cred);\n+ *   withCredential.wrap(new Runnable() {\n+ *     public void run() {\n+ *        readUserRecords(userId, CRED_KEY.get());\n+ *     }\n+ *   }).run();\n+ * </pre>\n+ *\n+ *\n+ *\n+ * <p>Notes and cautions on use:\n+ *\n+ * <ul>\n+ *   <li>Every {@code attach()} must be followed by a {@code Scope#close()}. Breaking these rules\n+ *       may lead to memory leaks.\n+ *   <li>While Context objects are immutable they do not place such a restriction on the state they\n+ *       store.\n+ *   <li>Context is not intended for passing optional parameters to an API and developers should\n+ *       take care to avoid excessive dependence on context when designing an API.\n+ * </ul>\n+ */\n+public final class Context {\n+\n+  /** Returns the root {@link Context} which all other {@link Context} are derived from. */\n+  public static Context root() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8611ed9598eb530ef81f8e737f93fc265cb0c544"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwODQ5NTY4", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#pullrequestreview-490849568", "createdAt": "2020-09-17T17:53:28Z", "commit": {"oid": "8611ed9598eb530ef81f8e737f93fc265cb0c544"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzo1MzoyOFrOHTuqgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzo1MzoyOFrOHTuqgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0OTUzNg==", "bodyText": "Do we need all the overrides at this point? I'd like to figure out how minimal we can make this API for starters.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r490449536", "createdAt": "2020-09-17T17:53:28Z", "author": {"login": "jkwatson"}, "path": "extensions/context/src/main/java/io/opentelemetry/context/Context.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2015 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.context;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A context propagation mechanism which can carry scoped-values across API boundaries and between\n+ * threads.\n+ *\n+ * <p>A Context object can be {@link #attach attached} to the {@link ContextStorage}, which\n+ * effectively forms a <b>scope</b> for the context. The scope is bound to the current thread.\n+ * Within a scope, its Context is accessible even across API boundaries, through {@link #current}.\n+ * The scope is later exited by {@link Scope#close()} closing} the scope.\n+ *\n+ * <p>Context objects are immutable and inherit state from their parent. To add or overwrite the\n+ * current state a new context object must be created and then attached, replacing the previously\n+ * bound context. For example:\n+ *\n+ * <pre>\n+ *   Context withCredential = Context.current().withValue(CRED_KEY, cred);\n+ *   withCredential.wrap(new Runnable() {\n+ *     public void run() {\n+ *        readUserRecords(userId, CRED_KEY.get());\n+ *     }\n+ *   }).run();\n+ * </pre>\n+ *\n+ *\n+ *\n+ * <p>Notes and cautions on use:\n+ *\n+ * <ul>\n+ *   <li>Every {@code attach()} must be followed by a {@code Scope#close()}. Breaking these rules\n+ *       may lead to memory leaks.\n+ *   <li>While Context objects are immutable they do not place such a restriction on the state they\n+ *       store.\n+ *   <li>Context is not intended for passing optional parameters to an API and developers should\n+ *       take care to avoid excessive dependence on context when designing an API.\n+ * </ul>\n+ */\n+public final class Context {\n+\n+  /** Returns the root {@link Context} which all other {@link Context} are derived from. */\n+  public static Context root() {\n+    return storage().rootContext();\n+  }\n+\n+  /** Return the context associated with the current scope. */\n+  public static Context current() {\n+    return storage().current();\n+  }\n+\n+  /**\n+   * Returns the default {@link ContextStorage} used to attach {@link Context}s to scopes of\n+   * execution. Should only be used when defining your own {@link ContextStorage} in case you want\n+   * to delegate functionality to the default implementation.\n+   */\n+  public static ContextStorage threadLocalStorage() {\n+    return ThreadLocalContextStorage.INSTANCE;\n+  }\n+\n+  static ContextStorage storage() {\n+    return LazyStorage.storage;\n+  }\n+\n+  private final PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> entries;\n+\n+  private Context(PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> entries) {\n+    this.entries = entries;\n+  }\n+\n+  Context() {\n+    entries = null;\n+  }\n+\n+  /**\n+   * Returns the value stored in this {@link Context} for the given {@link ContextKey}, or {@code\n+   * null} if there is no value for the key in this context.\n+   */\n+  @Nullable\n+  public <V> V getValue(ContextKey<V> key) {\n+    // Because withValue enforces the value for a key is its type, this is always safe.\n+    @SuppressWarnings(\"unchecked\")\n+    V value = (V) PersistentHashArrayMappedTrie.get(entries, key);\n+    return value;\n+  }\n+\n+  /**\n+   * Returns a new context with the given key value set.\n+   *\n+   * <pre>{@code\n+   * Context withCredential = Context.current().withValue(CRED_KEY, cred);\n+   * withCredential.run(new Runnable() {\n+   *   public void run() {\n+   *      readUserRecords(userId, CRED_KEY.get());\n+   *   }\n+   * });\n+   * }</pre>\n+   *\n+   * <p>Note that multiple calls to {@link #withValue(ContextKey, Object)} can be chained together.\n+   * That is,\n+   *\n+   * <pre>\n+   * context.withValues(K1, V1, K2, V2);\n+   * // is the same as\n+   * context.withValue(K1, V1).withValue(K2, V2);\n+   * </pre>\n+   *\n+   * <p>Nonetheless, {@link Context} should not be treated like a general purpose map with a large\n+   * number of keys and values \u2014 combine multiple related items together into a single key instead\n+   * of separating them. But if the items are unrelated, have separate keys for them.\n+   */\n+  public <V> Context withValue(ContextKey<V> k1, V v1) {\n+    PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> newEntries =\n+        PersistentHashArrayMappedTrie.put(entries, k1, v1);\n+    return new Context(newEntries);\n+  }\n+\n+  /** Returns a new context with the given key value set. */\n+  public <V1, V2> Context withValues(ContextKey<V1> k1, V1 v1, ContextKey<V2> k2, V2 v2) {\n+    PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> newEntries =\n+        PersistentHashArrayMappedTrie.put(entries, k1, v1);\n+    newEntries = PersistentHashArrayMappedTrie.put(newEntries, k2, v2);\n+    return new Context(newEntries);\n+  }\n+\n+  /** Returns a new context with the given key value set. */\n+  public <V1, V2, V3> Context withValues(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8611ed9598eb530ef81f8e737f93fc265cb0c544"}, "originalPosition": 161}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwOTkyNjcz", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#pullrequestreview-490992673", "createdAt": "2020-09-17T21:12:21Z", "commit": {"oid": "8611ed9598eb530ef81f8e737f93fc265cb0c544"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMToxMjoyMlrOHT1twQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMToxMjoyMlrOHT1twQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU2NTA1Nw==", "bodyText": "+1. Definitely something I've always wanted to have in grpc.Context", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r490565057", "createdAt": "2020-09-17T21:12:22Z", "author": {"login": "carlosalberto"}, "path": "extensions/context/src/main/java/io/opentelemetry/context/Context.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2015 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.context;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A context propagation mechanism which can carry scoped-values across API boundaries and between\n+ * threads.\n+ *\n+ * <p>A Context object can be {@link #attach attached} to the {@link ContextStorage}, which\n+ * effectively forms a <b>scope</b> for the context. The scope is bound to the current thread.\n+ * Within a scope, its Context is accessible even across API boundaries, through {@link #current}.\n+ * The scope is later exited by {@link Scope#close()} closing} the scope.\n+ *\n+ * <p>Context objects are immutable and inherit state from their parent. To add or overwrite the\n+ * current state a new context object must be created and then attached, replacing the previously\n+ * bound context. For example:\n+ *\n+ * <pre>\n+ *   Context withCredential = Context.current().withValue(CRED_KEY, cred);\n+ *   withCredential.wrap(new Runnable() {\n+ *     public void run() {\n+ *        readUserRecords(userId, CRED_KEY.get());\n+ *     }\n+ *   }).run();\n+ * </pre>\n+ *\n+ *\n+ *\n+ * <p>Notes and cautions on use:\n+ *\n+ * <ul>\n+ *   <li>Every {@code attach()} must be followed by a {@code Scope#close()}. Breaking these rules\n+ *       may lead to memory leaks.\n+ *   <li>While Context objects are immutable they do not place such a restriction on the state they\n+ *       store.\n+ *   <li>Context is not intended for passing optional parameters to an API and developers should\n+ *       take care to avoid excessive dependence on context when designing an API.\n+ * </ul>\n+ */\n+public final class Context {\n+\n+  /** Returns the root {@link Context} which all other {@link Context} are derived from. */\n+  public static Context root() {\n+    return storage().rootContext();\n+  }\n+\n+  /** Return the context associated with the current scope. */\n+  public static Context current() {\n+    return storage().current();\n+  }\n+\n+  /**\n+   * Returns the default {@link ContextStorage} used to attach {@link Context}s to scopes of\n+   * execution. Should only be used when defining your own {@link ContextStorage} in case you want\n+   * to delegate functionality to the default implementation.\n+   */\n+  public static ContextStorage threadLocalStorage() {\n+    return ThreadLocalContextStorage.INSTANCE;\n+  }\n+\n+  static ContextStorage storage() {\n+    return LazyStorage.storage;\n+  }\n+\n+  private final PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> entries;\n+\n+  private Context(PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> entries) {\n+    this.entries = entries;\n+  }\n+\n+  Context() {\n+    entries = null;\n+  }\n+\n+  /**\n+   * Returns the value stored in this {@link Context} for the given {@link ContextKey}, or {@code\n+   * null} if there is no value for the key in this context.\n+   */\n+  @Nullable\n+  public <V> V getValue(ContextKey<V> key) {\n+    // Because withValue enforces the value for a key is its type, this is always safe.\n+    @SuppressWarnings(\"unchecked\")\n+    V value = (V) PersistentHashArrayMappedTrie.get(entries, key);\n+    return value;\n+  }\n+\n+  /**\n+   * Returns a new context with the given key value set.\n+   *\n+   * <pre>{@code\n+   * Context withCredential = Context.current().withValue(CRED_KEY, cred);\n+   * withCredential.run(new Runnable() {\n+   *   public void run() {\n+   *      readUserRecords(userId, CRED_KEY.get());\n+   *   }\n+   * });\n+   * }</pre>\n+   *\n+   * <p>Note that multiple calls to {@link #withValue(ContextKey, Object)} can be chained together.\n+   * That is,\n+   *\n+   * <pre>\n+   * context.withValues(K1, V1, K2, V2);\n+   * // is the same as\n+   * context.withValue(K1, V1).withValue(K2, V2);\n+   * </pre>\n+   *\n+   * <p>Nonetheless, {@link Context} should not be treated like a general purpose map with a large\n+   * number of keys and values \u2014 combine multiple related items together into a single key instead\n+   * of separating them. But if the items are unrelated, have separate keys for them.\n+   */\n+  public <V> Context withValue(ContextKey<V> k1, V v1) {\n+    PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> newEntries =\n+        PersistentHashArrayMappedTrie.put(entries, k1, v1);\n+    return new Context(newEntries);\n+  }\n+\n+  /** Returns a new context with the given key value set. */\n+  public <V1, V2> Context withValues(ContextKey<V1> k1, V1 v1, ContextKey<V2> k2, V2 v2) {\n+    PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> newEntries =\n+        PersistentHashArrayMappedTrie.put(entries, k1, v1);\n+    newEntries = PersistentHashArrayMappedTrie.put(newEntries, k2, v2);\n+    return new Context(newEntries);\n+  }\n+\n+  /** Returns a new context with the given key value set. */\n+  public <V1, V2, V3> Context withValues(\n+      ContextKey<V1> k1, V1 v1, ContextKey<V2> k2, V2 v2, ContextKey<V3> k3, V3 v3) {\n+    PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> newEntries =\n+        PersistentHashArrayMappedTrie.put(entries, k1, v1);\n+    newEntries = PersistentHashArrayMappedTrie.put(newEntries, k2, v2);\n+    newEntries = PersistentHashArrayMappedTrie.put(newEntries, k3, v3);\n+    return new Context(newEntries);\n+  }\n+\n+  /**\n+   * Create a new context with the given key value set.\n+   *\n+   * <p>For more than 4 key-value pairs, note that multiple calls to {@link #withValue} can be\n+   * chained together. That is,\n+   *\n+   * <pre>\n+   * context.withValues(K1, V1, K2, V2);\n+   * // is the same as\n+   * context.withValue(K1, V1).withValue(K2, V2);\n+   * </pre>\n+   *\n+   * <p>Nonetheless, {@link Context} should not be treated like a general purpose map with a large\n+   * number of keys and values \u2014 combine multiple related items together into a single key instead\n+   * of separating them. But if the items are unrelated, have separate keys for them.\n+   */\n+  public <V1, V2, V3, V4> Context withValues(\n+      ContextKey<V1> k1,\n+      V1 v1,\n+      ContextKey<V2> k2,\n+      V2 v2,\n+      ContextKey<V3> k3,\n+      V3 v3,\n+      ContextKey<V4> k4,\n+      V4 v4) {\n+    PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> newEntries =\n+        PersistentHashArrayMappedTrie.put(entries, k1, v1);\n+    newEntries = PersistentHashArrayMappedTrie.put(newEntries, k2, v2);\n+    newEntries = PersistentHashArrayMappedTrie.put(newEntries, k3, v3);\n+    newEntries = PersistentHashArrayMappedTrie.put(newEntries, k4, v4);\n+    return new Context(newEntries);\n+  }\n+\n+  /**\n+   * Attaches this {@link Context}, making it the current {@link Context} and returns a {@link\n+   * Scope} which corresponds to the scope of execution this context is attached for. {@link\n+   * Context#current()} will return this {@link Context} until {@link Scope#close()} is called.\n+   * {@link Scope#close()} must be called to properly restore the previous context from before this\n+   * scope of execution or context will not work correctly. It is recommended to use\n+   * try-with-resources to call {@link Scope#close()} automatically.\n+   *\n+   * <pre>{@code\n+   * Context prevCtx = Context.current();\n+   * try (Scope ignored = ctx.attach()) {\n+   *   assert Context.current() == ctx;\n+   *   ...\n+   * }\n+   * assert Context.current() == prevCtx;\n+   * }</pre>\n+   */\n+  public Scope attach() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8611ed9598eb530ef81f8e737f93fc265cb0c544"}, "originalPosition": 220}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxMDYxNTk5", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#pullrequestreview-491061599", "createdAt": "2020-09-17T23:50:06Z", "commit": {"oid": "8611ed9598eb530ef81f8e737f93fc265cb0c544"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMzo1MDowNlrOHT5PUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMzo1Mjo0NlrOHT5SHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyMjgwMQ==", "bodyText": "We use it in instrumentation unfortunately. We're not supposed to, but there are cases where our automatic propagation doesn't work correctly and we have to force a new local root\nhttps://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/7e41b516ee793f2cb12c4f0893ec00c66837f7ee/instrumentation-api/src/main/java/io/opentelemetry/instrumentation/api/tracer/HttpServerTracer.java#L257", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r490622801", "createdAt": "2020-09-17T23:50:06Z", "author": {"login": "anuraaga"}, "path": "extensions/context/src/main/java/io/opentelemetry/context/Context.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2015 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.context;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A context propagation mechanism which can carry scoped-values across API boundaries and between\n+ * threads.\n+ *\n+ * <p>A Context object can be {@link #attach attached} to the {@link ContextStorage}, which\n+ * effectively forms a <b>scope</b> for the context. The scope is bound to the current thread.\n+ * Within a scope, its Context is accessible even across API boundaries, through {@link #current}.\n+ * The scope is later exited by {@link Scope#close()} closing} the scope.\n+ *\n+ * <p>Context objects are immutable and inherit state from their parent. To add or overwrite the\n+ * current state a new context object must be created and then attached, replacing the previously\n+ * bound context. For example:\n+ *\n+ * <pre>\n+ *   Context withCredential = Context.current().withValue(CRED_KEY, cred);\n+ *   withCredential.wrap(new Runnable() {\n+ *     public void run() {\n+ *        readUserRecords(userId, CRED_KEY.get());\n+ *     }\n+ *   }).run();\n+ * </pre>\n+ *\n+ *\n+ *\n+ * <p>Notes and cautions on use:\n+ *\n+ * <ul>\n+ *   <li>Every {@code attach()} must be followed by a {@code Scope#close()}. Breaking these rules\n+ *       may lead to memory leaks.\n+ *   <li>While Context objects are immutable they do not place such a restriction on the state they\n+ *       store.\n+ *   <li>Context is not intended for passing optional parameters to an API and developers should\n+ *       take care to avoid excessive dependence on context when designing an API.\n+ * </ul>\n+ */\n+public final class Context {\n+\n+  /** Returns the root {@link Context} which all other {@link Context} are derived from. */\n+  public static Context root() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0Nzc2Ng=="}, "originalCommit": {"oid": "8611ed9598eb530ef81f8e737f93fc265cb0c544"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyMzUxOQ==", "bodyText": "I'm ok with removing for now - but IIRC we did already have a case of adding two values at the same time in instrumentation. That doesn't mean the chaining mechanism is that much worse, but a bit less efficiency.\nFWIW, I was half-jokingly thinking of going up to 5 values to have something \"better\" than gRPC API :P", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r490623519", "createdAt": "2020-09-17T23:52:46Z", "author": {"login": "anuraaga"}, "path": "extensions/context/src/main/java/io/opentelemetry/context/Context.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2015 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.context;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A context propagation mechanism which can carry scoped-values across API boundaries and between\n+ * threads.\n+ *\n+ * <p>A Context object can be {@link #attach attached} to the {@link ContextStorage}, which\n+ * effectively forms a <b>scope</b> for the context. The scope is bound to the current thread.\n+ * Within a scope, its Context is accessible even across API boundaries, through {@link #current}.\n+ * The scope is later exited by {@link Scope#close()} closing} the scope.\n+ *\n+ * <p>Context objects are immutable and inherit state from their parent. To add or overwrite the\n+ * current state a new context object must be created and then attached, replacing the previously\n+ * bound context. For example:\n+ *\n+ * <pre>\n+ *   Context withCredential = Context.current().withValue(CRED_KEY, cred);\n+ *   withCredential.wrap(new Runnable() {\n+ *     public void run() {\n+ *        readUserRecords(userId, CRED_KEY.get());\n+ *     }\n+ *   }).run();\n+ * </pre>\n+ *\n+ *\n+ *\n+ * <p>Notes and cautions on use:\n+ *\n+ * <ul>\n+ *   <li>Every {@code attach()} must be followed by a {@code Scope#close()}. Breaking these rules\n+ *       may lead to memory leaks.\n+ *   <li>While Context objects are immutable they do not place such a restriction on the state they\n+ *       store.\n+ *   <li>Context is not intended for passing optional parameters to an API and developers should\n+ *       take care to avoid excessive dependence on context when designing an API.\n+ * </ul>\n+ */\n+public final class Context {\n+\n+  /** Returns the root {@link Context} which all other {@link Context} are derived from. */\n+  public static Context root() {\n+    return storage().rootContext();\n+  }\n+\n+  /** Return the context associated with the current scope. */\n+  public static Context current() {\n+    return storage().current();\n+  }\n+\n+  /**\n+   * Returns the default {@link ContextStorage} used to attach {@link Context}s to scopes of\n+   * execution. Should only be used when defining your own {@link ContextStorage} in case you want\n+   * to delegate functionality to the default implementation.\n+   */\n+  public static ContextStorage threadLocalStorage() {\n+    return ThreadLocalContextStorage.INSTANCE;\n+  }\n+\n+  static ContextStorage storage() {\n+    return LazyStorage.storage;\n+  }\n+\n+  private final PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> entries;\n+\n+  private Context(PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> entries) {\n+    this.entries = entries;\n+  }\n+\n+  Context() {\n+    entries = null;\n+  }\n+\n+  /**\n+   * Returns the value stored in this {@link Context} for the given {@link ContextKey}, or {@code\n+   * null} if there is no value for the key in this context.\n+   */\n+  @Nullable\n+  public <V> V getValue(ContextKey<V> key) {\n+    // Because withValue enforces the value for a key is its type, this is always safe.\n+    @SuppressWarnings(\"unchecked\")\n+    V value = (V) PersistentHashArrayMappedTrie.get(entries, key);\n+    return value;\n+  }\n+\n+  /**\n+   * Returns a new context with the given key value set.\n+   *\n+   * <pre>{@code\n+   * Context withCredential = Context.current().withValue(CRED_KEY, cred);\n+   * withCredential.run(new Runnable() {\n+   *   public void run() {\n+   *      readUserRecords(userId, CRED_KEY.get());\n+   *   }\n+   * });\n+   * }</pre>\n+   *\n+   * <p>Note that multiple calls to {@link #withValue(ContextKey, Object)} can be chained together.\n+   * That is,\n+   *\n+   * <pre>\n+   * context.withValues(K1, V1, K2, V2);\n+   * // is the same as\n+   * context.withValue(K1, V1).withValue(K2, V2);\n+   * </pre>\n+   *\n+   * <p>Nonetheless, {@link Context} should not be treated like a general purpose map with a large\n+   * number of keys and values \u2014 combine multiple related items together into a single key instead\n+   * of separating them. But if the items are unrelated, have separate keys for them.\n+   */\n+  public <V> Context withValue(ContextKey<V> k1, V v1) {\n+    PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> newEntries =\n+        PersistentHashArrayMappedTrie.put(entries, k1, v1);\n+    return new Context(newEntries);\n+  }\n+\n+  /** Returns a new context with the given key value set. */\n+  public <V1, V2> Context withValues(ContextKey<V1> k1, V1 v1, ContextKey<V2> k2, V2 v2) {\n+    PersistentHashArrayMappedTrie.Node<ContextKey<?>, Object> newEntries =\n+        PersistentHashArrayMappedTrie.put(entries, k1, v1);\n+    newEntries = PersistentHashArrayMappedTrie.put(newEntries, k2, v2);\n+    return new Context(newEntries);\n+  }\n+\n+  /** Returns a new context with the given key value set. */\n+  public <V1, V2, V3> Context withValues(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ0OTUzNg=="}, "originalCommit": {"oid": "8611ed9598eb530ef81f8e737f93fc265cb0c544"}, "originalPosition": 161}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNTk0NjE2", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#pullrequestreview-491594616", "createdAt": "2020-09-18T16:01:14Z", "commit": {"oid": "8611ed9598eb530ef81f8e737f93fc265cb0c544"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNjowMToxNFrOHUTGVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNjowMToxNFrOHUTGVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA0NjQ4NQ==", "bodyText": "Can we make this an interface, now that we're going to java 8?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r491046485", "createdAt": "2020-09-18T16:01:14Z", "author": {"login": "jkwatson"}, "path": "extensions/context/src/main/java/io/opentelemetry/context/Context.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2015 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.context;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A context propagation mechanism which can carry scoped-values across API boundaries and between\n+ * threads.\n+ *\n+ * <p>A Context object can be {@link #attach attached} to the {@link ContextStorage}, which\n+ * effectively forms a <b>scope</b> for the context. The scope is bound to the current thread.\n+ * Within a scope, its Context is accessible even across API boundaries, through {@link #current}.\n+ * The scope is later exited by {@link Scope#close()} closing} the scope.\n+ *\n+ * <p>Context objects are immutable and inherit state from their parent. To add or overwrite the\n+ * current state a new context object must be created and then attached, replacing the previously\n+ * bound context. For example:\n+ *\n+ * <pre>\n+ *   Context withCredential = Context.current().withValue(CRED_KEY, cred);\n+ *   withCredential.wrap(new Runnable() {\n+ *     public void run() {\n+ *        readUserRecords(userId, CRED_KEY.get());\n+ *     }\n+ *   }).run();\n+ * </pre>\n+ *\n+ *\n+ *\n+ * <p>Notes and cautions on use:\n+ *\n+ * <ul>\n+ *   <li>Every {@code attach()} must be followed by a {@code Scope#close()}. Breaking these rules\n+ *       may lead to memory leaks.\n+ *   <li>While Context objects are immutable they do not place such a restriction on the state they\n+ *       store.\n+ *   <li>Context is not intended for passing optional parameters to an API and developers should\n+ *       take care to avoid excessive dependence on context when designing an API.\n+ * </ul>\n+ */\n+public final class Context {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8611ed9598eb530ef81f8e737f93fc265cb0c544"}, "originalPosition": 74}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4babaaa0f7d6661bbcbc34cb067b4ce6884e1d1", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/e4babaaa0f7d6661bbcbc34cb067b4ce6884e1d1", "committedDate": "2020-09-19T06:26:57Z", "message": "Moar"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "100d8b316d9ac0423be859966aa898af5592efd4", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/100d8b316d9ac0423be859966aa898af5592efd4", "committedDate": "2020-09-19T06:27:02Z", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into opentelemetry-context"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0321790bb864763b2196fff38fdaef51836b550", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/a0321790bb864763b2196fff38fdaef51836b550", "committedDate": "2020-09-19T06:44:57Z", "message": "Extracted interfaces"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "704b76a7216a3ed0ccd75e7ac8007f33fa2edfe0", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/704b76a7216a3ed0ccd75e7ac8007f33fa2edfe0", "committedDate": "2020-09-23T04:55:40Z", "message": "More context"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2c7436d3565d001bb47a624be889b41ed2a0c8e", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/c2c7436d3565d001bb47a624be889b41ed2a0c8e", "committedDate": "2020-09-25T06:04:56Z", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into opentelemetry-context"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e0d13fb568688705ec462a7f1cb025021d66467", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/1e0d13fb568688705ec462a7f1cb025021d66467", "committedDate": "2020-09-25T09:10:17Z", "message": "Cleanup / tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MjQ4NzMz", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#pullrequestreview-496248733", "createdAt": "2020-09-25T09:15:04Z", "commit": {"oid": "1e0d13fb568688705ec462a7f1cb025021d66467"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwOToxNTowNFrOHX7rnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwOToxODozM1rOHX7y3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg1NzExNw==", "bodyText": "When using storage override with immutable contexts, this is where there can be gaps - you pick one context propagation mechanism and go with it.\nHowever, since Context is an interface now it would be fairly simple to allow providers to implement that too to close this gap without any breaking changes. We do still need a default context, DefaultContext here for users of libraries with no context propagation mechanism.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r494857117", "createdAt": "2020-09-25T09:15:04Z", "author": {"login": "anuraaga"}, "path": "extensions/context/src/grpcInOtelTest/java/io/opentelemetry/context/GrpcInOtelTest.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.context;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+class GrpcInOtelTest {\n+\n+  private static final ContextKey<String> ANIMAL = ContextKey.named(\"animal\");\n+\n+  private static final io.grpc.Context.Key<String> FOOD = io.grpc.Context.key(\"food\");\n+  private static final io.grpc.Context.Key<String> COUNTRY = io.grpc.Context.key(\"country\");\n+\n+  private static ExecutorService otherThread;\n+\n+  @BeforeAll\n+  static void setUp() {\n+    otherThread = Executors.newSingleThreadExecutor();\n+  }\n+\n+  @AfterAll\n+  static void tearDown() {\n+    otherThread.shutdown();\n+  }\n+\n+  @Test\n+  void grpcOtelMix() {\n+    io.grpc.Context grpcContext = io.grpc.Context.current().withValue(COUNTRY, \"japan\");\n+    assertThat(COUNTRY.get()).isNull();\n+    io.grpc.Context root = grpcContext.attach();\n+    try {\n+      assertThat(COUNTRY.get()).isEqualTo(\"japan\");\n+      try (Scope ignored = Context.current().withValues(ANIMAL, \"cat\").attach()) {\n+        assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+        assertThat(COUNTRY.get()).isEqualTo(\"japan\");\n+\n+        io.grpc.Context context2 = io.grpc.Context.current().withValue(FOOD, \"cheese\");\n+        assertThat(FOOD.get()).isNull();\n+        io.grpc.Context toRestore = context2.attach();\n+        try {\n+          assertThat(FOOD.get()).isEqualTo(\"cheese\");\n+          assertThat(COUNTRY.get()).isEqualTo(\"japan\");\n+          assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+        } finally {\n+          context2.detach(toRestore);\n+        }\n+      }\n+    } finally {\n+      grpcContext.detach(root);\n+    }\n+  }\n+\n+  @Test\n+  void grpcWrap() throws Exception {\n+    io.grpc.Context grpcContext = io.grpc.Context.current().withValue(COUNTRY, \"japan\");\n+    io.grpc.Context root = grpcContext.attach();\n+    try {\n+      try (Scope ignored = Context.current().withValues(ANIMAL, \"cat\").attach()) {\n+        assertThat(COUNTRY.get()).isEqualTo(\"japan\");\n+        assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+\n+        AtomicReference<String> grpcValue = new AtomicReference<>();\n+        AtomicReference<String> otelValue = new AtomicReference<>();\n+        Runnable runnable =\n+            () -> {\n+              grpcValue.set(COUNTRY.get());\n+              otelValue.set(Context.current().getValue(ANIMAL));\n+            };\n+        otherThread.submit(runnable).get();\n+        assertThat(grpcValue).hasValue(null);\n+        assertThat(otelValue).hasValue(null);\n+\n+        otherThread.submit(io.grpc.Context.current().wrap(runnable)).get();\n+        assertThat(grpcValue).hasValue(\"japan\");\n+\n+        // Since gRPC context is inside the OTel context, propagating gRPC context does not", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e0d13fb568688705ec462a7f1cb025021d66467"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg1ODQzOA==", "bodyText": "To make this easier without SPI we can add a static method that, when called close to app startup, does similar configuration (probably similar to what setResource type of things will end up at in the future). Left it out for now so this currently isn't completely trivial.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r494858438", "createdAt": "2020-09-25T09:17:31Z", "author": {"login": "anuraaga"}, "path": "extensions/context/src/main/java/io/opentelemetry/context/ContextStorage.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.opentelemetry.context;\n+\n+/**\n+ * The storage for storing and retrieving the current {@link Context}.\n+ *\n+ * <p>If you want to implement your own storage or add some hooks when a {@link Context} is attached", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e0d13fb568688705ec462a7f1cb025021d66467"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg1ODk3NQ==", "bodyText": "I'm not convinced this is actually faster than a normal CoW array for our propagation cases. Will benchmark and examine that in the future.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r494858975", "createdAt": "2020-09-25T09:18:33Z", "author": {"login": "anuraaga"}, "path": "extensions/context/src/main/java/io/opentelemetry/context/PersistentHashArrayMappedTrie.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2017 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.context;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * A persistent (copy-on-write) hash tree/trie. Collisions are handled linearly. Delete is not\n+ * supported, but replacement is. The implementation favors simplicity and low memory allocation\n+ * during insertion. Although the asymptotics are good, it is optimized for small sizes like less\n+ * than 20; \"unbelievably large\" would be 100.\n+ *\n+ * <p>Inspired by popcnt-based compression seen in Ideal Hash Trees, Phil Bagwell (2000). The rest\n+ * of the implementation is ignorant of/ignores the paper.\n+ */\n+final class PersistentHashArrayMappedTrie {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e0d13fb568688705ec462a7f1cb025021d66467"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2NTc2NDY5", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#pullrequestreview-496576469", "createdAt": "2020-09-25T16:34:09Z", "commit": {"oid": "1e0d13fb568688705ec462a7f1cb025021d66467"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNjozNDowOVrOHYKvgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNjozNDowOVrOHYKvgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTEwMzg3Mg==", "bodyText": "very minor: you can get rid of the brackets here", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r495103872", "createdAt": "2020-09-25T16:34:09Z", "author": {"login": "jkwatson"}, "path": "extensions/context/src/test/java/io/opentelemetry/context/ContextTest.java", "diffHunk": "@@ -0,0 +1,448 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.context;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.await;\n+\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.logging.Handler;\n+import java.util.logging.Level;\n+import java.util.logging.LogRecord;\n+import java.util.logging.Logger;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.TestInstance.Lifecycle;\n+\n+@SuppressWarnings(\"ClassCanBeStatic\")\n+class ContextTest {\n+\n+  private static final ContextKey<String> ANIMAL = ContextKey.named(\"animal\");\n+  private static final ContextKey<Object> BAG = ContextKey.named(\"bag\");\n+  private static final ContextKey<String> FOOD = ContextKey.named(\"food\");\n+  private static final ContextKey<Integer> COOKIES = ContextKey.named(\"cookies\");\n+\n+  private static final Context CAT = Context.current().withValues(ANIMAL, \"cat\");\n+\n+  // Make sure all tests clean up\n+  @AfterEach\n+  void tearDown() {\n+    assertThat(Context.current()).isEqualTo(Context.root());\n+  }\n+\n+  @Test\n+  void startsWithRoot() {\n+    assertThat(Context.current()).isEqualTo(Context.root());\n+  }\n+\n+  @Test\n+  void canBeAttached() {\n+    Context context = Context.current().withValues(ANIMAL, \"cat\");\n+    assertThat(Context.current().getValue(ANIMAL)).isNull();\n+    try (Scope ignored = context.attach()) {\n+      assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+\n+      try (Scope ignored2 = Context.root().attach()) {\n+        assertThat(Context.current().getValue(ANIMAL)).isNull();\n+      }\n+\n+      assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+    }\n+    assertThat(Context.current().getValue(ANIMAL)).isNull();\n+  }\n+\n+  @Test\n+  void attachSameTwice() {\n+    Context context = Context.current().withValues(ANIMAL, \"cat\");\n+    assertThat(Context.current().getValue(ANIMAL)).isNull();\n+    try (Scope ignored = context.attach()) {\n+      assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+\n+      try (Scope ignored2 = context.attach()) {\n+        assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+      }\n+\n+      assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+    }\n+    assertThat(Context.current().getValue(ANIMAL)).isNull();\n+  }\n+\n+  @Test\n+  void newThreadStartsWithRoot() throws Exception {\n+    Context context = Context.current().withValues(ANIMAL, \"cat\");\n+    try (Scope ignored = context.attach()) {\n+      assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+      AtomicReference<Context> current = new AtomicReference<>();\n+      Thread thread =\n+          new Thread(\n+              () -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e0d13fb568688705ec462a7f1cb025021d66467"}, "originalPosition": 109}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2NTgxOTU4", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#pullrequestreview-496581958", "createdAt": "2020-09-25T16:42:32Z", "commit": {"oid": "1e0d13fb568688705ec462a7f1cb025021d66467"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNjo0MjozM1rOHYLAMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNjo0MjozM1rOHYLAMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTEwODE0Ng==", "bodyText": "I think this needs to change to be \"wrap\"", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r495108146", "createdAt": "2020-09-25T16:42:33Z", "author": {"login": "jkwatson"}, "path": "extensions/context/src/main/java/io/opentelemetry/context/Context.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.context;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A context propagation mechanism which can carry scoped-values across API boundaries and between\n+ * threads.\n+ *\n+ * <p>A Context object can be {@linkplain #attach attached} to the {@link ContextStorage}, which\n+ * effectively forms a <b>scope</b> for the context. The scope is bound to the current thread.\n+ * Within a scope, its Context is accessible even across API boundaries, through {@link #current}.\n+ * The scope is later exited by {@link Scope#close()} closing} the scope.\n+ *\n+ * <p>Context objects are immutable and inherit state from their parent. To add or overwrite the\n+ * current state a new context object must be created and then attached, replacing the previously\n+ * bound context. For example:\n+ *\n+ * <pre>{@code\n+ * Context withCredential = Context.current().withValue(CRED_KEY, cred);\n+ * withCredential.wrap(new Runnable() {\n+ *   public void run() {\n+ *      readUserRecords(userId, CRED_KEY.get());\n+ *   }\n+ * }).run();\n+ * }</pre>\n+ *\n+ * <p>Notes and cautions on use:\n+ *\n+ * <ul>\n+ *   <li>Every {@code attach()} must be followed by a {@code Scope#close()}. Breaking these rules\n+ *       may lead to memory leaks.\n+ *   <li>While Context objects are immutable they do not place such a restriction on the state they\n+ *       store.\n+ *   <li>Context is not intended for passing optional parameters to an API and developers should\n+ *       take care to avoid excessive dependence on context when designing an API.\n+ *   <li>Attaching Context from a different ancestor will cause information in the current Context\n+ *       to be lost. This should generally be avoided.\n+ * </ul>\n+ */\n+public interface Context {\n+\n+  /** Return the context associated with the current scope. */\n+  static Context current() {\n+    Context current = ContextStorage.get().current();\n+    return current != null ? current : root();\n+  }\n+\n+  /**\n+   * Returns the root {@link Context} which all other {@link DefaultContext} are derived from.\n+   *\n+   * <p>It should generally not be required to use the root {@link Context} directly - instead, use\n+   * {@link Context#current()} to operate on the current {@link Context}. Only use this method if\n+   * you are absolutely sure you need to disregard the current {@link Context} - this almost always\n+   * is only a workaround hiding an underlying context propagation issue.\n+   */\n+  static Context root() {\n+    return DefaultContext.ROOT;\n+  }\n+\n+  /**\n+   * Returns the value stored in this {@link Context} for the given {@link DefaultContextKey}, or\n+   * {@code null} if there is no value for the key in this context.\n+   */\n+  @Nullable\n+  <V> V getValue(ContextKey<V> key);\n+\n+  /**\n+   * Returns a new context with the given key value set.\n+   *\n+   * <pre>{@code\n+   * Context withCredential = Context.current().withValue(CRED_KEY, cred);\n+   * withCredential.run(new Runnable() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e0d13fb568688705ec462a7f1cb025021d66467"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2NTk2NjEz", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#pullrequestreview-496596613", "createdAt": "2020-09-25T17:03:41Z", "commit": {"oid": "1e0d13fb568688705ec462a7f1cb025021d66467"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNzowMzo0MVrOHYLr9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNzowMzo0MVrOHYLr9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTExOTM0OA==", "bodyText": "I might be missing something, but I don't see this being used anywhere.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r495119348", "createdAt": "2020-09-25T17:03:41Z", "author": {"login": "jkwatson"}, "path": "extensions/context/src/grpcInOtelTest/java/io/grpc/override/ContextStorageOverride.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.override;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextKey;\n+import io.opentelemetry.context.Scope;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+public class ContextStorageOverride extends Context.Storage {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e0d13fb568688705ec462a7f1cb025021d66467"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a95c49dfb9acb47e0d010615400a181d64eadeac", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/a95c49dfb9acb47e0d010615400a181d64eadeac", "committedDate": "2020-09-26T05:57:19Z", "message": "Move and cleanups"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2OTQ0MjA1", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#pullrequestreview-496944205", "createdAt": "2020-09-26T05:48:10Z", "commit": {"oid": "1e0d13fb568688705ec462a7f1cb025021d66467"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwNTo0ODoxMFrOHYd_yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwNTo0ODoxMFrOHYd_yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxOTMzNg==", "bodyText": "Because it's public I don't think IntelliJ will try to delete it (if it was suggesting me an annotation I'd add it since don't know what it is :P). Added a comment though", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r495419336", "createdAt": "2020-09-26T05:48:10Z", "author": {"login": "anuraaga"}, "path": "extensions/context/src/grpcInOtelTest/java/io/grpc/override/ContextStorageOverride.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.override;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.ContextKey;\n+import io.opentelemetry.context.Scope;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+public class ContextStorageOverride extends Context.Storage {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTExOTM0OA=="}, "originalCommit": {"oid": "1e0d13fb568688705ec462a7f1cb025021d66467"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MDMzMTg0", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#pullrequestreview-497033184", "createdAt": "2020-09-26T21:52:17Z", "commit": {"oid": "9a938bcb2f9388b9a0254134f028759896747abd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7aa6556bd073b6e5dbffe8d1d79e861ff9606b70", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/7aa6556bd073b6e5dbffe8d1d79e861ff9606b70", "committedDate": "2020-09-28T05:08:53Z", "message": "Brackets"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9a938bcb2f9388b9a0254134f028759896747abd", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/9a938bcb2f9388b9a0254134f028759896747abd", "committedDate": "2020-09-26T05:59:09Z", "message": "Brackets"}, "afterCommit": {"oid": "7aa6556bd073b6e5dbffe8d1d79e861ff9606b70", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/7aa6556bd073b6e5dbffe8d1d79e861ff9606b70", "committedDate": "2020-09-28T05:08:53Z", "message": "Brackets"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MTg5NTI0", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#pullrequestreview-497189524", "createdAt": "2020-09-28T05:09:45Z", "commit": {"oid": "7aa6556bd073b6e5dbffe8d1d79e861ff9606b70"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNTowOTo0NVrOHYun7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQwNToxMDowNVrOHYuoYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MTc1Nw==", "bodyText": "Added this extension point to allow customizing the implementation of a key to match a storage.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r495691757", "createdAt": "2020-09-28T05:09:45Z", "author": {"login": "anuraaga"}, "path": "context/src/main/java/io/opentelemetry/context/ContextStorage.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.opentelemetry.context;\n+\n+/**\n+ * The storage for storing and retrieving the current {@link Context}.\n+ *\n+ * <p>If you want to implement your own storage or add some hooks when a {@link Context} is attached\n+ * and restored, you should use {@link ContextStorageProvider}. Here's an example that sets MDC\n+ * before {@link Context} is attached:\n+ *\n+ * <pre>{@code\n+ * > public class MyStorage implements ContextStorageProvider {\n+ * >\n+ * >   @Override\n+ * >   public ContextStorage get() {\n+ * >     ContextStorage threadLocalStorage = Context.threadLocalStorage();\n+ * >     return new RequestContextStorage() {\n+ * >       @Override\n+ * >       public Scope T attach(Context toAttach) {\n+ * >         Context current = current();\n+ * >         setMdc(toAttach);\n+ * >         Scope scope = threadLocalStorage.attach(toAttach);\n+ * >         return () -> {\n+ * >           clearMdc();\n+ * >           setMdc(current);\n+ * >           scope.close();\n+ * >         }\n+ * >       }\n+ * >\n+ * >       @Override\n+ * >       public Context current() {\n+ * >         return threadLocalStorage.current();\n+ * >       }\n+ * >     }\n+ * >   }\n+ * > }\n+ * }</pre>\n+ */\n+public interface ContextStorage {\n+\n+  /**\n+   * Returns the {@link ContextStorage} being used by this application. This is only for use when\n+   * integrating with other context propagation mechanisms and not meant for direct use. To attach\n+   * or detach a {@link Context} in an application, use {@link Context#makeCurrent()} and {@link\n+   * Scope#close()}.\n+   */\n+  static ContextStorage get() {\n+    return LazyStorage.storage;\n+  }\n+\n+  /**\n+   * Sets the specified {@link Context} as the current {@link Context} and returns a {@link Scope}\n+   * representing the scope of execution. {@link Scope#close()} must be called when the current\n+   * {@link Context} should be restored to what it was before attaching {@code toAttach}.\n+   */\n+  Scope attach(Context toAttach);\n+\n+  /**\n+   * Returns the current {@link DefaultContext}. If no {@link DefaultContext} has been attached yet,\n+   * this will be the {@linkplain Context#root()} root context}.\n+   */\n+  Context current();\n+\n+  /**\n+   * Returns a {@link ContextKey} for the given name. This is only useful when integrating with a\n+   * separate context propagation mechanism, where\n+   */\n+  default <T> ContextKey<T> contextKey(String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7aa6556bd073b6e5dbffe8d1d79e861ff9606b70"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MTg3NA==", "bodyText": "Works", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r495691874", "createdAt": "2020-09-28T05:10:05Z", "author": {"login": "anuraaga"}, "path": "context/src/otelAsGrpcTest/java/io/opentelemetry/context/OtelAsGrpcTest.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.context;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+class OtelAsGrpcTest {\n+\n+  private static final ContextKey<String> ANIMAL = ContextKey.named(\"animal\");\n+\n+  private static final io.grpc.Context.Key<String> FOOD = io.grpc.Context.key(\"food\");\n+  private static final io.grpc.Context.Key<String> COUNTRY = io.grpc.Context.key(\"country\");\n+\n+  private static ExecutorService otherThread;\n+\n+  @BeforeAll\n+  static void setUp() {\n+    otherThread = Executors.newSingleThreadExecutor();\n+  }\n+\n+  @AfterAll\n+  static void tearDown() {\n+    otherThread.shutdown();\n+  }\n+\n+  @Test\n+  void grpcOtelMix() {\n+    io.grpc.Context grpcContext = io.grpc.Context.current().withValue(COUNTRY, \"japan\");\n+    assertThat(COUNTRY.get()).isNull();\n+    io.grpc.Context root = grpcContext.attach();\n+    try {\n+      assertThat(COUNTRY.get()).isEqualTo(\"japan\");\n+      try (Scope ignored = Context.current().withValues(ANIMAL, \"cat\").makeCurrent()) {\n+        assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+        assertThat(COUNTRY.get()).isEqualTo(\"japan\");\n+\n+        io.grpc.Context context2 = io.grpc.Context.current().withValue(FOOD, \"cheese\");\n+        assertThat(FOOD.get()).isNull();\n+        io.grpc.Context toRestore = context2.attach();\n+        try {\n+          assertThat(FOOD.get()).isEqualTo(\"cheese\");\n+          assertThat(COUNTRY.get()).isEqualTo(\"japan\");\n+          assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+        } finally {\n+          context2.detach(toRestore);\n+        }\n+      }\n+    } finally {\n+      grpcContext.detach(root);\n+    }\n+  }\n+\n+  @Test\n+  void grpcWrap() throws Exception {\n+    io.grpc.Context grpcContext = io.grpc.Context.current().withValue(COUNTRY, \"japan\");\n+    io.grpc.Context root = grpcContext.attach();\n+    try {\n+      try (Scope ignored = Context.current().withValues(ANIMAL, \"cat\").makeCurrent()) {\n+        assertThat(COUNTRY.get()).isEqualTo(\"japan\");\n+        assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+\n+        AtomicReference<String> grpcValue = new AtomicReference<>();\n+        AtomicReference<String> otelValue = new AtomicReference<>();\n+        Runnable runnable =\n+            () -> {\n+              grpcValue.set(COUNTRY.get());\n+              otelValue.set(Context.current().getValue(ANIMAL));\n+            };\n+        otherThread.submit(runnable).get();\n+        assertThat(grpcValue).hasValue(null);\n+        assertThat(otelValue).hasValue(null);\n+\n+        otherThread.submit(io.grpc.Context.current().wrap(runnable)).get();\n+        assertThat(grpcValue).hasValue(\"japan\");\n+        assertThat(otelValue).hasValue(\"cat\");\n+      }\n+    } finally {\n+      grpcContext.detach(root);\n+    }\n+  }\n+\n+  @Test\n+  void otelWrap() throws Exception {\n+    io.grpc.Context grpcContext = io.grpc.Context.current().withValue(COUNTRY, \"japan\");\n+    io.grpc.Context root = grpcContext.attach();\n+    try {\n+      try (Scope ignored = Context.current().withValues(ANIMAL, \"cat\").makeCurrent()) {\n+        assertThat(COUNTRY.get()).isEqualTo(\"japan\");\n+        assertThat(Context.current().getValue(ANIMAL)).isEqualTo(\"cat\");\n+\n+        AtomicReference<String> grpcValue = new AtomicReference<>();\n+        AtomicReference<String> otelValue = new AtomicReference<>();\n+        Runnable runnable =\n+            () -> {\n+              grpcValue.set(COUNTRY.get());\n+              otelValue.set(Context.current().getValue(ANIMAL));\n+            };\n+        otherThread.submit(runnable).get();\n+        assertThat(grpcValue).hasValue(null);\n+        assertThat(otelValue).hasValue(null);\n+\n+        otherThread.submit(Context.current().wrap(runnable)).get();\n+\n+        assertThat(grpcValue).hasValue(\"japan\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7aa6556bd073b6e5dbffe8d1d79e861ff9606b70"}, "originalPosition": 125}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37c1b97ef8597b5e79fe5db4b0d2729b34637cfa", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/37c1b97ef8597b5e79fe5db4b0d2729b34637cfa", "committedDate": "2020-09-29T08:42:28Z", "message": "Add example for brave context interop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4799c6d6cf117545ec8ec6e451bc17a0beaaa10e", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/4799c6d6cf117545ec8ec6e451bc17a0beaaa10e", "committedDate": "2020-09-29T09:02:41Z", "message": "Brave in OTel"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f5338aa9cf78ea26552f90d0656df618dc47275", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/6f5338aa9cf78ea26552f90d0656df618dc47275", "committedDate": "2020-09-29T09:05:58Z", "message": "Spotless"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NTYwNzU1", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#pullrequestreview-498560755", "createdAt": "2020-09-29T14:54:11Z", "commit": {"oid": "6f5338aa9cf78ea26552f90d0656df618dc47275"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01fab50e4a285f2207a80adf59df227c6e6f3f49", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/01fab50e4a285f2207a80adf59df227c6e6f3f49", "committedDate": "2020-09-30T02:13:19Z", "message": "Missing folder"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5NTgwNTI5", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#pullrequestreview-499580529", "createdAt": "2020-09-30T15:54:57Z", "commit": {"oid": "01fab50e4a285f2207a80adf59df227c6e6f3f49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNTo1NDo1N1rOHakZQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNTo1NDo1N1rOHakZQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzYyMTMxNQ==", "bodyText": "Is DefaultContext really the expected one? Shouldn't be Context instead?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#discussion_r497621315", "createdAt": "2020-09-30T15:54:57Z", "author": {"login": "carlosalberto"}, "path": "context/src/main/java/io/opentelemetry/context/ContextStorageProvider.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.context;\n+\n+import java.util.concurrent.Executor;\n+\n+/**\n+ * A Java SPI (Service Provider Interface) to allow replacing the default {@link ContextStorage}.\n+ * This can be useful if, for example, you want to store OpenTelemetry {@link DefaultContext} in\n+ * another context propagation system. For example, the returned {@link ContextStorage} could\n+ * delegate to methods in\n+ *\n+ * <p><a\n+ * href=\"https://javadoc.io/doc/com.linecorp.armeria/armeria-javadoc/latest/com/linecorp/armeria/common/RequestContext.html\">{@code\n+ * com.linecorp.armeria.common.RequestContext}</a>, <a\n+ * href=\"https://grpc.github.io/grpc-java/javadoc/io/grpc/Context.html\">{@code\n+ * io.grpc.context.Context}</a>, or <a\n+ * href=\"https://download.eclipse.org/microprofile/microprofile-context-propagation-1.0.2/apidocs/org/eclipse/microprofile/context/ThreadContext.html\">{@code\n+ * org.eclipse.microprofile.context.ThreadContext}</a>\n+ *\n+ * <p>if you are already using one of those systems in your application. Then you would not have to\n+ * use methods like {@link Context#wrap(Executor)} and can use your current system instead.\n+ */\n+public interface ContextStorageProvider {\n+\n+  /** Returns the {@link ContextStorage} to use to store {@link DefaultContext}. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01fab50e4a285f2207a80adf59df227c6e6f3f49"}, "originalPosition": 40}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1e7c5c24ed178bb0ff78e79f6bc88ed1251ce99", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/e1e7c5c24ed178bb0ff78e79f6bc88ed1251ce99", "committedDate": "2020-09-30T23:55:35Z", "message": "Another"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTY5NTU2", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1658#pullrequestreview-500569556", "createdAt": "2020-10-01T17:30:27Z", "commit": {"oid": "e1e7c5c24ed178bb0ff78e79f6bc88ed1251ce99"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f665d63f6ad49abd30e6629b791411a58600946", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/2f665d63f6ad49abd30e6629b791411a58600946", "committedDate": "2020-10-05T07:39:39Z", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into opentelemetry-context"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c614e13e6dd02b729cafa351e7300762ea4aa90e", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/c614e13e6dd02b729cafa351e7300762ea4aa90e", "committedDate": "2020-10-05T07:41:30Z", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into opentelemetry-context"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62131e2fddcb97276babe3c5b2262c4259102223", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/62131e2fddcb97276babe3c5b2262c4259102223", "committedDate": "2020-10-05T07:41:44Z", "message": "Spotless"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3439, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}