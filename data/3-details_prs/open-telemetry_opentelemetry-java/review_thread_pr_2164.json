{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwMDAzNTQ0", "number": 2164, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNTo1MDozOVrOE-9dgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODozNzozN1rOFAZz0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NDU0MTQ0OnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNTo1MDozOVrOH8ZHZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwNDoyNzo1MlrOH9J_WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA4ODEwMQ==", "bodyText": "@trask Please review the shading I've set up in this PR.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2164#discussion_r533088101", "createdAt": "2020-12-01T05:50:39Z", "author": {"login": "anuraaga"}, "path": "build.gradle", "diffHunk": "@@ -509,6 +515,33 @@ configure(opentelemetryProjects) {\n         // Always run jmhReport after jmh task.\n         tasks.jmh.finalizedBy tasks.jmhReport\n     }\n+\n+    // We vendor in a shaded version of weak-lock-free into opentelemetry-context, which is a", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a174eb7f85786783e9b9caca0d7201606b455fb"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ4NTM3Ng==", "bodyText": "Have you verified the .pom/.module and META-INF still look OK for this? IIRC shadow by default does not preserve the MANIFEST.mf of any patched jars.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2164#discussion_r533485376", "createdAt": "2020-12-01T15:08:18Z", "author": {"login": "Oberon00"}, "path": "build.gradle", "diffHunk": "@@ -509,6 +515,33 @@ configure(opentelemetryProjects) {\n         // Always run jmhReport after jmh task.\n         tasks.jmh.finalizedBy tasks.jmhReport\n     }\n+\n+    // We vendor in a shaded version of weak-lock-free into opentelemetry-context, which is a", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA4ODEwMQ=="}, "originalCommit": {"oid": "4a174eb7f85786783e9b9caca0d7201606b455fb"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg4ODg1Ng==", "bodyText": "Thanks! Realized weak-lock-free was ending up in opentelemetry-context POM, changed so that doesn't happen.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2164#discussion_r533888856", "createdAt": "2020-12-02T04:27:52Z", "author": {"login": "anuraaga"}, "path": "build.gradle", "diffHunk": "@@ -509,6 +515,33 @@ configure(opentelemetryProjects) {\n         // Always run jmhReport after jmh task.\n         tasks.jmh.finalizedBy tasks.jmhReport\n     }\n+\n+    // We vendor in a shaded version of weak-lock-free into opentelemetry-context, which is a", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA4ODEwMQ=="}, "originalCommit": {"oid": "4a174eb7f85786783e9b9caca0d7201606b455fb"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODg4MDQxOnYy", "diffSide": "RIGHT", "path": "sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMjo1ODo1NFrOH9DR6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwNDoyODo0M1rOH9KAPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc3ODkyMw==", "bodyText": "This will leave data in the map as we never touch it again. Since things are weak we won't hold to span structures but we will keep the weak refs around until JVM shutdown.\nThis was a one reason I went with the NoopMap to avoid the issue to figure out where to place the closed checked :)\nprobably best to just put it in the existing if statement as the first check.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2164#discussion_r533778923", "createdAt": "2020-12-01T22:58:54Z", "author": {"login": "sfriberg"}, "path": "sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java", "diffHunk": "@@ -45,6 +46,9 @@ public boolean isStartRequired() {\n \n   @Override\n   public void onEnd(ReadableSpan rs) {\n+    if (closed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1a718223e3d932298b8b378a36b03498c21913"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg4OTA4Ng==", "bodyText": "Thanks!", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2164#discussion_r533889086", "createdAt": "2020-12-02T04:28:43Z", "author": {"login": "anuraaga"}, "path": "sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java", "diffHunk": "@@ -45,6 +46,9 @@ public boolean isStartRequired() {\n \n   @Override\n   public void onEnd(ReadableSpan rs) {\n+    if (closed) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc3ODkyMw=="}, "originalCommit": {"oid": "0e1a718223e3d932298b8b378a36b03498c21913"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODg5MDU2OnYy", "diffSide": "RIGHT", "path": "sdk-extensions/jfr-events/build.gradle", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMzowMjoyNlrOH9DYRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwNDozMTo0M1rOH9KDWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4MDU1MA==", "bodyText": "How do I ensure that we have this library around when loading JFR extension? Expect that opentelemetry is loaded and reachable and pulls in this dependency?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2164#discussion_r533780550", "createdAt": "2020-12-01T23:02:26Z", "author": {"login": "sfriberg"}, "path": "sdk-extensions/jfr-events/build.gradle", "diffHunk": "@@ -8,7 +10,9 @@ ext.moduleName = 'io.opentelemetry.sdk.extension.jfr'\n dependencies {\n     implementation project(':opentelemetry-api'),\n             project(':opentelemetry-sdk')\n-    implementation libraries.guava\n+\n+    compileOnly libraries.weak_lock_free", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e1a718223e3d932298b8b378a36b03498c21913"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg4ODk3OQ==", "bodyText": "Yeah this has the pattern where we vendor into opentelemetry-context, which is always pulled in as a dependency.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2164#discussion_r533888979", "createdAt": "2020-12-02T04:28:18Z", "author": {"login": "anuraaga"}, "path": "sdk-extensions/jfr-events/build.gradle", "diffHunk": "@@ -8,7 +10,9 @@ ext.moduleName = 'io.opentelemetry.sdk.extension.jfr'\n dependencies {\n     implementation project(':opentelemetry-api'),\n             project(':opentelemetry-sdk')\n-    implementation libraries.guava\n+\n+    compileOnly libraries.weak_lock_free", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4MDU1MA=="}, "originalCommit": {"oid": "0e1a718223e3d932298b8b378a36b03498c21913"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg4OTg4Mg==", "bodyText": "By the way if there's a better pattern I'm happy to try it :) This is the only one I could come up with without duplicating the class into each artifact that uses it.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2164#discussion_r533889882", "createdAt": "2020-12-02T04:31:43Z", "author": {"login": "anuraaga"}, "path": "sdk-extensions/jfr-events/build.gradle", "diffHunk": "@@ -8,7 +10,9 @@ ext.moduleName = 'io.opentelemetry.sdk.extension.jfr'\n dependencies {\n     implementation project(':opentelemetry-api'),\n             project(':opentelemetry-sdk')\n-    implementation libraries.guava\n+\n+    compileOnly libraries.weak_lock_free", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzc4MDU1MA=="}, "originalCommit": {"oid": "0e1a718223e3d932298b8b378a36b03498c21913"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NDEwMjUxOnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwMDo0MjoxOFrOH90MXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwMDo0OToxOVrOH90Wdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU4MDMxOQ==", "bodyText": "with the code vendor'd in, do we still need this?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2164#discussion_r534580319", "createdAt": "2020-12-03T00:42:18Z", "author": {"login": "jkwatson"}, "path": "build.gradle", "diffHunk": "@@ -328,6 +333,7 @@ configure(opentelemetryProjects) {\n                 prometheus_client_common: \"io.prometheus:simpleclient_common:${prometheusVersion}\",\n                 protobuf                : \"com.google.protobuf:protobuf-java\",\n                 protobuf_util           : \"com.google.protobuf:protobuf-java-util\",\n+                weak_lock_free          : \"com.blogspot.mydailyjava:weak-lock-free:${weakLockFreeVersion}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24c5fb2e17fa43ba450b2a7915050eae825ae7c2"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU4MjkwMw==", "bodyText": "Oops thanks", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2164#discussion_r534582903", "createdAt": "2020-12-03T00:49:19Z", "author": {"login": "anuraaga"}, "path": "build.gradle", "diffHunk": "@@ -328,6 +333,7 @@ configure(opentelemetryProjects) {\n                 prometheus_client_common: \"io.prometheus:simpleclient_common:${prometheusVersion}\",\n                 protobuf                : \"com.google.protobuf:protobuf-java\",\n                 protobuf_util           : \"com.google.protobuf:protobuf-java-util\",\n+                weak_lock_free          : \"com.blogspot.mydailyjava:weak-lock-free:${weakLockFreeVersion}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU4MDMxOQ=="}, "originalCommit": {"oid": "24c5fb2e17fa43ba450b2a7915050eae825ae7c2"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NDQ1MDY3OnYy", "diffSide": "RIGHT", "path": "sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwMzowNDowNVrOH93Y1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwNTo1MDowN1rOH97GBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDYzMjY2MA==", "bodyText": "I ask you... Is \"expunction\" a word? really?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2164#discussion_r534632660", "createdAt": "2020-12-03T03:04:05Z", "author": {"login": "jkwatson"}, "path": "sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java", "diffHunk": "@@ -26,11 +22,16 @@\n  */\n public class JfrSpanProcessor implements SpanProcessor {\n \n-  private volatile Map<SpanContext, SpanEvent> spanEvents =\n-      new MapMaker().concurrencyLevel(16).initialCapacity(128).weakKeys().makeMap();\n+  private final WeakConcurrentMap<SpanContext, SpanEvent> spanEvents =\n+      new WeakConcurrentMap.WithInlinedExpunction<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a2f4cc273509de1a164854e2da4c00bc2f2abe2"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY5MzM4Mg==", "bodyText": "Don't ask me ask raph :P", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2164#discussion_r534693382", "createdAt": "2020-12-03T05:50:07Z", "author": {"login": "anuraaga"}, "path": "sdk-extensions/jfr-events/src/main/java/io/opentelemetry/sdk/extension/jfr/JfrSpanProcessor.java", "diffHunk": "@@ -26,11 +22,16 @@\n  */\n public class JfrSpanProcessor implements SpanProcessor {\n \n-  private volatile Map<SpanContext, SpanEvent> spanEvents =\n-      new MapMaker().concurrencyLevel(16).initialCapacity(128).weakKeys().makeMap();\n+  private final WeakConcurrentMap<SpanContext, SpanEvent> spanEvents =\n+      new WeakConcurrentMap.WithInlinedExpunction<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDYzMjY2MA=="}, "originalCommit": {"oid": "5a2f4cc273509de1a164854e2da4c00bc2f2abe2"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NDQ2MzU5OnYy", "diffSide": "RIGHT", "path": "sdk/testing/src/main/java/io/opentelemetry/sdk/testing/context/StrictContextStorage.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwMzoxMDowM1rOH93gZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwMzoxMDowM1rOH93gZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDYzNDU5OA==", "bodyText": "why not have this done in the StrictScope constructor, so it controls the full lifecycle, rather having it put in here, but removed internal to the StrictScope.close()?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2164#discussion_r534634598", "createdAt": "2020-12-03T03:10:03Z", "author": {"login": "jkwatson"}, "path": "sdk/testing/src/main/java/io/opentelemetry/sdk/testing/context/StrictContextStorage.java", "diffHunk": "@@ -111,8 +116,9 @@ public Scope attach(Context context) {\n \n     stackTrace = Arrays.copyOfRange(stackTrace, from, stackTrace.length);\n     caller.setStackTrace(stackTrace);\n+    pendingScopes.put(scope, caller);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a2f4cc273509de1a164854e2da4c00bc2f2abe2"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NDQ3MDQ0OnYy", "diffSide": "RIGHT", "path": "sdk/testing/src/main/java/io/opentelemetry/sdk/testing/context/StrictContextStorage.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwMzoxMjo1MFrOH93kNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwNjoxMDoxMlrOH98OCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDYzNTU3Mw==", "bodyText": "so, we're only throwing the first that we run across, rather than alert about all the possibilities?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2164#discussion_r534635573", "createdAt": "2020-12-03T03:12:50Z", "author": {"login": "jkwatson"}, "path": "sdk/testing/src/main/java/io/opentelemetry/sdk/testing/context/StrictContextStorage.java", "diffHunk": "@@ -132,35 +138,28 @@ public Context current() {\n    */\n   // AssertionError to ensure test runners render the stack trace\n   public void ensureAllClosed() {\n-    List<CallerStackTrace> leakedCallers = new ArrayList<>();\n-    currentCallers.drainTo(leakedCallers);\n-    for (CallerStackTrace caller : leakedCallers) {\n+    pendingScopes.expungeStaleEntries();\n+    for (CallerStackTrace caller : pendingScopes.drainPendingCallers()) {\n       // Sometimes unit test runners truncate the cause of the exception.\n       // This flattens the exception as the caller of close() isn't important vs the one that leaked\n-      AssertionError toThrow =\n-          new AssertionError(\n-              \"Thread [\" + caller.threadName + \"] opened a scope of \" + caller.context + \" here:\");\n-      toThrow.setStackTrace(caller.getStackTrace());\n-      throw toThrow;\n+      throw callerError(caller);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a2f4cc273509de1a164854e2da4c00bc2f2abe2"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDcwMDAwNQ==", "bodyText": "Added logging when multiple, still throwing since this is mostly for unit tests where an exception is best", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2164#discussion_r534700005", "createdAt": "2020-12-03T05:57:26Z", "author": {"login": "anuraaga"}, "path": "sdk/testing/src/main/java/io/opentelemetry/sdk/testing/context/StrictContextStorage.java", "diffHunk": "@@ -132,35 +138,28 @@ public Context current() {\n    */\n   // AssertionError to ensure test runners render the stack trace\n   public void ensureAllClosed() {\n-    List<CallerStackTrace> leakedCallers = new ArrayList<>();\n-    currentCallers.drainTo(leakedCallers);\n-    for (CallerStackTrace caller : leakedCallers) {\n+    pendingScopes.expungeStaleEntries();\n+    for (CallerStackTrace caller : pendingScopes.drainPendingCallers()) {\n       // Sometimes unit test runners truncate the cause of the exception.\n       // This flattens the exception as the caller of close() isn't important vs the one that leaked\n-      AssertionError toThrow =\n-          new AssertionError(\n-              \"Thread [\" + caller.threadName + \"] opened a scope of \" + caller.context + \" here:\");\n-      toThrow.setStackTrace(caller.getStackTrace());\n-      throw toThrow;\n+      throw callerError(caller);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDYzNTU3Mw=="}, "originalCommit": {"oid": "5a2f4cc273509de1a164854e2da4c00bc2f2abe2"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDcxMTgxNg==", "bodyText": "Went ahead and added logging if more than one.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2164#discussion_r534711816", "createdAt": "2020-12-03T06:10:12Z", "author": {"login": "anuraaga"}, "path": "sdk/testing/src/main/java/io/opentelemetry/sdk/testing/context/StrictContextStorage.java", "diffHunk": "@@ -132,35 +138,28 @@ public Context current() {\n    */\n   // AssertionError to ensure test runners render the stack trace\n   public void ensureAllClosed() {\n-    List<CallerStackTrace> leakedCallers = new ArrayList<>();\n-    currentCallers.drainTo(leakedCallers);\n-    for (CallerStackTrace caller : leakedCallers) {\n+    pendingScopes.expungeStaleEntries();\n+    for (CallerStackTrace caller : pendingScopes.drainPendingCallers()) {\n       // Sometimes unit test runners truncate the cause of the exception.\n       // This flattens the exception as the caller of close() isn't important vs the one that leaked\n-      AssertionError toThrow =\n-          new AssertionError(\n-              \"Thread [\" + caller.threadName + \"] opened a scope of \" + caller.context + \" here:\");\n-      toThrow.setStackTrace(caller.getStackTrace());\n-      throw toThrow;\n+      throw callerError(caller);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDYzNTU3Mw=="}, "originalCommit": {"oid": "5a2f4cc273509de1a164854e2da4c00bc2f2abe2"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NDQ3MTk2OnYy", "diffSide": "RIGHT", "path": "sdk/testing/src/main/java/io/opentelemetry/sdk/testing/context/StrictContextStorage.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwMzoxMzo0M1rOH93lHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwMzoxMzo0M1rOH93lHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDYzNTgwNQ==", "bodyText": "this comment is duplicated down in callerError", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2164#discussion_r534635805", "createdAt": "2020-12-03T03:13:43Z", "author": {"login": "jkwatson"}, "path": "sdk/testing/src/main/java/io/opentelemetry/sdk/testing/context/StrictContextStorage.java", "diffHunk": "@@ -132,35 +138,28 @@ public Context current() {\n    */\n   // AssertionError to ensure test runners render the stack trace\n   public void ensureAllClosed() {\n-    List<CallerStackTrace> leakedCallers = new ArrayList<>();\n-    currentCallers.drainTo(leakedCallers);\n-    for (CallerStackTrace caller : leakedCallers) {\n+    pendingScopes.expungeStaleEntries();\n+    for (CallerStackTrace caller : pendingScopes.drainPendingCallers()) {\n       // Sometimes unit test runners truncate the cause of the exception.\n       // This flattens the exception as the caller of close() isn't important vs the one that leaked", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a2f4cc273509de1a164854e2da4c00bc2f2abe2"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1OTY3MTg2OnYy", "diffSide": "RIGHT", "path": "sdk/testing/src/main/java/io/opentelemetry/sdk/testing/context/StrictContextStorage.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODozNzozOFrOH-rdow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwMzo0OToyOVrOH-_mRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ4NTg1OQ==", "bodyText": "we could skip doing this if there's only one, so you don't get the same one twice? Not sure if that's good or bad, but just a thought.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2164#discussion_r535485859", "createdAt": "2020-12-03T18:37:38Z", "author": {"login": "jkwatson"}, "path": "sdk/testing/src/main/java/io/opentelemetry/sdk/testing/context/StrictContextStorage.java", "diffHunk": "@@ -132,35 +137,34 @@ public Context current() {\n    */\n   // AssertionError to ensure test runners render the stack trace\n   public void ensureAllClosed() {\n-    List<CallerStackTrace> leakedCallers = new ArrayList<>();\n-    currentCallers.drainTo(leakedCallers);\n-    for (CallerStackTrace caller : leakedCallers) {\n-      // Sometimes unit test runners truncate the cause of the exception.\n-      // This flattens the exception as the caller of close() isn't important vs the one that leaked\n-      AssertionError toThrow =\n-          new AssertionError(\n-              \"Thread [\" + caller.threadName + \"] opened a scope of \" + caller.context + \" here:\");\n-      toThrow.setStackTrace(caller.getStackTrace());\n-      throw toThrow;\n+    pendingScopes.expungeStaleEntries();\n+    List<CallerStackTrace> leaked = pendingScopes.drainPendingCallers();\n+    if (!leaked.isEmpty()) {\n+      if (leaked.size() > 1) {\n+        logger.log(Level.SEVERE, \"Multiple scopes leaked - first will be thrown as an error.\");\n+      }\n+      for (CallerStackTrace caller : leaked) {\n+        logger.log(Level.SEVERE, \"Scope leaked\", callerError(caller));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4586a7c0caf5ffabcbab39b9f48c3b4e7c7f7f08"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgxNTc0OQ==", "bodyText": "Oops - yeah this is a bug I meant to have it in the if statement, thanks", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2164#discussion_r535815749", "createdAt": "2020-12-04T03:49:29Z", "author": {"login": "anuraaga"}, "path": "sdk/testing/src/main/java/io/opentelemetry/sdk/testing/context/StrictContextStorage.java", "diffHunk": "@@ -132,35 +137,34 @@ public Context current() {\n    */\n   // AssertionError to ensure test runners render the stack trace\n   public void ensureAllClosed() {\n-    List<CallerStackTrace> leakedCallers = new ArrayList<>();\n-    currentCallers.drainTo(leakedCallers);\n-    for (CallerStackTrace caller : leakedCallers) {\n-      // Sometimes unit test runners truncate the cause of the exception.\n-      // This flattens the exception as the caller of close() isn't important vs the one that leaked\n-      AssertionError toThrow =\n-          new AssertionError(\n-              \"Thread [\" + caller.threadName + \"] opened a scope of \" + caller.context + \" here:\");\n-      toThrow.setStackTrace(caller.getStackTrace());\n-      throw toThrow;\n+    pendingScopes.expungeStaleEntries();\n+    List<CallerStackTrace> leaked = pendingScopes.drainPendingCallers();\n+    if (!leaked.isEmpty()) {\n+      if (leaked.size() > 1) {\n+        logger.log(Level.SEVERE, \"Multiple scopes leaked - first will be thrown as an error.\");\n+      }\n+      for (CallerStackTrace caller : leaked) {\n+        logger.log(Level.SEVERE, \"Scope leaked\", callerError(caller));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ4NTg1OQ=="}, "originalCommit": {"oid": "4586a7c0caf5ffabcbab39b9f48c3b4e7c7f7f08"}, "originalPosition": 66}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1808, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}