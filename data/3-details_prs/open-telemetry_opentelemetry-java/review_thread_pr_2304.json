{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM5OTc0ODY1", "number": 2304, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxOTo0NDo1NFrOFFxlfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMzo1NTozNVrOFF8nJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNTk5NjEzOnYy", "diffSide": "RIGHT", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporter/otlp/AttributeMarshaler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxOTo0NDo1NFrOIGc-aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMDoxMzoxNFrOIGeEYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYzNzA5OQ==", "bodyText": "we should have a better description here, even if it won't happen under any normal circumstance", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543637099", "createdAt": "2020-12-15T19:44:54Z", "author": {"login": "jkwatson"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporter/otlp/AttributeMarshaler.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporter.otlp;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.CodedOutputStream;\n+import com.google.protobuf.WireFormat;\n+import io.opentelemetry.api.common.AttributeKey;\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.proto.common.v1.AnyValue;\n+import io.opentelemetry.proto.common.v1.ArrayValue;\n+import io.opentelemetry.proto.common.v1.KeyValue;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+abstract class AttributeMarshaler extends MarshalerWithSize {\n+  private static final AttributeMarshaler[] EMPTY_REPEATED = new AttributeMarshaler[0];\n+  private final ByteString key;\n+  private final int valueSize;\n+\n+  static AttributeMarshaler[] createRepeated(Attributes attributes) {\n+    if (attributes.isEmpty()) {\n+      return EMPTY_REPEATED;\n+    }\n+\n+    AttributeMarshaler[] attributeMarshalers = new AttributeMarshaler[attributes.size()];\n+    // TODO: Revisit how to avoid the atomic integer creation.\n+    AtomicInteger pos = new AtomicInteger();\n+    attributes.forEach(\n+        (attributeKey, o) ->\n+            attributeMarshalers[pos.getAndIncrement()] =\n+                AttributeMarshaler.create(attributeKey, o));\n+    return attributeMarshalers;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  static AttributeMarshaler create(AttributeKey<?> attributeKey, Object value) {\n+    ByteString key = MarshalerUtil.toByteString(attributeKey.getKey());\n+    if (value == null) {\n+      return new KeyValueNullMarshaler(key);\n+    }\n+    switch (attributeKey.getType()) {\n+      case STRING:\n+        return new KeyValueStringMarshaler(key, MarshalerUtil.toByteString((String) value));\n+      case LONG:\n+        return new KeyValueLongMarshaler(key, (Long) value);\n+      case BOOLEAN:\n+        return new KeyValueBooleanMarshaler(key, (Boolean) value);\n+      case DOUBLE:\n+        return new KeyValueDoubleMarshaler(key, (Double) value);\n+      case STRING_ARRAY:\n+        return new KeyValueArrayStringMarshaler(key, (List<String>) value);\n+      case LONG_ARRAY:\n+        return new KeyValueArrayLongMarshaler(key, (List<Long>) value);\n+      case BOOLEAN_ARRAY:\n+        return new KeyValueArrayBooleanMarshaler(key, (List<Boolean>) value);\n+      case DOUBLE_ARRAY:\n+        return new KeyValueArrayDoubleMarshaler(key, (List<Double>) value);\n+    }\n+    throw new IllegalArgumentException(\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b288e09faa7d609dcd8739467ac3f1e9576b8169"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY1NTAxMA==", "bodyText": ":))))", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543655010", "createdAt": "2020-12-15T20:13:14Z", "author": {"login": "bogdandrutu"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporter/otlp/AttributeMarshaler.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporter.otlp;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.CodedOutputStream;\n+import com.google.protobuf.WireFormat;\n+import io.opentelemetry.api.common.AttributeKey;\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.proto.common.v1.AnyValue;\n+import io.opentelemetry.proto.common.v1.ArrayValue;\n+import io.opentelemetry.proto.common.v1.KeyValue;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+abstract class AttributeMarshaler extends MarshalerWithSize {\n+  private static final AttributeMarshaler[] EMPTY_REPEATED = new AttributeMarshaler[0];\n+  private final ByteString key;\n+  private final int valueSize;\n+\n+  static AttributeMarshaler[] createRepeated(Attributes attributes) {\n+    if (attributes.isEmpty()) {\n+      return EMPTY_REPEATED;\n+    }\n+\n+    AttributeMarshaler[] attributeMarshalers = new AttributeMarshaler[attributes.size()];\n+    // TODO: Revisit how to avoid the atomic integer creation.\n+    AtomicInteger pos = new AtomicInteger();\n+    attributes.forEach(\n+        (attributeKey, o) ->\n+            attributeMarshalers[pos.getAndIncrement()] =\n+                AttributeMarshaler.create(attributeKey, o));\n+    return attributeMarshalers;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  static AttributeMarshaler create(AttributeKey<?> attributeKey, Object value) {\n+    ByteString key = MarshalerUtil.toByteString(attributeKey.getKey());\n+    if (value == null) {\n+      return new KeyValueNullMarshaler(key);\n+    }\n+    switch (attributeKey.getType()) {\n+      case STRING:\n+        return new KeyValueStringMarshaler(key, MarshalerUtil.toByteString((String) value));\n+      case LONG:\n+        return new KeyValueLongMarshaler(key, (Long) value);\n+      case BOOLEAN:\n+        return new KeyValueBooleanMarshaler(key, (Boolean) value);\n+      case DOUBLE:\n+        return new KeyValueDoubleMarshaler(key, (Double) value);\n+      case STRING_ARRAY:\n+        return new KeyValueArrayStringMarshaler(key, (List<String>) value);\n+      case LONG_ARRAY:\n+        return new KeyValueArrayLongMarshaler(key, (List<Long>) value);\n+      case BOOLEAN_ARRAY:\n+        return new KeyValueArrayBooleanMarshaler(key, (List<Boolean>) value);\n+      case DOUBLE_ARRAY:\n+        return new KeyValueArrayDoubleMarshaler(key, (List<Double>) value);\n+    }\n+    throw new IllegalArgumentException(\"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYzNzA5OQ=="}, "originalCommit": {"oid": "b288e09faa7d609dcd8739467ac3f1e9576b8169"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNzI4Mzg3OnYy", "diffSide": "RIGHT", "path": "exporters/otlp/src/jmh/java/io/opentelemetry/exporter/otlp/RequestMarshalBenchmarks.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMjowNDozMVrOIGoUmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNDoxMzoyMFrOIGuOwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyMzAwMA==", "bodyText": "If I recall correctly, when size is known gRPC allocates byte[] how about using byte[] instead of ByteBuffer?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543823000", "createdAt": "2020-12-16T02:04:31Z", "author": {"login": "anuraaga"}, "path": "exporters/otlp/src/jmh/java/io/opentelemetry/exporter/otlp/RequestMarshalBenchmarks.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporter.otlp;\n+\n+import com.google.protobuf.CodedOutputStream;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode({Mode.AverageTime})\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@Fork(1)\n+public class RequestMarshalBenchmarks {\n+\n+  @Benchmark\n+  @Threads(1)\n+  public ByteBuffer createProtoMarshal(RequestMarshalState state) {\n+    ExportTraceServiceRequest protoRequest =\n+        ExportTraceServiceRequest.newBuilder()\n+            .addAllResourceSpans(SpanAdapter.toProtoResourceSpans(state.spanDataList))\n+            .build();\n+    return ByteBuffer.allocate(protoRequest.getSerializedSize());\n+  }\n+\n+  @Benchmark\n+  @Threads(1)\n+  public ByteBuffer marshalProto(RequestMarshalState state) throws IOException {\n+    ExportTraceServiceRequest protoRequest =\n+        ExportTraceServiceRequest.newBuilder()\n+            .addAllResourceSpans(SpanAdapter.toProtoResourceSpans(state.spanDataList))\n+            .build();\n+    ByteBuffer protoOutput = ByteBuffer.allocate(protoRequest.getSerializedSize());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31e7b639766295d476d83419f18f23557b85fe57"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkwMzAyNw==", "bodyText": "Good call, will change", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543903027", "createdAt": "2020-12-16T03:51:25Z", "author": {"login": "bogdandrutu"}, "path": "exporters/otlp/src/jmh/java/io/opentelemetry/exporter/otlp/RequestMarshalBenchmarks.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporter.otlp;\n+\n+import com.google.protobuf.CodedOutputStream;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode({Mode.AverageTime})\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@Fork(1)\n+public class RequestMarshalBenchmarks {\n+\n+  @Benchmark\n+  @Threads(1)\n+  public ByteBuffer createProtoMarshal(RequestMarshalState state) {\n+    ExportTraceServiceRequest protoRequest =\n+        ExportTraceServiceRequest.newBuilder()\n+            .addAllResourceSpans(SpanAdapter.toProtoResourceSpans(state.spanDataList))\n+            .build();\n+    return ByteBuffer.allocate(protoRequest.getSerializedSize());\n+  }\n+\n+  @Benchmark\n+  @Threads(1)\n+  public ByteBuffer marshalProto(RequestMarshalState state) throws IOException {\n+    ExportTraceServiceRequest protoRequest =\n+        ExportTraceServiceRequest.newBuilder()\n+            .addAllResourceSpans(SpanAdapter.toProtoResourceSpans(state.spanDataList))\n+            .build();\n+    ByteBuffer protoOutput = ByteBuffer.allocate(protoRequest.getSerializedSize());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyMzAwMA=="}, "originalCommit": {"oid": "31e7b639766295d476d83419f18f23557b85fe57"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkxOTgxMA==", "bodyText": "Done.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543919810", "createdAt": "2020-12-16T04:13:20Z", "author": {"login": "bogdandrutu"}, "path": "exporters/otlp/src/jmh/java/io/opentelemetry/exporter/otlp/RequestMarshalBenchmarks.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporter.otlp;\n+\n+import com.google.protobuf.CodedOutputStream;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode({Mode.AverageTime})\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@Fork(1)\n+public class RequestMarshalBenchmarks {\n+\n+  @Benchmark\n+  @Threads(1)\n+  public ByteBuffer createProtoMarshal(RequestMarshalState state) {\n+    ExportTraceServiceRequest protoRequest =\n+        ExportTraceServiceRequest.newBuilder()\n+            .addAllResourceSpans(SpanAdapter.toProtoResourceSpans(state.spanDataList))\n+            .build();\n+    return ByteBuffer.allocate(protoRequest.getSerializedSize());\n+  }\n+\n+  @Benchmark\n+  @Threads(1)\n+  public ByteBuffer marshalProto(RequestMarshalState state) throws IOException {\n+    ExportTraceServiceRequest protoRequest =\n+        ExportTraceServiceRequest.newBuilder()\n+            .addAllResourceSpans(SpanAdapter.toProtoResourceSpans(state.spanDataList))\n+            .build();\n+    ByteBuffer protoOutput = ByteBuffer.allocate(protoRequest.getSerializedSize());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyMzAwMA=="}, "originalCommit": {"oid": "31e7b639766295d476d83419f18f23557b85fe57"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNzI5MDU4OnYy", "diffSide": "RIGHT", "path": "exporters/otlp/src/jmh/java/io/opentelemetry/exporter/otlp/RequestMarshalState.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMjowNTo1MVrOIGoYpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNDoxMzoyNlrOIGuO6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyNDAzNg==", "bodyText": "Such 0's are relatively rare, how about using more representative IDs? Don't think it affects performance but just in case.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543824036", "createdAt": "2020-12-16T02:05:51Z", "author": {"login": "anuraaga"}, "path": "exporters/otlp/src/jmh/java/io/opentelemetry/exporter/otlp/RequestMarshalState.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporter.otlp;\n+\n+import io.opentelemetry.api.common.AttributeKey;\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.api.trace.Span;\n+import io.opentelemetry.api.trace.SpanContext;\n+import io.opentelemetry.api.trace.SpanId;\n+import io.opentelemetry.api.trace.TraceFlags;\n+import io.opentelemetry.api.trace.TraceId;\n+import io.opentelemetry.api.trace.TraceState;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.testing.trace.TestSpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+\n+@State(Scope.Benchmark)\n+public class RequestMarshalState {\n+  private static final Resource RESOURCE =\n+      Resource.create(\n+          Attributes.builder()\n+              .put(AttributeKey.booleanKey(\"key_bool\"), true)\n+              .put(AttributeKey.stringKey(\"key_string\"), \"string\")\n+              .put(AttributeKey.longKey(\"key_int\"), 100L)\n+              .put(AttributeKey.doubleKey(\"key_double\"), 100.3)\n+              .put(\n+                  AttributeKey.stringArrayKey(\"key_string_array\"),\n+                  Arrays.asList(\"string\", \"string\"))\n+              .put(AttributeKey.longArrayKey(\"key_long_array\"), Arrays.asList(12L, 23L))\n+              .put(AttributeKey.doubleArrayKey(\"key_double_array\"), Arrays.asList(12.3, 23.1))\n+              .put(AttributeKey.booleanArrayKey(\"key_boolean_array\"), Arrays.asList(true, false))\n+              .build());\n+\n+  private static final InstrumentationLibraryInfo INSTRUMENTATION_LIBRARY_INFO =\n+      InstrumentationLibraryInfo.create(\"name\", null);\n+  private static final byte[] TRACE_ID_BYTES =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31e7b639766295d476d83419f18f23557b85fe57"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkwMjYwNg==", "bodyText": "I will change them but for bytes in proto it shouldn\u2019t matter (maybe just from hex to bytes which for comparison that we do is irrelevant both of them doing it", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543902606", "createdAt": "2020-12-16T03:50:51Z", "author": {"login": "bogdandrutu"}, "path": "exporters/otlp/src/jmh/java/io/opentelemetry/exporter/otlp/RequestMarshalState.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporter.otlp;\n+\n+import io.opentelemetry.api.common.AttributeKey;\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.api.trace.Span;\n+import io.opentelemetry.api.trace.SpanContext;\n+import io.opentelemetry.api.trace.SpanId;\n+import io.opentelemetry.api.trace.TraceFlags;\n+import io.opentelemetry.api.trace.TraceId;\n+import io.opentelemetry.api.trace.TraceState;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.testing.trace.TestSpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+\n+@State(Scope.Benchmark)\n+public class RequestMarshalState {\n+  private static final Resource RESOURCE =\n+      Resource.create(\n+          Attributes.builder()\n+              .put(AttributeKey.booleanKey(\"key_bool\"), true)\n+              .put(AttributeKey.stringKey(\"key_string\"), \"string\")\n+              .put(AttributeKey.longKey(\"key_int\"), 100L)\n+              .put(AttributeKey.doubleKey(\"key_double\"), 100.3)\n+              .put(\n+                  AttributeKey.stringArrayKey(\"key_string_array\"),\n+                  Arrays.asList(\"string\", \"string\"))\n+              .put(AttributeKey.longArrayKey(\"key_long_array\"), Arrays.asList(12L, 23L))\n+              .put(AttributeKey.doubleArrayKey(\"key_double_array\"), Arrays.asList(12.3, 23.1))\n+              .put(AttributeKey.booleanArrayKey(\"key_boolean_array\"), Arrays.asList(true, false))\n+              .build());\n+\n+  private static final InstrumentationLibraryInfo INSTRUMENTATION_LIBRARY_INFO =\n+      InstrumentationLibraryInfo.create(\"name\", null);\n+  private static final byte[] TRACE_ID_BYTES =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyNDAzNg=="}, "originalCommit": {"oid": "31e7b639766295d476d83419f18f23557b85fe57"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkxOTg0OA==", "bodyText": "Done.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543919848", "createdAt": "2020-12-16T04:13:26Z", "author": {"login": "bogdandrutu"}, "path": "exporters/otlp/src/jmh/java/io/opentelemetry/exporter/otlp/RequestMarshalState.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporter.otlp;\n+\n+import io.opentelemetry.api.common.AttributeKey;\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.api.trace.Span;\n+import io.opentelemetry.api.trace.SpanContext;\n+import io.opentelemetry.api.trace.SpanId;\n+import io.opentelemetry.api.trace.TraceFlags;\n+import io.opentelemetry.api.trace.TraceId;\n+import io.opentelemetry.api.trace.TraceState;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.testing.trace.TestSpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+\n+@State(Scope.Benchmark)\n+public class RequestMarshalState {\n+  private static final Resource RESOURCE =\n+      Resource.create(\n+          Attributes.builder()\n+              .put(AttributeKey.booleanKey(\"key_bool\"), true)\n+              .put(AttributeKey.stringKey(\"key_string\"), \"string\")\n+              .put(AttributeKey.longKey(\"key_int\"), 100L)\n+              .put(AttributeKey.doubleKey(\"key_double\"), 100.3)\n+              .put(\n+                  AttributeKey.stringArrayKey(\"key_string_array\"),\n+                  Arrays.asList(\"string\", \"string\"))\n+              .put(AttributeKey.longArrayKey(\"key_long_array\"), Arrays.asList(12L, 23L))\n+              .put(AttributeKey.doubleArrayKey(\"key_double_array\"), Arrays.asList(12.3, 23.1))\n+              .put(AttributeKey.booleanArrayKey(\"key_boolean_array\"), Arrays.asList(true, false))\n+              .build());\n+\n+  private static final InstrumentationLibraryInfo INSTRUMENTATION_LIBRARY_INFO =\n+      InstrumentationLibraryInfo.create(\"name\", null);\n+  private static final byte[] TRACE_ID_BYTES =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyNDAzNg=="}, "originalCommit": {"oid": "31e7b639766295d476d83419f18f23557b85fe57"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNzMxODY0OnYy", "diffSide": "RIGHT", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporter/otlp/AttributeMarshaler.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMjoxMTozOFrOIGoqBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNTowNDo1OFrOIGwmFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyODQ4NA==", "bodyText": "It seems unfortunate to instantiate marshallers for each object. Isn't it better to define Marshaler something like\ninterface MarshalerWithSize<T> {\n\n  int serializedSize(T value);\n\n  void writeValue(T value, CodedOutputStream stream);\n}\nand have singleton marshalers?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543828484", "createdAt": "2020-12-16T02:11:38Z", "author": {"login": "anuraaga"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporter/otlp/AttributeMarshaler.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporter.otlp;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.CodedOutputStream;\n+import com.google.protobuf.WireFormat;\n+import io.opentelemetry.api.common.AttributeKey;\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.proto.common.v1.AnyValue;\n+import io.opentelemetry.proto.common.v1.ArrayValue;\n+import io.opentelemetry.proto.common.v1.KeyValue;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+abstract class AttributeMarshaler extends MarshalerWithSize {\n+  private static final AttributeMarshaler[] EMPTY_REPEATED = new AttributeMarshaler[0];\n+  private final ByteString key;\n+  private final int valueSize;\n+\n+  static AttributeMarshaler[] createRepeated(Attributes attributes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31e7b639766295d476d83419f18f23557b85fe57"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgzMDg2OQ==", "bodyText": "Wilder would be to make everything static methods since we don't need to be generic, we only have a single API. But that's probably overboard.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543830869", "createdAt": "2020-12-16T02:14:43Z", "author": {"login": "anuraaga"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporter/otlp/AttributeMarshaler.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporter.otlp;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.CodedOutputStream;\n+import com.google.protobuf.WireFormat;\n+import io.opentelemetry.api.common.AttributeKey;\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.proto.common.v1.AnyValue;\n+import io.opentelemetry.proto.common.v1.ArrayValue;\n+import io.opentelemetry.proto.common.v1.KeyValue;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+abstract class AttributeMarshaler extends MarshalerWithSize {\n+  private static final AttributeMarshaler[] EMPTY_REPEATED = new AttributeMarshaler[0];\n+  private final ByteString key;\n+  private final int valueSize;\n+\n+  static AttributeMarshaler[] createRepeated(Attributes attributes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyODQ4NA=="}, "originalCommit": {"oid": "31e7b639766295d476d83419f18f23557b85fe57"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg5OTM3Mw==", "bodyText": "The problem is that the size of the key needs a conversion to utf8 which is very expensive and allocating one object I measured to be better and do the conversion once. We can always improve more once we have the initial structure in place", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543899373", "createdAt": "2020-12-16T03:46:39Z", "author": {"login": "bogdandrutu"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporter/otlp/AttributeMarshaler.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporter.otlp;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.CodedOutputStream;\n+import com.google.protobuf.WireFormat;\n+import io.opentelemetry.api.common.AttributeKey;\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.proto.common.v1.AnyValue;\n+import io.opentelemetry.proto.common.v1.ArrayValue;\n+import io.opentelemetry.proto.common.v1.KeyValue;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+abstract class AttributeMarshaler extends MarshalerWithSize {\n+  private static final AttributeMarshaler[] EMPTY_REPEATED = new AttributeMarshaler[0];\n+  private final ByteString key;\n+  private final int valueSize;\n+\n+  static AttributeMarshaler[] createRepeated(Attributes attributes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyODQ4NA=="}, "originalCommit": {"oid": "31e7b639766295d476d83419f18f23557b85fe57"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkwMTIwNg==", "bodyText": "I am looking also into a different approach that gogoproto uses which is to calculate size once and then write from the end to the buffer so to avoid the need of caching the size result per message. We have more ways to improve this and I will do a bit more on this during the holidays but still believe it is a good start", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543901206", "createdAt": "2020-12-16T03:48:59Z", "author": {"login": "bogdandrutu"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporter/otlp/AttributeMarshaler.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporter.otlp;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.CodedOutputStream;\n+import com.google.protobuf.WireFormat;\n+import io.opentelemetry.api.common.AttributeKey;\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.proto.common.v1.AnyValue;\n+import io.opentelemetry.proto.common.v1.ArrayValue;\n+import io.opentelemetry.proto.common.v1.KeyValue;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+abstract class AttributeMarshaler extends MarshalerWithSize {\n+  private static final AttributeMarshaler[] EMPTY_REPEATED = new AttributeMarshaler[0];\n+  private final ByteString key;\n+  private final int valueSize;\n+\n+  static AttributeMarshaler[] createRepeated(Attributes attributes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyODQ4NA=="}, "originalCommit": {"oid": "31e7b639766295d476d83419f18f23557b85fe57"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkxNzAxMA==", "bodyText": "Ok - also don't forget we have a fast concurrent weak map now, so it can often be used as an efficient cache when needed. If the attribute key is the main reason for the instantiation, then that'd be easy to cache and maybe a simple win.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543917010", "createdAt": "2020-12-16T04:09:41Z", "author": {"login": "anuraaga"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporter/otlp/AttributeMarshaler.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporter.otlp;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.CodedOutputStream;\n+import com.google.protobuf.WireFormat;\n+import io.opentelemetry.api.common.AttributeKey;\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.proto.common.v1.AnyValue;\n+import io.opentelemetry.proto.common.v1.ArrayValue;\n+import io.opentelemetry.proto.common.v1.KeyValue;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+abstract class AttributeMarshaler extends MarshalerWithSize {\n+  private static final AttributeMarshaler[] EMPTY_REPEATED = new AttributeMarshaler[0];\n+  private final ByteString key;\n+  private final int valueSize;\n+\n+  static AttributeMarshaler[] createRepeated(Attributes attributes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyODQ4NA=="}, "originalCommit": {"oid": "31e7b639766295d476d83419f18f23557b85fe57"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk1ODU0OQ==", "bodyText": "???", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543958549", "createdAt": "2020-12-16T05:04:58Z", "author": {"login": "bogdandrutu"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporter/otlp/AttributeMarshaler.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporter.otlp;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.CodedOutputStream;\n+import com.google.protobuf.WireFormat;\n+import io.opentelemetry.api.common.AttributeKey;\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.proto.common.v1.AnyValue;\n+import io.opentelemetry.proto.common.v1.ArrayValue;\n+import io.opentelemetry.proto.common.v1.KeyValue;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+abstract class AttributeMarshaler extends MarshalerWithSize {\n+  private static final AttributeMarshaler[] EMPTY_REPEATED = new AttributeMarshaler[0];\n+  private final ByteString key;\n+  private final int valueSize;\n+\n+  static AttributeMarshaler[] createRepeated(Attributes attributes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyODQ4NA=="}, "originalCommit": {"oid": "31e7b639766295d476d83419f18f23557b85fe57"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNzgwMjYzOnYy", "diffSide": "RIGHT", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporter/otlp/AttributeMarshaler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMzo1NTozNVrOIGtZwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwMzo1NTozNVrOIGtZwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkwNjI0MA==", "bodyText": "I think asMap.entrySet should work fine too here escape analysis generally performs well for iteration. Otherwise, just\nnew BiConsumer<AttributeKey, Object> {\n  int index = 0;\n\n  void accept(AttributeKey, Object) {\n    attributeMarshalers[index++] = create()\n  }\n}", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543906240", "createdAt": "2020-12-16T03:55:35Z", "author": {"login": "anuraaga"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporter/otlp/AttributeMarshaler.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporter.otlp;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.CodedOutputStream;\n+import com.google.protobuf.WireFormat;\n+import io.opentelemetry.api.common.AttributeKey;\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.proto.common.v1.AnyValue;\n+import io.opentelemetry.proto.common.v1.ArrayValue;\n+import io.opentelemetry.proto.common.v1.KeyValue;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+abstract class AttributeMarshaler extends MarshalerWithSize {\n+  private static final AttributeMarshaler[] EMPTY_REPEATED = new AttributeMarshaler[0];\n+  private final ByteString key;\n+  private final int valueSize;\n+\n+  static AttributeMarshaler[] createRepeated(Attributes attributes) {\n+    if (attributes.isEmpty()) {\n+      return EMPTY_REPEATED;\n+    }\n+\n+    AttributeMarshaler[] attributeMarshalers = new AttributeMarshaler[attributes.size()];\n+    // TODO: Revisit how to avoid the atomic integer creation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31e7b639766295d476d83419f18f23557b85fe57"}, "originalPosition": 31}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1720, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}