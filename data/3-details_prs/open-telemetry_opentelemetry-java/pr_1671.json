{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkwNjU5NjQy", "number": 1671, "title": "support aws eks attributes", "bodyText": "Description: Add AWS EKS attrubutes support\nTesting: Verified in https://github.com/aws-samples/aws-xray-sdk-with-opentelemetry-sample/tree/both-otel-and-xray\nCan get AWS EKS attributes in Span.\nDocumentation: https://docs.aws.amazon.com/xray/latest/devguide/xray-sdk-java-configuration.html#xray-sdk-java-configuration-plugins", "createdAt": "2020-09-22T02:53:00Z", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671", "merged": true, "mergeCommit": {"oid": "056e63f354faac5eb56af429b39272dc9b2f284a"}, "closed": true, "closedAt": "2020-09-27T19:24:27Z", "author": {"login": "wangzlei"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdLO2nuAH2gAyNDkwNjU5NjQyOjM1NTFhNWFkMWEyZWJmY2FmZWUzOTk5ZWM0NWFmNzkzMTYxZTRlMGI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdMjizUgFqTQ5Njk0MzE1NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3551a5ad1a2ebfcafee3999ec45af793161e4e0b", "author": {"user": {"login": "wangzlei", "name": "Lei Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/3551a5ad1a2ebfcafee3999ec45af793161e4e0b", "committedDate": "2020-09-22T02:48:44Z", "message": "support aws eks attributes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMTE1OTE2", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#pullrequestreview-493115916", "createdAt": "2020-09-22T04:09:27Z", "commit": {"oid": "3551a5ad1a2ebfcafee3999ec45af793161e4e0b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNDowOToyN1rOHVpnsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNDoxNjoxMVrOHVptKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ2NDA1MA==", "bodyText": "This is a pretty heavyweight dependency, just one of the transitive dependencies alone is 8MB and I think total it will possibly double the agent size.\nCan you try making direct calls to the API? FWIU, token is just a file to read so authentication is very easy for k8s API so it's mostly just parsing, which doesn't seem too bad.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r492464050", "createdAt": "2020-09-22T04:09:27Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/build.gradle", "diffHunk": "@@ -16,6 +16,11 @@ dependencies {\n             libraries.guava,\n             platform(boms.guava)\n \n+    implementation 'com.fasterxml.jackson.core:jackson-databind:2.11.0',\n+            libraries.guava,\n+            platform(boms.guava)\n+    implementation 'io.kubernetes:client-java:9.0.0'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3551a5ad1a2ebfcafee3999ec45af793161e4e0b"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ2NTQ0OQ==", "bodyText": "Should be able to do one call to get a config map instead of listing\nhttps://docs.openshift.com/container-platform/3.7/rest_api/api/v1.ConfigMap.html#Get-api-v1-namespaces-namespace-configmaps-name", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r492465449", "createdAt": "2020-09-22T04:16:11Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/EksHelper.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.Configuration;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapList;\n+import io.kubernetes.client.util.Config;\n+import java.io.IOException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+class EksHelper {\n+\n+  private static final Logger logger = Logger.getLogger(EksHelper.class.getName());\n+\n+  private static final String NAMESPACE_KUBE_SYSTEM = \"kube-system\";\n+  private static final String NAMESPACE_AWS_CLOUDWATCH = \"amazon-cloudwatch\";\n+  private static final String EKS_CONFIGMAP = \"aws-auth\";\n+  private static final String CLOUDWATCH_CONFIGMAP = \"cluster-info\";\n+  private static final String CLUSTER_NAME_KEY = \"cluster.name\";\n+\n+  @Nullable private final CoreV1Api k8sApi;\n+\n+  public EksHelper() {\n+    CoreV1Api k8sApi = null;\n+    try {\n+      ApiClient client = Config.defaultClient();\n+      Configuration.setDefaultApiClient(client);\n+      k8sApi = new CoreV1Api();\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, \"Failed to init k8s client API, sdk is not running on EKS.\");\n+    }\n+    this.k8sApi = k8sApi;\n+  }\n+\n+  @VisibleForTesting\n+  public EksHelper(CoreV1Api k8sApi) {\n+    this.k8sApi = k8sApi;\n+  }\n+\n+  boolean isEks() {\n+    if (k8sApi == null) {\n+      return false;\n+    }\n+\n+    try {\n+      V1ConfigMapList configMapList =\n+          k8sApi.listNamespacedConfigMap(\n+              NAMESPACE_KUBE_SYSTEM, null, null, null, null, null, null, null, null, null);\n+\n+      if (configMapList == null) {\n+        logger.log(Level.INFO, \"Failed to get configmap of namespace %s.\", NAMESPACE_KUBE_SYSTEM);\n+        return false;\n+      }\n+\n+      for (V1ConfigMap item : configMapList.getItems()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3551a5ad1a2ebfcafee3999ec45af793161e4e0b"}, "originalPosition": 76}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e", "author": {"user": {"login": "wangzlei", "name": "Lei Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/4bdb6814459e66168b7d4a8c265f05bc3b43d18e", "committedDate": "2020-09-25T03:55:51Z", "message": "call k8s api by java native sdk"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MTE4ODk5", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#pullrequestreview-496118899", "createdAt": "2020-09-25T05:26:40Z", "commit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNToyNjo0MFrOHX1cSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTo1NDo1MlrOHX16XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NDg4OQ==", "bodyText": "Nothing particularly restful, let's call it just HttpClient or JdkHttpClient", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494754889", "createdAt": "2020-09-25T05:26:40Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NTUzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return String.format(\"Bearer %s\", content);\n          \n          \n            \n                  return \"Bearer \" + content;\n          \n      \n    \n    \n  \n\nAvoid String.format since it's slow performance and rarely that much more readable", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494755531", "createdAt": "2020-09-25T05:29:10Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      if (requestPropertyMap != null) {\n+        for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+          connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+        }\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.WARNING,\n+            String.format(\n+                \"Error reponse from %s code (%s) text %s\",\n+                urlStr, responseCode, readResponseString(connection)));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Restful Client fetch string failed: %s\", e));\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      throw new IllegalStateException(\"UTF-8 not supported can't happen.\", e);\n+    }\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(String keystorePath) {\n+    try {\n+      KeyStore keyStore = getK8sKeystore(keystorePath);\n+\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception: %s\", e);\n+    }\n+    return null;\n+  }\n+\n+  String getK8sCredHeader(String tokenFilePath) {\n+    try {\n+      File file = new File(tokenFilePath);\n+      String content = Files.asCharSource(file, Charsets.UTF_8).read();\n+      return String.format(\"Bearer %s\", content);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDAzMw==", "bodyText": "Let's avoid doing anything if keyStore is null due to an error. So I guess in the caller,\nKeyStore keyStore = getK8sKeystore(keystorePath);\nif (keyStore != null) { ((HttpsURLConnection))connection.setSslSocketFactory(buildSslSocketFactory(keyStore));", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494760033", "createdAt": "2020-09-25T05:45:47Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      if (requestPropertyMap != null) {\n+        for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+          connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+        }\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.WARNING,\n+            String.format(\n+                \"Error reponse from %s code (%s) text %s\",\n+                urlStr, responseCode, readResponseString(connection)));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Restful Client fetch string failed: %s\", e));\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      throw new IllegalStateException(\"UTF-8 not supported can't happen.\", e);\n+    }\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(String keystorePath) {\n+    try {\n+      KeyStore keyStore = getK8sKeystore(keystorePath);\n+\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDM2Mw==", "bodyText": "This is an internal class, let's assume it's not null", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494760363", "createdAt": "2020-09-25T05:47:01Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      if (requestPropertyMap != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDQ5Ng==", "bodyText": "This is an internal class, let's keep the logic more direct - we can assume not null means not empty, these are passed by our code, not users", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494760496", "createdAt": "2020-09-25T05:47:31Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDU3Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n          \n          \n            \n                    connection = new URL(urlStr).openConnection();", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494760573", "createdAt": "2020-09-25T05:47:48Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDYwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    connection = (HttpURLConnection) new URL(urlStr).openConnection();\n          \n          \n            \n                    connection = new URL(urlStr).openConnection();", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494760607", "createdAt": "2020-09-25T05:47:54Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDY2Ng==", "bodyText": "Check the urlStr is https before", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494760666", "createdAt": "2020-09-25T05:48:07Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MTQ3MA==", "bodyText": "Can clean up a bit I think\nFile caFile = new File(caFilePath); // Oh by the way, let's rename this variable from keystorePath :)\nif (!caFile.exists()) {\n  return null;\n}\n\ntry (InputStream certStream = new FileInputStream(caFile)) {\n  KeyStore trustStore = KeyStore.getInstance()\n  ...\n\n  return trustStore;\n} catch ()\n// No need for finally :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494761470", "createdAt": "2020-09-25T05:50:47Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      if (requestPropertyMap != null) {\n+        for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+          connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+        }\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.WARNING,\n+            String.format(\n+                \"Error reponse from %s code (%s) text %s\",\n+                urlStr, responseCode, readResponseString(connection)));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Restful Client fetch string failed: %s\", e));\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      throw new IllegalStateException(\"UTF-8 not supported can't happen.\", e);\n+    }\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(String keystorePath) {\n+    try {\n+      KeyStore keyStore = getK8sKeystore(keystorePath);\n+\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception: %s\", e);\n+    }\n+    return null;\n+  }\n+\n+  String getK8sCredHeader(String tokenFilePath) {\n+    try {\n+      File file = new File(tokenFilePath);\n+      String content = Files.asCharSource(file, Charsets.UTF_8).read();\n+      return String.format(\"Bearer %s\", content);\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Unable to load K8s client token: %s\", e));\n+    }\n+    return \"\";\n+  }\n+\n+  private static KeyStore getK8sKeystore(String keyStorePath) {\n+    InputStream certificateFile = null;\n+    try {\n+      KeyStore trustStore = null;\n+      File caFile = new File(keyStorePath);\n+\n+      if (caFile.exists()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MTU4NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      throw new IllegalArgumentException(\"K8s cert file contained no certificates.\");\n          \n          \n            \n                      return null;", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494761584", "createdAt": "2020-09-25T05:51:12Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      if (requestPropertyMap != null) {\n+        for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+          connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+        }\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.WARNING,\n+            String.format(\n+                \"Error reponse from %s code (%s) text %s\",\n+                urlStr, responseCode, readResponseString(connection)));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Restful Client fetch string failed: %s\", e));\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      throw new IllegalStateException(\"UTF-8 not supported can't happen.\", e);\n+    }\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(String keystorePath) {\n+    try {\n+      KeyStore keyStore = getK8sKeystore(keystorePath);\n+\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception: %s\", e);\n+    }\n+    return null;\n+  }\n+\n+  String getK8sCredHeader(String tokenFilePath) {\n+    try {\n+      File file = new File(tokenFilePath);\n+      String content = Files.asCharSource(file, Charsets.UTF_8).read();\n+      return String.format(\"Bearer %s\", content);\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Unable to load K8s client token: %s\", e));\n+    }\n+    return \"\";\n+  }\n+\n+  private static KeyStore getK8sKeystore(String keyStorePath) {\n+    InputStream certificateFile = null;\n+    try {\n+      KeyStore trustStore = null;\n+      File caFile = new File(keyStorePath);\n+\n+      if (caFile.exists()) {\n+        trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+        trustStore.load(null, null);\n+        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\");\n+\n+        certificateFile = new FileInputStream(caFile);\n+        Collection<? extends Certificate> certificates =\n+            certificateFactory.generateCertificates(certificateFile);\n+\n+        if (certificates.isEmpty()) {\n+          throw new IllegalArgumentException(\"K8s cert file contained no certificates.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MjAxMA==", "bodyText": "I switched the logging to FINE recently - since resource attributes are still a nice-to-have and not must, we should only log for debug logging and not as warnings.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494762010", "createdAt": "2020-09-25T05:52:40Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      if (requestPropertyMap != null) {\n+        for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+          connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+        }\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.WARNING,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MjU4OA==", "bodyText": "Offline you mentioned trouble testing HTTPS. Yeah it looks like wiremock only supports Java keystore, but not a certificate file. Armeria's mock server supports certificate files well so we'll probably switch to it, for now can leave a TODO", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494762588", "createdAt": "2020-09-25T05:54:52Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/test/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClientTest.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.any;\n+import static com.github.tomakehurst.wiremock.client.WireMock.equalTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.getRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.ok;\n+import static com.github.tomakehurst.wiremock.client.WireMock.stubFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlPathEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static com.github.tomakehurst.wiremock.core.WireMockConfiguration.wireMockConfig;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.github.tomakehurst.wiremock.junit.WireMockClassRule;\n+import com.google.common.collect.ImmutableMap;\n+import java.io.IOException;\n+import java.util.Map;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+public class RestfulClientTest {\n+\n+  @ClassRule\n+  public static WireMockClassRule server = new WireMockClassRule(wireMockConfig().dynamicPort());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 40}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e369a2a52dfff991f4899d5425257147965d60ec", "author": {"user": {"login": "wangzlei", "name": "Lei Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/e369a2a52dfff991f4899d5425257147965d60ec", "committedDate": "2020-09-25T21:41:53Z", "message": "fix code review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2OTMzNTQ1", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#pullrequestreview-496933545", "createdAt": "2020-09-26T02:43:18Z", "commit": {"oid": "e369a2a52dfff991f4899d5425257147965d60ec"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMjo0MzoxOFrOHYcdbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMjo0ODoxMFrOHYck9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM5NDE1Ng==", "bodyText": "Ah sorry in that case let cast to HttpUrlConnection here - the variable is that type so it's weird using a different one when casting.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495394156", "createdAt": "2020-09-26T02:43:18Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class JdkHttpClient {\n+\n+  private static final Logger logger = Logger.getLogger(JdkHttpClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (urlStr.startsWith(\"https\")) {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e369a2a52dfff991f4899d5425257147965d60ec"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM5NDY2MQ==", "bodyText": "Here also FINE, I think this is the block that's hit when the server doesn't exist at all (matters more when we switch Ec2Resource to this new class)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495394661", "createdAt": "2020-09-26T02:44:30Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class JdkHttpClient {\n+\n+  private static final Logger logger = Logger.getLogger(JdkHttpClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (urlStr.startsWith(\"https\")) {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        KeyStore keyStore = getK8sKeystore(keyStorePath);\n+        if (keyStore != null) {\n+          ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStore));\n+        }\n+      } else {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+        connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.FINE,\n+            \"Error reponse from \"\n+                + urlStr\n+                + \" code (\"\n+                + responseCode\n+                + \") text \"\n+                + readResponseString(connection));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, \"JdkHttpClient fetch string failed: \" + e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e369a2a52dfff991f4899d5425257147965d60ec"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM5NTIzNg==", "bodyText": "Package private", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495395236", "createdAt": "2020-09-26T02:45:59Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class JdkHttpClient {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e369a2a52dfff991f4899d5425257147965d60ec"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM5NTcxNw==", "bodyText": "Move this into EksResource it's k8s specific", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495395717", "createdAt": "2020-09-26T02:47:05Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class JdkHttpClient {\n+\n+  private static final Logger logger = Logger.getLogger(JdkHttpClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (urlStr.startsWith(\"https\")) {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        KeyStore keyStore = getK8sKeystore(keyStorePath);\n+        if (keyStore != null) {\n+          ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStore));\n+        }\n+      } else {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+        connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.FINE,\n+            \"Error reponse from \"\n+                + urlStr\n+                + \" code (\"\n+                + responseCode\n+                + \") text \"\n+                + readResponseString(connection));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, \"JdkHttpClient fetch string failed: \" + e);\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      logger.log(Level.WARNING, \"UTF-8 not supported can't happen. \" + e);\n+    }\n+    return \"\";\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(KeyStore keyStore) {\n+    try {\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception: \" + e);\n+    }\n+    return null;\n+  }\n+\n+  String getK8sCredHeader(String tokenFilePath) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e369a2a52dfff991f4899d5425257147965d60ec"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM5NjA4Nw==", "bodyText": "Rename to not be k8s since it's just about client TLS trusted cert.\ngetKeystoreForTrustedCert(String certPath) for example", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495396087", "createdAt": "2020-09-26T02:48:10Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class JdkHttpClient {\n+\n+  private static final Logger logger = Logger.getLogger(JdkHttpClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (urlStr.startsWith(\"https\")) {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        KeyStore keyStore = getK8sKeystore(keyStorePath);\n+        if (keyStore != null) {\n+          ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStore));\n+        }\n+      } else {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+        connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.FINE,\n+            \"Error reponse from \"\n+                + urlStr\n+                + \" code (\"\n+                + responseCode\n+                + \") text \"\n+                + readResponseString(connection));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, \"JdkHttpClient fetch string failed: \" + e);\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      logger.log(Level.WARNING, \"UTF-8 not supported can't happen. \" + e);\n+    }\n+    return \"\";\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(KeyStore keyStore) {\n+    try {\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception: \" + e);\n+    }\n+    return null;\n+  }\n+\n+  String getK8sCredHeader(String tokenFilePath) {\n+    try {\n+      File file = new File(tokenFilePath);\n+      String content = Files.asCharSource(file, Charsets.UTF_8).read();\n+      return \"Bearer \" + content;\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, \"Unable to load K8s client token: \" + e);\n+    }\n+    return \"\";\n+  }\n+\n+  private static KeyStore getK8sKeystore(String keyStorePath) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e369a2a52dfff991f4899d5425257147965d60ec"}, "originalPosition": 146}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1133693bec062259e1766554e501b56244417d27", "author": {"user": {"login": "wangzlei", "name": "Lei Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/1133693bec062259e1766554e501b56244417d27", "committedDate": "2020-09-26T04:37:36Z", "message": "fix code review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be35b8cb91f0c5170ad11ced929a64985c2fb22a", "author": {"user": {"login": "wangzlei", "name": "Lei Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/be35b8cb91f0c5170ad11ced929a64985c2fb22a", "committedDate": "2020-09-26T04:41:24Z", "message": "fix code review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2OTQzMTU1", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#pullrequestreview-496943155", "createdAt": "2020-09-26T05:28:19Z", "commit": {"oid": "be35b8cb91f0c5170ad11ced929a64985c2fb22a"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwNToyODoxOVrOHYd5vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwNToyODoxOVrOHYd5vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxNzc5MA==", "bodyText": "Ah good catch - if we need index let's just use traditional for loop. for(int i = 0; I < ...", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495417790", "createdAt": "2020-09-26T05:28:19Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.io.ByteStreams;\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+class JdkHttpClient {\n+\n+  private static final Logger logger = Logger.getLogger(JdkHttpClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod, String urlStr, Map<String, String> requestPropertyMap, String certPath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (urlStr.startsWith(\"https\")) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+        KeyStore keyStore = getKeystoreForTrustedCert(certPath);\n+        if (keyStore != null) {\n+          ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStore));\n+        }\n+      } else {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+        connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.FINE,\n+            \"Error reponse from \"\n+                + urlStr\n+                + \" code (\"\n+                + responseCode\n+                + \") text \"\n+                + readResponseString(connection));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.FINE, \"JdkHttpClient fetch string failed.\", e);\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      logger.log(Level.WARNING, \"UTF-8 not supported can't happen.\", e);\n+    }\n+    return \"\";\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(KeyStore keyStore) {\n+    try {\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception.\", e);\n+    }\n+    return null;\n+  }\n+\n+  private static KeyStore getKeystoreForTrustedCert(String certPath) {\n+    try (FileInputStream fis = new FileInputStream(certPath)) {\n+      KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+      trustStore.load(null, null);\n+      CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\");\n+\n+      Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(fis);\n+\n+      int i = 0;\n+      for (Certificate certificate : certificates) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be35b8cb91f0c5170ad11ced929a64985c2fb22a"}, "originalPosition": 138}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3466, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}