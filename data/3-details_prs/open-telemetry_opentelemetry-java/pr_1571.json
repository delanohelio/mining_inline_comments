{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcxMzgyMjky", "number": 1571, "title": "Make sure forceFlush / shutdown can have callers wait for them to be done by returning CompletableResultCode.", "bodyText": "/cc @huntc\nFixes #1584", "createdAt": "2020-08-21T05:13:04Z", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571", "merged": true, "mergeCommit": {"oid": "c6c179c2671fc73481a66f0b09aed8a71341becb"}, "closed": true, "closedAt": "2020-08-28T17:51:40Z", "author": {"login": "anuraaga"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdA_Jp6AFqTQ3MjIyMTM0NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdDYx5lAFqTQ3NzkyMDAxNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyMjIxMzQ1", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#pullrequestreview-472221345", "createdAt": "2020-08-21T06:39:18Z", "commit": {"oid": "36f640a16803f2c3e8d1d8ab65ab061df58cd1a0"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwNjozOToxOFrOHEdZnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwNjo1MDo1MlrOHEdqFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQzODA0NA==", "bodyText": "Shouldn't this always update nextExport?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r474438044", "createdAt": "2020-08-21T06:39:18Z", "author": {"login": "iNikem"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -132,180 +160,72 @@ public boolean isEndRequired() {\n \n   @Override\n   public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n+    forceFlush();\n+    ScheduledFuture<?> nextExport = this.nextExport;\n+    if (nextExport != null) {\n+      nextExport.cancel(false);\n+    }\n+    executor.shutdown();\n+    spanExporter.shutdown();\n   }\n \n   @Override\n   public void forceFlush() {\n-    worker.forceFlush();\n+    exportBatch();\n   }\n \n-  // Worker is a thread that batches multiple spans and calls the registered SpanExporter to export\n-  // the data.\n-  //\n-  // The list of batched data is protected by an explicit monitor object which ensures full\n-  // concurrency.\n-  private static final class Worker implements Runnable {\n-\n-    static {\n-      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.trace\");\n-      LongCounter droppedSpansCounter =\n-          meter\n-              .longCounterBuilder(\"droppedSpans\")\n-              .setUnit(\"1\")\n-              .setDescription(\n-                  \"The number of spans dropped by the BatchSpanProcessor due to high throughput.\")\n-              .build();\n-      droppedSpans =\n-          droppedSpansCounter.bind(\n-              Labels.of(\"spanProcessorType\", BatchSpanProcessor.class.getSimpleName()));\n-    }\n-\n-    private static final BoundLongCounter droppedSpans;\n-\n-    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n-\n-    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n-    private final SpanExporter spanExporter;\n-    private final long scheduleDelayMillis;\n-    private final int maxQueueSize;\n-    private final int maxExportBatchSize;\n-    private final int halfMaxQueueSize;\n-    private final Object monitor = new Object();\n-    private final int exporterTimeoutMillis;\n-    private final AtomicBoolean exportAvailable = new AtomicBoolean(true);\n-\n-    @GuardedBy(\"monitor\")\n-    private final List<ReadableSpan> spansList;\n-\n-    private Worker(\n-        SpanExporter spanExporter,\n-        long scheduleDelayMillis,\n-        int maxQueueSize,\n-        int maxExportBatchSize,\n-        int exporterTimeoutMillis) {\n-      this.spanExporter = spanExporter;\n-      this.scheduleDelayMillis = scheduleDelayMillis;\n-      this.maxQueueSize = maxQueueSize;\n-      this.halfMaxQueueSize = maxQueueSize >> 1;\n-      this.maxExportBatchSize = maxExportBatchSize;\n-      this.exporterTimeoutMillis = exporterTimeoutMillis;\n-      this.spansList = new ArrayList<>(maxQueueSize);\n+  // Timeout is best effort don't need to handle the future return value.\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void exportBatch() {\n+    List<ReadableSpan> batch = new ArrayList<>(Math.min(maxExportBatchSize, queue.size()));\n+    if (queue.drainTo(batch, maxExportBatchSize) == 0) {\n+      scheduleNextExport();\n+      return;\n     }\n \n-    private void addSpan(ReadableSpan span) {\n-      synchronized (monitor) {\n-        if (spansList.size() == maxQueueSize) {\n-          droppedSpans.add(1);\n-          return;\n-        }\n-        // TODO: Record a gauge for referenced spans.\n-        spansList.add(span);\n-        // Notify the worker thread that at half of the queue is available. It will take\n-        // time anyway for the thread to wake up.\n-        if (spansList.size() >= halfMaxQueueSize) {\n-          monitor.notifyAll();\n-        }\n-      }\n+    List<SpanData> forExport = new ArrayList<>(batch.size());\n+    for (ReadableSpan span : batch) {\n+      forExport.add(span.toSpanData());\n     }\n \n-    @Override\n-    public void run() {\n-      while (!Thread.currentThread().isInterrupted()) {\n-        // Copy all the batched spans in a separate list to release the monitor lock asap to\n-        // avoid blocking the producer thread.\n-        ArrayList<ReadableSpan> spansCopy;\n-        synchronized (monitor) {\n-          // If still maxExportBatchSize elements in the queue better to execute an extra\n-          if (spansList.size() < maxExportBatchSize) {\n-            do {\n-              // In the case of a spurious wakeup we export only if we have at least one span in\n-              // the batch. It is acceptable because batching is a best effort mechanism here.\n-              try {\n-                monitor.wait(scheduleDelayMillis);\n-              } catch (InterruptedException ie) {\n-                // Preserve the interruption status as per guidance and stop doing any work.\n-                Thread.currentThread().interrupt();\n-                return;\n-              }\n-            } while (spansList.isEmpty());\n+    final CompletableResultCode result = spanExporter.export(forExport);\n+    result.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            if (!result.isSuccess()) {\n+              logger.log(Level.FINE, \"Exporter failed\");\n+            }\n+            if (queue.size() >= maxExportBatchSize) {\n+              exportBatch();\n+            } else {\n+              scheduleNextExport();\n+            }\n           }\n-          spansCopy = new ArrayList<>(spansList);\n-          spansList.clear();\n-        }\n-        // Execute the batch export outside the synchronized to not block all producers.\n-        exportBatches(spansCopy);\n-      }\n-    }\n-\n-    private void shutdown() {\n-      forceFlush();\n-      timer.cancel();\n-      spanExporter.shutdown();\n-    }\n-\n-    private void forceFlush() {\n-      ArrayList<ReadableSpan> spansCopy;\n-      synchronized (monitor) {\n-        spansCopy = new ArrayList<>(spansList);\n-        spansList.clear();\n-      }\n-      // Execute the batch export outside the synchronized to not block all producers.\n-      exportBatches(spansCopy);\n-    }\n-\n-    private void exportBatches(ArrayList<ReadableSpan> spanList) {\n-      // TODO: Record a counter for pushed spans.\n-      for (int i = 0; i < spanList.size(); ) {\n-        int lastIndexToTake = Math.min(i + maxExportBatchSize, spanList.size());\n-        onBatchExport(createSpanDataForExport(spanList, i, lastIndexToTake));\n-        i = lastIndexToTake;\n-      }\n-    }\n-\n-    private static List<SpanData> createSpanDataForExport(\n-        List<ReadableSpan> spanList, int startIndex, int endIndex) {\n-      List<SpanData> spanDataBuffer = new ArrayList<>(endIndex - startIndex);\n-      for (int i = startIndex; i < endIndex; i++) {\n-        spanDataBuffer.add(spanList.get(i).toSpanData());\n-        // Remove the reference to the ReadableSpan to allow GC to free the memory.\n-        spanList.set(i, null);\n-      }\n-      return Collections.unmodifiableList(spanDataBuffer);\n-    }\n+        });\n+\n+    // Timeout if result doesn't complete soon enough.\n+    executor.schedule(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            result.fail();\n+          }\n+        },\n+        exporterTimeoutMillis,\n+        TimeUnit.MILLISECONDS);\n+  }\n \n-    // Exports the list of SpanData to the SpanExporter.\n-    @SuppressWarnings(\"BooleanParameter\")\n-    private void onBatchExport(final List<SpanData> spans) {\n-      if (exportAvailable.compareAndSet(true, false)) {\n-        try {\n-          final CompletableResultCode result = spanExporter.export(spans);\n-          result.whenComplete(\n-              new Runnable() {\n-                @Override\n-                public void run() {\n-                  if (!result.isSuccess()) {\n-                    logger.log(Level.FINE, \"Exporter failed\");\n-                  }\n-                  exportAvailable.set(true);\n-                }\n-              });\n-          timer.schedule(\n-              new TimerTask() {\n-                @Override\n-                public void run() {\n-                  result.fail();\n-                }\n-              },\n-              exporterTimeoutMillis);\n-        } catch (Exception e) {\n-          logger.log(Level.WARNING, \"Exporter threw an Exception\", e);\n-        }\n-      } else {\n-        logger.log(Level.FINE, \"Exporter busy. Dropping spans.\");\n-      }\n-    }\n+  private ScheduledFuture<?> scheduleNextExport() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36f640a16803f2c3e8d1d8ab65ab061df58cd1a0"}, "originalPosition": 325}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQzODkxOQ==", "bodyText": "Not specific to this PR: Why this timeout is the configuration of BSP and not of the exporter?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r474438919", "createdAt": "2020-08-21T06:41:52Z", "author": {"login": "iNikem"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -132,180 +160,72 @@ public boolean isEndRequired() {\n \n   @Override\n   public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n+    forceFlush();\n+    ScheduledFuture<?> nextExport = this.nextExport;\n+    if (nextExport != null) {\n+      nextExport.cancel(false);\n+    }\n+    executor.shutdown();\n+    spanExporter.shutdown();\n   }\n \n   @Override\n   public void forceFlush() {\n-    worker.forceFlush();\n+    exportBatch();\n   }\n \n-  // Worker is a thread that batches multiple spans and calls the registered SpanExporter to export\n-  // the data.\n-  //\n-  // The list of batched data is protected by an explicit monitor object which ensures full\n-  // concurrency.\n-  private static final class Worker implements Runnable {\n-\n-    static {\n-      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.trace\");\n-      LongCounter droppedSpansCounter =\n-          meter\n-              .longCounterBuilder(\"droppedSpans\")\n-              .setUnit(\"1\")\n-              .setDescription(\n-                  \"The number of spans dropped by the BatchSpanProcessor due to high throughput.\")\n-              .build();\n-      droppedSpans =\n-          droppedSpansCounter.bind(\n-              Labels.of(\"spanProcessorType\", BatchSpanProcessor.class.getSimpleName()));\n-    }\n-\n-    private static final BoundLongCounter droppedSpans;\n-\n-    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n-\n-    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n-    private final SpanExporter spanExporter;\n-    private final long scheduleDelayMillis;\n-    private final int maxQueueSize;\n-    private final int maxExportBatchSize;\n-    private final int halfMaxQueueSize;\n-    private final Object monitor = new Object();\n-    private final int exporterTimeoutMillis;\n-    private final AtomicBoolean exportAvailable = new AtomicBoolean(true);\n-\n-    @GuardedBy(\"monitor\")\n-    private final List<ReadableSpan> spansList;\n-\n-    private Worker(\n-        SpanExporter spanExporter,\n-        long scheduleDelayMillis,\n-        int maxQueueSize,\n-        int maxExportBatchSize,\n-        int exporterTimeoutMillis) {\n-      this.spanExporter = spanExporter;\n-      this.scheduleDelayMillis = scheduleDelayMillis;\n-      this.maxQueueSize = maxQueueSize;\n-      this.halfMaxQueueSize = maxQueueSize >> 1;\n-      this.maxExportBatchSize = maxExportBatchSize;\n-      this.exporterTimeoutMillis = exporterTimeoutMillis;\n-      this.spansList = new ArrayList<>(maxQueueSize);\n+  // Timeout is best effort don't need to handle the future return value.\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void exportBatch() {\n+    List<ReadableSpan> batch = new ArrayList<>(Math.min(maxExportBatchSize, queue.size()));\n+    if (queue.drainTo(batch, maxExportBatchSize) == 0) {\n+      scheduleNextExport();\n+      return;\n     }\n \n-    private void addSpan(ReadableSpan span) {\n-      synchronized (monitor) {\n-        if (spansList.size() == maxQueueSize) {\n-          droppedSpans.add(1);\n-          return;\n-        }\n-        // TODO: Record a gauge for referenced spans.\n-        spansList.add(span);\n-        // Notify the worker thread that at half of the queue is available. It will take\n-        // time anyway for the thread to wake up.\n-        if (spansList.size() >= halfMaxQueueSize) {\n-          monitor.notifyAll();\n-        }\n-      }\n+    List<SpanData> forExport = new ArrayList<>(batch.size());\n+    for (ReadableSpan span : batch) {\n+      forExport.add(span.toSpanData());\n     }\n \n-    @Override\n-    public void run() {\n-      while (!Thread.currentThread().isInterrupted()) {\n-        // Copy all the batched spans in a separate list to release the monitor lock asap to\n-        // avoid blocking the producer thread.\n-        ArrayList<ReadableSpan> spansCopy;\n-        synchronized (monitor) {\n-          // If still maxExportBatchSize elements in the queue better to execute an extra\n-          if (spansList.size() < maxExportBatchSize) {\n-            do {\n-              // In the case of a spurious wakeup we export only if we have at least one span in\n-              // the batch. It is acceptable because batching is a best effort mechanism here.\n-              try {\n-                monitor.wait(scheduleDelayMillis);\n-              } catch (InterruptedException ie) {\n-                // Preserve the interruption status as per guidance and stop doing any work.\n-                Thread.currentThread().interrupt();\n-                return;\n-              }\n-            } while (spansList.isEmpty());\n+    final CompletableResultCode result = spanExporter.export(forExport);\n+    result.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            if (!result.isSuccess()) {\n+              logger.log(Level.FINE, \"Exporter failed\");\n+            }\n+            if (queue.size() >= maxExportBatchSize) {\n+              exportBatch();\n+            } else {\n+              scheduleNextExport();\n+            }\n           }\n-          spansCopy = new ArrayList<>(spansList);\n-          spansList.clear();\n-        }\n-        // Execute the batch export outside the synchronized to not block all producers.\n-        exportBatches(spansCopy);\n-      }\n-    }\n-\n-    private void shutdown() {\n-      forceFlush();\n-      timer.cancel();\n-      spanExporter.shutdown();\n-    }\n-\n-    private void forceFlush() {\n-      ArrayList<ReadableSpan> spansCopy;\n-      synchronized (monitor) {\n-        spansCopy = new ArrayList<>(spansList);\n-        spansList.clear();\n-      }\n-      // Execute the batch export outside the synchronized to not block all producers.\n-      exportBatches(spansCopy);\n-    }\n-\n-    private void exportBatches(ArrayList<ReadableSpan> spanList) {\n-      // TODO: Record a counter for pushed spans.\n-      for (int i = 0; i < spanList.size(); ) {\n-        int lastIndexToTake = Math.min(i + maxExportBatchSize, spanList.size());\n-        onBatchExport(createSpanDataForExport(spanList, i, lastIndexToTake));\n-        i = lastIndexToTake;\n-      }\n-    }\n-\n-    private static List<SpanData> createSpanDataForExport(\n-        List<ReadableSpan> spanList, int startIndex, int endIndex) {\n-      List<SpanData> spanDataBuffer = new ArrayList<>(endIndex - startIndex);\n-      for (int i = startIndex; i < endIndex; i++) {\n-        spanDataBuffer.add(spanList.get(i).toSpanData());\n-        // Remove the reference to the ReadableSpan to allow GC to free the memory.\n-        spanList.set(i, null);\n-      }\n-      return Collections.unmodifiableList(spanDataBuffer);\n-    }\n+        });\n+\n+    // Timeout if result doesn't complete soon enough.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36f640a16803f2c3e8d1d8ab65ab061df58cd1a0"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQzOTY5NA==", "bodyText": "Should benchmark this, but we can save on allocations if we take elements by one, convert them to SpanData and only then put to outgoing forExport. Then we don't need batch.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r474439694", "createdAt": "2020-08-21T06:44:01Z", "author": {"login": "iNikem"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -132,180 +160,72 @@ public boolean isEndRequired() {\n \n   @Override\n   public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n+    forceFlush();\n+    ScheduledFuture<?> nextExport = this.nextExport;\n+    if (nextExport != null) {\n+      nextExport.cancel(false);\n+    }\n+    executor.shutdown();\n+    spanExporter.shutdown();\n   }\n \n   @Override\n   public void forceFlush() {\n-    worker.forceFlush();\n+    exportBatch();\n   }\n \n-  // Worker is a thread that batches multiple spans and calls the registered SpanExporter to export\n-  // the data.\n-  //\n-  // The list of batched data is protected by an explicit monitor object which ensures full\n-  // concurrency.\n-  private static final class Worker implements Runnable {\n-\n-    static {\n-      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.trace\");\n-      LongCounter droppedSpansCounter =\n-          meter\n-              .longCounterBuilder(\"droppedSpans\")\n-              .setUnit(\"1\")\n-              .setDescription(\n-                  \"The number of spans dropped by the BatchSpanProcessor due to high throughput.\")\n-              .build();\n-      droppedSpans =\n-          droppedSpansCounter.bind(\n-              Labels.of(\"spanProcessorType\", BatchSpanProcessor.class.getSimpleName()));\n-    }\n-\n-    private static final BoundLongCounter droppedSpans;\n-\n-    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n-\n-    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n-    private final SpanExporter spanExporter;\n-    private final long scheduleDelayMillis;\n-    private final int maxQueueSize;\n-    private final int maxExportBatchSize;\n-    private final int halfMaxQueueSize;\n-    private final Object monitor = new Object();\n-    private final int exporterTimeoutMillis;\n-    private final AtomicBoolean exportAvailable = new AtomicBoolean(true);\n-\n-    @GuardedBy(\"monitor\")\n-    private final List<ReadableSpan> spansList;\n-\n-    private Worker(\n-        SpanExporter spanExporter,\n-        long scheduleDelayMillis,\n-        int maxQueueSize,\n-        int maxExportBatchSize,\n-        int exporterTimeoutMillis) {\n-      this.spanExporter = spanExporter;\n-      this.scheduleDelayMillis = scheduleDelayMillis;\n-      this.maxQueueSize = maxQueueSize;\n-      this.halfMaxQueueSize = maxQueueSize >> 1;\n-      this.maxExportBatchSize = maxExportBatchSize;\n-      this.exporterTimeoutMillis = exporterTimeoutMillis;\n-      this.spansList = new ArrayList<>(maxQueueSize);\n+  // Timeout is best effort don't need to handle the future return value.\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void exportBatch() {\n+    List<ReadableSpan> batch = new ArrayList<>(Math.min(maxExportBatchSize, queue.size()));\n+    if (queue.drainTo(batch, maxExportBatchSize) == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36f640a16803f2c3e8d1d8ab65ab061df58cd1a0"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQzOTkyNQ==", "bodyText": "Can we reuse this list and not re-allocate it on every export?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r474439925", "createdAt": "2020-08-21T06:44:41Z", "author": {"login": "iNikem"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -132,180 +160,72 @@ public boolean isEndRequired() {\n \n   @Override\n   public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n+    forceFlush();\n+    ScheduledFuture<?> nextExport = this.nextExport;\n+    if (nextExport != null) {\n+      nextExport.cancel(false);\n+    }\n+    executor.shutdown();\n+    spanExporter.shutdown();\n   }\n \n   @Override\n   public void forceFlush() {\n-    worker.forceFlush();\n+    exportBatch();\n   }\n \n-  // Worker is a thread that batches multiple spans and calls the registered SpanExporter to export\n-  // the data.\n-  //\n-  // The list of batched data is protected by an explicit monitor object which ensures full\n-  // concurrency.\n-  private static final class Worker implements Runnable {\n-\n-    static {\n-      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.trace\");\n-      LongCounter droppedSpansCounter =\n-          meter\n-              .longCounterBuilder(\"droppedSpans\")\n-              .setUnit(\"1\")\n-              .setDescription(\n-                  \"The number of spans dropped by the BatchSpanProcessor due to high throughput.\")\n-              .build();\n-      droppedSpans =\n-          droppedSpansCounter.bind(\n-              Labels.of(\"spanProcessorType\", BatchSpanProcessor.class.getSimpleName()));\n-    }\n-\n-    private static final BoundLongCounter droppedSpans;\n-\n-    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n-\n-    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n-    private final SpanExporter spanExporter;\n-    private final long scheduleDelayMillis;\n-    private final int maxQueueSize;\n-    private final int maxExportBatchSize;\n-    private final int halfMaxQueueSize;\n-    private final Object monitor = new Object();\n-    private final int exporterTimeoutMillis;\n-    private final AtomicBoolean exportAvailable = new AtomicBoolean(true);\n-\n-    @GuardedBy(\"monitor\")\n-    private final List<ReadableSpan> spansList;\n-\n-    private Worker(\n-        SpanExporter spanExporter,\n-        long scheduleDelayMillis,\n-        int maxQueueSize,\n-        int maxExportBatchSize,\n-        int exporterTimeoutMillis) {\n-      this.spanExporter = spanExporter;\n-      this.scheduleDelayMillis = scheduleDelayMillis;\n-      this.maxQueueSize = maxQueueSize;\n-      this.halfMaxQueueSize = maxQueueSize >> 1;\n-      this.maxExportBatchSize = maxExportBatchSize;\n-      this.exporterTimeoutMillis = exporterTimeoutMillis;\n-      this.spansList = new ArrayList<>(maxQueueSize);\n+  // Timeout is best effort don't need to handle the future return value.\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void exportBatch() {\n+    List<ReadableSpan> batch = new ArrayList<>(Math.min(maxExportBatchSize, queue.size()));\n+    if (queue.drainTo(batch, maxExportBatchSize) == 0) {\n+      scheduleNextExport();\n+      return;\n     }\n \n-    private void addSpan(ReadableSpan span) {\n-      synchronized (monitor) {\n-        if (spansList.size() == maxQueueSize) {\n-          droppedSpans.add(1);\n-          return;\n-        }\n-        // TODO: Record a gauge for referenced spans.\n-        spansList.add(span);\n-        // Notify the worker thread that at half of the queue is available. It will take\n-        // time anyway for the thread to wake up.\n-        if (spansList.size() >= halfMaxQueueSize) {\n-          monitor.notifyAll();\n-        }\n-      }\n+    List<SpanData> forExport = new ArrayList<>(batch.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36f640a16803f2c3e8d1d8ab65ab061df58cd1a0"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0MjI2Mw==", "bodyText": "I am concerned, that if any error situation prevents the runtime to reach this line for one export attempt, then the whole BSP will stop working. It seem that current design (schedule next export when this one finishes) tries to achieve \"fixed delay\". If we switch to \"fixed rate\" we can simplify it. I don't see why \"fixed rate\" is worse than \"fixed delay\".", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r474442263", "createdAt": "2020-08-21T06:50:52Z", "author": {"login": "iNikem"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -132,180 +160,72 @@ public boolean isEndRequired() {\n \n   @Override\n   public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n+    forceFlush();\n+    ScheduledFuture<?> nextExport = this.nextExport;\n+    if (nextExport != null) {\n+      nextExport.cancel(false);\n+    }\n+    executor.shutdown();\n+    spanExporter.shutdown();\n   }\n \n   @Override\n   public void forceFlush() {\n-    worker.forceFlush();\n+    exportBatch();\n   }\n \n-  // Worker is a thread that batches multiple spans and calls the registered SpanExporter to export\n-  // the data.\n-  //\n-  // The list of batched data is protected by an explicit monitor object which ensures full\n-  // concurrency.\n-  private static final class Worker implements Runnable {\n-\n-    static {\n-      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.trace\");\n-      LongCounter droppedSpansCounter =\n-          meter\n-              .longCounterBuilder(\"droppedSpans\")\n-              .setUnit(\"1\")\n-              .setDescription(\n-                  \"The number of spans dropped by the BatchSpanProcessor due to high throughput.\")\n-              .build();\n-      droppedSpans =\n-          droppedSpansCounter.bind(\n-              Labels.of(\"spanProcessorType\", BatchSpanProcessor.class.getSimpleName()));\n-    }\n-\n-    private static final BoundLongCounter droppedSpans;\n-\n-    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n-\n-    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n-    private final SpanExporter spanExporter;\n-    private final long scheduleDelayMillis;\n-    private final int maxQueueSize;\n-    private final int maxExportBatchSize;\n-    private final int halfMaxQueueSize;\n-    private final Object monitor = new Object();\n-    private final int exporterTimeoutMillis;\n-    private final AtomicBoolean exportAvailable = new AtomicBoolean(true);\n-\n-    @GuardedBy(\"monitor\")\n-    private final List<ReadableSpan> spansList;\n-\n-    private Worker(\n-        SpanExporter spanExporter,\n-        long scheduleDelayMillis,\n-        int maxQueueSize,\n-        int maxExportBatchSize,\n-        int exporterTimeoutMillis) {\n-      this.spanExporter = spanExporter;\n-      this.scheduleDelayMillis = scheduleDelayMillis;\n-      this.maxQueueSize = maxQueueSize;\n-      this.halfMaxQueueSize = maxQueueSize >> 1;\n-      this.maxExportBatchSize = maxExportBatchSize;\n-      this.exporterTimeoutMillis = exporterTimeoutMillis;\n-      this.spansList = new ArrayList<>(maxQueueSize);\n+  // Timeout is best effort don't need to handle the future return value.\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void exportBatch() {\n+    List<ReadableSpan> batch = new ArrayList<>(Math.min(maxExportBatchSize, queue.size()));\n+    if (queue.drainTo(batch, maxExportBatchSize) == 0) {\n+      scheduleNextExport();\n+      return;\n     }\n \n-    private void addSpan(ReadableSpan span) {\n-      synchronized (monitor) {\n-        if (spansList.size() == maxQueueSize) {\n-          droppedSpans.add(1);\n-          return;\n-        }\n-        // TODO: Record a gauge for referenced spans.\n-        spansList.add(span);\n-        // Notify the worker thread that at half of the queue is available. It will take\n-        // time anyway for the thread to wake up.\n-        if (spansList.size() >= halfMaxQueueSize) {\n-          monitor.notifyAll();\n-        }\n-      }\n+    List<SpanData> forExport = new ArrayList<>(batch.size());\n+    for (ReadableSpan span : batch) {\n+      forExport.add(span.toSpanData());\n     }\n \n-    @Override\n-    public void run() {\n-      while (!Thread.currentThread().isInterrupted()) {\n-        // Copy all the batched spans in a separate list to release the monitor lock asap to\n-        // avoid blocking the producer thread.\n-        ArrayList<ReadableSpan> spansCopy;\n-        synchronized (monitor) {\n-          // If still maxExportBatchSize elements in the queue better to execute an extra\n-          if (spansList.size() < maxExportBatchSize) {\n-            do {\n-              // In the case of a spurious wakeup we export only if we have at least one span in\n-              // the batch. It is acceptable because batching is a best effort mechanism here.\n-              try {\n-                monitor.wait(scheduleDelayMillis);\n-              } catch (InterruptedException ie) {\n-                // Preserve the interruption status as per guidance and stop doing any work.\n-                Thread.currentThread().interrupt();\n-                return;\n-              }\n-            } while (spansList.isEmpty());\n+    final CompletableResultCode result = spanExporter.export(forExport);\n+    result.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            if (!result.isSuccess()) {\n+              logger.log(Level.FINE, \"Exporter failed\");\n+            }\n+            if (queue.size() >= maxExportBatchSize) {\n+              exportBatch();\n+            } else {\n+              scheduleNextExport();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36f640a16803f2c3e8d1d8ab65ab061df58cd1a0"}, "originalPosition": 234}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyMjQ4MDQz", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#pullrequestreview-472248043", "createdAt": "2020-08-21T06:55:57Z", "commit": {"oid": "36f640a16803f2c3e8d1d8ab65ab061df58cd1a0"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwNjo1NTo1N1rOHEdyWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwNzo0OToyN1rOHEgVhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0NDM3Nw==", "bodyText": "It's in the spec too ;)\nhttps://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/sdk.md#batching-processor\nI have this issue in case you'd like to add other potential improvements to the spec!\nopen-telemetry/opentelemetry-specification#849", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r474444377", "createdAt": "2020-08-21T06:55:57Z", "author": {"login": "anuraaga"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -132,180 +160,72 @@ public boolean isEndRequired() {\n \n   @Override\n   public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n+    forceFlush();\n+    ScheduledFuture<?> nextExport = this.nextExport;\n+    if (nextExport != null) {\n+      nextExport.cancel(false);\n+    }\n+    executor.shutdown();\n+    spanExporter.shutdown();\n   }\n \n   @Override\n   public void forceFlush() {\n-    worker.forceFlush();\n+    exportBatch();\n   }\n \n-  // Worker is a thread that batches multiple spans and calls the registered SpanExporter to export\n-  // the data.\n-  //\n-  // The list of batched data is protected by an explicit monitor object which ensures full\n-  // concurrency.\n-  private static final class Worker implements Runnable {\n-\n-    static {\n-      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.trace\");\n-      LongCounter droppedSpansCounter =\n-          meter\n-              .longCounterBuilder(\"droppedSpans\")\n-              .setUnit(\"1\")\n-              .setDescription(\n-                  \"The number of spans dropped by the BatchSpanProcessor due to high throughput.\")\n-              .build();\n-      droppedSpans =\n-          droppedSpansCounter.bind(\n-              Labels.of(\"spanProcessorType\", BatchSpanProcessor.class.getSimpleName()));\n-    }\n-\n-    private static final BoundLongCounter droppedSpans;\n-\n-    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n-\n-    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n-    private final SpanExporter spanExporter;\n-    private final long scheduleDelayMillis;\n-    private final int maxQueueSize;\n-    private final int maxExportBatchSize;\n-    private final int halfMaxQueueSize;\n-    private final Object monitor = new Object();\n-    private final int exporterTimeoutMillis;\n-    private final AtomicBoolean exportAvailable = new AtomicBoolean(true);\n-\n-    @GuardedBy(\"monitor\")\n-    private final List<ReadableSpan> spansList;\n-\n-    private Worker(\n-        SpanExporter spanExporter,\n-        long scheduleDelayMillis,\n-        int maxQueueSize,\n-        int maxExportBatchSize,\n-        int exporterTimeoutMillis) {\n-      this.spanExporter = spanExporter;\n-      this.scheduleDelayMillis = scheduleDelayMillis;\n-      this.maxQueueSize = maxQueueSize;\n-      this.halfMaxQueueSize = maxQueueSize >> 1;\n-      this.maxExportBatchSize = maxExportBatchSize;\n-      this.exporterTimeoutMillis = exporterTimeoutMillis;\n-      this.spansList = new ArrayList<>(maxQueueSize);\n+  // Timeout is best effort don't need to handle the future return value.\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void exportBatch() {\n+    List<ReadableSpan> batch = new ArrayList<>(Math.min(maxExportBatchSize, queue.size()));\n+    if (queue.drainTo(batch, maxExportBatchSize) == 0) {\n+      scheduleNextExport();\n+      return;\n     }\n \n-    private void addSpan(ReadableSpan span) {\n-      synchronized (monitor) {\n-        if (spansList.size() == maxQueueSize) {\n-          droppedSpans.add(1);\n-          return;\n-        }\n-        // TODO: Record a gauge for referenced spans.\n-        spansList.add(span);\n-        // Notify the worker thread that at half of the queue is available. It will take\n-        // time anyway for the thread to wake up.\n-        if (spansList.size() >= halfMaxQueueSize) {\n-          monitor.notifyAll();\n-        }\n-      }\n+    List<SpanData> forExport = new ArrayList<>(batch.size());\n+    for (ReadableSpan span : batch) {\n+      forExport.add(span.toSpanData());\n     }\n \n-    @Override\n-    public void run() {\n-      while (!Thread.currentThread().isInterrupted()) {\n-        // Copy all the batched spans in a separate list to release the monitor lock asap to\n-        // avoid blocking the producer thread.\n-        ArrayList<ReadableSpan> spansCopy;\n-        synchronized (monitor) {\n-          // If still maxExportBatchSize elements in the queue better to execute an extra\n-          if (spansList.size() < maxExportBatchSize) {\n-            do {\n-              // In the case of a spurious wakeup we export only if we have at least one span in\n-              // the batch. It is acceptable because batching is a best effort mechanism here.\n-              try {\n-                monitor.wait(scheduleDelayMillis);\n-              } catch (InterruptedException ie) {\n-                // Preserve the interruption status as per guidance and stop doing any work.\n-                Thread.currentThread().interrupt();\n-                return;\n-              }\n-            } while (spansList.isEmpty());\n+    final CompletableResultCode result = spanExporter.export(forExport);\n+    result.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            if (!result.isSuccess()) {\n+              logger.log(Level.FINE, \"Exporter failed\");\n+            }\n+            if (queue.size() >= maxExportBatchSize) {\n+              exportBatch();\n+            } else {\n+              scheduleNextExport();\n+            }\n           }\n-          spansCopy = new ArrayList<>(spansList);\n-          spansList.clear();\n-        }\n-        // Execute the batch export outside the synchronized to not block all producers.\n-        exportBatches(spansCopy);\n-      }\n-    }\n-\n-    private void shutdown() {\n-      forceFlush();\n-      timer.cancel();\n-      spanExporter.shutdown();\n-    }\n-\n-    private void forceFlush() {\n-      ArrayList<ReadableSpan> spansCopy;\n-      synchronized (monitor) {\n-        spansCopy = new ArrayList<>(spansList);\n-        spansList.clear();\n-      }\n-      // Execute the batch export outside the synchronized to not block all producers.\n-      exportBatches(spansCopy);\n-    }\n-\n-    private void exportBatches(ArrayList<ReadableSpan> spanList) {\n-      // TODO: Record a counter for pushed spans.\n-      for (int i = 0; i < spanList.size(); ) {\n-        int lastIndexToTake = Math.min(i + maxExportBatchSize, spanList.size());\n-        onBatchExport(createSpanDataForExport(spanList, i, lastIndexToTake));\n-        i = lastIndexToTake;\n-      }\n-    }\n-\n-    private static List<SpanData> createSpanDataForExport(\n-        List<ReadableSpan> spanList, int startIndex, int endIndex) {\n-      List<SpanData> spanDataBuffer = new ArrayList<>(endIndex - startIndex);\n-      for (int i = startIndex; i < endIndex; i++) {\n-        spanDataBuffer.add(spanList.get(i).toSpanData());\n-        // Remove the reference to the ReadableSpan to allow GC to free the memory.\n-        spanList.set(i, null);\n-      }\n-      return Collections.unmodifiableList(spanDataBuffer);\n-    }\n+        });\n+\n+    // Timeout if result doesn't complete soon enough.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQzODkxOQ=="}, "originalCommit": {"oid": "36f640a16803f2c3e8d1d8ab65ab061df58cd1a0"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0NDQ2NA==", "bodyText": "Oops mixed myself up here", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r474444464", "createdAt": "2020-08-21T06:56:12Z", "author": {"login": "anuraaga"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -132,180 +160,72 @@ public boolean isEndRequired() {\n \n   @Override\n   public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n+    forceFlush();\n+    ScheduledFuture<?> nextExport = this.nextExport;\n+    if (nextExport != null) {\n+      nextExport.cancel(false);\n+    }\n+    executor.shutdown();\n+    spanExporter.shutdown();\n   }\n \n   @Override\n   public void forceFlush() {\n-    worker.forceFlush();\n+    exportBatch();\n   }\n \n-  // Worker is a thread that batches multiple spans and calls the registered SpanExporter to export\n-  // the data.\n-  //\n-  // The list of batched data is protected by an explicit monitor object which ensures full\n-  // concurrency.\n-  private static final class Worker implements Runnable {\n-\n-    static {\n-      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.trace\");\n-      LongCounter droppedSpansCounter =\n-          meter\n-              .longCounterBuilder(\"droppedSpans\")\n-              .setUnit(\"1\")\n-              .setDescription(\n-                  \"The number of spans dropped by the BatchSpanProcessor due to high throughput.\")\n-              .build();\n-      droppedSpans =\n-          droppedSpansCounter.bind(\n-              Labels.of(\"spanProcessorType\", BatchSpanProcessor.class.getSimpleName()));\n-    }\n-\n-    private static final BoundLongCounter droppedSpans;\n-\n-    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n-\n-    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n-    private final SpanExporter spanExporter;\n-    private final long scheduleDelayMillis;\n-    private final int maxQueueSize;\n-    private final int maxExportBatchSize;\n-    private final int halfMaxQueueSize;\n-    private final Object monitor = new Object();\n-    private final int exporterTimeoutMillis;\n-    private final AtomicBoolean exportAvailable = new AtomicBoolean(true);\n-\n-    @GuardedBy(\"monitor\")\n-    private final List<ReadableSpan> spansList;\n-\n-    private Worker(\n-        SpanExporter spanExporter,\n-        long scheduleDelayMillis,\n-        int maxQueueSize,\n-        int maxExportBatchSize,\n-        int exporterTimeoutMillis) {\n-      this.spanExporter = spanExporter;\n-      this.scheduleDelayMillis = scheduleDelayMillis;\n-      this.maxQueueSize = maxQueueSize;\n-      this.halfMaxQueueSize = maxQueueSize >> 1;\n-      this.maxExportBatchSize = maxExportBatchSize;\n-      this.exporterTimeoutMillis = exporterTimeoutMillis;\n-      this.spansList = new ArrayList<>(maxQueueSize);\n+  // Timeout is best effort don't need to handle the future return value.\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void exportBatch() {\n+    List<ReadableSpan> batch = new ArrayList<>(Math.min(maxExportBatchSize, queue.size()));\n+    if (queue.drainTo(batch, maxExportBatchSize) == 0) {\n+      scheduleNextExport();\n+      return;\n     }\n \n-    private void addSpan(ReadableSpan span) {\n-      synchronized (monitor) {\n-        if (spansList.size() == maxQueueSize) {\n-          droppedSpans.add(1);\n-          return;\n-        }\n-        // TODO: Record a gauge for referenced spans.\n-        spansList.add(span);\n-        // Notify the worker thread that at half of the queue is available. It will take\n-        // time anyway for the thread to wake up.\n-        if (spansList.size() >= halfMaxQueueSize) {\n-          monitor.notifyAll();\n-        }\n-      }\n+    List<SpanData> forExport = new ArrayList<>(batch.size());\n+    for (ReadableSpan span : batch) {\n+      forExport.add(span.toSpanData());\n     }\n \n-    @Override\n-    public void run() {\n-      while (!Thread.currentThread().isInterrupted()) {\n-        // Copy all the batched spans in a separate list to release the monitor lock asap to\n-        // avoid blocking the producer thread.\n-        ArrayList<ReadableSpan> spansCopy;\n-        synchronized (monitor) {\n-          // If still maxExportBatchSize elements in the queue better to execute an extra\n-          if (spansList.size() < maxExportBatchSize) {\n-            do {\n-              // In the case of a spurious wakeup we export only if we have at least one span in\n-              // the batch. It is acceptable because batching is a best effort mechanism here.\n-              try {\n-                monitor.wait(scheduleDelayMillis);\n-              } catch (InterruptedException ie) {\n-                // Preserve the interruption status as per guidance and stop doing any work.\n-                Thread.currentThread().interrupt();\n-                return;\n-              }\n-            } while (spansList.isEmpty());\n+    final CompletableResultCode result = spanExporter.export(forExport);\n+    result.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            if (!result.isSuccess()) {\n+              logger.log(Level.FINE, \"Exporter failed\");\n+            }\n+            if (queue.size() >= maxExportBatchSize) {\n+              exportBatch();\n+            } else {\n+              scheduleNextExport();\n+            }\n           }\n-          spansCopy = new ArrayList<>(spansList);\n-          spansList.clear();\n-        }\n-        // Execute the batch export outside the synchronized to not block all producers.\n-        exportBatches(spansCopy);\n-      }\n-    }\n-\n-    private void shutdown() {\n-      forceFlush();\n-      timer.cancel();\n-      spanExporter.shutdown();\n-    }\n-\n-    private void forceFlush() {\n-      ArrayList<ReadableSpan> spansCopy;\n-      synchronized (monitor) {\n-        spansCopy = new ArrayList<>(spansList);\n-        spansList.clear();\n-      }\n-      // Execute the batch export outside the synchronized to not block all producers.\n-      exportBatches(spansCopy);\n-    }\n-\n-    private void exportBatches(ArrayList<ReadableSpan> spanList) {\n-      // TODO: Record a counter for pushed spans.\n-      for (int i = 0; i < spanList.size(); ) {\n-        int lastIndexToTake = Math.min(i + maxExportBatchSize, spanList.size());\n-        onBatchExport(createSpanDataForExport(spanList, i, lastIndexToTake));\n-        i = lastIndexToTake;\n-      }\n-    }\n-\n-    private static List<SpanData> createSpanDataForExport(\n-        List<ReadableSpan> spanList, int startIndex, int endIndex) {\n-      List<SpanData> spanDataBuffer = new ArrayList<>(endIndex - startIndex);\n-      for (int i = startIndex; i < endIndex; i++) {\n-        spanDataBuffer.add(spanList.get(i).toSpanData());\n-        // Remove the reference to the ReadableSpan to allow GC to free the memory.\n-        spanList.set(i, null);\n-      }\n-      return Collections.unmodifiableList(spanDataBuffer);\n-    }\n+        });\n+\n+    // Timeout if result doesn't complete soon enough.\n+    executor.schedule(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            result.fail();\n+          }\n+        },\n+        exporterTimeoutMillis,\n+        TimeUnit.MILLISECONDS);\n+  }\n \n-    // Exports the list of SpanData to the SpanExporter.\n-    @SuppressWarnings(\"BooleanParameter\")\n-    private void onBatchExport(final List<SpanData> spans) {\n-      if (exportAvailable.compareAndSet(true, false)) {\n-        try {\n-          final CompletableResultCode result = spanExporter.export(spans);\n-          result.whenComplete(\n-              new Runnable() {\n-                @Override\n-                public void run() {\n-                  if (!result.isSuccess()) {\n-                    logger.log(Level.FINE, \"Exporter failed\");\n-                  }\n-                  exportAvailable.set(true);\n-                }\n-              });\n-          timer.schedule(\n-              new TimerTask() {\n-                @Override\n-                public void run() {\n-                  result.fail();\n-                }\n-              },\n-              exporterTimeoutMillis);\n-        } catch (Exception e) {\n-          logger.log(Level.WARNING, \"Exporter threw an Exception\", e);\n-        }\n-      } else {\n-        logger.log(Level.FINE, \"Exporter busy. Dropping spans.\");\n-      }\n-    }\n+  private ScheduledFuture<?> scheduleNextExport() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQzODA0NA=="}, "originalCommit": {"oid": "36f640a16803f2c3e8d1d8ab65ab061df58cd1a0"}, "originalPosition": 325}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ3MTU0NA==", "bodyText": "I agree with the sentiment, but I think we can be confident in our implementation of CompletableResultCode - so worst case should be the timeout below calling this callback no matter what.\nI think fixed delay tends to be safer by easily preventing concurrent exports (avoid the need to keep track of availability) and is my reading of the spec anyways. Fixed rate would still be ok I think if we didn't have the eager export when queue still has items like on line 200, which makes the time spent on exporting very unpredictable - I noticed the other implementations have this behavior too so kept it here. Also if we went with fixed rate, I don't think we'd be able to do buffer reuse optimization as in https://github.com/open-telemetry/opentelemetry-java/pull/1571/files#r474439925\nI've seen a lot of similar async + scheduled tasks in Armeria and we almost always use this delay pattern to avoid the concurrency issue, and are just confident that callbacks always get called - I'd like to keep it like this but let me know if it's a strong concern.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r474471544", "createdAt": "2020-08-21T07:31:54Z", "author": {"login": "anuraaga"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -132,180 +160,72 @@ public boolean isEndRequired() {\n \n   @Override\n   public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n+    forceFlush();\n+    ScheduledFuture<?> nextExport = this.nextExport;\n+    if (nextExport != null) {\n+      nextExport.cancel(false);\n+    }\n+    executor.shutdown();\n+    spanExporter.shutdown();\n   }\n \n   @Override\n   public void forceFlush() {\n-    worker.forceFlush();\n+    exportBatch();\n   }\n \n-  // Worker is a thread that batches multiple spans and calls the registered SpanExporter to export\n-  // the data.\n-  //\n-  // The list of batched data is protected by an explicit monitor object which ensures full\n-  // concurrency.\n-  private static final class Worker implements Runnable {\n-\n-    static {\n-      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.trace\");\n-      LongCounter droppedSpansCounter =\n-          meter\n-              .longCounterBuilder(\"droppedSpans\")\n-              .setUnit(\"1\")\n-              .setDescription(\n-                  \"The number of spans dropped by the BatchSpanProcessor due to high throughput.\")\n-              .build();\n-      droppedSpans =\n-          droppedSpansCounter.bind(\n-              Labels.of(\"spanProcessorType\", BatchSpanProcessor.class.getSimpleName()));\n-    }\n-\n-    private static final BoundLongCounter droppedSpans;\n-\n-    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n-\n-    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n-    private final SpanExporter spanExporter;\n-    private final long scheduleDelayMillis;\n-    private final int maxQueueSize;\n-    private final int maxExportBatchSize;\n-    private final int halfMaxQueueSize;\n-    private final Object monitor = new Object();\n-    private final int exporterTimeoutMillis;\n-    private final AtomicBoolean exportAvailable = new AtomicBoolean(true);\n-\n-    @GuardedBy(\"monitor\")\n-    private final List<ReadableSpan> spansList;\n-\n-    private Worker(\n-        SpanExporter spanExporter,\n-        long scheduleDelayMillis,\n-        int maxQueueSize,\n-        int maxExportBatchSize,\n-        int exporterTimeoutMillis) {\n-      this.spanExporter = spanExporter;\n-      this.scheduleDelayMillis = scheduleDelayMillis;\n-      this.maxQueueSize = maxQueueSize;\n-      this.halfMaxQueueSize = maxQueueSize >> 1;\n-      this.maxExportBatchSize = maxExportBatchSize;\n-      this.exporterTimeoutMillis = exporterTimeoutMillis;\n-      this.spansList = new ArrayList<>(maxQueueSize);\n+  // Timeout is best effort don't need to handle the future return value.\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void exportBatch() {\n+    List<ReadableSpan> batch = new ArrayList<>(Math.min(maxExportBatchSize, queue.size()));\n+    if (queue.drainTo(batch, maxExportBatchSize) == 0) {\n+      scheduleNextExport();\n+      return;\n     }\n \n-    private void addSpan(ReadableSpan span) {\n-      synchronized (monitor) {\n-        if (spansList.size() == maxQueueSize) {\n-          droppedSpans.add(1);\n-          return;\n-        }\n-        // TODO: Record a gauge for referenced spans.\n-        spansList.add(span);\n-        // Notify the worker thread that at half of the queue is available. It will take\n-        // time anyway for the thread to wake up.\n-        if (spansList.size() >= halfMaxQueueSize) {\n-          monitor.notifyAll();\n-        }\n-      }\n+    List<SpanData> forExport = new ArrayList<>(batch.size());\n+    for (ReadableSpan span : batch) {\n+      forExport.add(span.toSpanData());\n     }\n \n-    @Override\n-    public void run() {\n-      while (!Thread.currentThread().isInterrupted()) {\n-        // Copy all the batched spans in a separate list to release the monitor lock asap to\n-        // avoid blocking the producer thread.\n-        ArrayList<ReadableSpan> spansCopy;\n-        synchronized (monitor) {\n-          // If still maxExportBatchSize elements in the queue better to execute an extra\n-          if (spansList.size() < maxExportBatchSize) {\n-            do {\n-              // In the case of a spurious wakeup we export only if we have at least one span in\n-              // the batch. It is acceptable because batching is a best effort mechanism here.\n-              try {\n-                monitor.wait(scheduleDelayMillis);\n-              } catch (InterruptedException ie) {\n-                // Preserve the interruption status as per guidance and stop doing any work.\n-                Thread.currentThread().interrupt();\n-                return;\n-              }\n-            } while (spansList.isEmpty());\n+    final CompletableResultCode result = spanExporter.export(forExport);\n+    result.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            if (!result.isSuccess()) {\n+              logger.log(Level.FINE, \"Exporter failed\");\n+            }\n+            if (queue.size() >= maxExportBatchSize) {\n+              exportBatch();\n+            } else {\n+              scheduleNextExport();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0MjI2Mw=="}, "originalCommit": {"oid": "36f640a16803f2c3e8d1d8ab65ab061df58cd1a0"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ3Mjg0Mw==", "bodyText": "I think poll has to get a lock in the queue at every call while drain only does it once for the entire batch, can only say for sure with a benchmark indeed but pending the benchmark, I lean towards sticking to drainTo.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r474472843", "createdAt": "2020-08-21T07:33:30Z", "author": {"login": "anuraaga"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -132,180 +160,72 @@ public boolean isEndRequired() {\n \n   @Override\n   public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n+    forceFlush();\n+    ScheduledFuture<?> nextExport = this.nextExport;\n+    if (nextExport != null) {\n+      nextExport.cancel(false);\n+    }\n+    executor.shutdown();\n+    spanExporter.shutdown();\n   }\n \n   @Override\n   public void forceFlush() {\n-    worker.forceFlush();\n+    exportBatch();\n   }\n \n-  // Worker is a thread that batches multiple spans and calls the registered SpanExporter to export\n-  // the data.\n-  //\n-  // The list of batched data is protected by an explicit monitor object which ensures full\n-  // concurrency.\n-  private static final class Worker implements Runnable {\n-\n-    static {\n-      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.trace\");\n-      LongCounter droppedSpansCounter =\n-          meter\n-              .longCounterBuilder(\"droppedSpans\")\n-              .setUnit(\"1\")\n-              .setDescription(\n-                  \"The number of spans dropped by the BatchSpanProcessor due to high throughput.\")\n-              .build();\n-      droppedSpans =\n-          droppedSpansCounter.bind(\n-              Labels.of(\"spanProcessorType\", BatchSpanProcessor.class.getSimpleName()));\n-    }\n-\n-    private static final BoundLongCounter droppedSpans;\n-\n-    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n-\n-    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n-    private final SpanExporter spanExporter;\n-    private final long scheduleDelayMillis;\n-    private final int maxQueueSize;\n-    private final int maxExportBatchSize;\n-    private final int halfMaxQueueSize;\n-    private final Object monitor = new Object();\n-    private final int exporterTimeoutMillis;\n-    private final AtomicBoolean exportAvailable = new AtomicBoolean(true);\n-\n-    @GuardedBy(\"monitor\")\n-    private final List<ReadableSpan> spansList;\n-\n-    private Worker(\n-        SpanExporter spanExporter,\n-        long scheduleDelayMillis,\n-        int maxQueueSize,\n-        int maxExportBatchSize,\n-        int exporterTimeoutMillis) {\n-      this.spanExporter = spanExporter;\n-      this.scheduleDelayMillis = scheduleDelayMillis;\n-      this.maxQueueSize = maxQueueSize;\n-      this.halfMaxQueueSize = maxQueueSize >> 1;\n-      this.maxExportBatchSize = maxExportBatchSize;\n-      this.exporterTimeoutMillis = exporterTimeoutMillis;\n-      this.spansList = new ArrayList<>(maxQueueSize);\n+  // Timeout is best effort don't need to handle the future return value.\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void exportBatch() {\n+    List<ReadableSpan> batch = new ArrayList<>(Math.min(maxExportBatchSize, queue.size()));\n+    if (queue.drainTo(batch, maxExportBatchSize) == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQzOTY5NA=="}, "originalCommit": {"oid": "36f640a16803f2c3e8d1d8ab65ab061df58cd1a0"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ4NjE0OA==", "bodyText": "This one we pass to the exporter so we can't reuse, I added a reused ReadableSpan buffer though.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r474486148", "createdAt": "2020-08-21T07:49:27Z", "author": {"login": "anuraaga"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -132,180 +160,72 @@ public boolean isEndRequired() {\n \n   @Override\n   public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n+    forceFlush();\n+    ScheduledFuture<?> nextExport = this.nextExport;\n+    if (nextExport != null) {\n+      nextExport.cancel(false);\n+    }\n+    executor.shutdown();\n+    spanExporter.shutdown();\n   }\n \n   @Override\n   public void forceFlush() {\n-    worker.forceFlush();\n+    exportBatch();\n   }\n \n-  // Worker is a thread that batches multiple spans and calls the registered SpanExporter to export\n-  // the data.\n-  //\n-  // The list of batched data is protected by an explicit monitor object which ensures full\n-  // concurrency.\n-  private static final class Worker implements Runnable {\n-\n-    static {\n-      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.trace\");\n-      LongCounter droppedSpansCounter =\n-          meter\n-              .longCounterBuilder(\"droppedSpans\")\n-              .setUnit(\"1\")\n-              .setDescription(\n-                  \"The number of spans dropped by the BatchSpanProcessor due to high throughput.\")\n-              .build();\n-      droppedSpans =\n-          droppedSpansCounter.bind(\n-              Labels.of(\"spanProcessorType\", BatchSpanProcessor.class.getSimpleName()));\n-    }\n-\n-    private static final BoundLongCounter droppedSpans;\n-\n-    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n-\n-    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n-    private final SpanExporter spanExporter;\n-    private final long scheduleDelayMillis;\n-    private final int maxQueueSize;\n-    private final int maxExportBatchSize;\n-    private final int halfMaxQueueSize;\n-    private final Object monitor = new Object();\n-    private final int exporterTimeoutMillis;\n-    private final AtomicBoolean exportAvailable = new AtomicBoolean(true);\n-\n-    @GuardedBy(\"monitor\")\n-    private final List<ReadableSpan> spansList;\n-\n-    private Worker(\n-        SpanExporter spanExporter,\n-        long scheduleDelayMillis,\n-        int maxQueueSize,\n-        int maxExportBatchSize,\n-        int exporterTimeoutMillis) {\n-      this.spanExporter = spanExporter;\n-      this.scheduleDelayMillis = scheduleDelayMillis;\n-      this.maxQueueSize = maxQueueSize;\n-      this.halfMaxQueueSize = maxQueueSize >> 1;\n-      this.maxExportBatchSize = maxExportBatchSize;\n-      this.exporterTimeoutMillis = exporterTimeoutMillis;\n-      this.spansList = new ArrayList<>(maxQueueSize);\n+  // Timeout is best effort don't need to handle the future return value.\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void exportBatch() {\n+    List<ReadableSpan> batch = new ArrayList<>(Math.min(maxExportBatchSize, queue.size()));\n+    if (queue.drainTo(batch, maxExportBatchSize) == 0) {\n+      scheduleNextExport();\n+      return;\n     }\n \n-    private void addSpan(ReadableSpan span) {\n-      synchronized (monitor) {\n-        if (spansList.size() == maxQueueSize) {\n-          droppedSpans.add(1);\n-          return;\n-        }\n-        // TODO: Record a gauge for referenced spans.\n-        spansList.add(span);\n-        // Notify the worker thread that at half of the queue is available. It will take\n-        // time anyway for the thread to wake up.\n-        if (spansList.size() >= halfMaxQueueSize) {\n-          monitor.notifyAll();\n-        }\n-      }\n+    List<SpanData> forExport = new ArrayList<>(batch.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQzOTkyNQ=="}, "originalCommit": {"oid": "36f640a16803f2c3e8d1d8ab65ab061df58cd1a0"}, "originalPosition": 198}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ee18066310a33638e201c3de4852b689efa5ffd6", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/ee18066310a33638e201c3de4852b689efa5ffd6", "committedDate": "2020-08-21T08:17:39Z", "message": "forceFlush"}, "afterCommit": {"oid": "e1640750a6e321f743a3c598d3fba2d2aa10c5ba", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/e1640750a6e321f743a3c598d3fba2d2aa10c5ba", "committedDate": "2020-08-21T08:39:55Z", "message": "forceFlush"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyNDc5NTQz", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#pullrequestreview-472479543", "createdAt": "2020-08-21T13:18:24Z", "commit": {"oid": "e1640750a6e321f743a3c598d3fba2d2aa10c5ba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxMzoxODoyNFrOHEszbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxMzoxODoyNFrOHEszbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY5MDQxMg==", "bodyText": "Empty if?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r474690412", "createdAt": "2020-08-21T13:18:24Z", "author": {"login": "iNikem"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -132,180 +166,102 @@ public boolean isEndRequired() {\n \n   @Override\n   public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n+    forceFlush();\n+    executor.shutdown();\n+    spanExporter.shutdown();\n   }\n \n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n   @Override\n   public void forceFlush() {\n-    worker.forceFlush();\n-  }\n-\n-  // Worker is a thread that batches multiple spans and calls the registered SpanExporter to export\n-  // the data.\n-  //\n-  // The list of batched data is protected by an explicit monitor object which ensures full\n-  // concurrency.\n-  private static final class Worker implements Runnable {\n-\n-    static {\n-      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.trace\");\n-      LongCounter droppedSpansCounter =\n-          meter\n-              .longCounterBuilder(\"droppedSpans\")\n-              .setUnit(\"1\")\n-              .setDescription(\n-                  \"The number of spans dropped by the BatchSpanProcessor due to high throughput.\")\n-              .build();\n-      droppedSpans =\n-          droppedSpansCounter.bind(\n-              Labels.of(\"spanProcessorType\", BatchSpanProcessor.class.getSimpleName()));\n-    }\n-\n-    private static final BoundLongCounter droppedSpans;\n-\n-    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n-\n-    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n-    private final SpanExporter spanExporter;\n-    private final long scheduleDelayMillis;\n-    private final int maxQueueSize;\n-    private final int maxExportBatchSize;\n-    private final int halfMaxQueueSize;\n-    private final Object monitor = new Object();\n-    private final int exporterTimeoutMillis;\n-    private final AtomicBoolean exportAvailable = new AtomicBoolean(true);\n-\n-    @GuardedBy(\"monitor\")\n-    private final List<ReadableSpan> spansList;\n-\n-    private Worker(\n-        SpanExporter spanExporter,\n-        long scheduleDelayMillis,\n-        int maxQueueSize,\n-        int maxExportBatchSize,\n-        int exporterTimeoutMillis) {\n-      this.spanExporter = spanExporter;\n-      this.scheduleDelayMillis = scheduleDelayMillis;\n-      this.maxQueueSize = maxQueueSize;\n-      this.halfMaxQueueSize = maxQueueSize >> 1;\n-      this.maxExportBatchSize = maxExportBatchSize;\n-      this.exporterTimeoutMillis = exporterTimeoutMillis;\n-      this.spansList = new ArrayList<>(maxQueueSize);\n+    forceFlush = true;\n+    // Cancel only returns true once.\n+    if (!nextExport.cancel(false)) {\n+      // Already exporting.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1640750a6e321f743a3c598d3fba2d2aa10c5ba"}, "originalPosition": 180}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyNDg5NTY2", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#pullrequestreview-472489566", "createdAt": "2020-08-21T13:30:33Z", "commit": {"oid": "e1640750a6e321f743a3c598d3fba2d2aa10c5ba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxMzozMDozM1rOHEtRCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxMzozMDozM1rOHEtRCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY5Nzk5Mw==", "bodyText": "With these recent changes it became much more complicated :(", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r474697993", "createdAt": "2020-08-21T13:30:33Z", "author": {"login": "iNikem"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -132,180 +166,102 @@ public boolean isEndRequired() {\n \n   @Override\n   public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n+    forceFlush();\n+    executor.shutdown();\n+    spanExporter.shutdown();\n   }\n \n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n   @Override\n   public void forceFlush() {\n-    worker.forceFlush();\n-  }\n-\n-  // Worker is a thread that batches multiple spans and calls the registered SpanExporter to export\n-  // the data.\n-  //\n-  // The list of batched data is protected by an explicit monitor object which ensures full\n-  // concurrency.\n-  private static final class Worker implements Runnable {\n-\n-    static {\n-      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.trace\");\n-      LongCounter droppedSpansCounter =\n-          meter\n-              .longCounterBuilder(\"droppedSpans\")\n-              .setUnit(\"1\")\n-              .setDescription(\n-                  \"The number of spans dropped by the BatchSpanProcessor due to high throughput.\")\n-              .build();\n-      droppedSpans =\n-          droppedSpansCounter.bind(\n-              Labels.of(\"spanProcessorType\", BatchSpanProcessor.class.getSimpleName()));\n-    }\n-\n-    private static final BoundLongCounter droppedSpans;\n-\n-    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n-\n-    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n-    private final SpanExporter spanExporter;\n-    private final long scheduleDelayMillis;\n-    private final int maxQueueSize;\n-    private final int maxExportBatchSize;\n-    private final int halfMaxQueueSize;\n-    private final Object monitor = new Object();\n-    private final int exporterTimeoutMillis;\n-    private final AtomicBoolean exportAvailable = new AtomicBoolean(true);\n-\n-    @GuardedBy(\"monitor\")\n-    private final List<ReadableSpan> spansList;\n-\n-    private Worker(\n-        SpanExporter spanExporter,\n-        long scheduleDelayMillis,\n-        int maxQueueSize,\n-        int maxExportBatchSize,\n-        int exporterTimeoutMillis) {\n-      this.spanExporter = spanExporter;\n-      this.scheduleDelayMillis = scheduleDelayMillis;\n-      this.maxQueueSize = maxQueueSize;\n-      this.halfMaxQueueSize = maxQueueSize >> 1;\n-      this.maxExportBatchSize = maxExportBatchSize;\n-      this.exporterTimeoutMillis = exporterTimeoutMillis;\n-      this.spansList = new ArrayList<>(maxQueueSize);\n+    forceFlush = true;\n+    // Cancel only returns true once.\n+    if (!nextExport.cancel(false)) {\n+      // Already exporting.\n     }\n-\n-    private void addSpan(ReadableSpan span) {\n-      synchronized (monitor) {\n-        if (spansList.size() == maxQueueSize) {\n-          droppedSpans.add(1);\n-          return;\n-        }\n-        // TODO: Record a gauge for referenced spans.\n-        spansList.add(span);\n-        // Notify the worker thread that at half of the queue is available. It will take\n-        // time anyway for the thread to wake up.\n-        if (spansList.size() >= halfMaxQueueSize) {\n-          monitor.notifyAll();\n-        }\n-      }\n-    }\n-\n-    @Override\n-    public void run() {\n-      while (!Thread.currentThread().isInterrupted()) {\n-        // Copy all the batched spans in a separate list to release the monitor lock asap to\n-        // avoid blocking the producer thread.\n-        ArrayList<ReadableSpan> spansCopy;\n-        synchronized (monitor) {\n-          // If still maxExportBatchSize elements in the queue better to execute an extra\n-          if (spansList.size() < maxExportBatchSize) {\n-            do {\n-              // In the case of a spurious wakeup we export only if we have at least one span in\n-              // the batch. It is acceptable because batching is a best effort mechanism here.\n-              try {\n-                monitor.wait(scheduleDelayMillis);\n-              } catch (InterruptedException ie) {\n-                // Preserve the interruption status as per guidance and stop doing any work.\n-                Thread.currentThread().interrupt();\n-                return;\n-              }\n-            } while (spansList.isEmpty());\n+    final CompletableResultCode result = new CompletableResultCode();\n+    executor.submit(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            exportBatch(result);\n           }\n-          spansCopy = new ArrayList<>(spansList);\n-          spansList.clear();\n-        }\n-        // Execute the batch export outside the synchronized to not block all producers.\n-        exportBatches(spansCopy);\n-      }\n-    }\n-\n-    private void shutdown() {\n-      forceFlush();\n-      timer.cancel();\n-      spanExporter.shutdown();\n+        });\n+    final CountDownLatch latch = new CountDownLatch(1);\n+    result.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            latch.countDown();\n+          }\n+        });\n+    try {\n+      latch.await(exporterTimeoutMillis, TimeUnit.MILLISECONDS);\n+    } catch (InterruptedException e) {\n+      logger.log(Level.WARNING, \"Interrupted while forcing span flush.\");\n+      Thread.currentThread().interrupt();\n     }\n+  }\n \n-    private void forceFlush() {\n-      ArrayList<ReadableSpan> spansCopy;\n-      synchronized (monitor) {\n-        spansCopy = new ArrayList<>(spansList);\n-        spansList.clear();\n-      }\n-      // Execute the batch export outside the synchronized to not block all producers.\n-      exportBatches(spansCopy);\n+  // Timeout is best effort don't need to handle the future return value.\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void exportBatch(final CompletableResultCode result) {\n+    spanBuffer.clear();\n+    if (queue.drainTo(spanBuffer, maxExportBatchSize) == 0) {\n+      result.succeed();\n+      scheduleNextExport();\n+      return;\n     }\n \n-    private void exportBatches(ArrayList<ReadableSpan> spanList) {\n-      // TODO: Record a counter for pushed spans.\n-      for (int i = 0; i < spanList.size(); ) {\n-        int lastIndexToTake = Math.min(i + maxExportBatchSize, spanList.size());\n-        onBatchExport(createSpanDataForExport(spanList, i, lastIndexToTake));\n-        i = lastIndexToTake;\n-      }\n+    List<SpanData> forExport = new ArrayList<>(spanBuffer.size());\n+    for (ReadableSpan span : spanBuffer) {\n+      forExport.add(span.toSpanData());\n     }\n \n-    private static List<SpanData> createSpanDataForExport(\n-        List<ReadableSpan> spanList, int startIndex, int endIndex) {\n-      List<SpanData> spanDataBuffer = new ArrayList<>(endIndex - startIndex);\n-      for (int i = startIndex; i < endIndex; i++) {\n-        spanDataBuffer.add(spanList.get(i).toSpanData());\n-        // Remove the reference to the ReadableSpan to allow GC to free the memory.\n-        spanList.set(i, null);\n-      }\n-      return Collections.unmodifiableList(spanDataBuffer);\n-    }\n+    final CompletableResultCode exportResult = spanExporter.export(forExport);\n+    exportResult.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            if (!exportResult.isSuccess()) {\n+              logger.log(Level.FINE, \"Exporter failed\");\n+            }\n+            if (queue.size() >= maxExportBatchSize) {\n+              exportBatch(result);\n+            } else if (forceFlush) {\n+              // When we're forcing a flush we want to export even when we don't have a full batch.\n+              forceFlush = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1640750a6e321f743a3c598d3fba2d2aa10c5ba"}, "originalPosition": 307}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyNjk4ODI1", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#pullrequestreview-472698825", "createdAt": "2020-08-21T18:23:22Z", "commit": {"oid": "38f76bb5e2284ca293e64a55b0e441f200c8f009"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxODoyMzoyMlrOHE2-ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxODoyMzoyMlrOHE2-ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg1NzA5OA==", "bodyText": "It sure would be nice if we had CompletableFuture here, so we could just have exportBatch return one and we could wait for it to a complete with a timeout. :(", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r474857098", "createdAt": "2020-08-21T18:23:22Z", "author": {"login": "jkwatson"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -132,180 +166,103 @@ public boolean isEndRequired() {\n \n   @Override\n   public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n+    forceFlush();\n+    executor.shutdown();\n+    spanExporter.shutdown();\n   }\n \n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n   @Override\n   public void forceFlush() {\n-    worker.forceFlush();\n-  }\n-\n-  // Worker is a thread that batches multiple spans and calls the registered SpanExporter to export\n-  // the data.\n-  //\n-  // The list of batched data is protected by an explicit monitor object which ensures full\n-  // concurrency.\n-  private static final class Worker implements Runnable {\n-\n-    static {\n-      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.trace\");\n-      LongCounter droppedSpansCounter =\n-          meter\n-              .longCounterBuilder(\"droppedSpans\")\n-              .setUnit(\"1\")\n-              .setDescription(\n-                  \"The number of spans dropped by the BatchSpanProcessor due to high throughput.\")\n-              .build();\n-      droppedSpans =\n-          droppedSpansCounter.bind(\n-              Labels.of(\"spanProcessorType\", BatchSpanProcessor.class.getSimpleName()));\n-    }\n-\n-    private static final BoundLongCounter droppedSpans;\n-\n-    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n-\n-    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n-    private final SpanExporter spanExporter;\n-    private final long scheduleDelayMillis;\n-    private final int maxQueueSize;\n-    private final int maxExportBatchSize;\n-    private final int halfMaxQueueSize;\n-    private final Object monitor = new Object();\n-    private final int exporterTimeoutMillis;\n-    private final AtomicBoolean exportAvailable = new AtomicBoolean(true);\n-\n-    @GuardedBy(\"monitor\")\n-    private final List<ReadableSpan> spansList;\n-\n-    private Worker(\n-        SpanExporter spanExporter,\n-        long scheduleDelayMillis,\n-        int maxQueueSize,\n-        int maxExportBatchSize,\n-        int exporterTimeoutMillis) {\n-      this.spanExporter = spanExporter;\n-      this.scheduleDelayMillis = scheduleDelayMillis;\n-      this.maxQueueSize = maxQueueSize;\n-      this.halfMaxQueueSize = maxQueueSize >> 1;\n-      this.maxExportBatchSize = maxExportBatchSize;\n-      this.exporterTimeoutMillis = exporterTimeoutMillis;\n-      this.spansList = new ArrayList<>(maxQueueSize);\n-    }\n-\n-    private void addSpan(ReadableSpan span) {\n-      synchronized (monitor) {\n-        if (spansList.size() == maxQueueSize) {\n-          droppedSpans.add(1);\n-          return;\n-        }\n-        // TODO: Record a gauge for referenced spans.\n-        spansList.add(span);\n-        // Notify the worker thread that at half of the queue is available. It will take\n-        // time anyway for the thread to wake up.\n-        if (spansList.size() >= halfMaxQueueSize) {\n-          monitor.notifyAll();\n-        }\n-      }\n+    forceFlush = true;\n+    // Cancel only returns true once.\n+    if (!nextExport.cancel(false)) {\n+      // Already exporting.\n+      return;\n     }\n-\n-    @Override\n-    public void run() {\n-      while (!Thread.currentThread().isInterrupted()) {\n-        // Copy all the batched spans in a separate list to release the monitor lock asap to\n-        // avoid blocking the producer thread.\n-        ArrayList<ReadableSpan> spansCopy;\n-        synchronized (monitor) {\n-          // If still maxExportBatchSize elements in the queue better to execute an extra\n-          if (spansList.size() < maxExportBatchSize) {\n-            do {\n-              // In the case of a spurious wakeup we export only if we have at least one span in\n-              // the batch. It is acceptable because batching is a best effort mechanism here.\n-              try {\n-                monitor.wait(scheduleDelayMillis);\n-              } catch (InterruptedException ie) {\n-                // Preserve the interruption status as per guidance and stop doing any work.\n-                Thread.currentThread().interrupt();\n-                return;\n-              }\n-            } while (spansList.isEmpty());\n+    final CompletableResultCode result = new CompletableResultCode();\n+    executor.submit(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            exportBatch(result);\n           }\n-          spansCopy = new ArrayList<>(spansList);\n-          spansList.clear();\n-        }\n-        // Execute the batch export outside the synchronized to not block all producers.\n-        exportBatches(spansCopy);\n-      }\n-    }\n-\n-    private void shutdown() {\n-      forceFlush();\n-      timer.cancel();\n-      spanExporter.shutdown();\n+        });\n+    final CountDownLatch latch = new CountDownLatch(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f76bb5e2284ca293e64a55b0e441f200c8f009"}, "originalPosition": 240}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyNzA1MDY0", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#pullrequestreview-472705064", "createdAt": "2020-08-21T18:34:03Z", "commit": {"oid": "38f76bb5e2284ca293e64a55b0e441f200c8f009"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxODozNDowM1rOHE3QxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxODozNDowM1rOHE3QxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg2MTc2NQ==", "bodyText": "Won't this cause an eventual stack overflow in the situation where the exporter can't keep up with the volume?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r474861765", "createdAt": "2020-08-21T18:34:03Z", "author": {"login": "jkwatson"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -132,180 +166,103 @@ public boolean isEndRequired() {\n \n   @Override\n   public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n+    forceFlush();\n+    executor.shutdown();\n+    spanExporter.shutdown();\n   }\n \n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n   @Override\n   public void forceFlush() {\n-    worker.forceFlush();\n-  }\n-\n-  // Worker is a thread that batches multiple spans and calls the registered SpanExporter to export\n-  // the data.\n-  //\n-  // The list of batched data is protected by an explicit monitor object which ensures full\n-  // concurrency.\n-  private static final class Worker implements Runnable {\n-\n-    static {\n-      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.trace\");\n-      LongCounter droppedSpansCounter =\n-          meter\n-              .longCounterBuilder(\"droppedSpans\")\n-              .setUnit(\"1\")\n-              .setDescription(\n-                  \"The number of spans dropped by the BatchSpanProcessor due to high throughput.\")\n-              .build();\n-      droppedSpans =\n-          droppedSpansCounter.bind(\n-              Labels.of(\"spanProcessorType\", BatchSpanProcessor.class.getSimpleName()));\n-    }\n-\n-    private static final BoundLongCounter droppedSpans;\n-\n-    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n-\n-    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n-    private final SpanExporter spanExporter;\n-    private final long scheduleDelayMillis;\n-    private final int maxQueueSize;\n-    private final int maxExportBatchSize;\n-    private final int halfMaxQueueSize;\n-    private final Object monitor = new Object();\n-    private final int exporterTimeoutMillis;\n-    private final AtomicBoolean exportAvailable = new AtomicBoolean(true);\n-\n-    @GuardedBy(\"monitor\")\n-    private final List<ReadableSpan> spansList;\n-\n-    private Worker(\n-        SpanExporter spanExporter,\n-        long scheduleDelayMillis,\n-        int maxQueueSize,\n-        int maxExportBatchSize,\n-        int exporterTimeoutMillis) {\n-      this.spanExporter = spanExporter;\n-      this.scheduleDelayMillis = scheduleDelayMillis;\n-      this.maxQueueSize = maxQueueSize;\n-      this.halfMaxQueueSize = maxQueueSize >> 1;\n-      this.maxExportBatchSize = maxExportBatchSize;\n-      this.exporterTimeoutMillis = exporterTimeoutMillis;\n-      this.spansList = new ArrayList<>(maxQueueSize);\n-    }\n-\n-    private void addSpan(ReadableSpan span) {\n-      synchronized (monitor) {\n-        if (spansList.size() == maxQueueSize) {\n-          droppedSpans.add(1);\n-          return;\n-        }\n-        // TODO: Record a gauge for referenced spans.\n-        spansList.add(span);\n-        // Notify the worker thread that at half of the queue is available. It will take\n-        // time anyway for the thread to wake up.\n-        if (spansList.size() >= halfMaxQueueSize) {\n-          monitor.notifyAll();\n-        }\n-      }\n+    forceFlush = true;\n+    // Cancel only returns true once.\n+    if (!nextExport.cancel(false)) {\n+      // Already exporting.\n+      return;\n     }\n-\n-    @Override\n-    public void run() {\n-      while (!Thread.currentThread().isInterrupted()) {\n-        // Copy all the batched spans in a separate list to release the monitor lock asap to\n-        // avoid blocking the producer thread.\n-        ArrayList<ReadableSpan> spansCopy;\n-        synchronized (monitor) {\n-          // If still maxExportBatchSize elements in the queue better to execute an extra\n-          if (spansList.size() < maxExportBatchSize) {\n-            do {\n-              // In the case of a spurious wakeup we export only if we have at least one span in\n-              // the batch. It is acceptable because batching is a best effort mechanism here.\n-              try {\n-                monitor.wait(scheduleDelayMillis);\n-              } catch (InterruptedException ie) {\n-                // Preserve the interruption status as per guidance and stop doing any work.\n-                Thread.currentThread().interrupt();\n-                return;\n-              }\n-            } while (spansList.isEmpty());\n+    final CompletableResultCode result = new CompletableResultCode();\n+    executor.submit(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            exportBatch(result);\n           }\n-          spansCopy = new ArrayList<>(spansList);\n-          spansList.clear();\n-        }\n-        // Execute the batch export outside the synchronized to not block all producers.\n-        exportBatches(spansCopy);\n-      }\n-    }\n-\n-    private void shutdown() {\n-      forceFlush();\n-      timer.cancel();\n-      spanExporter.shutdown();\n+        });\n+    final CountDownLatch latch = new CountDownLatch(1);\n+    result.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            latch.countDown();\n+          }\n+        });\n+    try {\n+      latch.await(exporterTimeoutMillis, TimeUnit.MILLISECONDS);\n+    } catch (InterruptedException e) {\n+      logger.log(Level.WARNING, \"Interrupted while forcing span flush.\");\n+      Thread.currentThread().interrupt();\n     }\n+  }\n \n-    private void forceFlush() {\n-      ArrayList<ReadableSpan> spansCopy;\n-      synchronized (monitor) {\n-        spansCopy = new ArrayList<>(spansList);\n-        spansList.clear();\n-      }\n-      // Execute the batch export outside the synchronized to not block all producers.\n-      exportBatches(spansCopy);\n+  // Timeout is best effort don't need to handle the future return value.\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void exportBatch(final CompletableResultCode result) {\n+    spanBuffer.clear();\n+    if (queue.drainTo(spanBuffer, maxExportBatchSize) == 0) {\n+      result.succeed();\n+      scheduleNextExport();\n+      return;\n     }\n \n-    private void exportBatches(ArrayList<ReadableSpan> spanList) {\n-      // TODO: Record a counter for pushed spans.\n-      for (int i = 0; i < spanList.size(); ) {\n-        int lastIndexToTake = Math.min(i + maxExportBatchSize, spanList.size());\n-        onBatchExport(createSpanDataForExport(spanList, i, lastIndexToTake));\n-        i = lastIndexToTake;\n-      }\n+    List<SpanData> forExport = new ArrayList<>(spanBuffer.size());\n+    for (ReadableSpan span : spanBuffer) {\n+      forExport.add(span.toSpanData());\n     }\n \n-    private static List<SpanData> createSpanDataForExport(\n-        List<ReadableSpan> spanList, int startIndex, int endIndex) {\n-      List<SpanData> spanDataBuffer = new ArrayList<>(endIndex - startIndex);\n-      for (int i = startIndex; i < endIndex; i++) {\n-        spanDataBuffer.add(spanList.get(i).toSpanData());\n-        // Remove the reference to the ReadableSpan to allow GC to free the memory.\n-        spanList.set(i, null);\n-      }\n-      return Collections.unmodifiableList(spanDataBuffer);\n-    }\n+    final CompletableResultCode exportResult = spanExporter.export(forExport);\n+    exportResult.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            if (!exportResult.isSuccess()) {\n+              logger.log(Level.FINE, \"Exporter failed\");\n+            }\n+            if (queue.size() >= maxExportBatchSize) {\n+              exportBatch(result);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f76bb5e2284ca293e64a55b0e441f200c8f009"}, "originalPosition": 305}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyNzA3NzQw", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#pullrequestreview-472707740", "createdAt": "2020-08-21T18:38:46Z", "commit": {"oid": "38f76bb5e2284ca293e64a55b0e441f200c8f009"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxODozODo0NlrOHE3YsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxODozODo0NlrOHE3YsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg2Mzc5Mg==", "bodyText": "it hurts me that we have to do this to implement the timeout. Especially since it won't actually stop the export from running!", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r474863792", "createdAt": "2020-08-21T18:38:46Z", "author": {"login": "jkwatson"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -132,180 +166,103 @@ public boolean isEndRequired() {\n \n   @Override\n   public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n+    forceFlush();\n+    executor.shutdown();\n+    spanExporter.shutdown();\n   }\n \n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n   @Override\n   public void forceFlush() {\n-    worker.forceFlush();\n-  }\n-\n-  // Worker is a thread that batches multiple spans and calls the registered SpanExporter to export\n-  // the data.\n-  //\n-  // The list of batched data is protected by an explicit monitor object which ensures full\n-  // concurrency.\n-  private static final class Worker implements Runnable {\n-\n-    static {\n-      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.trace\");\n-      LongCounter droppedSpansCounter =\n-          meter\n-              .longCounterBuilder(\"droppedSpans\")\n-              .setUnit(\"1\")\n-              .setDescription(\n-                  \"The number of spans dropped by the BatchSpanProcessor due to high throughput.\")\n-              .build();\n-      droppedSpans =\n-          droppedSpansCounter.bind(\n-              Labels.of(\"spanProcessorType\", BatchSpanProcessor.class.getSimpleName()));\n-    }\n-\n-    private static final BoundLongCounter droppedSpans;\n-\n-    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n-\n-    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n-    private final SpanExporter spanExporter;\n-    private final long scheduleDelayMillis;\n-    private final int maxQueueSize;\n-    private final int maxExportBatchSize;\n-    private final int halfMaxQueueSize;\n-    private final Object monitor = new Object();\n-    private final int exporterTimeoutMillis;\n-    private final AtomicBoolean exportAvailable = new AtomicBoolean(true);\n-\n-    @GuardedBy(\"monitor\")\n-    private final List<ReadableSpan> spansList;\n-\n-    private Worker(\n-        SpanExporter spanExporter,\n-        long scheduleDelayMillis,\n-        int maxQueueSize,\n-        int maxExportBatchSize,\n-        int exporterTimeoutMillis) {\n-      this.spanExporter = spanExporter;\n-      this.scheduleDelayMillis = scheduleDelayMillis;\n-      this.maxQueueSize = maxQueueSize;\n-      this.halfMaxQueueSize = maxQueueSize >> 1;\n-      this.maxExportBatchSize = maxExportBatchSize;\n-      this.exporterTimeoutMillis = exporterTimeoutMillis;\n-      this.spansList = new ArrayList<>(maxQueueSize);\n-    }\n-\n-    private void addSpan(ReadableSpan span) {\n-      synchronized (monitor) {\n-        if (spansList.size() == maxQueueSize) {\n-          droppedSpans.add(1);\n-          return;\n-        }\n-        // TODO: Record a gauge for referenced spans.\n-        spansList.add(span);\n-        // Notify the worker thread that at half of the queue is available. It will take\n-        // time anyway for the thread to wake up.\n-        if (spansList.size() >= halfMaxQueueSize) {\n-          monitor.notifyAll();\n-        }\n-      }\n+    forceFlush = true;\n+    // Cancel only returns true once.\n+    if (!nextExport.cancel(false)) {\n+      // Already exporting.\n+      return;\n     }\n-\n-    @Override\n-    public void run() {\n-      while (!Thread.currentThread().isInterrupted()) {\n-        // Copy all the batched spans in a separate list to release the monitor lock asap to\n-        // avoid blocking the producer thread.\n-        ArrayList<ReadableSpan> spansCopy;\n-        synchronized (monitor) {\n-          // If still maxExportBatchSize elements in the queue better to execute an extra\n-          if (spansList.size() < maxExportBatchSize) {\n-            do {\n-              // In the case of a spurious wakeup we export only if we have at least one span in\n-              // the batch. It is acceptable because batching is a best effort mechanism here.\n-              try {\n-                monitor.wait(scheduleDelayMillis);\n-              } catch (InterruptedException ie) {\n-                // Preserve the interruption status as per guidance and stop doing any work.\n-                Thread.currentThread().interrupt();\n-                return;\n-              }\n-            } while (spansList.isEmpty());\n+    final CompletableResultCode result = new CompletableResultCode();\n+    executor.submit(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            exportBatch(result);\n           }\n-          spansCopy = new ArrayList<>(spansList);\n-          spansList.clear();\n-        }\n-        // Execute the batch export outside the synchronized to not block all producers.\n-        exportBatches(spansCopy);\n-      }\n-    }\n-\n-    private void shutdown() {\n-      forceFlush();\n-      timer.cancel();\n-      spanExporter.shutdown();\n+        });\n+    final CountDownLatch latch = new CountDownLatch(1);\n+    result.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            latch.countDown();\n+          }\n+        });\n+    try {\n+      latch.await(exporterTimeoutMillis, TimeUnit.MILLISECONDS);\n+    } catch (InterruptedException e) {\n+      logger.log(Level.WARNING, \"Interrupted while forcing span flush.\");\n+      Thread.currentThread().interrupt();\n     }\n+  }\n \n-    private void forceFlush() {\n-      ArrayList<ReadableSpan> spansCopy;\n-      synchronized (monitor) {\n-        spansCopy = new ArrayList<>(spansList);\n-        spansList.clear();\n-      }\n-      // Execute the batch export outside the synchronized to not block all producers.\n-      exportBatches(spansCopy);\n+  // Timeout is best effort don't need to handle the future return value.\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void exportBatch(final CompletableResultCode result) {\n+    spanBuffer.clear();\n+    if (queue.drainTo(spanBuffer, maxExportBatchSize) == 0) {\n+      result.succeed();\n+      scheduleNextExport();\n+      return;\n     }\n \n-    private void exportBatches(ArrayList<ReadableSpan> spanList) {\n-      // TODO: Record a counter for pushed spans.\n-      for (int i = 0; i < spanList.size(); ) {\n-        int lastIndexToTake = Math.min(i + maxExportBatchSize, spanList.size());\n-        onBatchExport(createSpanDataForExport(spanList, i, lastIndexToTake));\n-        i = lastIndexToTake;\n-      }\n+    List<SpanData> forExport = new ArrayList<>(spanBuffer.size());\n+    for (ReadableSpan span : spanBuffer) {\n+      forExport.add(span.toSpanData());\n     }\n \n-    private static List<SpanData> createSpanDataForExport(\n-        List<ReadableSpan> spanList, int startIndex, int endIndex) {\n-      List<SpanData> spanDataBuffer = new ArrayList<>(endIndex - startIndex);\n-      for (int i = startIndex; i < endIndex; i++) {\n-        spanDataBuffer.add(spanList.get(i).toSpanData());\n-        // Remove the reference to the ReadableSpan to allow GC to free the memory.\n-        spanList.set(i, null);\n-      }\n-      return Collections.unmodifiableList(spanDataBuffer);\n-    }\n+    final CompletableResultCode exportResult = spanExporter.export(forExport);\n+    exportResult.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            if (!exportResult.isSuccess()) {\n+              logger.log(Level.FINE, \"Exporter failed\");\n+            }\n+            if (queue.size() >= maxExportBatchSize) {\n+              exportBatch(result);\n+            } else if (forceFlush) {\n+              // When we're forcing a flush we want to export even when we don't have a full batch.\n+              forceFlush = false;\n+              exportBatch(result);\n+            } else {\n+              result.succeed();\n+              scheduleNextExport();\n+            }\n+          }\n+        });\n+\n+    // Timeout if result doesn't complete soon enough.\n+    executor.schedule(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f76bb5e2284ca293e64a55b0e441f200c8f009"}, "originalPosition": 318}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyODI3Nzkw", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#pullrequestreview-472827790", "createdAt": "2020-08-21T21:25:48Z", "commit": {"oid": "90e80883497c6cc2ef096f6bc00466827af9db8a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQyMToyNTo0OFrOHE-Sog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQyMToyNTo0OFrOHE-Sog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDk3NjkzMA==", "bodyText": "It's an interesting idea to have the exporter also listen on its result, don't think I've seen that pattern before but it sounds like it'd work! In that case yeah this should be ok since we're failing the export result like before in the timeout.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r474976930", "createdAt": "2020-08-21T21:25:48Z", "author": {"login": "anuraaga"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -132,180 +166,103 @@ public boolean isEndRequired() {\n \n   @Override\n   public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n+    forceFlush();\n+    executor.shutdown();\n+    spanExporter.shutdown();\n   }\n \n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n   @Override\n   public void forceFlush() {\n-    worker.forceFlush();\n-  }\n-\n-  // Worker is a thread that batches multiple spans and calls the registered SpanExporter to export\n-  // the data.\n-  //\n-  // The list of batched data is protected by an explicit monitor object which ensures full\n-  // concurrency.\n-  private static final class Worker implements Runnable {\n-\n-    static {\n-      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.trace\");\n-      LongCounter droppedSpansCounter =\n-          meter\n-              .longCounterBuilder(\"droppedSpans\")\n-              .setUnit(\"1\")\n-              .setDescription(\n-                  \"The number of spans dropped by the BatchSpanProcessor due to high throughput.\")\n-              .build();\n-      droppedSpans =\n-          droppedSpansCounter.bind(\n-              Labels.of(\"spanProcessorType\", BatchSpanProcessor.class.getSimpleName()));\n-    }\n-\n-    private static final BoundLongCounter droppedSpans;\n-\n-    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n-\n-    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n-    private final SpanExporter spanExporter;\n-    private final long scheduleDelayMillis;\n-    private final int maxQueueSize;\n-    private final int maxExportBatchSize;\n-    private final int halfMaxQueueSize;\n-    private final Object monitor = new Object();\n-    private final int exporterTimeoutMillis;\n-    private final AtomicBoolean exportAvailable = new AtomicBoolean(true);\n-\n-    @GuardedBy(\"monitor\")\n-    private final List<ReadableSpan> spansList;\n-\n-    private Worker(\n-        SpanExporter spanExporter,\n-        long scheduleDelayMillis,\n-        int maxQueueSize,\n-        int maxExportBatchSize,\n-        int exporterTimeoutMillis) {\n-      this.spanExporter = spanExporter;\n-      this.scheduleDelayMillis = scheduleDelayMillis;\n-      this.maxQueueSize = maxQueueSize;\n-      this.halfMaxQueueSize = maxQueueSize >> 1;\n-      this.maxExportBatchSize = maxExportBatchSize;\n-      this.exporterTimeoutMillis = exporterTimeoutMillis;\n-      this.spansList = new ArrayList<>(maxQueueSize);\n-    }\n-\n-    private void addSpan(ReadableSpan span) {\n-      synchronized (monitor) {\n-        if (spansList.size() == maxQueueSize) {\n-          droppedSpans.add(1);\n-          return;\n-        }\n-        // TODO: Record a gauge for referenced spans.\n-        spansList.add(span);\n-        // Notify the worker thread that at half of the queue is available. It will take\n-        // time anyway for the thread to wake up.\n-        if (spansList.size() >= halfMaxQueueSize) {\n-          monitor.notifyAll();\n-        }\n-      }\n+    forceFlush = true;\n+    // Cancel only returns true once.\n+    if (!nextExport.cancel(false)) {\n+      // Already exporting.\n+      return;\n     }\n-\n-    @Override\n-    public void run() {\n-      while (!Thread.currentThread().isInterrupted()) {\n-        // Copy all the batched spans in a separate list to release the monitor lock asap to\n-        // avoid blocking the producer thread.\n-        ArrayList<ReadableSpan> spansCopy;\n-        synchronized (monitor) {\n-          // If still maxExportBatchSize elements in the queue better to execute an extra\n-          if (spansList.size() < maxExportBatchSize) {\n-            do {\n-              // In the case of a spurious wakeup we export only if we have at least one span in\n-              // the batch. It is acceptable because batching is a best effort mechanism here.\n-              try {\n-                monitor.wait(scheduleDelayMillis);\n-              } catch (InterruptedException ie) {\n-                // Preserve the interruption status as per guidance and stop doing any work.\n-                Thread.currentThread().interrupt();\n-                return;\n-              }\n-            } while (spansList.isEmpty());\n+    final CompletableResultCode result = new CompletableResultCode();\n+    executor.submit(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            exportBatch(result);\n           }\n-          spansCopy = new ArrayList<>(spansList);\n-          spansList.clear();\n-        }\n-        // Execute the batch export outside the synchronized to not block all producers.\n-        exportBatches(spansCopy);\n-      }\n-    }\n-\n-    private void shutdown() {\n-      forceFlush();\n-      timer.cancel();\n-      spanExporter.shutdown();\n+        });\n+    final CountDownLatch latch = new CountDownLatch(1);\n+    result.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            latch.countDown();\n+          }\n+        });\n+    try {\n+      latch.await(exporterTimeoutMillis, TimeUnit.MILLISECONDS);\n+    } catch (InterruptedException e) {\n+      logger.log(Level.WARNING, \"Interrupted while forcing span flush.\");\n+      Thread.currentThread().interrupt();\n     }\n+  }\n \n-    private void forceFlush() {\n-      ArrayList<ReadableSpan> spansCopy;\n-      synchronized (monitor) {\n-        spansCopy = new ArrayList<>(spansList);\n-        spansList.clear();\n-      }\n-      // Execute the batch export outside the synchronized to not block all producers.\n-      exportBatches(spansCopy);\n+  // Timeout is best effort don't need to handle the future return value.\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void exportBatch(final CompletableResultCode result) {\n+    spanBuffer.clear();\n+    if (queue.drainTo(spanBuffer, maxExportBatchSize) == 0) {\n+      result.succeed();\n+      scheduleNextExport();\n+      return;\n     }\n \n-    private void exportBatches(ArrayList<ReadableSpan> spanList) {\n-      // TODO: Record a counter for pushed spans.\n-      for (int i = 0; i < spanList.size(); ) {\n-        int lastIndexToTake = Math.min(i + maxExportBatchSize, spanList.size());\n-        onBatchExport(createSpanDataForExport(spanList, i, lastIndexToTake));\n-        i = lastIndexToTake;\n-      }\n+    List<SpanData> forExport = new ArrayList<>(spanBuffer.size());\n+    for (ReadableSpan span : spanBuffer) {\n+      forExport.add(span.toSpanData());\n     }\n \n-    private static List<SpanData> createSpanDataForExport(\n-        List<ReadableSpan> spanList, int startIndex, int endIndex) {\n-      List<SpanData> spanDataBuffer = new ArrayList<>(endIndex - startIndex);\n-      for (int i = startIndex; i < endIndex; i++) {\n-        spanDataBuffer.add(spanList.get(i).toSpanData());\n-        // Remove the reference to the ReadableSpan to allow GC to free the memory.\n-        spanList.set(i, null);\n-      }\n-      return Collections.unmodifiableList(spanDataBuffer);\n-    }\n+    final CompletableResultCode exportResult = spanExporter.export(forExport);\n+    exportResult.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            if (!exportResult.isSuccess()) {\n+              logger.log(Level.FINE, \"Exporter failed\");\n+            }\n+            if (queue.size() >= maxExportBatchSize) {\n+              exportBatch(result);\n+            } else if (forceFlush) {\n+              // When we're forcing a flush we want to export even when we don't have a full batch.\n+              forceFlush = false;\n+              exportBatch(result);\n+            } else {\n+              result.succeed();\n+              scheduleNextExport();\n+            }\n+          }\n+        });\n+\n+    // Timeout if result doesn't complete soon enough.\n+    executor.schedule(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg2Mzc5Mg=="}, "originalCommit": {"oid": "38f76bb5e2284ca293e64a55b0e441f200c8f009"}, "originalPosition": 318}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyODI5MTYz", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#pullrequestreview-472829163", "createdAt": "2020-08-21T21:29:18Z", "commit": {"oid": "90e80883497c6cc2ef096f6bc00466827af9db8a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQyMToyOToxOFrOHE-XIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQyMToyOToxOFrOHE-XIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDk3ODA4Mw==", "bodyText": "It\u2019s disappointing that we\u2019ve resorted to blocking a thread again as a solution given the effort I went to removing it in the past. Blocking is generally avoidable.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r474978083", "createdAt": "2020-08-21T21:29:18Z", "author": {"login": "huntc"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -132,180 +165,131 @@ public boolean isEndRequired() {\n \n   @Override\n   public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n+    nextExport.cancel(false);\n+    forceFlush();\n+    executor.shutdown();\n+    spanExporter.shutdown();\n   }\n \n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n   @Override\n   public void forceFlush() {\n-    worker.forceFlush();\n-  }\n-\n-  // Worker is a thread that batches multiple spans and calls the registered SpanExporter to export\n-  // the data.\n-  //\n-  // The list of batched data is protected by an explicit monitor object which ensures full\n-  // concurrency.\n-  private static final class Worker implements Runnable {\n-\n-    static {\n-      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.trace\");\n-      LongCounter droppedSpansCounter =\n-          meter\n-              .longCounterBuilder(\"droppedSpans\")\n-              .setUnit(\"1\")\n-              .setDescription(\n-                  \"The number of spans dropped by the BatchSpanProcessor due to high throughput.\")\n-              .build();\n-      droppedSpans =\n-          droppedSpansCounter.bind(\n-              Labels.of(\"spanProcessorType\", BatchSpanProcessor.class.getSimpleName()));\n-    }\n-\n-    private static final BoundLongCounter droppedSpans;\n-\n-    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n-\n-    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n-    private final SpanExporter spanExporter;\n-    private final long scheduleDelayMillis;\n-    private final int maxQueueSize;\n-    private final int maxExportBatchSize;\n-    private final int halfMaxQueueSize;\n-    private final Object monitor = new Object();\n-    private final int exporterTimeoutMillis;\n-    private final AtomicBoolean exportAvailable = new AtomicBoolean(true);\n-\n-    @GuardedBy(\"monitor\")\n-    private final List<ReadableSpan> spansList;\n-\n-    private Worker(\n-        SpanExporter spanExporter,\n-        long scheduleDelayMillis,\n-        int maxQueueSize,\n-        int maxExportBatchSize,\n-        int exporterTimeoutMillis) {\n-      this.spanExporter = spanExporter;\n-      this.scheduleDelayMillis = scheduleDelayMillis;\n-      this.maxQueueSize = maxQueueSize;\n-      this.halfMaxQueueSize = maxQueueSize >> 1;\n-      this.maxExportBatchSize = maxExportBatchSize;\n-      this.exporterTimeoutMillis = exporterTimeoutMillis;\n-      this.spansList = new ArrayList<>(maxQueueSize);\n-    }\n-\n-    private void addSpan(ReadableSpan span) {\n-      synchronized (monitor) {\n-        if (spansList.size() == maxQueueSize) {\n-          droppedSpans.add(1);\n-          return;\n-        }\n-        // TODO: Record a gauge for referenced spans.\n-        spansList.add(span);\n-        // Notify the worker thread that at half of the queue is available. It will take\n-        // time anyway for the thread to wake up.\n-        if (spansList.size() >= halfMaxQueueSize) {\n-          monitor.notifyAll();\n-        }\n-      }\n-    }\n-\n-    @Override\n-    public void run() {\n-      while (!Thread.currentThread().isInterrupted()) {\n-        // Copy all the batched spans in a separate list to release the monitor lock asap to\n-        // avoid blocking the producer thread.\n-        ArrayList<ReadableSpan> spansCopy;\n-        synchronized (monitor) {\n-          // If still maxExportBatchSize elements in the queue better to execute an extra\n-          if (spansList.size() < maxExportBatchSize) {\n-            do {\n-              // In the case of a spurious wakeup we export only if we have at least one span in\n-              // the batch. It is acceptable because batching is a best effort mechanism here.\n-              try {\n-                monitor.wait(scheduleDelayMillis);\n-              } catch (InterruptedException ie) {\n-                // Preserve the interruption status as per guidance and stop doing any work.\n-                Thread.currentThread().interrupt();\n-                return;\n-              }\n-            } while (spansList.isEmpty());\n+    final List<ReadableSpan> spans = new ArrayList<>(queue.size());\n+    queue.drainTo(spans);\n+    final CompletableResultCode result = new CompletableResultCode();\n+    executor.submit(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            exportNextBatch(spans, 0, result);\n           }\n-          spansCopy = new ArrayList<>(spansList);\n-          spansList.clear();\n-        }\n-        // Execute the batch export outside the synchronized to not block all producers.\n-        exportBatches(spansCopy);\n-      }\n-    }\n-\n-    private void shutdown() {\n-      forceFlush();\n-      timer.cancel();\n-      spanExporter.shutdown();\n+        });\n+    final CountDownLatch latch = new CountDownLatch(1);\n+    result.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            latch.countDown();\n+          }\n+        });\n+    try {\n+      latch.await(exporterTimeoutMillis, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90e80883497c6cc2ef096f6bc00466827af9db8a"}, "originalPosition": 246}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyODk3Nzc3", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#pullrequestreview-472897777", "createdAt": "2020-08-22T04:54:53Z", "commit": {"oid": "66e42b8052ca6798a50680fe3901c8a845d9c959"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyODk4MDY3", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#pullrequestreview-472898067", "createdAt": "2020-08-22T05:01:02Z", "commit": {"oid": "66e42b8052ca6798a50680fe3901c8a845d9c959"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQwNTowMTowM1rOHFCkmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQwNTowMTowM1rOHFCkmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA0NzA2NQ==", "bodyText": "I\u2019d really rather we don\u2019t add methods that encourage blocking. My past colleague, Viktor Klang, once said that providing an await on Scala\u2019s Future was a mistake. People WILL abuse this!!!\nPlease remove it.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r475047065", "createdAt": "2020-08-22T05:01:03Z", "author": {"login": "huntc"}, "path": "sdk/common/src/main/java/io/opentelemetry/sdk/common/export/CompletableResultCode.java", "diffHunk": "@@ -107,4 +149,32 @@ public CompletableResultCode whenComplete(Runnable action) {\n     }\n     return this;\n   }\n+\n+  /**\n+   * Waits for the specified amount of time for this {@link CompletableResultCode} to complete.\n+   *\n+   * @return this {@link CompletableResultCode}\n+   * @throws InterruptedException if the current thread was interrupted while waiting\n+   * @throws TimeoutException if the wait timed out\n+   */\n+  public CompletableResultCode get(long timeout, TimeUnit unit)\n+      throws InterruptedException, TimeoutException {\n+    synchronized (lock) {\n+      if (succeeded != null) {\n+        return this;\n+      }\n+    }\n+    final CountDownLatch latch = new CountDownLatch(1);\n+    whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            latch.countDown();\n+          }\n+        });\n+    if (!latch.await(timeout, unit)) {\n+      throw new TimeoutException();\n+    }\n+    return this;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66e42b8052ca6798a50680fe3901c8a845d9c959"}, "originalPosition": 95}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMTI0MjE4", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#pullrequestreview-473124218", "createdAt": "2020-08-24T05:12:48Z", "commit": {"oid": "141c05e131c281fceb6c7a17dd17260ceb0db64a"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwNToxMjo0OFrOHFU2QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwNToyMTowOFrOHFU-mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM0NjQ5Nw==", "bodyText": "Using Thread.sleep is fragile in tests", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r475346497", "createdAt": "2020-08-24T05:12:48Z", "author": {"login": "huntc"}, "path": "sdk/tracing/src/test/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessorTest.java", "diffHunk": "@@ -171,25 +174,35 @@ void exportMoreSpansThanTheBufferSize() {\n     ReadableSpan span4 = createSampledEndedSpan(SPAN_NAME_1);\n     ReadableSpan span5 = createSampledEndedSpan(SPAN_NAME_1);\n     ReadableSpan span6 = createSampledEndedSpan(SPAN_NAME_1);\n-    List<SpanData> exported = waitingSpanExporter.waitForExport();\n-    assertThat(exported)\n-        .containsExactly(\n-            span1.toSpanData(),\n-            span2.toSpanData(),\n-            span3.toSpanData(),\n-            span4.toSpanData(),\n-            span5.toSpanData(),\n-            span6.toSpanData());\n+\n+    // Give time for the BatchSpanProcessor to attempt to export spans.\n+    Thread.sleep(500);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "141c05e131c281fceb6c7a17dd17260ceb0db64a"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM0NzYyNg==", "bodyText": "Can we pass in the executor here so that the BSP can share resources and leave the executor as an outside concern?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r475347626", "createdAt": "2020-08-24T05:16:49Z", "author": {"login": "huntc"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -82,31 +83,61 @@\n  */\n public final class BatchSpanProcessor implements SpanProcessor {\n \n+  private static final Logger logger = Logger.getLogger(BatchSpanProcessor.class.getName());\n+\n   private static final String WORKER_THREAD_NAME =\n       BatchSpanProcessor.class.getSimpleName() + \"_WorkerThread\";\n-  private static final String TIMER_THREAD_NAME =\n-      BatchSpanProcessor.class.getSimpleName() + \"_TimerThread\";\n-  private final Worker worker;\n-  private final Thread workerThread;\n+\n+  private static final BoundLongCounter droppedSpans;\n+\n+  static {\n+    Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.trace\");\n+    LongCounter droppedSpansCounter =\n+        meter\n+            .longCounterBuilder(\"droppedSpans\")\n+            .setUnit(\"1\")\n+            .setDescription(\n+                \"The number of spans dropped by the BatchSpanProcessor due to high throughput.\")\n+            .build();\n+    droppedSpans =\n+        droppedSpansCounter.bind(\n+            Labels.of(\"spanProcessorType\", BatchSpanProcessor.class.getSimpleName()));\n+  }\n+\n+  private final int maxExportBatchSize;\n+  private final long scheduleDelayMillis;\n+  private final int exporterTimeoutMillis;\n   private final boolean sampled;\n \n+  private final SpanExporter spanExporter;\n+  private final BlockingQueue<ReadableSpan> queue;\n+  private final ScheduledExecutorService executor;\n+\n+  private final List<ReadableSpan> spanBuffer;\n+\n+  private volatile boolean closed;\n+  private volatile ScheduledFuture<?> nextExport;\n+\n   private BatchSpanProcessor(\n       SpanExporter spanExporter,\n       boolean sampled,\n       long scheduleDelayMillis,\n       int maxQueueSize,\n       int maxExportBatchSize,\n       int exporterTimeoutMillis) {\n-    this.worker =\n-        new Worker(\n-            spanExporter,\n-            scheduleDelayMillis,\n-            maxQueueSize,\n-            maxExportBatchSize,\n-            exporterTimeoutMillis);\n-    this.workerThread = new DaemonThreadFactory(WORKER_THREAD_NAME).newThread(worker);\n-    this.workerThread.start();\n+    this.maxExportBatchSize = maxExportBatchSize;\n+    this.scheduleDelayMillis = scheduleDelayMillis;\n+    this.exporterTimeoutMillis = exporterTimeoutMillis;\n     this.sampled = sampled;\n+\n+    this.spanExporter = spanExporter;\n+    queue = new ArrayBlockingQueue<>(maxQueueSize);\n+    executor =\n+        Executors.newSingleThreadScheduledExecutor(new DaemonThreadFactory(WORKER_THREAD_NAME));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "141c05e131c281fceb6c7a17dd17260ceb0db64a"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM0ODAwNQ==", "bodyText": "The executor should be an outside concern", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r475348005", "createdAt": "2020-08-24T05:18:28Z", "author": {"login": "huntc"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -131,181 +164,160 @@ public boolean isEndRequired() {\n   }\n \n   @Override\n-  public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n-  }\n+  public CompletableResultCode shutdown() {\n+    closed = true;\n+    nextExport.cancel(false);\n+\n+    final CompletableResultCode result = new CompletableResultCode();\n+    final CompletableResultCode flushResult = forceFlush();\n+    flushResult.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            executor.shutdown();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "141c05e131c281fceb6c7a17dd17260ceb0db64a"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM0ODYzMg==", "bodyText": "I'm thinking that a native array copy would be more efficient here... and then form an array list around that for calling the exporter. WDYT?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r475348632", "createdAt": "2020-08-24T05:21:08Z", "author": {"login": "huntc"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -131,181 +164,160 @@ public boolean isEndRequired() {\n   }\n \n   @Override\n-  public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n-  }\n+  public CompletableResultCode shutdown() {\n+    closed = true;\n+    nextExport.cancel(false);\n+\n+    final CompletableResultCode result = new CompletableResultCode();\n+    final CompletableResultCode flushResult = forceFlush();\n+    flushResult.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            executor.shutdown();\n+            final CompletableResultCode shutdownResult = spanExporter.shutdown();\n+            shutdownResult.whenComplete(\n+                new Runnable() {\n+                  @Override\n+                  public void run() {\n+                    if (!flushResult.isSuccess() || !shutdownResult.isSuccess()) {\n+                      result.fail();\n+                    } else {\n+                      result.succeed();\n+                    }\n+                  }\n+                });\n+          }\n+        });\n \n-  @Override\n-  public void forceFlush() {\n-    worker.forceFlush();\n+    return result;\n   }\n \n-  // Worker is a thread that batches multiple spans and calls the registered SpanExporter to export\n-  // the data.\n-  //\n-  // The list of batched data is protected by an explicit monitor object which ensures full\n-  // concurrency.\n-  private static final class Worker implements Runnable {\n-\n-    static {\n-      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.trace\");\n-      LongCounter droppedSpansCounter =\n-          meter\n-              .longCounterBuilder(\"droppedSpans\")\n-              .setUnit(\"1\")\n-              .setDescription(\n-                  \"The number of spans dropped by the BatchSpanProcessor due to high throughput.\")\n-              .build();\n-      droppedSpans =\n-          droppedSpansCounter.bind(\n-              Labels.of(\"spanProcessorType\", BatchSpanProcessor.class.getSimpleName()));\n-    }\n-\n-    private static final BoundLongCounter droppedSpans;\n-\n-    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n-\n-    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n-    private final SpanExporter spanExporter;\n-    private final long scheduleDelayMillis;\n-    private final int maxQueueSize;\n-    private final int maxExportBatchSize;\n-    private final int halfMaxQueueSize;\n-    private final Object monitor = new Object();\n-    private final int exporterTimeoutMillis;\n-    private final AtomicBoolean exportAvailable = new AtomicBoolean(true);\n-\n-    @GuardedBy(\"monitor\")\n-    private final List<ReadableSpan> spansList;\n-\n-    private Worker(\n-        SpanExporter spanExporter,\n-        long scheduleDelayMillis,\n-        int maxQueueSize,\n-        int maxExportBatchSize,\n-        int exporterTimeoutMillis) {\n-      this.spanExporter = spanExporter;\n-      this.scheduleDelayMillis = scheduleDelayMillis;\n-      this.maxQueueSize = maxQueueSize;\n-      this.halfMaxQueueSize = maxQueueSize >> 1;\n-      this.maxExportBatchSize = maxExportBatchSize;\n-      this.exporterTimeoutMillis = exporterTimeoutMillis;\n-      this.spansList = new ArrayList<>(maxQueueSize);\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  @Override\n+  public CompletableResultCode forceFlush() {\n+    if (queue.isEmpty()) {\n+      return CompletableResultCode.ofSuccess();\n     }\n+    final List<ReadableSpan> spans = new ArrayList<>(queue.size());\n+    queue.drainTo(spans);\n+    final CompletableResultCode result = new CompletableResultCode();\n+    executor.submit(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            exportNextBatch(spans, 0, result);\n+          }\n+        });\n+    return result;\n+  }\n \n-    private void addSpan(ReadableSpan span) {\n-      synchronized (monitor) {\n-        if (spansList.size() == maxQueueSize) {\n-          droppedSpans.add(1);\n-          return;\n-        }\n-        // TODO: Record a gauge for referenced spans.\n-        spansList.add(span);\n-        // Notify the worker thread that at half of the queue is available. It will take\n-        // time anyway for the thread to wake up.\n-        if (spansList.size() >= halfMaxQueueSize) {\n-          monitor.notifyAll();\n-        }\n-      }\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void exportSpans() {\n+    spanBuffer.clear();\n+    if (queue.drainTo(spanBuffer) == 0) {\n+      scheduleNextExport();\n+      return;\n     }\n \n-    @Override\n-    public void run() {\n-      while (!Thread.currentThread().isInterrupted()) {\n-        // Copy all the batched spans in a separate list to release the monitor lock asap to\n-        // avoid blocking the producer thread.\n-        ArrayList<ReadableSpan> spansCopy;\n-        synchronized (monitor) {\n-          // If still maxExportBatchSize elements in the queue better to execute an extra\n-          if (spansList.size() < maxExportBatchSize) {\n-            do {\n-              // In the case of a spurious wakeup we export only if we have at least one span in\n-              // the batch. It is acceptable because batching is a best effort mechanism here.\n-              try {\n-                monitor.wait(scheduleDelayMillis);\n-              } catch (InterruptedException ie) {\n-                // Preserve the interruption status as per guidance and stop doing any work.\n-                Thread.currentThread().interrupt();\n-                return;\n-              }\n-            } while (spansList.isEmpty());\n+    final CompletableResultCode result = new CompletableResultCode();\n+    executor.submit(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            exportNextBatch(spanBuffer, 0, result);\n           }\n-          spansCopy = new ArrayList<>(spansList);\n-          spansList.clear();\n-        }\n-        // Execute the batch export outside the synchronized to not block all producers.\n-        exportBatches(spansCopy);\n-      }\n-    }\n-\n-    private void shutdown() {\n-      forceFlush();\n-      timer.cancel();\n-      spanExporter.shutdown();\n-    }\n+        });\n+\n+    result.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            if (queue.size() >= maxExportBatchSize) {\n+              executor.submit(\n+                  new Runnable() {\n+                    @Override\n+                    public void run() {\n+                      exportSpans();\n+                    }\n+                  });\n+            } else {\n+              scheduleNextExport();\n+            }\n+          }\n+        });\n+  }\n \n-    private void forceFlush() {\n-      ArrayList<ReadableSpan> spansCopy;\n-      synchronized (monitor) {\n-        spansCopy = new ArrayList<>(spansList);\n-        spansList.clear();\n-      }\n-      // Execute the batch export outside the synchronized to not block all producers.\n-      exportBatches(spansCopy);\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void exportNextBatch(\n+      final List<ReadableSpan> spans, final int offset, final CompletableResultCode result) {\n+    int num = Math.min(maxExportBatchSize, spans.size() - offset);\n+    final int limit = offset + num;\n+    List<SpanData> forExport = new ArrayList<>(num);\n+    for (int i = offset; i < limit; i++) {\n+      forExport.add(spans.get(i).toSpanData());\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "141c05e131c281fceb6c7a17dd17260ceb0db64a"}, "originalPosition": 325}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNjQ4MzAw", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#pullrequestreview-473648300", "createdAt": "2020-08-24T16:10:24Z", "commit": {"oid": "141c05e131c281fceb6c7a17dd17260ceb0db64a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNjoxMDoyNFrOHFsJew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNjoxMDoyNFrOHFsJew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcyODI1MQ==", "bodyText": "It feels like there should be a way to compose the things in here more elegantly, but it could be done as a follow-on PR.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r475728251", "createdAt": "2020-08-24T16:10:24Z", "author": {"login": "jkwatson"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -131,181 +164,160 @@ public boolean isEndRequired() {\n   }\n \n   @Override\n-  public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n-  }\n+  public CompletableResultCode shutdown() {\n+    closed = true;\n+    nextExport.cancel(false);\n+\n+    final CompletableResultCode result = new CompletableResultCode();\n+    final CompletableResultCode flushResult = forceFlush();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "141c05e131c281fceb6c7a17dd17260ceb0db64a"}, "originalPosition": 129}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNjYxODUw", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#pullrequestreview-473661850", "createdAt": "2020-08-24T16:27:57Z", "commit": {"oid": "141c05e131c281fceb6c7a17dd17260ceb0db64a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNjoyNzo1N1rOHFszrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNjoyNzo1N1rOHFszrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTczOTA1NA==", "bodyText": "maybe numberToExport, rather than just num?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r475739054", "createdAt": "2020-08-24T16:27:57Z", "author": {"login": "jkwatson"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -131,181 +164,160 @@ public boolean isEndRequired() {\n   }\n \n   @Override\n-  public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n-  }\n+  public CompletableResultCode shutdown() {\n+    closed = true;\n+    nextExport.cancel(false);\n+\n+    final CompletableResultCode result = new CompletableResultCode();\n+    final CompletableResultCode flushResult = forceFlush();\n+    flushResult.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            executor.shutdown();\n+            final CompletableResultCode shutdownResult = spanExporter.shutdown();\n+            shutdownResult.whenComplete(\n+                new Runnable() {\n+                  @Override\n+                  public void run() {\n+                    if (!flushResult.isSuccess() || !shutdownResult.isSuccess()) {\n+                      result.fail();\n+                    } else {\n+                      result.succeed();\n+                    }\n+                  }\n+                });\n+          }\n+        });\n \n-  @Override\n-  public void forceFlush() {\n-    worker.forceFlush();\n+    return result;\n   }\n \n-  // Worker is a thread that batches multiple spans and calls the registered SpanExporter to export\n-  // the data.\n-  //\n-  // The list of batched data is protected by an explicit monitor object which ensures full\n-  // concurrency.\n-  private static final class Worker implements Runnable {\n-\n-    static {\n-      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.trace\");\n-      LongCounter droppedSpansCounter =\n-          meter\n-              .longCounterBuilder(\"droppedSpans\")\n-              .setUnit(\"1\")\n-              .setDescription(\n-                  \"The number of spans dropped by the BatchSpanProcessor due to high throughput.\")\n-              .build();\n-      droppedSpans =\n-          droppedSpansCounter.bind(\n-              Labels.of(\"spanProcessorType\", BatchSpanProcessor.class.getSimpleName()));\n-    }\n-\n-    private static final BoundLongCounter droppedSpans;\n-\n-    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n-\n-    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n-    private final SpanExporter spanExporter;\n-    private final long scheduleDelayMillis;\n-    private final int maxQueueSize;\n-    private final int maxExportBatchSize;\n-    private final int halfMaxQueueSize;\n-    private final Object monitor = new Object();\n-    private final int exporterTimeoutMillis;\n-    private final AtomicBoolean exportAvailable = new AtomicBoolean(true);\n-\n-    @GuardedBy(\"monitor\")\n-    private final List<ReadableSpan> spansList;\n-\n-    private Worker(\n-        SpanExporter spanExporter,\n-        long scheduleDelayMillis,\n-        int maxQueueSize,\n-        int maxExportBatchSize,\n-        int exporterTimeoutMillis) {\n-      this.spanExporter = spanExporter;\n-      this.scheduleDelayMillis = scheduleDelayMillis;\n-      this.maxQueueSize = maxQueueSize;\n-      this.halfMaxQueueSize = maxQueueSize >> 1;\n-      this.maxExportBatchSize = maxExportBatchSize;\n-      this.exporterTimeoutMillis = exporterTimeoutMillis;\n-      this.spansList = new ArrayList<>(maxQueueSize);\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  @Override\n+  public CompletableResultCode forceFlush() {\n+    if (queue.isEmpty()) {\n+      return CompletableResultCode.ofSuccess();\n     }\n+    final List<ReadableSpan> spans = new ArrayList<>(queue.size());\n+    queue.drainTo(spans);\n+    final CompletableResultCode result = new CompletableResultCode();\n+    executor.submit(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            exportNextBatch(spans, 0, result);\n+          }\n+        });\n+    return result;\n+  }\n \n-    private void addSpan(ReadableSpan span) {\n-      synchronized (monitor) {\n-        if (spansList.size() == maxQueueSize) {\n-          droppedSpans.add(1);\n-          return;\n-        }\n-        // TODO: Record a gauge for referenced spans.\n-        spansList.add(span);\n-        // Notify the worker thread that at half of the queue is available. It will take\n-        // time anyway for the thread to wake up.\n-        if (spansList.size() >= halfMaxQueueSize) {\n-          monitor.notifyAll();\n-        }\n-      }\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void exportSpans() {\n+    spanBuffer.clear();\n+    if (queue.drainTo(spanBuffer) == 0) {\n+      scheduleNextExport();\n+      return;\n     }\n \n-    @Override\n-    public void run() {\n-      while (!Thread.currentThread().isInterrupted()) {\n-        // Copy all the batched spans in a separate list to release the monitor lock asap to\n-        // avoid blocking the producer thread.\n-        ArrayList<ReadableSpan> spansCopy;\n-        synchronized (monitor) {\n-          // If still maxExportBatchSize elements in the queue better to execute an extra\n-          if (spansList.size() < maxExportBatchSize) {\n-            do {\n-              // In the case of a spurious wakeup we export only if we have at least one span in\n-              // the batch. It is acceptable because batching is a best effort mechanism here.\n-              try {\n-                monitor.wait(scheduleDelayMillis);\n-              } catch (InterruptedException ie) {\n-                // Preserve the interruption status as per guidance and stop doing any work.\n-                Thread.currentThread().interrupt();\n-                return;\n-              }\n-            } while (spansList.isEmpty());\n+    final CompletableResultCode result = new CompletableResultCode();\n+    executor.submit(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            exportNextBatch(spanBuffer, 0, result);\n           }\n-          spansCopy = new ArrayList<>(spansList);\n-          spansList.clear();\n-        }\n-        // Execute the batch export outside the synchronized to not block all producers.\n-        exportBatches(spansCopy);\n-      }\n-    }\n-\n-    private void shutdown() {\n-      forceFlush();\n-      timer.cancel();\n-      spanExporter.shutdown();\n-    }\n+        });\n+\n+    result.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            if (queue.size() >= maxExportBatchSize) {\n+              executor.submit(\n+                  new Runnable() {\n+                    @Override\n+                    public void run() {\n+                      exportSpans();\n+                    }\n+                  });\n+            } else {\n+              scheduleNextExport();\n+            }\n+          }\n+        });\n+  }\n \n-    private void forceFlush() {\n-      ArrayList<ReadableSpan> spansCopy;\n-      synchronized (monitor) {\n-        spansCopy = new ArrayList<>(spansList);\n-        spansList.clear();\n-      }\n-      // Execute the batch export outside the synchronized to not block all producers.\n-      exportBatches(spansCopy);\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void exportNextBatch(\n+      final List<ReadableSpan> spans, final int offset, final CompletableResultCode result) {\n+    int num = Math.min(maxExportBatchSize, spans.size() - offset);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "141c05e131c281fceb6c7a17dd17260ceb0db64a"}, "originalPosition": 320}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNjczMTk3", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#pullrequestreview-473673197", "createdAt": "2020-08-24T16:41:11Z", "commit": {"oid": "141c05e131c281fceb6c7a17dd17260ceb0db64a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNjo0MToxMVrOHFtcnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNjo0MToxMVrOHFtcnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc0OTUzMw==", "bodyText": "What do you think about putting this inside the try block? Seems like it might read a little more cleanly not to have to pre-declare the exportResult.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#discussion_r475749533", "createdAt": "2020-08-24T16:41:11Z", "author": {"login": "jkwatson"}, "path": "sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -131,181 +164,160 @@ public boolean isEndRequired() {\n   }\n \n   @Override\n-  public void shutdown() {\n-    workerThread.interrupt();\n-    worker.shutdown();\n-  }\n+  public CompletableResultCode shutdown() {\n+    closed = true;\n+    nextExport.cancel(false);\n+\n+    final CompletableResultCode result = new CompletableResultCode();\n+    final CompletableResultCode flushResult = forceFlush();\n+    flushResult.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            executor.shutdown();\n+            final CompletableResultCode shutdownResult = spanExporter.shutdown();\n+            shutdownResult.whenComplete(\n+                new Runnable() {\n+                  @Override\n+                  public void run() {\n+                    if (!flushResult.isSuccess() || !shutdownResult.isSuccess()) {\n+                      result.fail();\n+                    } else {\n+                      result.succeed();\n+                    }\n+                  }\n+                });\n+          }\n+        });\n \n-  @Override\n-  public void forceFlush() {\n-    worker.forceFlush();\n+    return result;\n   }\n \n-  // Worker is a thread that batches multiple spans and calls the registered SpanExporter to export\n-  // the data.\n-  //\n-  // The list of batched data is protected by an explicit monitor object which ensures full\n-  // concurrency.\n-  private static final class Worker implements Runnable {\n-\n-    static {\n-      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.trace\");\n-      LongCounter droppedSpansCounter =\n-          meter\n-              .longCounterBuilder(\"droppedSpans\")\n-              .setUnit(\"1\")\n-              .setDescription(\n-                  \"The number of spans dropped by the BatchSpanProcessor due to high throughput.\")\n-              .build();\n-      droppedSpans =\n-          droppedSpansCounter.bind(\n-              Labels.of(\"spanProcessorType\", BatchSpanProcessor.class.getSimpleName()));\n-    }\n-\n-    private static final BoundLongCounter droppedSpans;\n-\n-    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n-\n-    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n-    private final SpanExporter spanExporter;\n-    private final long scheduleDelayMillis;\n-    private final int maxQueueSize;\n-    private final int maxExportBatchSize;\n-    private final int halfMaxQueueSize;\n-    private final Object monitor = new Object();\n-    private final int exporterTimeoutMillis;\n-    private final AtomicBoolean exportAvailable = new AtomicBoolean(true);\n-\n-    @GuardedBy(\"monitor\")\n-    private final List<ReadableSpan> spansList;\n-\n-    private Worker(\n-        SpanExporter spanExporter,\n-        long scheduleDelayMillis,\n-        int maxQueueSize,\n-        int maxExportBatchSize,\n-        int exporterTimeoutMillis) {\n-      this.spanExporter = spanExporter;\n-      this.scheduleDelayMillis = scheduleDelayMillis;\n-      this.maxQueueSize = maxQueueSize;\n-      this.halfMaxQueueSize = maxQueueSize >> 1;\n-      this.maxExportBatchSize = maxExportBatchSize;\n-      this.exporterTimeoutMillis = exporterTimeoutMillis;\n-      this.spansList = new ArrayList<>(maxQueueSize);\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  @Override\n+  public CompletableResultCode forceFlush() {\n+    if (queue.isEmpty()) {\n+      return CompletableResultCode.ofSuccess();\n     }\n+    final List<ReadableSpan> spans = new ArrayList<>(queue.size());\n+    queue.drainTo(spans);\n+    final CompletableResultCode result = new CompletableResultCode();\n+    executor.submit(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            exportNextBatch(spans, 0, result);\n+          }\n+        });\n+    return result;\n+  }\n \n-    private void addSpan(ReadableSpan span) {\n-      synchronized (monitor) {\n-        if (spansList.size() == maxQueueSize) {\n-          droppedSpans.add(1);\n-          return;\n-        }\n-        // TODO: Record a gauge for referenced spans.\n-        spansList.add(span);\n-        // Notify the worker thread that at half of the queue is available. It will take\n-        // time anyway for the thread to wake up.\n-        if (spansList.size() >= halfMaxQueueSize) {\n-          monitor.notifyAll();\n-        }\n-      }\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void exportSpans() {\n+    spanBuffer.clear();\n+    if (queue.drainTo(spanBuffer) == 0) {\n+      scheduleNextExport();\n+      return;\n     }\n \n-    @Override\n-    public void run() {\n-      while (!Thread.currentThread().isInterrupted()) {\n-        // Copy all the batched spans in a separate list to release the monitor lock asap to\n-        // avoid blocking the producer thread.\n-        ArrayList<ReadableSpan> spansCopy;\n-        synchronized (monitor) {\n-          // If still maxExportBatchSize elements in the queue better to execute an extra\n-          if (spansList.size() < maxExportBatchSize) {\n-            do {\n-              // In the case of a spurious wakeup we export only if we have at least one span in\n-              // the batch. It is acceptable because batching is a best effort mechanism here.\n-              try {\n-                monitor.wait(scheduleDelayMillis);\n-              } catch (InterruptedException ie) {\n-                // Preserve the interruption status as per guidance and stop doing any work.\n-                Thread.currentThread().interrupt();\n-                return;\n-              }\n-            } while (spansList.isEmpty());\n+    final CompletableResultCode result = new CompletableResultCode();\n+    executor.submit(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            exportNextBatch(spanBuffer, 0, result);\n           }\n-          spansCopy = new ArrayList<>(spansList);\n-          spansList.clear();\n-        }\n-        // Execute the batch export outside the synchronized to not block all producers.\n-        exportBatches(spansCopy);\n-      }\n-    }\n-\n-    private void shutdown() {\n-      forceFlush();\n-      timer.cancel();\n-      spanExporter.shutdown();\n-    }\n+        });\n+\n+    result.whenComplete(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            if (queue.size() >= maxExportBatchSize) {\n+              executor.submit(\n+                  new Runnable() {\n+                    @Override\n+                    public void run() {\n+                      exportSpans();\n+                    }\n+                  });\n+            } else {\n+              scheduleNextExport();\n+            }\n+          }\n+        });\n+  }\n \n-    private void forceFlush() {\n-      ArrayList<ReadableSpan> spansCopy;\n-      synchronized (monitor) {\n-        spansCopy = new ArrayList<>(spansList);\n-        spansList.clear();\n-      }\n-      // Execute the batch export outside the synchronized to not block all producers.\n-      exportBatches(spansCopy);\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void exportNextBatch(\n+      final List<ReadableSpan> spans, final int offset, final CompletableResultCode result) {\n+    int num = Math.min(maxExportBatchSize, spans.size() - offset);\n+    final int limit = offset + num;\n+    List<SpanData> forExport = new ArrayList<>(num);\n+    for (int i = offset; i < limit; i++) {\n+      forExport.add(spans.get(i).toSpanData());\n     }\n-\n-    private void exportBatches(ArrayList<ReadableSpan> spanList) {\n-      // TODO: Record a counter for pushed spans.\n-      for (int i = 0; i < spanList.size(); ) {\n-        int lastIndexToTake = Math.min(i + maxExportBatchSize, spanList.size());\n-        onBatchExport(createSpanDataForExport(spanList, i, lastIndexToTake));\n-        i = lastIndexToTake;\n-      }\n+    final CompletableResultCode exportResult;\n+    try {\n+      exportResult = spanExporter.export(forExport);\n+    } catch (Exception e) {\n+      logger.log(Level.FINE, \"Exporter failed\", e);\n+      maybeContinueBatch(spans, limit, result);\n+      return;\n     }\n+    exportResult.whenComplete(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "141c05e131c281fceb6c7a17dd17260ceb0db64a"}, "originalPosition": 342}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35c74d38d9001dc0d3ccaf32f06a18917b9ba4c4", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/35c74d38d9001dc0d3ccaf32f06a18917b9ba4c4", "committedDate": "2020-08-27T06:28:32Z", "message": "Make sure forceFlush / shutdown can have callers wait for them to be done by returning CompletableResultCode."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee3b5ee157a5340c61cb00c4e291d77a5341c43d", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/ee3b5ee157a5340c61cb00c4e291d77a5341c43d", "committedDate": "2020-08-27T06:42:39Z", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into simplify-batch-span-processor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "555df8b12e059c23e6ae87495668cc2dd5efe1e6", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/555df8b12e059c23e6ae87495668cc2dd5efe1e6", "committedDate": "2020-08-27T06:52:28Z", "message": "Merge"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "141c05e131c281fceb6c7a17dd17260ceb0db64a", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/141c05e131c281fceb6c7a17dd17260ceb0db64a", "committedDate": "2020-08-24T02:55:40Z", "message": "javadoc"}, "afterCommit": {"oid": "555df8b12e059c23e6ae87495668cc2dd5efe1e6", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/555df8b12e059c23e6ae87495668cc2dd5efe1e6", "committedDate": "2020-08-27T06:52:28Z", "message": "Merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e3e2ba3e697d1a2cdc5066953520befc76efc59", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/6e3e2ba3e697d1a2cdc5066953520befc76efc59", "committedDate": "2020-08-28T09:36:23Z", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into simplify-batch-span-processor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3OTIwMDE3", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1571#pullrequestreview-477920017", "createdAt": "2020-08-28T17:51:14Z", "commit": {"oid": "6e3e2ba3e697d1a2cdc5066953520befc76efc59"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2387, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}