{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUyMzY2NDQy", "number": 1432, "title": "Reuse char[] when constructing trace context header for injection.", "bodyText": "For #1430 I will probably add a similar reusable StringBuilder for reducing overhead of recording exceptions. First I figured we should apply it to our existing place to understand the implications.\nWhen constructing strings, it is almost always worth using a reused buffer which avoids zeroing the array and extra garbage generation, and this works well since these buffers do not get exposed outside of the method.\nMain concern is putting this in internal, we should reduce the number of these ThreadLocal that we have in an app since there's no point at all in having multiple, but with internal it's not supposed to be used outside, e.g., in the SDK or in propagation extensions. But in common it seems to expose it to the public. Does it make sense to allow this sort of class outside the API module? I can add the error prone RestrictedApi annotation to formalize that if it does. It's too bad the JDK will never add this sort of class since it's somewhat unsafe, and JDK never exposes unsafe APIs to users. But memory usage of apps would go down if there was one thread local to rule them all...\nAbout 15% faster with less than half of the allocation.\nAfter\nBenchmark                                                                       Mode  Cnt    Score     Error   Units\nHttpTraceContextInjectBenchmark.measureInject                                   avgt   15   70.617 \u2592   7.677   ns/op\nHttpTraceContextInjectBenchmark.measureInject:\u2556gc.alloc.rate                    avgt   15  868.646 \u2592  82.041  MB/sec\nHttpTraceContextInjectBenchmark.measureInject:\u2556gc.alloc.rate.norm               avgt   15   96.009 \u2592   0.001    B/op\nHttpTraceContextInjectBenchmark.measureInject:\u2556gc.churn.G1_Eden_Space           avgt   15  877.322 \u2592 109.523  MB/sec\nHttpTraceContextInjectBenchmark.measureInject:\u2556gc.churn.G1_Eden_Space.norm      avgt   15   97.044 \u2592   8.893    B/op\nHttpTraceContextInjectBenchmark.measureInject:\u2556gc.churn.G1_Survivor_Space       avgt   15    0.004 \u2592   0.003  MB/sec\nHttpTraceContextInjectBenchmark.measureInject:\u2556gc.churn.G1_Survivor_Space.norm  avgt   15   ? 10?\u2502              B/op\nHttpTraceContextInjectBenchmark.measureInject:\u2556gc.count                         avgt   15   76.000            counts\nHttpTraceContextInjectBenchmark.measureInject:\u2556gc.time                          avgt   15  123.000                ms\n\nBefore\nBenchmark                                                                       Mode  Cnt     Score     Error   Units\nHttpTraceContextInjectBenchmark.measureInject                                   avgt   15    84.904 \u2592  12.105   ns/op\nHttpTraceContextInjectBenchmark.measureInject:\u2556gc.alloc.rate                    avgt   15  1697.155 \u2592 213.918  MB/sec\nHttpTraceContextInjectBenchmark.measureInject:\u2556gc.alloc.rate.norm               avgt   15   224.017 \u2592   0.001    B/op\nHttpTraceContextInjectBenchmark.measureInject:\u2556gc.churn.G1_Eden_Space           avgt   15  1692.461 \u2592 228.890  MB/sec\nHttpTraceContextInjectBenchmark.measureInject:\u2556gc.churn.G1_Eden_Space.norm      avgt   15   223.377 \u2592  10.128    B/op\nHttpTraceContextInjectBenchmark.measureInject:\u2556gc.churn.G1_Survivor_Space       avgt   15     0.004 \u2592   0.003  MB/sec\nHttpTraceContextInjectBenchmark.measureInject:\u2556gc.churn.G1_Survivor_Space.norm  avgt   15     0.001 \u2592   0.001    B/op\nHttpTraceContextInjectBenchmark.measureInject:\u2556gc.count                         avgt   15   114.000            counts\nHttpTraceContextInjectBenchmark.measureInject:\u2556gc.time                          avgt   15   205.000                ms", "createdAt": "2020-07-19T06:01:06Z", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1432", "merged": true, "mergeCommit": {"oid": "1b0f20d647e20076a36dd2d566d212e76db86c28"}, "closed": true, "closedAt": "2020-07-20T16:06:57Z", "author": {"login": "anuraaga"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc2WkdwAH2gAyNDUyMzY2NDQyOjY4OWVjNmY3MTM1OGJmZTJlMzE3MTJkYzJlYjg0NjFkMjAzYTU5MWI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc20M6zAFqTQ1MTc2NzYxMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "689ec6f71358bfe2e31712dc2eb8461d203a591b", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/689ec6f71358bfe2e31712dc2eb8461d203a591b", "committedDate": "2020-07-19T05:55:44Z", "message": "Reuse char[] when constructing trace context header for injection."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "583c1cc5244c5e82dc6f6028c62368cd602ce719", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/583c1cc5244c5e82dc6f6028c62368cd602ce719", "committedDate": "2020-07-19T05:57:24Z", "message": "Spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3781498d153724d38712a1b24cffe5e06faddb7c", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/3781498d153724d38712a1b24cffe5e06faddb7c", "committedDate": "2020-07-19T06:06:39Z", "message": "License"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMzA5NTAw", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1432#pullrequestreview-451309500", "createdAt": "2020-07-20T05:43:27Z", "commit": {"oid": "3781498d153724d38712a1b24cffe5e06faddb7c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNTo0MzoyN1rOGz5aOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNTo0MzoyN1rOGz5aOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA3MTE2MQ==", "bodyText": "This seems to not be thread safe. if the framework consumes the string set in the setter on a different thread it looks like we may have a problem", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1432#discussion_r457071161", "createdAt": "2020-07-20T05:43:27Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/trace/propagation/HttpTraceContext.java", "diffHunk": "@@ -98,7 +99,7 @@\n     spanContext.getSpanId().copyLowerBase16To(chars, SPAN_ID_OFFSET);\n     chars[TRACE_OPTION_OFFSET - 1] = TRACEPARENT_DELIMITER;\n     spanContext.getTraceFlags().copyLowerBase16To(chars, TRACE_OPTION_OFFSET);\n-    setter.set(carrier, TRACE_PARENT, new String(chars));\n+    setter.set(carrier, TRACE_PARENT, new String(chars, 0, TRACEPARENT_HEADER_SIZE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3781498d153724d38712a1b24cffe5e06faddb7c"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNjM2NTgx", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1432#pullrequestreview-451636581", "createdAt": "2020-07-20T14:03:51Z", "commit": {"oid": "3781498d153724d38712a1b24cffe5e06faddb7c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNjg5NzA3", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1432#pullrequestreview-451689707", "createdAt": "2020-07-20T14:59:13Z", "commit": {"oid": "3781498d153724d38712a1b24cffe5e06faddb7c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNzY3MTc2", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1432#pullrequestreview-451767176", "createdAt": "2020-07-20T16:26:37Z", "commit": {"oid": "3781498d153724d38712a1b24cffe5e06faddb7c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjoyNjozN1rOG0V7Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjoyNjozN1rOG0V7Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzODMzNA==", "bodyText": "I'm not in love with this name, but it's fine for now. :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1432#discussion_r457538334", "createdAt": "2020-07-20T16:26:37Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/internal/TemporaryBuffers.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.internal;\n+\n+/**\n+ * {@link ThreadLocal} buffers for use when creating new derived objects such as {@link String}s.\n+ * These buffers are reused within a single thread - it is _not safe_ to use the buffer to generate\n+ * multiple derived objects at the same time because the same memory will be used. In general, you\n+ * should get a temporary buffer, fill it with data, and finish by converting into the derived\n+ * object within the same method to avoid multiple usages of the same buffer.\n+ */\n+public final class TemporaryBuffers {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3781498d153724d38712a1b24cffe5e06faddb7c"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNzY3NjEw", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1432#pullrequestreview-451767610", "createdAt": "2020-07-20T16:27:09Z", "commit": {"oid": "3781498d153724d38712a1b24cffe5e06faddb7c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjoyNzowOVrOG0V8hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjoyNzowOVrOG0V8hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzODY5Mw==", "bodyText": "Any thoughts to an optional boolean to zero-out the buffer before handing it out?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1432#discussion_r457538693", "createdAt": "2020-07-20T16:27:09Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/internal/TemporaryBuffers.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.internal;\n+\n+/**\n+ * {@link ThreadLocal} buffers for use when creating new derived objects such as {@link String}s.\n+ * These buffers are reused within a single thread - it is _not safe_ to use the buffer to generate\n+ * multiple derived objects at the same time because the same memory will be used. In general, you\n+ * should get a temporary buffer, fill it with data, and finish by converting into the derived\n+ * object within the same method to avoid multiple usages of the same buffer.\n+ */\n+public final class TemporaryBuffers {\n+\n+  private static final ThreadLocal<char[]> CHAR_ARRAY = new ThreadLocal<>();\n+\n+  /**\n+   * A {@link ThreadLocal} {@code char[]} of size {@code len}. Take care when using a large value of\n+   * {@code len} as this buffer will remain for the lifetime of the thread. The returned buffer will\n+   * not be zeroed and may be larger than the requested size, you must make sure to fill the entire\n+   * content to the desired value and set the length explicitly when converting to a {@link String}.\n+   */\n+  public static char[] chars(int len) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3781498d153724d38712a1b24cffe5e06faddb7c"}, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2580, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}