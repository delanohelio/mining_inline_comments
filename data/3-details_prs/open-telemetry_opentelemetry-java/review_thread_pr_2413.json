{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ2MTgzNTAy", "number": 2413, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMlQwMjowODoyNVrOFKh3Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMlQwMjowODoyNVrOFKh3Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ2NTg0ODM0OnYy", "diffSide": "RIGHT", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/aggregation/DoubleLastValueAggregation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMlQwMjowODoyNVrOINUG_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wMlQxODo1NTo0NVrOINY4Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgzMTg3MA==", "bodyText": "this could be replaced with a single default:", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2413#discussion_r550831870", "createdAt": "2021-01-02T02:08:25Z", "author": {"login": "jkwatson"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/aggregation/DoubleLastValueAggregation.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.metrics.aggregation;\n+\n+import io.opentelemetry.api.common.Labels;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.accumulation.DoubleAccumulation;\n+import io.opentelemetry.sdk.metrics.aggregator.Aggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.DoubleLastValueAggregator;\n+import io.opentelemetry.sdk.metrics.common.InstrumentDescriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.concurrent.Immutable;\n+\n+@Immutable\n+final class DoubleLastValueAggregation extends AbstractAggregation<DoubleAccumulation> {\n+  static final DoubleLastValueAggregation INSTANCE =\n+      new DoubleLastValueAggregation(DoubleLastValueAggregator.getInstance());\n+\n+  private DoubleLastValueAggregation(Aggregator<DoubleAccumulation> aggregator) {\n+    super(aggregator);\n+  }\n+\n+  @Override\n+  public DoubleAccumulation merge(DoubleAccumulation a1, DoubleAccumulation a2) {\n+    // TODO: Define the order between accumulation.\n+    return a2;\n+  }\n+\n+  @Override\n+  public MetricData toMetricData(\n+      Resource resource,\n+      InstrumentationLibraryInfo instrumentationLibraryInfo,\n+      InstrumentDescriptor descriptor,\n+      Map<Labels, DoubleAccumulation> accumulationByLabels,\n+      long startEpochNanos,\n+      long epochNanos) {\n+    List<MetricData.DoublePoint> points =\n+        MetricDataUtils.toDoublePointList(accumulationByLabels, startEpochNanos, epochNanos);\n+\n+    switch (descriptor.getType()) {\n+      case SUM_OBSERVER:\n+        return MetricDataUtils.toDoubleSumMetricData(\n+            resource, instrumentationLibraryInfo, descriptor, points, /* isMonotonic= */ true);\n+      case UP_DOWN_SUM_OBSERVER:\n+        return MetricDataUtils.toDoubleSumMetricData(\n+            resource, instrumentationLibraryInfo, descriptor, points, /* isMonotonic= */ false);\n+      case VALUE_OBSERVER:\n+        return MetricData.createDoubleGauge(\n+            resource,\n+            instrumentationLibraryInfo,\n+            descriptor.getName(),\n+            descriptor.getDescription(),\n+            descriptor.getUnit(),\n+            MetricData.DoubleGaugeData.create(points));\n+      case COUNTER:\n+      case UP_DOWN_COUNTER:\n+      case VALUE_RECORDER:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db5bfd4917bb99667d7b104c3d0246ea661e32dc"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDkwOTk3NA==", "bodyText": "I tend to not do that so when we add a new option it forces me to update all switch statements and think about the implications, if I add default errorprone will not complain when adding a new value", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2413#discussion_r550909974", "createdAt": "2021-01-02T18:55:45Z", "author": {"login": "bogdandrutu"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/aggregation/DoubleLastValueAggregation.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.sdk.metrics.aggregation;\n+\n+import io.opentelemetry.api.common.Labels;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.accumulation.DoubleAccumulation;\n+import io.opentelemetry.sdk.metrics.aggregator.Aggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.DoubleLastValueAggregator;\n+import io.opentelemetry.sdk.metrics.common.InstrumentDescriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.concurrent.Immutable;\n+\n+@Immutable\n+final class DoubleLastValueAggregation extends AbstractAggregation<DoubleAccumulation> {\n+  static final DoubleLastValueAggregation INSTANCE =\n+      new DoubleLastValueAggregation(DoubleLastValueAggregator.getInstance());\n+\n+  private DoubleLastValueAggregation(Aggregator<DoubleAccumulation> aggregator) {\n+    super(aggregator);\n+  }\n+\n+  @Override\n+  public DoubleAccumulation merge(DoubleAccumulation a1, DoubleAccumulation a2) {\n+    // TODO: Define the order between accumulation.\n+    return a2;\n+  }\n+\n+  @Override\n+  public MetricData toMetricData(\n+      Resource resource,\n+      InstrumentationLibraryInfo instrumentationLibraryInfo,\n+      InstrumentDescriptor descriptor,\n+      Map<Labels, DoubleAccumulation> accumulationByLabels,\n+      long startEpochNanos,\n+      long epochNanos) {\n+    List<MetricData.DoublePoint> points =\n+        MetricDataUtils.toDoublePointList(accumulationByLabels, startEpochNanos, epochNanos);\n+\n+    switch (descriptor.getType()) {\n+      case SUM_OBSERVER:\n+        return MetricDataUtils.toDoubleSumMetricData(\n+            resource, instrumentationLibraryInfo, descriptor, points, /* isMonotonic= */ true);\n+      case UP_DOWN_SUM_OBSERVER:\n+        return MetricDataUtils.toDoubleSumMetricData(\n+            resource, instrumentationLibraryInfo, descriptor, points, /* isMonotonic= */ false);\n+      case VALUE_OBSERVER:\n+        return MetricData.createDoubleGauge(\n+            resource,\n+            instrumentationLibraryInfo,\n+            descriptor.getName(),\n+            descriptor.getDescription(),\n+            descriptor.getUnit(),\n+            MetricData.DoubleGaugeData.create(points));\n+      case COUNTER:\n+      case UP_DOWN_COUNTER:\n+      case VALUE_RECORDER:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDgzMTg3MA=="}, "originalCommit": {"oid": "db5bfd4917bb99667d7b104c3d0246ea661e32dc"}, "originalPosition": 63}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1642, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}