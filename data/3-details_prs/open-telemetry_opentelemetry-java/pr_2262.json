{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM1Njk1MjU5", "number": 2262, "title": "Add a doc outlining possible approach to SDK configuration.", "bodyText": "@jkwatson asked me to make a proposal of SDK configuration, and I've tried to outline goals and approaches here. This might not be the best approach, but it keeps these principles in mind\n\nKeep the end-user API as simple as possible\nIt's ok to push some complexity downstream for less-common use cases like dynamic config, partial SDKs\nIt's ok to expect more domain knowledge from authors of SDK components / extensions than of end users\nKeep core lightweight and let external configuration mechanisms take on the brunt of configuration\n\nPerhaps these principles aren't good principles :) But this can hopefully give something to talk about.", "createdAt": "2020-12-10T06:31:19Z", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262", "merged": true, "mergeCommit": {"oid": "3fc313a94dfca7ed7145b150ff0683717df2b644"}, "closed": true, "closedAt": "2020-12-22T00:34:55Z", "author": {"login": "anuraaga"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdktXY3gH2gAyNTM1Njk1MjU5OjU3MzMxNmQwM2Q0NGNiZTJiZTBhODJjN2FkNWU0YjhkZjA0YjY0NTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdnJx8pgFqTU1NDk3Mjk1Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/573316d03d44cbe2be0a82c7ad5e4b8df04b6458", "committedDate": "2020-12-10T06:29:47Z", "message": "Add a doc outlining possible approach to SDK configuration."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4ODkwNDg3", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#pullrequestreview-548890487", "createdAt": "2020-12-10T06:35:46Z", "commit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNjozNTo0NlrOIC4mhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNjozNTo0NlrOIC4mhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTg5NTQyOQ==", "bodyText": "At least in Brave", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539895429", "createdAt": "2020-12-10T06:35:46Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 270}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4OTEwMDM0", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#pullrequestreview-548910034", "createdAt": "2020-12-10T07:18:50Z", "commit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzoxODo1MFrOIC6xkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzo0MDozNVrOIC7cTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzMTAyNw==", "bodyText": "s/cafe/care?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539931027", "createdAt": "2020-12-10T07:18:50Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzMjU4Nw==", "bodyText": "How can I set https://github.com/open-telemetry/opentelemetry-java/tree/master/sdk-extensions/async-processor to be used instead of the normal batch span processor?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539932587", "createdAt": "2020-12-10T07:21:13Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzMzM2Mw==", "bodyText": "s/tracerProvider/meterProvider?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539933363", "createdAt": "2020-12-10T07:22:44Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzNDI3OA==", "bodyText": "I would encourage passing Otel instance always. So if we add more functionality to the otel instance we don't break the API.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539934278", "createdAt": "2020-12-10T07:24:44Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzNDU5Ng==", "bodyText": "So there is no world outside Spring? :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539934596", "createdAt": "2020-12-10T07:25:27Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTg5NTQyOQ=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 270}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzNTU2Mw==", "bodyText": "I think this is a very unexpected behavior....", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539935563", "createdAt": "2020-12-10T07:27:23Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzNzMwNg==", "bodyText": "What if someone is very strict and want to actually use a different sdk instance + pipeline to monitor the main monitoring sdk?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539937306", "createdAt": "2020-12-10T07:31:11Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 323}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzODM2MQ==", "bodyText": "So if I am not using Spring I am not a \"framework\" author? :)\nI would rewrite with something like:\nWhen using a framework that supports dependency injection and lazy initialization ....", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539938361", "createdAt": "2020-12-10T07:33:14Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 328}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzOTEzMA==", "bodyText": "If TraceConfig is not \"immutable\" you have hard time and undefined behaviors. What does it happen if we decide to call sampler twice and gets changed between the calls? Or any other property that we use?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539939130", "createdAt": "2020-12-10T07:34:56Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 375}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0MDU3NQ==", "bodyText": "Who is the author of this line? Only one person should configure or control the SDK config. Any random \"service\" running in an application service should be able to affect only their instance of SDK if any, otherwise should not be able to control the config.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539940575", "createdAt": "2020-12-10T07:37:40Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0MTk2Nw==", "bodyText": "By making immutable we can guarantee that one config is applied for the entire lifetime of one span, and you cannot do this with a mutable config.\nYou may say that you add a \"Factory\" that returns an immutable TraceConfig, that is a lot of unnecessary allocations (you may cache the result). But if there is a factory why someone cannot do the same thing and update the Factory?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539941967", "createdAt": "2020-12-10T07:40:35Z", "author": {"login": "bogdandrutu"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzOTEzMA=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 375}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4OTI1OTAy", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#pullrequestreview-548925902", "createdAt": "2020-12-10T07:47:17Z", "commit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwNzo0NzoxN1rOIC7pnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwODowMTo1MlrOIC8I5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0NTM3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n          \n          \n            \n            inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539945372", "createdAt": "2020-12-10T07:47:17Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0NTQ4Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n          \n          \n            \n              public MeterProvider meterProvider(OpenTelemetry openTelemetry) {", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539945483", "createdAt": "2020-12-10T07:47:31Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0NTkxNA==", "bodyText": "I'm not sure what difference it makes for this example - the reason I pass both is just illustrative, but it may be more common to only have one of them. If you need tracing, just depend on TracerProvider - though nothing would prevent OpenTelemetry either and this is mostly up to what the framework author wants to present here.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539945914", "createdAt": "2020-12-10T07:48:20Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzNDI3OA=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0NjIxMg==", "bodyText": "I mention Brave since I have the most experience with it. I would expect OT and OC to have come to similar conclusion but I don't know. But no Spring involved here.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539946212", "createdAt": "2020-12-10T07:48:59Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTg5NTQyOQ=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 270}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0NjUzMQ==", "bodyText": "This is an example of how we might do it more automatically. But we could just leave it to being wired manually, and then it could be wired to any SDK.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539946531", "createdAt": "2020-12-10T07:49:38Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzNzMwNg=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 323}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0NzM0MA==", "bodyText": "I didn't use the word Spring here - I use Spring in my examples expecting it to be most familiar to readers, for me Dagger would have been easier to write. It's just replacing @Component -> @Module, @Bean -> @Provides though, Lazy happens to be the same.\nI don't see much wrong with claiming that most frameworks use dependency injection in Java since they do.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539947340", "createdAt": "2020-12-10T07:51:09Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzODM2MQ=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 328}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0OTgwMg==", "bodyText": "Yeah makes sense - a factory seems reasonable though, mental model could actually be more clear, a factory of trace configs for spans, not a global thing that's always referenced. For static config, it'll just return itself, for dynamic, caching in a volatile until changed again seems like a very common approach.\nIf the factory is initialized when building the SDK, the implementation could be private to the framework. I think it does make it very hard to do a strange update of the SDK (would have to just ignore the framework-provided SDK completely).", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539949802", "createdAt": "2020-12-10T07:55:37Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzOTEzMA=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 375}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk1MTI2Mw==", "bodyText": "Yeah - it's demonstrating something very buggy, but it's to illustrate that I think having mutation APIs does open this sort of thing up, giving up control from the framework author. Though for use cases that are common for raw-SDK users, we could also add extensions with e.g., dynamic trace config providers.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539951263", "createdAt": "2020-12-10T07:58:08Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk0MDU3NQ=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk1MzM4Mg==", "bodyText": "It could also be reasonable to leave this up to frameworks - but it will almost always be required.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539953382", "createdAt": "2020-12-10T08:01:52Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzNTU2Mw=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 262}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/c60b399bbac5d863c1517a1c50d98279e1d7cffb", "committedDate": "2020-12-10T08:05:16Z", "message": "Apply suggestions from code review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4OTc2MDI4", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#pullrequestreview-548976028", "createdAt": "2020-12-10T08:59:09Z", "commit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwODo1OTowOVrOIC-S-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOToyNzowOFrOIC_fGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4ODczMA==", "bodyText": "Do we want to have default exporter?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539988730", "createdAt": "2020-12-10T08:59:09Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4OTEyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - Exports spans using OTLP to spans-service\n          \n          \n            \n            - Exports spans using OTLP to `spans-service`", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539989122", "createdAt": "2020-12-10T08:59:35Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk4OTcwMQ==", "bodyText": "What about propagation?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539989701", "createdAt": "2020-12-10T09:00:27Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5MDIxMw==", "bodyText": "batching becomes the property of exporters?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539990213", "createdAt": "2020-12-10T09:01:12Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5MDU2Nw==", "bodyText": "I like this", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539990567", "createdAt": "2020-12-10T09:01:43Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5MTUzNA==", "bodyText": "How do you plan to chain SpanProcessor.end() calls?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539991534", "createdAt": "2020-12-10T09:03:14Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5MzAyNw==", "bodyText": "I think we bundle two types here: authors of custom exporters/samplers and frameworks authors. The latter will handle configuration, but the former will just write a component according to an interface.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539993027", "createdAt": "2020-12-10T09:05:24Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5NTA3Mw==", "bodyText": "I agree with this section, but not with \"easy-to-reason lifecycle\". Shared instance kept in a field will break if somebody somewhere calls shutdown on the same shared instance.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539995073", "createdAt": "2020-12-10T09:08:23Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5NjI2MQ==", "bodyText": "I agree with Bogdan. Let it be explicit.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539996261", "createdAt": "2020-12-10T09:10:07Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzNTU2Mw=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTk5ODE1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            See special note with Java Agent below though.\n          \n          \n            \n            See special note about Java Agent below though.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r539998151", "createdAt": "2020-12-10T09:13:01Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAwMDE0MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n          \n          \n            \n                tracer = openTelemetry.getTracerProvider().get(\"spanexporter\");", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540000140", "createdAt": "2020-12-10T09:15:56Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAwMjgwNQ==", "bodyText": "How are we going to support dynamic Samplers?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540002805", "createdAt": "2020-12-10T09:19:41Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes cafe of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzOTEzMA=="}, "originalCommit": {"oid": "573316d03d44cbe2be0a82c7ad5e4b8df04b6458"}, "originalPosition": 375}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAwMzMwNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The above presents programmatic configuration for the SDK and proposeds that the core SDK has no\n          \n          \n            \n            The above presents programmatic configuration for the SDK and proposes that the core SDK has no", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540003305", "createdAt": "2020-12-10T09:20:23Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+\n+## Auto-configuration\n+\n+The above presents programmatic configuration for the SDK and proposeds that the core SDK has no", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 399}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAwNDYxNg==", "bodyText": "Wait :) I understand your purpose and mostly support it, but configuration from environment is useful. If core SDK does not support (which is fine), we may need an example of how one can achieve it.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540004616", "createdAt": "2020-12-10T09:22:05Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+\n+## Auto-configuration\n+\n+The above presents programmatic configuration for the SDK and proposeds that the core SDK has no\n+other mechanism for configuration. There is no SPI nor processing of environment variables or", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 400}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAwODIxOA==", "bodyText": "I got very confused by this section. It seems like configuration duplication. What if I by mistake do both OpenTelemetrySdk.builder().xxxxx as above and DefaultOpenTelemetry.builder().xxxx as below?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540008218", "createdAt": "2020-12-10T09:27:08Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+\n+## Auto-configuration\n+\n+The above presents programmatic configuration for the SDK and proposeds that the core SDK has no\n+other mechanism for configuration. There is no SPI nor processing of environment variables or\n+system properties. There are many mechanisms for configuration, for example Spring Boot. \n+Integration with these systems becomes easier to reason about if we consider auto-configuration at\n+a layer above the core SDK.\n+\n+### Java Auto-Instrumentation Agent\n+\n+Java Auto-Instrumentation Agent is the primary means of automatically configuring the SDK. It\n+contains system properties, environment variables, and SPIs for allowing a user to have a fully\n+setup tracing configuration just by applying the agent. In fact, the agent does not even allow a\n+user to use the SDK directly, actively blocking it. Instead of having a situation where some\n+configuration is automatic in the core SDK and some in the agent, we can move it all to the agent.\n+The agent already exposes exporter SPIs - it can also expose SPIs for customization of the SDK\n+components that are manually configured above.\n+\n+- We could consider having a very similar autoconfiguration wrapper artifact as an SDK extension too.\n+But we would assume the core SDK is always manually configured.\n+\n+To allow users of the agent to apply tracing to their own code, the agent should attempt to\n+instrument dependency injection to provide an instance of `OpenTelemetry` using the agent-configured\n+SDK, for example it should add it to the Spring `ApplicationContext`. For cases where dependency\n+injection is not available, though, there is no option but to provide access to the SDK through a\n+global variable. We can expect such usage to still function correctly even if the agent is removed\n+and a different configuration mechanism is used, such as manual configuration as above, or Spring\n+Sleuth.\n+\n+### Spring Sleuth\n+\n+[Spring Sleuth](https://spring.io/projects/spring-cloud-sleuth) (or any similar observability-aware server framework such as \n+[curio-server-framework](https://github.com/curioswitch/curiostack/blob/master/common/server/framework/src/main/java/org/curioswitch/common/server/framework/monitoring/MonitoringModule.java)\n+or internal frameworks developed by devops teams at companies) is also a mechanism for automatically\n+configuring the SDK. In general, we would expect Sleuth users to not be using the java agent.\n+\n+Examples of how Sleuth could work are presented above in examples using `@Bean`. In particular, we\n+expect it to have its own set of configuration properties - by making sure we don't implement\n+configuration properties in the core SDK, only configuration layers like the agent or a possible\n+configuration wrapper, we avoid the possibility of confusion by having duplicate variables (in\n+practice, OpenTelemetry naming would likely be ignored and overwritten by Spring naming).\n+\n+## Partial SDKs", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 439}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NTA0OTQ1", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#pullrequestreview-549504945", "createdAt": "2020-12-10T18:53:06Z", "commit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1MzowNlrOIDYX-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1MzowNlrOIDYX-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxNTk5Mw==", "bodyText": "this is an excellent call-out, and something we all definitely need to keep in mind. Sometimes this will mean we add \"more than one way to do things\" because it will make app developers lives easier, even if it makes our jobs as maintainers more annoying/painful.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540415993", "createdAt": "2020-12-10T18:53:06Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NTA2MzA3", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#pullrequestreview-549506307", "createdAt": "2020-12-10T18:54:50Z", "commit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1NDo1MVrOIDYcbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1NDo1MVrOIDYcbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxNzEzNA==", "bodyText": "is performance at configuration time really much of an issue and something we should worry about?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540417134", "createdAt": "2020-12-10T18:54:51Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NTA2Njcw", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#pullrequestreview-549506670", "createdAt": "2020-12-10T18:55:21Z", "commit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1NToyMVrOIDYdkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1NToyMVrOIDYdkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxNzQyNQ==", "bodyText": "is this a \"single entrypoint\" per use-case, or only a single entrypoint, period?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540417425", "createdAt": "2020-12-10T18:55:21Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NTA5ODA0", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#pullrequestreview-549509804", "createdAt": "2020-12-10T18:59:14Z", "commit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1OToxNFrOIDYndw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1OToxNFrOIDYndw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQxOTk1OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The SDK consists of configuration options for all the signals it supports. Users all have different\n          \n          \n            \n            The SDK exposes configuration options for all the signals it supports. Users all have different", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540419959", "createdAt": "2020-12-10T18:59:14Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NTEwMDYx", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#pullrequestreview-549510061", "createdAt": "2020-12-10T18:59:34Z", "commit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1OTozNFrOIDYoVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODo1OTozNFrOIDYoVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQyMDE4Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            requirements for how they use the SDK, for example they may use different exporters depending on\n          \n          \n            \n            requirements for how they use the SDK; for example they may use different exporters depending on", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540420182", "createdAt": "2020-12-10T18:59:34Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 55}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NTI3MTk4", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#pullrequestreview-549527198", "createdAt": "2020-12-10T19:22:21Z", "commit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxOToyMjoyMVrOIDZfkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxOToyMjoyMVrOIDZfkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQzNDMyMg==", "bodyText": "This example mixes two signals, which is good. The question is: are we likely to end up with an unwieldy builder if it contains the configuration for multiple signals, especially when we (eventually) add logs in here as well.\nWould we be better off (as I think Bogdan has suggested) requiring the SDK components for each signal to be configured indivually, then have the OpenTelemetrySdk builder only compose the other components? I can see pros and cons.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540434322", "createdAt": "2020-12-10T19:22:21Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 75}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NTQyMDQx", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#pullrequestreview-549542041", "createdAt": "2020-12-10T19:42:15Z", "commit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxOTo0MjoxNVrOIDaQnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxOTo0MjoxNVrOIDaQnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ0Njg3Ng==", "bodyText": "Here is a sticking point that I see with the omnibus build-everything-at-the-OpenTelemetrySdk-level: For 1.0, we need to remove metrics from the OpenTelemetrySdk, which will mean that we must provide a way to build the pre-release MeterSdkProvider in a stand-alone manner. And, there may (probably will) be people who only want to use one of the signals, without the omnibus OpenTelemetrySdk, so we'll need to provide individual builders for each of the signals.\nIf we need to provide individual builders for each SDK signal, then are we ok with having both ways of building things? If so, then \ud83d\udc4d . This does seem to be a case where we should favor the end-user and make sure that they can do it either way.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540446876", "createdAt": "2020-12-10T19:42:15Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 184}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NjgyMzg0", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#pullrequestreview-549682384", "createdAt": "2020-12-10T23:04:48Z", "commit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzowNDo0OFrOIDhgmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzowNDo0OFrOIDhgmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2NTY1OA==", "bodyText": "obviously would need a null check here for the tracer, but that's a nit, obviously", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540565658", "createdAt": "2020-12-10T23:04:48Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 304}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NjkwNzE3", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#pullrequestreview-549690717", "createdAt": "2020-12-10T23:22:49Z", "commit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzoyMjo0OVrOIDiB_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMzoyMjo0OVrOIDiB_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3NDIwNA==", "bodyText": "this is definitely something I hadn't pondered. This wouldn't work with pre-release signals, though, unless the pre-release metrics SDK (for instance) also provided an extension to the OpenTelemetry interface, too. \ud83e\udd14", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540574204", "createdAt": "2020-12-10T23:22:49Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,492 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK consists of configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK, for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .build())\n+  .addMetricExposition(PrometheusExposition.getDefault())\n+  .build();\n+```\n+\n+This\n+\n+- Exports spans using OTLP to spans-service\n+  - Uses the BatchSpanProcessor (or a batching exporter wraper) which we consider the best default \n+  for exporting. It has defaults for queue size, timeout, etc\n+- Exposes metrics using Prometheus format\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+  .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+  .setClock(AtomicClock.create())\n+  .setPropagators(B3Propagator.getInstance())\n+  .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .setTimeout(Duration.ofSeconds(10))\n+    .setBatchQueueSize(10000)\n+    .build())\n+  .addSpanExporter(ZipkinExporter.builder()\n+    .setEndpoint(\"spans-service:4317\")\n+    .disableBatching()\n+    .build())\n+  .addSpanExporter(FullyAsyncZipkinExporter.create())\n+  .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+  .addSpanProcessor(CustomEventAddingProcessor.create())\n+  .setTraceSampler(Sampler.rateLimiting())\n+  .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+  .setIdGenerator(TimestampedIdGenerator.create())\n+  .setMeterStuff(InProgressMetricsStuff.create())\n+  .build()\n+```\n+\n+This configures resource, clock, exporters, span processors, sampler, trace limits, and metrics.\n+Everything is exposed on the `OpenTelemetrySdkBuilder` to provide discoverability of all the parts\n+of the SDK and to let the SDK manage shared components - it is not possible to configure a different\n+`Resource` for tracing and metrics, something that would be a gotcha. Exporters are handled natively\n+given they are so important - even though the exporters are specified before span processors, they\n+will always be executed last to make sure all span processors appy to them. The exporter builders\n+inherit from a `ExporterBuilder` type of abstract class - it takes care of batching configuration to\n+avoid having to understand separate concepts like `BatchSpanProcessor`. Exporters that don't support\n+batching at all, like the custom `FullyAsyncZipkinExporter` don't have to. Note this can be\n+similarly achieved by having wrappers like `BatchExporter.wrap(OtlpGrpcSpanExporter.builder()...`\n+as well and is presented as one option.\n+\n+Note that parts can be separated to separate subconfig classes if it seems to make the API easier to\n+use. We would want to avoid duplication though, e.g., having two configurations that expect a\n+`Resource`.\n+\n+One thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+  \n+  @Bean\n+  public OpenTelemetry openTelemetry(MonitoringConfig config) {\n+    OpenTelemetrySdk.builder()\n+      .setResource(Resource.getDefault().merge(CoolResource.getDefault()))\n+      .setClock(AtomicClock.create())\n+      .setPropagators(B3Propagator.getInstance())\n+      .addSpanExporter(OtlpGrpcSpanExporter.builder()\n+        .setEndpoint(config.getOtlpExporter().getEndpoint())\n+        .setTimeout(config.getOtlpExporter().getTimeout())\n+        .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+        .build())\n+      .addSpanExporter(ZipkinExporter.builder()\n+        .setEndpoint(config.getZipkinExporter().getEndpoint())\n+        .disableBatching()\n+        .build())\n+      .addSpanExporter(FullyAsyncZipkinExporter.create())\n+      .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+      .addSpanProcessor(CustomEventAddingProcessor.create())\n+      .setTraceSampler(config.getSamplingRate() != 0 \n+          ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+      .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+      .setIdGenerator(TimestampedIdGenerator.create())\n+      .setMeterStuff(InProgressMetricsStuff.create())\n+      .build();\n+  }\n+  \n+  @Bean\n+  public TracerProvider tracerProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getTracerProvider();\n+  }\n+  \n+  @Bean\n+  public MeterProvider meterProvider(OpenTelemetry openTelemetry) {\n+    return openTelemetry.getMeterProvider();\n+  }\n+  \n+  @Bean\n+  public AuthServiceStub authService(OpenTelemetry openTelemetry, AuthConfig config) {\n+    return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+      .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+  }\n+  \n+  @Bean\n+  public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+    return TracingServletFilter.create(openTelemetry);\n+  }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason lifecycle, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. To reduce gotchas for application developers, the first SDK that is instantiated is stored\n+automatically in the global variable.\n+\n+Before an SDK has been set, access to the global SDK will throw an exception and will not return a\n+default. The global can only be used after an SDK has been configured. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note with Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+    traer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.spanBuilder(\"export\").startSpan();\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+    tracerProvider.addSpanExporter(exporter);\n+    components.add(exporter);\n+  }\n+\n+  public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+    tracerProvider.setSampler(sampler);\n+    components.add(sampler);\n+  }\n+\n+  public OpenTelemetry build() {\n+    OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+    for (OpenTelemetryComponent component : components) {\n+      component.setOpenTelemetry(sdk);\n+    }\n+  }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+  @Bean\n+  @ForSpanExporter\n+  public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+  }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+  private Lazy<Tracer> tracer;\n+  \n+  @Inject\n+  public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+  }\n+  \n+  @Override\n+  public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+  }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+\n+## Auto-configuration\n+\n+The above presents programmatic configuration for the SDK and proposeds that the core SDK has no\n+other mechanism for configuration. There is no SPI nor processing of environment variables or\n+system properties. There are many mechanisms for configuration, for example Spring Boot. \n+Integration with these systems becomes easier to reason about if we consider auto-configuration at\n+a layer above the core SDK.\n+\n+### Java Auto-Instrumentation Agent\n+\n+Java Auto-Instrumentation Agent is the primary means of automatically configuring the SDK. It\n+contains system properties, environment variables, and SPIs for allowing a user to have a fully\n+setup tracing configuration just by applying the agent. In fact, the agent does not even allow a\n+user to use the SDK directly, actively blocking it. Instead of having a situation where some\n+configuration is automatic in the core SDK and some in the agent, we can move it all to the agent.\n+The agent already exposes exporter SPIs - it can also expose SPIs for customization of the SDK\n+components that are manually configured above.\n+\n+- We could consider having a very similar autoconfiguration wrapper artifact as an SDK extension too.\n+But we would assume the core SDK is always manually configured.\n+\n+To allow users of the agent to apply tracing to their own code, the agent should attempt to\n+instrument dependency injection to provide an instance of `OpenTelemetry` using the agent-configured\n+SDK, for example it should add it to the Spring `ApplicationContext`. For cases where dependency\n+injection is not available, though, there is no option but to provide access to the SDK through a\n+global variable. We can expect such usage to still function correctly even if the agent is removed\n+and a different configuration mechanism is used, such as manual configuration as above, or Spring\n+Sleuth.\n+\n+### Spring Sleuth\n+\n+[Spring Sleuth](https://spring.io/projects/spring-cloud-sleuth) (or any similar observability-aware server framework such as \n+[curio-server-framework](https://github.com/curioswitch/curiostack/blob/master/common/server/framework/src/main/java/org/curioswitch/common/server/framework/monitoring/MonitoringModule.java)\n+or internal frameworks developed by devops teams at companies) is also a mechanism for automatically\n+configuring the SDK. In general, we would expect Sleuth users to not be using the java agent.\n+\n+Examples of how Sleuth could work are presented above in examples using `@Bean`. In particular, we\n+expect it to have its own set of configuration properties - by making sure we don't implement\n+configuration properties in the core SDK, only configuration layers like the agent or a possible\n+configuration wrapper, we avoid the possibility of confusion by having duplicate variables (in\n+practice, OpenTelemetry naming would likely be ignored and overwritten by Spring naming).\n+\n+## Partial SDKs\n+\n+We allow implementing particular signals of the OpenTelemetry API without using our SDK. For example,\n+a MeterProvider may be implemented with micrometer. For this reason, each signal must also present\n+all of its options in the form of, e.g., `TracerSdkProviderBuilder`. We expect the vast majority of\n+users to use `OpenTelemetrySdkBuilder` - while there is some duplication with the signal provider\n+builder, it is work maintainers can do to present the simplest interface for the most common use\n+case of using the whole SDK.\n+\n+Without SPI, the way to initialize a partial SDK would be to use `DefaultOpenTelemetry`.\n+\n+```java\n+@Bean\n+public OpenTelemetry openTelemetry() {\n+  return DefaultOpenTelemetry.builder()\n+    .setTraceProvider(TracerSdkProvider.builder().build())\n+    .setMeterProvider(MicrometerProvider.builder().build())\n+    .build();\n+}\n+``` \n+\n+As this should be a fairly minor use case, and commonly handled by framework developers, this seems\n+reasonable. We can also hope that where it is important, it is the author of partial SDKs that\n+provide a one-stop-shop entrypoint.\n+\n+```java\n+@Bean\n+public OpenTelemetry openTelemetry() {\n+  return OpenTelemetrySdkWithMicrometer.builder()\n+    .addSpanExporter()\n+    .setMeterRegistry()\n+    .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c60b399bbac5d863c1517a1c50d98279e1d7cffb"}, "originalPosition": 470}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21ce475dab269a1430a29a9b203875e49e73c5f2", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/21ce475dab269a1430a29a9b203875e49e73c5f2", "committedDate": "2020-12-11T08:22:59Z", "message": "First some cleanups"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92d2066ca18247cb830b3a2db889fab25303aa0a", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/92d2066ca18247cb830b3a2db889fab25303aa0a", "committedDate": "2020-12-11T08:25:45Z", "message": "Merge branch 'configuration-doc' of github.com:anuraaga/opentelemetry-java into configuration-doc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea727428a7399cffcc58725ca07c6525823722b3", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/ea727428a7399cffcc58725ca07c6525823722b3", "committedDate": "2020-12-11T09:03:21Z", "message": "Revamp"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26e344b7711bab9ab03fd41a3170b70de81a436b", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/26e344b7711bab9ab03fd41a3170b70de81a436b", "committedDate": "2020-12-11T09:04:19Z", "message": "Global not magic"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTE5MDM0", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#pullrequestreview-549919034", "createdAt": "2020-12-11T09:10:59Z", "commit": {"oid": "26e344b7711bab9ab03fd41a3170b70de81a436b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwOToxMDo1OVrOIDvoXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwOToxMDo1OVrOIDvoXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5NzAyMg==", "bodyText": "Realized there's probably no point for this class, it could only help if it coordinates Resource sharing, etc.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r540797022", "createdAt": "2020-12-11T09:10:59Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,608 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26e344b7711bab9ab03fd41a3170b70de81a436b"}, "originalPosition": 79}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c408f33589c88208325090714a942aed6ed325a", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/8c408f33589c88208325090714a942aed6ed325a", "committedDate": "2020-12-12T04:31:36Z", "message": "Management, API-only, global"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNjg5MzU4", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#pullrequestreview-550689358", "createdAt": "2020-12-12T04:32:57Z", "commit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMlQwNDozMjo1N1rOIEadAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMlQwNDozNzowM1rOIEafWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ5ODYyNw==", "bodyText": "@jkwatson I had removed the auto-set as global due to controversy, but do think it's the best option in most cases. If the problem is mystery and surprise, then this naming, while obtuse, can make it clear. I would not have a normal build() method as that would reduce the discoverability of this mechanism - it has to be buildWithoutSetting or something similar to make sure a user makes a conscious decision without just assuming to use build().", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541498627", "createdAt": "2020-12-12T04:32:57Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ5OTA5Mw==", "bodyText": "@jkwatson I realized it could make sense to remove shutdown from the TracerSdkProvider. It seems like it could make some lifecycle woes simpler to reason about, maybe even enable toBuilder()?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541499093", "createdAt": "2020-12-12T04:36:22Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.\n+An alternative is to flatten all settings onto `OpenTelemetrySdkBuilder` - this has a downside that\n+it makes it very natural to create new tracer / meter providers for each configuration of the SDK,\n+which could result in a lot of duplication of resources like threads, workers, TCP connections. So\n+instead, this can make it clearer that those signals themselves are full-featured, and \n+`OpenTelemetry` is just a bag of signals.\n+\n+Keep in mind, reconfiguring `Clock` is expected to be an extremely uncommon operation.\n+\n+Another thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+    @Bean\n+    public Resource resource() {\n+        return Resource.getDefault().merge(CoolResource.getDefault());\n+    }\n+    \n+    @Bean\n+    public Clock otelClock() {\n+        return AtomicClock.create();\n+    }\n+\n+    @Bean\n+    public TracerSdkProvider tracerProvider(Resource resource, Clock clock, MonitoringConfig config) {\n+        return TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(config.getOtlpExporter().getEndpoint())\n+                    .setTimeout(config.getOtlpExporter().getTimeout())\n+                    .build())\n+                .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+                .setTimeout(config.getOtlpExporter().getTimeout())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(config.getZipkinExporter().getEndpoint())\n+                    .build())\n+                .build())\n+            .setTraceSampler(config.getSamplingRate() != 0 \n+               ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+    }\n+  \n+    @Bean\n+    public MeterSdkProvider meterProvider(Resource resource, Clock clock) {\n+        return MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public IntervalMetricReader metricReader(MeterSdkProvider meterProvider) {\n+        return IntervalMetricReader.builder()\n+            .addMetricProducer(meterProvider.getMetricProducer())\n+            .addMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public OpenTelemetry openTelemetry(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+           .addPropagator(B3Propagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+\n+    @Bean\n+    @ForJaeger\n+    public OpenTelemetry openTelemetryJaeger(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+  \n+    @Bean\n+    public AuthServiceStub authService(@ForJaeger OpenTelemetry openTelemetry, AuthConfig config) {\n+        return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+          .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+    }\n+    \n+    @Bean\n+    public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+        return TracingServletFilter.create(openTelemetry);\n+    }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason initialization ordering, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. It is expected that frameworks or end-users will set the SDK as the global to support\n+instrumentation that requires this.\n+\n+Before an SDK has been set, access to the global `OpenTelemetry` will return a no-op \n+`DefaultOpenTelemetry`. This is because it is possible library instrumentation is using the global,\n+and it may even use it during the processing of a request (rather than only at initialization time).\n+For this reason, we cannot throw an exception. Instead, if the SDK is detected on the classpath, we\n+will log a `SEVERE` warning once-only indicating the API has been accessed before the SDK configured\n+with directions on how a user could solve the problem. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note about Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+        tracer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+        Tracer tracer = this.tracer;\n+        if (tracer != null) {\n+          tracer.spanBuilder(\"export\").startSpan();\n+        }\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+    public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+        tracerProvider.addSpanExporter(exporter);\n+        components.add(exporter);\n+    }\n+    \n+    public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+        tracerProvider.setSampler(sampler);\n+        components.add(sampler);\n+    }\n+    \n+    public OpenTelemetry build() {\n+        OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+        for (OpenTelemetryComponent component : components) {\n+          component.setOpenTelemetry(sdk);\n+        }\n+    }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+    @Bean\n+    @ForSpanExporter\n+    public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+    }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+    private Lazy<Tracer> tracer;\n+    \n+    @Inject\n+    public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+    }\n+    \n+    @Override\n+    public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+    }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+## TracerSdkManagement\n+\n+With the proposal to make a configured SDK fully built rather than allowing configuration\n+mutability, the SDK management interface would only have `shutdown` and `forceFlush`. It seems\n+reasonable to actually remove `shutdown` from the `TracerSdkProvider` - the SDK provider is mostly\n+a bag of parts and has no intrinsic component, if instead components like `BatchSpanProcessor` and\n+`SpanExporter` implement `Closeable`, we can model shutdown as the responsibility of the creator of\n+the resources, which is idiomatic. In DI frameworks, this would generally be automatic. This would\n+prevent the case where two `TracerProvider` share an exporter and one of them is shutdown - when\n+shutting down the exporter, shut down the exporter.\n+\n+```java\n+public class MyApp {\n+ \n+    public static void main(String[] args) {\n+        try (OtlpGrpcSpanExporter otlpExporter = OtlpGrpcSpanExporter.builder().build();\n+              BatchSpanProcessor otlpProcessor = BatchSpanProcessor.builder(otlpExporter).build()) {\n+            OpenTelemetrySdk sdk = OpenTelemetrySdk.builder()\n+                .setTracerProvider(TracerSdkProvider.builder()\n+                                        .addSpanProcessor(otlpProcessor)\n+                                        .build())\n+                .build();\n+ \n+            Server server = Server.builder().setOpenTelemetry(sdk).build();\n+            server.listenAndServe();\n+        }\n+    }\n+\n+}\n+```\n+\n+```java\n+@Component\n+public class MyModule {\n+\n+    @Bean\n+    // If SpanExporter extends Closeable, it's automatically closed\n+    OtlpGrpcSpanExporter otlpExporter() {\n+        return OtlpGrpcSpanExporter.builder().build()\n+    }\n+   \n+    @Bean\n+    // If BatchSpanProcessor extends Closeable, it's automatically closed\n+    BatchSpanProcessor otlpSpanProcessor(OtlpGrpcSpanExporter otlpExporter) {\n+        return BatchSpanProcessor.builder(otlpExporter).build();\n+    }\n+ \n+    @Bean\n+    TracerSdkProvider tracerProvider(BatchSpanProcessor otlpSpanProcessor) {\n+        return TracerSdkProvider.builder().addSpanProcessor(otlpSpanProcessor).build();\n+    }\n+\n+    @Bean\n+    OpenTelemetrySdk openTelemetry(TracerSdkProvider tracerProvider) {\n+        return OpenTelemetrySdk.builder().setTracerProvider(tracerProvider).build();\n+    }\n+}\n+```\n+\n+The `OpenTelemetrySdk` and `TracerSdkProvider` are still exposed to provide access to `forceFlush`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 557}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTQ5OTIyNQ==", "bodyText": "@jkwatson API-only case", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541499225", "createdAt": "2020-12-12T04:37:03Z", "author": {"login": "anuraaga"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.\n+An alternative is to flatten all settings onto `OpenTelemetrySdkBuilder` - this has a downside that\n+it makes it very natural to create new tracer / meter providers for each configuration of the SDK,\n+which could result in a lot of duplication of resources like threads, workers, TCP connections. So\n+instead, this can make it clearer that those signals themselves are full-featured, and \n+`OpenTelemetry` is just a bag of signals.\n+\n+Keep in mind, reconfiguring `Clock` is expected to be an extremely uncommon operation.\n+\n+Another thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+    @Bean\n+    public Resource resource() {\n+        return Resource.getDefault().merge(CoolResource.getDefault());\n+    }\n+    \n+    @Bean\n+    public Clock otelClock() {\n+        return AtomicClock.create();\n+    }\n+\n+    @Bean\n+    public TracerSdkProvider tracerProvider(Resource resource, Clock clock, MonitoringConfig config) {\n+        return TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(config.getOtlpExporter().getEndpoint())\n+                    .setTimeout(config.getOtlpExporter().getTimeout())\n+                    .build())\n+                .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+                .setTimeout(config.getOtlpExporter().getTimeout())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(config.getZipkinExporter().getEndpoint())\n+                    .build())\n+                .build())\n+            .setTraceSampler(config.getSamplingRate() != 0 \n+               ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+    }\n+  \n+    @Bean\n+    public MeterSdkProvider meterProvider(Resource resource, Clock clock) {\n+        return MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public IntervalMetricReader metricReader(MeterSdkProvider meterProvider) {\n+        return IntervalMetricReader.builder()\n+            .addMetricProducer(meterProvider.getMetricProducer())\n+            .addMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public OpenTelemetry openTelemetry(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+           .addPropagator(B3Propagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+\n+    @Bean\n+    @ForJaeger\n+    public OpenTelemetry openTelemetryJaeger(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+  \n+    @Bean\n+    public AuthServiceStub authService(@ForJaeger OpenTelemetry openTelemetry, AuthConfig config) {\n+        return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+          .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+    }\n+    \n+    @Bean\n+    public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+        return TracingServletFilter.create(openTelemetry);\n+    }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason initialization ordering, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. It is expected that frameworks or end-users will set the SDK as the global to support\n+instrumentation that requires this.\n+\n+Before an SDK has been set, access to the global `OpenTelemetry` will return a no-op \n+`DefaultOpenTelemetry`. This is because it is possible library instrumentation is using the global,\n+and it may even use it during the processing of a request (rather than only at initialization time).\n+For this reason, we cannot throw an exception. Instead, if the SDK is detected on the classpath, we", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 363}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwODk2NzA2", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#pullrequestreview-550896706", "createdAt": "2020-12-13T08:29:58Z", "commit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QwODoyOTo1OFrOIExfjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QwOTowMDo1NlrOIExzdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3NjEwOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Verify familiar with telemetry.\n          \n          \n            \n            Very familiar with telemetry.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541876109", "createdAt": "2020-12-13T08:29:58Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3NjcxMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The SDK builder will simply allow accept its components as builder parameters. It only allows\n          \n          \n            \n            The SDK builder will simply accept its components as builder parameters. It only allows", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541876712", "createdAt": "2020-12-13T08:34:06Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3Njk5Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n          \n          \n            \n                      .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n          \n          \n            \n                          .setEndpoint(\"spans-service:4317\")\n          \n          \n            \n                          .build())\n          \n          \n            \n                      .build();\n          \n          \n            \n                    TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n          \n          \n            \n                      .addSpanProcessor(BatchSpanProcessor.builder(\n          \n          \n            \n                          OtlpGrpcSpanExporter.builder().setEndpoint(\"spans-service:4317\").build())\n          \n          \n            \n                        .build())\n          \n          \n            \n                      .build();", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541876992", "createdAt": "2020-12-13T08:36:02Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3NzM1Ng==", "bodyText": "You don't have OpenTelemetrySdkBuilder.build() method anymore", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541877356", "createdAt": "2020-12-13T08:38:14Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3NzM3NQ==", "bodyText": "You don't have OpenTelemetrySdkBuilder.build() method anymore", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541877375", "createdAt": "2020-12-13T08:38:23Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3NzUxOQ==", "bodyText": "I don't see a problem here.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541877519", "createdAt": "2020-12-13T08:39:20Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3OTU3NA==", "bodyText": "I am still somewhat confused by this section", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541879574", "createdAt": "2020-12-13T08:51:11Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.\n+An alternative is to flatten all settings onto `OpenTelemetrySdkBuilder` - this has a downside that\n+it makes it very natural to create new tracer / meter providers for each configuration of the SDK,\n+which could result in a lot of duplication of resources like threads, workers, TCP connections. So\n+instead, this can make it clearer that those signals themselves are full-featured, and \n+`OpenTelemetry` is just a bag of signals.\n+\n+Keep in mind, reconfiguring `Clock` is expected to be an extremely uncommon operation.\n+\n+Another thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+    @Bean\n+    public Resource resource() {\n+        return Resource.getDefault().merge(CoolResource.getDefault());\n+    }\n+    \n+    @Bean\n+    public Clock otelClock() {\n+        return AtomicClock.create();\n+    }\n+\n+    @Bean\n+    public TracerSdkProvider tracerProvider(Resource resource, Clock clock, MonitoringConfig config) {\n+        return TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(config.getOtlpExporter().getEndpoint())\n+                    .setTimeout(config.getOtlpExporter().getTimeout())\n+                    .build())\n+                .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+                .setTimeout(config.getOtlpExporter().getTimeout())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(config.getZipkinExporter().getEndpoint())\n+                    .build())\n+                .build())\n+            .setTraceSampler(config.getSamplingRate() != 0 \n+               ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+    }\n+  \n+    @Bean\n+    public MeterSdkProvider meterProvider(Resource resource, Clock clock) {\n+        return MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public IntervalMetricReader metricReader(MeterSdkProvider meterProvider) {\n+        return IntervalMetricReader.builder()\n+            .addMetricProducer(meterProvider.getMetricProducer())\n+            .addMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public OpenTelemetry openTelemetry(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+           .addPropagator(B3Propagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+\n+    @Bean\n+    @ForJaeger\n+    public OpenTelemetry openTelemetryJaeger(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+  \n+    @Bean\n+    public AuthServiceStub authService(@ForJaeger OpenTelemetry openTelemetry, AuthConfig config) {\n+        return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+          .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+    }\n+    \n+    @Bean\n+    public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+        return TracingServletFilter.create(openTelemetry);\n+    }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason initialization ordering, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. It is expected that frameworks or end-users will set the SDK as the global to support\n+instrumentation that requires this.\n+\n+Before an SDK has been set, access to the global `OpenTelemetry` will return a no-op \n+`DefaultOpenTelemetry`. This is because it is possible library instrumentation is using the global,\n+and it may even use it during the processing of a request (rather than only at initialization time).\n+For this reason, we cannot throw an exception. Instead, if the SDK is detected on the classpath, we\n+will log a `SEVERE` warning once-only indicating the API has been accessed before the SDK configured\n+with directions on how a user could solve the problem. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note about Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+        tracer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+        Tracer tracer = this.tracer;\n+        if (tracer != null) {\n+          tracer.spanBuilder(\"export\").startSpan();\n+        }\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+    public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+        tracerProvider.addSpanExporter(exporter);\n+        components.add(exporter);\n+    }\n+    \n+    public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+        tracerProvider.setSampler(sampler);\n+        components.add(sampler);\n+    }\n+    \n+    public OpenTelemetry build() {\n+        OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+        for (OpenTelemetryComponent component : components) {\n+          component.setOpenTelemetry(sdk);\n+        }\n+    }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+    @Bean\n+    @ForSpanExporter\n+    public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+    }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+    private Lazy<Tracer> tracer;\n+    \n+    @Inject\n+    public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+    }\n+    \n+    @Override\n+    public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+    }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 461}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3OTYwNA==", "bodyText": "I am still somewhat confused by this section", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541879604", "createdAt": "2020-12-13T08:51:20Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.\n+An alternative is to flatten all settings onto `OpenTelemetrySdkBuilder` - this has a downside that\n+it makes it very natural to create new tracer / meter providers for each configuration of the SDK,\n+which could result in a lot of duplication of resources like threads, workers, TCP connections. So\n+instead, this can make it clearer that those signals themselves are full-featured, and \n+`OpenTelemetry` is just a bag of signals.\n+\n+Keep in mind, reconfiguring `Clock` is expected to be an extremely uncommon operation.\n+\n+Another thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+    @Bean\n+    public Resource resource() {\n+        return Resource.getDefault().merge(CoolResource.getDefault());\n+    }\n+    \n+    @Bean\n+    public Clock otelClock() {\n+        return AtomicClock.create();\n+    }\n+\n+    @Bean\n+    public TracerSdkProvider tracerProvider(Resource resource, Clock clock, MonitoringConfig config) {\n+        return TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(config.getOtlpExporter().getEndpoint())\n+                    .setTimeout(config.getOtlpExporter().getTimeout())\n+                    .build())\n+                .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+                .setTimeout(config.getOtlpExporter().getTimeout())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(config.getZipkinExporter().getEndpoint())\n+                    .build())\n+                .build())\n+            .setTraceSampler(config.getSamplingRate() != 0 \n+               ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+    }\n+  \n+    @Bean\n+    public MeterSdkProvider meterProvider(Resource resource, Clock clock) {\n+        return MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public IntervalMetricReader metricReader(MeterSdkProvider meterProvider) {\n+        return IntervalMetricReader.builder()\n+            .addMetricProducer(meterProvider.getMetricProducer())\n+            .addMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public OpenTelemetry openTelemetry(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+           .addPropagator(B3Propagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+\n+    @Bean\n+    @ForJaeger\n+    public OpenTelemetry openTelemetryJaeger(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+  \n+    @Bean\n+    public AuthServiceStub authService(@ForJaeger OpenTelemetry openTelemetry, AuthConfig config) {\n+        return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+          .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+    }\n+    \n+    @Bean\n+    public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+        return TracingServletFilter.create(openTelemetry);\n+    }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason initialization ordering, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. It is expected that frameworks or end-users will set the SDK as the global to support\n+instrumentation that requires this.\n+\n+Before an SDK has been set, access to the global `OpenTelemetry` will return a no-op \n+`DefaultOpenTelemetry`. This is because it is possible library instrumentation is using the global,\n+and it may even use it during the processing of a request (rather than only at initialization time).\n+For this reason, we cannot throw an exception. Instead, if the SDK is detected on the classpath, we\n+will log a `SEVERE` warning once-only indicating the API has been accessed before the SDK configured\n+with directions on how a user could solve the problem. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note about Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+        tracer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+        Tracer tracer = this.tracer;\n+        if (tracer != null) {\n+          tracer.spanBuilder(\"export\").startSpan();\n+        }\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+    public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+        tracerProvider.addSpanExporter(exporter);\n+        components.add(exporter);\n+    }\n+    \n+    public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+        tracerProvider.setSampler(sampler);\n+        components.add(sampler);\n+    }\n+    \n+    public OpenTelemetry build() {\n+        OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+        for (OpenTelemetryComponent component : components) {\n+          component.setOpenTelemetry(sdk);\n+        }\n+    }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+    @Bean\n+    @ForSpanExporter\n+    public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+    }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+    private Lazy<Tracer> tracer;\n+    \n+    @Inject\n+    public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+    }\n+    \n+    @Override\n+    public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+    }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+## TracerSdkManagement", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 498}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg4MDI5NQ==", "bodyText": "I still think that we have to de-emphasize global instance of OpenTelemetry more. The common way of using OpenTelemetry should be via instance. Global should be something special and a conscious choice. Even requiring a separate explicit Global.set(OpenTelemetry)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541880295", "createdAt": "2020-12-13T08:55:25Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.\n+An alternative is to flatten all settings onto `OpenTelemetrySdkBuilder` - this has a downside that\n+it makes it very natural to create new tracer / meter providers for each configuration of the SDK,\n+which could result in a lot of duplication of resources like threads, workers, TCP connections. So\n+instead, this can make it clearer that those signals themselves are full-featured, and \n+`OpenTelemetry` is just a bag of signals.\n+\n+Keep in mind, reconfiguring `Clock` is expected to be an extremely uncommon operation.\n+\n+Another thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+    @Bean\n+    public Resource resource() {\n+        return Resource.getDefault().merge(CoolResource.getDefault());\n+    }\n+    \n+    @Bean\n+    public Clock otelClock() {\n+        return AtomicClock.create();\n+    }\n+\n+    @Bean\n+    public TracerSdkProvider tracerProvider(Resource resource, Clock clock, MonitoringConfig config) {\n+        return TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(config.getOtlpExporter().getEndpoint())\n+                    .setTimeout(config.getOtlpExporter().getTimeout())\n+                    .build())\n+                .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+                .setTimeout(config.getOtlpExporter().getTimeout())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(config.getZipkinExporter().getEndpoint())\n+                    .build())\n+                .build())\n+            .setTraceSampler(config.getSamplingRate() != 0 \n+               ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+    }\n+  \n+    @Bean\n+    public MeterSdkProvider meterProvider(Resource resource, Clock clock) {\n+        return MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public IntervalMetricReader metricReader(MeterSdkProvider meterProvider) {\n+        return IntervalMetricReader.builder()\n+            .addMetricProducer(meterProvider.getMetricProducer())\n+            .addMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public OpenTelemetry openTelemetry(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+           .addPropagator(B3Propagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+\n+    @Bean\n+    @ForJaeger\n+    public OpenTelemetry openTelemetryJaeger(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+  \n+    @Bean\n+    public AuthServiceStub authService(@ForJaeger OpenTelemetry openTelemetry, AuthConfig config) {\n+        return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+          .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+    }\n+    \n+    @Bean\n+    public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+        return TracingServletFilter.create(openTelemetry);\n+    }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason initialization ordering, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. It is expected that frameworks or end-users will set the SDK as the global to support\n+instrumentation that requires this.\n+\n+Before an SDK has been set, access to the global `OpenTelemetry` will return a no-op \n+`DefaultOpenTelemetry`. This is because it is possible library instrumentation is using the global,\n+and it may even use it during the processing of a request (rather than only at initialization time).\n+For this reason, we cannot throw an exception. Instead, if the SDK is detected on the classpath, we\n+will log a `SEVERE` warning once-only indicating the API has been accessed before the SDK configured\n+with directions on how a user could solve the problem. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note about Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+        tracer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+        Tracer tracer = this.tracer;\n+        if (tracer != null) {\n+          tracer.spanBuilder(\"export\").startSpan();\n+        }\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+    public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+        tracerProvider.addSpanExporter(exporter);\n+        components.add(exporter);\n+    }\n+    \n+    public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+        tracerProvider.setSampler(sampler);\n+        components.add(sampler);\n+    }\n+    \n+    public OpenTelemetry build() {\n+        OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+        for (OpenTelemetryComponent component : components) {\n+          component.setOpenTelemetry(sdk);\n+        }\n+    }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+    @Bean\n+    @ForSpanExporter\n+    public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+    }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+    private Lazy<Tracer> tracer;\n+    \n+    @Inject\n+    public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+    }\n+    \n+    @Override\n+    public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+    }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+## TracerSdkManagement\n+\n+With the proposal to make a configured SDK fully built rather than allowing configuration\n+mutability, the SDK management interface would only have `shutdown` and `forceFlush`. It seems\n+reasonable to actually remove `shutdown` from the `TracerSdkProvider` - the SDK provider is mostly\n+a bag of parts and has no intrinsic component, if instead components like `BatchSpanProcessor` and\n+`SpanExporter` implement `Closeable`, we can model shutdown as the responsibility of the creator of\n+the resources, which is idiomatic. In DI frameworks, this would generally be automatic. This would\n+prevent the case where two `TracerProvider` share an exporter and one of them is shutdown - when\n+shutting down the exporter, shut down the exporter.\n+\n+```java\n+public class MyApp {\n+ \n+    public static void main(String[] args) {\n+        try (OtlpGrpcSpanExporter otlpExporter = OtlpGrpcSpanExporter.builder().build();\n+              BatchSpanProcessor otlpProcessor = BatchSpanProcessor.builder(otlpExporter).build()) {\n+            OpenTelemetrySdk sdk = OpenTelemetrySdk.builder()\n+                .setTracerProvider(TracerSdkProvider.builder()\n+                                        .addSpanProcessor(otlpProcessor)\n+                                        .build())\n+                .build();\n+ \n+            Server server = Server.builder().setOpenTelemetry(sdk).build();\n+            server.listenAndServe();\n+        }\n+    }\n+\n+}\n+```\n+\n+```java\n+@Component\n+public class MyModule {\n+\n+    @Bean\n+    // If SpanExporter extends Closeable, it's automatically closed\n+    OtlpGrpcSpanExporter otlpExporter() {\n+        return OtlpGrpcSpanExporter.builder().build()\n+    }\n+   \n+    @Bean\n+    // If BatchSpanProcessor extends Closeable, it's automatically closed\n+    BatchSpanProcessor otlpSpanProcessor(OtlpGrpcSpanExporter otlpExporter) {\n+        return BatchSpanProcessor.builder(otlpExporter).build();\n+    }\n+ \n+    @Bean\n+    TracerSdkProvider tracerProvider(BatchSpanProcessor otlpSpanProcessor) {\n+        return TracerSdkProvider.builder().addSpanProcessor(otlpSpanProcessor).build();\n+    }\n+\n+    @Bean\n+    OpenTelemetrySdk openTelemetry(TracerSdkProvider tracerProvider) {\n+        return OpenTelemetrySdk.builder().setTracerProvider(tracerProvider).build();\n+    }\n+}\n+```\n+\n+The `OpenTelemetrySdk` and `TracerSdkProvider` are still exposed to provide access to `forceFlush`.\n+This makes it seem like `forceFlush`, though implemented in the SDK, may be more appropriate for the\n+API as it's an end-user API - it could make the separation of concerns of the initialization of the\n+SDK and the end-user tracing API complete. But the spec currently does not allow it.\n+\n+## Library instrumentation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 562}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg4MTIwNg==", "bodyText": "So what is the essential difference between this case and the \"full\" OpenTelemetrySdkBuilder above?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r541881206", "createdAt": "2020-12-13T09:00:56Z", "author": {"login": "iNikem"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,676 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Verify familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply allow accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();\n+}\n+```\n+\n+A very simple configuration may look like this.\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+          .addSpanProcessor(BatchSpanProcessor.builder(OtlpGrpcSpanExporter.builder())\n+              .setEndpoint(\"spans-service:4317\")\n+              .build())\n+          .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder().build();\n+        IntervalMetricReader.builder()\n+          .setMetricProducers(meterProvider.getMetricProducer())\n+          .setMetricExporter(PrometheusMetricServer.create())\n+          .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+          .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+          .setTracerProvider(tracerProvider)\n+          .setMeterProvider(meterProvider)\n+          .build();\n+   }\n+}\n+```\n+\n+This\n+\n+- Exports spans using OTLP to `spans-service`\n+  - Uses the BatchSpanProcessor. Future work is to make configuring this more intuitive\n+- Exposes metrics using Prometheus format\n+  - Future work is to make configuring this more intuitive\n+- Uses ParentBased(AlwaysOn) sampler\n+- Uses standard random IDs\n+- Uses a default Resource which simply consists of the SDK (or any other resources we decide to)\n+include in the core SDK, not extensions\n+- Uses the default Clock, which uses Java 8 / 9+ optimized APIs for getting time\n+  - The only real reason a user would set this is for unit tests, not for production\n+- Enforces default numeric limits related to number of attribute, etc\n+- Enables single w3c propagator\n+\n+Because the exporting is often the only aspect an end user needs to configure, this is the simplest\n+possible API for configuring the SDK.\n+\n+Let's look at a more complicated example\n+\n+```java\n+class HelloWorld {\n+    public static void main(String[] args) {\n+        Resource resource = Resource.getDefault().merge(CoolResource.getDefault());\n+        Clock clock = AtomicClock.create();\n+        TracerSdkProvider tracerProvider = TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .setTimeout(Duration.ofSeconds(10))\n+                    .setBatchQueueSize(10000)\n+                    .build())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(\"spans-service:4317\")\n+                    .build())\n+                .build())\n+            .setTraceSampler(Sampler.rateLimiting())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(10).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+        \n+        MeterSdkProvider meterProvider = MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+        IntervalMetricReader.builder()\n+            .setMetricProducers(meterProvider.getMetricProducer())\n+            .setMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+        \n+        OpenTelemetrySdk openTelemetry = OpenTelemetrySdk.builder()\n+            .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+            .addPropagator(B3Propagator.getInstance())\n+            .setTracerProvider(tracerProvider)\n+            .setMeterProvider(meterProvider)\n+            .build();\n+ \n+        OpenTelemetrySdk openTelemetryForJaegerBackend = OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+   }\n+}\n+```\n+\n+This configures resource, clock, exporters, span processors, propagators, sampler, trace limits, and metrics.\n+It configures two SDKs with different propagators. We unfortunately cannot achieve our goal of only\n+setting a property once - `Resource` and `Clock` are shared among signals but configured repeatedly.\n+An alternative is to flatten all settings onto `OpenTelemetrySdkBuilder` - this has a downside that\n+it makes it very natural to create new tracer / meter providers for each configuration of the SDK,\n+which could result in a lot of duplication of resources like threads, workers, TCP connections. So\n+instead, this can make it clearer that those signals themselves are full-featured, and \n+`OpenTelemetry` is just a bag of signals.\n+\n+Keep in mind, reconfiguring `Clock` is expected to be an extremely uncommon operation.\n+\n+Another thing to keep in mind is that it will be less common for an application developer to go this far\n+and we can expect it is actually framework developers that use the full configuration capabilities\n+of the SDK, likely by tying it to a separate configuration system.\n+\n+### Why build instances\n+\n+We have found that even at such an early stage of user adoption, users want to build instances of\n+the SDK.\n+\n+- Integrates with dependency injection, e.g., Spring, in a similar way as many other libraries\n+- Can allow having multiple instances in the same app, in multi-concern single-classloader scenarios\n+- Allow managing lifecycle of SDK, e.g., shutting down and starting along with the lifecycle of a\n+serverless runtime\n+\n+### Configuring the SDK in a framework\n+\n+It is extremely common for Java apps to be written using a dependency injection framework like\n+Spring, Guice, Dagger, HK, and many more. They will all follow a very similar pattern though.\n+\n+```java\n+@Component\n+public class OpenTelemetryModule {\n+    @Bean\n+    public Resource resource() {\n+        return Resource.getDefault().merge(CoolResource.getDefault());\n+    }\n+    \n+    @Bean\n+    public Clock otelClock() {\n+        return AtomicClock.create();\n+    }\n+\n+    @Bean\n+    public TracerSdkProvider tracerProvider(Resource resource, Clock clock, MonitoringConfig config) {\n+        return TracerSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .addSpanProcessor(CustomAttributeAddingProcessor.create())\n+            .addSpanProcessor(CustomEventAddingProcessor.create())\n+            .addSpanProcessor(BatchSpanProcessor.builder(\n+                OtlpGrpcSpanExporter.builder()\n+                    .setEndpoint(config.getOtlpExporter().getEndpoint())\n+                    .setTimeout(config.getOtlpExporter().getTimeout())\n+                    .build())\n+                .setBatchQueueSize(config.getOtlpExporter().getQueueSize())\n+                .setTimeout(config.getOtlpExporter().getTimeout())\n+                .build())\n+            .addSpanProcessor(SimpleSpanProcessor.builder(\n+                ZipkinExporter.builder()\n+                    .setEndpoint(config.getZipkinExporter().getEndpoint())\n+                    .build())\n+                .build())\n+            .setTraceSampler(config.getSamplingRate() != 0 \n+               ? Sampler.rateLimiting(config.getSamplingRate()) : Sampler.getDefault())\n+            .setTraceLimits(TraceLimits.builder().setMaxAttributes(config.getMaxSpanAttributes()).build())\n+            .setIdGenerator(TimestampedIdGenerator.create())\n+            .build();\n+    }\n+  \n+    @Bean\n+    public MeterSdkProvider meterProvider(Resource resource, Clock clock) {\n+        return MeterSdkProvider.builder()\n+            .setResource(resource)\n+            .setClock(clock)\n+            .setMeterStuff(InProgressMetricsStuff.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public IntervalMetricReader metricReader(MeterSdkProvider meterProvider) {\n+        return IntervalMetricReader.builder()\n+            .addMetricProducer(meterProvider.getMetricProducer())\n+            .addMetricExporter(PrometheusMetricServer.create())\n+            .build();\n+    }\n+\n+    @Bean\n+    public OpenTelemetry openTelemetry(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(W3CHttpTraceContextPropagator.getInstance())\n+           .addPropagator(B3Propagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+\n+    @Bean\n+    @ForJaeger\n+    public OpenTelemetry openTelemetryJaeger(TracerSdkProvider tracerProvider, MeterSdkProvider meterProvider) {\n+        return OpenTelemetrySdk.builder()\n+           .addPropagator(JaegerPropagator.getInstance())\n+           .setTracerProvider(tracerProvider)\n+           .setMeterProvider(meterProvider)\n+           .build();\n+    }\n+  \n+    @Bean\n+    public AuthServiceStub authService(@ForJaeger OpenTelemetry openTelemetry, AuthConfig config) {\n+        return AuthServiceGrpc.newBlockingStub(ManagedChannelBuilder.forEndpoint(config.getEndpoint()))\n+          .withInterceptor(TracingClientInterceptor.create(openTelemetry));\n+    }\n+    \n+    @Bean\n+    public ServletFilter servletFilter(OpenTelemetry openTelemetry) {\n+        return TracingServletFilter.create(openTelemetry);\n+    }\n+}\n+\n+// Use some instrumented client\n+@Component\n+public class MyAuthInterceptor {\n+\n+  private final AuthServiceStub authService;\n+  \n+  @Inject\n+  public MyAuthInterceptor(AuthServiceStub authService) {\n+    this.authService = authService;\n+  }\n+  \n+  public void doAuth() {\n+    if (!authService.getToken(\"credential\").isAuthenticated()) {\n+      throw new HackerException();\n+    }\n+  }\n+}\n+\n+// Use tracer directly, not so common\n+@Component\n+public class MyService {\n+\n+  private final Tracer tracer;\n+  private final Meter meter;\n+  \n+  @Inject\n+  public MyService(TracerProvider tracerProvider, MeterProvider meterProvider) {\n+    tracer = tracerProvider.get(\"my-service\");\n+    meter = meterProvider.get(\"my-service\");\n+  }\n+  \n+  public void doLogic() {\n+    Span span = tracer.spanBuilder(\"logic\").startSpan();\n+    try (Scope ignored = span.makeCurrent()) {\n+      Thread.sleep(1000);\n+    } finally {\n+      span.end();\n+    }\n+  }\n+}\n+```\n+\n+## The global instance of the SDK\n+\n+A built instance is convenient to use in most Java apps because of dependency injection. Because it\n+has a easy-to-reason initialization ordering, being tied into the dependency ordering (even if dependency \n+injection happened to be done manually through constructor invocation), we encourage application\n+developers to only use it.\n+\n+However, there are corner cases where an instance cannot be injected. The famous example is MySQL -\n+MySQL interceptors are initialized by calling a default constructor, and there is no way to pass a\n+built instance of a signal provider. For this case, we must store an SDK instance into a global\n+variable. It is expected that frameworks or end-users will set the SDK as the global to support\n+instrumentation that requires this.\n+\n+Before an SDK has been set, access to the global `OpenTelemetry` will return a no-op \n+`DefaultOpenTelemetry`. This is because it is possible library instrumentation is using the global,\n+and it may even use it during the processing of a request (rather than only at initialization time).\n+For this reason, we cannot throw an exception. Instead, if the SDK is detected on the classpath, we\n+will log a `SEVERE` warning once-only indicating the API has been accessed before the SDK configured\n+with directions on how a user could solve the problem. SDKs must be configured early\n+in an application to ensure it applies to all of the logic in the app, and this will generally be\n+ensured by the configuration framework such as Spring. For application developers, this restriction\n+should not have any effect one way or the other in the vast majority of cases.\n+\n+MySQL is the only known corner case that requires the global SDK instance. If such a corner case\n+didn't exist, we may not even support it in the first place.\n+\n+See special note about Java Agent below though.\n+\n+## Telemetry within SDK components\n+\n+SDK components, such as exporters or remote samplers, may want to emit telemetry for their own\n+processing. However, the SDK components must be initialized before the SDK can be fully built. We do\n+not support partially built SDK because one cannot reason about the behavior of it. Similarly we\n+do not support using the global instance of the SDK before it has been built. Therefore, SDK\n+components that require `OpenTelemetry` must accept it lazily. This is a restriction, but given\n+such components are rarely developed by application developers, and generally developed by either\n+framework authors or OpenTelemetry maintainers, this restriction is deemed reasonable.\n+\n+If this mechanism was built into the SDK, it may look like\n+\n+```java\n+interface OpenTelemetryComponent {\n+  default void setOpenTelemetry(OpenTelemetry openTelemetry) {}\n+}\n+interface SpanExporter extends OpenTelemetryComponent {\n+}\n+public class BatchExporter implements SpanExporter {\n+  \n+  private volatile Tracer tracer;\n+  \n+  @Override\n+  public void setOpenTelemetry(OpenTelemetry openTelemetry) {\n+        tracer = openTelemetry.getTracerProvider().get(\"spanexporter\");\n+  }\n+  \n+  @Override\n+  public void export() {\n+        Tracer tracer = this.tracer;\n+        if (tracer != null) {\n+          tracer.spanBuilder(\"export\").startSpan();\n+        }\n+  }\n+}\n+public class OpenTelemetrySdkBuilder {\n+    public OpenTelemetrySdkBuilder addSpanExporter(SpanExporter exporter) {\n+        tracerProvider.addSpanExporter(exporter);\n+        components.add(exporter);\n+    }\n+    \n+    public OpenTelemetrySdkBuilder setSampler(Sampler sampler) {\n+        tracerProvider.setSampler(sampler);\n+        components.add(sampler);\n+    }\n+    \n+    public OpenTelemetry build() {\n+        OpenTelemetrySdk sdk = new OpenTelemetrySdk(tracerProvider.build(), meterProvider.build());\n+        for (OpenTelemetryComponent component : components) {\n+          component.setOpenTelemetry(sdk);\n+        }\n+    }\n+}\n+```\n+\n+A framework author will have an even easier time since most dependency injection frameworks\n+natively support lazy injection.\n+\n+```java\n+@Component\n+public class MonitoringModule {\n+  \n+    @Bean\n+    @ForSpanExporter\n+    public Tracer tracer(TracerProvider tracerProvider) {\n+    return tracerProvider.get(\"spanexporter\");\n+    }\n+}\n+\n+@Component\n+public class MyExporter implements SpanExporter {\n+\n+    private Lazy<Tracer> tracer;\n+    \n+    @Inject\n+    public MyExporter(@ForSpanExporter Lazy<Tracer> tracer) {\n+    this.tracer = tracer;\n+    }\n+    \n+    @Override\n+    public void export() {\n+    tracer.get().spanBuilder(\"export\").startSpan();\n+    }\n+}\n+```\n+\n+## Immutability of OpenTelemetry configuration\n+\n+The above attempts to avoid allowing a built SDK to be mutated. Allowing mutation can make code\n+harder to reason about (any component, even deep in business logic, could update the SDK without\n+hindrance), can reduce performance (require volatile read on most operations), and produce thread\n+safety issues if not well implemented. In particular, compared to the current state as of writing,\n+\n+- `addSpanProcessor` is not needed because we instead push the complexity of handling telemetry\n+within telemetry components to those components, where the maintainers will have more domain\n+knowledge. It allows this mutator method to be removed from the end-user API.\n+\n+- `updateTraceConfig` - instead of allowing updates at the top level, we should consider making\n+`TraceConfig` an interface, and the SDK default implementation is static. It allows the above\n+benefits of immutability to be in place for the common case where dynamic updates are not needed.\n+Where dynamic updates are needed, it can be replaced with a mutable implementation instead of making\n+the SDK configuration mutable. This keeps update methods out of the end-user APIs and will generally\n+give framework developers more control by handling dynamicism themselves without the chance of\n+end-users to affect it negatively.\n+\n+Some highly buggy code that could be enabled by mutability.\n+\n+```java\n+class SleuthUsingService {\n+  \n+  @Inject\n+  private OpenTelemetry openTelemetry;\n+\n+  public void doLogic() {\n+    // My logic is important, so always sample it!\n+    OpenTelemetrySdk.getTracerManagement().updateTraceConfig(config -> config.setSampler(ALWAYS_ON));\n+    // This service was able to affect other services, even though Sleuth intends to\n+    // \"manage the SDK\". Unlike the javaagent, it can't block access to SDK methods we may provide.\n+    doSampledLogicWhileOtherServicesAlsoGetSampled();\n+  }\n+}\n+```\n+\n+## TracerSdkManagement\n+\n+With the proposal to make a configured SDK fully built rather than allowing configuration\n+mutability, the SDK management interface would only have `shutdown` and `forceFlush`. It seems\n+reasonable to actually remove `shutdown` from the `TracerSdkProvider` - the SDK provider is mostly\n+a bag of parts and has no intrinsic component, if instead components like `BatchSpanProcessor` and\n+`SpanExporter` implement `Closeable`, we can model shutdown as the responsibility of the creator of\n+the resources, which is idiomatic. In DI frameworks, this would generally be automatic. This would\n+prevent the case where two `TracerProvider` share an exporter and one of them is shutdown - when\n+shutting down the exporter, shut down the exporter.\n+\n+```java\n+public class MyApp {\n+ \n+    public static void main(String[] args) {\n+        try (OtlpGrpcSpanExporter otlpExporter = OtlpGrpcSpanExporter.builder().build();\n+              BatchSpanProcessor otlpProcessor = BatchSpanProcessor.builder(otlpExporter).build()) {\n+            OpenTelemetrySdk sdk = OpenTelemetrySdk.builder()\n+                .setTracerProvider(TracerSdkProvider.builder()\n+                                        .addSpanProcessor(otlpProcessor)\n+                                        .build())\n+                .build();\n+ \n+            Server server = Server.builder().setOpenTelemetry(sdk).build();\n+            server.listenAndServe();\n+        }\n+    }\n+\n+}\n+```\n+\n+```java\n+@Component\n+public class MyModule {\n+\n+    @Bean\n+    // If SpanExporter extends Closeable, it's automatically closed\n+    OtlpGrpcSpanExporter otlpExporter() {\n+        return OtlpGrpcSpanExporter.builder().build()\n+    }\n+   \n+    @Bean\n+    // If BatchSpanProcessor extends Closeable, it's automatically closed\n+    BatchSpanProcessor otlpSpanProcessor(OtlpGrpcSpanExporter otlpExporter) {\n+        return BatchSpanProcessor.builder(otlpExporter).build();\n+    }\n+ \n+    @Bean\n+    TracerSdkProvider tracerProvider(BatchSpanProcessor otlpSpanProcessor) {\n+        return TracerSdkProvider.builder().addSpanProcessor(otlpSpanProcessor).build();\n+    }\n+\n+    @Bean\n+    OpenTelemetrySdk openTelemetry(TracerSdkProvider tracerProvider) {\n+        return OpenTelemetrySdk.builder().setTracerProvider(tracerProvider).build();\n+    }\n+}\n+```\n+\n+The `OpenTelemetrySdk` and `TracerSdkProvider` are still exposed to provide access to `forceFlush`.\n+This makes it seem like `forceFlush`, though implemented in the SDK, may be more appropriate for the\n+API as it's an end-user API - it could make the separation of concerns of the initialization of the\n+SDK and the end-user tracing API complete. But the spec currently does not allow it.\n+\n+## Library instrumentation\n+\n+As the configuration of observability is contained on `OpenTelemetry` instances, it is expected that\n+library instrumentation accept an `OpenTelemetry` instance, often as a builder for their e.g.,\n+tracing interceptor, when configuring observability. An alternative method that leaves out the\n+parameter and falls back to the global can be added as well. Library authors would still have the\n+choice of starting with using the global and adding configurability by accepting `OpenTelemetry` if\n+users request it - we would expect official `OpenTelemetry` maintained library instrumentation to\n+follow our pattern though.\n+\n+## Auto-configuration\n+\n+The above presents programmatic configuration for the SDK and proposes that the core SDK has no\n+other mechanism for configuration. There is no SPI nor processing of environment variables or\n+system properties. There are many mechanisms for configuration, for example Spring Boot. \n+Integration with these systems becomes easier to reason about if we consider auto-configuration at\n+a layer above the core SDK.\n+\n+### Java Auto-Instrumentation Agent\n+\n+Java Auto-Instrumentation Agent is the primary means of automatically configuring the SDK. It\n+contains system properties, environment variables, and SPIs for allowing a user to have a fully\n+setup tracing configuration just by applying the agent. In fact, the agent does not even allow a\n+user to use the SDK directly, actively blocking it. Instead of having a situation where some\n+configuration is automatic in the core SDK and some in the agent, we can move it all to the agent.\n+The agent already exposes exporter SPIs - it can also expose SPIs for customization of the SDK\n+components that are manually configured above.\n+\n+- We could consider having a very similar autoconfiguration wrapper artifact as an SDK extension too.\n+But we would assume the core SDK is always manually configured.\n+\n+To allow users of the agent to apply tracing to their own code, the agent should attempt to\n+instrument dependency injection to provide an instance of `OpenTelemetry` using the agent-configured\n+SDK, for example it should add it to the Spring `ApplicationContext`. For cases where dependency\n+injection is not available, though, there is no option but to provide access to the SDK through a\n+global variable. We can expect such usage to still function correctly even if the agent is removed\n+and a different configuration mechanism is used, such as manual configuration as above, or Spring\n+Sleuth.\n+\n+### SDK Auto-Configuration Wrapper\n+\n+For non-agent users, we can still provide a non-programmatic solution for configuring the SDK -\n+it can be a different artifact which contains SPIs similar to what we have currently, supports\n+environment variables and other auto-configuration. A single entrypoint method, `initialize()` could\n+determine the configuration, initialize `OpenTelemetry`, and set it as the global. As this artifact\n+is in our control, it would be reasonable for `opentelemetry-api` to check the classpath for the\n+presence of the wrapper and invoke it automatically.\n+\n+### Spring Sleuth\n+\n+[Spring Sleuth](https://spring.io/projects/spring-cloud-sleuth) (or any similar observability-aware server framework such as \n+[curio-server-framework](https://github.com/curioswitch/curiostack/blob/master/common/server/framework/src/main/java/org/curioswitch/common/server/framework/monitoring/MonitoringModule.java)\n+or internal frameworks developed by devops teams at companies) is also a mechanism for automatically\n+configuring the SDK. In general, we would expect Sleuth users to not be using the java agent.\n+\n+Examples of how Sleuth could work are presented above in examples using `@Bean`. In particular, we\n+expect it to have its own set of configuration properties - by making sure we don't implement\n+configuration properties in the core SDK, only configuration layers like the agent or a possible\n+configuration wrapper, we avoid the possibility of confusion by having duplicate variables (in\n+practice, OpenTelemetry naming would likely be ignored and overwritten by Spring naming).\n+\n+## Partial SDKs\n+\n+We allow implementing particular signals of the OpenTelemetry API without using our SDK. For example,\n+a MeterProvider may be implemented with micrometer. For this reason, each signal must also present\n+all of its options in the form of, e.g., `TracerSdkProviderBuilder`. We expect the vast majority of\n+users to use `OpenTelemetrySdkBuilder` - while there is some duplication with the signal provider\n+builder, it is work maintainers can do to present the simplest interface for the most common use\n+case of using the whole SDK.\n+\n+Without SPI, the way to initialize a partial SDK would be to use `DefaultOpenTelemetry`.\n+\n+```java\n+@Bean\n+public OpenTelemetry openTelemetry() {\n+  return DefaultOpenTelemetry.builder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c408f33589c88208325090714a942aed6ed325a"}, "originalPosition": 637}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e11d9249fbec9c776fa0802c1067074450f834eb", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/e11d9249fbec9c776fa0802c1067074450f834eb", "committedDate": "2020-12-14T02:04:55Z", "message": "Cleanups"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7139fe83fde9863e4db48bb39a616c5fcba391ef", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/7139fe83fde9863e4db48bb39a616c5fcba391ef", "committedDate": "2020-12-14T08:25:41Z", "message": "More cleanups"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f9be509daf569dd67a37b14adcf177951f1c27af", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/f9be509daf569dd67a37b14adcf177951f1c27af", "committedDate": "2020-12-14T08:25:20Z", "message": "More cleanups"}, "afterCommit": {"oid": "7139fe83fde9863e4db48bb39a616c5fcba391ef", "author": {"user": {"login": "anuraaga", "name": "Anuraag Agrawal"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/7139fe83fde9863e4db48bb39a616c5fcba391ef", "committedDate": "2020-12-14T08:25:41Z", "message": "More cleanups"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0OTY5NDkx", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#pullrequestreview-554969491", "createdAt": "2020-12-17T20:38:40Z", "commit": {"oid": "7139fe83fde9863e4db48bb39a616c5fcba391ef"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDozODo0MFrOIIH4jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMDozODo0MFrOIIH4jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM4ODY4NA==", "bodyText": "I might just call this one build().  ;)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#discussion_r545388684", "createdAt": "2020-12-17T20:38:40Z", "author": {"login": "jkwatson"}, "path": "docs/sdk-configuration.md", "diffHunk": "@@ -0,0 +1,612 @@\n+# Design for configuring the SDK\n+\n+This document outlines some of the goals we have for user configuration of the SDK. It is a\n+continuation of discussion started with https://github.com/open-telemetry/opentelemetry-java/issues/2022.\n+\n+## Target audiences\n+\n+There are a few different target audiences that are related to our configuration story.\n+\n+- Application developers, aka end-users. Often have no knowledge of tracing but want to add \n+OpenTelemetry to their app and see traces show up in a console. Application developers will increase\n+in number forever, while the below are more constant.\n+\n+- Dev-ops / framework developers. Write components or frameworks to support providing tracing to\n+their application developers. May write custom SDK extensions such as exporters, samplers, to fit\n+with their internal infrastructure and as such have some familiarity with tracing at least as the\n+SDK presents it.\n+\n+- Telemetry extension authors. Write custom SDK extensions, often to support a particular backend.\n+Very familiar with telemetry.\n+\n+- OpenTelemetry maintainers. Write the SDK code.\n+\n+When making decisions, especially about complexity, we always prioritize the application developers,\n+then framework developers, then maintainers. This is because we expect those with less domain\n+knowledge about tracing to require a simpler experience than those with more. There is also more\n+bang-for-the-buck by making the end-user experience as streamlined as possible since we expect there\n+to be much more of them than other audiences.\n+\n+## Goals and non-goals\n+\n+### Goals\n+\n+- Provide a single entrypoint to configuring the SDK. For end-users, less familiar with the SDK, we\n+want to have everything together to provide discoverability and simpler end-user code. If there are\n+several, clear use cases which benefit from different entrypoints, we could have multiple\n+corresponding to each one.\n+\n+- Fit well with common Java idioms such as dependency injection, or common frameworks like Spring.\n+\n+- Reduce the chance of gotchas or configuration mishaps.\n+\n+- Aim for optimal performance of the configured SDK for the most common use case.\n+\n+### Non-goals\n+\n+- Provide the best possible experience for custom SDKs. Generally the burden of the experience for\n+custom SDKs can fall on their authors, we optimize for our standard usage, the full SDK. Any\n+reference to \"the SDK\" in this document refers to the full SDK with all signals.\n+\n+- Make sure everything is auto-configurable. This is out of the scope of the SDK, and instead is\n+left to auto-configuration layers, which are also described below but not as part of the core SDK. \n+In partiular, SignalProvider SPIs which currently exist are proposed to be removed from the SDK. The \n+SDK may provide an autoconfiguration extension as an option which is not internal to the main SDK \n+components.\n+\n+## Configuring an instance of the SDK\n+\n+The SDK exposes configuration options for all the signals it supports. Users all have different\n+requirements for how they use the SDK; for example they may use different exporters depending on\n+their backend. Because we cannot guess the configuration the user needs, we expect that the SDK must\n+be configured by the user before it can be used.\n+\n+Goals for configuring the SDK are\n+\n+- Discoverability of options\n+- Ease of use by end users, e.g., less complicated code required\n+- Avoid requiring duplicate configuration, which can lead to errors or confusion\n+- Provide good defaults where possible\n+\n+In Java, the builder pattern is common for configuring instances. Let's look at what that may look\n+like. The simplest configuration will be when a user wants to get a default experience, exporting\n+with a specific exporter to an endpoint.\n+\n+The SDK builder will simply accept its components as builder parameters. It only allows\n+setting SDK implementations and is not meant for use with partial SDKs.\n+\n+```java\n+class OpenTelemetrySdkBuilder {\n+  public OpenTelemetrySdkBuilder setTracerProvider(TracerSdkProvider tracerProvider);\n+  public OpenTelemetrySdkBuilder setMeterProvider(MeterSdkProvider meterProvider);\n+  public OpenTelemetrySdk buildAndSetAsGlobal();\n+  public OpenTelemetrySdk buildWithoutSettingAsGlobal();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7139fe83fde9863e4db48bb39a616c5fcba391ef"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0OTcyOTU2", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2262#pullrequestreview-554972956", "createdAt": "2020-12-17T20:43:59Z", "commit": {"oid": "7139fe83fde9863e4db48bb39a616c5fcba391ef"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3633, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}