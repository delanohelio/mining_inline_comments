{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4MzIwMDQ5", "number": 1220, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMDo1OTozOVrOD807Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzo1NTo1OFrOD89uRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MTA4MzE4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/metrics/DoubleSumObserver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMDo1OTozOVrOGWAPtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNDozNToxM1rOGWHfug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcyNTg3Nw==", "bodyText": "It does not sound monotonic to me since the cpu usage can float up and down. Maybe:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *           .doubleSumObserverBuilder(\"cpu_usage\")\n          \n          \n            \n             *           .doubleSumObserverBuilder(\"cpu_usage_time\")\n          \n      \n    \n    \n  \n\nOr we could provide a memory example, e.g. \"bytes written\"", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1220#discussion_r425725877", "createdAt": "2020-05-15T10:59:39Z", "author": {"login": "thisthat"}, "path": "api/src/main/java/io/opentelemetry/metrics/DoubleSumObserver.java", "diffHunk": "@@ -16,33 +16,42 @@\n \n package io.opentelemetry.metrics;\n \n-import io.opentelemetry.metrics.DoubleSumObserver.ResultDoubleObserver;\n+import io.opentelemetry.metrics.DoubleSumObserver.ResultDoubleSumObserver;\n import java.util.Map;\n import javax.annotation.concurrent.ThreadSafe;\n \n /**\n- * Observer to report pre-aggregated metrics with double value.\n+ * {@code SumObserver} is the asynchronous instrument corresponding to Counter, used to capture a\n+ * monotonic sum with Observe(sum).\n+ *\n+ * <p>\"Sum\" appears in the name to remind that it is used to capture sums directly. Use a\n+ * SumObserver to capture any value that starts at zero and rises throughout the process lifetime\n+ * and never falls.\n+ *\n+ * <p>A {@code SumObserver} is a good choice in situations where a measurement is expensive to\n+ * compute, such that it would be wasteful to compute on every request.\n  *\n  * <p>Example:\n  *\n  * <pre>{@code\n  * class YourClass {\n  *\n  *   private static final Meter meter = OpenTelemetry.getMeterRegistry().get(\"my_library_name\");\n- *   private static final DoubleSumObserver observer =\n+ *   private static final DoubleSumObserver cpuObserver =\n  *       meter.\n- *           .doubleSumObserverBuilder(\"doWork_latency\")\n- *           .setDescription(\"gRPC Latency\")\n+ *           .doubleSumObserverBuilder(\"cpu_usage\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8568f0f87c1584047a8bc42791a7f57280c11de4"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg0NDY2Ng==", "bodyText": "CPU usage as provided by proc or other sources is a classic monotonic always increasing sum, it is the total time in jiffrey (probably I misspelled this) since the beginning of the process", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1220#discussion_r425844666", "createdAt": "2020-05-15T14:35:13Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/metrics/DoubleSumObserver.java", "diffHunk": "@@ -16,33 +16,42 @@\n \n package io.opentelemetry.metrics;\n \n-import io.opentelemetry.metrics.DoubleSumObserver.ResultDoubleObserver;\n+import io.opentelemetry.metrics.DoubleSumObserver.ResultDoubleSumObserver;\n import java.util.Map;\n import javax.annotation.concurrent.ThreadSafe;\n \n /**\n- * Observer to report pre-aggregated metrics with double value.\n+ * {@code SumObserver} is the asynchronous instrument corresponding to Counter, used to capture a\n+ * monotonic sum with Observe(sum).\n+ *\n+ * <p>\"Sum\" appears in the name to remind that it is used to capture sums directly. Use a\n+ * SumObserver to capture any value that starts at zero and rises throughout the process lifetime\n+ * and never falls.\n+ *\n+ * <p>A {@code SumObserver} is a good choice in situations where a measurement is expensive to\n+ * compute, such that it would be wasteful to compute on every request.\n  *\n  * <p>Example:\n  *\n  * <pre>{@code\n  * class YourClass {\n  *\n  *   private static final Meter meter = OpenTelemetry.getMeterRegistry().get(\"my_library_name\");\n- *   private static final DoubleSumObserver observer =\n+ *   private static final DoubleSumObserver cpuObserver =\n  *       meter.\n- *           .doubleSumObserverBuilder(\"doWork_latency\")\n- *           .setDescription(\"gRPC Latency\")\n+ *           .doubleSumObserverBuilder(\"cpu_usage\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcyNTg3Nw=="}, "originalCommit": {"oid": "8568f0f87c1584047a8bc42791a7f57280c11de4"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MTEwMjc3OnYy", "diffSide": "RIGHT", "path": "contrib/runtime_metrics/src/main/java/io/opentelemetry/contrib/metrics/runtime/MemoryPools.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMTowNjo0OVrOGWAcjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNDo0NToxMVrOGWH5cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcyOTE2NQ==", "bodyText": "I think we can remove this TODO", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1220#discussion_r425729165", "createdAt": "2020-05-15T11:06:49Z", "author": {"login": "thisthat"}, "path": "contrib/runtime_metrics/src/main/java/io/opentelemetry/contrib/metrics/runtime/MemoryPools.java", "diffHunk": "@@ -69,12 +70,11 @@ public MemoryPools() {\n   /** Export only the \"area\" metric. */\n   public void exportMemoryAreaMetric() {\n     // TODO: Set this as non-monotonic.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8568f0f87c1584047a8bc42791a7f57280c11de4"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg1MTI1MQ==", "bodyText": "Done.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1220#discussion_r425851251", "createdAt": "2020-05-15T14:45:11Z", "author": {"login": "bogdandrutu"}, "path": "contrib/runtime_metrics/src/main/java/io/opentelemetry/contrib/metrics/runtime/MemoryPools.java", "diffHunk": "@@ -69,12 +70,11 @@ public MemoryPools() {\n   /** Export only the \"area\" metric. */\n   public void exportMemoryAreaMetric() {\n     // TODO: Set this as non-monotonic.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcyOTE2NQ=="}, "originalCommit": {"oid": "8568f0f87c1584047a8bc42791a7f57280c11de4"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MTEwNDkxOnYy", "diffSide": "RIGHT", "path": "contrib/runtime_metrics/src/main/java/io/opentelemetry/contrib/metrics/runtime/MemoryPools.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMTowNzozN1rOGWAd7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNDo0NTowMlrOGWH48Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcyOTUxNw==", "bodyText": "also this", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1220#discussion_r425729517", "createdAt": "2020-05-15T11:07:37Z", "author": {"login": "thisthat"}, "path": "contrib/runtime_metrics/src/main/java/io/opentelemetry/contrib/metrics/runtime/MemoryPools.java", "diffHunk": "@@ -103,12 +103,11 @@ public void update(ResultLongObserver resultLongObserver) {\n   /** Export only the \"pool\" metric. */\n   public void exportMemoryPoolMetric() {\n     // TODO: Set this as non-monotonic.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8568f0f87c1584047a8bc42791a7f57280c11de4"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg1MTEyMQ==", "bodyText": "Done.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1220#discussion_r425851121", "createdAt": "2020-05-15T14:45:02Z", "author": {"login": "bogdandrutu"}, "path": "contrib/runtime_metrics/src/main/java/io/opentelemetry/contrib/metrics/runtime/MemoryPools.java", "diffHunk": "@@ -103,12 +103,11 @@ public void update(ResultLongObserver resultLongObserver) {\n   /** Export only the \"pool\" metric. */\n   public void exportMemoryPoolMetric() {\n     // TODO: Set this as non-monotonic.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcyOTUxNw=="}, "originalCommit": {"oid": "8568f0f87c1584047a8bc42791a7f57280c11de4"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MTEzNDg2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/metrics/LongSumObserver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxMToxODoyMlrOGWAw_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNDozMjo1MVrOGWHZvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTczNDM5Ng==", "bodyText": "Also this example is not monotonic", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1220#discussion_r425734396", "createdAt": "2020-05-15T11:18:22Z", "author": {"login": "thisthat"}, "path": "api/src/main/java/io/opentelemetry/metrics/LongSumObserver.java", "diffHunk": "@@ -16,33 +16,42 @@\n \n package io.opentelemetry.metrics;\n \n-import io.opentelemetry.metrics.LongSumObserver.ResultLongObserver;\n+import io.opentelemetry.metrics.LongSumObserver.ResultLongSumObserver;\n import java.util.Map;\n import javax.annotation.concurrent.ThreadSafe;\n \n /**\n- * Observer to report pre-aggregated metrics with double value.\n+ * {@code SumObserver} is the asynchronous instrument corresponding to Counter, used to capture a\n+ * monotonic sum with Observe(sum).\n+ *\n+ * <p>\"Sum\" appears in the name to remind that it is used to capture sums directly. Use a\n+ * SumObserver to capture any value that starts at zero and rises throughout the process lifetime\n+ * and never falls.\n+ *\n+ * <p>A {@code SumObserver} is a good choice in situations where a measurement is expensive to\n+ * compute, such that it would be wasteful to compute on every request.\n  *\n  * <p>Example:\n  *\n  * <pre>{@code\n  * class YourClass {\n  *\n  *   private static final Meter meter = OpenTelemetry.getMeterRegistry().get(\"my_library_name\");\n- *   private static final LongSumObserver observer =\n+ *   private static final LongSumObserver cpuObserver =\n  *       meter.\n- *           .longSumObserverBuilder(\"doWork_latency\")\n- *           .setDescription(\"gRPC Latency\")\n+ *           .longSumObserverBuilder(\"cpu_usage\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8568f0f87c1584047a8bc42791a7f57280c11de4"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg0MzEzNQ==", "bodyText": "It is because it is the total usage time since beginning of the process.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1220#discussion_r425843135", "createdAt": "2020-05-15T14:32:51Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/metrics/LongSumObserver.java", "diffHunk": "@@ -16,33 +16,42 @@\n \n package io.opentelemetry.metrics;\n \n-import io.opentelemetry.metrics.LongSumObserver.ResultLongObserver;\n+import io.opentelemetry.metrics.LongSumObserver.ResultLongSumObserver;\n import java.util.Map;\n import javax.annotation.concurrent.ThreadSafe;\n \n /**\n- * Observer to report pre-aggregated metrics with double value.\n+ * {@code SumObserver} is the asynchronous instrument corresponding to Counter, used to capture a\n+ * monotonic sum with Observe(sum).\n+ *\n+ * <p>\"Sum\" appears in the name to remind that it is used to capture sums directly. Use a\n+ * SumObserver to capture any value that starts at zero and rises throughout the process lifetime\n+ * and never falls.\n+ *\n+ * <p>A {@code SumObserver} is a good choice in situations where a measurement is expensive to\n+ * compute, such that it would be wasteful to compute on every request.\n  *\n  * <p>Example:\n  *\n  * <pre>{@code\n  * class YourClass {\n  *\n  *   private static final Meter meter = OpenTelemetry.getMeterRegistry().get(\"my_library_name\");\n- *   private static final LongSumObserver observer =\n+ *   private static final LongSumObserver cpuObserver =\n  *       meter.\n- *           .longSumObserverBuilder(\"doWork_latency\")\n- *           .setDescription(\"gRPC Latency\")\n+ *           .longSumObserverBuilder(\"cpu_usage\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTczNDM5Ng=="}, "originalCommit": {"oid": "8568f0f87c1584047a8bc42791a7f57280c11de4"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjQ4NjYxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/metrics/DoubleSumObserver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzo0Mzo0OVrOGWOKhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzo0NTo0OVrOGWOOpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MzkyNg==", "bodyText": "Something to think about: this interface is exactly the same as the one in the up-down version. We could think about sharing the interface, calling it something like DoubleSumResult and reducing a wee bit of duplicated code.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1220#discussion_r425953926", "createdAt": "2020-05-15T17:43:49Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/metrics/DoubleSumObserver.java", "diffHunk": "@@ -67,15 +76,12 @@\n     @Override\n     Builder setConstantLabels(Map<String, String> constantLabels);\n \n-    @Override\n-    Builder setMonotonic(boolean monotonic);\n-\n     @Override\n     DoubleSumObserver build();\n   }\n \n   /** The result for the {@link AsynchronousInstrument.Callback}. */\n-  interface ResultDoubleObserver {\n+  interface ResultDoubleSumObserver {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2ddb1d0385efd4b4a93788cf80999e16add3597"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1NDk4MQ==", "bodyText": "#1230", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1220#discussion_r425954981", "createdAt": "2020-05-15T17:45:49Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/metrics/DoubleSumObserver.java", "diffHunk": "@@ -67,15 +76,12 @@\n     @Override\n     Builder setConstantLabels(Map<String, String> constantLabels);\n \n-    @Override\n-    Builder setMonotonic(boolean monotonic);\n-\n     @Override\n     DoubleSumObserver build();\n   }\n \n   /** The result for the {@link AsynchronousInstrument.Callback}. */\n-  interface ResultDoubleObserver {\n+  interface ResultDoubleSumObserver {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1MzkyNg=="}, "originalCommit": {"oid": "d2ddb1d0385efd4b4a93788cf80999e16add3597"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjQ4OTQ2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/metrics/DoubleUpDownSumObserver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzo0NDo0MFrOGWOMQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxODozMjoxNFrOGWPpDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1NDM3MQ==", "bodyText": "copy-paste miss here. Should be the DoubleUpDown...", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1220#discussion_r425954371", "createdAt": "2020-05-15T17:44:40Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/metrics/DoubleUpDownSumObserver.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.metrics;\n+\n+import io.opentelemetry.metrics.DoubleUpDownSumObserver.ResultDoubleUpDownSumObserver;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * UpDownSumObserver is the asynchronous instrument corresponding to UpDownCounter, used to capture\n+ * a non-monotonic count with Observe(sum).\n+ *\n+ * <p>\"Sum\" appears in the name to remind that it is used to capture sums directly. Use a\n+ * UpDownSumObserver to capture any value that starts at zero and rises or falls throughout the\n+ * process lifetime.\n+ *\n+ * <p>A {@code UpDownSumObserver} is a good choice in situations where a measurement is expensive to\n+ * compute, such that it would be wasteful to compute on every request.\n+ *\n+ * <p>Example:\n+ *\n+ * <pre>{@code\n+ * class YourClass {\n+ *\n+ *   private static final Meter meter = OpenTelemetry.getMeterRegistry().get(\"my_library_name\");\n+ *   private static final DoubleUpDownSumObserver memoryObserver =\n+ *       meter.\n+ *           .doubleUpDownSumObserverBuilder(\"memory_usage\")\n+ *           .setDescription(\"System memory usage\")\n+ *           .setUnit(\"by\")\n+ *           .build();\n+ *\n+ *   void init() {\n+ *     memoryObserver.setCallback(\n+ *         new LongSumObserver.Callback<LongObserver.ResultLongObserver>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2ddb1d0385efd4b4a93788cf80999e16add3597"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk3ODEyNA==", "bodyText": "Done.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1220#discussion_r425978124", "createdAt": "2020-05-15T18:32:14Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/metrics/DoubleUpDownSumObserver.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.metrics;\n+\n+import io.opentelemetry.metrics.DoubleUpDownSumObserver.ResultDoubleUpDownSumObserver;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * UpDownSumObserver is the asynchronous instrument corresponding to UpDownCounter, used to capture\n+ * a non-monotonic count with Observe(sum).\n+ *\n+ * <p>\"Sum\" appears in the name to remind that it is used to capture sums directly. Use a\n+ * UpDownSumObserver to capture any value that starts at zero and rises or falls throughout the\n+ * process lifetime.\n+ *\n+ * <p>A {@code UpDownSumObserver} is a good choice in situations where a measurement is expensive to\n+ * compute, such that it would be wasteful to compute on every request.\n+ *\n+ * <p>Example:\n+ *\n+ * <pre>{@code\n+ * class YourClass {\n+ *\n+ *   private static final Meter meter = OpenTelemetry.getMeterRegistry().get(\"my_library_name\");\n+ *   private static final DoubleUpDownSumObserver memoryObserver =\n+ *       meter.\n+ *           .doubleUpDownSumObserverBuilder(\"memory_usage\")\n+ *           .setDescription(\"System memory usage\")\n+ *           .setUnit(\"by\")\n+ *           .build();\n+ *\n+ *   void init() {\n+ *     memoryObserver.setCallback(\n+ *         new LongSumObserver.Callback<LongObserver.ResultLongObserver>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1NDM3MQ=="}, "originalCommit": {"oid": "d2ddb1d0385efd4b4a93788cf80999e16add3597"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjQ5NjU0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/metrics/LongUpDownSumObserver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzo0Njo1OFrOGWOQ6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxODozMjoyMFrOGWPpRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1NTU2MA==", "bodyText": "should be LongUpDown..", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1220#discussion_r425955560", "createdAt": "2020-05-15T17:46:58Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/metrics/LongUpDownSumObserver.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.metrics;\n+\n+import io.opentelemetry.metrics.LongUpDownSumObserver.ResultLongUpDownSumObserver;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * UpDownSumObserver is the asynchronous instrument corresponding to UpDownCounter, used to capture\n+ * a non-monotonic count with Observe(sum).\n+ *\n+ * <p>\"Sum\" appears in the name to remind that it is used to capture sums directly. Use a\n+ * UpDownSumObserver to capture any value that starts at zero and rises or falls throughout the\n+ * process lifetime.\n+ *\n+ * <p>A {@code UpDownSumObserver} is a good choice in situations where a measurement is expensive to\n+ * compute, such that it would be wasteful to compute on every request.\n+ *\n+ * <p>Example:\n+ *\n+ * <pre>{@code\n+ * class YourClass {\n+ *\n+ *   private static final Meter meter = OpenTelemetry.getMeterRegistry().get(\"my_library_name\");\n+ *   private static final LongUpDownSumObserver memoryObserver =\n+ *       meter.\n+ *           .longUpDownSumObserverBuilder(\"memory_usage\")\n+ *           .setDescription(\"System memory usage\")\n+ *           .setUnit(\"by\")\n+ *           .build();\n+ *\n+ *   void init() {\n+ *     memoryObserver.setCallback(\n+ *         new LongSumObserver.Callback<LongObserver.ResultLongObserver>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2ddb1d0385efd4b4a93788cf80999e16add3597"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk3ODE4MA==", "bodyText": "Done.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1220#discussion_r425978180", "createdAt": "2020-05-15T18:32:20Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/metrics/LongUpDownSumObserver.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.metrics;\n+\n+import io.opentelemetry.metrics.LongUpDownSumObserver.ResultLongUpDownSumObserver;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * UpDownSumObserver is the asynchronous instrument corresponding to UpDownCounter, used to capture\n+ * a non-monotonic count with Observe(sum).\n+ *\n+ * <p>\"Sum\" appears in the name to remind that it is used to capture sums directly. Use a\n+ * UpDownSumObserver to capture any value that starts at zero and rises or falls throughout the\n+ * process lifetime.\n+ *\n+ * <p>A {@code UpDownSumObserver} is a good choice in situations where a measurement is expensive to\n+ * compute, such that it would be wasteful to compute on every request.\n+ *\n+ * <p>Example:\n+ *\n+ * <pre>{@code\n+ * class YourClass {\n+ *\n+ *   private static final Meter meter = OpenTelemetry.getMeterRegistry().get(\"my_library_name\");\n+ *   private static final LongUpDownSumObserver memoryObserver =\n+ *       meter.\n+ *           .longUpDownSumObserverBuilder(\"memory_usage\")\n+ *           .setDescription(\"System memory usage\")\n+ *           .setUnit(\"by\")\n+ *           .build();\n+ *\n+ *   void init() {\n+ *     memoryObserver.setCallback(\n+ *         new LongSumObserver.Callback<LongObserver.ResultLongObserver>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1NTU2MA=="}, "originalCommit": {"oid": "d2ddb1d0385efd4b4a93788cf80999e16add3597"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjQ5OTg0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/metrics/LongUpDownSumObserver.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzo0ODowMlrOGWOTCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxODoxMjowMVrOGWPB2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1NjEwNg==", "bodyText": "I don't think we need these 3 methods declared here, as they just restate the parent interface.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1220#discussion_r425956106", "createdAt": "2020-05-15T17:48:02Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/metrics/LongUpDownSumObserver.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.metrics;\n+\n+import io.opentelemetry.metrics.LongUpDownSumObserver.ResultLongUpDownSumObserver;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * UpDownSumObserver is the asynchronous instrument corresponding to UpDownCounter, used to capture\n+ * a non-monotonic count with Observe(sum).\n+ *\n+ * <p>\"Sum\" appears in the name to remind that it is used to capture sums directly. Use a\n+ * UpDownSumObserver to capture any value that starts at zero and rises or falls throughout the\n+ * process lifetime.\n+ *\n+ * <p>A {@code UpDownSumObserver} is a good choice in situations where a measurement is expensive to\n+ * compute, such that it would be wasteful to compute on every request.\n+ *\n+ * <p>Example:\n+ *\n+ * <pre>{@code\n+ * class YourClass {\n+ *\n+ *   private static final Meter meter = OpenTelemetry.getMeterRegistry().get(\"my_library_name\");\n+ *   private static final LongUpDownSumObserver memoryObserver =\n+ *       meter.\n+ *           .longUpDownSumObserverBuilder(\"memory_usage\")\n+ *           .setDescription(\"System memory usage\")\n+ *           .setUnit(\"by\")\n+ *           .build();\n+ *\n+ *   void init() {\n+ *     memoryObserver.setCallback(\n+ *         new LongSumObserver.Callback<LongObserver.ResultLongObserver>() {\n+ *          {@literal @}Override\n+ *           public void update(ResultLongObserver result) {\n+ *             // Get system memory usage\n+ *             result.observe(memoryUsed, \"state\", \"used\");\n+ *             result.observe(memoryFree, \"state\", \"free\");\n+ *           }\n+ *         });\n+ *   }\n+ * }\n+ * }</pre>\n+ *\n+ * @since 0.1.0\n+ */\n+@ThreadSafe\n+public interface LongUpDownSumObserver extends AsynchronousInstrument<ResultLongUpDownSumObserver> {\n+  @Override\n+  void setCallback(Callback<ResultLongUpDownSumObserver> metricUpdater);\n+\n+  /** Builder class for {@link LongUpDownSumObserver}. */\n+  interface Builder extends AsynchronousInstrument.Builder {\n+    @Override\n+    Builder setDescription(String description);\n+\n+    @Override\n+    Builder setUnit(String unit);\n+\n+    @Override\n+    Builder setConstantLabels(Map<String, String> constantLabels);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2ddb1d0385efd4b4a93788cf80999e16add3597"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1NzMwOQ==", "bodyText": "nm. we need them to return the subinterface", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1220#discussion_r425957309", "createdAt": "2020-05-15T17:50:12Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/metrics/LongUpDownSumObserver.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.metrics;\n+\n+import io.opentelemetry.metrics.LongUpDownSumObserver.ResultLongUpDownSumObserver;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * UpDownSumObserver is the asynchronous instrument corresponding to UpDownCounter, used to capture\n+ * a non-monotonic count with Observe(sum).\n+ *\n+ * <p>\"Sum\" appears in the name to remind that it is used to capture sums directly. Use a\n+ * UpDownSumObserver to capture any value that starts at zero and rises or falls throughout the\n+ * process lifetime.\n+ *\n+ * <p>A {@code UpDownSumObserver} is a good choice in situations where a measurement is expensive to\n+ * compute, such that it would be wasteful to compute on every request.\n+ *\n+ * <p>Example:\n+ *\n+ * <pre>{@code\n+ * class YourClass {\n+ *\n+ *   private static final Meter meter = OpenTelemetry.getMeterRegistry().get(\"my_library_name\");\n+ *   private static final LongUpDownSumObserver memoryObserver =\n+ *       meter.\n+ *           .longUpDownSumObserverBuilder(\"memory_usage\")\n+ *           .setDescription(\"System memory usage\")\n+ *           .setUnit(\"by\")\n+ *           .build();\n+ *\n+ *   void init() {\n+ *     memoryObserver.setCallback(\n+ *         new LongSumObserver.Callback<LongObserver.ResultLongObserver>() {\n+ *          {@literal @}Override\n+ *           public void update(ResultLongObserver result) {\n+ *             // Get system memory usage\n+ *             result.observe(memoryUsed, \"state\", \"used\");\n+ *             result.observe(memoryFree, \"state\", \"free\");\n+ *           }\n+ *         });\n+ *   }\n+ * }\n+ * }</pre>\n+ *\n+ * @since 0.1.0\n+ */\n+@ThreadSafe\n+public interface LongUpDownSumObserver extends AsynchronousInstrument<ResultLongUpDownSumObserver> {\n+  @Override\n+  void setCallback(Callback<ResultLongUpDownSumObserver> metricUpdater);\n+\n+  /** Builder class for {@link LongUpDownSumObserver}. */\n+  interface Builder extends AsynchronousInstrument.Builder {\n+    @Override\n+    Builder setDescription(String description);\n+\n+    @Override\n+    Builder setUnit(String unit);\n+\n+    @Override\n+    Builder setConstantLabels(Map<String, String> constantLabels);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1NjEwNg=="}, "originalCommit": {"oid": "d2ddb1d0385efd4b4a93788cf80999e16add3597"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk2ODA4OA==", "bodyText": "Yes.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1220#discussion_r425968088", "createdAt": "2020-05-15T18:12:01Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/metrics/LongUpDownSumObserver.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.metrics;\n+\n+import io.opentelemetry.metrics.LongUpDownSumObserver.ResultLongUpDownSumObserver;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * UpDownSumObserver is the asynchronous instrument corresponding to UpDownCounter, used to capture\n+ * a non-monotonic count with Observe(sum).\n+ *\n+ * <p>\"Sum\" appears in the name to remind that it is used to capture sums directly. Use a\n+ * UpDownSumObserver to capture any value that starts at zero and rises or falls throughout the\n+ * process lifetime.\n+ *\n+ * <p>A {@code UpDownSumObserver} is a good choice in situations where a measurement is expensive to\n+ * compute, such that it would be wasteful to compute on every request.\n+ *\n+ * <p>Example:\n+ *\n+ * <pre>{@code\n+ * class YourClass {\n+ *\n+ *   private static final Meter meter = OpenTelemetry.getMeterRegistry().get(\"my_library_name\");\n+ *   private static final LongUpDownSumObserver memoryObserver =\n+ *       meter.\n+ *           .longUpDownSumObserverBuilder(\"memory_usage\")\n+ *           .setDescription(\"System memory usage\")\n+ *           .setUnit(\"by\")\n+ *           .build();\n+ *\n+ *   void init() {\n+ *     memoryObserver.setCallback(\n+ *         new LongSumObserver.Callback<LongObserver.ResultLongObserver>() {\n+ *          {@literal @}Override\n+ *           public void update(ResultLongObserver result) {\n+ *             // Get system memory usage\n+ *             result.observe(memoryUsed, \"state\", \"used\");\n+ *             result.observe(memoryFree, \"state\", \"free\");\n+ *           }\n+ *         });\n+ *   }\n+ * }\n+ * }</pre>\n+ *\n+ * @since 0.1.0\n+ */\n+@ThreadSafe\n+public interface LongUpDownSumObserver extends AsynchronousInstrument<ResultLongUpDownSumObserver> {\n+  @Override\n+  void setCallback(Callback<ResultLongUpDownSumObserver> metricUpdater);\n+\n+  /** Builder class for {@link LongUpDownSumObserver}. */\n+  interface Builder extends AsynchronousInstrument.Builder {\n+    @Override\n+    Builder setDescription(String description);\n+\n+    @Override\n+    Builder setUnit(String unit);\n+\n+    @Override\n+    Builder setConstantLabels(Map<String, String> constantLabels);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1NjEwNg=="}, "originalCommit": {"oid": "d2ddb1d0385efd4b4a93788cf80999e16add3597"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjUwMjQ5OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/metrics/DoubleUpDownSumObserver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzo0ODo0NFrOGWOUqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzo0OToyMVrOGWOV6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1NjUyMQ==", "bodyText": "These three methods restate the parent interface methods. I think we don't need them here, as well.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1220#discussion_r425956521", "createdAt": "2020-05-15T17:48:44Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/metrics/DoubleUpDownSumObserver.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.metrics;\n+\n+import io.opentelemetry.metrics.DoubleUpDownSumObserver.ResultDoubleUpDownSumObserver;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * UpDownSumObserver is the asynchronous instrument corresponding to UpDownCounter, used to capture\n+ * a non-monotonic count with Observe(sum).\n+ *\n+ * <p>\"Sum\" appears in the name to remind that it is used to capture sums directly. Use a\n+ * UpDownSumObserver to capture any value that starts at zero and rises or falls throughout the\n+ * process lifetime.\n+ *\n+ * <p>A {@code UpDownSumObserver} is a good choice in situations where a measurement is expensive to\n+ * compute, such that it would be wasteful to compute on every request.\n+ *\n+ * <p>Example:\n+ *\n+ * <pre>{@code\n+ * class YourClass {\n+ *\n+ *   private static final Meter meter = OpenTelemetry.getMeterRegistry().get(\"my_library_name\");\n+ *   private static final DoubleUpDownSumObserver memoryObserver =\n+ *       meter.\n+ *           .doubleUpDownSumObserverBuilder(\"memory_usage\")\n+ *           .setDescription(\"System memory usage\")\n+ *           .setUnit(\"by\")\n+ *           .build();\n+ *\n+ *   void init() {\n+ *     memoryObserver.setCallback(\n+ *         new LongSumObserver.Callback<LongObserver.ResultLongObserver>() {\n+ *          {@literal @}Override\n+ *           public void update(ResultLongObserver result) {\n+ *             // Get system memory usage\n+ *             result.observe(memoryUsed, \"state\", \"used\");\n+ *             result.observe(memoryFree, \"state\", \"free\");\n+ *           }\n+ *         });\n+ *   }\n+ * }\n+ * }</pre>\n+ *\n+ * @since 0.1.0\n+ */\n+@ThreadSafe\n+public interface DoubleUpDownSumObserver\n+    extends AsynchronousInstrument<ResultDoubleUpDownSumObserver> {\n+  @Override\n+  void setCallback(Callback<ResultDoubleUpDownSumObserver> metricUpdater);\n+\n+  /** Builder class for {@link DoubleUpDownSumObserver}. */\n+  interface Builder extends AsynchronousInstrument.Builder {\n+    @Override\n+    Builder setDescription(String description);\n+\n+    @Override\n+    Builder setUnit(String unit);\n+\n+    @Override\n+    Builder setConstantLabels(Map<String, String> constantLabels);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2ddb1d0385efd4b4a93788cf80999e16add3597"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1Njg0Mw==", "bodyText": "oh hmm. we need them to return the subclass, don't we. never mind, I think we do need them.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1220#discussion_r425956843", "createdAt": "2020-05-15T17:49:21Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/metrics/DoubleUpDownSumObserver.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.metrics;\n+\n+import io.opentelemetry.metrics.DoubleUpDownSumObserver.ResultDoubleUpDownSumObserver;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * UpDownSumObserver is the asynchronous instrument corresponding to UpDownCounter, used to capture\n+ * a non-monotonic count with Observe(sum).\n+ *\n+ * <p>\"Sum\" appears in the name to remind that it is used to capture sums directly. Use a\n+ * UpDownSumObserver to capture any value that starts at zero and rises or falls throughout the\n+ * process lifetime.\n+ *\n+ * <p>A {@code UpDownSumObserver} is a good choice in situations where a measurement is expensive to\n+ * compute, such that it would be wasteful to compute on every request.\n+ *\n+ * <p>Example:\n+ *\n+ * <pre>{@code\n+ * class YourClass {\n+ *\n+ *   private static final Meter meter = OpenTelemetry.getMeterRegistry().get(\"my_library_name\");\n+ *   private static final DoubleUpDownSumObserver memoryObserver =\n+ *       meter.\n+ *           .doubleUpDownSumObserverBuilder(\"memory_usage\")\n+ *           .setDescription(\"System memory usage\")\n+ *           .setUnit(\"by\")\n+ *           .build();\n+ *\n+ *   void init() {\n+ *     memoryObserver.setCallback(\n+ *         new LongSumObserver.Callback<LongObserver.ResultLongObserver>() {\n+ *          {@literal @}Override\n+ *           public void update(ResultLongObserver result) {\n+ *             // Get system memory usage\n+ *             result.observe(memoryUsed, \"state\", \"used\");\n+ *             result.observe(memoryFree, \"state\", \"free\");\n+ *           }\n+ *         });\n+ *   }\n+ * }\n+ * }</pre>\n+ *\n+ * @since 0.1.0\n+ */\n+@ThreadSafe\n+public interface DoubleUpDownSumObserver\n+    extends AsynchronousInstrument<ResultDoubleUpDownSumObserver> {\n+  @Override\n+  void setCallback(Callback<ResultDoubleUpDownSumObserver> metricUpdater);\n+\n+  /** Builder class for {@link DoubleUpDownSumObserver}. */\n+  interface Builder extends AsynchronousInstrument.Builder {\n+    @Override\n+    Builder setDescription(String description);\n+\n+    @Override\n+    Builder setUnit(String unit);\n+\n+    @Override\n+    Builder setConstantLabels(Map<String, String> constantLabels);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk1NjUyMQ=="}, "originalCommit": {"oid": "d2ddb1d0385efd4b4a93788cf80999e16add3597"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjUyNDIxOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/io/opentelemetry/metrics/DoubleUpDownSumObserverTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNzo1NTo1OFrOGWOi9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxODozMzozMlrOGWPrsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk2MDE4MQ==", "bodyText": "2020", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1220#discussion_r425960181", "createdAt": "2020-05-15T17:55:58Z", "author": {"login": "jkwatson"}, "path": "api/src/test/java/io/opentelemetry/metrics/DoubleUpDownSumObserverTest.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2ddb1d0385efd4b4a93788cf80999e16add3597"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk3ODgwMw==", "bodyText": "Done.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1220#discussion_r425978803", "createdAt": "2020-05-15T18:33:32Z", "author": {"login": "bogdandrutu"}, "path": "api/src/test/java/io/opentelemetry/metrics/DoubleUpDownSumObserverTest.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk2MDE4MQ=="}, "originalCommit": {"oid": "d2ddb1d0385efd4b4a93788cf80999e16add3597"}, "originalPosition": 2}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 671, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}