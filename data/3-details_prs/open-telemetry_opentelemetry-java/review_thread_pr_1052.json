{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1MzAxOTQx", "number": 1052, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMDowODoxN1rODsdKQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTowMDo1N1rODtSXhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTQxNjk2OnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMDowODoxN1rOF9UtCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMzozMToxMVrOF9WJBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0NjY2Nw==", "bodyText": "Style change?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r399846667", "createdAt": "2020-03-29T20:08:17Z", "author": {"login": "carlosalberto"}, "path": "build.gradle", "diffHunk": "@@ -93,27 +93,30 @@ subprojects {\n         guavaVersion = '28.2-android'\n         jmhVersion = '1.19'\n         opentracingVersion = '0.33.0'\n+        prometheusVersion = '0.8.1'\n         protobufVersion = '3.11.4'\n         protocVersion = '3.11.4'\n \n         libraries = [\n-                auto_value           : \"com.google.auto.value:auto-value:${autoValueVersion}\",\n-                auto_value_annotation: \"com.google.auto.value:auto-value-annotations:${autoValueVersion}\",\n-                disruptor            : 'com.lmax:disruptor:3.4.2',\n-                errorprone_annotation: \"com.google.errorprone:error_prone_annotations:${errorProneVersion}\",\n-                errorprone_core      : \"com.google.errorprone:error_prone_core:${errorProneVersion}\",\n-                errorprone_javac     : \"com.google.errorprone:javac:${errorProneJavacVersion}\",\n-                grpc_api             : \"io.grpc:grpc-api:${grpcVersion}\",\n-                grpc_context         : \"io.grpc:grpc-context:${grpcVersion}\",\n-                grpc_protobuf        : \"io.grpc:grpc-protobuf:${grpcVersion}\",\n-                grpc_stub            : \"io.grpc:grpc-stub:${grpcVersion}\",\n-                guava                : \"com.google.guava:guava:${guavaVersion}\",\n-                javax_annotations    : \"javax.annotation:javax.annotation-api:1.3.2\",\n-                jmh_core             : \"org.openjdk.jmh:jmh-core:${jmhVersion}\",\n-                jmh_bytecode         : \"org.openjdk.jmh:jmh-generator-bytecode:${jmhVersion}\",\n-                jsr305               : \"com.google.code.findbugs:jsr305:${findBugsJsr305Version}\",\n-                protobuf             : \"com.google.protobuf:protobuf-java:${protobufVersion}\",\n-                protobuf_util        : \"com.google.protobuf:protobuf-java-util:${protobufVersion}\",\n+                auto_value              : \"com.google.auto.value:auto-value:${autoValueVersion}\",\n+                auto_value_annotation   : \"com.google.auto.value:auto-value-annotations:${autoValueVersion}\",\n+                disruptor               : 'com.lmax:disruptor:3.4.2',\n+                errorprone_annotation   : \"com.google.errorprone:error_prone_annotations:${errorProneVersion}\",\n+                errorprone_core         : \"com.google.errorprone:error_prone_core:${errorProneVersion}\",\n+                errorprone_javac        : \"com.google.errorprone:javac:${errorProneJavacVersion}\",\n+                grpc_api                : \"io.grpc:grpc-api:${grpcVersion}\",\n+                grpc_context            : \"io.grpc:grpc-context:${grpcVersion}\",\n+                grpc_protobuf           : \"io.grpc:grpc-protobuf:${grpcVersion}\",\n+                grpc_stub               : \"io.grpc:grpc-stub:${grpcVersion}\",\n+                guava                   : \"com.google.guava:guava:${guavaVersion}\",\n+                javax_annotations       : \"javax.annotation:javax.annotation-api:1.3.2\",\n+                jmh_core                : \"org.openjdk.jmh:jmh-core:${jmhVersion}\",\n+                jmh_bytecode            : \"org.openjdk.jmh:jmh-generator-bytecode:${jmhVersion}\",\n+                jsr305                  : \"com.google.code.findbugs:jsr305:${findBugsJsr305Version}\",\n+                prometheus_client       : \"io.prometheus:simpleclient:${prometheusVersion}\",\n+                prometheus_client_common: \"io.prometheus:simpleclient_common:${prometheusVersion}\",\n+                protobuf                : \"com.google.protobuf:protobuf-java:${protobufVersion}\",\n+                protobuf_util           : \"com.google.protobuf:protobuf-java-util:${protobufVersion}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f65842028d39e3f176e73a9913d78d7e87cc015"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg3MDIxMg==", "bodyText": "Added prometheus entries, and a longer name and everything moved right", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r399870212", "createdAt": "2020-03-29T23:31:11Z", "author": {"login": "bogdandrutu"}, "path": "build.gradle", "diffHunk": "@@ -93,27 +93,30 @@ subprojects {\n         guavaVersion = '28.2-android'\n         jmhVersion = '1.19'\n         opentracingVersion = '0.33.0'\n+        prometheusVersion = '0.8.1'\n         protobufVersion = '3.11.4'\n         protocVersion = '3.11.4'\n \n         libraries = [\n-                auto_value           : \"com.google.auto.value:auto-value:${autoValueVersion}\",\n-                auto_value_annotation: \"com.google.auto.value:auto-value-annotations:${autoValueVersion}\",\n-                disruptor            : 'com.lmax:disruptor:3.4.2',\n-                errorprone_annotation: \"com.google.errorprone:error_prone_annotations:${errorProneVersion}\",\n-                errorprone_core      : \"com.google.errorprone:error_prone_core:${errorProneVersion}\",\n-                errorprone_javac     : \"com.google.errorprone:javac:${errorProneJavacVersion}\",\n-                grpc_api             : \"io.grpc:grpc-api:${grpcVersion}\",\n-                grpc_context         : \"io.grpc:grpc-context:${grpcVersion}\",\n-                grpc_protobuf        : \"io.grpc:grpc-protobuf:${grpcVersion}\",\n-                grpc_stub            : \"io.grpc:grpc-stub:${grpcVersion}\",\n-                guava                : \"com.google.guava:guava:${guavaVersion}\",\n-                javax_annotations    : \"javax.annotation:javax.annotation-api:1.3.2\",\n-                jmh_core             : \"org.openjdk.jmh:jmh-core:${jmhVersion}\",\n-                jmh_bytecode         : \"org.openjdk.jmh:jmh-generator-bytecode:${jmhVersion}\",\n-                jsr305               : \"com.google.code.findbugs:jsr305:${findBugsJsr305Version}\",\n-                protobuf             : \"com.google.protobuf:protobuf-java:${protobufVersion}\",\n-                protobuf_util        : \"com.google.protobuf:protobuf-java-util:${protobufVersion}\",\n+                auto_value              : \"com.google.auto.value:auto-value:${autoValueVersion}\",\n+                auto_value_annotation   : \"com.google.auto.value:auto-value-annotations:${autoValueVersion}\",\n+                disruptor               : 'com.lmax:disruptor:3.4.2',\n+                errorprone_annotation   : \"com.google.errorprone:error_prone_annotations:${errorProneVersion}\",\n+                errorprone_core         : \"com.google.errorprone:error_prone_core:${errorProneVersion}\",\n+                errorprone_javac        : \"com.google.errorprone:javac:${errorProneJavacVersion}\",\n+                grpc_api                : \"io.grpc:grpc-api:${grpcVersion}\",\n+                grpc_context            : \"io.grpc:grpc-context:${grpcVersion}\",\n+                grpc_protobuf           : \"io.grpc:grpc-protobuf:${grpcVersion}\",\n+                grpc_stub               : \"io.grpc:grpc-stub:${grpcVersion}\",\n+                guava                   : \"com.google.guava:guava:${guavaVersion}\",\n+                javax_annotations       : \"javax.annotation:javax.annotation-api:1.3.2\",\n+                jmh_core                : \"org.openjdk.jmh:jmh-core:${jmhVersion}\",\n+                jmh_bytecode            : \"org.openjdk.jmh:jmh-generator-bytecode:${jmhVersion}\",\n+                jsr305                  : \"com.google.code.findbugs:jsr305:${findBugsJsr305Version}\",\n+                prometheus_client       : \"io.prometheus:simpleclient:${prometheusVersion}\",\n+                prometheus_client_common: \"io.prometheus:simpleclient_common:${prometheusVersion}\",\n+                protobuf                : \"com.google.protobuf:protobuf-java:${protobufVersion}\",\n+                protobuf_util           : \"com.google.protobuf:protobuf-java-util:${protobufVersion}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0NjY2Nw=="}, "originalCommit": {"oid": "0f65842028d39e3f176e73a9913d78d7e87cc015"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDEwMjE4OnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNTo1ODozNlrOF9amSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNTo1ODozNlrOF9amSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0MzI0MA==", "bodyText": "just a small nit:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            disruptor               : 'com.lmax:disruptor:3.4.2',\n          \n          \n            \n                            disruptor               : \"com.lmax:disruptor:3.4.2\",", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r399943240", "createdAt": "2020-03-30T05:58:36Z", "author": {"login": "thisthat"}, "path": "build.gradle", "diffHunk": "@@ -93,27 +93,30 @@ subprojects {\n         guavaVersion = '28.2-android'\n         jmhVersion = '1.19'\n         opentracingVersion = '0.33.0'\n+        prometheusVersion = '0.8.1'\n         protobufVersion = '3.11.4'\n         protocVersion = '3.11.4'\n \n         libraries = [\n-                auto_value           : \"com.google.auto.value:auto-value:${autoValueVersion}\",\n-                auto_value_annotation: \"com.google.auto.value:auto-value-annotations:${autoValueVersion}\",\n-                disruptor            : 'com.lmax:disruptor:3.4.2',\n-                errorprone_annotation: \"com.google.errorprone:error_prone_annotations:${errorProneVersion}\",\n-                errorprone_core      : \"com.google.errorprone:error_prone_core:${errorProneVersion}\",\n-                errorprone_javac     : \"com.google.errorprone:javac:${errorProneJavacVersion}\",\n-                grpc_api             : \"io.grpc:grpc-api:${grpcVersion}\",\n-                grpc_context         : \"io.grpc:grpc-context:${grpcVersion}\",\n-                grpc_protobuf        : \"io.grpc:grpc-protobuf:${grpcVersion}\",\n-                grpc_stub            : \"io.grpc:grpc-stub:${grpcVersion}\",\n-                guava                : \"com.google.guava:guava:${guavaVersion}\",\n-                javax_annotations    : \"javax.annotation:javax.annotation-api:1.3.2\",\n-                jmh_core             : \"org.openjdk.jmh:jmh-core:${jmhVersion}\",\n-                jmh_bytecode         : \"org.openjdk.jmh:jmh-generator-bytecode:${jmhVersion}\",\n-                jsr305               : \"com.google.code.findbugs:jsr305:${findBugsJsr305Version}\",\n-                protobuf             : \"com.google.protobuf:protobuf-java:${protobufVersion}\",\n-                protobuf_util        : \"com.google.protobuf:protobuf-java-util:${protobufVersion}\",\n+                auto_value              : \"com.google.auto.value:auto-value:${autoValueVersion}\",\n+                auto_value_annotation   : \"com.google.auto.value:auto-value-annotations:${autoValueVersion}\",\n+                disruptor               : 'com.lmax:disruptor:3.4.2',", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f65842028d39e3f176e73a9913d78d7e87cc015"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDEwNjIyOnYy", "diffSide": "RIGHT", "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjowMDoyOVrOF9aofw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjowMDoyOVrOF9aofw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0MzgwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Summary} will be converted to two (sum and count) plus the number of Percentile values {@code\n          \n          \n            \n             * Summary} will be converted to two {@link Sample}s (sum and count) plus the number of Percentile values {@code", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r399943807", "createdAt": "2020-03-30T06:00:29Z", "author": {"login": "thisthat"}, "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.prometheus;\n+\n+import static io.prometheus.client.Collector.doubleToGoString;\n+\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.Collector.MetricFamilySamples;\n+import io.prometheus.client.Collector.MetricFamilySamples.Sample;\n+import io.prometheus.client.Collector.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Util methods to convert OpenTelemetry Metrics data models to Prometheus data models.\n+ *\n+ * <p>Each OpenTelemetry {@link MetricData} will be converted to a Prometheus {@link\n+ * MetricFamilySamples}, and each {@code Point} of the {@link MetricData} will be converted to\n+ * Prometheus {@link Sample}s.\n+ *\n+ * <p>{@code DoublePoint}, {@code LongPoint} will be converted to a single {@link Sample}. {@code\n+ * Summary} will be converted to two (sum and count) plus the number of Percentile values {@code", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f65842028d39e3f176e73a9913d78d7e87cc015"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDEyMTgzOnYy", "diffSide": "RIGHT", "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjowODowNlrOF9axsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjowODowNlrOF9axsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk0NjE2Mw==", "bodyText": "Given the Javadoc at the beginning of the class, I would expect a join by an underscore.\nFurthermore, one less string replace \ud83d\ude09\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return Collector.sanitizeMetricName(instrumentationLibraryName + \".\" + descriptorMetricName);\n          \n          \n            \n                return Collector.sanitizeMetricName(instrumentationLibraryName + \"_\" + descriptorMetricName);", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r399946163", "createdAt": "2020-03-30T06:08:06Z", "author": {"login": "thisthat"}, "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.prometheus;\n+\n+import static io.prometheus.client.Collector.doubleToGoString;\n+\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.Collector.MetricFamilySamples;\n+import io.prometheus.client.Collector.MetricFamilySamples.Sample;\n+import io.prometheus.client.Collector.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Util methods to convert OpenTelemetry Metrics data models to Prometheus data models.\n+ *\n+ * <p>Each OpenTelemetry {@link MetricData} will be converted to a Prometheus {@link\n+ * MetricFamilySamples}, and each {@code Point} of the {@link MetricData} will be converted to\n+ * Prometheus {@link Sample}s.\n+ *\n+ * <p>{@code DoublePoint}, {@code LongPoint} will be converted to a single {@link Sample}. {@code\n+ * Summary} will be converted to two (sum and count) plus the number of Percentile values {@code\n+ * Sample}s\n+ *\n+ * <p>Please note that Prometheus Metric and Label name can only have alphanumeric characters and\n+ * underscore. All other characters will be sanitized by underscores.\n+ */\n+final class MetricAdapter {\n+\n+  static final String SAMPLE_SUFFIX_COUNT = \"_count\";\n+  static final String SAMPLE_SUFFIX_SUM = \"_sum\";\n+  static final String LABEL_NAME_QUANTILE = \"quantile\";\n+\n+  // Converts a MetricData to a Prometheus MetricFamilySamples.\n+  static MetricFamilySamples toMetricFamilySamples(MetricData metricData) {\n+    Descriptor descriptor = metricData.getDescriptor();\n+    String fullName =\n+        toMetricFullName(\n+            descriptor.getName(), metricData.getInstrumentationLibraryInfo().getName());\n+    Type type = toMetricFamilyType(descriptor.getType());\n+\n+    return new MetricFamilySamples(\n+        fullName,\n+        type,\n+        descriptor.getDescription(),\n+        toSamples(fullName, descriptor, metricData.getPoints()));\n+  }\n+\n+  private static String toMetricFullName(\n+      String descriptorMetricName, String instrumentationLibraryName) {\n+    if (instrumentationLibraryName.isEmpty()) {\n+      return Collector.sanitizeMetricName(descriptorMetricName);\n+    }\n+\n+    return Collector.sanitizeMetricName(instrumentationLibraryName + \".\" + descriptorMetricName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f65842028d39e3f176e73a9913d78d7e87cc015"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDE0OTMwOnYy", "diffSide": "RIGHT", "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjoyMDowMFrOF9bBbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjoyMDowMFrOF9bBbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MDE5MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          new MetricFamilySamples.Sample(\n          \n          \n            \n                          new Sample(", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r399950190", "createdAt": "2020-03-30T06:20:00Z", "author": {"login": "thisthat"}, "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.prometheus;\n+\n+import static io.prometheus.client.Collector.doubleToGoString;\n+\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.Collector.MetricFamilySamples;\n+import io.prometheus.client.Collector.MetricFamilySamples.Sample;\n+import io.prometheus.client.Collector.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Util methods to convert OpenTelemetry Metrics data models to Prometheus data models.\n+ *\n+ * <p>Each OpenTelemetry {@link MetricData} will be converted to a Prometheus {@link\n+ * MetricFamilySamples}, and each {@code Point} of the {@link MetricData} will be converted to\n+ * Prometheus {@link Sample}s.\n+ *\n+ * <p>{@code DoublePoint}, {@code LongPoint} will be converted to a single {@link Sample}. {@code\n+ * Summary} will be converted to two (sum and count) plus the number of Percentile values {@code\n+ * Sample}s\n+ *\n+ * <p>Please note that Prometheus Metric and Label name can only have alphanumeric characters and\n+ * underscore. All other characters will be sanitized by underscores.\n+ */\n+final class MetricAdapter {\n+\n+  static final String SAMPLE_SUFFIX_COUNT = \"_count\";\n+  static final String SAMPLE_SUFFIX_SUM = \"_sum\";\n+  static final String LABEL_NAME_QUANTILE = \"quantile\";\n+\n+  // Converts a MetricData to a Prometheus MetricFamilySamples.\n+  static MetricFamilySamples toMetricFamilySamples(MetricData metricData) {\n+    Descriptor descriptor = metricData.getDescriptor();\n+    String fullName =\n+        toMetricFullName(\n+            descriptor.getName(), metricData.getInstrumentationLibraryInfo().getName());\n+    Type type = toMetricFamilyType(descriptor.getType());\n+\n+    return new MetricFamilySamples(\n+        fullName,\n+        type,\n+        descriptor.getDescription(),\n+        toSamples(fullName, descriptor, metricData.getPoints()));\n+  }\n+\n+  private static String toMetricFullName(\n+      String descriptorMetricName, String instrumentationLibraryName) {\n+    if (instrumentationLibraryName.isEmpty()) {\n+      return Collector.sanitizeMetricName(descriptorMetricName);\n+    }\n+\n+    return Collector.sanitizeMetricName(instrumentationLibraryName + \".\" + descriptorMetricName);\n+  }\n+\n+  static Type toMetricFamilyType(MetricData.Descriptor.Type type) {\n+    switch (type) {\n+      case NON_MONOTONIC_LONG:\n+      case NON_MONOTONIC_DOUBLE:\n+        return Type.GAUGE;\n+      case MONOTONIC_LONG:\n+      case MONOTONIC_DOUBLE:\n+        return Type.COUNTER;\n+      case SUMMARY:\n+        return Type.SUMMARY;\n+    }\n+    return Type.UNTYPED;\n+  }\n+\n+  // Converts a list of points from MetricData to a list of Prometheus Samples.\n+  static List<Sample> toSamples(String name, Descriptor descriptor, Collection<Point> points) {\n+    final List<Sample> samples =\n+        new ArrayList<>(estimateNumSamples(points.size(), descriptor.getType()));\n+\n+    List<String> constLabelNames = Collections.emptyList();\n+    List<String> constLabelValues = Collections.emptyList();\n+    if (descriptor.getConstantLabels().size() != 0) {\n+      constLabelNames = new ArrayList<>(descriptor.getConstantLabels().size());\n+      constLabelValues = new ArrayList<>(descriptor.getConstantLabels().size());\n+      for (Map.Entry<String, String> entry : descriptor.getConstantLabels().entrySet()) {\n+        constLabelNames.add(toLabelName(entry.getKey()));\n+        constLabelValues.add(entry.getValue() == null ? \"\" : entry.getValue());\n+      }\n+    }\n+\n+    for (Point point : points) {\n+      List<String> labelNames = Collections.emptyList();\n+      List<String> labelValues = Collections.emptyList();\n+      if (constLabelNames.size() + point.getLabels().size() != 0) {\n+        labelNames =\n+            new ArrayList<>(descriptor.getConstantLabels().size() + point.getLabels().size());\n+        labelNames.addAll(constLabelNames);\n+        labelValues =\n+            new ArrayList<>(descriptor.getConstantLabels().size() + point.getLabels().size());\n+        labelValues.addAll(constLabelValues);\n+\n+        for (Map.Entry<String, String> entry : point.getLabels().entrySet()) {\n+          // TODO: Use a cache(map) of converted label names to avoid sanitization multiple times\n+          // for the same label key.\n+          labelNames.add(toLabelName(entry.getKey()));\n+          labelValues.add(entry.getValue() == null ? \"\" : entry.getValue());\n+        }\n+      }\n+\n+      switch (descriptor.getType()) {\n+        case MONOTONIC_DOUBLE:\n+        case NON_MONOTONIC_DOUBLE:\n+          DoublePoint doublePoint = (DoublePoint) point;\n+          samples.add(new Sample(name, labelNames, labelValues, doublePoint.getValue()));\n+          break;\n+        case MONOTONIC_LONG:\n+        case NON_MONOTONIC_LONG:\n+          LongPoint longPoint = (LongPoint) point;\n+          samples.add(new Sample(name, labelNames, labelValues, longPoint.getValue()));\n+          break;\n+        case SUMMARY:\n+          SummaryPoint summaryPoint = (SummaryPoint) point;\n+          samples.add(\n+              new MetricFamilySamples.Sample(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f65842028d39e3f176e73a9913d78d7e87cc015"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDE1MDU4OnYy", "diffSide": "RIGHT", "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjoyMDozNVrOF9bCPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjoyMDozNVrOF9bCPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MDM5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          new MetricFamilySamples.Sample(\n          \n          \n            \n                          new Sample(", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r399950397", "createdAt": "2020-03-30T06:20:35Z", "author": {"login": "thisthat"}, "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.prometheus;\n+\n+import static io.prometheus.client.Collector.doubleToGoString;\n+\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.Collector.MetricFamilySamples;\n+import io.prometheus.client.Collector.MetricFamilySamples.Sample;\n+import io.prometheus.client.Collector.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Util methods to convert OpenTelemetry Metrics data models to Prometheus data models.\n+ *\n+ * <p>Each OpenTelemetry {@link MetricData} will be converted to a Prometheus {@link\n+ * MetricFamilySamples}, and each {@code Point} of the {@link MetricData} will be converted to\n+ * Prometheus {@link Sample}s.\n+ *\n+ * <p>{@code DoublePoint}, {@code LongPoint} will be converted to a single {@link Sample}. {@code\n+ * Summary} will be converted to two (sum and count) plus the number of Percentile values {@code\n+ * Sample}s\n+ *\n+ * <p>Please note that Prometheus Metric and Label name can only have alphanumeric characters and\n+ * underscore. All other characters will be sanitized by underscores.\n+ */\n+final class MetricAdapter {\n+\n+  static final String SAMPLE_SUFFIX_COUNT = \"_count\";\n+  static final String SAMPLE_SUFFIX_SUM = \"_sum\";\n+  static final String LABEL_NAME_QUANTILE = \"quantile\";\n+\n+  // Converts a MetricData to a Prometheus MetricFamilySamples.\n+  static MetricFamilySamples toMetricFamilySamples(MetricData metricData) {\n+    Descriptor descriptor = metricData.getDescriptor();\n+    String fullName =\n+        toMetricFullName(\n+            descriptor.getName(), metricData.getInstrumentationLibraryInfo().getName());\n+    Type type = toMetricFamilyType(descriptor.getType());\n+\n+    return new MetricFamilySamples(\n+        fullName,\n+        type,\n+        descriptor.getDescription(),\n+        toSamples(fullName, descriptor, metricData.getPoints()));\n+  }\n+\n+  private static String toMetricFullName(\n+      String descriptorMetricName, String instrumentationLibraryName) {\n+    if (instrumentationLibraryName.isEmpty()) {\n+      return Collector.sanitizeMetricName(descriptorMetricName);\n+    }\n+\n+    return Collector.sanitizeMetricName(instrumentationLibraryName + \".\" + descriptorMetricName);\n+  }\n+\n+  static Type toMetricFamilyType(MetricData.Descriptor.Type type) {\n+    switch (type) {\n+      case NON_MONOTONIC_LONG:\n+      case NON_MONOTONIC_DOUBLE:\n+        return Type.GAUGE;\n+      case MONOTONIC_LONG:\n+      case MONOTONIC_DOUBLE:\n+        return Type.COUNTER;\n+      case SUMMARY:\n+        return Type.SUMMARY;\n+    }\n+    return Type.UNTYPED;\n+  }\n+\n+  // Converts a list of points from MetricData to a list of Prometheus Samples.\n+  static List<Sample> toSamples(String name, Descriptor descriptor, Collection<Point> points) {\n+    final List<Sample> samples =\n+        new ArrayList<>(estimateNumSamples(points.size(), descriptor.getType()));\n+\n+    List<String> constLabelNames = Collections.emptyList();\n+    List<String> constLabelValues = Collections.emptyList();\n+    if (descriptor.getConstantLabels().size() != 0) {\n+      constLabelNames = new ArrayList<>(descriptor.getConstantLabels().size());\n+      constLabelValues = new ArrayList<>(descriptor.getConstantLabels().size());\n+      for (Map.Entry<String, String> entry : descriptor.getConstantLabels().entrySet()) {\n+        constLabelNames.add(toLabelName(entry.getKey()));\n+        constLabelValues.add(entry.getValue() == null ? \"\" : entry.getValue());\n+      }\n+    }\n+\n+    for (Point point : points) {\n+      List<String> labelNames = Collections.emptyList();\n+      List<String> labelValues = Collections.emptyList();\n+      if (constLabelNames.size() + point.getLabels().size() != 0) {\n+        labelNames =\n+            new ArrayList<>(descriptor.getConstantLabels().size() + point.getLabels().size());\n+        labelNames.addAll(constLabelNames);\n+        labelValues =\n+            new ArrayList<>(descriptor.getConstantLabels().size() + point.getLabels().size());\n+        labelValues.addAll(constLabelValues);\n+\n+        for (Map.Entry<String, String> entry : point.getLabels().entrySet()) {\n+          // TODO: Use a cache(map) of converted label names to avoid sanitization multiple times\n+          // for the same label key.\n+          labelNames.add(toLabelName(entry.getKey()));\n+          labelValues.add(entry.getValue() == null ? \"\" : entry.getValue());\n+        }\n+      }\n+\n+      switch (descriptor.getType()) {\n+        case MONOTONIC_DOUBLE:\n+        case NON_MONOTONIC_DOUBLE:\n+          DoublePoint doublePoint = (DoublePoint) point;\n+          samples.add(new Sample(name, labelNames, labelValues, doublePoint.getValue()));\n+          break;\n+        case MONOTONIC_LONG:\n+        case NON_MONOTONIC_LONG:\n+          LongPoint longPoint = (LongPoint) point;\n+          samples.add(new Sample(name, labelNames, labelValues, longPoint.getValue()));\n+          break;\n+        case SUMMARY:\n+          SummaryPoint summaryPoint = (SummaryPoint) point;\n+          samples.add(\n+              new MetricFamilySamples.Sample(\n+                  name + SAMPLE_SUFFIX_COUNT, labelNames, labelValues, summaryPoint.getCount()));\n+          samples.add(\n+              new MetricFamilySamples.Sample(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f65842028d39e3f176e73a9913d78d7e87cc015"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDE1MjE3OnYy", "diffSide": "RIGHT", "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjoyMToxNFrOF9bDRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjoyMToxNFrOF9bDRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MDY2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            new MetricFamilySamples.Sample(\n          \n          \n            \n                            new Sample(", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r399950661", "createdAt": "2020-03-30T06:21:14Z", "author": {"login": "thisthat"}, "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.prometheus;\n+\n+import static io.prometheus.client.Collector.doubleToGoString;\n+\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.Collector.MetricFamilySamples;\n+import io.prometheus.client.Collector.MetricFamilySamples.Sample;\n+import io.prometheus.client.Collector.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Util methods to convert OpenTelemetry Metrics data models to Prometheus data models.\n+ *\n+ * <p>Each OpenTelemetry {@link MetricData} will be converted to a Prometheus {@link\n+ * MetricFamilySamples}, and each {@code Point} of the {@link MetricData} will be converted to\n+ * Prometheus {@link Sample}s.\n+ *\n+ * <p>{@code DoublePoint}, {@code LongPoint} will be converted to a single {@link Sample}. {@code\n+ * Summary} will be converted to two (sum and count) plus the number of Percentile values {@code\n+ * Sample}s\n+ *\n+ * <p>Please note that Prometheus Metric and Label name can only have alphanumeric characters and\n+ * underscore. All other characters will be sanitized by underscores.\n+ */\n+final class MetricAdapter {\n+\n+  static final String SAMPLE_SUFFIX_COUNT = \"_count\";\n+  static final String SAMPLE_SUFFIX_SUM = \"_sum\";\n+  static final String LABEL_NAME_QUANTILE = \"quantile\";\n+\n+  // Converts a MetricData to a Prometheus MetricFamilySamples.\n+  static MetricFamilySamples toMetricFamilySamples(MetricData metricData) {\n+    Descriptor descriptor = metricData.getDescriptor();\n+    String fullName =\n+        toMetricFullName(\n+            descriptor.getName(), metricData.getInstrumentationLibraryInfo().getName());\n+    Type type = toMetricFamilyType(descriptor.getType());\n+\n+    return new MetricFamilySamples(\n+        fullName,\n+        type,\n+        descriptor.getDescription(),\n+        toSamples(fullName, descriptor, metricData.getPoints()));\n+  }\n+\n+  private static String toMetricFullName(\n+      String descriptorMetricName, String instrumentationLibraryName) {\n+    if (instrumentationLibraryName.isEmpty()) {\n+      return Collector.sanitizeMetricName(descriptorMetricName);\n+    }\n+\n+    return Collector.sanitizeMetricName(instrumentationLibraryName + \".\" + descriptorMetricName);\n+  }\n+\n+  static Type toMetricFamilyType(MetricData.Descriptor.Type type) {\n+    switch (type) {\n+      case NON_MONOTONIC_LONG:\n+      case NON_MONOTONIC_DOUBLE:\n+        return Type.GAUGE;\n+      case MONOTONIC_LONG:\n+      case MONOTONIC_DOUBLE:\n+        return Type.COUNTER;\n+      case SUMMARY:\n+        return Type.SUMMARY;\n+    }\n+    return Type.UNTYPED;\n+  }\n+\n+  // Converts a list of points from MetricData to a list of Prometheus Samples.\n+  static List<Sample> toSamples(String name, Descriptor descriptor, Collection<Point> points) {\n+    final List<Sample> samples =\n+        new ArrayList<>(estimateNumSamples(points.size(), descriptor.getType()));\n+\n+    List<String> constLabelNames = Collections.emptyList();\n+    List<String> constLabelValues = Collections.emptyList();\n+    if (descriptor.getConstantLabels().size() != 0) {\n+      constLabelNames = new ArrayList<>(descriptor.getConstantLabels().size());\n+      constLabelValues = new ArrayList<>(descriptor.getConstantLabels().size());\n+      for (Map.Entry<String, String> entry : descriptor.getConstantLabels().entrySet()) {\n+        constLabelNames.add(toLabelName(entry.getKey()));\n+        constLabelValues.add(entry.getValue() == null ? \"\" : entry.getValue());\n+      }\n+    }\n+\n+    for (Point point : points) {\n+      List<String> labelNames = Collections.emptyList();\n+      List<String> labelValues = Collections.emptyList();\n+      if (constLabelNames.size() + point.getLabels().size() != 0) {\n+        labelNames =\n+            new ArrayList<>(descriptor.getConstantLabels().size() + point.getLabels().size());\n+        labelNames.addAll(constLabelNames);\n+        labelValues =\n+            new ArrayList<>(descriptor.getConstantLabels().size() + point.getLabels().size());\n+        labelValues.addAll(constLabelValues);\n+\n+        for (Map.Entry<String, String> entry : point.getLabels().entrySet()) {\n+          // TODO: Use a cache(map) of converted label names to avoid sanitization multiple times\n+          // for the same label key.\n+          labelNames.add(toLabelName(entry.getKey()));\n+          labelValues.add(entry.getValue() == null ? \"\" : entry.getValue());\n+        }\n+      }\n+\n+      switch (descriptor.getType()) {\n+        case MONOTONIC_DOUBLE:\n+        case NON_MONOTONIC_DOUBLE:\n+          DoublePoint doublePoint = (DoublePoint) point;\n+          samples.add(new Sample(name, labelNames, labelValues, doublePoint.getValue()));\n+          break;\n+        case MONOTONIC_LONG:\n+        case NON_MONOTONIC_LONG:\n+          LongPoint longPoint = (LongPoint) point;\n+          samples.add(new Sample(name, labelNames, labelValues, longPoint.getValue()));\n+          break;\n+        case SUMMARY:\n+          SummaryPoint summaryPoint = (SummaryPoint) point;\n+          samples.add(\n+              new MetricFamilySamples.Sample(\n+                  name + SAMPLE_SUFFIX_COUNT, labelNames, labelValues, summaryPoint.getCount()));\n+          samples.add(\n+              new MetricFamilySamples.Sample(\n+                  name + SAMPLE_SUFFIX_SUM, labelNames, labelValues, summaryPoint.getSum()));\n+          List<ValueAtPercentile> valueAtPercentiles = summaryPoint.getPercentileValues();\n+          List<String> labelNamesWithQuantile = new ArrayList<>(labelNames.size());\n+          labelNamesWithQuantile.addAll(labelNames);\n+          labelNamesWithQuantile.add(LABEL_NAME_QUANTILE);\n+          for (ValueAtPercentile valueAtPercentile : valueAtPercentiles) {\n+            List<String> labelValuesWithQuantile = new ArrayList<>(labelValues.size());\n+            labelValuesWithQuantile.addAll(labelValues);\n+            labelValuesWithQuantile.add(doubleToGoString(valueAtPercentile.getPercentile()));\n+            samples.add(\n+                new MetricFamilySamples.Sample(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f65842028d39e3f176e73a9913d78d7e87cc015"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDE3MTAwOnYy", "diffSide": "RIGHT", "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/PrometheusCollector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNjoyOToyOVrOF9bOYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMjoyNzoxNVrOF9-iMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MzUwNQ==", "bodyText": "This is not clear to me. Maybe \"Sets the metric producer for the collector\"?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r399953505", "createdAt": "2020-03-30T06:29:29Z", "author": {"login": "thisthat"}, "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/PrometheusCollector.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.prometheus;\n+\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.export.MetricProducer;\n+import io.prometheus.client.Collector;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+public final class PrometheusCollector extends Collector {\n+  private final MetricProducer metricProducer;\n+\n+  private PrometheusCollector(MetricProducer metricProducer) {\n+    this.metricProducer = metricProducer;\n+  }\n+\n+  @Override\n+  public List<MetricFamilySamples> collect() {\n+    Collection<MetricData> allMetrics = metricProducer.getAllMetrics();\n+    List<MetricFamilySamples> allSamples = new ArrayList<>(allMetrics.size());\n+    for (MetricData metricData : allMetrics) {\n+      allSamples.add(MetricAdapter.toMetricFamilySamples(metricData));\n+    }\n+    return allSamples;\n+  }\n+\n+  /**\n+   * Returns a new builder instance for this exporter.\n+   *\n+   * @return a new builder instance for this exporter.\n+   */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  /** Builder utility for this exporter. */\n+  public static class Builder {\n+    private MetricProducer metricProducer;\n+\n+    /**\n+     * Sets the managed chanel to use when communicating with the backend. Required.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f65842028d39e3f176e73a9913d78d7e87cc015"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUzMjAxNg==", "bodyText": "I failed on copy-paste test :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r400532016", "createdAt": "2020-03-30T22:27:15Z", "author": {"login": "bogdandrutu"}, "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/PrometheusCollector.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.prometheus;\n+\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.export.MetricProducer;\n+import io.prometheus.client.Collector;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+public final class PrometheusCollector extends Collector {\n+  private final MetricProducer metricProducer;\n+\n+  private PrometheusCollector(MetricProducer metricProducer) {\n+    this.metricProducer = metricProducer;\n+  }\n+\n+  @Override\n+  public List<MetricFamilySamples> collect() {\n+    Collection<MetricData> allMetrics = metricProducer.getAllMetrics();\n+    List<MetricFamilySamples> allSamples = new ArrayList<>(allMetrics.size());\n+    for (MetricData metricData : allMetrics) {\n+      allSamples.add(MetricAdapter.toMetricFamilySamples(metricData));\n+    }\n+    return allSamples;\n+  }\n+\n+  /**\n+   * Returns a new builder instance for this exporter.\n+   *\n+   * @return a new builder instance for this exporter.\n+   */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  /** Builder utility for this exporter. */\n+  public static class Builder {\n+    private MetricProducer metricProducer;\n+\n+    /**\n+     * Sets the managed chanel to use when communicating with the backend. Required.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk1MzUwNQ=="}, "originalCommit": {"oid": "0f65842028d39e3f176e73a9913d78d7e87cc015"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NDYxMzcxOnYy", "diffSide": "RIGHT", "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/PrometheusCollector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwNToyNjowMVrOF-Fzsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNjoxNjo0NFrOF-dpmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY1MTE4Nw==", "bodyText": "Since it is required, should this method check for not null?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  this.metricProducer = metricProducer;\n          \n          \n            \n            \t  Utils.checkNotNull(metricProducer, \"metricProducer\");\n          \n          \n            \n                  this.metricProducer = metricProducer;", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r400651187", "createdAt": "2020-03-31T05:26:01Z", "author": {"login": "thisthat"}, "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/PrometheusCollector.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.prometheus;\n+\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.export.MetricProducer;\n+import io.prometheus.client.Collector;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+public final class PrometheusCollector extends Collector {\n+  private final MetricProducer metricProducer;\n+\n+  private PrometheusCollector(MetricProducer metricProducer) {\n+    this.metricProducer = metricProducer;\n+  }\n+\n+  @Override\n+  public List<MetricFamilySamples> collect() {\n+    Collection<MetricData> allMetrics = metricProducer.getAllMetrics();\n+    List<MetricFamilySamples> allSamples = new ArrayList<>(allMetrics.size());\n+    for (MetricData metricData : allMetrics) {\n+      allSamples.add(MetricAdapter.toMetricFamilySamples(metricData));\n+    }\n+    return allSamples;\n+  }\n+\n+  /**\n+   * Returns a new builder instance for this exporter.\n+   *\n+   * @return a new builder instance for this exporter.\n+   */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  /** Builder utility for this exporter. */\n+  public static class Builder {\n+    private MetricProducer metricProducer;\n+\n+    /**\n+     * Sets the metric producer for the collector. Required.\n+     *\n+     * @param metricProducer the {@link MetricProducer} to use.\n+     * @return this builder's instance.\n+     */\n+    public Builder setMetricProducer(MetricProducer metricProducer) {\n+      this.metricProducer = metricProducer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8d7ab7e52f40bfb7c6cc37d9c0249fdc32c4fc3"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA0MTgxOQ==", "bodyText": "Done in the build to ensure that it was called before calling build (required semantic).", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r401041819", "createdAt": "2020-03-31T16:16:44Z", "author": {"login": "bogdandrutu"}, "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/PrometheusCollector.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.prometheus;\n+\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.export.MetricProducer;\n+import io.prometheus.client.Collector;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+public final class PrometheusCollector extends Collector {\n+  private final MetricProducer metricProducer;\n+\n+  private PrometheusCollector(MetricProducer metricProducer) {\n+    this.metricProducer = metricProducer;\n+  }\n+\n+  @Override\n+  public List<MetricFamilySamples> collect() {\n+    Collection<MetricData> allMetrics = metricProducer.getAllMetrics();\n+    List<MetricFamilySamples> allSamples = new ArrayList<>(allMetrics.size());\n+    for (MetricData metricData : allMetrics) {\n+      allSamples.add(MetricAdapter.toMetricFamilySamples(metricData));\n+    }\n+    return allSamples;\n+  }\n+\n+  /**\n+   * Returns a new builder instance for this exporter.\n+   *\n+   * @return a new builder instance for this exporter.\n+   */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  /** Builder utility for this exporter. */\n+  public static class Builder {\n+    private MetricProducer metricProducer;\n+\n+    /**\n+     * Sets the metric producer for the collector. Required.\n+     *\n+     * @param metricProducer the {@link MetricProducer} to use.\n+     * @return this builder's instance.\n+     */\n+    public Builder setMetricProducer(MetricProducer metricProducer) {\n+      this.metricProducer = metricProducer;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY1MTE4Nw=="}, "originalCommit": {"oid": "f8d7ab7e52f40bfb7c6cc37d9c0249fdc32c4fc3"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4ODEzMDI2OnYy", "diffSide": "RIGHT", "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDo1OTozOFrOF-oB6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwMjoyMzo0NFrOF-unCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIxMTg4Mw==", "bodyText": "this method is gigantic. Would be good to refactor it into smaller chunks.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r401211883", "createdAt": "2020-03-31T20:59:38Z", "author": {"login": "jkwatson"}, "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.prometheus;\n+\n+import static io.prometheus.client.Collector.doubleToGoString;\n+\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.Collector.MetricFamilySamples;\n+import io.prometheus.client.Collector.MetricFamilySamples.Sample;\n+import io.prometheus.client.Collector.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Util methods to convert OpenTelemetry Metrics data models to Prometheus data models.\n+ *\n+ * <p>Each OpenTelemetry {@link MetricData} will be converted to a Prometheus {@link\n+ * MetricFamilySamples}, and each {@code Point} of the {@link MetricData} will be converted to\n+ * Prometheus {@link Sample}s.\n+ *\n+ * <p>{@code DoublePoint}, {@code LongPoint} will be converted to a single {@link Sample}. {@code\n+ * Summary} will be converted to two {@link Sample}s (sum and count) plus the number of Percentile\n+ * values {@code Sample}s\n+ *\n+ * <p>Please note that Prometheus Metric and Label name can only have alphanumeric characters and\n+ * underscore. All other characters will be sanitized by underscores.\n+ */\n+final class MetricAdapter {\n+\n+  static final String SAMPLE_SUFFIX_COUNT = \"_count\";\n+  static final String SAMPLE_SUFFIX_SUM = \"_sum\";\n+  static final String LABEL_NAME_QUANTILE = \"quantile\";\n+\n+  // Converts a MetricData to a Prometheus MetricFamilySamples.\n+  static MetricFamilySamples toMetricFamilySamples(MetricData metricData) {\n+    Descriptor descriptor = metricData.getDescriptor();\n+    String fullName =\n+        toMetricFullName(\n+            descriptor.getName(), metricData.getInstrumentationLibraryInfo().getName());\n+    Type type = toMetricFamilyType(descriptor.getType());\n+\n+    return new MetricFamilySamples(\n+        fullName,\n+        type,\n+        descriptor.getDescription(),\n+        toSamples(fullName, descriptor, metricData.getPoints()));\n+  }\n+\n+  private static String toMetricFullName(\n+      String descriptorMetricName, String instrumentationLibraryName) {\n+    if (instrumentationLibraryName.isEmpty()) {\n+      return Collector.sanitizeMetricName(descriptorMetricName);\n+    }\n+\n+    // Use \"_\" here even though the right way would be to use \".\" in general, but \".\" will be\n+    // replaced with \"_\" anyway so one less replace call.\n+    return Collector.sanitizeMetricName(instrumentationLibraryName + \"_\" + descriptorMetricName);\n+  }\n+\n+  static Type toMetricFamilyType(MetricData.Descriptor.Type type) {\n+    switch (type) {\n+      case NON_MONOTONIC_LONG:\n+      case NON_MONOTONIC_DOUBLE:\n+        return Type.GAUGE;\n+      case MONOTONIC_LONG:\n+      case MONOTONIC_DOUBLE:\n+        return Type.COUNTER;\n+      case SUMMARY:\n+        return Type.SUMMARY;\n+    }\n+    return Type.UNTYPED;\n+  }\n+\n+  // Converts a list of points from MetricData to a list of Prometheus Samples.\n+  static List<Sample> toSamples(String name, Descriptor descriptor, Collection<Point> points) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90a54dddb10ae4d393584495d152ac1b2c576e1e"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxOTY5MA==", "bodyText": "A bit of splitting :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r401319690", "createdAt": "2020-04-01T02:23:44Z", "author": {"login": "bogdandrutu"}, "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.prometheus;\n+\n+import static io.prometheus.client.Collector.doubleToGoString;\n+\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.Collector.MetricFamilySamples;\n+import io.prometheus.client.Collector.MetricFamilySamples.Sample;\n+import io.prometheus.client.Collector.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Util methods to convert OpenTelemetry Metrics data models to Prometheus data models.\n+ *\n+ * <p>Each OpenTelemetry {@link MetricData} will be converted to a Prometheus {@link\n+ * MetricFamilySamples}, and each {@code Point} of the {@link MetricData} will be converted to\n+ * Prometheus {@link Sample}s.\n+ *\n+ * <p>{@code DoublePoint}, {@code LongPoint} will be converted to a single {@link Sample}. {@code\n+ * Summary} will be converted to two {@link Sample}s (sum and count) plus the number of Percentile\n+ * values {@code Sample}s\n+ *\n+ * <p>Please note that Prometheus Metric and Label name can only have alphanumeric characters and\n+ * underscore. All other characters will be sanitized by underscores.\n+ */\n+final class MetricAdapter {\n+\n+  static final String SAMPLE_SUFFIX_COUNT = \"_count\";\n+  static final String SAMPLE_SUFFIX_SUM = \"_sum\";\n+  static final String LABEL_NAME_QUANTILE = \"quantile\";\n+\n+  // Converts a MetricData to a Prometheus MetricFamilySamples.\n+  static MetricFamilySamples toMetricFamilySamples(MetricData metricData) {\n+    Descriptor descriptor = metricData.getDescriptor();\n+    String fullName =\n+        toMetricFullName(\n+            descriptor.getName(), metricData.getInstrumentationLibraryInfo().getName());\n+    Type type = toMetricFamilyType(descriptor.getType());\n+\n+    return new MetricFamilySamples(\n+        fullName,\n+        type,\n+        descriptor.getDescription(),\n+        toSamples(fullName, descriptor, metricData.getPoints()));\n+  }\n+\n+  private static String toMetricFullName(\n+      String descriptorMetricName, String instrumentationLibraryName) {\n+    if (instrumentationLibraryName.isEmpty()) {\n+      return Collector.sanitizeMetricName(descriptorMetricName);\n+    }\n+\n+    // Use \"_\" here even though the right way would be to use \".\" in general, but \".\" will be\n+    // replaced with \"_\" anyway so one less replace call.\n+    return Collector.sanitizeMetricName(instrumentationLibraryName + \"_\" + descriptorMetricName);\n+  }\n+\n+  static Type toMetricFamilyType(MetricData.Descriptor.Type type) {\n+    switch (type) {\n+      case NON_MONOTONIC_LONG:\n+      case NON_MONOTONIC_DOUBLE:\n+        return Type.GAUGE;\n+      case MONOTONIC_LONG:\n+      case MONOTONIC_DOUBLE:\n+        return Type.COUNTER;\n+      case SUMMARY:\n+        return Type.SUMMARY;\n+    }\n+    return Type.UNTYPED;\n+  }\n+\n+  // Converts a list of points from MetricData to a list of Prometheus Samples.\n+  static List<Sample> toSamples(String name, Descriptor descriptor, Collection<Point> points) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIxMTg4Mw=="}, "originalCommit": {"oid": "90a54dddb10ae4d393584495d152ac1b2c576e1e"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4ODEzNDQ1OnYy", "diffSide": "RIGHT", "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTowMDo1N1rOF-oEpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTowMDo1N1rOF-oEpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIxMjU4Mw==", "bodyText": "not sure if it might read better to have return numPoints; as the default block in the switch.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1052#discussion_r401212583", "createdAt": "2020-03-31T21:00:57Z", "author": {"login": "jkwatson"}, "path": "exporters/prometheus/src/main/java/io/opentelemetry/exporters/prometheus/MetricAdapter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.prometheus;\n+\n+import static io.prometheus.client.Collector.doubleToGoString;\n+\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Point;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.prometheus.client.Collector;\n+import io.prometheus.client.Collector.MetricFamilySamples;\n+import io.prometheus.client.Collector.MetricFamilySamples.Sample;\n+import io.prometheus.client.Collector.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Util methods to convert OpenTelemetry Metrics data models to Prometheus data models.\n+ *\n+ * <p>Each OpenTelemetry {@link MetricData} will be converted to a Prometheus {@link\n+ * MetricFamilySamples}, and each {@code Point} of the {@link MetricData} will be converted to\n+ * Prometheus {@link Sample}s.\n+ *\n+ * <p>{@code DoublePoint}, {@code LongPoint} will be converted to a single {@link Sample}. {@code\n+ * Summary} will be converted to two {@link Sample}s (sum and count) plus the number of Percentile\n+ * values {@code Sample}s\n+ *\n+ * <p>Please note that Prometheus Metric and Label name can only have alphanumeric characters and\n+ * underscore. All other characters will be sanitized by underscores.\n+ */\n+final class MetricAdapter {\n+\n+  static final String SAMPLE_SUFFIX_COUNT = \"_count\";\n+  static final String SAMPLE_SUFFIX_SUM = \"_sum\";\n+  static final String LABEL_NAME_QUANTILE = \"quantile\";\n+\n+  // Converts a MetricData to a Prometheus MetricFamilySamples.\n+  static MetricFamilySamples toMetricFamilySamples(MetricData metricData) {\n+    Descriptor descriptor = metricData.getDescriptor();\n+    String fullName =\n+        toMetricFullName(\n+            descriptor.getName(), metricData.getInstrumentationLibraryInfo().getName());\n+    Type type = toMetricFamilyType(descriptor.getType());\n+\n+    return new MetricFamilySamples(\n+        fullName,\n+        type,\n+        descriptor.getDescription(),\n+        toSamples(fullName, descriptor, metricData.getPoints()));\n+  }\n+\n+  private static String toMetricFullName(\n+      String descriptorMetricName, String instrumentationLibraryName) {\n+    if (instrumentationLibraryName.isEmpty()) {\n+      return Collector.sanitizeMetricName(descriptorMetricName);\n+    }\n+\n+    // Use \"_\" here even though the right way would be to use \".\" in general, but \".\" will be\n+    // replaced with \"_\" anyway so one less replace call.\n+    return Collector.sanitizeMetricName(instrumentationLibraryName + \"_\" + descriptorMetricName);\n+  }\n+\n+  static Type toMetricFamilyType(MetricData.Descriptor.Type type) {\n+    switch (type) {\n+      case NON_MONOTONIC_LONG:\n+      case NON_MONOTONIC_DOUBLE:\n+        return Type.GAUGE;\n+      case MONOTONIC_LONG:\n+      case MONOTONIC_DOUBLE:\n+        return Type.COUNTER;\n+      case SUMMARY:\n+        return Type.SUMMARY;\n+    }\n+    return Type.UNTYPED;\n+  }\n+\n+  // Converts a list of points from MetricData to a list of Prometheus Samples.\n+  static List<Sample> toSamples(String name, Descriptor descriptor, Collection<Point> points) {\n+    final List<Sample> samples =\n+        new ArrayList<>(estimateNumSamples(points.size(), descriptor.getType()));\n+\n+    List<String> constLabelNames = Collections.emptyList();\n+    List<String> constLabelValues = Collections.emptyList();\n+    if (descriptor.getConstantLabels().size() != 0) {\n+      constLabelNames = new ArrayList<>(descriptor.getConstantLabels().size());\n+      constLabelValues = new ArrayList<>(descriptor.getConstantLabels().size());\n+      for (Map.Entry<String, String> entry : descriptor.getConstantLabels().entrySet()) {\n+        constLabelNames.add(toLabelName(entry.getKey()));\n+        constLabelValues.add(entry.getValue() == null ? \"\" : entry.getValue());\n+      }\n+    }\n+\n+    for (Point point : points) {\n+      List<String> labelNames = Collections.emptyList();\n+      List<String> labelValues = Collections.emptyList();\n+      if (constLabelNames.size() + point.getLabels().size() != 0) {\n+        labelNames =\n+            new ArrayList<>(descriptor.getConstantLabels().size() + point.getLabels().size());\n+        labelNames.addAll(constLabelNames);\n+        labelValues =\n+            new ArrayList<>(descriptor.getConstantLabels().size() + point.getLabels().size());\n+        labelValues.addAll(constLabelValues);\n+\n+        for (Map.Entry<String, String> entry : point.getLabels().entrySet()) {\n+          // TODO: Use a cache(map) of converted label names to avoid sanitization multiple times\n+          // for the same label key.\n+          labelNames.add(toLabelName(entry.getKey()));\n+          labelValues.add(entry.getValue() == null ? \"\" : entry.getValue());\n+        }\n+      }\n+\n+      switch (descriptor.getType()) {\n+        case MONOTONIC_DOUBLE:\n+        case NON_MONOTONIC_DOUBLE:\n+          DoublePoint doublePoint = (DoublePoint) point;\n+          samples.add(new Sample(name, labelNames, labelValues, doublePoint.getValue()));\n+          break;\n+        case MONOTONIC_LONG:\n+        case NON_MONOTONIC_LONG:\n+          LongPoint longPoint = (LongPoint) point;\n+          samples.add(new Sample(name, labelNames, labelValues, longPoint.getValue()));\n+          break;\n+        case SUMMARY:\n+          SummaryPoint summaryPoint = (SummaryPoint) point;\n+          samples.add(\n+              new Sample(\n+                  name + SAMPLE_SUFFIX_COUNT, labelNames, labelValues, summaryPoint.getCount()));\n+          samples.add(\n+              new Sample(name + SAMPLE_SUFFIX_SUM, labelNames, labelValues, summaryPoint.getSum()));\n+          List<ValueAtPercentile> valueAtPercentiles = summaryPoint.getPercentileValues();\n+          List<String> labelNamesWithQuantile = new ArrayList<>(labelNames.size());\n+          labelNamesWithQuantile.addAll(labelNames);\n+          labelNamesWithQuantile.add(LABEL_NAME_QUANTILE);\n+          for (ValueAtPercentile valueAtPercentile : valueAtPercentiles) {\n+            List<String> labelValuesWithQuantile = new ArrayList<>(labelValues.size());\n+            labelValuesWithQuantile.addAll(labelValues);\n+            labelValuesWithQuantile.add(doubleToGoString(valueAtPercentile.getPercentile()));\n+            samples.add(\n+                new Sample(\n+                    name,\n+                    labelNamesWithQuantile,\n+                    labelValuesWithQuantile,\n+                    valueAtPercentile.getValue()));\n+          }\n+          break;\n+      }\n+    }\n+    return samples;\n+  }\n+\n+  // Converts a label keys to a label names. Sanitizes the label keys.\n+  static String toLabelName(String labelKey) {\n+    return Collector.sanitizeMetricName(labelKey);\n+  }\n+\n+  private static int estimateNumSamples(int numPoints, Descriptor.Type type) {\n+    switch (type) {\n+      case NON_MONOTONIC_LONG:\n+      case NON_MONOTONIC_DOUBLE:\n+      case MONOTONIC_LONG:\n+      case MONOTONIC_DOUBLE:\n+        return numPoints;\n+      case SUMMARY:\n+        // count + sum + estimated 2 percentiles (default MinMaxSumCount aggregator).\n+        return numPoints * 4;\n+    }\n+    return numPoints;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90a54dddb10ae4d393584495d152ac1b2c576e1e"}, "originalPosition": 188}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 807, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}