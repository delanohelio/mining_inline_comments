{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1MDcxMjgy", "number": 857, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDo0NToyNlrODfsWAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDo0NjozNFrODfsXPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTU4OTc3OnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/view/Aggregations.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDo0NToyNlrOFpi-RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDo1NDowNlrOFpjNDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwODkzMg==", "bodyText": "I think this is a no-op check, since the array that is created will always be non-null.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/857#discussion_r379108932", "createdAt": "2020-02-13T20:45:26Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/view/Aggregations.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import io.opentelemetry.internal.Utils;\n+import io.opentelemetry.sdk.metrics.aggregator.AggregatorFactory;\n+import io.opentelemetry.sdk.metrics.aggregator.DoubleSumAggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.LongSumAggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.NoopAggregator;\n+import io.opentelemetry.sdk.metrics.common.InstrumentType;\n+import io.opentelemetry.sdk.metrics.common.InstrumentValueType;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor.Type;\n+import javax.annotation.concurrent.Immutable;\n+\n+public class Aggregations {\n+\n+  /**\n+   * Aggregation that calculates sum of recorded measurements.\n+   *\n+   * @since 0.1.0\n+   */\n+  public static Aggregation sum() {\n+    return Sum.INSTANCE;\n+  }\n+\n+  /**\n+   * Aggregation that calculates count of recorded measurements (the number of recorded\n+   * measurements).\n+   *\n+   * @since 0.1.0\n+   */\n+  public static Aggregation count() {\n+    return Count.INSTANCE;\n+  }\n+\n+  /**\n+   * Aggregation that calculates distribution stats on recorded measurements. Distribution includes\n+   * sum, count, histogram, and sum of squared deviations.\n+   *\n+   * <p>The boundaries for the buckets in the underlying histogram needs to be sorted.\n+   *\n+   * @param bucketBoundaries bucket boundaries to use for distribution.\n+   * @return a new {@code Distribution}.\n+   * @since 0.1.0\n+   */\n+  public static Aggregation distributionWithExplicitBounds(Double... bucketBoundaries) {\n+    return new Distribution(bucketBoundaries);\n+  }\n+\n+  /**\n+   * Aggregation that calculates the last value of all recorded measurements.\n+   *\n+   * @since 0.1.0\n+   */\n+  public static Aggregation lastValue() {\n+    return LastValue.INSTANCE;\n+  }\n+\n+  @Immutable\n+  private enum Sum implements Aggregation {\n+    INSTANCE;\n+\n+    @Override\n+    public AggregatorFactory getAggregatorFactory(InstrumentValueType instrumentValueType) {\n+      return instrumentValueType == InstrumentValueType.LONG\n+          ? LongSumAggregator.getFactory()\n+          : DoubleSumAggregator.getFactory();\n+    }\n+\n+    @Override\n+    public Type getDescriptorType(\n+        InstrumentType instrumentType, InstrumentValueType instrumentValueType) {\n+      switch (instrumentType) {\n+        case COUNTER_MONOTONIC:\n+        case MEASURE_ABSOLUTE:\n+        case OBSERVER_MONOTONIC:\n+          return instrumentValueType == InstrumentValueType.LONG\n+              ? Type.MONOTONIC_LONG\n+              : Type.MONOTONIC_DOUBLE;\n+        case COUNTER_NON_MONOTONIC:\n+        case MEASURE_NON_ABSOLUTE:\n+        case OBSERVER_NON_MONOTONIC:\n+          return instrumentValueType == InstrumentValueType.LONG\n+              ? Type.NON_MONOTONIC_LONG\n+              : Type.NON_MONOTONIC_DOUBLE;\n+      }\n+      throw new IllegalArgumentException(\"This should not happen\");\n+    }\n+\n+    @Override\n+    public boolean availableForInstrument(InstrumentType instrumentType) {\n+      // Available for all instruments.\n+      return true;\n+    }\n+  }\n+\n+  @Immutable\n+  private enum Count implements Aggregation {\n+    INSTANCE;\n+\n+    @Override\n+    public AggregatorFactory getAggregatorFactory(InstrumentValueType instrumentValueType) {\n+      // TODO: Implement count aggregator and use it here.\n+      return NoopAggregator.getFactory();\n+    }\n+\n+    @Override\n+    public Type getDescriptorType(\n+        InstrumentType instrumentType, InstrumentValueType instrumentValueType) {\n+      return Type.MONOTONIC_LONG;\n+    }\n+\n+    @Override\n+    public boolean availableForInstrument(InstrumentType instrumentType) {\n+      // It is not available for Observer instruments.\n+      return instrumentType != InstrumentType.OBSERVER_MONOTONIC\n+          && instrumentType != InstrumentType.OBSERVER_NON_MONOTONIC;\n+    }\n+  }\n+\n+  @Immutable\n+  private static final class Distribution implements Aggregation {\n+    private final AggregatorFactory factory;\n+\n+    Distribution(Double... bucketBoundaries) {\n+      Utils.checkNotNull(bucketBoundaries, \"bucketBoundaries\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fb653a5f2e7df696ff932c8f1e20654cf160bf"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExMjcxOQ==", "bodyText": "done.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/857#discussion_r379112719", "createdAt": "2020-02-13T20:54:06Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/view/Aggregations.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import io.opentelemetry.internal.Utils;\n+import io.opentelemetry.sdk.metrics.aggregator.AggregatorFactory;\n+import io.opentelemetry.sdk.metrics.aggregator.DoubleSumAggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.LongSumAggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.NoopAggregator;\n+import io.opentelemetry.sdk.metrics.common.InstrumentType;\n+import io.opentelemetry.sdk.metrics.common.InstrumentValueType;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor.Type;\n+import javax.annotation.concurrent.Immutable;\n+\n+public class Aggregations {\n+\n+  /**\n+   * Aggregation that calculates sum of recorded measurements.\n+   *\n+   * @since 0.1.0\n+   */\n+  public static Aggregation sum() {\n+    return Sum.INSTANCE;\n+  }\n+\n+  /**\n+   * Aggregation that calculates count of recorded measurements (the number of recorded\n+   * measurements).\n+   *\n+   * @since 0.1.0\n+   */\n+  public static Aggregation count() {\n+    return Count.INSTANCE;\n+  }\n+\n+  /**\n+   * Aggregation that calculates distribution stats on recorded measurements. Distribution includes\n+   * sum, count, histogram, and sum of squared deviations.\n+   *\n+   * <p>The boundaries for the buckets in the underlying histogram needs to be sorted.\n+   *\n+   * @param bucketBoundaries bucket boundaries to use for distribution.\n+   * @return a new {@code Distribution}.\n+   * @since 0.1.0\n+   */\n+  public static Aggregation distributionWithExplicitBounds(Double... bucketBoundaries) {\n+    return new Distribution(bucketBoundaries);\n+  }\n+\n+  /**\n+   * Aggregation that calculates the last value of all recorded measurements.\n+   *\n+   * @since 0.1.0\n+   */\n+  public static Aggregation lastValue() {\n+    return LastValue.INSTANCE;\n+  }\n+\n+  @Immutable\n+  private enum Sum implements Aggregation {\n+    INSTANCE;\n+\n+    @Override\n+    public AggregatorFactory getAggregatorFactory(InstrumentValueType instrumentValueType) {\n+      return instrumentValueType == InstrumentValueType.LONG\n+          ? LongSumAggregator.getFactory()\n+          : DoubleSumAggregator.getFactory();\n+    }\n+\n+    @Override\n+    public Type getDescriptorType(\n+        InstrumentType instrumentType, InstrumentValueType instrumentValueType) {\n+      switch (instrumentType) {\n+        case COUNTER_MONOTONIC:\n+        case MEASURE_ABSOLUTE:\n+        case OBSERVER_MONOTONIC:\n+          return instrumentValueType == InstrumentValueType.LONG\n+              ? Type.MONOTONIC_LONG\n+              : Type.MONOTONIC_DOUBLE;\n+        case COUNTER_NON_MONOTONIC:\n+        case MEASURE_NON_ABSOLUTE:\n+        case OBSERVER_NON_MONOTONIC:\n+          return instrumentValueType == InstrumentValueType.LONG\n+              ? Type.NON_MONOTONIC_LONG\n+              : Type.NON_MONOTONIC_DOUBLE;\n+      }\n+      throw new IllegalArgumentException(\"This should not happen\");\n+    }\n+\n+    @Override\n+    public boolean availableForInstrument(InstrumentType instrumentType) {\n+      // Available for all instruments.\n+      return true;\n+    }\n+  }\n+\n+  @Immutable\n+  private enum Count implements Aggregation {\n+    INSTANCE;\n+\n+    @Override\n+    public AggregatorFactory getAggregatorFactory(InstrumentValueType instrumentValueType) {\n+      // TODO: Implement count aggregator and use it here.\n+      return NoopAggregator.getFactory();\n+    }\n+\n+    @Override\n+    public Type getDescriptorType(\n+        InstrumentType instrumentType, InstrumentValueType instrumentValueType) {\n+      return Type.MONOTONIC_LONG;\n+    }\n+\n+    @Override\n+    public boolean availableForInstrument(InstrumentType instrumentType) {\n+      // It is not available for Observer instruments.\n+      return instrumentType != InstrumentType.OBSERVER_MONOTONIC\n+          && instrumentType != InstrumentType.OBSERVER_NON_MONOTONIC;\n+    }\n+  }\n+\n+  @Immutable\n+  private static final class Distribution implements Aggregation {\n+    private final AggregatorFactory factory;\n+\n+    Distribution(Double... bucketBoundaries) {\n+      Utils.checkNotNull(bucketBoundaries, \"bucketBoundaries\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwODkzMg=="}, "originalCommit": {"oid": "c7fb653a5f2e7df696ff932c8f1e20654cf160bf"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NTU5Mjk1OnYy", "diffSide": "RIGHT", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/view/Aggregations.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDo0NjozNFrOFpjALw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDo1NDoxMVrOFpjNLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwOTQyMw==", "bodyText": "change message to \"Unsupported instrument/value types\"", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/857#discussion_r379109423", "createdAt": "2020-02-13T20:46:34Z", "author": {"login": "jkwatson"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/view/Aggregations.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import io.opentelemetry.internal.Utils;\n+import io.opentelemetry.sdk.metrics.aggregator.AggregatorFactory;\n+import io.opentelemetry.sdk.metrics.aggregator.DoubleSumAggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.LongSumAggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.NoopAggregator;\n+import io.opentelemetry.sdk.metrics.common.InstrumentType;\n+import io.opentelemetry.sdk.metrics.common.InstrumentValueType;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor.Type;\n+import javax.annotation.concurrent.Immutable;\n+\n+public class Aggregations {\n+\n+  /**\n+   * Aggregation that calculates sum of recorded measurements.\n+   *\n+   * @since 0.1.0\n+   */\n+  public static Aggregation sum() {\n+    return Sum.INSTANCE;\n+  }\n+\n+  /**\n+   * Aggregation that calculates count of recorded measurements (the number of recorded\n+   * measurements).\n+   *\n+   * @since 0.1.0\n+   */\n+  public static Aggregation count() {\n+    return Count.INSTANCE;\n+  }\n+\n+  /**\n+   * Aggregation that calculates distribution stats on recorded measurements. Distribution includes\n+   * sum, count, histogram, and sum of squared deviations.\n+   *\n+   * <p>The boundaries for the buckets in the underlying histogram needs to be sorted.\n+   *\n+   * @param bucketBoundaries bucket boundaries to use for distribution.\n+   * @return a new {@code Distribution}.\n+   * @since 0.1.0\n+   */\n+  public static Aggregation distributionWithExplicitBounds(Double... bucketBoundaries) {\n+    return new Distribution(bucketBoundaries);\n+  }\n+\n+  /**\n+   * Aggregation that calculates the last value of all recorded measurements.\n+   *\n+   * @since 0.1.0\n+   */\n+  public static Aggregation lastValue() {\n+    return LastValue.INSTANCE;\n+  }\n+\n+  @Immutable\n+  private enum Sum implements Aggregation {\n+    INSTANCE;\n+\n+    @Override\n+    public AggregatorFactory getAggregatorFactory(InstrumentValueType instrumentValueType) {\n+      return instrumentValueType == InstrumentValueType.LONG\n+          ? LongSumAggregator.getFactory()\n+          : DoubleSumAggregator.getFactory();\n+    }\n+\n+    @Override\n+    public Type getDescriptorType(\n+        InstrumentType instrumentType, InstrumentValueType instrumentValueType) {\n+      switch (instrumentType) {\n+        case COUNTER_MONOTONIC:\n+        case MEASURE_ABSOLUTE:\n+        case OBSERVER_MONOTONIC:\n+          return instrumentValueType == InstrumentValueType.LONG\n+              ? Type.MONOTONIC_LONG\n+              : Type.MONOTONIC_DOUBLE;\n+        case COUNTER_NON_MONOTONIC:\n+        case MEASURE_NON_ABSOLUTE:\n+        case OBSERVER_NON_MONOTONIC:\n+          return instrumentValueType == InstrumentValueType.LONG\n+              ? Type.NON_MONOTONIC_LONG\n+              : Type.NON_MONOTONIC_DOUBLE;\n+      }\n+      throw new IllegalArgumentException(\"This should not happen\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7fb653a5f2e7df696ff932c8f1e20654cf160bf"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExMjc1MQ==", "bodyText": "done.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/857#discussion_r379112751", "createdAt": "2020-02-13T20:54:11Z", "author": {"login": "bogdandrutu"}, "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/view/Aggregations.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics.view;\n+\n+import io.opentelemetry.internal.Utils;\n+import io.opentelemetry.sdk.metrics.aggregator.AggregatorFactory;\n+import io.opentelemetry.sdk.metrics.aggregator.DoubleSumAggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.LongSumAggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.NoopAggregator;\n+import io.opentelemetry.sdk.metrics.common.InstrumentType;\n+import io.opentelemetry.sdk.metrics.common.InstrumentValueType;\n+import io.opentelemetry.sdk.metrics.data.MetricData.Descriptor.Type;\n+import javax.annotation.concurrent.Immutable;\n+\n+public class Aggregations {\n+\n+  /**\n+   * Aggregation that calculates sum of recorded measurements.\n+   *\n+   * @since 0.1.0\n+   */\n+  public static Aggregation sum() {\n+    return Sum.INSTANCE;\n+  }\n+\n+  /**\n+   * Aggregation that calculates count of recorded measurements (the number of recorded\n+   * measurements).\n+   *\n+   * @since 0.1.0\n+   */\n+  public static Aggregation count() {\n+    return Count.INSTANCE;\n+  }\n+\n+  /**\n+   * Aggregation that calculates distribution stats on recorded measurements. Distribution includes\n+   * sum, count, histogram, and sum of squared deviations.\n+   *\n+   * <p>The boundaries for the buckets in the underlying histogram needs to be sorted.\n+   *\n+   * @param bucketBoundaries bucket boundaries to use for distribution.\n+   * @return a new {@code Distribution}.\n+   * @since 0.1.0\n+   */\n+  public static Aggregation distributionWithExplicitBounds(Double... bucketBoundaries) {\n+    return new Distribution(bucketBoundaries);\n+  }\n+\n+  /**\n+   * Aggregation that calculates the last value of all recorded measurements.\n+   *\n+   * @since 0.1.0\n+   */\n+  public static Aggregation lastValue() {\n+    return LastValue.INSTANCE;\n+  }\n+\n+  @Immutable\n+  private enum Sum implements Aggregation {\n+    INSTANCE;\n+\n+    @Override\n+    public AggregatorFactory getAggregatorFactory(InstrumentValueType instrumentValueType) {\n+      return instrumentValueType == InstrumentValueType.LONG\n+          ? LongSumAggregator.getFactory()\n+          : DoubleSumAggregator.getFactory();\n+    }\n+\n+    @Override\n+    public Type getDescriptorType(\n+        InstrumentType instrumentType, InstrumentValueType instrumentValueType) {\n+      switch (instrumentType) {\n+        case COUNTER_MONOTONIC:\n+        case MEASURE_ABSOLUTE:\n+        case OBSERVER_MONOTONIC:\n+          return instrumentValueType == InstrumentValueType.LONG\n+              ? Type.MONOTONIC_LONG\n+              : Type.MONOTONIC_DOUBLE;\n+        case COUNTER_NON_MONOTONIC:\n+        case MEASURE_NON_ABSOLUTE:\n+        case OBSERVER_NON_MONOTONIC:\n+          return instrumentValueType == InstrumentValueType.LONG\n+              ? Type.NON_MONOTONIC_LONG\n+              : Type.NON_MONOTONIC_DOUBLE;\n+      }\n+      throw new IllegalArgumentException(\"This should not happen\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwOTQyMw=="}, "originalCommit": {"oid": "c7fb653a5f2e7df696ff932c8f1e20654cf160bf"}, "originalPosition": 101}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1097, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}