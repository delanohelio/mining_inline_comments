{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1ODk4NjMw", "number": 984, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNDo0MTowMVrODmtaCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNDoxMDowNVrODm7s3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxOTE2NDI1OnYy", "diffSide": "RIGHT", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/OtlpGrpcSpanExporter.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNDo0MTowMVrOF0R8OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxODo0NDo0NlrOF0cUWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM2NDIxNg==", "bodyText": "I thought that we had decided that retrying would be the responsibility of the exporter, and that we wouldn't use this code any more. I guess that never got changed, but I still think the exporter should handle its own retries. (also, I don't think any of the span processors currently do any retry logic).", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390364216", "createdAt": "2020-03-10T14:41:01Z", "author": {"login": "jkwatson"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/OtlpGrpcSpanExporter.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.grpc.ManagedChannel;\n+import io.grpc.StatusRuntimeException;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;\n+import io.opentelemetry.proto.collector.trace.v1.TraceServiceGrpc;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans using OTLP via gRPC, using OpenTelemetry's protobuf model. */\n+@ThreadSafe\n+public final class OtlpGrpcSpanExporter implements SpanExporter {\n+  private static final Logger logger = Logger.getLogger(OtlpGrpcSpanExporter.class.getName());\n+\n+  private final TraceServiceGrpc.TraceServiceBlockingStub blockingStub;\n+  private final ManagedChannel managedChannel;\n+  private final long deadline;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.\n+   *\n+   * @param channel the channel to use when communicating with the Jaeger Collector.\n+   * @param deadline max waiting time for the collector to process each span batch. When set to 0 or\n+   *     to a negative value, the exporter will wait indefinitely.\n+   */\n+  private OtlpGrpcSpanExporter(ManagedChannel channel, long deadline) {\n+    this.managedChannel = channel;\n+    this.blockingStub = TraceServiceGrpc.newBlockingStub(channel);\n+    this.deadline = deadline;\n+  }\n+\n+  /**\n+   * Submits all the given spans in a single batch to the Jaeger collector.\n+   *\n+   * @param spans the list of sampled Spans to be exported.\n+   * @return the result of the operation\n+   */\n+  @Override\n+  public ResultCode export(List<SpanData> spans) {\n+    ExportTraceServiceRequest exportTraceServiceRequest =\n+        ExportTraceServiceRequest.newBuilder()\n+            .addAllResourceSpans(SpanAdapter.toProtoResourceSpans(spans))\n+            .build();\n+\n+    try {\n+      TraceServiceGrpc.TraceServiceBlockingStub stub = this.blockingStub;\n+      if (deadline > 0) {\n+        stub = stub.withDeadlineAfter(deadline, TimeUnit.MILLISECONDS);\n+      }\n+\n+      // for now, there's nothing to check in the response object\n+      // noinspection ResultOfMethodCallIgnored\n+      stub.export(exportTraceServiceRequest);\n+      return ResultCode.SUCCESS;\n+    } catch (StatusRuntimeException e) {\n+      // Retryable codes from https://github.com/open-telemetry/oteps/pull/65\n+      switch (e.getStatus().getCode()) {\n+        case CANCELLED:\n+        case DEADLINE_EXCEEDED:\n+        case RESOURCE_EXHAUSTED:\n+        case OUT_OF_RANGE:\n+        case UNAVAILABLE:\n+        case DATA_LOSS:\n+          return ResultCode.FAILED_RETRYABLE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19996d87b34ed932e8079d2aa87e39a1c3e59ab6"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM5NzQ4NA==", "bodyText": "Looks like this is still in the spec. I'll open up a spec issue to discuss.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390397484", "createdAt": "2020-03-10T15:23:36Z", "author": {"login": "jkwatson"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/OtlpGrpcSpanExporter.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.grpc.ManagedChannel;\n+import io.grpc.StatusRuntimeException;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;\n+import io.opentelemetry.proto.collector.trace.v1.TraceServiceGrpc;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans using OTLP via gRPC, using OpenTelemetry's protobuf model. */\n+@ThreadSafe\n+public final class OtlpGrpcSpanExporter implements SpanExporter {\n+  private static final Logger logger = Logger.getLogger(OtlpGrpcSpanExporter.class.getName());\n+\n+  private final TraceServiceGrpc.TraceServiceBlockingStub blockingStub;\n+  private final ManagedChannel managedChannel;\n+  private final long deadline;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.\n+   *\n+   * @param channel the channel to use when communicating with the Jaeger Collector.\n+   * @param deadline max waiting time for the collector to process each span batch. When set to 0 or\n+   *     to a negative value, the exporter will wait indefinitely.\n+   */\n+  private OtlpGrpcSpanExporter(ManagedChannel channel, long deadline) {\n+    this.managedChannel = channel;\n+    this.blockingStub = TraceServiceGrpc.newBlockingStub(channel);\n+    this.deadline = deadline;\n+  }\n+\n+  /**\n+   * Submits all the given spans in a single batch to the Jaeger collector.\n+   *\n+   * @param spans the list of sampled Spans to be exported.\n+   * @return the result of the operation\n+   */\n+  @Override\n+  public ResultCode export(List<SpanData> spans) {\n+    ExportTraceServiceRequest exportTraceServiceRequest =\n+        ExportTraceServiceRequest.newBuilder()\n+            .addAllResourceSpans(SpanAdapter.toProtoResourceSpans(spans))\n+            .build();\n+\n+    try {\n+      TraceServiceGrpc.TraceServiceBlockingStub stub = this.blockingStub;\n+      if (deadline > 0) {\n+        stub = stub.withDeadlineAfter(deadline, TimeUnit.MILLISECONDS);\n+      }\n+\n+      // for now, there's nothing to check in the response object\n+      // noinspection ResultOfMethodCallIgnored\n+      stub.export(exportTraceServiceRequest);\n+      return ResultCode.SUCCESS;\n+    } catch (StatusRuntimeException e) {\n+      // Retryable codes from https://github.com/open-telemetry/oteps/pull/65\n+      switch (e.getStatus().getCode()) {\n+        case CANCELLED:\n+        case DEADLINE_EXCEEDED:\n+        case RESOURCE_EXHAUSTED:\n+        case OUT_OF_RANGE:\n+        case UNAVAILABLE:\n+        case DATA_LOSS:\n+          return ResultCode.FAILED_RETRYABLE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM2NDIxNg=="}, "originalCommit": {"oid": "19996d87b34ed932e8079d2aa87e39a1c3e59ab6"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQwNDE1NQ==", "bodyText": "open-telemetry/opentelemetry-specification#509", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390404155", "createdAt": "2020-03-10T15:32:08Z", "author": {"login": "jkwatson"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/OtlpGrpcSpanExporter.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.grpc.ManagedChannel;\n+import io.grpc.StatusRuntimeException;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;\n+import io.opentelemetry.proto.collector.trace.v1.TraceServiceGrpc;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans using OTLP via gRPC, using OpenTelemetry's protobuf model. */\n+@ThreadSafe\n+public final class OtlpGrpcSpanExporter implements SpanExporter {\n+  private static final Logger logger = Logger.getLogger(OtlpGrpcSpanExporter.class.getName());\n+\n+  private final TraceServiceGrpc.TraceServiceBlockingStub blockingStub;\n+  private final ManagedChannel managedChannel;\n+  private final long deadline;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.\n+   *\n+   * @param channel the channel to use when communicating with the Jaeger Collector.\n+   * @param deadline max waiting time for the collector to process each span batch. When set to 0 or\n+   *     to a negative value, the exporter will wait indefinitely.\n+   */\n+  private OtlpGrpcSpanExporter(ManagedChannel channel, long deadline) {\n+    this.managedChannel = channel;\n+    this.blockingStub = TraceServiceGrpc.newBlockingStub(channel);\n+    this.deadline = deadline;\n+  }\n+\n+  /**\n+   * Submits all the given spans in a single batch to the Jaeger collector.\n+   *\n+   * @param spans the list of sampled Spans to be exported.\n+   * @return the result of the operation\n+   */\n+  @Override\n+  public ResultCode export(List<SpanData> spans) {\n+    ExportTraceServiceRequest exportTraceServiceRequest =\n+        ExportTraceServiceRequest.newBuilder()\n+            .addAllResourceSpans(SpanAdapter.toProtoResourceSpans(spans))\n+            .build();\n+\n+    try {\n+      TraceServiceGrpc.TraceServiceBlockingStub stub = this.blockingStub;\n+      if (deadline > 0) {\n+        stub = stub.withDeadlineAfter(deadline, TimeUnit.MILLISECONDS);\n+      }\n+\n+      // for now, there's nothing to check in the response object\n+      // noinspection ResultOfMethodCallIgnored\n+      stub.export(exportTraceServiceRequest);\n+      return ResultCode.SUCCESS;\n+    } catch (StatusRuntimeException e) {\n+      // Retryable codes from https://github.com/open-telemetry/oteps/pull/65\n+      switch (e.getStatus().getCode()) {\n+        case CANCELLED:\n+        case DEADLINE_EXCEEDED:\n+        case RESOURCE_EXHAUSTED:\n+        case OUT_OF_RANGE:\n+        case UNAVAILABLE:\n+        case DATA_LOSS:\n+          return ResultCode.FAILED_RETRYABLE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM2NDIxNg=="}, "originalCommit": {"oid": "19996d87b34ed932e8079d2aa87e39a1c3e59ab6"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUzNDIzNA==", "bodyText": "As explained in that issue, this is an exporter so then I need to implement retry logic and I will use the same logic to determine when to retry.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390534234", "createdAt": "2020-03-10T18:44:46Z", "author": {"login": "bogdandrutu"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/OtlpGrpcSpanExporter.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.grpc.ManagedChannel;\n+import io.grpc.StatusRuntimeException;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;\n+import io.opentelemetry.proto.collector.trace.v1.TraceServiceGrpc;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans using OTLP via gRPC, using OpenTelemetry's protobuf model. */\n+@ThreadSafe\n+public final class OtlpGrpcSpanExporter implements SpanExporter {\n+  private static final Logger logger = Logger.getLogger(OtlpGrpcSpanExporter.class.getName());\n+\n+  private final TraceServiceGrpc.TraceServiceBlockingStub blockingStub;\n+  private final ManagedChannel managedChannel;\n+  private final long deadline;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.\n+   *\n+   * @param channel the channel to use when communicating with the Jaeger Collector.\n+   * @param deadline max waiting time for the collector to process each span batch. When set to 0 or\n+   *     to a negative value, the exporter will wait indefinitely.\n+   */\n+  private OtlpGrpcSpanExporter(ManagedChannel channel, long deadline) {\n+    this.managedChannel = channel;\n+    this.blockingStub = TraceServiceGrpc.newBlockingStub(channel);\n+    this.deadline = deadline;\n+  }\n+\n+  /**\n+   * Submits all the given spans in a single batch to the Jaeger collector.\n+   *\n+   * @param spans the list of sampled Spans to be exported.\n+   * @return the result of the operation\n+   */\n+  @Override\n+  public ResultCode export(List<SpanData> spans) {\n+    ExportTraceServiceRequest exportTraceServiceRequest =\n+        ExportTraceServiceRequest.newBuilder()\n+            .addAllResourceSpans(SpanAdapter.toProtoResourceSpans(spans))\n+            .build();\n+\n+    try {\n+      TraceServiceGrpc.TraceServiceBlockingStub stub = this.blockingStub;\n+      if (deadline > 0) {\n+        stub = stub.withDeadlineAfter(deadline, TimeUnit.MILLISECONDS);\n+      }\n+\n+      // for now, there's nothing to check in the response object\n+      // noinspection ResultOfMethodCallIgnored\n+      stub.export(exportTraceServiceRequest);\n+      return ResultCode.SUCCESS;\n+    } catch (StatusRuntimeException e) {\n+      // Retryable codes from https://github.com/open-telemetry/oteps/pull/65\n+      switch (e.getStatus().getCode()) {\n+        case CANCELLED:\n+        case DEADLINE_EXCEEDED:\n+        case RESOURCE_EXHAUSTED:\n+        case OUT_OF_RANGE:\n+        case UNAVAILABLE:\n+        case DATA_LOSS:\n+          return ResultCode.FAILED_RETRYABLE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM2NDIxNg=="}, "originalCommit": {"oid": "19996d87b34ed932e8079d2aa87e39a1c3e59ab6"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxOTIxNDgzOnYy", "diffSide": "RIGHT", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/OtlpGrpcSpanExporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNDo1MTowN1rOF0Sbgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNTowMjozM1rOF0S_Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3MjIyNw==", "bodyText": "rather than the comment, name the variable \"deadlineMillis\"", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390372227", "createdAt": "2020-03-10T14:51:07Z", "author": {"login": "jkwatson"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/OtlpGrpcSpanExporter.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.grpc.ManagedChannel;\n+import io.grpc.StatusRuntimeException;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;\n+import io.opentelemetry.proto.collector.trace.v1.TraceServiceGrpc;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans using OTLP via gRPC, using OpenTelemetry's protobuf model. */\n+@ThreadSafe\n+public final class OtlpGrpcSpanExporter implements SpanExporter {\n+  private static final Logger logger = Logger.getLogger(OtlpGrpcSpanExporter.class.getName());\n+\n+  private final TraceServiceGrpc.TraceServiceBlockingStub blockingStub;\n+  private final ManagedChannel managedChannel;\n+  private final long deadline;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.\n+   *\n+   * @param channel the channel to use when communicating with the Jaeger Collector.\n+   * @param deadline max waiting time for the collector to process each span batch. When set to 0 or\n+   *     to a negative value, the exporter will wait indefinitely.\n+   */\n+  private OtlpGrpcSpanExporter(ManagedChannel channel, long deadline) {\n+    this.managedChannel = channel;\n+    this.blockingStub = TraceServiceGrpc.newBlockingStub(channel);\n+    this.deadline = deadline;\n+  }\n+\n+  /**\n+   * Submits all the given spans in a single batch to the Jaeger collector.\n+   *\n+   * @param spans the list of sampled Spans to be exported.\n+   * @return the result of the operation\n+   */\n+  @Override\n+  public ResultCode export(List<SpanData> spans) {\n+    ExportTraceServiceRequest exportTraceServiceRequest =\n+        ExportTraceServiceRequest.newBuilder()\n+            .addAllResourceSpans(SpanAdapter.toProtoResourceSpans(spans))\n+            .build();\n+\n+    try {\n+      TraceServiceGrpc.TraceServiceBlockingStub stub = this.blockingStub;\n+      if (deadline > 0) {\n+        stub = stub.withDeadlineAfter(deadline, TimeUnit.MILLISECONDS);\n+      }\n+\n+      // for now, there's nothing to check in the response object\n+      // noinspection ResultOfMethodCallIgnored\n+      stub.export(exportTraceServiceRequest);\n+      return ResultCode.SUCCESS;\n+    } catch (StatusRuntimeException e) {\n+      // Retryable codes from https://github.com/open-telemetry/oteps/pull/65\n+      switch (e.getStatus().getCode()) {\n+        case CANCELLED:\n+        case DEADLINE_EXCEEDED:\n+        case RESOURCE_EXHAUSTED:\n+        case OUT_OF_RANGE:\n+        case UNAVAILABLE:\n+        case DATA_LOSS:\n+          return ResultCode.FAILED_RETRYABLE;\n+        default:\n+          return ResultCode.FAILED_NOT_RETRYABLE;\n+      }\n+    } catch (Throwable t) {\n+      return ResultCode.FAILED_NOT_RETRYABLE;\n+    }\n+  }\n+\n+  /**\n+   * Creates a new builder instance.\n+   *\n+   * @return a new instance builder for this exporter\n+   */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  /**\n+   * Initiates an orderly shutdown in which preexisting calls continue but new calls are immediately\n+   * cancelled. The channel is forcefully closed after a timeout.\n+   */\n+  @Override\n+  public void shutdown() {\n+    try {\n+      managedChannel.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n+    } catch (InterruptedException e) {\n+      logger.log(Level.WARNING, \"Failed to shutdown the gRPC channel\", e);\n+    }\n+  }\n+\n+  /** Builder utility for this exporter. */\n+  public static class Builder {\n+    private ManagedChannel channel;\n+    private long deadline = 1_000; // ms", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19996d87b34ed932e8079d2aa87e39a1c3e59ab6"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM4MTMzNQ==", "bodyText": "Done.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390381335", "createdAt": "2020-03-10T15:02:33Z", "author": {"login": "bogdandrutu"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/OtlpGrpcSpanExporter.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.grpc.ManagedChannel;\n+import io.grpc.StatusRuntimeException;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;\n+import io.opentelemetry.proto.collector.trace.v1.TraceServiceGrpc;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans using OTLP via gRPC, using OpenTelemetry's protobuf model. */\n+@ThreadSafe\n+public final class OtlpGrpcSpanExporter implements SpanExporter {\n+  private static final Logger logger = Logger.getLogger(OtlpGrpcSpanExporter.class.getName());\n+\n+  private final TraceServiceGrpc.TraceServiceBlockingStub blockingStub;\n+  private final ManagedChannel managedChannel;\n+  private final long deadline;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.\n+   *\n+   * @param channel the channel to use when communicating with the Jaeger Collector.\n+   * @param deadline max waiting time for the collector to process each span batch. When set to 0 or\n+   *     to a negative value, the exporter will wait indefinitely.\n+   */\n+  private OtlpGrpcSpanExporter(ManagedChannel channel, long deadline) {\n+    this.managedChannel = channel;\n+    this.blockingStub = TraceServiceGrpc.newBlockingStub(channel);\n+    this.deadline = deadline;\n+  }\n+\n+  /**\n+   * Submits all the given spans in a single batch to the Jaeger collector.\n+   *\n+   * @param spans the list of sampled Spans to be exported.\n+   * @return the result of the operation\n+   */\n+  @Override\n+  public ResultCode export(List<SpanData> spans) {\n+    ExportTraceServiceRequest exportTraceServiceRequest =\n+        ExportTraceServiceRequest.newBuilder()\n+            .addAllResourceSpans(SpanAdapter.toProtoResourceSpans(spans))\n+            .build();\n+\n+    try {\n+      TraceServiceGrpc.TraceServiceBlockingStub stub = this.blockingStub;\n+      if (deadline > 0) {\n+        stub = stub.withDeadlineAfter(deadline, TimeUnit.MILLISECONDS);\n+      }\n+\n+      // for now, there's nothing to check in the response object\n+      // noinspection ResultOfMethodCallIgnored\n+      stub.export(exportTraceServiceRequest);\n+      return ResultCode.SUCCESS;\n+    } catch (StatusRuntimeException e) {\n+      // Retryable codes from https://github.com/open-telemetry/oteps/pull/65\n+      switch (e.getStatus().getCode()) {\n+        case CANCELLED:\n+        case DEADLINE_EXCEEDED:\n+        case RESOURCE_EXHAUSTED:\n+        case OUT_OF_RANGE:\n+        case UNAVAILABLE:\n+        case DATA_LOSS:\n+          return ResultCode.FAILED_RETRYABLE;\n+        default:\n+          return ResultCode.FAILED_NOT_RETRYABLE;\n+      }\n+    } catch (Throwable t) {\n+      return ResultCode.FAILED_NOT_RETRYABLE;\n+    }\n+  }\n+\n+  /**\n+   * Creates a new builder instance.\n+   *\n+   * @return a new instance builder for this exporter\n+   */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  /**\n+   * Initiates an orderly shutdown in which preexisting calls continue but new calls are immediately\n+   * cancelled. The channel is forcefully closed after a timeout.\n+   */\n+  @Override\n+  public void shutdown() {\n+    try {\n+      managedChannel.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n+    } catch (InterruptedException e) {\n+      logger.log(Level.WARNING, \"Failed to shutdown the gRPC channel\", e);\n+    }\n+  }\n+\n+  /** Builder utility for this exporter. */\n+  public static class Builder {\n+    private ManagedChannel channel;\n+    private long deadline = 1_000; // ms", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3MjIyNw=="}, "originalCommit": {"oid": "19996d87b34ed932e8079d2aa87e39a1c3e59ab6"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxOTI0MzEzOnYy", "diffSide": "RIGHT", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/SpanAdapter.java", "isResolved": true, "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNDo1NjozMlrOF0SsxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMjozNDoyOFrOF0jZ0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3NjY0NA==", "bodyText": "Can we really have more than one Resource per SDK? I wonder if we should pass the Resource in at the top level of the export API, rather than have to make every exporter do this convoluted logic.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390376644", "createdAt": "2020-03-10T14:56:32Z", "author": {"login": "jkwatson"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/SpanAdapter.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.opentelemetry.proto.trace.v1.ResourceSpans;\n+import io.opentelemetry.proto.trace.v1.Span;\n+import io.opentelemetry.proto.trace.v1.Span.SpanKind;\n+import io.opentelemetry.proto.trace.v1.Status;\n+import io.opentelemetry.proto.trace.v1.Status.StatusCode;\n+import io.opentelemetry.sdk.contrib.otproto.TraceProtoUtils;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.TimedEvent;\n+import io.opentelemetry.trace.AttributeValue;\n+import io.opentelemetry.trace.Link;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+final class SpanAdapter {\n+  static List<ResourceSpans> toProtoResourceSpans(List<SpanData> spanDataList) {\n+    Map<Resource, ResourceSpans.Builder> resourceSpansBuilderMap = new HashMap<>();\n+    for (SpanData spanData : spanDataList) {\n+      Resource resource = spanData.getResource();\n+      ResourceSpans.Builder resourceSpansBuilder =\n+          resourceSpansBuilderMap.get(spanData.getResource());\n+      if (resourceSpansBuilder == null) {\n+        resourceSpansBuilder =\n+            ResourceSpans.newBuilder().setResource(ResourceAdapter.toProtoResource(resource));\n+        resourceSpansBuilderMap.put(resource, resourceSpansBuilder);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19996d87b34ed932e8079d2aa87e39a1c3e59ab6"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3OTkyOQ==", "bodyText": "We can have multiple instances of the SDK, but not multiple Resources per SDK. Maybe we should file an issue for this.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390379929", "createdAt": "2020-03-10T15:00:40Z", "author": {"login": "bogdandrutu"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/SpanAdapter.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.opentelemetry.proto.trace.v1.ResourceSpans;\n+import io.opentelemetry.proto.trace.v1.Span;\n+import io.opentelemetry.proto.trace.v1.Span.SpanKind;\n+import io.opentelemetry.proto.trace.v1.Status;\n+import io.opentelemetry.proto.trace.v1.Status.StatusCode;\n+import io.opentelemetry.sdk.contrib.otproto.TraceProtoUtils;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.TimedEvent;\n+import io.opentelemetry.trace.AttributeValue;\n+import io.opentelemetry.trace.Link;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+final class SpanAdapter {\n+  static List<ResourceSpans> toProtoResourceSpans(List<SpanData> spanDataList) {\n+    Map<Resource, ResourceSpans.Builder> resourceSpansBuilderMap = new HashMap<>();\n+    for (SpanData spanData : spanDataList) {\n+      Resource resource = spanData.getResource();\n+      ResourceSpans.Builder resourceSpansBuilder =\n+          resourceSpansBuilderMap.get(spanData.getResource());\n+      if (resourceSpansBuilder == null) {\n+        resourceSpansBuilder =\n+            ResourceSpans.newBuilder().setResource(ResourceAdapter.toProtoResource(resource));\n+        resourceSpansBuilderMap.put(resource, resourceSpansBuilder);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3NjY0NA=="}, "originalCommit": {"oid": "19996d87b34ed932e8079d2aa87e39a1c3e59ab6"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM5Mjk3NA==", "bodyText": "ok. Let's extract this bit that builds the map into it's own method, for clarity.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390392974", "createdAt": "2020-03-10T15:17:42Z", "author": {"login": "jkwatson"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/SpanAdapter.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.opentelemetry.proto.trace.v1.ResourceSpans;\n+import io.opentelemetry.proto.trace.v1.Span;\n+import io.opentelemetry.proto.trace.v1.Span.SpanKind;\n+import io.opentelemetry.proto.trace.v1.Status;\n+import io.opentelemetry.proto.trace.v1.Status.StatusCode;\n+import io.opentelemetry.sdk.contrib.otproto.TraceProtoUtils;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.TimedEvent;\n+import io.opentelemetry.trace.AttributeValue;\n+import io.opentelemetry.trace.Link;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+final class SpanAdapter {\n+  static List<ResourceSpans> toProtoResourceSpans(List<SpanData> spanDataList) {\n+    Map<Resource, ResourceSpans.Builder> resourceSpansBuilderMap = new HashMap<>();\n+    for (SpanData spanData : spanDataList) {\n+      Resource resource = spanData.getResource();\n+      ResourceSpans.Builder resourceSpansBuilder =\n+          resourceSpansBuilderMap.get(spanData.getResource());\n+      if (resourceSpansBuilder == null) {\n+        resourceSpansBuilder =\n+            ResourceSpans.newBuilder().setResource(ResourceAdapter.toProtoResource(resource));\n+        resourceSpansBuilderMap.put(resource, resourceSpansBuilder);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3NjY0NA=="}, "originalCommit": {"oid": "19996d87b34ed932e8079d2aa87e39a1c3e59ab6"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU1Nzk1OQ==", "bodyText": "I think the logic is pretty isolated, can you clarify how would you like the code to be structured?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390557959", "createdAt": "2020-03-10T19:26:07Z", "author": {"login": "bogdandrutu"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/SpanAdapter.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.opentelemetry.proto.trace.v1.ResourceSpans;\n+import io.opentelemetry.proto.trace.v1.Span;\n+import io.opentelemetry.proto.trace.v1.Span.SpanKind;\n+import io.opentelemetry.proto.trace.v1.Status;\n+import io.opentelemetry.proto.trace.v1.Status.StatusCode;\n+import io.opentelemetry.sdk.contrib.otproto.TraceProtoUtils;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.TimedEvent;\n+import io.opentelemetry.trace.AttributeValue;\n+import io.opentelemetry.trace.Link;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+final class SpanAdapter {\n+  static List<ResourceSpans> toProtoResourceSpans(List<SpanData> spanDataList) {\n+    Map<Resource, ResourceSpans.Builder> resourceSpansBuilderMap = new HashMap<>();\n+    for (SpanData spanData : spanDataList) {\n+      Resource resource = spanData.getResource();\n+      ResourceSpans.Builder resourceSpansBuilder =\n+          resourceSpansBuilderMap.get(spanData.getResource());\n+      if (resourceSpansBuilder == null) {\n+        resourceSpansBuilder =\n+            ResourceSpans.newBuilder().setResource(ResourceAdapter.toProtoResource(resource));\n+        resourceSpansBuilderMap.put(resource, resourceSpansBuilder);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3NjY0NA=="}, "originalCommit": {"oid": "19996d87b34ed932e8079d2aa87e39a1c3e59ab6"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYwODUxOA==", "bodyText": "I'd just take the code that creates the Map and populates it and move it to its own method.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390608518", "createdAt": "2020-03-10T21:01:05Z", "author": {"login": "jkwatson"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/SpanAdapter.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.opentelemetry.proto.trace.v1.ResourceSpans;\n+import io.opentelemetry.proto.trace.v1.Span;\n+import io.opentelemetry.proto.trace.v1.Span.SpanKind;\n+import io.opentelemetry.proto.trace.v1.Status;\n+import io.opentelemetry.proto.trace.v1.Status.StatusCode;\n+import io.opentelemetry.sdk.contrib.otproto.TraceProtoUtils;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.TimedEvent;\n+import io.opentelemetry.trace.AttributeValue;\n+import io.opentelemetry.trace.Link;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+final class SpanAdapter {\n+  static List<ResourceSpans> toProtoResourceSpans(List<SpanData> spanDataList) {\n+    Map<Resource, ResourceSpans.Builder> resourceSpansBuilderMap = new HashMap<>();\n+    for (SpanData spanData : spanDataList) {\n+      Resource resource = spanData.getResource();\n+      ResourceSpans.Builder resourceSpansBuilder =\n+          resourceSpansBuilderMap.get(spanData.getResource());\n+      if (resourceSpansBuilder == null) {\n+        resourceSpansBuilder =\n+            ResourceSpans.newBuilder().setResource(ResourceAdapter.toProtoResource(resource));\n+        resourceSpansBuilderMap.put(resource, resourceSpansBuilder);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3NjY0NA=="}, "originalCommit": {"oid": "19996d87b34ed932e8079d2aa87e39a1c3e59ab6"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY0NzI2Ng==", "bodyText": "While I am constructing the Map I am also converting the Spans and add them to the builder. So not sure how to cleanly separate them.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390647266", "createdAt": "2020-03-10T22:26:10Z", "author": {"login": "bogdandrutu"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/SpanAdapter.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.opentelemetry.proto.trace.v1.ResourceSpans;\n+import io.opentelemetry.proto.trace.v1.Span;\n+import io.opentelemetry.proto.trace.v1.Span.SpanKind;\n+import io.opentelemetry.proto.trace.v1.Status;\n+import io.opentelemetry.proto.trace.v1.Status.StatusCode;\n+import io.opentelemetry.sdk.contrib.otproto.TraceProtoUtils;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.TimedEvent;\n+import io.opentelemetry.trace.AttributeValue;\n+import io.opentelemetry.trace.Link;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+final class SpanAdapter {\n+  static List<ResourceSpans> toProtoResourceSpans(List<SpanData> spanDataList) {\n+    Map<Resource, ResourceSpans.Builder> resourceSpansBuilderMap = new HashMap<>();\n+    for (SpanData spanData : spanDataList) {\n+      Resource resource = spanData.getResource();\n+      ResourceSpans.Builder resourceSpansBuilder =\n+          resourceSpansBuilderMap.get(spanData.getResource());\n+      if (resourceSpansBuilder == null) {\n+        resourceSpansBuilder =\n+            ResourceSpans.newBuilder().setResource(ResourceAdapter.toProtoResource(resource));\n+        resourceSpansBuilderMap.put(resource, resourceSpansBuilder);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3NjY0NA=="}, "originalCommit": {"oid": "19996d87b34ed932e8079d2aa87e39a1c3e59ab6"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY0ODMxMQ==", "bodyText": "couldn't lines 37 through 48 be a method that returns the Map<Resource, ResourceSpans.Builder>?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390648311", "createdAt": "2020-03-10T22:28:52Z", "author": {"login": "jkwatson"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/SpanAdapter.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.opentelemetry.proto.trace.v1.ResourceSpans;\n+import io.opentelemetry.proto.trace.v1.Span;\n+import io.opentelemetry.proto.trace.v1.Span.SpanKind;\n+import io.opentelemetry.proto.trace.v1.Status;\n+import io.opentelemetry.proto.trace.v1.Status.StatusCode;\n+import io.opentelemetry.sdk.contrib.otproto.TraceProtoUtils;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.TimedEvent;\n+import io.opentelemetry.trace.AttributeValue;\n+import io.opentelemetry.trace.Link;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+final class SpanAdapter {\n+  static List<ResourceSpans> toProtoResourceSpans(List<SpanData> spanDataList) {\n+    Map<Resource, ResourceSpans.Builder> resourceSpansBuilderMap = new HashMap<>();\n+    for (SpanData spanData : spanDataList) {\n+      Resource resource = spanData.getResource();\n+      ResourceSpans.Builder resourceSpansBuilder =\n+          resourceSpansBuilderMap.get(spanData.getResource());\n+      if (resourceSpansBuilder == null) {\n+        resourceSpansBuilder =\n+            ResourceSpans.newBuilder().setResource(ResourceAdapter.toProtoResource(resource));\n+        resourceSpansBuilderMap.put(resource, resourceSpansBuilder);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3NjY0NA=="}, "originalCommit": {"oid": "19996d87b34ed932e8079d2aa87e39a1c3e59ab6"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY0OTE4MQ==", "bodyText": "Yes but that method also converts Spans so for me it is not that of a clear separation.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390649181", "createdAt": "2020-03-10T22:31:18Z", "author": {"login": "bogdandrutu"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/SpanAdapter.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.opentelemetry.proto.trace.v1.ResourceSpans;\n+import io.opentelemetry.proto.trace.v1.Span;\n+import io.opentelemetry.proto.trace.v1.Span.SpanKind;\n+import io.opentelemetry.proto.trace.v1.Status;\n+import io.opentelemetry.proto.trace.v1.Status.StatusCode;\n+import io.opentelemetry.sdk.contrib.otproto.TraceProtoUtils;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.TimedEvent;\n+import io.opentelemetry.trace.AttributeValue;\n+import io.opentelemetry.trace.Link;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+final class SpanAdapter {\n+  static List<ResourceSpans> toProtoResourceSpans(List<SpanData> spanDataList) {\n+    Map<Resource, ResourceSpans.Builder> resourceSpansBuilderMap = new HashMap<>();\n+    for (SpanData spanData : spanDataList) {\n+      Resource resource = spanData.getResource();\n+      ResourceSpans.Builder resourceSpansBuilder =\n+          resourceSpansBuilderMap.get(spanData.getResource());\n+      if (resourceSpansBuilder == null) {\n+        resourceSpansBuilder =\n+            ResourceSpans.newBuilder().setResource(ResourceAdapter.toProtoResource(resource));\n+        resourceSpansBuilderMap.put(resource, resourceSpansBuilder);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3NjY0NA=="}, "originalCommit": {"oid": "19996d87b34ed932e8079d2aa87e39a1c3e59ab6"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY0OTM4Nw==", "bodyText": "But if that unblocks this PR I will do it :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390649387", "createdAt": "2020-03-10T22:31:49Z", "author": {"login": "bogdandrutu"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/SpanAdapter.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.opentelemetry.proto.trace.v1.ResourceSpans;\n+import io.opentelemetry.proto.trace.v1.Span;\n+import io.opentelemetry.proto.trace.v1.Span.SpanKind;\n+import io.opentelemetry.proto.trace.v1.Status;\n+import io.opentelemetry.proto.trace.v1.Status.StatusCode;\n+import io.opentelemetry.sdk.contrib.otproto.TraceProtoUtils;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.TimedEvent;\n+import io.opentelemetry.trace.AttributeValue;\n+import io.opentelemetry.trace.Link;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+final class SpanAdapter {\n+  static List<ResourceSpans> toProtoResourceSpans(List<SpanData> spanDataList) {\n+    Map<Resource, ResourceSpans.Builder> resourceSpansBuilderMap = new HashMap<>();\n+    for (SpanData spanData : spanDataList) {\n+      Resource resource = spanData.getResource();\n+      ResourceSpans.Builder resourceSpansBuilder =\n+          resourceSpansBuilderMap.get(spanData.getResource());\n+      if (resourceSpansBuilder == null) {\n+        resourceSpansBuilder =\n+            ResourceSpans.newBuilder().setResource(ResourceAdapter.toProtoResource(resource));\n+        resourceSpansBuilderMap.put(resource, resourceSpansBuilder);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3NjY0NA=="}, "originalCommit": {"oid": "19996d87b34ed932e8079d2aa87e39a1c3e59ab6"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1MDMyMQ==", "bodyText": "I think that's fair. I won't hold it up if you want to keep it as-is. We have bigger fish to fry. :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390650321", "createdAt": "2020-03-10T22:34:28Z", "author": {"login": "jkwatson"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/SpanAdapter.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.opentelemetry.proto.trace.v1.ResourceSpans;\n+import io.opentelemetry.proto.trace.v1.Span;\n+import io.opentelemetry.proto.trace.v1.Span.SpanKind;\n+import io.opentelemetry.proto.trace.v1.Status;\n+import io.opentelemetry.proto.trace.v1.Status.StatusCode;\n+import io.opentelemetry.sdk.contrib.otproto.TraceProtoUtils;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.TimedEvent;\n+import io.opentelemetry.trace.AttributeValue;\n+import io.opentelemetry.trace.Link;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+final class SpanAdapter {\n+  static List<ResourceSpans> toProtoResourceSpans(List<SpanData> spanDataList) {\n+    Map<Resource, ResourceSpans.Builder> resourceSpansBuilderMap = new HashMap<>();\n+    for (SpanData spanData : spanDataList) {\n+      Resource resource = spanData.getResource();\n+      ResourceSpans.Builder resourceSpansBuilder =\n+          resourceSpansBuilderMap.get(spanData.getResource());\n+      if (resourceSpansBuilder == null) {\n+        resourceSpansBuilder =\n+            ResourceSpans.newBuilder().setResource(ResourceAdapter.toProtoResource(resource));\n+        resourceSpansBuilderMap.put(resource, resourceSpansBuilder);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3NjY0NA=="}, "originalCommit": {"oid": "19996d87b34ed932e8079d2aa87e39a1c3e59ab6"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTQ4OTQ4OnYy", "diffSide": "RIGHT", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/OtlpGrpcSpanExporter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMzo1Njo0M1rOF0offg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMzo1Njo0M1rOF0offg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczMzY5NA==", "bodyText": "Jaeger?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390733694", "createdAt": "2020-03-11T03:56:43Z", "author": {"login": "carlosalberto"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/OtlpGrpcSpanExporter.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.grpc.ManagedChannel;\n+import io.grpc.StatusRuntimeException;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;\n+import io.opentelemetry.proto.collector.trace.v1.TraceServiceGrpc;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans using OTLP via gRPC, using OpenTelemetry's protobuf model. */\n+@ThreadSafe\n+public final class OtlpGrpcSpanExporter implements SpanExporter {\n+  private static final Logger logger = Logger.getLogger(OtlpGrpcSpanExporter.class.getName());\n+\n+  private final TraceServiceGrpc.TraceServiceBlockingStub blockingStub;\n+  private final ManagedChannel managedChannel;\n+  private final long deadlineMs;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2715d84b5bf9075274c0af3cff32ce9135a6b403"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTQ4OTkyOnYy", "diffSide": "RIGHT", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/OtlpGrpcSpanExporter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMzo1NzowOFrOF0of0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMzo1NzowOFrOF0of0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczMzc3OQ==", "bodyText": "Same.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390733779", "createdAt": "2020-03-11T03:57:08Z", "author": {"login": "carlosalberto"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/OtlpGrpcSpanExporter.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.grpc.ManagedChannel;\n+import io.grpc.StatusRuntimeException;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;\n+import io.opentelemetry.proto.collector.trace.v1.TraceServiceGrpc;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans using OTLP via gRPC, using OpenTelemetry's protobuf model. */\n+@ThreadSafe\n+public final class OtlpGrpcSpanExporter implements SpanExporter {\n+  private static final Logger logger = Logger.getLogger(OtlpGrpcSpanExporter.class.getName());\n+\n+  private final TraceServiceGrpc.TraceServiceBlockingStub blockingStub;\n+  private final ManagedChannel managedChannel;\n+  private final long deadlineMs;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.\n+   *\n+   * @param channel the channel to use when communicating with the Jaeger Collector.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2715d84b5bf9075274c0af3cff32ce9135a6b403"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTQ5MTU3OnYy", "diffSide": "RIGHT", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/OtlpGrpcSpanExporter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMzo1ODoyMlrOF0og6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMzo1ODoyMlrOF0og6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczNDA1Ng==", "bodyText": "Jaeger, etc.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390734056", "createdAt": "2020-03-11T03:58:22Z", "author": {"login": "carlosalberto"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/OtlpGrpcSpanExporter.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.grpc.ManagedChannel;\n+import io.grpc.StatusRuntimeException;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;\n+import io.opentelemetry.proto.collector.trace.v1.TraceServiceGrpc;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans using OTLP via gRPC, using OpenTelemetry's protobuf model. */\n+@ThreadSafe\n+public final class OtlpGrpcSpanExporter implements SpanExporter {\n+  private static final Logger logger = Logger.getLogger(OtlpGrpcSpanExporter.class.getName());\n+\n+  private final TraceServiceGrpc.TraceServiceBlockingStub blockingStub;\n+  private final ManagedChannel managedChannel;\n+  private final long deadlineMs;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.\n+   *\n+   * @param channel the channel to use when communicating with the Jaeger Collector.\n+   * @param deadlineMs max waiting time for the collector to process each span batch. When set to 0\n+   *     or to a negative value, the exporter will wait indefinitely.\n+   */\n+  private OtlpGrpcSpanExporter(ManagedChannel channel, long deadlineMs) {\n+    this.managedChannel = channel;\n+    this.blockingStub = TraceServiceGrpc.newBlockingStub(channel);\n+    this.deadlineMs = deadlineMs;\n+  }\n+\n+  /**\n+   * Submits all the given spans in a single batch to the Jaeger collector.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2715d84b5bf9075274c0af3cff32ce9135a6b403"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTUwNjIzOnYy", "diffSide": "RIGHT", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/CommonAdapter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNDoxMDowNVrOF0oqBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNDoxMDowNVrOF0oqBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczNjM4OQ==", "bodyText": "Guess no multi value attributes for now? ;)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390736389", "createdAt": "2020-03-11T04:10:05Z", "author": {"login": "carlosalberto"}, "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/CommonAdapter.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.opentelemetry.proto.common.v1.AttributeKeyValue;\n+import io.opentelemetry.proto.common.v1.AttributeKeyValue.ValueType;\n+import io.opentelemetry.trace.AttributeValue;\n+\n+final class CommonAdapter {\n+  static AttributeKeyValue toProtoAttribute(String key, AttributeValue attributeValue) {\n+    AttributeKeyValue.Builder builder = AttributeKeyValue.newBuilder().setKey(key);\n+    switch (attributeValue.getType()) {\n+      case STRING:\n+        return builder\n+            .setType(ValueType.STRING)\n+            .setStringValue(attributeValue.getStringValue())\n+            .build();\n+      case BOOLEAN:\n+        return builder\n+            .setType(ValueType.BOOL)\n+            .setBoolValue(attributeValue.getBooleanValue())\n+            .build();\n+      case LONG:\n+        return builder.setType(ValueType.INT).setIntValue(attributeValue.getLongValue()).build();\n+      case DOUBLE:\n+        return builder\n+            .setType(ValueType.DOUBLE)\n+            .setDoubleValue(attributeValue.getDoubleValue())\n+            .build();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2715d84b5bf9075274c0af3cff32ce9135a6b403"}, "originalPosition": 44}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 961, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}