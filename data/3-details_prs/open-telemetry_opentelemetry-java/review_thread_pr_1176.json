{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzNDU5NTUy", "number": 1176, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMTozODoxOVrOD5XRTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNDoyNjowOFrOD6qNwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNDc2Njg2OnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMTozODoxOVrOGQlbPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMTozNjo0OVrOGSRMEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0MzU4Mw==", "bodyText": "FYI, this isn't the latest version of zipkin-junit.\nAny version of zipkin-junit newer than 2.18.3 use okhttp 4, which requires jvm >= 8", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r420043583", "createdAt": "2020-05-05T11:38:19Z", "author": {"login": "jarebudev"}, "path": "build.gradle", "diffHunk": "@@ -97,6 +97,7 @@ subprojects {\n         protobufVersion = '3.11.4'\n         protocVersion = '3.11.4'\n         zipkinReporterVersion = '2.12.2'\n+        zipkinVersion = '2.18.3'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c8992243b4aa7571675b10de121628432d25211"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzNTg3NA==", "bodyText": "Are we losing test functionality by using the older version? Should we start thinking about having integration tests that use java 8 for the testing?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r420435874", "createdAt": "2020-05-05T22:08:32Z", "author": {"login": "jkwatson"}, "path": "build.gradle", "diffHunk": "@@ -97,6 +97,7 @@ subprojects {\n         protobufVersion = '3.11.4'\n         protocVersion = '3.11.4'\n         zipkinReporterVersion = '2.12.2'\n+        zipkinVersion = '2.18.3'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0MzU4Mw=="}, "originalCommit": {"oid": "4c8992243b4aa7571675b10de121628432d25211"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3NDYyNg==", "bodyText": "yeah it seems odd to not use java 8 in tests. Most projects have build requirements at least 8 if not above these days.. consider when you want to add features that conditionally work with futures etc.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r420474626", "createdAt": "2020-05-05T23:52:50Z", "author": {"login": "codefromthecrypt"}, "path": "build.gradle", "diffHunk": "@@ -97,6 +97,7 @@ subprojects {\n         protobufVersion = '3.11.4'\n         protocVersion = '3.11.4'\n         zipkinReporterVersion = '2.12.2'\n+        zipkinVersion = '2.18.3'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0MzU4Mw=="}, "originalCommit": {"oid": "4c8992243b4aa7571675b10de121628432d25211"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkwMTU3Nw==", "bodyText": "I agree with Adrian here, I see no reason that all tests shouldn't build with at least Java 8.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r420901577", "createdAt": "2020-05-06T15:53:30Z", "author": {"login": "devinsba"}, "path": "build.gradle", "diffHunk": "@@ -97,6 +97,7 @@ subprojects {\n         protobufVersion = '3.11.4'\n         protocVersion = '3.11.4'\n         zipkinReporterVersion = '2.12.2'\n+        zipkinVersion = '2.18.3'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0MzU4Mw=="}, "originalCommit": {"oid": "4c8992243b4aa7571675b10de121628432d25211"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU3OTY1Ng==", "bodyText": "I agree, but that's work for a different PR.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r421579656", "createdAt": "2020-05-07T15:08:15Z", "author": {"login": "jkwatson"}, "path": "build.gradle", "diffHunk": "@@ -97,6 +97,7 @@ subprojects {\n         protobufVersion = '3.11.4'\n         protocVersion = '3.11.4'\n         zipkinReporterVersion = '2.12.2'\n+        zipkinVersion = '2.18.3'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0MzU4Mw=="}, "originalCommit": {"oid": "4c8992243b4aa7571675b10de121628432d25211"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgwOTE3MQ==", "bodyText": "I've raised #1187 to cover this", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r421809171", "createdAt": "2020-05-07T21:36:49Z", "author": {"login": "jarebudev"}, "path": "build.gradle", "diffHunk": "@@ -97,6 +97,7 @@ subprojects {\n         protobufVersion = '3.11.4'\n         protocVersion = '3.11.4'\n         zipkinReporterVersion = '2.12.2'\n+        zipkinVersion = '2.18.3'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0MzU4Mw=="}, "originalCommit": {"oid": "4c8992243b4aa7571675b10de121628432d25211"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNTU3Nzc2OnYy", "diffSide": "RIGHT", "path": "contrib/trace_propagators/build.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDo1NDoyOFrOGQtWtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMToxMzo0MlrOGQ7ywg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE3MzQ5Mg==", "bodyText": "I see what you did, please split this change in a separate PR. Also nice catch :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r420173492", "createdAt": "2020-05-05T14:54:28Z", "author": {"login": "bogdandrutu"}, "path": "contrib/trace_propagators/build.gradle", "diffHunk": "@@ -12,6 +12,8 @@ ext.moduleName = \"io.opentelemetry.contrib.trace.propagation\"\n dependencies {\n     api project(':opentelemetry-api')\n \n+    testImplementation libraries.jaeger_client", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a371ed67fa789e3322867c700815960a689f0785"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxMDA1MA==", "bodyText": "Sure thing, I've created #1177.  As soon as that one is merged I'll rebase this PR.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r420410050", "createdAt": "2020-05-05T21:13:42Z", "author": {"login": "jarebudev"}, "path": "contrib/trace_propagators/build.gradle", "diffHunk": "@@ -12,6 +12,8 @@ ext.moduleName = \"io.opentelemetry.contrib.trace.propagation\"\n dependencies {\n     api project(':opentelemetry-api')\n \n+    testImplementation libraries.jaeger_client", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE3MzQ5Mg=="}, "originalCommit": {"oid": "a371ed67fa789e3322867c700815960a689f0785"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNTU4NTMyOnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/build.gradle", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDo1NjowMVrOGQtbnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDo1NjowMVrOGQtbnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE3NDc0OA==", "bodyText": "nit: you can use comma separated here instead of having multiple testImplementation.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r420174748", "createdAt": "2020-05-05T14:56:01Z", "author": {"login": "bogdandrutu"}, "path": "exporters/zipkin/build.gradle", "diffHunk": "@@ -19,11 +19,22 @@ dependencies {\n     implementation libraries.zipkin_urlconnection\n \n     testImplementation libraries.guava\n-\n+    testImplementation libraries.zipkin_junit", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a371ed67fa789e3322867c700815960a689f0785"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzQ4NTY0OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterEndToEndHttpTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzo1NzowNVrOGQ_0JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjo1Mjo1MlrOGSTBxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3NTk0MQ==", "bodyText": "typically when I write tests like this, I add a second method directly over and under it so that you can see the translation. This helps people understand the intent and any surprising things such as annotation naming choices or missed timestamp resolutions.\nto do that, I would move attributes and annotations to locals here so that you can see everything without too much scrolling. the ID constants which are fine to be up top and plus you'd use these for zipkin also.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r420475941", "createdAt": "2020-05-05T23:57:05Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterEndToEndHttpTest.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import zipkin2.Endpoint;\n+import zipkin2.codec.Encoding;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.junit.ZipkinRule;\n+import zipkin2.reporter.urlconnection.URLConnectionSender;\n+\n+/**\n+ * Tests which use Zipkin's {@link ZipkinRule} to verify that the {@link ZipkinSpanExporter} can\n+ * send spans via HTTP to Zipkin's API using supported encodings.\n+ */\n+@RunWith(JUnit4.class)\n+public class ZipkinSpanExporterEndToEndHttpTest {\n+\n+  private static final String TRACE_ID = \"d239036e7d5cec116b562147388b35bf\";\n+  private static final String SPAN_ID = \"9cc1e3049173be09\";\n+  private static final String PARENT_SPAN_ID = \"8b03ab423da481c5\";\n+  private static final Map<String, AttributeValue> attributes = Collections.emptyMap();\n+  private static final List<SpanData.TimedEvent> annotations =\n+      ImmutableList.of(\n+          SpanData.TimedEvent.create(\n+              1505855799_433901068L, \"RECEIVED\", Collections.<String, AttributeValue>emptyMap()),\n+          SpanData.TimedEvent.create(\n+              1505855799_459486280L, \"SENT\", Collections.<String, AttributeValue>emptyMap()));\n+\n+  private static final String ENDPOINT_V1_SPANS = \"/api/v1/spans\";\n+  private static final String ENDPOINT_V2_SPANS = \"/api/v2/spans\";\n+  private static final String SERVICE_NAME = \"myService\";\n+  private static final Endpoint localEndpoint =\n+      ZipkinSpanExporter.produceLocalEndpoint(SERVICE_NAME);\n+\n+  @Rule public ZipkinRule zipkin = new ZipkinRule();\n+\n+  @Test\n+  public void testExportWithDefaultEncoding() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setEndpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+            .setServiceName(SERVICE_NAME)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsProtobuf() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+                    .encoding(Encoding.PROTO3)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.PROTO3)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsThrift() {\n+\n+    @SuppressWarnings(\"deprecation\")\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V1_SPANS)\n+                    .encoding(Encoding.THRIFT)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.THRIFT)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsJsonV1() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V1_SPANS)\n+                    .encoding(Encoding.JSON)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.JSON_V1)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportFailedAsWrongEncoderUsed() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+                    .encoding(Encoding.JSON)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.PROTO3)\n+            .build();\n+\n+    ZipkinSpanExporter zipkinSpanExporter = ZipkinSpanExporter.create(configuration);\n+\n+    SpanData spanData = buildStandardSpan().build();\n+    SpanExporter.ResultCode resultCode = zipkinSpanExporter.export(Collections.singleton(spanData));\n+\n+    assertThat(resultCode).isEqualTo(SpanExporter.ResultCode.FAILURE);\n+    List<zipkin2.Span> zipkinSpans = zipkin.getTrace(TRACE_ID);\n+    assertThat(zipkinSpans).isNotNull();\n+    assertThat(zipkinSpans).isEmpty();\n+  }\n+\n+  /**\n+   * Exports a span, verify that it was received by Zipkin, and check that the span stored by Zipkin\n+   * matches what was sent.\n+   */\n+  private void exportAndVerify(ZipkinExporterConfiguration configuration) {\n+    ZipkinSpanExporter zipkinSpanExporter = ZipkinSpanExporter.create(configuration);\n+\n+    SpanData spanData = buildStandardSpan().build();\n+    SpanExporter.ResultCode resultCode = zipkinSpanExporter.export(Collections.singleton(spanData));\n+\n+    assertThat(resultCode).isEqualTo(SpanExporter.ResultCode.SUCCESS);\n+    List<zipkin2.Span> zipkinSpans = zipkin.getTrace(TRACE_ID);\n+\n+    assertThat(zipkinSpans).isNotNull();\n+    assertThat(zipkinSpans.size()).isEqualTo(1);\n+    assertThat(zipkinSpans.get(0))\n+        .isEqualTo(ZipkinSpanExporter.generateSpan(spanData, localEndpoint));\n+  }\n+\n+  private static SpanData.Builder buildStandardSpan() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a371ed67fa789e3322867c700815960a689f0785"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzOTMwMw==", "bodyText": "I've not gone overboard on the tidying up, but I added a method to build the Zipkin span underneath the OTel span", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r421839303", "createdAt": "2020-05-07T22:52:52Z", "author": {"login": "jarebudev"}, "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterEndToEndHttpTest.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import zipkin2.Endpoint;\n+import zipkin2.codec.Encoding;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.junit.ZipkinRule;\n+import zipkin2.reporter.urlconnection.URLConnectionSender;\n+\n+/**\n+ * Tests which use Zipkin's {@link ZipkinRule} to verify that the {@link ZipkinSpanExporter} can\n+ * send spans via HTTP to Zipkin's API using supported encodings.\n+ */\n+@RunWith(JUnit4.class)\n+public class ZipkinSpanExporterEndToEndHttpTest {\n+\n+  private static final String TRACE_ID = \"d239036e7d5cec116b562147388b35bf\";\n+  private static final String SPAN_ID = \"9cc1e3049173be09\";\n+  private static final String PARENT_SPAN_ID = \"8b03ab423da481c5\";\n+  private static final Map<String, AttributeValue> attributes = Collections.emptyMap();\n+  private static final List<SpanData.TimedEvent> annotations =\n+      ImmutableList.of(\n+          SpanData.TimedEvent.create(\n+              1505855799_433901068L, \"RECEIVED\", Collections.<String, AttributeValue>emptyMap()),\n+          SpanData.TimedEvent.create(\n+              1505855799_459486280L, \"SENT\", Collections.<String, AttributeValue>emptyMap()));\n+\n+  private static final String ENDPOINT_V1_SPANS = \"/api/v1/spans\";\n+  private static final String ENDPOINT_V2_SPANS = \"/api/v2/spans\";\n+  private static final String SERVICE_NAME = \"myService\";\n+  private static final Endpoint localEndpoint =\n+      ZipkinSpanExporter.produceLocalEndpoint(SERVICE_NAME);\n+\n+  @Rule public ZipkinRule zipkin = new ZipkinRule();\n+\n+  @Test\n+  public void testExportWithDefaultEncoding() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setEndpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+            .setServiceName(SERVICE_NAME)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsProtobuf() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+                    .encoding(Encoding.PROTO3)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.PROTO3)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsThrift() {\n+\n+    @SuppressWarnings(\"deprecation\")\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V1_SPANS)\n+                    .encoding(Encoding.THRIFT)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.THRIFT)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsJsonV1() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V1_SPANS)\n+                    .encoding(Encoding.JSON)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.JSON_V1)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportFailedAsWrongEncoderUsed() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+                    .encoding(Encoding.JSON)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.PROTO3)\n+            .build();\n+\n+    ZipkinSpanExporter zipkinSpanExporter = ZipkinSpanExporter.create(configuration);\n+\n+    SpanData spanData = buildStandardSpan().build();\n+    SpanExporter.ResultCode resultCode = zipkinSpanExporter.export(Collections.singleton(spanData));\n+\n+    assertThat(resultCode).isEqualTo(SpanExporter.ResultCode.FAILURE);\n+    List<zipkin2.Span> zipkinSpans = zipkin.getTrace(TRACE_ID);\n+    assertThat(zipkinSpans).isNotNull();\n+    assertThat(zipkinSpans).isEmpty();\n+  }\n+\n+  /**\n+   * Exports a span, verify that it was received by Zipkin, and check that the span stored by Zipkin\n+   * matches what was sent.\n+   */\n+  private void exportAndVerify(ZipkinExporterConfiguration configuration) {\n+    ZipkinSpanExporter zipkinSpanExporter = ZipkinSpanExporter.create(configuration);\n+\n+    SpanData spanData = buildStandardSpan().build();\n+    SpanExporter.ResultCode resultCode = zipkinSpanExporter.export(Collections.singleton(spanData));\n+\n+    assertThat(resultCode).isEqualTo(SpanExporter.ResultCode.SUCCESS);\n+    List<zipkin2.Span> zipkinSpans = zipkin.getTrace(TRACE_ID);\n+\n+    assertThat(zipkinSpans).isNotNull();\n+    assertThat(zipkinSpans.size()).isEqualTo(1);\n+    assertThat(zipkinSpans.get(0))\n+        .isEqualTo(ZipkinSpanExporter.generateSpan(spanData, localEndpoint));\n+  }\n+\n+  private static SpanData.Builder buildStandardSpan() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3NTk0MQ=="}, "originalCommit": {"oid": "a371ed67fa789e3322867c700815960a689f0785"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzQ4OTAxOnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterEndToEndHttpTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzo1ODo1MlrOGQ_2KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzo1ODo1MlrOGQ_2KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3NjQ1Ng==", "bodyText": "interesting using nanos resolution, but will leave that aside..\nwhen you add a method that generates the zipkin span, probably moving these timestamps to constants will help, and show that in zipkin they are /1000", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r420476456", "createdAt": "2020-05-05T23:58:52Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterEndToEndHttpTest.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import zipkin2.Endpoint;\n+import zipkin2.codec.Encoding;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.junit.ZipkinRule;\n+import zipkin2.reporter.urlconnection.URLConnectionSender;\n+\n+/**\n+ * Tests which use Zipkin's {@link ZipkinRule} to verify that the {@link ZipkinSpanExporter} can\n+ * send spans via HTTP to Zipkin's API using supported encodings.\n+ */\n+@RunWith(JUnit4.class)\n+public class ZipkinSpanExporterEndToEndHttpTest {\n+\n+  private static final String TRACE_ID = \"d239036e7d5cec116b562147388b35bf\";\n+  private static final String SPAN_ID = \"9cc1e3049173be09\";\n+  private static final String PARENT_SPAN_ID = \"8b03ab423da481c5\";\n+  private static final Map<String, AttributeValue> attributes = Collections.emptyMap();\n+  private static final List<SpanData.TimedEvent> annotations =\n+      ImmutableList.of(\n+          SpanData.TimedEvent.create(\n+              1505855799_433901068L, \"RECEIVED\", Collections.<String, AttributeValue>emptyMap()),\n+          SpanData.TimedEvent.create(\n+              1505855799_459486280L, \"SENT\", Collections.<String, AttributeValue>emptyMap()));\n+\n+  private static final String ENDPOINT_V1_SPANS = \"/api/v1/spans\";\n+  private static final String ENDPOINT_V2_SPANS = \"/api/v2/spans\";\n+  private static final String SERVICE_NAME = \"myService\";\n+  private static final Endpoint localEndpoint =\n+      ZipkinSpanExporter.produceLocalEndpoint(SERVICE_NAME);\n+\n+  @Rule public ZipkinRule zipkin = new ZipkinRule();\n+\n+  @Test\n+  public void testExportWithDefaultEncoding() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setEndpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+            .setServiceName(SERVICE_NAME)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsProtobuf() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+                    .encoding(Encoding.PROTO3)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.PROTO3)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsThrift() {\n+\n+    @SuppressWarnings(\"deprecation\")\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V1_SPANS)\n+                    .encoding(Encoding.THRIFT)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.THRIFT)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsJsonV1() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V1_SPANS)\n+                    .encoding(Encoding.JSON)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.JSON_V1)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportFailedAsWrongEncoderUsed() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+                    .encoding(Encoding.JSON)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.PROTO3)\n+            .build();\n+\n+    ZipkinSpanExporter zipkinSpanExporter = ZipkinSpanExporter.create(configuration);\n+\n+    SpanData spanData = buildStandardSpan().build();\n+    SpanExporter.ResultCode resultCode = zipkinSpanExporter.export(Collections.singleton(spanData));\n+\n+    assertThat(resultCode).isEqualTo(SpanExporter.ResultCode.FAILURE);\n+    List<zipkin2.Span> zipkinSpans = zipkin.getTrace(TRACE_ID);\n+    assertThat(zipkinSpans).isNotNull();\n+    assertThat(zipkinSpans).isEmpty();\n+  }\n+\n+  /**\n+   * Exports a span, verify that it was received by Zipkin, and check that the span stored by Zipkin\n+   * matches what was sent.\n+   */\n+  private void exportAndVerify(ZipkinExporterConfiguration configuration) {\n+    ZipkinSpanExporter zipkinSpanExporter = ZipkinSpanExporter.create(configuration);\n+\n+    SpanData spanData = buildStandardSpan().build();\n+    SpanExporter.ResultCode resultCode = zipkinSpanExporter.export(Collections.singleton(spanData));\n+\n+    assertThat(resultCode).isEqualTo(SpanExporter.ResultCode.SUCCESS);\n+    List<zipkin2.Span> zipkinSpans = zipkin.getTrace(TRACE_ID);\n+\n+    assertThat(zipkinSpans).isNotNull();\n+    assertThat(zipkinSpans.size()).isEqualTo(1);\n+    assertThat(zipkinSpans.get(0))\n+        .isEqualTo(ZipkinSpanExporter.generateSpan(spanData, localEndpoint));\n+  }\n+\n+  private static SpanData.Builder buildStandardSpan() {\n+    return SpanData.newBuilder()\n+        .setTraceId(TraceId.fromLowerBase16(TRACE_ID, 0))\n+        .setSpanId(SpanId.fromLowerBase16(SPAN_ID, 0))\n+        .setParentSpanId(SpanId.fromLowerBase16(PARENT_SPAN_ID, 0))\n+        .setTraceFlags(TraceFlags.builder().setIsSampled(true).build())\n+        .setStatus(Status.OK)\n+        .setKind(Span.Kind.SERVER)\n+        .setHasRemoteParent(true)\n+        .setName(\"Recv.helloworld.Greeter.SayHello\")\n+        .setStartEpochNanos(1505855794_194009601L)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a371ed67fa789e3322867c700815960a689f0785"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxODQ5MTM4OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterEndToEndHttpTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODozMTozM1rOGRI-uA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMjo0ODo0N1rOGSS8ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyNjEwNA==", "bodyText": "ZipkinExporterConfiguration.builder()\n            .setSender(\n                URLConnectionSender.newBuilder()\n                    .endpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n                    .encoding(Encoding.JSON)\n                    .build())\n            .setServiceName(SERVICE_NAME)\n            .setEncoder(SpanBytesEncoder.PROTO3)\n            .build();\n\nlooking like it can be method with 4 parameters instead of duplicating it", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r420626104", "createdAt": "2020-05-06T08:31:33Z", "author": {"login": "DotSpy"}, "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterEndToEndHttpTest.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import zipkin2.Endpoint;\n+import zipkin2.codec.Encoding;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.junit.ZipkinRule;\n+import zipkin2.reporter.urlconnection.URLConnectionSender;\n+\n+/**\n+ * Tests which use Zipkin's {@link ZipkinRule} to verify that the {@link ZipkinSpanExporter} can\n+ * send spans via HTTP to Zipkin's API using supported encodings.\n+ */\n+@RunWith(JUnit4.class)\n+public class ZipkinSpanExporterEndToEndHttpTest {\n+\n+  private static final String TRACE_ID = \"d239036e7d5cec116b562147388b35bf\";\n+  private static final String SPAN_ID = \"9cc1e3049173be09\";\n+  private static final String PARENT_SPAN_ID = \"8b03ab423da481c5\";\n+  private static final Map<String, AttributeValue> attributes = Collections.emptyMap();\n+  private static final List<SpanData.TimedEvent> annotations =\n+      ImmutableList.of(\n+          SpanData.TimedEvent.create(\n+              1505855799_433901068L, \"RECEIVED\", Collections.<String, AttributeValue>emptyMap()),\n+          SpanData.TimedEvent.create(\n+              1505855799_459486280L, \"SENT\", Collections.<String, AttributeValue>emptyMap()));\n+\n+  private static final String ENDPOINT_V1_SPANS = \"/api/v1/spans\";\n+  private static final String ENDPOINT_V2_SPANS = \"/api/v2/spans\";\n+  private static final String SERVICE_NAME = \"myService\";\n+  private static final Endpoint localEndpoint =\n+      ZipkinSpanExporter.produceLocalEndpoint(SERVICE_NAME);\n+\n+  @Rule public ZipkinRule zipkin = new ZipkinRule();\n+\n+  @Test\n+  public void testExportWithDefaultEncoding() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setEndpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+            .setServiceName(SERVICE_NAME)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsProtobuf() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+                    .encoding(Encoding.PROTO3)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.PROTO3)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsThrift() {\n+\n+    @SuppressWarnings(\"deprecation\")\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V1_SPANS)\n+                    .encoding(Encoding.THRIFT)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.THRIFT)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsJsonV1() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V1_SPANS)\n+                    .encoding(Encoding.JSON)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.JSON_V1)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportFailedAsWrongEncoderUsed() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a371ed67fa789e3322867c700815960a689f0785"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzNzk2Mg==", "bodyText": "While tidying the test up I extracted this into its own method", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r421837962", "createdAt": "2020-05-07T22:48:47Z", "author": {"login": "jarebudev"}, "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterEndToEndHttpTest.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import zipkin2.Endpoint;\n+import zipkin2.codec.Encoding;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.junit.ZipkinRule;\n+import zipkin2.reporter.urlconnection.URLConnectionSender;\n+\n+/**\n+ * Tests which use Zipkin's {@link ZipkinRule} to verify that the {@link ZipkinSpanExporter} can\n+ * send spans via HTTP to Zipkin's API using supported encodings.\n+ */\n+@RunWith(JUnit4.class)\n+public class ZipkinSpanExporterEndToEndHttpTest {\n+\n+  private static final String TRACE_ID = \"d239036e7d5cec116b562147388b35bf\";\n+  private static final String SPAN_ID = \"9cc1e3049173be09\";\n+  private static final String PARENT_SPAN_ID = \"8b03ab423da481c5\";\n+  private static final Map<String, AttributeValue> attributes = Collections.emptyMap();\n+  private static final List<SpanData.TimedEvent> annotations =\n+      ImmutableList.of(\n+          SpanData.TimedEvent.create(\n+              1505855799_433901068L, \"RECEIVED\", Collections.<String, AttributeValue>emptyMap()),\n+          SpanData.TimedEvent.create(\n+              1505855799_459486280L, \"SENT\", Collections.<String, AttributeValue>emptyMap()));\n+\n+  private static final String ENDPOINT_V1_SPANS = \"/api/v1/spans\";\n+  private static final String ENDPOINT_V2_SPANS = \"/api/v2/spans\";\n+  private static final String SERVICE_NAME = \"myService\";\n+  private static final Endpoint localEndpoint =\n+      ZipkinSpanExporter.produceLocalEndpoint(SERVICE_NAME);\n+\n+  @Rule public ZipkinRule zipkin = new ZipkinRule();\n+\n+  @Test\n+  public void testExportWithDefaultEncoding() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setEndpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+            .setServiceName(SERVICE_NAME)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsProtobuf() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+                    .encoding(Encoding.PROTO3)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.PROTO3)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsThrift() {\n+\n+    @SuppressWarnings(\"deprecation\")\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V1_SPANS)\n+                    .encoding(Encoding.THRIFT)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.THRIFT)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsJsonV1() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setSender(\n+                URLConnectionSender.newBuilder()\n+                    .endpoint(zipkin.httpUrl() + ENDPOINT_V1_SPANS)\n+                    .encoding(Encoding.JSON)\n+                    .build())\n+            .setServiceName(SERVICE_NAME)\n+            .setEncoder(SpanBytesEncoder.JSON_V1)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportFailedAsWrongEncoderUsed() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyNjEwNA=="}, "originalCommit": {"oid": "a371ed67fa789e3322867c700815960a689f0785"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjUzNTM2OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterEndToEndHttpTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwMjoxNDo0MlrOGSWlzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMzo1NjozM1rOGSmc1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5NzY3Ng==", "bodyText": "for the purpose of \"find\", etc either make this a constant or use the same form as below? 1505855799000000L + 465726528L using the same value representation helps see what's different in the formats", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r421897676", "createdAt": "2020-05-08T02:14:42Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterEndToEndHttpTest.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.Encoding;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.junit.ZipkinRule;\n+import zipkin2.reporter.urlconnection.URLConnectionSender;\n+\n+/**\n+ * Tests which use Zipkin's {@link ZipkinRule} to verify that the {@link ZipkinSpanExporter} can\n+ * send spans via HTTP to Zipkin's API using supported encodings.\n+ */\n+@RunWith(JUnit4.class)\n+public class ZipkinSpanExporterEndToEndHttpTest {\n+\n+  private static final String TRACE_ID = \"d239036e7d5cec116b562147388b35bf\";\n+  private static final String SPAN_ID = \"9cc1e3049173be09\";\n+  private static final String PARENT_SPAN_ID = \"8b03ab423da481c5\";\n+  private static final Map<String, AttributeValue> attributes = Collections.emptyMap();\n+  private static final List<SpanData.TimedEvent> annotations =\n+      ImmutableList.of(\n+          SpanData.TimedEvent.create(\n+              1505855799_433901068L, \"RECEIVED\", Collections.<String, AttributeValue>emptyMap()),\n+          SpanData.TimedEvent.create(\n+              1505855799_459486280L, \"SENT\", Collections.<String, AttributeValue>emptyMap()));\n+\n+  private static final String ENDPOINT_V1_SPANS = \"/api/v1/spans\";\n+  private static final String ENDPOINT_V2_SPANS = \"/api/v2/spans\";\n+  private static final String SERVICE_NAME = \"myService\";\n+  private static final Endpoint localEndpoint =\n+      ZipkinSpanExporter.produceLocalEndpoint(SERVICE_NAME);\n+\n+  @Rule public ZipkinRule zipkin = new ZipkinRule();\n+\n+  @Test\n+  public void testExportWithDefaultEncoding() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setEndpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+            .setServiceName(SERVICE_NAME)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsProtobuf() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        buildZipkinExporterConfiguration(\n+            zipkin.httpUrl() + ENDPOINT_V2_SPANS, Encoding.PROTO3, SpanBytesEncoder.PROTO3);\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsThrift() {\n+\n+    @SuppressWarnings(\"deprecation\")\n+    ZipkinExporterConfiguration configuration =\n+        buildZipkinExporterConfiguration(\n+            zipkin.httpUrl() + ENDPOINT_V1_SPANS, Encoding.THRIFT, SpanBytesEncoder.THRIFT);\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsJsonV1() {\n+    ZipkinExporterConfiguration configuration =\n+        buildZipkinExporterConfiguration(\n+            zipkin.httpUrl() + ENDPOINT_V1_SPANS, Encoding.JSON, SpanBytesEncoder.JSON_V1);\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportFailedAsWrongEncoderUsed() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        buildZipkinExporterConfiguration(\n+            zipkin.httpUrl() + ENDPOINT_V2_SPANS, Encoding.JSON, SpanBytesEncoder.PROTO3);\n+\n+    ZipkinSpanExporter zipkinSpanExporter = ZipkinSpanExporter.create(configuration);\n+\n+    SpanData spanData = buildStandardSpan().build();\n+    SpanExporter.ResultCode resultCode = zipkinSpanExporter.export(Collections.singleton(spanData));\n+\n+    assertThat(resultCode).isEqualTo(SpanExporter.ResultCode.FAILURE);\n+    List<Span> zipkinSpans = zipkin.getTrace(TRACE_ID);\n+    assertThat(zipkinSpans).isNotNull();\n+    assertThat(zipkinSpans).isEmpty();\n+  }\n+\n+  private static ZipkinExporterConfiguration buildZipkinExporterConfiguration(\n+      String endpoint, Encoding encoding, SpanBytesEncoder encoder) {\n+    return ZipkinExporterConfiguration.builder()\n+        .setSender(URLConnectionSender.newBuilder().endpoint(endpoint).encoding(encoding).build())\n+        .setServiceName(SERVICE_NAME)\n+        .setEncoder(encoder)\n+        .build();\n+  }\n+\n+  /**\n+   * Exports a span, verify that it was received by Zipkin, and check that the span stored by Zipkin\n+   * matches what was sent.\n+   */\n+  private void exportAndVerify(ZipkinExporterConfiguration configuration) {\n+    ZipkinSpanExporter zipkinSpanExporter = ZipkinSpanExporter.create(configuration);\n+\n+    SpanData spanData = buildStandardSpan().build();\n+    SpanExporter.ResultCode resultCode = zipkinSpanExporter.export(Collections.singleton(spanData));\n+\n+    assertThat(resultCode).isEqualTo(SpanExporter.ResultCode.SUCCESS);\n+    List<Span> zipkinSpans = zipkin.getTrace(TRACE_ID);\n+\n+    assertThat(zipkinSpans).isNotNull();\n+    assertThat(zipkinSpans.size()).isEqualTo(1);\n+    assertThat(zipkinSpans.get(0)).isEqualTo(buildZipkinSpan());\n+  }\n+\n+  private static SpanData.Builder buildStandardSpan() {\n+    return SpanData.newBuilder()\n+        .setTraceId(TraceId.fromLowerBase16(TRACE_ID, 0))\n+        .setSpanId(SpanId.fromLowerBase16(SPAN_ID, 0))\n+        .setParentSpanId(SpanId.fromLowerBase16(PARENT_SPAN_ID, 0))\n+        .setTraceFlags(TraceFlags.builder().setIsSampled(true).build())\n+        .setStatus(Status.OK)\n+        .setKind(Kind.SERVER)\n+        .setHasRemoteParent(true)\n+        .setName(\"Recv.helloworld.Greeter.SayHello\")\n+        .setStartEpochNanos(1505855794_194009601L)\n+        .setAttributes(attributes)\n+        .setTotalAttributeCount(attributes.size())\n+        .setTimedEvents(annotations)\n+        .setLinks(Collections.<SpanData.Link>emptyList())\n+        .setEndEpochNanos(1505855799_465726528L)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f1f6fefaa0c677a09a57fd6bc9a032fac2d0f1d"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE1NzUyNA==", "bodyText": "thanks, i've extracted these into constants now, should be good to go :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r422157524", "createdAt": "2020-05-08T13:56:33Z", "author": {"login": "jarebudev"}, "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterEndToEndHttpTest.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.Encoding;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.junit.ZipkinRule;\n+import zipkin2.reporter.urlconnection.URLConnectionSender;\n+\n+/**\n+ * Tests which use Zipkin's {@link ZipkinRule} to verify that the {@link ZipkinSpanExporter} can\n+ * send spans via HTTP to Zipkin's API using supported encodings.\n+ */\n+@RunWith(JUnit4.class)\n+public class ZipkinSpanExporterEndToEndHttpTest {\n+\n+  private static final String TRACE_ID = \"d239036e7d5cec116b562147388b35bf\";\n+  private static final String SPAN_ID = \"9cc1e3049173be09\";\n+  private static final String PARENT_SPAN_ID = \"8b03ab423da481c5\";\n+  private static final Map<String, AttributeValue> attributes = Collections.emptyMap();\n+  private static final List<SpanData.TimedEvent> annotations =\n+      ImmutableList.of(\n+          SpanData.TimedEvent.create(\n+              1505855799_433901068L, \"RECEIVED\", Collections.<String, AttributeValue>emptyMap()),\n+          SpanData.TimedEvent.create(\n+              1505855799_459486280L, \"SENT\", Collections.<String, AttributeValue>emptyMap()));\n+\n+  private static final String ENDPOINT_V1_SPANS = \"/api/v1/spans\";\n+  private static final String ENDPOINT_V2_SPANS = \"/api/v2/spans\";\n+  private static final String SERVICE_NAME = \"myService\";\n+  private static final Endpoint localEndpoint =\n+      ZipkinSpanExporter.produceLocalEndpoint(SERVICE_NAME);\n+\n+  @Rule public ZipkinRule zipkin = new ZipkinRule();\n+\n+  @Test\n+  public void testExportWithDefaultEncoding() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setEndpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+            .setServiceName(SERVICE_NAME)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsProtobuf() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        buildZipkinExporterConfiguration(\n+            zipkin.httpUrl() + ENDPOINT_V2_SPANS, Encoding.PROTO3, SpanBytesEncoder.PROTO3);\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsThrift() {\n+\n+    @SuppressWarnings(\"deprecation\")\n+    ZipkinExporterConfiguration configuration =\n+        buildZipkinExporterConfiguration(\n+            zipkin.httpUrl() + ENDPOINT_V1_SPANS, Encoding.THRIFT, SpanBytesEncoder.THRIFT);\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsJsonV1() {\n+    ZipkinExporterConfiguration configuration =\n+        buildZipkinExporterConfiguration(\n+            zipkin.httpUrl() + ENDPOINT_V1_SPANS, Encoding.JSON, SpanBytesEncoder.JSON_V1);\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportFailedAsWrongEncoderUsed() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        buildZipkinExporterConfiguration(\n+            zipkin.httpUrl() + ENDPOINT_V2_SPANS, Encoding.JSON, SpanBytesEncoder.PROTO3);\n+\n+    ZipkinSpanExporter zipkinSpanExporter = ZipkinSpanExporter.create(configuration);\n+\n+    SpanData spanData = buildStandardSpan().build();\n+    SpanExporter.ResultCode resultCode = zipkinSpanExporter.export(Collections.singleton(spanData));\n+\n+    assertThat(resultCode).isEqualTo(SpanExporter.ResultCode.FAILURE);\n+    List<Span> zipkinSpans = zipkin.getTrace(TRACE_ID);\n+    assertThat(zipkinSpans).isNotNull();\n+    assertThat(zipkinSpans).isEmpty();\n+  }\n+\n+  private static ZipkinExporterConfiguration buildZipkinExporterConfiguration(\n+      String endpoint, Encoding encoding, SpanBytesEncoder encoder) {\n+    return ZipkinExporterConfiguration.builder()\n+        .setSender(URLConnectionSender.newBuilder().endpoint(endpoint).encoding(encoding).build())\n+        .setServiceName(SERVICE_NAME)\n+        .setEncoder(encoder)\n+        .build();\n+  }\n+\n+  /**\n+   * Exports a span, verify that it was received by Zipkin, and check that the span stored by Zipkin\n+   * matches what was sent.\n+   */\n+  private void exportAndVerify(ZipkinExporterConfiguration configuration) {\n+    ZipkinSpanExporter zipkinSpanExporter = ZipkinSpanExporter.create(configuration);\n+\n+    SpanData spanData = buildStandardSpan().build();\n+    SpanExporter.ResultCode resultCode = zipkinSpanExporter.export(Collections.singleton(spanData));\n+\n+    assertThat(resultCode).isEqualTo(SpanExporter.ResultCode.SUCCESS);\n+    List<Span> zipkinSpans = zipkin.getTrace(TRACE_ID);\n+\n+    assertThat(zipkinSpans).isNotNull();\n+    assertThat(zipkinSpans.size()).isEqualTo(1);\n+    assertThat(zipkinSpans.get(0)).isEqualTo(buildZipkinSpan());\n+  }\n+\n+  private static SpanData.Builder buildStandardSpan() {\n+    return SpanData.newBuilder()\n+        .setTraceId(TraceId.fromLowerBase16(TRACE_ID, 0))\n+        .setSpanId(SpanId.fromLowerBase16(SPAN_ID, 0))\n+        .setParentSpanId(SpanId.fromLowerBase16(PARENT_SPAN_ID, 0))\n+        .setTraceFlags(TraceFlags.builder().setIsSampled(true).build())\n+        .setStatus(Status.OK)\n+        .setKind(Kind.SERVER)\n+        .setHasRemoteParent(true)\n+        .setName(\"Recv.helloworld.Greeter.SayHello\")\n+        .setStartEpochNanos(1505855794_194009601L)\n+        .setAttributes(attributes)\n+        .setTotalAttributeCount(attributes.size())\n+        .setTimedEvents(annotations)\n+        .setLinks(Collections.<SpanData.Link>emptyList())\n+        .setEndEpochNanos(1505855799_465726528L)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5NzY3Ng=="}, "originalCommit": {"oid": "3f1f6fefaa0c677a09a57fd6bc9a032fac2d0f1d"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODM1NjQ4OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterEndToEndHttpTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNDoyNjowOFrOGSndpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNDoyNjowOFrOGSndpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE3NDExNw==", "bodyText": "looks good. actually the annotations themselves we can revisit, but in any case this E to E makes future discussions easier.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1176#discussion_r422174117", "createdAt": "2020-05-08T14:26:08Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterEndToEndHttpTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.Encoding;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.junit.ZipkinRule;\n+import zipkin2.reporter.urlconnection.URLConnectionSender;\n+\n+/**\n+ * Tests which use Zipkin's {@link ZipkinRule} to verify that the {@link ZipkinSpanExporter} can\n+ * send spans via HTTP to Zipkin's API using supported encodings.\n+ */\n+@RunWith(JUnit4.class)\n+public class ZipkinSpanExporterEndToEndHttpTest {\n+\n+  private static final String TRACE_ID = \"d239036e7d5cec116b562147388b35bf\";\n+  private static final String SPAN_ID = \"9cc1e3049173be09\";\n+  private static final String PARENT_SPAN_ID = \"8b03ab423da481c5\";\n+  private static final String SPAN_NAME = \"Recv.helloworld.Greeter.SayHello\";\n+  private static final long START_EPOCH_NANOS = 1505855794_194009601L;\n+  private static final long END_EPOCH_NANOS = 1505855799_465726528L;\n+  private static final long RECEIVED_TIMESTAMP_NANOS = 1505855799_433901068L;\n+  private static final long SENT_TIMESTAMP_NANOS = 1505855799_459486280L;\n+  private static final Map<String, AttributeValue> attributes = Collections.emptyMap();\n+  private static final List<SpanData.TimedEvent> annotations =\n+      ImmutableList.of(\n+          SpanData.TimedEvent.create(\n+              RECEIVED_TIMESTAMP_NANOS, \"RECEIVED\", Collections.<String, AttributeValue>emptyMap()),\n+          SpanData.TimedEvent.create(\n+              SENT_TIMESTAMP_NANOS, \"SENT\", Collections.<String, AttributeValue>emptyMap()));\n+\n+  private static final String ENDPOINT_V1_SPANS = \"/api/v1/spans\";\n+  private static final String ENDPOINT_V2_SPANS = \"/api/v2/spans\";\n+  private static final String SERVICE_NAME = \"myService\";\n+  private static final Endpoint localEndpoint =\n+      ZipkinSpanExporter.produceLocalEndpoint(SERVICE_NAME);\n+\n+  @Rule public ZipkinRule zipkin = new ZipkinRule();\n+\n+  @Test\n+  public void testExportWithDefaultEncoding() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setEndpoint(zipkin.httpUrl() + ENDPOINT_V2_SPANS)\n+            .setServiceName(SERVICE_NAME)\n+            .build();\n+\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsProtobuf() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        buildZipkinExporterConfiguration(\n+            zipkin.httpUrl() + ENDPOINT_V2_SPANS, Encoding.PROTO3, SpanBytesEncoder.PROTO3);\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsThrift() {\n+\n+    @SuppressWarnings(\"deprecation\")\n+    ZipkinExporterConfiguration configuration =\n+        buildZipkinExporterConfiguration(\n+            zipkin.httpUrl() + ENDPOINT_V1_SPANS, Encoding.THRIFT, SpanBytesEncoder.THRIFT);\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportAsJsonV1() {\n+    ZipkinExporterConfiguration configuration =\n+        buildZipkinExporterConfiguration(\n+            zipkin.httpUrl() + ENDPOINT_V1_SPANS, Encoding.JSON, SpanBytesEncoder.JSON_V1);\n+    exportAndVerify(configuration);\n+  }\n+\n+  @Test\n+  public void testExportFailedAsWrongEncoderUsed() {\n+\n+    ZipkinExporterConfiguration configuration =\n+        buildZipkinExporterConfiguration(\n+            zipkin.httpUrl() + ENDPOINT_V2_SPANS, Encoding.JSON, SpanBytesEncoder.PROTO3);\n+\n+    ZipkinSpanExporter zipkinSpanExporter = ZipkinSpanExporter.create(configuration);\n+\n+    SpanData spanData = buildStandardSpan().build();\n+    SpanExporter.ResultCode resultCode = zipkinSpanExporter.export(Collections.singleton(spanData));\n+\n+    assertThat(resultCode).isEqualTo(SpanExporter.ResultCode.FAILURE);\n+    List<Span> zipkinSpans = zipkin.getTrace(TRACE_ID);\n+    assertThat(zipkinSpans).isNotNull();\n+    assertThat(zipkinSpans).isEmpty();\n+  }\n+\n+  private static ZipkinExporterConfiguration buildZipkinExporterConfiguration(\n+      String endpoint, Encoding encoding, SpanBytesEncoder encoder) {\n+    return ZipkinExporterConfiguration.builder()\n+        .setSender(URLConnectionSender.newBuilder().endpoint(endpoint).encoding(encoding).build())\n+        .setServiceName(SERVICE_NAME)\n+        .setEncoder(encoder)\n+        .build();\n+  }\n+\n+  /**\n+   * Exports a span, verify that it was received by Zipkin, and check that the span stored by Zipkin\n+   * matches what was sent.\n+   */\n+  private void exportAndVerify(ZipkinExporterConfiguration configuration) {\n+    ZipkinSpanExporter zipkinSpanExporter = ZipkinSpanExporter.create(configuration);\n+\n+    SpanData spanData = buildStandardSpan().build();\n+    SpanExporter.ResultCode resultCode = zipkinSpanExporter.export(Collections.singleton(spanData));\n+\n+    assertThat(resultCode).isEqualTo(SpanExporter.ResultCode.SUCCESS);\n+    List<Span> zipkinSpans = zipkin.getTrace(TRACE_ID);\n+\n+    assertThat(zipkinSpans).isNotNull();\n+    assertThat(zipkinSpans.size()).isEqualTo(1);\n+    assertThat(zipkinSpans.get(0)).isEqualTo(buildZipkinSpan());\n+  }\n+\n+  private static SpanData.Builder buildStandardSpan() {\n+    return SpanData.newBuilder()\n+        .setTraceId(TraceId.fromLowerBase16(TRACE_ID, 0))\n+        .setSpanId(SpanId.fromLowerBase16(SPAN_ID, 0))\n+        .setParentSpanId(SpanId.fromLowerBase16(PARENT_SPAN_ID, 0))\n+        .setTraceFlags(TraceFlags.builder().setIsSampled(true).build())\n+        .setStatus(Status.OK)\n+        .setKind(Kind.SERVER)\n+        .setHasRemoteParent(true)\n+        .setName(SPAN_NAME)\n+        .setStartEpochNanos(START_EPOCH_NANOS)\n+        .setAttributes(attributes)\n+        .setTotalAttributeCount(attributes.size())\n+        .setTimedEvents(annotations)\n+        .setLinks(Collections.<SpanData.Link>emptyList())\n+        .setEndEpochNanos(END_EPOCH_NANOS)\n+        .setHasEnded(true);\n+  }\n+\n+  private static Span buildZipkinSpan() {\n+    return Span.newBuilder()\n+        .traceId(TRACE_ID)\n+        .parentId(PARENT_SPAN_ID)\n+        .id(SPAN_ID)\n+        .kind(Span.Kind.SERVER)\n+        .name(SPAN_NAME)\n+        .timestamp(START_EPOCH_NANOS / 1000)\n+        .duration((END_EPOCH_NANOS / 1000) - (START_EPOCH_NANOS / 1000))\n+        .localEndpoint(localEndpoint)\n+        .addAnnotation(RECEIVED_TIMESTAMP_NANOS / 1000, \"RECEIVED\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab15cc5aca88730fb06a088d8e9d18c69290ee8b"}, "originalPosition": 188}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 901, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}