{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxNTAyMzY5", "number": 1380, "title": "Implemented base zPages classes and TraceZ zPage", "bodyText": "zPages are a set of in-process dynamically generated HTML pages that collect and display data from the running process. In the set, TraceZ (/tracez) is the zPage that focuses on information collected about the trace spans. In particular, the TraceZ zPage displays information on sample running spans, sample latency, and sample error spans.\nThis PR implemented:\n\n\nthe base classes that are needed for creating a new zPage\n\n\nthe TraceZ zPage", "createdAt": "2020-06-29T15:47:57Z", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380", "merged": true, "mergeCommit": {"oid": "373fbf4a2e62839812338d6d1d1dedbcae7dab6c"}, "closed": true, "closedAt": "2020-07-15T15:51:30Z", "author": {"login": "wtyanan"}, "timelineItems": {"totalCount": 78, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcwFcRPgBqjM0OTQwMDcxNTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc1MquoAFqTQ0OTA4OTIzNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3c900bd626f6d0297b3d3ff5ce441802329359fe", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/3c900bd626f6d0297b3d3ff5ce441802329359fe", "committedDate": "2020-06-29T17:23:36Z", "message": "Merge branch 'master' into master"}, "afterCommit": {"oid": "accdd4b4c870cee12aa33bf6310bc268067b8600", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/accdd4b4c870cee12aa33bf6310bc268067b8600", "committedDate": "2020-06-29T14:36:07Z", "message": "Javadoc description update (#16)\n\n* Minor javadoc wording update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ca81bc037a1d7b9384f74d24e62846cc8007972", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/9ca81bc037a1d7b9384f74d24e62846cc8007972", "committedDate": "2020-06-29T18:47:15Z", "message": "Implemented a span processor for the TraceZ zPage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86c6db8d38c11c292eab92d71cbcf4b8503a2615", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/86c6db8d38c11c292eab92d71cbcf4b8503a2615", "committedDate": "2020-06-29T18:47:27Z", "message": "Implemented aggregation logic for running and latency based spans,\nsummary table generation with running span logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66bafe20481caadd4b4ee541edb4dfedae896148", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/66bafe20481caadd4b4ee541edb4dfedae896148", "committedDate": "2020-06-29T18:51:00Z", "message": "Implemented aggregation logic for error based spans"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af80d27e7921040258e294956774b5dc1e3681d3", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/af80d27e7921040258e294956774b5dc1e3681d3", "committedDate": "2020-06-29T18:51:28Z", "message": "Finished implementation of TraceZ zPage summary table"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2eb7be705e2a5702de0761258988604fad7d3e0", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/d2eb7be705e2a5702de0761258988604fad7d3e0", "committedDate": "2020-06-29T18:52:19Z", "message": "Finished implementation of HttpHandler, HttpServer, and TraceZ zPage"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "accdd4b4c870cee12aa33bf6310bc268067b8600", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/accdd4b4c870cee12aa33bf6310bc268067b8600", "committedDate": "2020-06-29T14:36:07Z", "message": "Javadoc description update (#16)\n\n* Minor javadoc wording update"}, "afterCommit": {"oid": "d2eb7be705e2a5702de0761258988604fad7d3e0", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/d2eb7be705e2a5702de0761258988604fad7d3e0", "committedDate": "2020-06-29T18:52:19Z", "message": "Finished implementation of HttpHandler, HttpServer, and TraceZ zPage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "219d3834e2e4021936f241613e016523e3f5a0b9", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/219d3834e2e4021936f241613e016523e3f5a0b9", "committedDate": "2020-06-29T19:15:32Z", "message": "Refactored the sdk_contrib folder to follow updated syntax"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a400dcc1d93e916d7216c42d4b7ec1587c4af30d", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/a400dcc1d93e916d7216c42d4b7ec1587c4af30d", "committedDate": "2020-06-29T19:00:07Z", "message": "Refactored the sdk_contrib folder based on the OT master branch"}, "afterCommit": {"oid": "219d3834e2e4021936f241613e016523e3f5a0b9", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/219d3834e2e4021936f241613e016523e3f5a0b9", "committedDate": "2020-06-29T19:15:32Z", "message": "Refactored the sdk_contrib folder to follow updated syntax"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "febc45317c659821b15b59945661476e92e9811e", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/febc45317c659821b15b59945661476e92e9811e", "committedDate": "2020-06-29T19:30:06Z", "message": "Merge branch 'master' into master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "425e436b9954219329b0b54327cdc2ca3493a287", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/425e436b9954219329b0b54327cdc2ca3493a287", "committedDate": "2020-06-29T19:37:57Z", "message": "Removed duplicate function"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NDUwODUx", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-439450851", "createdAt": "2020-06-29T19:49:58Z", "commit": {"oid": "425e436b9954219329b0b54327cdc2ca3493a287"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxOTo0OTo1OFrOGqfwCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxOTo0OTo1OFrOGqfwCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxMzU3OQ==", "bodyText": "rather than synchronizing everything, what do you think about using a ConcurrentMap implementation?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447213579", "createdAt": "2020-06-29T19:49:58Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * can be read from system properties, environment variables, or {@link java.util.Properties}\n+ * objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link\n+ * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.ssp.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_SSP_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+public final class TracezSpanProcessor implements SpanProcessor {\n+  private final Map<SpanId, ReadableSpan> runningSpanCache;\n+  private final Map<SpanId, ReadableSpan> completedSpanCache;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  public TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new HashMap<>();\n+    completedSpanCache = new HashMap<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425e436b9954219329b0b54327cdc2ca3493a287"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NDUxNDUx", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-439451451", "createdAt": "2020-06-29T19:50:51Z", "commit": {"oid": "425e436b9954219329b0b54327cdc2ca3493a287"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxOTo1MDo1MVrOGqfyCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxOTo1MDo1MVrOGqfyCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxNDA5MA==", "bodyText": "It looks like this completedSpanCache will grow without bounds. We need to make sure that we don't hold references to these spans indefinitely.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447214090", "createdAt": "2020-06-29T19:50:51Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * can be read from system properties, environment variables, or {@link java.util.Properties}\n+ * objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link\n+ * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.ssp.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_SSP_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+public final class TracezSpanProcessor implements SpanProcessor {\n+  private final Map<SpanId, ReadableSpan> runningSpanCache;\n+  private final Map<SpanId, ReadableSpan> completedSpanCache;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  public TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new HashMap<>();\n+    completedSpanCache = new HashMap<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    synchronized (this) {\n+      runningSpanCache.put(span.getSpanContext().getSpanId(), span);\n+    }\n+  }\n+\n+  @Override\n+  public boolean isStartRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void onEnd(ReadableSpan span) {\n+    SpanId id = span.getSpanContext().getSpanId();\n+    synchronized (this) {\n+      runningSpanCache.remove(id);\n+      if (!sampled || span.getSpanContext().getTraceFlags().isSampled()) {\n+        completedSpanCache.put(id, span);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425e436b9954219329b0b54327cdc2ca3493a287"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NDUzMDM0", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-439453034", "createdAt": "2020-06-29T19:53:18Z", "commit": {"oid": "425e436b9954219329b0b54327cdc2ca3493a287"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxOTo1MzoxOFrOGqf2-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxOTo1MzoxOFrOGqf2-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxNTM1NQ==", "bodyText": "It would probably be better not to link to this. If it gets moved, then every zpage view in the world will be broken. Better would be to have it hosted internal to the module.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447215355", "createdAt": "2020-06-29T19:53:18Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,599 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator.LatencyBoundaries;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.BufferedWriter;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  @javax.annotation.Nullable private final TracezDataAggregator dataAggregator;\n+  // Map from LatencyBoundaries to human readable string on the UI\n+  private static final ImmutableMap<LatencyBoundaries, String> LATENCY_BOUNDARIES_STRING_MAP =\n+      buildLatencyBoundariesStringMap();\n+\n+  private TracezZPageHandler(TracezDataAggregator dataAggregator) {\n+    this.dataAggregator = dataAggregator;\n+  }\n+\n+  /**\n+   * Constructs a new {@code TracezZPageHandler}.\n+   *\n+   * @return a new {@code TracezZPageHandler}.\n+   */\n+  static TracezZPageHandler create(@javax.annotation.Nullable TracezDataAggregator dataAggregator) {\n+    return new TracezZPageHandler(dataAggregator);\n+  }\n+\n+  @Override\n+  public String getUrlPath() {\n+    return TRACEZ_URL;\n+  }\n+\n+  /**\n+   * Emits CSS Styles to the {@link PrintWriter} {@code out}. Content emited by this function should\n+   * be enclosed by <head></head> tag.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   */\n+  private static void emitHtmlStyle(PrintWriter out) {\n+    out.write(\"<style>\");\n+    out.write(ZPageStyle.style);\n+    out.write(\"</style>\");\n+  }\n+\n+  /**\n+   * Emits the header of the summary table to the {@link PrintWriter} {@code out}.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   * @param formatter A {@link Formatter} for formatting HTML expressions.\n+   */\n+  private static void emitSummaryTableHeader(PrintWriter out, Formatter formatter) {\n+    // First row\n+    out.write(\"<tr class=\\\"bg-color\\\">\");\n+    out.write(\"<th colspan=1 class=\\\"header-text\\\"><b>Span Name</b></th>\");\n+    out.write(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Running</b></th>\");\n+    out.write(\"<th colspan=9 class=\\\"header-text border-left-white\\\"><b>Latency Samples</b></th>\");\n+    out.write(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Error Samples</b></th>\");\n+    out.write(\"</tr>\");\n+\n+    // Second row\n+    out.write(\"<tr class=\\\"bg-color\\\">\");\n+    out.write(\"<th colspan=1></th>\");\n+    out.write(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    for (LatencyBoundaries latencyBoundaries : LatencyBoundaries.values()) {\n+      formatter.format(\n+          \"<th colspan=1 class=\\\"border-left-white align-center\\\"\"\n+              + \"style=\\\"color: #fff;\\\"><b>[%s]</b></th>\",\n+          LATENCY_BOUNDARIES_STRING_MAP.get(latencyBoundaries));\n+    }\n+    out.write(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    out.write(\"</tr>\");\n+  }\n+\n+  /**\n+   * Emits a single cell of the summary table depends on the paramters passed in, to the {@link\n+   * PrintWriter} {@code out}.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   * @param formatter {@link Formatter} for formatting HTML expressions.\n+   * @param spanName The name of the corresponding span.\n+   * @param numOfSamples The number of samples of the corresponding span.\n+   * @param type The type of the corresponding span (running, latency, error).\n+   * @param subtype The sub-type of the corresponding span (latency [0, 8], error [0, 15]).\n+   */\n+  private static void emitSummaryTableCell(\n+      PrintWriter out,\n+      Formatter formatter,\n+      String spanName,\n+      int numOfSamples,\n+      SampleType type,\n+      int subtype)\n+      throws UnsupportedEncodingException {\n+    // If numOfSamples is greater than 0, emit a link to see detailed span information\n+    // If numOfSamples is smaller than 0, print the text \"N/A\", otherwise print the text \"0\"\n+    if (numOfSamples > 0) {\n+      formatter.format(\n+          \"<td class=\\\"align-center border-left-dark\\\"><a href=\\\"?%s=%s&%s=%d&%s=%d\\\">%d</a></td>\",\n+          PARAM_SPAN_NAME,\n+          URLEncoder.encode(spanName, \"UTF-8\"),\n+          PARAM_SAMPLE_TYPE,\n+          type.getValue(),\n+          PARAM_SAMPLE_SUB_TYPE,\n+          subtype,\n+          numOfSamples);\n+    } else if (numOfSamples < 0) {\n+      out.write(\"<td class=\\\"align-center border-left-dark\\\">N/A</td>\");\n+    } else {\n+      out.write(\"<td class=\\\"align-center border-left-dark\\\">0</td>\");\n+    }\n+  }\n+\n+  /**\n+   * Emits the summary table of running spans and sampled spans to the {@link PrintWriter} {@code\n+   * out}.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   * @param formatter A {@link Formatter} for formatting HTML expressions.\n+   */\n+  private void emitSummaryTable(PrintWriter out, Formatter formatter)\n+      throws UnsupportedEncodingException {\n+    if (dataAggregator == null) {\n+      return;\n+    }\n+    out.write(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    emitSummaryTableHeader(out, formatter);\n+\n+    Set<String> spanNames = dataAggregator.getSpanNames();\n+    boolean zebraStripe = false;\n+\n+    Map<String, Integer> runningSpanCounts = dataAggregator.getRunningSpanCounts();\n+    Map<String, Map<LatencyBoundaries, Integer>> latencySpanCounts =\n+        dataAggregator.getSpanLatencyCounts();\n+    Map<String, Integer> errorSpanCounts = dataAggregator.getErrorSpanCounts();\n+    for (String spanName : spanNames) {\n+      if (zebraStripe) {\n+        formatter.format(\"<tr style=\\\"background-color: %s\\\">\", ZEBRA_STRIPE_COLOR);\n+      } else {\n+        out.write(\"<tr>\");\n+      }\n+      zebraStripe = !zebraStripe;\n+      formatter.format(\"<td>%s</td>\", htmlEscaper().escape(spanName));\n+\n+      // Running spans column\n+      int numOfRunningSpans =\n+          runningSpanCounts.containsKey(spanName) ? runningSpanCounts.get(spanName) : 0;\n+      // subtype is ignored for running spans\n+      emitSummaryTableCell(out, formatter, spanName, numOfRunningSpans, SampleType.RUNNING, 0);\n+\n+      // Latency based sampled spans column\n+      int subtype = 0;\n+      for (LatencyBoundaries latencyBoundaries : LatencyBoundaries.values()) {\n+        int numOfLatencySamples =\n+            latencySpanCounts.containsKey(spanName)\n+                    && latencySpanCounts.get(spanName).containsKey(latencyBoundaries)\n+                ? latencySpanCounts.get(spanName).get(latencyBoundaries)\n+                : 0;\n+        emitSummaryTableCell(\n+            out, formatter, spanName, numOfLatencySamples, SampleType.LATENCY, subtype);\n+        subtype += 1;\n+      }\n+\n+      // Error based sampled spans column\n+      int numOfErrorSamples =\n+          errorSpanCounts.containsKey(spanName) ? errorSpanCounts.get(spanName) : 0;\n+      // subtype 0 means all errors\n+      emitSummaryTableCell(out, formatter, spanName, numOfErrorSamples, SampleType.ERROR, 0);\n+    }\n+    out.write(\"</table>\");\n+  }\n+\n+  private static void emitSpanNameAndCount(\n+      Formatter formatter, String spanName, int count, SampleType type) {\n+    formatter.format(\n+        \"<p class=\\\"align-center\\\"><b> Span Name: %s </b></p>\", htmlEscaper().escape(spanName));\n+    formatter.format(\n+        \"<p class=\\\"align-center\\\"><b> Number of %s: %d </b></p>\",\n+        type == SampleType.RUNNING\n+            ? \"running\"\n+            : type == SampleType.LATENCY ? \"latency samples\" : \"error samples\",\n+        count);\n+  }\n+\n+  private static void emitSpanDetails(\n+      PrintWriter out, Formatter formatter, Collection<SpanData> spans) {\n+    out.write(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    out.write(\"<tr class=\\\"bg-color\\\">\");\n+    out.write(\n+        \"<td style=\\\"color: #fff;\\\"><pre class=\\\"no-margin wrap-text\\\"><b>When</b></pre></td>\");\n+    out.write(\n+        \"<td class=\\\"border-left-white\\\" style=\\\"color: #fff;\\\">\"\n+            + \"<pre class=\\\"no-margin wrap-text\\\"><b>Elapsed(s)</b></pre></td>\");\n+    out.write(\"<td class=\\\"border-left-white\\\"></td>\");\n+    out.write(\"</tr>\");\n+    boolean zebraStripe = false;\n+    for (SpanData span : spans) {\n+      zebraStripe = emitSingleSpan(out, formatter, span, zebraStripe);\n+    }\n+    out.write(\"</table>\");\n+  }\n+\n+  private static boolean emitSingleSpan(\n+      PrintWriter out, Formatter formatter, SpanData span, boolean zebraStripe) {\n+    Calendar calendar = Calendar.getInstance();\n+    calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(span.getStartEpochNanos()));\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(span.getStartEpochNanos());\n+    String elapsedSecondsStr =\n+        span.getHasEnded()\n+            ? String.format(\"%.6f\", (span.getEndEpochNanos() - span.getStartEpochNanos()) * 1.0e-9)\n+            : String.format(\"%s\", \"\");\n+    formatter.format(\n+        \"<tr style=\\\"background-color: %s;\\\">\", zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+    formatter.format(\n+        \"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\"><b>\"\n+            + \"%04d/%02d/%02d-%02d:%02d:%02d.%06d</b></pre></td>\",\n+        calendar.get(Calendar.YEAR),\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        microsField);\n+    formatter.format(\n+        \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\"><b>%s</b></pre></td>\",\n+        elapsedSecondsStr);\n+    formatter.format(\n+        \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\"><b>\"\n+            + \"TraceId: <b style=\\\"color:%s;\\\">%s</b> \"\n+            + \" | SpanId: %s | ParentSpanId: %s</b></pre></td>\",\n+        span.getTraceFlags().isSampled() ? SAMPLED_TRACE_ID_COLOR : NOT_SAMPLED_TRACE_ID_COLOR,\n+        span.getTraceId().toLowerBase16(),\n+        span.getSpanId().toLowerBase16(),\n+        (span.getParentSpanId() == null\n+            ? SpanId.getInvalid().toLowerBase16()\n+            : span.getParentSpanId().toLowerBase16()));\n+    out.write(\"</tr>\");\n+    zebraStripe = !zebraStripe;\n+\n+    int lastEntryDayOfYear = calendar.get(Calendar.DAY_OF_YEAR);\n+\n+    long lastEpochNanos = span.getStartEpochNanos();\n+    List<Event> timedEvents = new ArrayList<>(span.getEvents());\n+    Collections.sort(timedEvents, new EventComparator());\n+    for (Event event : timedEvents) {\n+      calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(event.getEpochNanos()));\n+      formatter.format(\n+          \"<tr style=\\\"background-color: %s;\\\">\", zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+      emitSingleEvent(out, formatter, event, calendar, lastEntryDayOfYear, lastEpochNanos);\n+      out.write(\"</tr>\");\n+      if (calendar.get(Calendar.DAY_OF_YEAR) != lastEntryDayOfYear) {\n+        lastEntryDayOfYear = calendar.get(Calendar.DAY_OF_YEAR);\n+      }\n+      lastEpochNanos = event.getEpochNanos();\n+      zebraStripe = !zebraStripe;\n+    }\n+    formatter.format(\n+        \"<tr style=\\\"background-color: %s;\\\"><td></td><td class=\\\"border-left-dark\\\">\"\n+            + \"</td><td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">\",\n+        zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+    Status status = span.getStatus();\n+    if (status != null) {\n+      formatter.format(\"%s | \", htmlEscaper().escape(status.toString()));\n+    }\n+    formatter.format(\"%s</pre></td>\", htmlEscaper().escape(renderAttributes(span.getAttributes())));\n+    zebraStripe = !zebraStripe;\n+    return zebraStripe;\n+  }\n+\n+  private static void emitSingleEvent(\n+      PrintWriter out,\n+      Formatter formatter,\n+      Event event,\n+      Calendar calendar,\n+      int lastEntryDayOfYear,\n+      long lastEpochNanos) {\n+    if (calendar.get(Calendar.DAY_OF_YEAR) == lastEntryDayOfYear) {\n+      out.write(\"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\">\");\n+    } else {\n+      formatter.format(\n+          \"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\">%04d/%02d/%02d-\",\n+          calendar.get(Calendar.YEAR),\n+          calendar.get(Calendar.MONTH) + 1,\n+          calendar.get(Calendar.DAY_OF_MONTH));\n+    }\n+\n+    // Special printing so that durations smaller than one second\n+    // are left padded with blanks instead of '0' characters.\n+    // E.g.,\n+    //        Number                  Printout\n+    //        ---------------------------------\n+    //        0.000534                  .   534\n+    //        1.000534                 1.000534\n+    long deltaMicros = TimeUnit.NANOSECONDS.toMicros(event.getEpochNanos() - lastEpochNanos);\n+    String deltaString;\n+    if (deltaMicros >= 1000000) {\n+      deltaString = String.format(\"%.6f\", (deltaMicros / 1000000.0));\n+    } else {\n+      deltaString = String.format(\"%1s.%6d\", \"\", deltaMicros);\n+    }\n+\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(event.getEpochNanos());\n+    formatter.format(\n+        \"%02d:%02d:%02d.%06d</pre></td> \"\n+            + \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">%s</pre></td>\"\n+            + \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">%s</pre></td>\",\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        microsField,\n+        deltaString,\n+        htmlEscaper().escape(renderEvent(event)));\n+  }\n+\n+  private static String renderAttributes(ReadableAttributes attributes) {\n+    final StringBuilder stringBuilder = new StringBuilder();\n+    stringBuilder.append(\"Attributes:{\");\n+    final AtomicBoolean first = new AtomicBoolean(true);\n+    attributes.forEach(\n+        new KeyValueConsumer<AttributeValue>() {\n+          @Override\n+          public void consume(String key, AttributeValue value) {\n+            if (!first.getAndSet(false)) {\n+              stringBuilder.append(\", \");\n+            }\n+            stringBuilder.append(key);\n+            stringBuilder.append(\"=\");\n+            stringBuilder.append(value.toString());\n+          }\n+        });\n+    stringBuilder.append(\"}\");\n+    return stringBuilder.toString();\n+  }\n+\n+  private static String renderEvent(Event event) {\n+    StringBuilder stringBuilder = new StringBuilder();\n+    stringBuilder.append(event.getName());\n+    if (!event.getAttributes().isEmpty()) {\n+      stringBuilder.append(\" | \");\n+      stringBuilder.append(renderAttributes(event.getAttributes()));\n+    }\n+    return stringBuilder.toString();\n+  }\n+\n+  /**\n+   * Emits HTML body content to the {@link PrintWriter} {@code out}. Content emited by this function\n+   * should be enclosed by <body></body> tag.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   */\n+  private void emitHtmlBody(Map<String, String> queryMap, PrintWriter out)\n+      throws UnsupportedEncodingException {\n+    if (dataAggregator == null) {\n+      out.write(\"OpenTelemetry implementation not available.\");\n+      return;\n+    }\n+    // Link to OpenTelemetry Logo\n+    out.write(\n+        \"<img style=\\\"height: 90px;\\\"\"\n+            + \"src=\\\"https://opentelemetry.io/img/logos/opentelemetry-horizontal-color.png\\\" />\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425e436b9954219329b0b54327cdc2ca3493a287"}, "originalPosition": 450}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NDYyMDIw", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-439462020", "createdAt": "2020-06-29T20:07:12Z", "commit": {"oid": "425e436b9954219329b0b54327cdc2ca3493a287"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMDowNzoxMlrOGqgTwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMDowNzoxMlrOGqgTwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIyMjcyMg==", "bodyText": "I'm pretty hesitant to depend on anything in the com.sun namespace. There is no guarentee that all JDKs will support this, or that these classes will be around in the future.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447222722", "createdAt": "2020-06-29T20:07:12Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageHttpHandler.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425e436b9954219329b0b54327cdc2ca3493a287"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NzMyNDk3", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-439732497", "createdAt": "2020-06-30T07:16:32Z", "commit": {"oid": "425e436b9954219329b0b54327cdc2ca3493a287"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNzoxNjozMlrOGqu6jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNzoxNjozMlrOGqu6jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ2MjAzMQ==", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright 2019, OpenTelemetry Authors\n          \n          \n            \n             * Copyright 2020, OpenTelemetry Authors", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447462031", "createdAt": "2020-06-30T07:16:32Z", "author": {"login": "thisthat"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425e436b9954219329b0b54327cdc2ca3493a287"}, "originalPosition": 2}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NzM0MzU3", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-439734357", "createdAt": "2020-06-30T07:19:19Z", "commit": {"oid": "425e436b9954219329b0b54327cdc2ca3493a287"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNzoxOToxOVrOGqvAUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNzoxOToxOVrOGqvAUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ2MzUwNQ==", "bodyText": "SimpleSpanProcessor uses this env var. I suggest using your own name, e.g. otel.zpages.export.sampled", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447463505", "createdAt": "2020-06-30T07:19:19Z", "author": {"login": "thisthat"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * can be read from system properties, environment variables, or {@link java.util.Properties}\n+ * objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link\n+ * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.ssp.export.sampled}: sets whether only sampled spans should be exported.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425e436b9954219329b0b54327cdc2ca3493a287"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMDc3NDc0", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-440077474", "createdAt": "2020-06-30T14:32:10Z", "commit": {"oid": "425e436b9954219329b0b54327cdc2ca3493a287"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNDozMjoxMFrOGq_TZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNDozMjoxMFrOGq_TZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzczMDUzMg==", "bodyText": "Return a copy perhaps?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r447730532", "createdAt": "2020-06-30T14:32:10Z", "author": {"login": "carlosalberto"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * can be read from system properties, environment variables, or {@link java.util.Properties}\n+ * objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link\n+ * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.ssp.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_SSP_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+public final class TracezSpanProcessor implements SpanProcessor {\n+  private final Map<SpanId, ReadableSpan> runningSpanCache;\n+  private final Map<SpanId, ReadableSpan> completedSpanCache;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  public TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new HashMap<>();\n+    completedSpanCache = new HashMap<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    synchronized (this) {\n+      runningSpanCache.put(span.getSpanContext().getSpanId(), span);\n+    }\n+  }\n+\n+  @Override\n+  public boolean isStartRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void onEnd(ReadableSpan span) {\n+    SpanId id = span.getSpanContext().getSpanId();\n+    synchronized (this) {\n+      runningSpanCache.remove(id);\n+      if (!sampled || span.getSpanContext().getTraceFlags().isSampled()) {\n+        completedSpanCache.put(id, span);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public boolean isEndRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    // Do nothing.\n+  }\n+\n+  @Override\n+  public void forceFlush() {\n+    // Do nothing.\n+  }\n+\n+  /**\n+   * Returns a Collection of all running spans for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   *\n+   * @return a Collection of {@link io.opentelemetry.sdk.trace.ReadableSpan}.\n+   */\n+  public Collection<ReadableSpan> getRunningSpans() {\n+    synchronized (this) {\n+      return runningSpanCache.values();\n+    }\n+  }\n+\n+  /**\n+   * Returns a Collection of all completed spans for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   *\n+   * @return a Collection of {@link io.opentelemetry.sdk.trace.ReadableSpan}.\n+   */\n+  public Collection<ReadableSpan> getCompletedSpans() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "425e436b9954219329b0b54327cdc2ca3493a287"}, "originalPosition": 123}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f282f241ab9e6b4223576ab376dfca7543c3a8f", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/0f282f241ab9e6b4223576ab376dfca7543c3a8f", "committedDate": "2020-06-30T20:29:14Z", "message": "Changed inline base64 images"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/a2ef65c69dc473bd7fe00e136e5f41b14bd3d514", "committedDate": "2020-06-30T20:33:14Z", "message": "Fixed copyright statement"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNDYzMjQz", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-440463243", "createdAt": "2020-07-01T00:01:24Z", "commit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514"}, "state": "COMMENTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDowMToyNVrOGrSasw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDo0NjoxMFrOGrTJMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0MzY5OQ==", "bodyText": "Looks like can be package private", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448043699", "createdAt": "2020-07-01T00:01:25Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+public final class TracezDataAggregator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0NDEzMA==", "bodyText": "Should we have a cap on the size of this? running spans seems small, but worried about the size of completed spans.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448044130", "createdAt": "2020-07-01T00:02:55Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+public final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  public TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  public Set<String> getSpanNames() {\n+    Set<String> spanNames = new TreeSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0NDgzNQ==", "bodyText": "Looks like we have a dependency on Guava. How about using immutable collections (e.g. ImmutableSortedSet) for all of these?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448044835", "createdAt": "2020-07-01T00:05:41Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+public final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  public TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  public Set<String> getSpanNames() {\n+    Set<String> spanNames = new TreeSet<>();\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0NjYwNg==", "bodyText": "@jkwatson What do you think about adding .getStatus to ReadableSpan (I guess it should really have all the getters?). Going through toSpanData just to check if the span is ok seems off.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448046606", "createdAt": "2020-07-01T00:11:33Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+public final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  public TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  public Set<String> getSpanNames() {\n+    Set<String> spanNames = new TreeSet<>();\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    for (ReadableSpan span : allRunningSpans) {\n+      spanNames.add(span.getName());\n+    }\n+    Collection<ReadableSpan> allCompletedSpans = spanProcessor.getCompletedSpans();\n+    for (ReadableSpan span : allCompletedSpans) {\n+      spanNames.add(span.getName());\n+    }\n+    return spanNames;\n+  }\n+\n+  /**\n+   * Returns a Map of the running span counts for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @return a Map of span counts for each span name.\n+   */\n+  public Map<String, Integer> getRunningSpanCounts() {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    Map<String, Integer> numSpansPerName = new HashMap<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      Integer prevValue = numSpansPerName.get(span.getName());\n+      numSpansPerName.put(span.getName(), prevValue != null ? prevValue + 1 : 1);\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all running spans with a given span name for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link io.opentelemetry.sdk.trace.data.SpanData}.\n+   */\n+  public List<SpanData> getRunningSpans(String spanName) {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      if (span.getName().equals(spanName)) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * A class of boundaries for the latency buckets. The completed spans with a status of {@link\n+   * io.opentelemetry.trace.Status#OK} are categorized into one of these buckets om the traceZ\n+   * zPage.\n+   */\n+  public enum LatencyBoundaries {\n+    /** Stores finished successful requests of duration within the interval [0, 10us). */\n+    ZERO_MICROSx10(0, TimeUnit.MICROSECONDS.toNanos(10)),\n+\n+    /** Stores finished successful requests of duration within the interval [10us, 100us). */\n+    MICROSx10_MICROSx100(TimeUnit.MICROSECONDS.toNanos(10), TimeUnit.MICROSECONDS.toNanos(100)),\n+\n+    /** Stores finished successful requests of duration within the interval [100us, 1ms). */\n+    MICROSx100_MILLIx1(TimeUnit.MICROSECONDS.toNanos(100), TimeUnit.MILLISECONDS.toNanos(1)),\n+\n+    /** Stores finished successful requests of duration within the interval [1ms, 10ms). */\n+    MILLIx1_MILLIx10(TimeUnit.MILLISECONDS.toNanos(1), TimeUnit.MILLISECONDS.toNanos(10)),\n+\n+    /** Stores finished successful requests of duration within the interval [10ms, 100ms). */\n+    MILLIx10_MILLIx100(TimeUnit.MILLISECONDS.toNanos(10), TimeUnit.MILLISECONDS.toNanos(100)),\n+\n+    /** Stores finished successful requests of duration within the interval [100ms, 1sec). */\n+    MILLIx100_SECONDx1(TimeUnit.MILLISECONDS.toNanos(100), TimeUnit.SECONDS.toNanos(1)),\n+\n+    /** Stores finished successful requests of duration within the interval [1sec, 10sec). */\n+    SECONDx1_SECONDx10(TimeUnit.SECONDS.toNanos(1), TimeUnit.SECONDS.toNanos(10)),\n+\n+    /** Stores finished successful requests of duration within the interval [10sec, 100sec). */\n+    SECONDx10_SECONDx100(TimeUnit.SECONDS.toNanos(10), TimeUnit.SECONDS.toNanos(100)),\n+\n+    /** Stores finished successful requests of duration greater than or equal to 100sec. */\n+    SECONDx100_MAX(TimeUnit.SECONDS.toNanos(100), Long.MAX_VALUE);\n+\n+    private final long latencyLowerBound;\n+    private final long latencyUpperBound;\n+\n+    /**\n+     * Constructs a {@code LatencyBoundaries} with the given boundaries and label.\n+     *\n+     * @param latencyLowerBound the latency lower bound of the bucket.\n+     * @param latencyUpperBound the latency upper bound of the bucket.\n+     */\n+    LatencyBoundaries(long latencyLowerBound, long latencyUpperBound) {\n+      this.latencyLowerBound = latencyLowerBound;\n+      this.latencyUpperBound = latencyUpperBound;\n+    }\n+\n+    /**\n+     * Returns the latency lower bound of the bucket.\n+     *\n+     * @return the latency lower bound of the bucket.\n+     */\n+    public long getLatencyLowerBound() {\n+      return latencyLowerBound;\n+    }\n+\n+    /**\n+     * Returns the latency upper bound of the bucket.\n+     *\n+     * @return the latency upper bound of the bucket.\n+     */\n+    public long getLatencyUpperBound() {\n+      return latencyUpperBound;\n+    }\n+  }\n+\n+  /**\n+   * Returns a Map of counts for the {@link io.opentelemetry.trace.Status#OK} spans within\n+   * [lowerBound, upperBound) {@link io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @param lowerBound latency lower bound (inclusive)\n+   * @param upperBound latency upper bound (exclusive)\n+   * @return a Map of span counts for each span name within the bounds.\n+   */\n+  public Map<String, Integer> getSpanLatencyCounts(long lowerBound, long upperBound) {\n+    Collection<ReadableSpan> allCompletedSpans = spanProcessor.getCompletedSpans();\n+    Map<String, Integer> numSpansPerName = new HashMap<>();\n+    for (ReadableSpan span : allCompletedSpans) {\n+      if (span.toSpanData().getStatus().isOk()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0ODAwOQ==", "bodyText": "caffeine is pretty small and a great library, would consider it if we end up with an LRU. We want to keep dependencies light but I would definitely want a good cache implementation backing a span processor that hits every span.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448048009", "createdAt": "2020-07-01T00:16:58Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * can be read from system properties, environment variables, or {@link java.util.Properties}\n+ * objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link\n+ * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.ssp.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_SSP_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+public final class TracezSpanProcessor implements SpanProcessor {\n+  private final Map<SpanId, ReadableSpan> runningSpanCache;\n+  private final Map<SpanId, ReadableSpan> completedSpanCache;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  public TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new HashMap<>();\n+    completedSpanCache = new HashMap<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    synchronized (this) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIxMzU3OQ=="}, "originalCommit": {"oid": "425e436b9954219329b0b54327cdc2ca3493a287"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0ODkyOQ==", "bodyText": "I see there is mention about capping the size of this map, but in general I'm sort of concerned about the design of the class if it's based on keeping a map of all completed spans. Can we incrementally update data structures in this class instead? Keeping running spans as a map is ok I think since it should be bounded and avoids having to both incrementally update and revert structures, but if I'm not missing it, it seems that all the structures computed from this map can be inlined and updated incrementally instead?\nOf course if going with incremental, the comment about Immutable goes away :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448048929", "createdAt": "2020-07-01T00:20:32Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * can be read from system properties, environment variables, or {@link java.util.Properties}\n+ * objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link\n+ * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.ssp.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_SSP_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+public final class TracezSpanProcessor implements SpanProcessor {\n+  private final Map<SpanId, ReadableSpan> runningSpanCache;\n+  private final Map<SpanId, ReadableSpan> completedSpanCache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MDA0MQ==", "bodyText": "I see the dependency in build.gradle, I guess either way we're requiring it as a dependency, not relying on the JDK? Want to make sure I didn't miss something", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448050041", "createdAt": "2020-07-01T00:24:59Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageHttpHandler.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIyMjcyMg=="}, "originalCommit": {"oid": "425e436b9954219329b0b54327cdc2ca3493a287"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MDY0Nw==", "bodyText": "Let's use try / resources, think there's plenty of room for exceptions in the middle causing a leak.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448050647", "createdAt": "2020-07-01T00:27:13Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator.LatencyBoundaries;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.BufferedWriter;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  @javax.annotation.Nullable private final TracezDataAggregator dataAggregator;\n+  // Map from LatencyBoundaries to human readable string on the UI\n+  private static final ImmutableMap<LatencyBoundaries, String> LATENCY_BOUNDARIES_STRING_MAP =\n+      buildLatencyBoundariesStringMap();\n+\n+  private TracezZPageHandler(TracezDataAggregator dataAggregator) {\n+    this.dataAggregator = dataAggregator;\n+  }\n+\n+  /**\n+   * Constructs a new {@code TracezZPageHandler}.\n+   *\n+   * @return a new {@code TracezZPageHandler}.\n+   */\n+  static TracezZPageHandler create(@javax.annotation.Nullable TracezDataAggregator dataAggregator) {\n+    return new TracezZPageHandler(dataAggregator);\n+  }\n+\n+  @Override\n+  public String getUrlPath() {\n+    return TRACEZ_URL;\n+  }\n+\n+  /**\n+   * Emits CSS Styles to the {@link PrintWriter} {@code out}. Content emited by this function should\n+   * be enclosed by <head></head> tag.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   */\n+  private static void emitHtmlStyle(PrintWriter out) {\n+    out.write(\"<style>\");\n+    out.write(ZPageStyle.style);\n+    out.write(\"</style>\");\n+  }\n+\n+  /**\n+   * Emits the header of the summary table to the {@link PrintWriter} {@code out}.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   * @param formatter A {@link Formatter} for formatting HTML expressions.\n+   */\n+  private static void emitSummaryTableHeader(PrintWriter out, Formatter formatter) {\n+    // First row\n+    out.write(\"<tr class=\\\"bg-color\\\">\");\n+    out.write(\"<th colspan=1 class=\\\"header-text\\\"><b>Span Name</b></th>\");\n+    out.write(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Running</b></th>\");\n+    out.write(\"<th colspan=9 class=\\\"header-text border-left-white\\\"><b>Latency Samples</b></th>\");\n+    out.write(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Error Samples</b></th>\");\n+    out.write(\"</tr>\");\n+\n+    // Second row\n+    out.write(\"<tr class=\\\"bg-color\\\">\");\n+    out.write(\"<th colspan=1></th>\");\n+    out.write(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    for (LatencyBoundaries latencyBoundaries : LatencyBoundaries.values()) {\n+      formatter.format(\n+          \"<th colspan=1 class=\\\"border-left-white align-center\\\"\"\n+              + \"style=\\\"color: #fff;\\\"><b>[%s]</b></th>\",\n+          LATENCY_BOUNDARIES_STRING_MAP.get(latencyBoundaries));\n+    }\n+    out.write(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    out.write(\"</tr>\");\n+  }\n+\n+  /**\n+   * Emits a single cell of the summary table depends on the paramters passed in, to the {@link\n+   * PrintWriter} {@code out}.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   * @param formatter {@link Formatter} for formatting HTML expressions.\n+   * @param spanName The name of the corresponding span.\n+   * @param numOfSamples The number of samples of the corresponding span.\n+   * @param type The type of the corresponding span (running, latency, error).\n+   * @param subtype The sub-type of the corresponding span (latency [0, 8], error [0, 15]).\n+   */\n+  private static void emitSummaryTableCell(\n+      PrintWriter out,\n+      Formatter formatter,\n+      String spanName,\n+      int numOfSamples,\n+      SampleType type,\n+      int subtype)\n+      throws UnsupportedEncodingException {\n+    // If numOfSamples is greater than 0, emit a link to see detailed span information\n+    // If numOfSamples is smaller than 0, print the text \"N/A\", otherwise print the text \"0\"\n+    if (numOfSamples > 0) {\n+      formatter.format(\n+          \"<td class=\\\"align-center border-left-dark\\\"><a href=\\\"?%s=%s&%s=%d&%s=%d\\\">%d</a></td>\",\n+          PARAM_SPAN_NAME,\n+          URLEncoder.encode(spanName, \"UTF-8\"),\n+          PARAM_SAMPLE_TYPE,\n+          type.getValue(),\n+          PARAM_SAMPLE_SUB_TYPE,\n+          subtype,\n+          numOfSamples);\n+    } else if (numOfSamples < 0) {\n+      out.write(\"<td class=\\\"align-center border-left-dark\\\">N/A</td>\");\n+    } else {\n+      out.write(\"<td class=\\\"align-center border-left-dark\\\">0</td>\");\n+    }\n+  }\n+\n+  /**\n+   * Emits the summary table of running spans and sampled spans to the {@link PrintWriter} {@code\n+   * out}.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   * @param formatter A {@link Formatter} for formatting HTML expressions.\n+   */\n+  private void emitSummaryTable(PrintWriter out, Formatter formatter)\n+      throws UnsupportedEncodingException {\n+    if (dataAggregator == null) {\n+      return;\n+    }\n+    out.write(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    emitSummaryTableHeader(out, formatter);\n+\n+    Set<String> spanNames = dataAggregator.getSpanNames();\n+    boolean zebraStripe = false;\n+\n+    Map<String, Integer> runningSpanCounts = dataAggregator.getRunningSpanCounts();\n+    Map<String, Map<LatencyBoundaries, Integer>> latencySpanCounts =\n+        dataAggregator.getSpanLatencyCounts();\n+    Map<String, Integer> errorSpanCounts = dataAggregator.getErrorSpanCounts();\n+    for (String spanName : spanNames) {\n+      if (zebraStripe) {\n+        formatter.format(\"<tr style=\\\"background-color: %s\\\">\", ZEBRA_STRIPE_COLOR);\n+      } else {\n+        out.write(\"<tr>\");\n+      }\n+      zebraStripe = !zebraStripe;\n+      formatter.format(\"<td>%s</td>\", htmlEscaper().escape(spanName));\n+\n+      // Running spans column\n+      int numOfRunningSpans =\n+          runningSpanCounts.containsKey(spanName) ? runningSpanCounts.get(spanName) : 0;\n+      // subtype is ignored for running spans\n+      emitSummaryTableCell(out, formatter, spanName, numOfRunningSpans, SampleType.RUNNING, 0);\n+\n+      // Latency based sampled spans column\n+      int subtype = 0;\n+      for (LatencyBoundaries latencyBoundaries : LatencyBoundaries.values()) {\n+        int numOfLatencySamples =\n+            latencySpanCounts.containsKey(spanName)\n+                    && latencySpanCounts.get(spanName).containsKey(latencyBoundaries)\n+                ? latencySpanCounts.get(spanName).get(latencyBoundaries)\n+                : 0;\n+        emitSummaryTableCell(\n+            out, formatter, spanName, numOfLatencySamples, SampleType.LATENCY, subtype);\n+        subtype += 1;\n+      }\n+\n+      // Error based sampled spans column\n+      int numOfErrorSamples =\n+          errorSpanCounts.containsKey(spanName) ? errorSpanCounts.get(spanName) : 0;\n+      // subtype 0 means all errors\n+      emitSummaryTableCell(out, formatter, spanName, numOfErrorSamples, SampleType.ERROR, 0);\n+    }\n+    out.write(\"</table>\");\n+  }\n+\n+  private static void emitSpanNameAndCount(\n+      Formatter formatter, String spanName, int count, SampleType type) {\n+    formatter.format(\n+        \"<p class=\\\"align-center\\\"><b> Span Name: %s </b></p>\", htmlEscaper().escape(spanName));\n+    formatter.format(\n+        \"<p class=\\\"align-center\\\"><b> Number of %s: %d </b></p>\",\n+        type == SampleType.RUNNING\n+            ? \"running\"\n+            : type == SampleType.LATENCY ? \"latency samples\" : \"error samples\",\n+        count);\n+  }\n+\n+  private static void emitSpanDetails(\n+      PrintWriter out, Formatter formatter, Collection<SpanData> spans) {\n+    out.write(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    out.write(\"<tr class=\\\"bg-color\\\">\");\n+    out.write(\n+        \"<td style=\\\"color: #fff;\\\"><pre class=\\\"no-margin wrap-text\\\"><b>When</b></pre></td>\");\n+    out.write(\n+        \"<td class=\\\"border-left-white\\\" style=\\\"color: #fff;\\\">\"\n+            + \"<pre class=\\\"no-margin wrap-text\\\"><b>Elapsed(s)</b></pre></td>\");\n+    out.write(\"<td class=\\\"border-left-white\\\"></td>\");\n+    out.write(\"</tr>\");\n+    boolean zebraStripe = false;\n+    for (SpanData span : spans) {\n+      zebraStripe = emitSingleSpan(out, formatter, span, zebraStripe);\n+    }\n+    out.write(\"</table>\");\n+  }\n+\n+  private static boolean emitSingleSpan(\n+      PrintWriter out, Formatter formatter, SpanData span, boolean zebraStripe) {\n+    Calendar calendar = Calendar.getInstance();\n+    calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(span.getStartEpochNanos()));\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(span.getStartEpochNanos());\n+    String elapsedSecondsStr =\n+        span.getHasEnded()\n+            ? String.format(\"%.6f\", (span.getEndEpochNanos() - span.getStartEpochNanos()) * 1.0e-9)\n+            : String.format(\"%s\", \"\");\n+    formatter.format(\n+        \"<tr style=\\\"background-color: %s;\\\">\", zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+    formatter.format(\n+        \"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\"><b>\"\n+            + \"%04d/%02d/%02d-%02d:%02d:%02d.%06d</b></pre></td>\",\n+        calendar.get(Calendar.YEAR),\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        microsField);\n+    formatter.format(\n+        \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\"><b>%s</b></pre></td>\",\n+        elapsedSecondsStr);\n+    formatter.format(\n+        \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\"><b>\"\n+            + \"TraceId: <b style=\\\"color:%s;\\\">%s</b> \"\n+            + \" | SpanId: %s | ParentSpanId: %s</b></pre></td>\",\n+        span.getTraceFlags().isSampled() ? SAMPLED_TRACE_ID_COLOR : NOT_SAMPLED_TRACE_ID_COLOR,\n+        span.getTraceId().toLowerBase16(),\n+        span.getSpanId().toLowerBase16(),\n+        (span.getParentSpanId() == null\n+            ? SpanId.getInvalid().toLowerBase16()\n+            : span.getParentSpanId().toLowerBase16()));\n+    out.write(\"</tr>\");\n+    zebraStripe = !zebraStripe;\n+\n+    int lastEntryDayOfYear = calendar.get(Calendar.DAY_OF_YEAR);\n+\n+    long lastEpochNanos = span.getStartEpochNanos();\n+    List<Event> timedEvents = new ArrayList<>(span.getEvents());\n+    Collections.sort(timedEvents, new EventComparator());\n+    for (Event event : timedEvents) {\n+      calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(event.getEpochNanos()));\n+      formatter.format(\n+          \"<tr style=\\\"background-color: %s;\\\">\", zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+      emitSingleEvent(out, formatter, event, calendar, lastEntryDayOfYear, lastEpochNanos);\n+      out.write(\"</tr>\");\n+      if (calendar.get(Calendar.DAY_OF_YEAR) != lastEntryDayOfYear) {\n+        lastEntryDayOfYear = calendar.get(Calendar.DAY_OF_YEAR);\n+      }\n+      lastEpochNanos = event.getEpochNanos();\n+      zebraStripe = !zebraStripe;\n+    }\n+    formatter.format(\n+        \"<tr style=\\\"background-color: %s;\\\"><td></td><td class=\\\"border-left-dark\\\">\"\n+            + \"</td><td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">\",\n+        zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+    Status status = span.getStatus();\n+    if (status != null) {\n+      formatter.format(\"%s | \", htmlEscaper().escape(status.toString()));\n+    }\n+    formatter.format(\"%s</pre></td>\", htmlEscaper().escape(renderAttributes(span.getAttributes())));\n+    zebraStripe = !zebraStripe;\n+    return zebraStripe;\n+  }\n+\n+  private static void emitSingleEvent(\n+      PrintWriter out,\n+      Formatter formatter,\n+      Event event,\n+      Calendar calendar,\n+      int lastEntryDayOfYear,\n+      long lastEpochNanos) {\n+    if (calendar.get(Calendar.DAY_OF_YEAR) == lastEntryDayOfYear) {\n+      out.write(\"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\">\");\n+    } else {\n+      formatter.format(\n+          \"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\">%04d/%02d/%02d-\",\n+          calendar.get(Calendar.YEAR),\n+          calendar.get(Calendar.MONTH) + 1,\n+          calendar.get(Calendar.DAY_OF_MONTH));\n+    }\n+\n+    // Special printing so that durations smaller than one second\n+    // are left padded with blanks instead of '0' characters.\n+    // E.g.,\n+    //        Number                  Printout\n+    //        ---------------------------------\n+    //        0.000534                  .   534\n+    //        1.000534                 1.000534\n+    long deltaMicros = TimeUnit.NANOSECONDS.toMicros(event.getEpochNanos() - lastEpochNanos);\n+    String deltaString;\n+    if (deltaMicros >= 1000000) {\n+      deltaString = String.format(\"%.6f\", (deltaMicros / 1000000.0));\n+    } else {\n+      deltaString = String.format(\"%1s.%6d\", \"\", deltaMicros);\n+    }\n+\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(event.getEpochNanos());\n+    formatter.format(\n+        \"%02d:%02d:%02d.%06d</pre></td> \"\n+            + \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">%s</pre></td>\"\n+            + \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">%s</pre></td>\",\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        microsField,\n+        deltaString,\n+        htmlEscaper().escape(renderEvent(event)));\n+  }\n+\n+  private static String renderAttributes(ReadableAttributes attributes) {\n+    final StringBuilder stringBuilder = new StringBuilder();\n+    stringBuilder.append(\"Attributes:{\");\n+    final AtomicBoolean first = new AtomicBoolean(true);\n+    attributes.forEach(\n+        new KeyValueConsumer<AttributeValue>() {\n+          @Override\n+          public void consume(String key, AttributeValue value) {\n+            if (!first.getAndSet(false)) {\n+              stringBuilder.append(\", \");\n+            }\n+            stringBuilder.append(key);\n+            stringBuilder.append(\"=\");\n+            stringBuilder.append(value.toString());\n+          }\n+        });\n+    stringBuilder.append(\"}\");\n+    return stringBuilder.toString();\n+  }\n+\n+  private static String renderEvent(Event event) {\n+    StringBuilder stringBuilder = new StringBuilder();\n+    stringBuilder.append(event.getName());\n+    if (!event.getAttributes().isEmpty()) {\n+      stringBuilder.append(\" | \");\n+      stringBuilder.append(renderAttributes(event.getAttributes()));\n+    }\n+    return stringBuilder.toString();\n+  }\n+\n+  /**\n+   * Emits HTML body content to the {@link PrintWriter} {@code out}. Content emited by this function\n+   * should be enclosed by <body></body> tag.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   */\n+  private void emitHtmlBody(Map<String, String> queryMap, PrintWriter out)\n+      throws UnsupportedEncodingException {\n+    if (dataAggregator == null) {\n+      out.write(\"OpenTelemetry implementation not available.\");\n+      return;\n+    }\n+    // Link to OpenTelemetry Logo\n+    out.write(\n+        \"<img style=\\\"height: 90px;\\\"\"\n+            + \"src=\\\"data:image/png;base64,\"\n+            + ZPageLogo.logoBase64\n+            + \"\\\" />\");\n+    out.write(\"<h1>TraceZ Summary</h1>\");\n+    Formatter formatter = new Formatter(out, Locale.US);\n+    emitSummaryTable(out, formatter);\n+    // spanName will be null if the query parameter doesn't exist in the URL\n+    String spanName = queryMap.get(PARAM_SPAN_NAME);\n+    if (spanName != null) {\n+      // Show detailed information for the corresponding span\n+      String typeStr = queryMap.get(PARAM_SAMPLE_TYPE);\n+      if (typeStr != null) {\n+        List<SpanData> spans = null;\n+        SampleType type = SampleType.fromString(typeStr);\n+        if (type == SampleType.UNKNOWN) {\n+          // Type of sample is garbage value\n+          return;\n+        } else if (type == SampleType.RUNNING) {\n+          // Display running span\n+          spans = dataAggregator.getRunningSpans(spanName);\n+          Collections.sort(spans, new SpanDataComparator(/* incremental= */ true));\n+        } else {\n+          String subtypeStr = queryMap.get(PARAM_SAMPLE_SUB_TYPE);\n+          if (subtypeStr != null) {\n+            int subtype = Integer.parseInt(subtypeStr);\n+            if (type == SampleType.LATENCY) {\n+              if (subtype < 0 || subtype >= LatencyBoundaries.values().length) {\n+                // N/A or out-of-bound check for latency based subtype, valid values: [0, 8]\n+                return;\n+              }\n+              // Display latency based span\n+              LatencyBoundaries latencyBoundary = LatencyBoundaries.values()[subtype];\n+              spans =\n+                  dataAggregator.getOkSpans(\n+                      spanName,\n+                      latencyBoundary.getLatencyLowerBound(),\n+                      latencyBoundary.getLatencyUpperBound());\n+              Collections.sort(spans, new SpanDataComparator(/* incremental= */ false));\n+            } else {\n+              if (subtype < 0 || subtype >= CanonicalCode.values().length) {\n+                // N/A or out-of-bound cueck for error based subtype, valid values: [0, 15]\n+                return;\n+              }\n+              // Display error based span\n+              spans = dataAggregator.getErrorSpans(spanName);\n+              Collections.sort(spans, new SpanDataComparator(/* incremental= */ false));\n+            }\n+          }\n+        }\n+        out.write(\"<h2>Span Details</h2>\");\n+        emitSpanNameAndCount(formatter, spanName, spans == null ? 0 : spans.size(), type);\n+\n+        if (spans != null) {\n+          emitSpanDetails(out, formatter, spans);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void emitHtml(Map<String, String> queryMap, OutputStream outputStream) {\n+    // PrintWriter for emiting HTML contents\n+    PrintWriter out =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514"}, "originalPosition": 512}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MTc5MQ==", "bodyText": "Think we can keep this package private since the server class registers it. We could also have a factory that returns SpanProcessor if that seems useful without exposing the implementation class", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448051791", "createdAt": "2020-07-01T00:31:36Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * can be read from system properties, environment variables, or {@link java.util.Properties}\n+ * objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link\n+ * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.ssp.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_SSP_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+public final class TracezSpanProcessor implements SpanProcessor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MjAyOA==", "bodyText": "Import @Nullable", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448052028", "createdAt": "2020-07-01T00:32:27Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator.LatencyBoundaries;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.BufferedWriter;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  @javax.annotation.Nullable private final TracezDataAggregator dataAggregator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MjA3Ng==", "bodyText": "Group static finals together above normal final field", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448052076", "createdAt": "2020-07-01T00:32:39Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator.LatencyBoundaries;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.BufferedWriter;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  @javax.annotation.Nullable private final TracezDataAggregator dataAggregator;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MjAyOA=="}, "originalCommit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MjIwNw==", "bodyText": "@Nullable on parameter", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448052207", "createdAt": "2020-07-01T00:33:13Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator.LatencyBoundaries;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.BufferedWriter;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  @javax.annotation.Nullable private final TracezDataAggregator dataAggregator;\n+  // Map from LatencyBoundaries to human readable string on the UI\n+  private static final ImmutableMap<LatencyBoundaries, String> LATENCY_BOUNDARIES_STRING_MAP =\n+      buildLatencyBoundariesStringMap();\n+\n+  private TracezZPageHandler(TracezDataAggregator dataAggregator) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MjI1Nw==", "bodyText": "The class is package private, I think we can make the constructor package private and remove this factory", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448052257", "createdAt": "2020-07-01T00:33:26Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator.LatencyBoundaries;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.BufferedWriter;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  @javax.annotation.Nullable private final TracezDataAggregator dataAggregator;\n+  // Map from LatencyBoundaries to human readable string on the UI\n+  private static final ImmutableMap<LatencyBoundaries, String> LATENCY_BOUNDARIES_STRING_MAP =\n+      buildLatencyBoundariesStringMap();\n+\n+  private TracezZPageHandler(TracezDataAggregator dataAggregator) {\n+    this.dataAggregator = dataAggregator;\n+  }\n+\n+  /**\n+   * Constructs a new {@code TracezZPageHandler}.\n+   *\n+   * @return a new {@code TracezZPageHandler}.\n+   */\n+  static TracezZPageHandler create(@javax.annotation.Nullable TracezDataAggregator dataAggregator) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzI0Ng==", "bodyText": "Think we can just use PrintStream since we're going to an OutputStream anyways.\nAlso I'd leave the BufferedWriter or BufferedOutputStream out here and let callers pass it in, they may not want the buffering.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448053246", "createdAt": "2020-07-01T00:37:11Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator.LatencyBoundaries;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.BufferedWriter;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  @javax.annotation.Nullable private final TracezDataAggregator dataAggregator;\n+  // Map from LatencyBoundaries to human readable string on the UI\n+  private static final ImmutableMap<LatencyBoundaries, String> LATENCY_BOUNDARIES_STRING_MAP =\n+      buildLatencyBoundariesStringMap();\n+\n+  private TracezZPageHandler(TracezDataAggregator dataAggregator) {\n+    this.dataAggregator = dataAggregator;\n+  }\n+\n+  /**\n+   * Constructs a new {@code TracezZPageHandler}.\n+   *\n+   * @return a new {@code TracezZPageHandler}.\n+   */\n+  static TracezZPageHandler create(@javax.annotation.Nullable TracezDataAggregator dataAggregator) {\n+    return new TracezZPageHandler(dataAggregator);\n+  }\n+\n+  @Override\n+  public String getUrlPath() {\n+    return TRACEZ_URL;\n+  }\n+\n+  /**\n+   * Emits CSS Styles to the {@link PrintWriter} {@code out}. Content emited by this function should\n+   * be enclosed by <head></head> tag.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   */\n+  private static void emitHtmlStyle(PrintWriter out) {\n+    out.write(\"<style>\");\n+    out.write(ZPageStyle.style);\n+    out.write(\"</style>\");\n+  }\n+\n+  /**\n+   * Emits the header of the summary table to the {@link PrintWriter} {@code out}.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   * @param formatter A {@link Formatter} for formatting HTML expressions.\n+   */\n+  private static void emitSummaryTableHeader(PrintWriter out, Formatter formatter) {\n+    // First row\n+    out.write(\"<tr class=\\\"bg-color\\\">\");\n+    out.write(\"<th colspan=1 class=\\\"header-text\\\"><b>Span Name</b></th>\");\n+    out.write(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Running</b></th>\");\n+    out.write(\"<th colspan=9 class=\\\"header-text border-left-white\\\"><b>Latency Samples</b></th>\");\n+    out.write(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Error Samples</b></th>\");\n+    out.write(\"</tr>\");\n+\n+    // Second row\n+    out.write(\"<tr class=\\\"bg-color\\\">\");\n+    out.write(\"<th colspan=1></th>\");\n+    out.write(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    for (LatencyBoundaries latencyBoundaries : LatencyBoundaries.values()) {\n+      formatter.format(\n+          \"<th colspan=1 class=\\\"border-left-white align-center\\\"\"\n+              + \"style=\\\"color: #fff;\\\"><b>[%s]</b></th>\",\n+          LATENCY_BOUNDARIES_STRING_MAP.get(latencyBoundaries));\n+    }\n+    out.write(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    out.write(\"</tr>\");\n+  }\n+\n+  /**\n+   * Emits a single cell of the summary table depends on the paramters passed in, to the {@link\n+   * PrintWriter} {@code out}.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   * @param formatter {@link Formatter} for formatting HTML expressions.\n+   * @param spanName The name of the corresponding span.\n+   * @param numOfSamples The number of samples of the corresponding span.\n+   * @param type The type of the corresponding span (running, latency, error).\n+   * @param subtype The sub-type of the corresponding span (latency [0, 8], error [0, 15]).\n+   */\n+  private static void emitSummaryTableCell(\n+      PrintWriter out,\n+      Formatter formatter,\n+      String spanName,\n+      int numOfSamples,\n+      SampleType type,\n+      int subtype)\n+      throws UnsupportedEncodingException {\n+    // If numOfSamples is greater than 0, emit a link to see detailed span information\n+    // If numOfSamples is smaller than 0, print the text \"N/A\", otherwise print the text \"0\"\n+    if (numOfSamples > 0) {\n+      formatter.format(\n+          \"<td class=\\\"align-center border-left-dark\\\"><a href=\\\"?%s=%s&%s=%d&%s=%d\\\">%d</a></td>\",\n+          PARAM_SPAN_NAME,\n+          URLEncoder.encode(spanName, \"UTF-8\"),\n+          PARAM_SAMPLE_TYPE,\n+          type.getValue(),\n+          PARAM_SAMPLE_SUB_TYPE,\n+          subtype,\n+          numOfSamples);\n+    } else if (numOfSamples < 0) {\n+      out.write(\"<td class=\\\"align-center border-left-dark\\\">N/A</td>\");\n+    } else {\n+      out.write(\"<td class=\\\"align-center border-left-dark\\\">0</td>\");\n+    }\n+  }\n+\n+  /**\n+   * Emits the summary table of running spans and sampled spans to the {@link PrintWriter} {@code\n+   * out}.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   * @param formatter A {@link Formatter} for formatting HTML expressions.\n+   */\n+  private void emitSummaryTable(PrintWriter out, Formatter formatter)\n+      throws UnsupportedEncodingException {\n+    if (dataAggregator == null) {\n+      return;\n+    }\n+    out.write(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    emitSummaryTableHeader(out, formatter);\n+\n+    Set<String> spanNames = dataAggregator.getSpanNames();\n+    boolean zebraStripe = false;\n+\n+    Map<String, Integer> runningSpanCounts = dataAggregator.getRunningSpanCounts();\n+    Map<String, Map<LatencyBoundaries, Integer>> latencySpanCounts =\n+        dataAggregator.getSpanLatencyCounts();\n+    Map<String, Integer> errorSpanCounts = dataAggregator.getErrorSpanCounts();\n+    for (String spanName : spanNames) {\n+      if (zebraStripe) {\n+        formatter.format(\"<tr style=\\\"background-color: %s\\\">\", ZEBRA_STRIPE_COLOR);\n+      } else {\n+        out.write(\"<tr>\");\n+      }\n+      zebraStripe = !zebraStripe;\n+      formatter.format(\"<td>%s</td>\", htmlEscaper().escape(spanName));\n+\n+      // Running spans column\n+      int numOfRunningSpans =\n+          runningSpanCounts.containsKey(spanName) ? runningSpanCounts.get(spanName) : 0;\n+      // subtype is ignored for running spans\n+      emitSummaryTableCell(out, formatter, spanName, numOfRunningSpans, SampleType.RUNNING, 0);\n+\n+      // Latency based sampled spans column\n+      int subtype = 0;\n+      for (LatencyBoundaries latencyBoundaries : LatencyBoundaries.values()) {\n+        int numOfLatencySamples =\n+            latencySpanCounts.containsKey(spanName)\n+                    && latencySpanCounts.get(spanName).containsKey(latencyBoundaries)\n+                ? latencySpanCounts.get(spanName).get(latencyBoundaries)\n+                : 0;\n+        emitSummaryTableCell(\n+            out, formatter, spanName, numOfLatencySamples, SampleType.LATENCY, subtype);\n+        subtype += 1;\n+      }\n+\n+      // Error based sampled spans column\n+      int numOfErrorSamples =\n+          errorSpanCounts.containsKey(spanName) ? errorSpanCounts.get(spanName) : 0;\n+      // subtype 0 means all errors\n+      emitSummaryTableCell(out, formatter, spanName, numOfErrorSamples, SampleType.ERROR, 0);\n+    }\n+    out.write(\"</table>\");\n+  }\n+\n+  private static void emitSpanNameAndCount(\n+      Formatter formatter, String spanName, int count, SampleType type) {\n+    formatter.format(\n+        \"<p class=\\\"align-center\\\"><b> Span Name: %s </b></p>\", htmlEscaper().escape(spanName));\n+    formatter.format(\n+        \"<p class=\\\"align-center\\\"><b> Number of %s: %d </b></p>\",\n+        type == SampleType.RUNNING\n+            ? \"running\"\n+            : type == SampleType.LATENCY ? \"latency samples\" : \"error samples\",\n+        count);\n+  }\n+\n+  private static void emitSpanDetails(\n+      PrintWriter out, Formatter formatter, Collection<SpanData> spans) {\n+    out.write(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    out.write(\"<tr class=\\\"bg-color\\\">\");\n+    out.write(\n+        \"<td style=\\\"color: #fff;\\\"><pre class=\\\"no-margin wrap-text\\\"><b>When</b></pre></td>\");\n+    out.write(\n+        \"<td class=\\\"border-left-white\\\" style=\\\"color: #fff;\\\">\"\n+            + \"<pre class=\\\"no-margin wrap-text\\\"><b>Elapsed(s)</b></pre></td>\");\n+    out.write(\"<td class=\\\"border-left-white\\\"></td>\");\n+    out.write(\"</tr>\");\n+    boolean zebraStripe = false;\n+    for (SpanData span : spans) {\n+      zebraStripe = emitSingleSpan(out, formatter, span, zebraStripe);\n+    }\n+    out.write(\"</table>\");\n+  }\n+\n+  private static boolean emitSingleSpan(\n+      PrintWriter out, Formatter formatter, SpanData span, boolean zebraStripe) {\n+    Calendar calendar = Calendar.getInstance();\n+    calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(span.getStartEpochNanos()));\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(span.getStartEpochNanos());\n+    String elapsedSecondsStr =\n+        span.getHasEnded()\n+            ? String.format(\"%.6f\", (span.getEndEpochNanos() - span.getStartEpochNanos()) * 1.0e-9)\n+            : String.format(\"%s\", \"\");\n+    formatter.format(\n+        \"<tr style=\\\"background-color: %s;\\\">\", zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+    formatter.format(\n+        \"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\"><b>\"\n+            + \"%04d/%02d/%02d-%02d:%02d:%02d.%06d</b></pre></td>\",\n+        calendar.get(Calendar.YEAR),\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        microsField);\n+    formatter.format(\n+        \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\"><b>%s</b></pre></td>\",\n+        elapsedSecondsStr);\n+    formatter.format(\n+        \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\"><b>\"\n+            + \"TraceId: <b style=\\\"color:%s;\\\">%s</b> \"\n+            + \" | SpanId: %s | ParentSpanId: %s</b></pre></td>\",\n+        span.getTraceFlags().isSampled() ? SAMPLED_TRACE_ID_COLOR : NOT_SAMPLED_TRACE_ID_COLOR,\n+        span.getTraceId().toLowerBase16(),\n+        span.getSpanId().toLowerBase16(),\n+        (span.getParentSpanId() == null\n+            ? SpanId.getInvalid().toLowerBase16()\n+            : span.getParentSpanId().toLowerBase16()));\n+    out.write(\"</tr>\");\n+    zebraStripe = !zebraStripe;\n+\n+    int lastEntryDayOfYear = calendar.get(Calendar.DAY_OF_YEAR);\n+\n+    long lastEpochNanos = span.getStartEpochNanos();\n+    List<Event> timedEvents = new ArrayList<>(span.getEvents());\n+    Collections.sort(timedEvents, new EventComparator());\n+    for (Event event : timedEvents) {\n+      calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(event.getEpochNanos()));\n+      formatter.format(\n+          \"<tr style=\\\"background-color: %s;\\\">\", zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+      emitSingleEvent(out, formatter, event, calendar, lastEntryDayOfYear, lastEpochNanos);\n+      out.write(\"</tr>\");\n+      if (calendar.get(Calendar.DAY_OF_YEAR) != lastEntryDayOfYear) {\n+        lastEntryDayOfYear = calendar.get(Calendar.DAY_OF_YEAR);\n+      }\n+      lastEpochNanos = event.getEpochNanos();\n+      zebraStripe = !zebraStripe;\n+    }\n+    formatter.format(\n+        \"<tr style=\\\"background-color: %s;\\\"><td></td><td class=\\\"border-left-dark\\\">\"\n+            + \"</td><td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">\",\n+        zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+    Status status = span.getStatus();\n+    if (status != null) {\n+      formatter.format(\"%s | \", htmlEscaper().escape(status.toString()));\n+    }\n+    formatter.format(\"%s</pre></td>\", htmlEscaper().escape(renderAttributes(span.getAttributes())));\n+    zebraStripe = !zebraStripe;\n+    return zebraStripe;\n+  }\n+\n+  private static void emitSingleEvent(\n+      PrintWriter out,\n+      Formatter formatter,\n+      Event event,\n+      Calendar calendar,\n+      int lastEntryDayOfYear,\n+      long lastEpochNanos) {\n+    if (calendar.get(Calendar.DAY_OF_YEAR) == lastEntryDayOfYear) {\n+      out.write(\"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\">\");\n+    } else {\n+      formatter.format(\n+          \"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\">%04d/%02d/%02d-\",\n+          calendar.get(Calendar.YEAR),\n+          calendar.get(Calendar.MONTH) + 1,\n+          calendar.get(Calendar.DAY_OF_MONTH));\n+    }\n+\n+    // Special printing so that durations smaller than one second\n+    // are left padded with blanks instead of '0' characters.\n+    // E.g.,\n+    //        Number                  Printout\n+    //        ---------------------------------\n+    //        0.000534                  .   534\n+    //        1.000534                 1.000534\n+    long deltaMicros = TimeUnit.NANOSECONDS.toMicros(event.getEpochNanos() - lastEpochNanos);\n+    String deltaString;\n+    if (deltaMicros >= 1000000) {\n+      deltaString = String.format(\"%.6f\", (deltaMicros / 1000000.0));\n+    } else {\n+      deltaString = String.format(\"%1s.%6d\", \"\", deltaMicros);\n+    }\n+\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(event.getEpochNanos());\n+    formatter.format(\n+        \"%02d:%02d:%02d.%06d</pre></td> \"\n+            + \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">%s</pre></td>\"\n+            + \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">%s</pre></td>\",\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        microsField,\n+        deltaString,\n+        htmlEscaper().escape(renderEvent(event)));\n+  }\n+\n+  private static String renderAttributes(ReadableAttributes attributes) {\n+    final StringBuilder stringBuilder = new StringBuilder();\n+    stringBuilder.append(\"Attributes:{\");\n+    final AtomicBoolean first = new AtomicBoolean(true);\n+    attributes.forEach(\n+        new KeyValueConsumer<AttributeValue>() {\n+          @Override\n+          public void consume(String key, AttributeValue value) {\n+            if (!first.getAndSet(false)) {\n+              stringBuilder.append(\", \");\n+            }\n+            stringBuilder.append(key);\n+            stringBuilder.append(\"=\");\n+            stringBuilder.append(value.toString());\n+          }\n+        });\n+    stringBuilder.append(\"}\");\n+    return stringBuilder.toString();\n+  }\n+\n+  private static String renderEvent(Event event) {\n+    StringBuilder stringBuilder = new StringBuilder();\n+    stringBuilder.append(event.getName());\n+    if (!event.getAttributes().isEmpty()) {\n+      stringBuilder.append(\" | \");\n+      stringBuilder.append(renderAttributes(event.getAttributes()));\n+    }\n+    return stringBuilder.toString();\n+  }\n+\n+  /**\n+   * Emits HTML body content to the {@link PrintWriter} {@code out}. Content emited by this function\n+   * should be enclosed by <body></body> tag.\n+   *\n+   * @param out The {@link PrintWriter} {@code out}.\n+   */\n+  private void emitHtmlBody(Map<String, String> queryMap, PrintWriter out)\n+      throws UnsupportedEncodingException {\n+    if (dataAggregator == null) {\n+      out.write(\"OpenTelemetry implementation not available.\");\n+      return;\n+    }\n+    // Link to OpenTelemetry Logo\n+    out.write(\n+        \"<img style=\\\"height: 90px;\\\"\"\n+            + \"src=\\\"data:image/png;base64,\"\n+            + ZPageLogo.logoBase64\n+            + \"\\\" />\");\n+    out.write(\"<h1>TraceZ Summary</h1>\");\n+    Formatter formatter = new Formatter(out, Locale.US);\n+    emitSummaryTable(out, formatter);\n+    // spanName will be null if the query parameter doesn't exist in the URL\n+    String spanName = queryMap.get(PARAM_SPAN_NAME);\n+    if (spanName != null) {\n+      // Show detailed information for the corresponding span\n+      String typeStr = queryMap.get(PARAM_SAMPLE_TYPE);\n+      if (typeStr != null) {\n+        List<SpanData> spans = null;\n+        SampleType type = SampleType.fromString(typeStr);\n+        if (type == SampleType.UNKNOWN) {\n+          // Type of sample is garbage value\n+          return;\n+        } else if (type == SampleType.RUNNING) {\n+          // Display running span\n+          spans = dataAggregator.getRunningSpans(spanName);\n+          Collections.sort(spans, new SpanDataComparator(/* incremental= */ true));\n+        } else {\n+          String subtypeStr = queryMap.get(PARAM_SAMPLE_SUB_TYPE);\n+          if (subtypeStr != null) {\n+            int subtype = Integer.parseInt(subtypeStr);\n+            if (type == SampleType.LATENCY) {\n+              if (subtype < 0 || subtype >= LatencyBoundaries.values().length) {\n+                // N/A or out-of-bound check for latency based subtype, valid values: [0, 8]\n+                return;\n+              }\n+              // Display latency based span\n+              LatencyBoundaries latencyBoundary = LatencyBoundaries.values()[subtype];\n+              spans =\n+                  dataAggregator.getOkSpans(\n+                      spanName,\n+                      latencyBoundary.getLatencyLowerBound(),\n+                      latencyBoundary.getLatencyUpperBound());\n+              Collections.sort(spans, new SpanDataComparator(/* incremental= */ false));\n+            } else {\n+              if (subtype < 0 || subtype >= CanonicalCode.values().length) {\n+                // N/A or out-of-bound cueck for error based subtype, valid values: [0, 15]\n+                return;\n+              }\n+              // Display error based span\n+              spans = dataAggregator.getErrorSpans(spanName);\n+              Collections.sort(spans, new SpanDataComparator(/* incremental= */ false));\n+            }\n+          }\n+        }\n+        out.write(\"<h2>Span Details</h2>\");\n+        emitSpanNameAndCount(formatter, spanName, spans == null ? 0 : spans.size(), type);\n+\n+        if (spans != null) {\n+          emitSpanDetails(out, formatter, spans);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void emitHtml(Map<String, String> queryMap, OutputStream outputStream) {\n+    // PrintWriter for emiting HTML contents\n+    PrintWriter out =\n+        new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream, Charsets.UTF_8)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514"}, "originalPosition": 513}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzUxNA==", "bodyText": "parseQueryMap", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448053514", "createdAt": "2020-07-01T00:38:13Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageHttpHandler.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** An {@link HttpHanlder} that will be used to render HTML pages using any {@code ZPageHandler}. */\n+final class ZPageHttpHandler implements HttpHandler {\n+  // The corresponding ZPageHandler for the zPage (e.g. TracezZPageHandler)\n+  private final ZPageHandler zpageHandler;\n+\n+  /** Constructs a new {@code ZPageHttpHandler}. */\n+  ZPageHttpHandler(ZPageHandler zpageHandler) {\n+    this.zpageHandler = zpageHandler;\n+  }\n+\n+  /**\n+   * Build a query map from the {@code uri}.\n+   *\n+   * @param uri the {@link URI} for buiding the query map\n+   * @return the query map built based on the @{code uri}\n+   */\n+  @VisibleForTesting\n+  static ImmutableMap<String, String> queryMapBuilder(URI uri) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzgyMg==", "bodyText": "It's mysterious that a get method has a side effect like registering a span processor. We should at least document this in the javadoc.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448053822", "createdAt": "2020-07-01T00:39:33Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageServer.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A collection of HTML pages to display stats and trace data and allow library configuration\n+ * control.\n+ *\n+ * <p>Example usage with private {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     ZPageServer.startHttpServerAndRegisterAllPages(8000);\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ *\n+ * <p>Example usage with shared {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     HttpServer server = HttpServer.create(new InetSocketAddress(8000), 10);\n+ *     ZPageServer.registerAllPagesToHttpServer(server);\n+ *     server.start();\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ */\n+@ThreadSafe\n+public final class ZPageServer {\n+  // The maximum number of queued incoming connections allowed on the HttpServer listening socket.\n+  private static final int HTTPSERVER_BACKLOG = 5;\n+  // Length of time to wait for the HttpServer to stop\n+  private static final int HTTPSERVER_STOP_DELAY = 1;\n+  // Tracez SpanProcessor and DataAggregator for constructing TracezZPageHandler\n+  private static final TracezSpanProcessor tracezSpanProcessor =\n+      TracezSpanProcessor.newBuilder().build();\n+  private static final TracezDataAggregator tracezDataAggregator =\n+      new TracezDataAggregator(tracezSpanProcessor);\n+  // Handler for /tracez page\n+  private static final ZPageHandler tracezZPageHandler =\n+      TracezZPageHandler.create(tracezDataAggregator);\n+\n+  private static final Object mutex = new Object();\n+  private static volatile boolean isTracezSpanProcesserAdded = false;\n+\n+  @GuardedBy(\"mutex\")\n+  @Nullable\n+  private static HttpServer server;\n+\n+  /** Function that adds the {@link TracezSpanProcessor} to the {@link tracerSdkProvider}. */\n+  private static void addTracezSpanProcessor() {\n+    if (!isTracezSpanProcesserAdded) {\n+      synchronized (mutex) {\n+        if (isTracezSpanProcesserAdded) {\n+          return;\n+        }\n+        TracerSdkProvider tracerProvider = OpenTelemetrySdk.getTracerProvider();\n+        tracerProvider.addSpanProcessor(tracezSpanProcessor);\n+        isTracezSpanProcesserAdded = true;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns a {@code ZPageHandler} for tracing debug. The page displays information about all\n+   * running spans and all sampled spans based on latency and error.\n+   *\n+   * <p>It displays a summary table which contains one row for each span name and data about number\n+   * of running and sampled spans.\n+   *\n+   * <p>Clicking on a cell in the table with a number that is greater than zero will display\n+   * detailed information about that span.\n+   *\n+   * @return a {@code ZPageHandler} for tracing debug.\n+   */\n+  public static ZPageHandler getTracezZPageHandler() {\n+    addTracezSpanProcessor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1Mzk5OQ==", "bodyText": "Could just use AtomicBoolean instead of double-check", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448053999", "createdAt": "2020-07-01T00:40:14Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageServer.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A collection of HTML pages to display stats and trace data and allow library configuration\n+ * control.\n+ *\n+ * <p>Example usage with private {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     ZPageServer.startHttpServerAndRegisterAllPages(8000);\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ *\n+ * <p>Example usage with shared {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     HttpServer server = HttpServer.create(new InetSocketAddress(8000), 10);\n+ *     ZPageServer.registerAllPagesToHttpServer(server);\n+ *     server.start();\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ */\n+@ThreadSafe\n+public final class ZPageServer {\n+  // The maximum number of queued incoming connections allowed on the HttpServer listening socket.\n+  private static final int HTTPSERVER_BACKLOG = 5;\n+  // Length of time to wait for the HttpServer to stop\n+  private static final int HTTPSERVER_STOP_DELAY = 1;\n+  // Tracez SpanProcessor and DataAggregator for constructing TracezZPageHandler\n+  private static final TracezSpanProcessor tracezSpanProcessor =\n+      TracezSpanProcessor.newBuilder().build();\n+  private static final TracezDataAggregator tracezDataAggregator =\n+      new TracezDataAggregator(tracezSpanProcessor);\n+  // Handler for /tracez page\n+  private static final ZPageHandler tracezZPageHandler =\n+      TracezZPageHandler.create(tracezDataAggregator);\n+\n+  private static final Object mutex = new Object();\n+  private static volatile boolean isTracezSpanProcesserAdded = false;\n+\n+  @GuardedBy(\"mutex\")\n+  @Nullable\n+  private static HttpServer server;\n+\n+  /** Function that adds the {@link TracezSpanProcessor} to the {@link tracerSdkProvider}. */\n+  private static void addTracezSpanProcessor() {\n+    if (!isTracezSpanProcesserAdded) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1NDgzNA==", "bodyText": "Just an aside, I won't ever start a ZPageServer in my apps :) And will register this directly into my preferred web server, such as Armeria.\nI don't see anything in the design that prevents it and it looks good, but wanted to make sure it's on people's minds :) The only point was about the BufferedWriter which I wouldn't want to use in conjunction with a different server framework.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448054834", "createdAt": "2020-07-01T00:43:20Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageHandler.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import java.io.OutputStream;\n+import java.util.Map;\n+\n+/**\n+ * The main interface for all zPages. All zPages should implement this interface to allow the HTTP\n+ * server implementation to support these pages.\n+ */\n+public abstract class ZPageHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1NTEyOA==", "bodyText": "Do you want to trim anything?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448055128", "createdAt": "2020-07-01T00:44:27Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageHttpHandler.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** An {@link HttpHanlder} that will be used to render HTML pages using any {@code ZPageHandler}. */\n+final class ZPageHttpHandler implements HttpHandler {\n+  // The corresponding ZPageHandler for the zPage (e.g. TracezZPageHandler)\n+  private final ZPageHandler zpageHandler;\n+\n+  /** Constructs a new {@code ZPageHttpHandler}. */\n+  ZPageHttpHandler(ZPageHandler zpageHandler) {\n+    this.zpageHandler = zpageHandler;\n+  }\n+\n+  /**\n+   * Build a query map from the {@code uri}.\n+   *\n+   * @param uri the {@link URI} for buiding the query map\n+   * @return the query map built based on the @{code uri}\n+   */\n+  @VisibleForTesting\n+  static ImmutableMap<String, String> queryMapBuilder(URI uri) {\n+    String queryStrings = uri.getQuery();\n+    if (queryStrings == null) {\n+      return ImmutableMap.of();\n+    }\n+    Map<String, String> queryMap = new HashMap<String, String>();\n+    for (String param : Splitter.on(\"&\").split(queryStrings)) {\n+      List<String> keyValuePair = Splitter.on(\"=\").splitToList(param);\n+      if (keyValuePair.size() > 1) {\n+        queryMap.put(keyValuePair.get(0), keyValuePair.get(1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1NTUyNw==", "bodyText": "Unit", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448055527", "createdAt": "2020-07-01T00:45:53Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/ZPageServerTest.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** UNit tests for {@link ZPageServer}. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1NTYwMw==", "bodyText": "Or just delete this line, it's obvious from the class name ZPageServerTest", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448055603", "createdAt": "2020-07-01T00:46:10Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/ZPageServerTest.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** UNit tests for {@link ZPageServer}. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1NTUyNw=="}, "originalCommit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7f4904b36b7176c0bbe4c6e692766d4f45fd142", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/d7f4904b36b7176c0bbe4c6e692766d4f45fd142", "committedDate": "2020-07-01T20:06:40Z", "message": "Modified the TracezSpanProcessor to only allow for a limited number of completed spans (#17)\n\n* Modified the TracezSpanProcessor to only allow for a limited number of completed spans\r\n\r\n* Renamed count functions and reduced logic in addToBucket"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50fe3f13357bd56373e0ed29bc12ab9366958f99", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/50fe3f13357bd56373e0ed29bc12ab9366958f99", "committedDate": "2020-07-01T20:54:16Z", "message": "Fixed typos and turned SpanProcessor and DataAggregator to package private"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMTk2OTgx", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-441196981", "createdAt": "2020-07-01T21:06:40Z", "commit": {"oid": "50fe3f13357bd56373e0ed29bc12ab9366958f99"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMTowNjo0MFrOGr1Xbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMTowNjo0MFrOGr1Xbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNjMwMg==", "bodyText": "This file is getting really big. I'd pull the inner classes out to the top level (but keep them package access).", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r448616302", "createdAt": "2020-07-01T21:06:40Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  public TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  public Set<String> getSpanNames() {\n+    Set<String> spanNames = new TreeSet<>();\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    for (ReadableSpan span : allRunningSpans) {\n+      spanNames.add(span.getName());\n+    }\n+    spanNames.addAll(spanProcessor.getCompletedSpanCache().keySet());\n+    return spanNames;\n+  }\n+\n+  /**\n+   * Returns a Map of the running span counts for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @return a Map of span counts for each span name.\n+   */\n+  public Map<String, Integer> getRunningSpanCounts() {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    Map<String, Integer> numSpansPerName = new HashMap<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      Integer prevValue = numSpansPerName.get(span.getName());\n+      numSpansPerName.put(span.getName(), prevValue != null ? prevValue + 1 : 1);\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all running spans with a given span name for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link io.opentelemetry.sdk.trace.data.SpanData}.\n+   */\n+  public List<SpanData> getRunningSpans(String spanName) {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      if (span.getName().equals(spanName)) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * A class of boundaries for the latency buckets. The completed spans with a status of {@link\n+   * io.opentelemetry.trace.Status#OK} are categorized into one of these buckets om the traceZ\n+   * zPage.\n+   */\n+  enum LatencyBoundaries {\n+    /** Stores finished successful requests of duration within the interval [0, 10us). */\n+    ZERO_MICROSx10(0, TimeUnit.MICROSECONDS.toNanos(10)),\n+\n+    /** Stores finished successful requests of duration within the interval [10us, 100us). */\n+    MICROSx10_MICROSx100(TimeUnit.MICROSECONDS.toNanos(10), TimeUnit.MICROSECONDS.toNanos(100)),\n+\n+    /** Stores finished successful requests of duration within the interval [100us, 1ms). */\n+    MICROSx100_MILLIx1(TimeUnit.MICROSECONDS.toNanos(100), TimeUnit.MILLISECONDS.toNanos(1)),\n+\n+    /** Stores finished successful requests of duration within the interval [1ms, 10ms). */\n+    MILLIx1_MILLIx10(TimeUnit.MILLISECONDS.toNanos(1), TimeUnit.MILLISECONDS.toNanos(10)),\n+\n+    /** Stores finished successful requests of duration within the interval [10ms, 100ms). */\n+    MILLIx10_MILLIx100(TimeUnit.MILLISECONDS.toNanos(10), TimeUnit.MILLISECONDS.toNanos(100)),\n+\n+    /** Stores finished successful requests of duration within the interval [100ms, 1sec). */\n+    MILLIx100_SECONDx1(TimeUnit.MILLISECONDS.toNanos(100), TimeUnit.SECONDS.toNanos(1)),\n+\n+    /** Stores finished successful requests of duration within the interval [1sec, 10sec). */\n+    SECONDx1_SECONDx10(TimeUnit.SECONDS.toNanos(1), TimeUnit.SECONDS.toNanos(10)),\n+\n+    /** Stores finished successful requests of duration within the interval [10sec, 100sec). */\n+    SECONDx10_SECONDx100(TimeUnit.SECONDS.toNanos(10), TimeUnit.SECONDS.toNanos(100)),\n+\n+    /** Stores finished successful requests of duration greater than or equal to 100sec. */\n+    SECONDx100_MAX(TimeUnit.SECONDS.toNanos(100), Long.MAX_VALUE);\n+\n+    private final long latencyLowerBound;\n+    private final long latencyUpperBound;\n+\n+    /**\n+     * Constructs a {@code LatencyBoundaries} with the given boundaries and label.\n+     *\n+     * @param latencyLowerBound the latency lower bound of the bucket.\n+     * @param latencyUpperBound the latency upper bound of the bucket.\n+     */\n+    LatencyBoundaries(long latencyLowerBound, long latencyUpperBound) {\n+      this.latencyLowerBound = latencyLowerBound;\n+      this.latencyUpperBound = latencyUpperBound;\n+    }\n+\n+    /**\n+     * Returns the latency lower bound of the bucket.\n+     *\n+     * @return the latency lower bound of the bucket.\n+     */\n+    long getLatencyLowerBound() {\n+      return latencyLowerBound;\n+    }\n+\n+    /**\n+     * Returns the latency upper bound of the bucket.\n+     *\n+     * @return the latency upper bound of the bucket.\n+     */\n+    long getLatencyUpperBound() {\n+      return latencyUpperBound;\n+    }\n+  }\n+\n+  static final class SpanBuckets {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50fe3f13357bd56373e0ed29bc12ab9366958f99"}, "originalPosition": 171}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12c333ad251caf3b180b60a03b29e218d0b0a57c", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/12c333ad251caf3b180b60a03b29e218d0b0a57c", "committedDate": "2020-07-01T23:55:23Z", "message": "Separated SpanBuckets and LatencyBoundaries from TracezDataAggregator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f409ad2b855aa77d5acbb617e444594fbd03825", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/1f409ad2b855aa77d5acbb617e444594fbd03825", "committedDate": "2020-07-02T16:29:00Z", "message": "Switched to PrintStream, removed bufferWritter, removed factory and changed to package private constructor, added documentation for getTracerzHandler behavior, and other small fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODk1MDY1", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-441895065", "createdAt": "2020-07-02T17:30:26Z", "commit": {"oid": "1f409ad2b855aa77d5acbb617e444594fbd03825"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzozMDoyNlrOGsXGUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzozMDoyNlrOGsXGUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE2ODk3Ng==", "bodyText": "no need for a fully qualified name here. please import it.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449168976", "createdAt": "2020-07-02T17:30:26Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * can be read from system properties, environment variables, or {@link java.util.Properties}\n+ * objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link\n+ * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.zpages.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_ZPAGES_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+final class TracezSpanProcessor implements SpanProcessor {\n+  private final ConcurrentMap<SpanId, ReadableSpan> runningSpanCache;\n+  private final ConcurrentMap<String, TracezSpanBuckets> completedSpanCache;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  public TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new ConcurrentHashMap<>();\n+    completedSpanCache = new ConcurrentHashMap<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    runningSpanCache.putIfAbsent(span.getSpanContext().getSpanId(), span);\n+  }\n+\n+  @Override\n+  public boolean isStartRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void onEnd(ReadableSpan span) {\n+    runningSpanCache.remove(span.getSpanContext().getSpanId());\n+    if (!sampled || span.getSpanContext().getTraceFlags().isSampled()) {\n+      completedSpanCache.putIfAbsent(span.getName(), new TracezSpanBuckets());\n+      synchronized (this) {\n+        completedSpanCache.get(span.getName()).addToBucket(span);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public boolean isEndRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    // Do nothing.\n+  }\n+\n+  @Override\n+  public void forceFlush() {\n+    // Do nothing.\n+  }\n+\n+  /**\n+   * Returns a Collection of all running spans for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   *\n+   * @return a Collection of {@link io.opentelemetry.sdk.trace.ReadableSpan}.\n+   */\n+  public Collection<ReadableSpan> getRunningSpans() {\n+    return runningSpanCache.values();\n+  }\n+\n+  /**\n+   * Returns a Collection of all completed spans for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   *\n+   * @return a Collection of {@link io.opentelemetry.sdk.trace.ReadableSpan}.\n+   */\n+  public Collection<ReadableSpan> getCompletedSpans() {\n+    Collection<ReadableSpan> completedSpans = new ArrayList<>();\n+    synchronized (this) {\n+      for (TracezSpanBuckets buckets : completedSpanCache.values()) {\n+        completedSpans.addAll(buckets.getSpans());\n+      }\n+    }\n+    return completedSpans;\n+  }\n+\n+  /**\n+   * Returns the completed span cache for {@link\n+   * io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   *\n+   * @return a Map of String to {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanBuckets}.\n+   */\n+  public Map<String, TracezSpanBuckets> getCompletedSpanCache() {\n+    synchronized (this) {\n+      return completedSpanCache;\n+    }\n+  }\n+\n+  /**\n+   * Returns a new Builder for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   *\n+   * @return a new {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+   */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  /** Builder class for {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}. */\n+  public static final class Builder extends ConfigBuilder<Builder> {\n+\n+    private static final String KEY_SAMPLED = \"otel.zpages.export.sampled\";\n+    private static final boolean DEFAULT_EXPORT_ONLY_SAMPLED = true;\n+    private boolean sampled = DEFAULT_EXPORT_ONLY_SAMPLED;\n+\n+    private Builder() {}\n+\n+    /**\n+     * Sets the configuration values from the given configuration map for only the available keys.\n+     * This method looks for the following keys:\n+     *\n+     * <ul>\n+     *   <li>{@code otel.zpages.export.sampled}: to set whether only sampled spans should be\n+     *       exported.\n+     * </ul>\n+     *\n+     * @param configMap {@link Map} holding the configuration values.\n+     * @return this.\n+     */\n+    @VisibleForTesting\n+    @Override\n+    protected Builder fromConfigMap(\n+        Map<String, String> configMap, NamingConvention namingConvention) {\n+      configMap = namingConvention.normalize(configMap);\n+      Boolean boolValue = getBooleanProperty(KEY_SAMPLED, configMap);\n+      if (boolValue != null) {\n+        return this.setExportOnlySampled(boolValue);\n+      }\n+      return this;\n+    }\n+\n+    /**\n+     * Sets whether only sampled spans should be exported.\n+     *\n+     * <p>Default value is {@code true}.\n+     *\n+     * @see Builder#DEFAULT_EXPORT_ONLY_SAMPLED\n+     * @param sampled report only sampled spans.\n+     * @return this.\n+     */\n+    public Builder setExportOnlySampled(boolean sampled) {\n+      this.sampled = sampled;\n+      return this;\n+    }\n+\n+    /**\n+     * Returns a new {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+     *\n+     * @return a new {@link io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor}.\n+     */\n+    public io.opentelemetry.sdk.extensions.zpages.TracezSpanProcessor build() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f409ad2b855aa77d5acbb617e444594fbd03825"}, "originalPosition": 204}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODk2Mzg0", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-441896384", "createdAt": "2020-07-02T17:32:35Z", "commit": {"oid": "1f409ad2b855aa77d5acbb617e444594fbd03825"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzozMjozNVrOGsXKrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzozMjozNVrOGsXKrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3MDA5NQ==", "bodyText": "this method isn't used anywhere, I don't think", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449170095", "createdAt": "2020-07-02T17:32:35Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private static final int NUM_SAMPLES_PER_LATENCY_BUCKET = 10;\n+  private static final int NUM_SAMPLES_PER_ERROR_BUCKET = 5;\n+\n+  private final Map<LatencyBoundaries, EvictingQueue<ReadableSpan>> latencyBuckets =\n+      new HashMap<>();\n+  private final Map<CanonicalCode, EvictingQueue<ReadableSpan>> errorBuckets = new HashMap<>();\n+\n+  public TracezSpanBuckets() {\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyBuckets.put(\n+          bucket, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_LATENCY_BUCKET));\n+    }\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBuckets.put(code, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_ERROR_BUCKET));\n+      }\n+    }\n+  }\n+\n+  public void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      long latency = span.getLatencyNanos();\n+      for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+        if (latency >= bucket.getLatencyLowerBound() && latency < bucket.getLatencyUpperBound()) {\n+          latencyBuckets.get(bucket).add(span);\n+          return;\n+        }\n+      }\n+    }\n+    errorBuckets.get(status.getCanonicalCode()).add(span);\n+  }\n+\n+  public Map<LatencyBoundaries, Integer> getLatencyBoundariesToCountMap() {\n+    Map<LatencyBoundaries, Integer> latencyCounts = new EnumMap<>(LatencyBoundaries.class);\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyCounts.put(bucket, latencyBuckets.get(bucket).size());\n+    }\n+    return latencyCounts;\n+  }\n+\n+  public Map<CanonicalCode, Integer> getErrorCanonicalCodeToCountMap() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f409ad2b855aa77d5acbb617e444594fbd03825"}, "originalPosition": 71}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db2b2fa2bec72903224aa5ac5a18e553b52b643b", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/db2b2fa2bec72903224aa5ac5a18e553b52b643b", "committedDate": "2020-07-02T17:33:56Z", "message": "Fixed package name"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODk3Mzgw", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-441897380", "createdAt": "2020-07-02T17:34:08Z", "commit": {"oid": "1f409ad2b855aa77d5acbb617e444594fbd03825"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzozNDowOFrOGsXNvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzozNDowOFrOGsXNvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3MDg3OQ==", "bodyText": "There's a bunch of fully-qualified names in docs throughout this PR. Let's make sure to use the imports and remove the FQNs when we can.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449170879", "createdAt": "2020-07-02T17:34:08Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link io.opentelemetry.sdk.extensions.zpages.TracezDataAggregator}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f409ad2b855aa77d5acbb617e444594fbd03825"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxOTEwMTUy", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-441910152", "createdAt": "2020-07-02T17:54:01Z", "commit": {"oid": "db2b2fa2bec72903224aa5ac5a18e553b52b643b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzo1NDowMVrOGsX03w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzo1NDowMVrOGsX03w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4MDg5NQ==", "bodyText": "there is no need for an Atomic instance to also be volatile. And, it should be declared final.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449180895", "createdAt": "2020-07-02T17:54:01Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageServer.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A collection of HTML pages to display stats and trace data and allow library configuration\n+ * control.\n+ *\n+ * <p>Example usage with private {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     ZPageServer.startHttpServerAndRegisterAllPages(8000);\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ *\n+ * <p>Example usage with shared {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     HttpServer server = HttpServer.create(new InetSocketAddress(8000), 10);\n+ *     ZPageServer.registerAllPagesToHttpServer(server);\n+ *     server.start();\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ */\n+@ThreadSafe\n+public final class ZPageServer {\n+  // The maximum number of queued incoming connections allowed on the HttpServer listening socket.\n+  private static final int HTTPSERVER_BACKLOG = 5;\n+  // Length of time to wait for the HttpServer to stop\n+  private static final int HTTPSERVER_STOP_DELAY = 1;\n+  // Tracez SpanProcessor and DataAggregator for constructing TracezZPageHandler\n+  private static final TracezSpanProcessor tracezSpanProcessor =\n+      TracezSpanProcessor.newBuilder().build();\n+  private static final TracezDataAggregator tracezDataAggregator =\n+      new TracezDataAggregator(tracezSpanProcessor);\n+  // Handler for /tracez page\n+  private static final ZPageHandler tracezZPageHandler =\n+      new TracezZPageHandler(tracezDataAggregator);\n+\n+  private static final Object mutex = new Object();\n+  private static volatile AtomicBoolean isTracezSpanProcesserAdded = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db2b2fa2bec72903224aa5ac5a18e553b52b643b"}, "originalPosition": 75}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxOTE3MDkw", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-441917090", "createdAt": "2020-07-02T18:05:04Z", "commit": {"oid": "db2b2fa2bec72903224aa5ac5a18e553b52b643b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowNTowNFrOGsYLXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowNTowNFrOGsYLXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NjY1NA==", "bodyText": "If you're guarding this with the check to the AtomicBoolean, is there much to be gained by additional synchronizing here? Also, if we really do need a lock, we should implement it with one of the higher-level concurrency primitives build-in to the JDK, like a ReentrantLock", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449186654", "createdAt": "2020-07-02T18:05:04Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageServer.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A collection of HTML pages to display stats and trace data and allow library configuration\n+ * control.\n+ *\n+ * <p>Example usage with private {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     ZPageServer.startHttpServerAndRegisterAllPages(8000);\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ *\n+ * <p>Example usage with shared {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     HttpServer server = HttpServer.create(new InetSocketAddress(8000), 10);\n+ *     ZPageServer.registerAllPagesToHttpServer(server);\n+ *     server.start();\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ */\n+@ThreadSafe\n+public final class ZPageServer {\n+  // The maximum number of queued incoming connections allowed on the HttpServer listening socket.\n+  private static final int HTTPSERVER_BACKLOG = 5;\n+  // Length of time to wait for the HttpServer to stop\n+  private static final int HTTPSERVER_STOP_DELAY = 1;\n+  // Tracez SpanProcessor and DataAggregator for constructing TracezZPageHandler\n+  private static final TracezSpanProcessor tracezSpanProcessor =\n+      TracezSpanProcessor.newBuilder().build();\n+  private static final TracezDataAggregator tracezDataAggregator =\n+      new TracezDataAggregator(tracezSpanProcessor);\n+  // Handler for /tracez page\n+  private static final ZPageHandler tracezZPageHandler =\n+      new TracezZPageHandler(tracezDataAggregator);\n+\n+  private static final Object mutex = new Object();\n+  private static volatile AtomicBoolean isTracezSpanProcesserAdded = new AtomicBoolean(false);\n+\n+  @GuardedBy(\"mutex\")\n+  @Nullable\n+  private static HttpServer server;\n+\n+  /** Function that adds the {@link TracezSpanProcessor} to the {@link tracerSdkProvider}. */\n+  private static void addTracezSpanProcessor() {\n+    if (isTracezSpanProcesserAdded.compareAndSet(false, true)) {\n+      synchronized (mutex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db2b2fa2bec72903224aa5ac5a18e553b52b643b"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxOTE3NDY5", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-441917469", "createdAt": "2020-07-02T18:05:40Z", "commit": {"oid": "db2b2fa2bec72903224aa5ac5a18e553b52b643b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowNTo0MFrOGsYMtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowNTo0MFrOGsYMtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4Njk5OQ==", "bodyText": "I think this method can be private, yes?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449186999", "createdAt": "2020-07-02T18:05:40Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageServer.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A collection of HTML pages to display stats and trace data and allow library configuration\n+ * control.\n+ *\n+ * <p>Example usage with private {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     ZPageServer.startHttpServerAndRegisterAllPages(8000);\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ *\n+ * <p>Example usage with shared {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     HttpServer server = HttpServer.create(new InetSocketAddress(8000), 10);\n+ *     ZPageServer.registerAllPagesToHttpServer(server);\n+ *     server.start();\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ */\n+@ThreadSafe\n+public final class ZPageServer {\n+  // The maximum number of queued incoming connections allowed on the HttpServer listening socket.\n+  private static final int HTTPSERVER_BACKLOG = 5;\n+  // Length of time to wait for the HttpServer to stop\n+  private static final int HTTPSERVER_STOP_DELAY = 1;\n+  // Tracez SpanProcessor and DataAggregator for constructing TracezZPageHandler\n+  private static final TracezSpanProcessor tracezSpanProcessor =\n+      TracezSpanProcessor.newBuilder().build();\n+  private static final TracezDataAggregator tracezDataAggregator =\n+      new TracezDataAggregator(tracezSpanProcessor);\n+  // Handler for /tracez page\n+  private static final ZPageHandler tracezZPageHandler =\n+      new TracezZPageHandler(tracezDataAggregator);\n+\n+  private static final Object mutex = new Object();\n+  private static volatile AtomicBoolean isTracezSpanProcesserAdded = new AtomicBoolean(false);\n+\n+  @GuardedBy(\"mutex\")\n+  @Nullable\n+  private static HttpServer server;\n+\n+  /** Function that adds the {@link TracezSpanProcessor} to the {@link tracerSdkProvider}. */\n+  private static void addTracezSpanProcessor() {\n+    if (isTracezSpanProcesserAdded.compareAndSet(false, true)) {\n+      synchronized (mutex) {\n+        TracerSdkProvider tracerProvider = OpenTelemetrySdk.getTracerProvider();\n+        tracerProvider.addSpanProcessor(tracezSpanProcessor);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns a {@code ZPageHandler} for tracing debug. The page displays information about all\n+   * running spans and all sampled spans based on latency and error.\n+   *\n+   * <p>It displays a summary table which contains one row for each span name and data about number\n+   * of running and sampled spans.\n+   *\n+   * <p>Clicking on a cell in the table with a number that is greater than zero will display\n+   * detailed information about that span.\n+   *\n+   * <p>This method will add the TracezSpanProcessor to the tracerProvider, it should only be called\n+   * once.\n+   *\n+   * @return a {@code ZPageHandler} for tracing debug.\n+   */\n+  public static ZPageHandler getTracezZPageHandler() {\n+    addTracezSpanProcessor();\n+    return tracezZPageHandler;\n+  }\n+\n+  /**\n+   * Registers all zPages to the given {@link HttpServer} {@code server}.\n+   *\n+   * @param server the server that exports the zPages.\n+   */\n+  public static void registerAllPagesToHttpServer(HttpServer server) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db2b2fa2bec72903224aa5ac5a18e553b52b643b"}, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxOTE4NTkz", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-441918593", "createdAt": "2020-07-02T18:07:27Z", "commit": {"oid": "db2b2fa2bec72903224aa5ac5a18e553b52b643b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowNzoyN1rOGsYQOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODowNzoyN1rOGsYQOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4Nzg5OA==", "bodyText": "is it really worth throwing an exception if two threads try to stop the server? Seems like it should just be a no-op.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449187898", "createdAt": "2020-07-02T18:07:27Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageServer.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A collection of HTML pages to display stats and trace data and allow library configuration\n+ * control.\n+ *\n+ * <p>Example usage with private {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     ZPageServer.startHttpServerAndRegisterAllPages(8000);\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ *\n+ * <p>Example usage with shared {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     HttpServer server = HttpServer.create(new InetSocketAddress(8000), 10);\n+ *     ZPageServer.registerAllPagesToHttpServer(server);\n+ *     server.start();\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ */\n+@ThreadSafe\n+public final class ZPageServer {\n+  // The maximum number of queued incoming connections allowed on the HttpServer listening socket.\n+  private static final int HTTPSERVER_BACKLOG = 5;\n+  // Length of time to wait for the HttpServer to stop\n+  private static final int HTTPSERVER_STOP_DELAY = 1;\n+  // Tracez SpanProcessor and DataAggregator for constructing TracezZPageHandler\n+  private static final TracezSpanProcessor tracezSpanProcessor =\n+      TracezSpanProcessor.newBuilder().build();\n+  private static final TracezDataAggregator tracezDataAggregator =\n+      new TracezDataAggregator(tracezSpanProcessor);\n+  // Handler for /tracez page\n+  private static final ZPageHandler tracezZPageHandler =\n+      new TracezZPageHandler(tracezDataAggregator);\n+\n+  private static final Object mutex = new Object();\n+  private static volatile AtomicBoolean isTracezSpanProcesserAdded = new AtomicBoolean(false);\n+\n+  @GuardedBy(\"mutex\")\n+  @Nullable\n+  private static HttpServer server;\n+\n+  /** Function that adds the {@link TracezSpanProcessor} to the {@link tracerSdkProvider}. */\n+  private static void addTracezSpanProcessor() {\n+    if (isTracezSpanProcesserAdded.compareAndSet(false, true)) {\n+      synchronized (mutex) {\n+        TracerSdkProvider tracerProvider = OpenTelemetrySdk.getTracerProvider();\n+        tracerProvider.addSpanProcessor(tracezSpanProcessor);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns a {@code ZPageHandler} for tracing debug. The page displays information about all\n+   * running spans and all sampled spans based on latency and error.\n+   *\n+   * <p>It displays a summary table which contains one row for each span name and data about number\n+   * of running and sampled spans.\n+   *\n+   * <p>Clicking on a cell in the table with a number that is greater than zero will display\n+   * detailed information about that span.\n+   *\n+   * <p>This method will add the TracezSpanProcessor to the tracerProvider, it should only be called\n+   * once.\n+   *\n+   * @return a {@code ZPageHandler} for tracing debug.\n+   */\n+  public static ZPageHandler getTracezZPageHandler() {\n+    addTracezSpanProcessor();\n+    return tracezZPageHandler;\n+  }\n+\n+  /**\n+   * Registers all zPages to the given {@link HttpServer} {@code server}.\n+   *\n+   * @param server the server that exports the zPages.\n+   */\n+  public static void registerAllPagesToHttpServer(HttpServer server) {\n+    // For future zPages, register them to the server in here\n+    server.createContext(\n+        tracezZPageHandler.getUrlPath(), new ZPageHttpHandler(getTracezZPageHandler()));\n+  }\n+\n+  /** Method for stopping the {@link HttpServer} {@code server}. */\n+  private static void stop() {\n+    synchronized (mutex) {\n+      checkState(server != null, \"The HttpServer is already stopped.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db2b2fa2bec72903224aa5ac5a18e553b52b643b"}, "originalPosition": 125}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69224884e0e7ecd9f2aa1909b802ee8824380053", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/69224884e0e7ecd9f2aa1909b802ee8824380053", "committedDate": "2020-07-02T18:36:55Z", "message": "Changed way of registering handlers, changed atomicBoolean to final, removed unnecessary lock"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63bc912c7a1a04b9cb51c4d87ca61a73468d911a", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/63bc912c7a1a04b9cb51c4d87ca61a73468d911a", "committedDate": "2020-07-02T19:10:04Z", "message": "Changed registerTracezZPageHandler to package private"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMDczNzQy", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-442073742", "createdAt": "2020-07-02T23:45:15Z", "commit": {"oid": "63bc912c7a1a04b9cb51c4d87ca61a73468d911a"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMzo0NToxNlrOGsf1Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMzo1ODo0OVrOGsgBZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxMjA4Mw==", "bodyText": "I think it may have gotten hidden by GitHub so linking again to my comment on incrementality, sorry if it's a double-notification\n#1380 (comment)\nI'm wondering whether we can incrementally update data structures that keep the information we want to return instead of storing ReadableSpan itself.\nFor example, in the processor, something like\n// NB: Too bad we can't use LongAdder without vendoring it...\nprivate final ConcurrentHashMap<String, Map<LatencyBoundaries, AtomicInteger>> spanNameLatencyBoundaryCounts = new ConcurrentHashMap<>\n\nonEnd() {\n  latencyCounts = spanNameLatencyBoundaryCounts.computeIfAbsent(span.getName(),\n // Prepopulated with AtomicInteger for each boundary \n LatencyBoundaries.createEnumMap())\n  LatencyBoundaries boundary = LatencyBoundaries.get(span.getLatencyNanos());\n  latencyCounts.get(boundary).incrementAndGet();\n}\n\nThis doesn't seem too complex, and will have all the information. Currently, with NUM_SAMPLES_PER_LATENCY_BUCKET the count is max 10 for any bucket if I'm not mistaken, is that what we want to report on the zpage? @jkwatson does this approach seem reasonable? I may be missing something that blocks it - I was actually initially most worried about getSpanLatencyCounts(long lowerBound, long upperBound) but I don't see it used in the PR anymore.\nAlso an aside, it's curious opentelemetry isn't using the opentelemetry API itself for gathering these metrics :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449312083", "createdAt": "2020-07-02T23:45:16Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private static final int NUM_SAMPLES_PER_LATENCY_BUCKET = 10;\n+  private static final int NUM_SAMPLES_PER_ERROR_BUCKET = 5;\n+\n+  private final Map<LatencyBoundaries, EvictingQueue<ReadableSpan>> latencyBuckets =\n+      new HashMap<>();\n+  private final Map<CanonicalCode, EvictingQueue<ReadableSpan>> errorBuckets = new HashMap<>();\n+\n+  public TracezSpanBuckets() {\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyBuckets.put(\n+          bucket, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_LATENCY_BUCKET));\n+    }\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBuckets.put(code, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_ERROR_BUCKET));\n+      }\n+    }\n+  }\n+\n+  public void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      long latency = span.getLatencyNanos();\n+      for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+        if (latency >= bucket.getLatencyLowerBound() && latency < bucket.getLatencyUpperBound()) {\n+          latencyBuckets.get(bucket).add(span);\n+          return;\n+        }\n+      }\n+    }\n+    errorBuckets.get(status.getCanonicalCode()).add(span);\n+  }\n+\n+  public Map<LatencyBoundaries, Integer> getLatencyBoundariesToCountMap() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63bc912c7a1a04b9cb51c4d87ca61a73468d911a"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxMzczOA==", "bodyText": "Cool that there's a design doc! Can you make it public?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449313738", "createdAt": "2020-07-02T23:52:34Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageServer.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A collection of HTML pages to display stats and trace data and allow library configuration\n+ * control.\n+ *\n+ * <p>Example usage with private {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     ZPageServer.startHttpServerAndRegisterAllPages(8000);\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ *\n+ * <p>Example usage with shared {@link HttpServer}\n+ *\n+ * <pre>{@code\n+ * public class Main {\n+ *   public static void main(String[] args) throws Exception {\n+ *     HttpServer server = HttpServer.create(new InetSocketAddress(8000), 10);\n+ *     ZPageServer.registerAllPagesToHttpServer(server);\n+ *     server.start();\n+ *     ... // do work\n+ *   }\n+ * }\n+ * }</pre>\n+ */\n+@ThreadSafe\n+public final class ZPageServer {\n+  // The maximum number of queued incoming connections allowed on the HttpServer listening socket.\n+  private static final int HTTPSERVER_BACKLOG = 5;\n+  // Length of time to wait for the HttpServer to stop\n+  private static final int HTTPSERVER_STOP_DELAY = 1;\n+  // Tracez SpanProcessor and DataAggregator for constructing TracezZPageHandler\n+  private static final TracezSpanProcessor tracezSpanProcessor =\n+      TracezSpanProcessor.newBuilder().build();\n+  private static final TracezDataAggregator tracezDataAggregator =\n+      new TracezDataAggregator(tracezSpanProcessor);\n+  // Handler for /tracez page\n+  private static final ZPageHandler tracezZPageHandler =\n+      TracezZPageHandler.create(tracezDataAggregator);\n+\n+  private static final Object mutex = new Object();\n+  private static volatile boolean isTracezSpanProcesserAdded = false;\n+\n+  @GuardedBy(\"mutex\")\n+  @Nullable\n+  private static HttpServer server;\n+\n+  /** Function that adds the {@link TracezSpanProcessor} to the {@link tracerSdkProvider}. */\n+  private static void addTracezSpanProcessor() {\n+    if (!isTracezSpanProcesserAdded) {\n+      synchronized (mutex) {\n+        if (isTracezSpanProcesserAdded) {\n+          return;\n+        }\n+        TracerSdkProvider tracerProvider = OpenTelemetrySdk.getTracerProvider();\n+        tracerProvider.addSpanProcessor(tracezSpanProcessor);\n+        isTracezSpanProcesserAdded = true;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns a {@code ZPageHandler} for tracing debug. The page displays information about all\n+   * running spans and all sampled spans based on latency and error.\n+   *\n+   * <p>It displays a summary table which contains one row for each span name and data about number\n+   * of running and sampled spans.\n+   *\n+   * <p>Clicking on a cell in the table with a number that is greater than zero will display\n+   * detailed information about that span.\n+   *\n+   * @return a {@code ZPageHandler} for tracing debug.\n+   */\n+  public static ZPageHandler getTracezZPageHandler() {\n+    addTracezSpanProcessor();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MzgyMg=="}, "originalCommit": {"oid": "a2ef65c69dc473bd7fe00e136e5f41b14bd3d514"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxNDg3NQ==", "bodyText": "Realized since we're using this class and assuming it's in the JDK, compileOnly is fine.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449314875", "createdAt": "2020-07-02T23:57:20Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/build.gradle", "diffHunk": "@@ -0,0 +1,19 @@\n+plugins {\n+    id \"java\"\n+    id \"maven-publish\"\n+\n+    id \"ru.vyarus.animalsniffer\"\n+}\n+\n+description = 'OpenTelemetry - zPages'\n+ext.moduleName = \"io.opentelemetry.sdk.extension.zpages\"\n+\n+dependencies {\n+    api project(':opentelemetry-api'),\n+            project(':opentelemetry-sdk')\n+\n+    implementation libraries.guava\n+    implementation 'com.sun.net.httpserver:http:20070405'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63bc912c7a1a04b9cb51c4d87ca61a73468d911a"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxNTExMA==", "bodyText": "Can you add private static final constants for the splitters?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449315110", "createdAt": "2020-07-02T23:58:26Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageHttpHandler.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** An {@link HttpHanlder} that will be used to render HTML pages using any {@code ZPageHandler}. */\n+final class ZPageHttpHandler implements HttpHandler {\n+  // The corresponding ZPageHandler for the zPage (e.g. TracezZPageHandler)\n+  private final ZPageHandler zpageHandler;\n+\n+  /** Constructs a new {@code ZPageHttpHandler}. */\n+  ZPageHttpHandler(ZPageHandler zpageHandler) {\n+    this.zpageHandler = zpageHandler;\n+  }\n+\n+  /**\n+   * Build a query map from the {@code uri}.\n+   *\n+   * @param uri the {@link URI} for buiding the query map\n+   * @return the query map built based on the @{code uri}\n+   */\n+  @VisibleForTesting\n+  static ImmutableMap<String, String> parseQueryMap(URI uri) {\n+    String queryStrings = uri.getQuery();\n+    if (queryStrings == null) {\n+      return ImmutableMap.of();\n+    }\n+    Map<String, String> queryMap = new HashMap<String, String>();\n+    for (String param : Splitter.on(\"&\").split(queryStrings)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63bc912c7a1a04b9cb51c4d87ca61a73468d911a"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxNTE3NA==", "bodyText": "Instead of manual trim, use Splitter.trimResults", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r449315174", "createdAt": "2020-07-02T23:58:49Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageHttpHandler.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableMap;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** An {@link HttpHanlder} that will be used to render HTML pages using any {@code ZPageHandler}. */\n+final class ZPageHttpHandler implements HttpHandler {\n+  // The corresponding ZPageHandler for the zPage (e.g. TracezZPageHandler)\n+  private final ZPageHandler zpageHandler;\n+\n+  /** Constructs a new {@code ZPageHttpHandler}. */\n+  ZPageHttpHandler(ZPageHandler zpageHandler) {\n+    this.zpageHandler = zpageHandler;\n+  }\n+\n+  /**\n+   * Build a query map from the {@code uri}.\n+   *\n+   * @param uri the {@link URI} for buiding the query map\n+   * @return the query map built based on the @{code uri}\n+   */\n+  @VisibleForTesting\n+  static ImmutableMap<String, String> parseQueryMap(URI uri) {\n+    String queryStrings = uri.getQuery();\n+    if (queryStrings == null) {\n+      return ImmutableMap.of();\n+    }\n+    Map<String, String> queryMap = new HashMap<String, String>();\n+    for (String param : Splitter.on(\"&\").split(queryStrings)) {\n+      List<String> keyValuePair = Splitter.on(\"=\").splitToList(param);\n+      if (keyValuePair.size() > 1) {\n+        queryMap.put(keyValuePair.get(0).trim(), keyValuePair.get(1).trim());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63bc912c7a1a04b9cb51c4d87ca61a73468d911a"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ed29a76c2231f626d1c25c710176b388552925a", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/8ed29a76c2231f626d1c25c710176b388552925a", "committedDate": "2020-07-03T14:57:08Z", "message": "Fixed javadoc styling and wording"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be0d55da38a949b219e61ac840b47e0e2b33bf75", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/be0d55da38a949b219e61ac840b47e0e2b33bf75", "committedDate": "2020-07-06T14:36:38Z", "message": "Added constants for splitters, changed httpserver to compileOnly dependency"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3ed03673e6c2e0817b2e6450c03e589e6aaeac51", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/3ed03673e6c2e0817b2e6450c03e589e6aaeac51", "committedDate": "2020-07-06T13:50:20Z", "message": "Added constants for splitters, changed httpserver to compileOnly dependency"}, "afterCommit": {"oid": "be0d55da38a949b219e61ac840b47e0e2b33bf75", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/be0d55da38a949b219e61ac840b47e0e2b33bf75", "committedDate": "2020-07-06T14:36:38Z", "message": "Added constants for splitters, changed httpserver to compileOnly dependency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff9247b059b0177ab2d5c20ac9b5396c5b651941", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/ff9247b059b0177ab2d5c20ac9b5396c5b651941", "committedDate": "2020-07-06T18:47:36Z", "message": "Removed FQNs from backend files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd282171464124becadbf182e113537e9714fd0a", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/bd282171464124becadbf182e113537e9714fd0a", "committedDate": "2020-07-06T19:13:33Z", "message": "Removed style errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb41a8b36765212860795818dc51f6d0ce926d6b", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/fb41a8b36765212860795818dc51f6d0ce926d6b", "committedDate": "2020-07-06T21:58:26Z", "message": "Updated TracezSpanProcessor to maintain a set of span names incrementally"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b46dd90f80985b0f500647c879f494eec0ea6b6", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/8b46dd90f80985b0f500647c879f494eec0ea6b6", "committedDate": "2020-07-07T17:25:18Z", "message": "Added visibleForTesting tag, adjusted HTML expression"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MjA2MjYx", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-444206261", "createdAt": "2020-07-07T19:58:07Z", "commit": {"oid": "bd282171464124becadbf182e113537e9714fd0a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOTo1ODowN1rOGuNfoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxOTo1ODowN1rOGuNfoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTEwODc2OA==", "bodyText": "This method isn't being used. Can we remove it?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451108768", "createdAt": "2020-07-07T19:58:07Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  public TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  public Set<String> getSpanNames() {\n+    Set<String> spanNames = new TreeSet<>();\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    for (ReadableSpan span : allRunningSpans) {\n+      spanNames.add(span.getName());\n+    }\n+    spanNames.addAll(spanProcessor.getCompletedSpanCache().keySet());\n+    return spanNames;\n+  }\n+\n+  /**\n+   * Returns a Map of the running span counts for {@link TracezDataAggregator}.\n+   *\n+   * @return a Map of span counts for each span name.\n+   */\n+  public Map<String, Integer> getRunningSpanCounts() {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    Map<String, Integer> numSpansPerName = new HashMap<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      Integer prevValue = numSpansPerName.get(span.getName());\n+      numSpansPerName.put(span.getName(), prevValue != null ? prevValue + 1 : 1);\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all running spans with a given span name for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link SpanData}.\n+   */\n+  public List<SpanData> getRunningSpans(String spanName) {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      if (span.getName().equals(spanName)) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * Returns a Map of counts for the {@link Status#OK} spans within [lowerBound, upperBound) {@link\n+   * TracezDataAggregator}.\n+   *\n+   * @param lowerBound latency lower bound (inclusive)\n+   * @param upperBound latency upper bound (exclusive)\n+   * @return a Map of span counts for each span name within the bounds.\n+   */\n+  public Map<String, Integer> getSpanLatencyCounts(long lowerBound, long upperBound) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd282171464124becadbf182e113537e9714fd0a"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MjA4MTc4", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-444208178", "createdAt": "2020-07-07T20:01:04Z", "commit": {"oid": "8b46dd90f80985b0f500647c879f494eec0ea6b6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMDowMTowNFrOGuNldw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMDowMTowNFrOGuNldw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExMDI2Mw==", "bodyText": "I don't think we need all this synchronization if we're using a ConcurrentMap, do we?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451110263", "createdAt": "2020-07-07T20:01:04Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link TracezSpanProcessor} can be read from system properties,\n+ * environment variables, or {@link java.util.Properties} objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.zpages.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_ZPAGES_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+final class TracezSpanProcessor implements SpanProcessor {\n+  private final ConcurrentMap<SpanId, ReadableSpan> runningSpanCache;\n+  private final ConcurrentMap<String, TracezSpanBuckets> completedSpanCache;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  public TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new ConcurrentHashMap<>();\n+    completedSpanCache = new ConcurrentHashMap<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    runningSpanCache.putIfAbsent(span.getSpanContext().getSpanId(), span);\n+  }\n+\n+  @Override\n+  public boolean isStartRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void onEnd(ReadableSpan span) {\n+    runningSpanCache.remove(span.getSpanContext().getSpanId());\n+    if (!sampled || span.getSpanContext().getTraceFlags().isSampled()) {\n+      completedSpanCache.putIfAbsent(span.getName(), new TracezSpanBuckets());\n+      synchronized (this) {\n+        completedSpanCache.get(span.getName()).addToBucket(span);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b46dd90f80985b0f500647c879f494eec0ea6b6"}, "originalPosition": 83}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99497ac199471542c047e3a66613defed7c1a691", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/99497ac199471542c047e3a66613defed7c1a691", "committedDate": "2020-07-07T21:43:50Z", "message": "Merge branch 'master' of github.com:williamhu99/opentelemetry-java into master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ee432fa707c5a9741d69cdb4b5769c25983462a", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/9ee432fa707c5a9741d69cdb4b5769c25983462a", "committedDate": "2020-07-07T21:48:23Z", "message": "Removed unused functions in the data aggregator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd", "committedDate": "2020-07-07T23:16:14Z", "message": "Made TracezSpanBuckets thread-safe"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MzIyNDA5", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-444322409", "createdAt": "2020-07-07T23:45:25Z", "commit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "state": "COMMENTED", "comments": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMzo0NToyNVrOGuTUJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMTo0NToxNVrOGuVNww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwNDEzNA==", "bodyText": "Thanks for the context, didn't realize there's a details page too (seems to be missing from the design doc). In that case we can stick with the current approach. It's a bit weird since the numbers seem like they'll all converge to 10 naturally, but guess the numbers aren't actually the main feature here.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451204134", "createdAt": "2020-07-07T23:45:25Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private static final int NUM_SAMPLES_PER_LATENCY_BUCKET = 10;\n+  private static final int NUM_SAMPLES_PER_ERROR_BUCKET = 5;\n+\n+  private final Map<LatencyBoundaries, EvictingQueue<ReadableSpan>> latencyBuckets =\n+      new HashMap<>();\n+  private final Map<CanonicalCode, EvictingQueue<ReadableSpan>> errorBuckets = new HashMap<>();\n+\n+  public TracezSpanBuckets() {\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyBuckets.put(\n+          bucket, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_LATENCY_BUCKET));\n+    }\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBuckets.put(code, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_ERROR_BUCKET));\n+      }\n+    }\n+  }\n+\n+  public void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      long latency = span.getLatencyNanos();\n+      for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+        if (latency >= bucket.getLatencyLowerBound() && latency < bucket.getLatencyUpperBound()) {\n+          latencyBuckets.get(bucket).add(span);\n+          return;\n+        }\n+      }\n+    }\n+    errorBuckets.get(status.getCanonicalCode()).add(span);\n+  }\n+\n+  public Map<LatencyBoundaries, Integer> getLatencyBoundariesToCountMap() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTMxMjA4Mw=="}, "originalCommit": {"oid": "63bc912c7a1a04b9cb51c4d87ca61a73468d911a"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwNDQ4OA==", "bodyText": "How about using resources instead of base64 encoding into source? Makes it much easier to update the logo when needed / view it in IDE, etc.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451204488", "createdAt": "2020-07-07T23:46:38Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageLogo.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+final class ZPageLogo {\n+  private ZPageLogo() {}\n+\n+  /** OpenTelemetry logo in base64 encoding. */\n+  static String logoBase64 =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwNzM4OA==", "bodyText": "Remove public for this non-public class", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451207388", "createdAt": "2020-07-07T23:56:09Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  public TracezDataAggregator(TracezSpanProcessor spanProcessor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwNzUzMg==", "bodyText": "Use entrySet instead of keySet", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451207532", "createdAt": "2020-07-07T23:56:46Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  public TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  public Set<String> getSpanNames() {\n+    return spanProcessor.getSpanNames();\n+  }\n+\n+  /**\n+   * Returns a Map of the running span counts for {@link TracezDataAggregator}.\n+   *\n+   * @return a Map of span counts for each span name.\n+   */\n+  public Map<String, Integer> getRunningSpanCounts() {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    Map<String, Integer> numSpansPerName = new HashMap<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      Integer prevValue = numSpansPerName.get(span.getName());\n+      numSpansPerName.put(span.getName(), prevValue != null ? prevValue + 1 : 1);\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all running spans with a given span name for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link SpanData}.\n+   */\n+  public List<SpanData> getRunningSpans(String spanName) {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      if (span.getName().equals(spanName)) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * Returns a Map of span names to counts for all {@link Status#OK} spans in {@link\n+   * TracezDataAggregator}.\n+   *\n+   * @return a Map of span names to counts, where the counts are further indexed by the latency\n+   *     boundaries.\n+   */\n+  public Map<String, Map<LatencyBoundaries, Integer>> getSpanLatencyCounts() {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Map<String, Map<LatencyBoundaries, Integer>> numSpansPerName = new HashMap<>();\n+    for (String name : completedSpanCache.keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwODE4OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Collection<ReadableSpan> allCompletedSpans =\n          \n          \n            \n                    completedSpanCache.containsKey(spanName)\n          \n          \n            \n                        ? completedSpanCache.get(spanName).getOkSpans()\n          \n          \n            \n                        : Collections.<ReadableSpan>emptyList();\n          \n          \n            \n                TracezSpanBuckes buckets = completedSpanCache.get(spanName);\n          \n          \n            \n                if (buckets == null) {\n          \n          \n            \n                  return Collections.emptyList();\n          \n          \n            \n                }\n          \n          \n            \n                Collection<ReadableSpan> = buckets.getOkSpans();\n          \n      \n    \n    \n  \n\nAvoid both containsKey and get, e.g., looking up the map twice.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451208188", "createdAt": "2020-07-07T23:59:07Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  public TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  public Set<String> getSpanNames() {\n+    return spanProcessor.getSpanNames();\n+  }\n+\n+  /**\n+   * Returns a Map of the running span counts for {@link TracezDataAggregator}.\n+   *\n+   * @return a Map of span counts for each span name.\n+   */\n+  public Map<String, Integer> getRunningSpanCounts() {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    Map<String, Integer> numSpansPerName = new HashMap<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      Integer prevValue = numSpansPerName.get(span.getName());\n+      numSpansPerName.put(span.getName(), prevValue != null ? prevValue + 1 : 1);\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all running spans with a given span name for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link SpanData}.\n+   */\n+  public List<SpanData> getRunningSpans(String spanName) {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      if (span.getName().equals(spanName)) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * Returns a Map of span names to counts for all {@link Status#OK} spans in {@link\n+   * TracezDataAggregator}.\n+   *\n+   * @return a Map of span names to counts, where the counts are further indexed by the latency\n+   *     boundaries.\n+   */\n+  public Map<String, Map<LatencyBoundaries, Integer>> getSpanLatencyCounts() {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Map<String, Map<LatencyBoundaries, Integer>> numSpansPerName = new HashMap<>();\n+    for (String name : completedSpanCache.keySet()) {\n+      numSpansPerName.put(name, completedSpanCache.get(name).getLatencyBoundariesToCountMap());\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all {@link Status#OK} spans with a given span name between [lowerBound,\n+   * upperBound) for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @param lowerBound latency lower bound (inclusive)\n+   * @param upperBound latency upper bound (exclusive)\n+   * @return a List of {@link SpanData}.\n+   */\n+  public List<SpanData> getOkSpans(String spanName, long lowerBound, long upperBound) {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Collection<ReadableSpan> allCompletedSpans =\n+        completedSpanCache.containsKey(spanName)\n+            ? completedSpanCache.get(spanName).getOkSpans()\n+            : Collections.<ReadableSpan>emptyList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwODQwMQ==", "bodyText": "Ditto", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451208401", "createdAt": "2020-07-07T23:59:50Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  public TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  public Set<String> getSpanNames() {\n+    return spanProcessor.getSpanNames();\n+  }\n+\n+  /**\n+   * Returns a Map of the running span counts for {@link TracezDataAggregator}.\n+   *\n+   * @return a Map of span counts for each span name.\n+   */\n+  public Map<String, Integer> getRunningSpanCounts() {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    Map<String, Integer> numSpansPerName = new HashMap<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      Integer prevValue = numSpansPerName.get(span.getName());\n+      numSpansPerName.put(span.getName(), prevValue != null ? prevValue + 1 : 1);\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all running spans with a given span name for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link SpanData}.\n+   */\n+  public List<SpanData> getRunningSpans(String spanName) {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      if (span.getName().equals(spanName)) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * Returns a Map of span names to counts for all {@link Status#OK} spans in {@link\n+   * TracezDataAggregator}.\n+   *\n+   * @return a Map of span names to counts, where the counts are further indexed by the latency\n+   *     boundaries.\n+   */\n+  public Map<String, Map<LatencyBoundaries, Integer>> getSpanLatencyCounts() {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Map<String, Map<LatencyBoundaries, Integer>> numSpansPerName = new HashMap<>();\n+    for (String name : completedSpanCache.keySet()) {\n+      numSpansPerName.put(name, completedSpanCache.get(name).getLatencyBoundariesToCountMap());\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all {@link Status#OK} spans with a given span name between [lowerBound,\n+   * upperBound) for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @param lowerBound latency lower bound (inclusive)\n+   * @param upperBound latency upper bound (exclusive)\n+   * @return a List of {@link SpanData}.\n+   */\n+  public List<SpanData> getOkSpans(String spanName, long lowerBound, long upperBound) {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Collection<ReadableSpan> allCompletedSpans =\n+        completedSpanCache.containsKey(spanName)\n+            ? completedSpanCache.get(spanName).getOkSpans()\n+            : Collections.<ReadableSpan>emptyList();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allCompletedSpans) {\n+      if (span.getLatencyNanos() >= lowerBound && span.getLatencyNanos() < upperBound) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * Returns a Map of error span counts for {@link TracezDataAggregator}.\n+   *\n+   * @return a Map of error span counts for each span name.\n+   */\n+  public Map<String, Integer> getErrorSpanCounts() {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Map<String, Integer> numErrorsPerName = new HashMap<>();\n+    for (String name : completedSpanCache.keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwODUyMA==", "bodyText": "Ditto", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451208520", "createdAt": "2020-07-08T00:00:15Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  public TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  public Set<String> getSpanNames() {\n+    return spanProcessor.getSpanNames();\n+  }\n+\n+  /**\n+   * Returns a Map of the running span counts for {@link TracezDataAggregator}.\n+   *\n+   * @return a Map of span counts for each span name.\n+   */\n+  public Map<String, Integer> getRunningSpanCounts() {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    Map<String, Integer> numSpansPerName = new HashMap<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      Integer prevValue = numSpansPerName.get(span.getName());\n+      numSpansPerName.put(span.getName(), prevValue != null ? prevValue + 1 : 1);\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all running spans with a given span name for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link SpanData}.\n+   */\n+  public List<SpanData> getRunningSpans(String spanName) {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      if (span.getName().equals(spanName)) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * Returns a Map of span names to counts for all {@link Status#OK} spans in {@link\n+   * TracezDataAggregator}.\n+   *\n+   * @return a Map of span names to counts, where the counts are further indexed by the latency\n+   *     boundaries.\n+   */\n+  public Map<String, Map<LatencyBoundaries, Integer>> getSpanLatencyCounts() {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Map<String, Map<LatencyBoundaries, Integer>> numSpansPerName = new HashMap<>();\n+    for (String name : completedSpanCache.keySet()) {\n+      numSpansPerName.put(name, completedSpanCache.get(name).getLatencyBoundariesToCountMap());\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all {@link Status#OK} spans with a given span name between [lowerBound,\n+   * upperBound) for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @param lowerBound latency lower bound (inclusive)\n+   * @param upperBound latency upper bound (exclusive)\n+   * @return a List of {@link SpanData}.\n+   */\n+  public List<SpanData> getOkSpans(String spanName, long lowerBound, long upperBound) {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Collection<ReadableSpan> allCompletedSpans =\n+        completedSpanCache.containsKey(spanName)\n+            ? completedSpanCache.get(spanName).getOkSpans()\n+            : Collections.<ReadableSpan>emptyList();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allCompletedSpans) {\n+      if (span.getLatencyNanos() >= lowerBound && span.getLatencyNanos() < upperBound) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * Returns a Map of error span counts for {@link TracezDataAggregator}.\n+   *\n+   * @return a Map of error span counts for each span name.\n+   */\n+  public Map<String, Integer> getErrorSpanCounts() {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Map<String, Integer> numErrorsPerName = new HashMap<>();\n+    for (String name : completedSpanCache.keySet()) {\n+      numErrorsPerName.put(name, completedSpanCache.get(name).getErrorSpans().size());\n+    }\n+    return numErrorsPerName;\n+  }\n+\n+  /**\n+   * Returns a List of error spans with a given span name for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link SpanData}.\n+   */\n+  public List<SpanData> getErrorSpans(String spanName) {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Collection<ReadableSpan> allCompletedSpans =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwODYzMg==", "bodyText": "Ditto", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451208632", "createdAt": "2020-07-08T00:00:35Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private static final int NUM_SAMPLES_PER_LATENCY_BUCKET = 10;\n+  private static final int NUM_SAMPLES_PER_ERROR_BUCKET = 5;\n+\n+  private final Map<LatencyBoundaries, EvictingQueue<ReadableSpan>> latencyBuckets =\n+      new HashMap<>();\n+  private final Map<CanonicalCode, EvictingQueue<ReadableSpan>> errorBuckets = new HashMap<>();\n+\n+  public TracezSpanBuckets() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxNzE5Mw==", "bodyText": "Use ImmutableMap instead of HashMap to make clear the buckets can be accessed without threadsafety (not the queue), the maps themselves are fully initialized in the constructor.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451217193", "createdAt": "2020-07-08T00:33:51Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private static final int NUM_SAMPLES_PER_LATENCY_BUCKET = 10;\n+  private static final int NUM_SAMPLES_PER_ERROR_BUCKET = 5;\n+\n+  private final Map<LatencyBoundaries, EvictingQueue<ReadableSpan>> latencyBuckets =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxNzM3OA==", "bodyText": "Synchronize on the queue, not the map (above suggestion about ImmutableMap is to make clear that this is safe)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451217378", "createdAt": "2020-07-08T00:34:40Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private static final int NUM_SAMPLES_PER_LATENCY_BUCKET = 10;\n+  private static final int NUM_SAMPLES_PER_ERROR_BUCKET = 5;\n+\n+  private final Map<LatencyBoundaries, EvictingQueue<ReadableSpan>> latencyBuckets =\n+      new HashMap<>();\n+  private final Map<CanonicalCode, EvictingQueue<ReadableSpan>> errorBuckets = new HashMap<>();\n+\n+  public TracezSpanBuckets() {\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyBuckets.put(\n+          bucket, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_LATENCY_BUCKET));\n+    }\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBuckets.put(code, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_ERROR_BUCKET));\n+      }\n+    }\n+  }\n+\n+  public void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      long latency = span.getLatencyNanos();\n+      for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+        if (latency >= bucket.getLatencyLowerBound() && latency < bucket.getLatencyUpperBound()) {\n+          synchronized (latencyBuckets) {\n+            latencyBuckets.get(bucket).add(span);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxNzU4Nw==", "bodyText": "Name this LatencyBoundary, an enum name should be what each item is, not what the group is.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451217587", "createdAt": "2020-07-08T00:35:31Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/LatencyBoundaries.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A class of boundaries for the latency buckets. The completed spans with a status of {@link\n+ * io.opentelemetry.trace.Status#OK} are categorized into one of these buckets om the traceZ zPage.\n+ */\n+enum LatencyBoundaries {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxNzc3Mw==", "bodyText": "Ditto", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451217773", "createdAt": "2020-07-08T00:36:08Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private static final int NUM_SAMPLES_PER_LATENCY_BUCKET = 10;\n+  private static final int NUM_SAMPLES_PER_ERROR_BUCKET = 5;\n+\n+  private final Map<LatencyBoundaries, EvictingQueue<ReadableSpan>> latencyBuckets =\n+      new HashMap<>();\n+  private final Map<CanonicalCode, EvictingQueue<ReadableSpan>> errorBuckets = new HashMap<>();\n+\n+  public TracezSpanBuckets() {\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyBuckets.put(\n+          bucket, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_LATENCY_BUCKET));\n+    }\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBuckets.put(code, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_ERROR_BUCKET));\n+      }\n+    }\n+  }\n+\n+  public void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      long latency = span.getLatencyNanos();\n+      for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+        if (latency >= bucket.getLatencyLowerBound() && latency < bucket.getLatencyUpperBound()) {\n+          synchronized (latencyBuckets) {\n+            latencyBuckets.get(bucket).add(span);\n+          }\n+          return;\n+        }\n+      }\n+    }\n+    synchronized (errorBuckets) {\n+      errorBuckets.get(status.getCanonicalCode()).add(span);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxNzg0Mw==", "bodyText": "I think it's worth having LatencyBoundary.get(long latencyNanos) to return the boundary to make this code a bit more simple.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451217843", "createdAt": "2020-07-08T00:36:29Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private static final int NUM_SAMPLES_PER_LATENCY_BUCKET = 10;\n+  private static final int NUM_SAMPLES_PER_ERROR_BUCKET = 5;\n+\n+  private final Map<LatencyBoundaries, EvictingQueue<ReadableSpan>> latencyBuckets =\n+      new HashMap<>();\n+  private final Map<CanonicalCode, EvictingQueue<ReadableSpan>> errorBuckets = new HashMap<>();\n+\n+  public TracezSpanBuckets() {\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyBuckets.put(\n+          bucket, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_LATENCY_BUCKET));\n+    }\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBuckets.put(code, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_ERROR_BUCKET));\n+      }\n+    }\n+  }\n+\n+  public void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      long latency = span.getLatencyNanos();\n+      for (LatencyBoundaries bucket : LatencyBoundaries.values()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxOTU3OA==", "bodyText": "Recommend returning List, there doesn't seem to be a reason to use a more limited type especially for an internal class", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451219578", "createdAt": "2020-07-08T00:43:23Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private static final int NUM_SAMPLES_PER_LATENCY_BUCKET = 10;\n+  private static final int NUM_SAMPLES_PER_ERROR_BUCKET = 5;\n+\n+  private final Map<LatencyBoundaries, EvictingQueue<ReadableSpan>> latencyBuckets =\n+      new HashMap<>();\n+  private final Map<CanonicalCode, EvictingQueue<ReadableSpan>> errorBuckets = new HashMap<>();\n+\n+  public TracezSpanBuckets() {\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyBuckets.put(\n+          bucket, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_LATENCY_BUCKET));\n+    }\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBuckets.put(code, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_ERROR_BUCKET));\n+      }\n+    }\n+  }\n+\n+  public void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      long latency = span.getLatencyNanos();\n+      for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+        if (latency >= bucket.getLatencyLowerBound() && latency < bucket.getLatencyUpperBound()) {\n+          synchronized (latencyBuckets) {\n+            latencyBuckets.get(bucket).add(span);\n+          }\n+          return;\n+        }\n+      }\n+    }\n+    synchronized (errorBuckets) {\n+      errorBuckets.get(status.getCanonicalCode()).add(span);\n+    }\n+  }\n+\n+  public Map<LatencyBoundaries, Integer> getLatencyBoundariesToCountMap() {\n+    Map<LatencyBoundaries, Integer> latencyCounts = new EnumMap<>(LatencyBoundaries.class);\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyCounts.put(bucket, latencyBuckets.get(bucket).size());\n+    }\n+    return latencyCounts;\n+  }\n+\n+  public Collection<ReadableSpan> getOkSpans() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyMDEyOA==", "bodyText": "I believe this has a chance of throwing ConcurrentModificationException, you should just do\nsynchronized(latencyBucket) {\n  okSpans.addAll(latencyBucket);\n}\n\nwhich will work after following the other comments.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451220128", "createdAt": "2020-07-08T00:45:36Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private static final int NUM_SAMPLES_PER_LATENCY_BUCKET = 10;\n+  private static final int NUM_SAMPLES_PER_ERROR_BUCKET = 5;\n+\n+  private final Map<LatencyBoundaries, EvictingQueue<ReadableSpan>> latencyBuckets =\n+      new HashMap<>();\n+  private final Map<CanonicalCode, EvictingQueue<ReadableSpan>> errorBuckets = new HashMap<>();\n+\n+  public TracezSpanBuckets() {\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyBuckets.put(\n+          bucket, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_LATENCY_BUCKET));\n+    }\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBuckets.put(code, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_ERROR_BUCKET));\n+      }\n+    }\n+  }\n+\n+  public void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      long latency = span.getLatencyNanos();\n+      for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+        if (latency >= bucket.getLatencyLowerBound() && latency < bucket.getLatencyUpperBound()) {\n+          synchronized (latencyBuckets) {\n+            latencyBuckets.get(bucket).add(span);\n+          }\n+          return;\n+        }\n+      }\n+    }\n+    synchronized (errorBuckets) {\n+      errorBuckets.get(status.getCanonicalCode()).add(span);\n+    }\n+  }\n+\n+  public Map<LatencyBoundaries, Integer> getLatencyBoundariesToCountMap() {\n+    Map<LatencyBoundaries, Integer> latencyCounts = new EnumMap<>(LatencyBoundaries.class);\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyCounts.put(bucket, latencyBuckets.get(bucket).size());\n+    }\n+    return latencyCounts;\n+  }\n+\n+  public Collection<ReadableSpan> getOkSpans() {\n+    Collection<ReadableSpan> okSpans = new ArrayList<>();\n+    for (EvictingQueue<ReadableSpan> latencyBucket : latencyBuckets.values()) {\n+      okSpans.addAll(new ArrayList<>(latencyBucket));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyMTQ2OA==", "bodyText": "Should be able to remove this synchronization, it's a concurrent map and each bucket handles its own thread safety", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451221468", "createdAt": "2020-07-08T00:50:48Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link TracezSpanProcessor} can be read from system properties,\n+ * environment variables, or {@link java.util.Properties} objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.zpages.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_ZPAGES_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+final class TracezSpanProcessor implements SpanProcessor {\n+  private final ConcurrentMap<SpanId, ReadableSpan> runningSpanCache;\n+  private final ConcurrentMap<String, TracezSpanBuckets> completedSpanCache;\n+  private final Set<String> spanNames;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  public TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new ConcurrentHashMap<>();\n+    completedSpanCache = new ConcurrentHashMap<>();\n+    spanNames = new TreeSet<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    runningSpanCache.putIfAbsent(span.getSpanContext().getSpanId(), span);\n+    synchronized (spanNames) {\n+      spanNames.add(span.getName());\n+    }\n+  }\n+\n+  @Override\n+  public boolean isStartRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void onEnd(ReadableSpan span) {\n+    runningSpanCache.remove(span.getSpanContext().getSpanId());\n+    if (!sampled || span.getSpanContext().getTraceFlags().isSampled()) {\n+      completedSpanCache.putIfAbsent(span.getName(), new TracezSpanBuckets());\n+      completedSpanCache.get(span.getName()).addToBucket(span);\n+    }\n+  }\n+\n+  @Override\n+  public boolean isEndRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    // Do nothing.\n+  }\n+\n+  @Override\n+  public void forceFlush() {\n+    // Do nothing.\n+  }\n+\n+  /**\n+   * Returns a Collection of all running spans for {@link TracezSpanProcessor}.\n+   *\n+   * @return a Collection of {@link ReadableSpan}.\n+   */\n+  public Collection<ReadableSpan> getRunningSpans() {\n+    return runningSpanCache.values();\n+  }\n+\n+  /**\n+   * Returns a Collection of all completed spans for {@link TracezSpanProcessor}.\n+   *\n+   * @return a Collection of {@link ReadableSpan}.\n+   */\n+  public Collection<ReadableSpan> getCompletedSpans() {\n+    Collection<ReadableSpan> completedSpans = new ArrayList<>();\n+    synchronized (this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyNzkyNw==", "bodyText": "Though I am worried about the performance impact of this synchronization, if it's just one latency bucket it's better, but I think it's pretty common for a server to only have a single method and serve huge QPS with similar latency (think an authentication server). The contention here seems like it could get pretty huge, possibly breaking the tenet that observability must not be intrusive.\nIt seems like a pretty small amount of code to implement a non-blocking ring buffer, if not in this PR can you make sure to try it in another that also adds a JMH? I don't think there's a need to have the bucket size match opencensus if there's a reason we find for a different.\nfinal class SpanBucket {\n  // power of 2 means Integer.MAX_VALUE % BUCKET_SIZE = BUCKET_SIZE - 1 the maximum remainder, and\n  // we will loop back to 0.\n  private static final int BUCKET_SIZE = 16; \n  private final Span[] spans = new Span[BUCKET_SIZE];\n  private final AtomicInteger index = new AtomicInteger();\n\n  void add(Span span) {\n    spans[UnsignedInts.remainder(index.getAndIncrement(), BUCKET_SIZE)] = span;\n  }\n\n  int size() {\n    for (int i = BUCKET_SIZE - 1; i >= 0; i--) {\n      if (spans[i] != null) {\n        return i + 1;\n      }\n    }\n    return 0;\n  }\n  \n  void addTo(List<Span> result) {\n    for (int i = 0; i < BUCKET_SIZE; i++) {\n      Span span = spans[i];\n      if (span != null) {\n        result.add(span);\n      } else {\n        break;\n      }\n    }\n  }", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451227927", "createdAt": "2020-07-08T01:16:36Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.EvictingQueue;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private static final int NUM_SAMPLES_PER_LATENCY_BUCKET = 10;\n+  private static final int NUM_SAMPLES_PER_ERROR_BUCKET = 5;\n+\n+  private final Map<LatencyBoundaries, EvictingQueue<ReadableSpan>> latencyBuckets =\n+      new HashMap<>();\n+  private final Map<CanonicalCode, EvictingQueue<ReadableSpan>> errorBuckets = new HashMap<>();\n+\n+  public TracezSpanBuckets() {\n+    for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+      latencyBuckets.put(\n+          bucket, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_LATENCY_BUCKET));\n+    }\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBuckets.put(code, EvictingQueue.<ReadableSpan>create(NUM_SAMPLES_PER_ERROR_BUCKET));\n+      }\n+    }\n+  }\n+\n+  public void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      long latency = span.getLatencyNanos();\n+      for (LatencyBoundaries bucket : LatencyBoundaries.values()) {\n+        if (latency >= bucket.getLatencyLowerBound() && latency < bucket.getLatencyUpperBound()) {\n+          synchronized (latencyBuckets) {\n+            latencyBuckets.get(bucket).add(span);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxNzM3OA=="}, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyOTY3NA==", "bodyText": "Sorry for back and forth, now realizing we do need to keep track of the spans I think it'd be ok to not keep track of span names incrementally, like your previous approach. Better not to worry about synchronization here if possible.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451229674", "createdAt": "2020-07-08T01:23:29Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link TracezSpanProcessor} can be read from system properties,\n+ * environment variables, or {@link java.util.Properties} objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.zpages.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_ZPAGES_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+final class TracezSpanProcessor implements SpanProcessor {\n+  private final ConcurrentMap<SpanId, ReadableSpan> runningSpanCache;\n+  private final ConcurrentMap<String, TracezSpanBuckets> completedSpanCache;\n+  private final Set<String> spanNames;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  public TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new ConcurrentHashMap<>();\n+    completedSpanCache = new ConcurrentHashMap<>();\n+    spanNames = new TreeSet<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    runningSpanCache.putIfAbsent(span.getSpanContext().getSpanId(), span);\n+    synchronized (spanNames) {\n+      spanNames.add(span.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMDQwMg==", "bodyText": ".putIfAbsent is only Java 8 (hmm strange that animal sniffer isn't catching this). Anyways, we don't need to care it'll only be called once, just use .put", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451230402", "createdAt": "2020-07-08T01:26:16Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link TracezSpanProcessor} can be read from system properties,\n+ * environment variables, or {@link java.util.Properties} objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.zpages.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_ZPAGES_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+final class TracezSpanProcessor implements SpanProcessor {\n+  private final ConcurrentMap<SpanId, ReadableSpan> runningSpanCache;\n+  private final ConcurrentMap<String, TracezSpanBuckets> completedSpanCache;\n+  private final Set<String> spanNames;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  public TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new ConcurrentHashMap<>();\n+    completedSpanCache = new ConcurrentHashMap<>();\n+    spanNames = new TreeSet<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    runningSpanCache.putIfAbsent(span.getSpanContext().getSpanId(), span);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMTIyNQ==", "bodyText": "Ditto, we'll want to do a double-checked lock\nTracezSpanBuckets buckets = completedSpanCache.get(span.getName());\nif (buckets == null) {\n  synchronized (completedSpanCache) {\n    buckets = completedSpanCache.get(span.getName());\n    if (buckets == null) {\n      buckets = new TracezSpanBuckets();\n      completedSpanCache.put(span.getName(), buckets);\n    }\n  }\n}\nbuckets.addToBucket(span);", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451231225", "createdAt": "2020-07-08T01:29:34Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link TracezSpanProcessor} can be read from system properties,\n+ * environment variables, or {@link java.util.Properties} objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.zpages.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_ZPAGES_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+final class TracezSpanProcessor implements SpanProcessor {\n+  private final ConcurrentMap<SpanId, ReadableSpan> runningSpanCache;\n+  private final ConcurrentMap<String, TracezSpanBuckets> completedSpanCache;\n+  private final Set<String> spanNames;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  public TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new ConcurrentHashMap<>();\n+    completedSpanCache = new ConcurrentHashMap<>();\n+    spanNames = new TreeSet<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    runningSpanCache.putIfAbsent(span.getSpanContext().getSpanId(), span);\n+    synchronized (spanNames) {\n+      spanNames.add(span.getName());\n+    }\n+  }\n+\n+  @Override\n+  public boolean isStartRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void onEnd(ReadableSpan span) {\n+    runningSpanCache.remove(span.getSpanContext().getSpanId());\n+    if (!sampled || span.getSpanContext().getTraceFlags().isSampled()) {\n+      completedSpanCache.putIfAbsent(span.getName(), new TracezSpanBuckets());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMjkyNw==", "bodyText": "Since performance of this page isn't a big deal, it's not too bad but reconsider using Formatter, it's orders of magnitude slower than concatenation and while useful for formatting floating points, otherwise is not doing much more than concatenation. It's generally good practice to just never use String.format / Formatter and not worry about the performance tradeoff.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451232927", "createdAt": "2020-07-08T01:36:11Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,594 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  // Map from LatencyBoundaries to human readable string on the UI\n+  private static final ImmutableMap<LatencyBoundaries, String> LATENCY_BOUNDARIES_STRING_MAP =\n+      buildLatencyBoundariesStringMap();\n+  @Nullable private final TracezDataAggregator dataAggregator;\n+\n+  /** Constructs a new {@code TracezZPageHandler}. */\n+  TracezZPageHandler(@Nullable TracezDataAggregator dataAggregator) {\n+    this.dataAggregator = dataAggregator;\n+  }\n+\n+  @Override\n+  public String getUrlPath() {\n+    return TRACEZ_URL;\n+  }\n+\n+  /**\n+   * Emits CSS Styles to the {@link PrintStream} {@code out}. Content emitted by this function\n+   * should be enclosed by <head></head> tag.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private static void emitHtmlStyle(PrintStream out) {\n+    out.print(\"<style>\");\n+    out.print(ZPageStyle.style);\n+    out.print(\"</style>\");\n+  }\n+\n+  /**\n+   * Emits the header of the summary table to the {@link PrintStream} {@code out}.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   * @param formatter a {@link Formatter} for formatting HTML expressions.\n+   */\n+  private static void emitSummaryTableHeader(PrintStream out, Formatter formatter) {\n+    // First row\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\"<th colspan=1 class=\\\"header-text\\\"><b>Span Name</b></th>\");\n+    out.print(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Running</b></th>\");\n+    out.print(\"<th colspan=9 class=\\\"header-text border-left-white\\\"><b>Latency Samples</b></th>\");\n+    out.print(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Error Samples</b></th>\");\n+    out.print(\"</tr>\");\n+\n+    // Second row\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\"<th colspan=1></th>\");\n+    out.print(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    for (LatencyBoundaries latencyBoundaries : LatencyBoundaries.values()) {\n+      formatter.format(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzNDg1Mw==", "bodyText": "Prefer @MockitoRule", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451234853", "createdAt": "2020-07-08T01:43:42Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandlerTest.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.EndSpanOptions;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+import java.util.Map;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Unit tests for {@link TracezZPageHandler}. */\n+@RunWith(JUnit4.class)\n+public final class TracezZPageHandlerTest {\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezZPageHandlerTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  private static final String FINISHED_SPAN_ONE = \"FinishedSpanOne\";\n+  private static final String FINISHED_SPAN_TWO = \"FinishedSpanTwo\";\n+  private static final String RUNNING_SPAN = \"RunningSpan\";\n+  private static final String LATENCY_SPAN = \"LatencySpan\";\n+  private static final String ERROR_SPAN = \"ErrorSpan\";\n+\n+  @Before\n+  public void setup() {\n+    MockitoAnnotations.initMocks(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzNDkzNQ==", "bodyText": "statics before non-statics", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451234935", "createdAt": "2020-07-08T01:44:04Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandlerTest.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.EndSpanOptions;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+import java.util.Map;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Unit tests for {@link TracezZPageHandler}. */\n+@RunWith(JUnit4.class)\n+public final class TracezZPageHandlerTest {\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezZPageHandlerTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  private static final String FINISHED_SPAN_ONE = \"FinishedSpanOne\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzNTE2NQ==", "bodyText": "Think there's a assertThat(counts).isEmpty()", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451235165", "createdAt": "2020-07-08T01:45:01Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorTest.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Unit tests for {@link TracezDataAggregator}. */\n+@RunWith(JUnit4.class)\n+public final class TracezDataAggregatorTest {\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezDataAggregatorTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  private static final String SPAN_NAME_ONE = \"one\";\n+  private static final String SPAN_NAME_TWO = \"two\";\n+\n+  @Before\n+  public void setup() {\n+    MockitoAnnotations.initMocks(this);\n+    tracerSdkProvider.addSpanProcessor(spanProcessor);\n+  }\n+\n+  @Test\n+  public void getSpanNames_noSpans() {\n+    assertThat(dataAggregator.getSpanNames().size()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  public void getSpanNames_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getSpanNames should return a set with 2 span names */\n+    Set<String> names = dataAggregator.getSpanNames();\n+    assertThat(names.size()).isEqualTo(2);\n+    assertThat(names).contains(SPAN_NAME_ONE);\n+    assertThat(names).contains(SPAN_NAME_TWO);\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getSpanNames should still return a set with 2 span names */\n+    names = dataAggregator.getSpanNames();\n+    assertThat(names.size()).isEqualTo(2);\n+    assertThat(names).contains(SPAN_NAME_ONE);\n+    assertThat(names).contains(SPAN_NAME_TWO);\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_noSpans() {\n+    /* getRunningSpanCounts should return a an empty map */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(0);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+    assertThat(counts.get(SPAN_NAME_TWO)).isNull();\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_oneSpanName() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    /* getRunningSpanCounts should return a map with 1 span name */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isEqualTo(3);\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getRunningSpanCounts should return a map with no span names */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(0);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getRunningSpanCounts should return a map with 2 different span names */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(2);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_TWO)).isEqualTo(1);\n+\n+    span1.end();\n+    /* getRunningSpanCounts should return a map with 1 unique span name */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+    assertThat(counts.get(SPAN_NAME_TWO)).isEqualTo(1);\n+\n+    span2.end();\n+    /* getRunningSpanCounts should return a map with no span names */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(0);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+    assertThat(counts.get(SPAN_NAME_TWO)).isNull();\n+  }\n+\n+  @Test\n+  public void getRunningSpans_noSpans() {\n+    /* getRunningSpans should return an empty List */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE).size()).isEqualTo(0);\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_TWO).size()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  public void getRunningSpans_oneSpanName() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    /* getRunningSpans should return a List with all 3 spans */\n+    List<SpanData> spans = dataAggregator.getRunningSpans(SPAN_NAME_ONE);\n+    assertThat(spans.size()).isEqualTo(3);\n+    assertThat(spans).contains(((ReadableSpan) span1).toSpanData());\n+    assertThat(spans).contains(((ReadableSpan) span2).toSpanData());\n+    assertThat(spans).contains(((ReadableSpan) span3).toSpanData());\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getRunningSpans should return an empty List */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE).size()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  public void getRunningSpans_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getRunningSpans should return a List with only the corresponding span */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE))\n+        .containsExactly(((ReadableSpan) span1).toSpanData());\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_TWO))\n+        .containsExactly(((ReadableSpan) span2).toSpanData());\n+    span1.end();\n+    span2.end();\n+    /* getRunningSpans should return an empty List for each span name */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE).size()).isEqualTo(0);\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_TWO).size()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  public void getSpanLatencyCounts_noSpans() {\n+    /* getSpanLatencyCounts should return a an empty map */\n+    Map<String, Map<LatencyBoundaries, Integer>> counts = dataAggregator.getSpanLatencyCounts();\n+    assertThat(counts.size()).isEqualTo(0);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+    assertThat(counts.get(SPAN_NAME_TWO)).isNull();\n+  }\n+\n+  @Test\n+  public void getSpanLatencyCounts_noCompletedSpans() {\n+    /* getSpanLatencyCounts should return a an empty map */\n+    Span span = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Map<String, Map<LatencyBoundaries, Integer>> counts = dataAggregator.getSpanLatencyCounts();\n+    span.end();\n+    assertThat(counts.size()).isEqualTo(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzNTI2Nw==", "bodyText": "Remove assertions on empty map they're redundant.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451235267", "createdAt": "2020-07-08T01:45:15Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorTest.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Unit tests for {@link TracezDataAggregator}. */\n+@RunWith(JUnit4.class)\n+public final class TracezDataAggregatorTest {\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezDataAggregatorTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  private static final String SPAN_NAME_ONE = \"one\";\n+  private static final String SPAN_NAME_TWO = \"two\";\n+\n+  @Before\n+  public void setup() {\n+    MockitoAnnotations.initMocks(this);\n+    tracerSdkProvider.addSpanProcessor(spanProcessor);\n+  }\n+\n+  @Test\n+  public void getSpanNames_noSpans() {\n+    assertThat(dataAggregator.getSpanNames().size()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  public void getSpanNames_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getSpanNames should return a set with 2 span names */\n+    Set<String> names = dataAggregator.getSpanNames();\n+    assertThat(names.size()).isEqualTo(2);\n+    assertThat(names).contains(SPAN_NAME_ONE);\n+    assertThat(names).contains(SPAN_NAME_TWO);\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getSpanNames should still return a set with 2 span names */\n+    names = dataAggregator.getSpanNames();\n+    assertThat(names.size()).isEqualTo(2);\n+    assertThat(names).contains(SPAN_NAME_ONE);\n+    assertThat(names).contains(SPAN_NAME_TWO);\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_noSpans() {\n+    /* getRunningSpanCounts should return a an empty map */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(0);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+    assertThat(counts.get(SPAN_NAME_TWO)).isNull();\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_oneSpanName() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    /* getRunningSpanCounts should return a map with 1 span name */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isEqualTo(3);\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getRunningSpanCounts should return a map with no span names */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(0);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getRunningSpanCounts should return a map with 2 different span names */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(2);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_TWO)).isEqualTo(1);\n+\n+    span1.end();\n+    /* getRunningSpanCounts should return a map with 1 unique span name */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+    assertThat(counts.get(SPAN_NAME_TWO)).isEqualTo(1);\n+\n+    span2.end();\n+    /* getRunningSpanCounts should return a map with no span names */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(0);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+    assertThat(counts.get(SPAN_NAME_TWO)).isNull();\n+  }\n+\n+  @Test\n+  public void getRunningSpans_noSpans() {\n+    /* getRunningSpans should return an empty List */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE).size()).isEqualTo(0);\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_TWO).size()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  public void getRunningSpans_oneSpanName() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    /* getRunningSpans should return a List with all 3 spans */\n+    List<SpanData> spans = dataAggregator.getRunningSpans(SPAN_NAME_ONE);\n+    assertThat(spans.size()).isEqualTo(3);\n+    assertThat(spans).contains(((ReadableSpan) span1).toSpanData());\n+    assertThat(spans).contains(((ReadableSpan) span2).toSpanData());\n+    assertThat(spans).contains(((ReadableSpan) span3).toSpanData());\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getRunningSpans should return an empty List */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE).size()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  public void getRunningSpans_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getRunningSpans should return a List with only the corresponding span */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE))\n+        .containsExactly(((ReadableSpan) span1).toSpanData());\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_TWO))\n+        .containsExactly(((ReadableSpan) span2).toSpanData());\n+    span1.end();\n+    span2.end();\n+    /* getRunningSpans should return an empty List for each span name */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE).size()).isEqualTo(0);\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_TWO).size()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  public void getSpanLatencyCounts_noSpans() {\n+    /* getSpanLatencyCounts should return a an empty map */\n+    Map<String, Map<LatencyBoundaries, Integer>> counts = dataAggregator.getSpanLatencyCounts();\n+    assertThat(counts.size()).isEqualTo(0);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+    assertThat(counts.get(SPAN_NAME_TWO)).isNull();\n+  }\n+\n+  @Test\n+  public void getSpanLatencyCounts_noCompletedSpans() {\n+    /* getSpanLatencyCounts should return a an empty map */\n+    Span span = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Map<String, Map<LatencyBoundaries, Integer>> counts = dataAggregator.getSpanLatencyCounts();\n+    span.end();\n+    assertThat(counts.size()).isEqualTo(0);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 190}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0ODY1NDc4", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-444865478", "createdAt": "2020-07-08T15:11:08Z", "commit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxNToxMTowOFrOGusvlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQxNToxMTowOFrOGusvlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYyMDc1OA==", "bodyText": "Yeah I would say it's a better default - otherwise you have to make a judgment call on performance vs readability, but I think the readability gain from printf is usually very low (interpolated strings would be a different story, eventually they'll be in Java and hopefully fast to make up for decades ;) )", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451620758", "createdAt": "2020-07-08T15:11:08Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,594 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  // Map from LatencyBoundaries to human readable string on the UI\n+  private static final ImmutableMap<LatencyBoundaries, String> LATENCY_BOUNDARIES_STRING_MAP =\n+      buildLatencyBoundariesStringMap();\n+  @Nullable private final TracezDataAggregator dataAggregator;\n+\n+  /** Constructs a new {@code TracezZPageHandler}. */\n+  TracezZPageHandler(@Nullable TracezDataAggregator dataAggregator) {\n+    this.dataAggregator = dataAggregator;\n+  }\n+\n+  @Override\n+  public String getUrlPath() {\n+    return TRACEZ_URL;\n+  }\n+\n+  /**\n+   * Emits CSS Styles to the {@link PrintStream} {@code out}. Content emitted by this function\n+   * should be enclosed by <head></head> tag.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private static void emitHtmlStyle(PrintStream out) {\n+    out.print(\"<style>\");\n+    out.print(ZPageStyle.style);\n+    out.print(\"</style>\");\n+  }\n+\n+  /**\n+   * Emits the header of the summary table to the {@link PrintStream} {@code out}.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   * @param formatter a {@link Formatter} for formatting HTML expressions.\n+   */\n+  private static void emitSummaryTableHeader(PrintStream out, Formatter formatter) {\n+    // First row\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\"<th colspan=1 class=\\\"header-text\\\"><b>Span Name</b></th>\");\n+    out.print(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Running</b></th>\");\n+    out.print(\"<th colspan=9 class=\\\"header-text border-left-white\\\"><b>Latency Samples</b></th>\");\n+    out.print(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Error Samples</b></th>\");\n+    out.print(\"</tr>\");\n+\n+    // Second row\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\"<th colspan=1></th>\");\n+    out.print(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    for (LatencyBoundaries latencyBoundaries : LatencyBoundaries.values()) {\n+      formatter.format(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMjkyNw=="}, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 146}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5e819e5002423825612086b48fb3009758f0a18", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/c5e819e5002423825612086b48fb3009758f0a18", "committedDate": "2020-07-08T15:20:14Z", "message": "Changed test to use Mockitorule, removed unnecessary Formatter, unrolled attribute value"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19b16d77cdfac95ea86ba01a892c43bf9f2f8a6c", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/19b16d77cdfac95ea86ba01a892c43bf9f2f8a6c", "committedDate": "2020-07-08T20:13:50Z", "message": "Changed test with @Mock to use Mockito test runner"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2647c45615c8e5690f5ca6ac63d2e298e44e34b7", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/2647c45615c8e5690f5ca6ac63d2e298e44e34b7", "committedDate": "2020-07-08T21:15:53Z", "message": "Renamed LatencyBoundaries to LatencyBoundary and cleaned up code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eea8895802c79bed039af92344761d4154dfb3e8", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/eea8895802c79bed039af92344761d4154dfb3e8", "committedDate": "2020-07-08T21:16:04Z", "message": "Merge branch 'master' of github.com:williamhu99/opentelemetry-java into master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88a703b4591e804e3804e5e8e8459d24244a2d27", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/88a703b4591e804e3804e5e8e8459d24244a2d27", "committedDate": "2020-07-08T22:38:47Z", "message": "Replaced the EvictingQueue with a faster SpanBucket class and modified checks in TracezDataAggregatorTest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MTgxMzMz", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-445181333", "createdAt": "2020-07-08T22:52:59Z", "commit": {"oid": "88a703b4591e804e3804e5e8e8459d24244a2d27"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQyMjo1Mjo1OVrOGu72zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQyMzozMzoyNVrOGu8pKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg2ODM2NA==", "bodyText": "Thanks I never noticed it has a different API on Java 7! Here let's still stick with put since we don't need the behavior (any span will only pass through here once)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451868364", "createdAt": "2020-07-08T22:52:59Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link TracezSpanProcessor} can be read from system properties,\n+ * environment variables, or {@link java.util.Properties} objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.zpages.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_ZPAGES_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+final class TracezSpanProcessor implements SpanProcessor {\n+  private final ConcurrentMap<SpanId, ReadableSpan> runningSpanCache;\n+  private final ConcurrentMap<String, TracezSpanBuckets> completedSpanCache;\n+  private final Set<String> spanNames;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  public TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new ConcurrentHashMap<>();\n+    completedSpanCache = new ConcurrentHashMap<>();\n+    spanNames = new TreeSet<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    runningSpanCache.putIfAbsent(span.getSpanContext().getSpanId(), span);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMDQwMg=="}, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg2ODUzMg==", "bodyText": "Yup sorry didn't realize the ConcurrentMap method, this LGTM", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451868532", "createdAt": "2020-07-08T22:53:33Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link TracezSpanProcessor} can be read from system properties,\n+ * environment variables, or {@link java.util.Properties} objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.zpages.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_ZPAGES_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+final class TracezSpanProcessor implements SpanProcessor {\n+  private final ConcurrentMap<SpanId, ReadableSpan> runningSpanCache;\n+  private final ConcurrentMap<String, TracezSpanBuckets> completedSpanCache;\n+  private final Set<String> spanNames;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  public TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new ConcurrentHashMap<>();\n+    completedSpanCache = new ConcurrentHashMap<>();\n+    spanNames = new TreeSet<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    runningSpanCache.putIfAbsent(span.getSpanContext().getSpanId(), span);\n+    synchronized (spanNames) {\n+      spanNames.add(span.getName());\n+    }\n+  }\n+\n+  @Override\n+  public boolean isStartRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void onEnd(ReadableSpan span) {\n+    runningSpanCache.remove(span.getSpanContext().getSpanId());\n+    if (!sampled || span.getSpanContext().getTraceFlags().isSampled()) {\n+      completedSpanCache.putIfAbsent(span.getName(), new TracezSpanBuckets());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMTIyNQ=="}, "originalCommit": {"oid": "dcaf7304c7d3e24bd6ea73058e5bbd806a899ecd"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg2OTk5Mw==", "bodyText": "Since package private, remove public", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451869993", "createdAt": "2020-07-08T22:57:54Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/LatencyBoundary.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A class of boundaries for the latency buckets. The completed spans with a status of {@link\n+ * io.opentelemetry.trace.Status#OK} are categorized into one of these buckets om the traceZ zPage.\n+ */\n+enum LatencyBoundary {\n+  /** Stores finished successful requests of duration within the interval [0, 10us). */\n+  ZERO_MICROSx10(0, TimeUnit.MICROSECONDS.toNanos(10)),\n+\n+  /** Stores finished successful requests of duration within the interval [10us, 100us). */\n+  MICROSx10_MICROSx100(TimeUnit.MICROSECONDS.toNanos(10), TimeUnit.MICROSECONDS.toNanos(100)),\n+\n+  /** Stores finished successful requests of duration within the interval [100us, 1ms). */\n+  MICROSx100_MILLIx1(TimeUnit.MICROSECONDS.toNanos(100), TimeUnit.MILLISECONDS.toNanos(1)),\n+\n+  /** Stores finished successful requests of duration within the interval [1ms, 10ms). */\n+  MILLIx1_MILLIx10(TimeUnit.MILLISECONDS.toNanos(1), TimeUnit.MILLISECONDS.toNanos(10)),\n+\n+  /** Stores finished successful requests of duration within the interval [10ms, 100ms). */\n+  MILLIx10_MILLIx100(TimeUnit.MILLISECONDS.toNanos(10), TimeUnit.MILLISECONDS.toNanos(100)),\n+\n+  /** Stores finished successful requests of duration within the interval [100ms, 1sec). */\n+  MILLIx100_SECONDx1(TimeUnit.MILLISECONDS.toNanos(100), TimeUnit.SECONDS.toNanos(1)),\n+\n+  /** Stores finished successful requests of duration within the interval [1sec, 10sec). */\n+  SECONDx1_SECONDx10(TimeUnit.SECONDS.toNanos(1), TimeUnit.SECONDS.toNanos(10)),\n+\n+  /** Stores finished successful requests of duration within the interval [10sec, 100sec). */\n+  SECONDx10_SECONDx100(TimeUnit.SECONDS.toNanos(10), TimeUnit.SECONDS.toNanos(100)),\n+\n+  /** Stores finished successful requests of duration greater than or equal to 100sec. */\n+  SECONDx100_MAX(TimeUnit.SECONDS.toNanos(100), Long.MAX_VALUE);\n+\n+  private final long latencyLowerBound;\n+  private final long latencyUpperBound;\n+\n+  /**\n+   * Constructs a {@code LatencyBoundaries} with the given boundaries and label.\n+   *\n+   * @param latencyLowerBound the latency lower bound of the bucket.\n+   * @param latencyUpperBound the latency upper bound of the bucket.\n+   */\n+  LatencyBoundary(long latencyLowerBound, long latencyUpperBound) {\n+    this.latencyLowerBound = latencyLowerBound;\n+    this.latencyUpperBound = latencyUpperBound;\n+  }\n+\n+  /**\n+   * Returns the latency lower bound of the bucket.\n+   *\n+   * @return the latency lower bound of the bucket.\n+   */\n+  public long getLatencyLowerBound() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88a703b4591e804e3804e5e8e8459d24244a2d27"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg3MTQxMA==", "bodyText": "Nit let's go ahead and initialize this in the constructor too a bit confusing when some is initialized as field and other in constructor", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451871410", "createdAt": "2020-07-08T23:02:17Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/SpanBucket.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.primitives.UnsignedInts;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+final class SpanBucket {\n+  // A power of 2 means Integer.MAX_VALUE % bucketSize = bucketSize - 1, so the index will always\n+  // loop back to 0.\n+  private static final int LATENCY_BUCKET_SIZE = 16;\n+  private static final int ERROR_BUCKET_SIZE = 8;\n+\n+  private final ReadableSpan[] spans;\n+  private final AtomicInteger index = new AtomicInteger();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88a703b4591e804e3804e5e8e8459d24244a2d27"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg3MjM1MQ==", "bodyText": "With your new implementation, I don't think we need this synchronization anywhere in this file :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451872351", "createdAt": "2020-07-08T23:05:14Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private final ImmutableMap<LatencyBoundary, SpanBucket> latencyBuckets;\n+  private final ImmutableMap<CanonicalCode, SpanBucket> errorBuckets;\n+\n+  TracezSpanBuckets() {\n+    ImmutableMap.Builder<LatencyBoundary, SpanBucket> latencyBucketsBuilder =\n+        ImmutableMap.builder();\n+    for (LatencyBoundary bucket : LatencyBoundary.values()) {\n+      latencyBucketsBuilder.put(bucket, new SpanBucket(/* isLatencyBucket= */ true));\n+    }\n+    latencyBuckets = latencyBucketsBuilder.build();\n+    ImmutableMap.Builder<CanonicalCode, SpanBucket> errorBucketsBuilder = ImmutableMap.builder();\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBucketsBuilder.put(code, new SpanBucket(/* isLatencyBucket= */ false));\n+      }\n+    }\n+    errorBuckets = errorBucketsBuilder.build();\n+  }\n+\n+  void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      SpanBucket latencyBucket =\n+          latencyBuckets.get(LatencyBoundary.getBoundary(span.getLatencyNanos()));\n+      synchronized (latencyBucket) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88a703b4591e804e3804e5e8e8459d24244a2d27"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg3NDA4Ng==", "bodyText": "This looks like a constant don't need to format", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451874086", "createdAt": "2020-07-08T23:10:36Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,605 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  // Map from LatencyBoundary to human readable string on the UI\n+  private static final ImmutableMap<LatencyBoundary, String> LATENCY_BOUNDARIES_STRING_MAP =\n+      buildLatencyBoundaryStringMap();\n+  @Nullable private final TracezDataAggregator dataAggregator;\n+\n+  /** Constructs a new {@code TracezZPageHandler}. */\n+  TracezZPageHandler(@Nullable TracezDataAggregator dataAggregator) {\n+    this.dataAggregator = dataAggregator;\n+  }\n+\n+  @Override\n+  public String getUrlPath() {\n+    return TRACEZ_URL;\n+  }\n+\n+  /**\n+   * Emits CSS Styles to the {@link PrintStream} {@code out}. Content emitted by this function\n+   * should be enclosed by <head></head> tag.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private static void emitHtmlStyle(PrintStream out) {\n+    out.print(\"<style>\");\n+    out.print(ZPageStyle.style);\n+    out.print(\"</style>\");\n+  }\n+\n+  /**\n+   * Emits the header of the summary table to the {@link PrintStream} {@code out}.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private static void emitSummaryTableHeader(PrintStream out) {\n+    // First row\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\"<th colspan=1 class=\\\"header-text\\\"><b>Span Name</b></th>\");\n+    out.print(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Running</b></th>\");\n+    out.print(\"<th colspan=9 class=\\\"header-text border-left-white\\\"><b>Latency Samples</b></th>\");\n+    out.print(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Error Samples</b></th>\");\n+    out.print(\"</tr>\");\n+\n+    // Second row\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\"<th colspan=1></th>\");\n+    out.print(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    for (LatencyBoundary latencyBoundary : LatencyBoundary.values()) {\n+      out.print(\n+          \"<th colspan=1 class=\\\"border-left-white align-center\\\"\"\n+              + \"style=\\\"color: #fff;\\\"><b>[\"\n+              + LATENCY_BOUNDARIES_STRING_MAP.get(latencyBoundary)\n+              + \"]</b></th>\");\n+    }\n+    out.print(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    out.print(\"</tr>\");\n+  }\n+\n+  /**\n+   * Emits a single cell of the summary table depends on the paramters passed in, to the {@link\n+   * PrintStream} {@code out}.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   * @param spanName the name of the corresponding span.\n+   * @param numOfSamples the number of samples of the corresponding span.\n+   * @param type the type of the corresponding span (running, latency, error).\n+   * @param subtype the sub-type of the corresponding span (latency [0, 8], error [0, 15]).\n+   */\n+  private static void emitSummaryTableCell(\n+      PrintStream out, String spanName, int numOfSamples, SampleType type, int subtype)\n+      throws UnsupportedEncodingException {\n+    // If numOfSamples is greater than 0, emit a link to see detailed span information\n+    // If numOfSamples is smaller than 0, print the text \"N/A\", otherwise print the text \"0\"\n+    if (numOfSamples > 0) {\n+      out.print(\"<td class=\\\"align-center border-left-dark\\\"><a href=\\\"?\");\n+      out.print(PARAM_SPAN_NAME + \"=\" + URLEncoder.encode(spanName, \"UTF-8\"));\n+      out.print(\"&\" + PARAM_SAMPLE_TYPE + \"=\" + type.getValue());\n+      out.print(\"&\" + PARAM_SAMPLE_SUB_TYPE + \"=\" + subtype);\n+      out.print(\"\\\">\" + numOfSamples + \"</a></td>\");\n+    } else if (numOfSamples < 0) {\n+      out.print(\"<td class=\\\"align-center border-left-dark\\\">N/A</td>\");\n+    } else {\n+      out.print(\"<td class=\\\"align-center border-left-dark\\\">0</td>\");\n+    }\n+  }\n+\n+  /**\n+   * Emits the summary table of running spans and sampled spans to the {@link PrintStream} {@code\n+   * out}.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private void emitSummaryTable(PrintStream out) throws UnsupportedEncodingException {\n+    if (dataAggregator == null) {\n+      return;\n+    }\n+    out.print(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    emitSummaryTableHeader(out);\n+\n+    Set<String> spanNames = dataAggregator.getSpanNames();\n+    boolean zebraStripe = false;\n+\n+    Map<String, Integer> runningSpanCounts = dataAggregator.getRunningSpanCounts();\n+    Map<String, Map<LatencyBoundary, Integer>> latencySpanCounts =\n+        dataAggregator.getSpanLatencyCounts();\n+    Map<String, Integer> errorSpanCounts = dataAggregator.getErrorSpanCounts();\n+    for (String spanName : spanNames) {\n+      if (zebraStripe) {\n+        out.print(\"<tr style=\\\"background-color: \" + ZEBRA_STRIPE_COLOR + \"\\\">\");\n+      } else {\n+        out.print(\"<tr>\");\n+      }\n+      zebraStripe = !zebraStripe;\n+      out.print(\"<td>\" + htmlEscaper().escape(spanName) + \"</td>\");\n+\n+      // Running spans column\n+      int numOfRunningSpans =\n+          runningSpanCounts.containsKey(spanName) ? runningSpanCounts.get(spanName) : 0;\n+      // subtype is ignored for running spans\n+      emitSummaryTableCell(out, spanName, numOfRunningSpans, SampleType.RUNNING, 0);\n+\n+      // Latency based sampled spans column\n+      int subtype = 0;\n+      for (LatencyBoundary latencyBoundary : LatencyBoundary.values()) {\n+        int numOfLatencySamples =\n+            latencySpanCounts.containsKey(spanName)\n+                    && latencySpanCounts.get(spanName).containsKey(latencyBoundary)\n+                ? latencySpanCounts.get(spanName).get(latencyBoundary)\n+                : 0;\n+        emitSummaryTableCell(out, spanName, numOfLatencySamples, SampleType.LATENCY, subtype);\n+        subtype += 1;\n+      }\n+\n+      // Error based sampled spans column\n+      int numOfErrorSamples =\n+          errorSpanCounts.containsKey(spanName) ? errorSpanCounts.get(spanName) : 0;\n+      // subtype 0 means all errors\n+      emitSummaryTableCell(out, spanName, numOfErrorSamples, SampleType.ERROR, 0);\n+    }\n+    out.print(\"</table>\");\n+  }\n+\n+  private static void emitSpanNameAndCount(\n+      PrintStream out, String spanName, int count, SampleType type) {\n+    out.print(\n+        \"<p class=\\\"align-center\\\"><b> Span Name: \" + htmlEscaper().escape(spanName) + \" </b></p>\");\n+    String typeString =\n+        type == SampleType.RUNNING\n+            ? \"running\"\n+            : type == SampleType.LATENCY ? \"latency samples\" : \"error samples\";\n+    out.print(\"<p class=\\\"align-center\\\"><b> Number of \" + typeString + \": \" + count + \" </b></p>\");\n+  }\n+\n+  private static void emitSpanDetails(\n+      PrintStream out, Formatter formatter, Collection<SpanData> spans) {\n+    out.print(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\n+        \"<td style=\\\"color: #fff;\\\"><pre class=\\\"no-margin wrap-text\\\"><b>When</b></pre></td>\");\n+    out.print(\n+        \"<td class=\\\"border-left-white\\\" style=\\\"color: #fff;\\\">\"\n+            + \"<pre class=\\\"no-margin wrap-text\\\"><b>Elapsed(s)</b></pre></td>\");\n+    out.print(\"<td class=\\\"border-left-white\\\"></td>\");\n+    out.print(\"</tr>\");\n+    boolean zebraStripe = false;\n+    for (SpanData span : spans) {\n+      zebraStripe = emitSingleSpan(out, formatter, span, zebraStripe);\n+    }\n+    out.print(\"</table>\");\n+  }\n+\n+  private static boolean emitSingleSpan(\n+      PrintStream out, Formatter formatter, SpanData span, boolean zebraStripe) {\n+    Calendar calendar = Calendar.getInstance();\n+    calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(span.getStartEpochNanos()));\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(span.getStartEpochNanos());\n+    String elapsedSecondsStr =\n+        span.getHasEnded()\n+            ? String.format(\"%.6f\", (span.getEndEpochNanos() - span.getStartEpochNanos()) * 1.0e-9)\n+            : String.format(\"%s\", \"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88a703b4591e804e3804e5e8e8459d24244a2d27"}, "originalPosition": 276}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg3OTc1Mw==", "bodyText": "You can add first as a boolean field of the anonymous KeyValueConsumer instead of using AtomicBoolean though it could be a bit more readable to separate out a named class which you pass the StringBuilder in explicitly", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451879753", "createdAt": "2020-07-08T23:28:34Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,605 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  // Map from LatencyBoundary to human readable string on the UI\n+  private static final ImmutableMap<LatencyBoundary, String> LATENCY_BOUNDARIES_STRING_MAP =\n+      buildLatencyBoundaryStringMap();\n+  @Nullable private final TracezDataAggregator dataAggregator;\n+\n+  /** Constructs a new {@code TracezZPageHandler}. */\n+  TracezZPageHandler(@Nullable TracezDataAggregator dataAggregator) {\n+    this.dataAggregator = dataAggregator;\n+  }\n+\n+  @Override\n+  public String getUrlPath() {\n+    return TRACEZ_URL;\n+  }\n+\n+  /**\n+   * Emits CSS Styles to the {@link PrintStream} {@code out}. Content emitted by this function\n+   * should be enclosed by <head></head> tag.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private static void emitHtmlStyle(PrintStream out) {\n+    out.print(\"<style>\");\n+    out.print(ZPageStyle.style);\n+    out.print(\"</style>\");\n+  }\n+\n+  /**\n+   * Emits the header of the summary table to the {@link PrintStream} {@code out}.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private static void emitSummaryTableHeader(PrintStream out) {\n+    // First row\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\"<th colspan=1 class=\\\"header-text\\\"><b>Span Name</b></th>\");\n+    out.print(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Running</b></th>\");\n+    out.print(\"<th colspan=9 class=\\\"header-text border-left-white\\\"><b>Latency Samples</b></th>\");\n+    out.print(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Error Samples</b></th>\");\n+    out.print(\"</tr>\");\n+\n+    // Second row\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\"<th colspan=1></th>\");\n+    out.print(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    for (LatencyBoundary latencyBoundary : LatencyBoundary.values()) {\n+      out.print(\n+          \"<th colspan=1 class=\\\"border-left-white align-center\\\"\"\n+              + \"style=\\\"color: #fff;\\\"><b>[\"\n+              + LATENCY_BOUNDARIES_STRING_MAP.get(latencyBoundary)\n+              + \"]</b></th>\");\n+    }\n+    out.print(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    out.print(\"</tr>\");\n+  }\n+\n+  /**\n+   * Emits a single cell of the summary table depends on the paramters passed in, to the {@link\n+   * PrintStream} {@code out}.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   * @param spanName the name of the corresponding span.\n+   * @param numOfSamples the number of samples of the corresponding span.\n+   * @param type the type of the corresponding span (running, latency, error).\n+   * @param subtype the sub-type of the corresponding span (latency [0, 8], error [0, 15]).\n+   */\n+  private static void emitSummaryTableCell(\n+      PrintStream out, String spanName, int numOfSamples, SampleType type, int subtype)\n+      throws UnsupportedEncodingException {\n+    // If numOfSamples is greater than 0, emit a link to see detailed span information\n+    // If numOfSamples is smaller than 0, print the text \"N/A\", otherwise print the text \"0\"\n+    if (numOfSamples > 0) {\n+      out.print(\"<td class=\\\"align-center border-left-dark\\\"><a href=\\\"?\");\n+      out.print(PARAM_SPAN_NAME + \"=\" + URLEncoder.encode(spanName, \"UTF-8\"));\n+      out.print(\"&\" + PARAM_SAMPLE_TYPE + \"=\" + type.getValue());\n+      out.print(\"&\" + PARAM_SAMPLE_SUB_TYPE + \"=\" + subtype);\n+      out.print(\"\\\">\" + numOfSamples + \"</a></td>\");\n+    } else if (numOfSamples < 0) {\n+      out.print(\"<td class=\\\"align-center border-left-dark\\\">N/A</td>\");\n+    } else {\n+      out.print(\"<td class=\\\"align-center border-left-dark\\\">0</td>\");\n+    }\n+  }\n+\n+  /**\n+   * Emits the summary table of running spans and sampled spans to the {@link PrintStream} {@code\n+   * out}.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private void emitSummaryTable(PrintStream out) throws UnsupportedEncodingException {\n+    if (dataAggregator == null) {\n+      return;\n+    }\n+    out.print(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    emitSummaryTableHeader(out);\n+\n+    Set<String> spanNames = dataAggregator.getSpanNames();\n+    boolean zebraStripe = false;\n+\n+    Map<String, Integer> runningSpanCounts = dataAggregator.getRunningSpanCounts();\n+    Map<String, Map<LatencyBoundary, Integer>> latencySpanCounts =\n+        dataAggregator.getSpanLatencyCounts();\n+    Map<String, Integer> errorSpanCounts = dataAggregator.getErrorSpanCounts();\n+    for (String spanName : spanNames) {\n+      if (zebraStripe) {\n+        out.print(\"<tr style=\\\"background-color: \" + ZEBRA_STRIPE_COLOR + \"\\\">\");\n+      } else {\n+        out.print(\"<tr>\");\n+      }\n+      zebraStripe = !zebraStripe;\n+      out.print(\"<td>\" + htmlEscaper().escape(spanName) + \"</td>\");\n+\n+      // Running spans column\n+      int numOfRunningSpans =\n+          runningSpanCounts.containsKey(spanName) ? runningSpanCounts.get(spanName) : 0;\n+      // subtype is ignored for running spans\n+      emitSummaryTableCell(out, spanName, numOfRunningSpans, SampleType.RUNNING, 0);\n+\n+      // Latency based sampled spans column\n+      int subtype = 0;\n+      for (LatencyBoundary latencyBoundary : LatencyBoundary.values()) {\n+        int numOfLatencySamples =\n+            latencySpanCounts.containsKey(spanName)\n+                    && latencySpanCounts.get(spanName).containsKey(latencyBoundary)\n+                ? latencySpanCounts.get(spanName).get(latencyBoundary)\n+                : 0;\n+        emitSummaryTableCell(out, spanName, numOfLatencySamples, SampleType.LATENCY, subtype);\n+        subtype += 1;\n+      }\n+\n+      // Error based sampled spans column\n+      int numOfErrorSamples =\n+          errorSpanCounts.containsKey(spanName) ? errorSpanCounts.get(spanName) : 0;\n+      // subtype 0 means all errors\n+      emitSummaryTableCell(out, spanName, numOfErrorSamples, SampleType.ERROR, 0);\n+    }\n+    out.print(\"</table>\");\n+  }\n+\n+  private static void emitSpanNameAndCount(\n+      PrintStream out, String spanName, int count, SampleType type) {\n+    out.print(\n+        \"<p class=\\\"align-center\\\"><b> Span Name: \" + htmlEscaper().escape(spanName) + \" </b></p>\");\n+    String typeString =\n+        type == SampleType.RUNNING\n+            ? \"running\"\n+            : type == SampleType.LATENCY ? \"latency samples\" : \"error samples\";\n+    out.print(\"<p class=\\\"align-center\\\"><b> Number of \" + typeString + \": \" + count + \" </b></p>\");\n+  }\n+\n+  private static void emitSpanDetails(\n+      PrintStream out, Formatter formatter, Collection<SpanData> spans) {\n+    out.print(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\n+        \"<td style=\\\"color: #fff;\\\"><pre class=\\\"no-margin wrap-text\\\"><b>When</b></pre></td>\");\n+    out.print(\n+        \"<td class=\\\"border-left-white\\\" style=\\\"color: #fff;\\\">\"\n+            + \"<pre class=\\\"no-margin wrap-text\\\"><b>Elapsed(s)</b></pre></td>\");\n+    out.print(\"<td class=\\\"border-left-white\\\"></td>\");\n+    out.print(\"</tr>\");\n+    boolean zebraStripe = false;\n+    for (SpanData span : spans) {\n+      zebraStripe = emitSingleSpan(out, formatter, span, zebraStripe);\n+    }\n+    out.print(\"</table>\");\n+  }\n+\n+  private static boolean emitSingleSpan(\n+      PrintStream out, Formatter formatter, SpanData span, boolean zebraStripe) {\n+    Calendar calendar = Calendar.getInstance();\n+    calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(span.getStartEpochNanos()));\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(span.getStartEpochNanos());\n+    String elapsedSecondsStr =\n+        span.getHasEnded()\n+            ? String.format(\"%.6f\", (span.getEndEpochNanos() - span.getStartEpochNanos()) * 1.0e-9)\n+            : String.format(\"%s\", \"\");\n+    formatter.format(\n+        \"<tr style=\\\"background-color: %s;\\\">\", zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+    formatter.format(\n+        \"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\"><b>\"\n+            + \"%04d/%02d/%02d-%02d:%02d:%02d.%06d</b></pre></td>\",\n+        calendar.get(Calendar.YEAR),\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        microsField);\n+    formatter.format(\n+        \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\"><b>%s</b></pre></td>\",\n+        elapsedSecondsStr);\n+    formatter.format(\n+        \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\"><b>\"\n+            + \"TraceId: <b style=\\\"color:%s;\\\">%s</b> \"\n+            + \" | SpanId: %s | ParentSpanId: %s</b></pre></td>\",\n+        span.getTraceFlags().isSampled() ? SAMPLED_TRACE_ID_COLOR : NOT_SAMPLED_TRACE_ID_COLOR,\n+        span.getTraceId().toLowerBase16(),\n+        span.getSpanId().toLowerBase16(),\n+        (span.getParentSpanId() == null\n+            ? SpanId.getInvalid().toLowerBase16()\n+            : span.getParentSpanId().toLowerBase16()));\n+    out.print(\"</tr>\");\n+    zebraStripe = !zebraStripe;\n+\n+    int lastEntryDayOfYear = calendar.get(Calendar.DAY_OF_YEAR);\n+\n+    long lastEpochNanos = span.getStartEpochNanos();\n+    List<Event> timedEvents = new ArrayList<>(span.getEvents());\n+    Collections.sort(timedEvents, new EventComparator());\n+    for (Event event : timedEvents) {\n+      calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(event.getEpochNanos()));\n+      formatter.format(\n+          \"<tr style=\\\"background-color: %s;\\\">\", zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+      emitSingleEvent(out, formatter, event, calendar, lastEntryDayOfYear, lastEpochNanos);\n+      out.print(\"</tr>\");\n+      if (calendar.get(Calendar.DAY_OF_YEAR) != lastEntryDayOfYear) {\n+        lastEntryDayOfYear = calendar.get(Calendar.DAY_OF_YEAR);\n+      }\n+      lastEpochNanos = event.getEpochNanos();\n+      zebraStripe = !zebraStripe;\n+    }\n+    formatter.format(\n+        \"<tr style=\\\"background-color: %s;\\\"><td></td><td class=\\\"border-left-dark\\\">\"\n+            + \"</td><td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">\",\n+        zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+    Status status = span.getStatus();\n+    if (status != null) {\n+      formatter.format(\"%s | \", htmlEscaper().escape(status.toString()));\n+    }\n+    formatter.format(\"%s</pre></td>\", htmlEscaper().escape(renderAttributes(span.getAttributes())));\n+    zebraStripe = !zebraStripe;\n+    return zebraStripe;\n+  }\n+\n+  private static void emitSingleEvent(\n+      PrintStream out,\n+      Formatter formatter,\n+      Event event,\n+      Calendar calendar,\n+      int lastEntryDayOfYear,\n+      long lastEpochNanos) {\n+    if (calendar.get(Calendar.DAY_OF_YEAR) == lastEntryDayOfYear) {\n+      out.print(\"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\">\");\n+    } else {\n+      formatter.format(\n+          \"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\">%04d/%02d/%02d-\",\n+          calendar.get(Calendar.YEAR),\n+          calendar.get(Calendar.MONTH) + 1,\n+          calendar.get(Calendar.DAY_OF_MONTH));\n+    }\n+\n+    // Special printing so that durations smaller than one second\n+    // are left padded with blanks instead of '0' characters.\n+    // E.g.,\n+    //        Number                  Printout\n+    //        ---------------------------------\n+    //        0.000534                  .   534\n+    //        1.000534                 1.000534\n+    long deltaMicros = TimeUnit.NANOSECONDS.toMicros(event.getEpochNanos() - lastEpochNanos);\n+    String deltaString;\n+    if (deltaMicros >= 1000000) {\n+      deltaString = String.format(\"%.6f\", (deltaMicros / 1000000.0));\n+    } else {\n+      deltaString = String.format(\"%1s.%6d\", \"\", deltaMicros);\n+    }\n+\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(event.getEpochNanos());\n+    formatter.format(\n+        \"%02d:%02d:%02d.%06d</pre></td> \"\n+            + \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">%s</pre></td>\"\n+            + \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">%s</pre></td>\",\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        microsField,\n+        deltaString,\n+        htmlEscaper().escape(renderEvent(event)));\n+  }\n+\n+  private static String renderAttributes(ReadableAttributes attributes) {\n+    final StringBuilder stringBuilder = new StringBuilder();\n+    stringBuilder.append(\"Attributes:{\");\n+    final AtomicBoolean first = new AtomicBoolean(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88a703b4591e804e3804e5e8e8459d24244a2d27"}, "originalPosition": 383}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg4MDA1Ng==", "bodyText": "Use java.util.Logger not system.err", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451880056", "createdAt": "2020-07-08T23:29:34Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -0,0 +1,605 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.html.HtmlEscapers.htmlEscaper;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs.KeyValueConsumer;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Event;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.Serializable;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Formatter;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+final class TracezZPageHandler extends ZPageHandler {\n+  private enum SampleType {\n+    RUNNING(0),\n+    LATENCY(1),\n+    ERROR(2),\n+    UNKNOWN(-1);\n+\n+    private final int value;\n+\n+    SampleType(int value) {\n+      this.value = value;\n+    }\n+\n+    static SampleType fromString(String str) {\n+      int value = Integer.parseInt(str);\n+      switch (value) {\n+        case 0:\n+          return RUNNING;\n+        case 1:\n+          return LATENCY;\n+        case 2:\n+          return ERROR;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+\n+    int getValue() {\n+      return value;\n+    }\n+  }\n+\n+  private static final String TRACEZ_URL = \"/tracez\";\n+  // Background color used for zebra striping rows of summary table\n+  private static final String ZEBRA_STRIPE_COLOR = \"#e6e6e6\";\n+  // Color for sampled traceIds\n+  private static final String SAMPLED_TRACE_ID_COLOR = \"#c1272d\";\n+  // Color for not sampled traceIds\n+  private static final String NOT_SAMPLED_TRACE_ID_COLOR = \"black\";\n+  // Query string parameter name for span name\n+  private static final String PARAM_SPAN_NAME = \"zspanname\";\n+  // Query string parameter name for type to display\n+  // * 0 = running, 1 = latency, 2 = error\n+  private static final String PARAM_SAMPLE_TYPE = \"ztype\";\n+  // Query string parameter name for sub-type:\n+  // * for latency based sampled spans [0, 8] corresponds to each latency boundaries\n+  //   where 0 corresponds to the first boundary\n+  // * for error based sampled spans [0, 15], 0 means all, otherwise the error code\n+  private static final String PARAM_SAMPLE_SUB_TYPE = \"zsubtype\";\n+  // Map from LatencyBoundary to human readable string on the UI\n+  private static final ImmutableMap<LatencyBoundary, String> LATENCY_BOUNDARIES_STRING_MAP =\n+      buildLatencyBoundaryStringMap();\n+  @Nullable private final TracezDataAggregator dataAggregator;\n+\n+  /** Constructs a new {@code TracezZPageHandler}. */\n+  TracezZPageHandler(@Nullable TracezDataAggregator dataAggregator) {\n+    this.dataAggregator = dataAggregator;\n+  }\n+\n+  @Override\n+  public String getUrlPath() {\n+    return TRACEZ_URL;\n+  }\n+\n+  /**\n+   * Emits CSS Styles to the {@link PrintStream} {@code out}. Content emitted by this function\n+   * should be enclosed by <head></head> tag.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private static void emitHtmlStyle(PrintStream out) {\n+    out.print(\"<style>\");\n+    out.print(ZPageStyle.style);\n+    out.print(\"</style>\");\n+  }\n+\n+  /**\n+   * Emits the header of the summary table to the {@link PrintStream} {@code out}.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private static void emitSummaryTableHeader(PrintStream out) {\n+    // First row\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\"<th colspan=1 class=\\\"header-text\\\"><b>Span Name</b></th>\");\n+    out.print(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Running</b></th>\");\n+    out.print(\"<th colspan=9 class=\\\"header-text border-left-white\\\"><b>Latency Samples</b></th>\");\n+    out.print(\"<th colspan=1 class=\\\"header-text border-left-white\\\"><b>Error Samples</b></th>\");\n+    out.print(\"</tr>\");\n+\n+    // Second row\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\"<th colspan=1></th>\");\n+    out.print(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    for (LatencyBoundary latencyBoundary : LatencyBoundary.values()) {\n+      out.print(\n+          \"<th colspan=1 class=\\\"border-left-white align-center\\\"\"\n+              + \"style=\\\"color: #fff;\\\"><b>[\"\n+              + LATENCY_BOUNDARIES_STRING_MAP.get(latencyBoundary)\n+              + \"]</b></th>\");\n+    }\n+    out.print(\"<th colspan=1 class=\\\"border-left-white\\\"></th>\");\n+    out.print(\"</tr>\");\n+  }\n+\n+  /**\n+   * Emits a single cell of the summary table depends on the paramters passed in, to the {@link\n+   * PrintStream} {@code out}.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   * @param spanName the name of the corresponding span.\n+   * @param numOfSamples the number of samples of the corresponding span.\n+   * @param type the type of the corresponding span (running, latency, error).\n+   * @param subtype the sub-type of the corresponding span (latency [0, 8], error [0, 15]).\n+   */\n+  private static void emitSummaryTableCell(\n+      PrintStream out, String spanName, int numOfSamples, SampleType type, int subtype)\n+      throws UnsupportedEncodingException {\n+    // If numOfSamples is greater than 0, emit a link to see detailed span information\n+    // If numOfSamples is smaller than 0, print the text \"N/A\", otherwise print the text \"0\"\n+    if (numOfSamples > 0) {\n+      out.print(\"<td class=\\\"align-center border-left-dark\\\"><a href=\\\"?\");\n+      out.print(PARAM_SPAN_NAME + \"=\" + URLEncoder.encode(spanName, \"UTF-8\"));\n+      out.print(\"&\" + PARAM_SAMPLE_TYPE + \"=\" + type.getValue());\n+      out.print(\"&\" + PARAM_SAMPLE_SUB_TYPE + \"=\" + subtype);\n+      out.print(\"\\\">\" + numOfSamples + \"</a></td>\");\n+    } else if (numOfSamples < 0) {\n+      out.print(\"<td class=\\\"align-center border-left-dark\\\">N/A</td>\");\n+    } else {\n+      out.print(\"<td class=\\\"align-center border-left-dark\\\">0</td>\");\n+    }\n+  }\n+\n+  /**\n+   * Emits the summary table of running spans and sampled spans to the {@link PrintStream} {@code\n+   * out}.\n+   *\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private void emitSummaryTable(PrintStream out) throws UnsupportedEncodingException {\n+    if (dataAggregator == null) {\n+      return;\n+    }\n+    out.print(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    emitSummaryTableHeader(out);\n+\n+    Set<String> spanNames = dataAggregator.getSpanNames();\n+    boolean zebraStripe = false;\n+\n+    Map<String, Integer> runningSpanCounts = dataAggregator.getRunningSpanCounts();\n+    Map<String, Map<LatencyBoundary, Integer>> latencySpanCounts =\n+        dataAggregator.getSpanLatencyCounts();\n+    Map<String, Integer> errorSpanCounts = dataAggregator.getErrorSpanCounts();\n+    for (String spanName : spanNames) {\n+      if (zebraStripe) {\n+        out.print(\"<tr style=\\\"background-color: \" + ZEBRA_STRIPE_COLOR + \"\\\">\");\n+      } else {\n+        out.print(\"<tr>\");\n+      }\n+      zebraStripe = !zebraStripe;\n+      out.print(\"<td>\" + htmlEscaper().escape(spanName) + \"</td>\");\n+\n+      // Running spans column\n+      int numOfRunningSpans =\n+          runningSpanCounts.containsKey(spanName) ? runningSpanCounts.get(spanName) : 0;\n+      // subtype is ignored for running spans\n+      emitSummaryTableCell(out, spanName, numOfRunningSpans, SampleType.RUNNING, 0);\n+\n+      // Latency based sampled spans column\n+      int subtype = 0;\n+      for (LatencyBoundary latencyBoundary : LatencyBoundary.values()) {\n+        int numOfLatencySamples =\n+            latencySpanCounts.containsKey(spanName)\n+                    && latencySpanCounts.get(spanName).containsKey(latencyBoundary)\n+                ? latencySpanCounts.get(spanName).get(latencyBoundary)\n+                : 0;\n+        emitSummaryTableCell(out, spanName, numOfLatencySamples, SampleType.LATENCY, subtype);\n+        subtype += 1;\n+      }\n+\n+      // Error based sampled spans column\n+      int numOfErrorSamples =\n+          errorSpanCounts.containsKey(spanName) ? errorSpanCounts.get(spanName) : 0;\n+      // subtype 0 means all errors\n+      emitSummaryTableCell(out, spanName, numOfErrorSamples, SampleType.ERROR, 0);\n+    }\n+    out.print(\"</table>\");\n+  }\n+\n+  private static void emitSpanNameAndCount(\n+      PrintStream out, String spanName, int count, SampleType type) {\n+    out.print(\n+        \"<p class=\\\"align-center\\\"><b> Span Name: \" + htmlEscaper().escape(spanName) + \" </b></p>\");\n+    String typeString =\n+        type == SampleType.RUNNING\n+            ? \"running\"\n+            : type == SampleType.LATENCY ? \"latency samples\" : \"error samples\";\n+    out.print(\"<p class=\\\"align-center\\\"><b> Number of \" + typeString + \": \" + count + \" </b></p>\");\n+  }\n+\n+  private static void emitSpanDetails(\n+      PrintStream out, Formatter formatter, Collection<SpanData> spans) {\n+    out.print(\"<table style=\\\"border-spacing: 0; border: 1px solid #363636;\\\">\");\n+    out.print(\"<tr class=\\\"bg-color\\\">\");\n+    out.print(\n+        \"<td style=\\\"color: #fff;\\\"><pre class=\\\"no-margin wrap-text\\\"><b>When</b></pre></td>\");\n+    out.print(\n+        \"<td class=\\\"border-left-white\\\" style=\\\"color: #fff;\\\">\"\n+            + \"<pre class=\\\"no-margin wrap-text\\\"><b>Elapsed(s)</b></pre></td>\");\n+    out.print(\"<td class=\\\"border-left-white\\\"></td>\");\n+    out.print(\"</tr>\");\n+    boolean zebraStripe = false;\n+    for (SpanData span : spans) {\n+      zebraStripe = emitSingleSpan(out, formatter, span, zebraStripe);\n+    }\n+    out.print(\"</table>\");\n+  }\n+\n+  private static boolean emitSingleSpan(\n+      PrintStream out, Formatter formatter, SpanData span, boolean zebraStripe) {\n+    Calendar calendar = Calendar.getInstance();\n+    calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(span.getStartEpochNanos()));\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(span.getStartEpochNanos());\n+    String elapsedSecondsStr =\n+        span.getHasEnded()\n+            ? String.format(\"%.6f\", (span.getEndEpochNanos() - span.getStartEpochNanos()) * 1.0e-9)\n+            : String.format(\"%s\", \"\");\n+    formatter.format(\n+        \"<tr style=\\\"background-color: %s;\\\">\", zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+    formatter.format(\n+        \"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\"><b>\"\n+            + \"%04d/%02d/%02d-%02d:%02d:%02d.%06d</b></pre></td>\",\n+        calendar.get(Calendar.YEAR),\n+        calendar.get(Calendar.MONTH) + 1,\n+        calendar.get(Calendar.DAY_OF_MONTH),\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        microsField);\n+    formatter.format(\n+        \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\"><b>%s</b></pre></td>\",\n+        elapsedSecondsStr);\n+    formatter.format(\n+        \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\"><b>\"\n+            + \"TraceId: <b style=\\\"color:%s;\\\">%s</b> \"\n+            + \" | SpanId: %s | ParentSpanId: %s</b></pre></td>\",\n+        span.getTraceFlags().isSampled() ? SAMPLED_TRACE_ID_COLOR : NOT_SAMPLED_TRACE_ID_COLOR,\n+        span.getTraceId().toLowerBase16(),\n+        span.getSpanId().toLowerBase16(),\n+        (span.getParentSpanId() == null\n+            ? SpanId.getInvalid().toLowerBase16()\n+            : span.getParentSpanId().toLowerBase16()));\n+    out.print(\"</tr>\");\n+    zebraStripe = !zebraStripe;\n+\n+    int lastEntryDayOfYear = calendar.get(Calendar.DAY_OF_YEAR);\n+\n+    long lastEpochNanos = span.getStartEpochNanos();\n+    List<Event> timedEvents = new ArrayList<>(span.getEvents());\n+    Collections.sort(timedEvents, new EventComparator());\n+    for (Event event : timedEvents) {\n+      calendar.setTimeInMillis(TimeUnit.NANOSECONDS.toMillis(event.getEpochNanos()));\n+      formatter.format(\n+          \"<tr style=\\\"background-color: %s;\\\">\", zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+      emitSingleEvent(out, formatter, event, calendar, lastEntryDayOfYear, lastEpochNanos);\n+      out.print(\"</tr>\");\n+      if (calendar.get(Calendar.DAY_OF_YEAR) != lastEntryDayOfYear) {\n+        lastEntryDayOfYear = calendar.get(Calendar.DAY_OF_YEAR);\n+      }\n+      lastEpochNanos = event.getEpochNanos();\n+      zebraStripe = !zebraStripe;\n+    }\n+    formatter.format(\n+        \"<tr style=\\\"background-color: %s;\\\"><td></td><td class=\\\"border-left-dark\\\">\"\n+            + \"</td><td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">\",\n+        zebraStripe ? ZEBRA_STRIPE_COLOR : \"#fff\");\n+    Status status = span.getStatus();\n+    if (status != null) {\n+      formatter.format(\"%s | \", htmlEscaper().escape(status.toString()));\n+    }\n+    formatter.format(\"%s</pre></td>\", htmlEscaper().escape(renderAttributes(span.getAttributes())));\n+    zebraStripe = !zebraStripe;\n+    return zebraStripe;\n+  }\n+\n+  private static void emitSingleEvent(\n+      PrintStream out,\n+      Formatter formatter,\n+      Event event,\n+      Calendar calendar,\n+      int lastEntryDayOfYear,\n+      long lastEpochNanos) {\n+    if (calendar.get(Calendar.DAY_OF_YEAR) == lastEntryDayOfYear) {\n+      out.print(\"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\">\");\n+    } else {\n+      formatter.format(\n+          \"<td class=\\\"align-right\\\"><pre class=\\\"no-margin wrap-text\\\">%04d/%02d/%02d-\",\n+          calendar.get(Calendar.YEAR),\n+          calendar.get(Calendar.MONTH) + 1,\n+          calendar.get(Calendar.DAY_OF_MONTH));\n+    }\n+\n+    // Special printing so that durations smaller than one second\n+    // are left padded with blanks instead of '0' characters.\n+    // E.g.,\n+    //        Number                  Printout\n+    //        ---------------------------------\n+    //        0.000534                  .   534\n+    //        1.000534                 1.000534\n+    long deltaMicros = TimeUnit.NANOSECONDS.toMicros(event.getEpochNanos() - lastEpochNanos);\n+    String deltaString;\n+    if (deltaMicros >= 1000000) {\n+      deltaString = String.format(\"%.6f\", (deltaMicros / 1000000.0));\n+    } else {\n+      deltaString = String.format(\"%1s.%6d\", \"\", deltaMicros);\n+    }\n+\n+    long microsField = TimeUnit.NANOSECONDS.toMicros(event.getEpochNanos());\n+    formatter.format(\n+        \"%02d:%02d:%02d.%06d</pre></td> \"\n+            + \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">%s</pre></td>\"\n+            + \"<td class=\\\"border-left-dark\\\"><pre class=\\\"no-margin wrap-text\\\">%s</pre></td>\",\n+        calendar.get(Calendar.HOUR_OF_DAY),\n+        calendar.get(Calendar.MINUTE),\n+        calendar.get(Calendar.SECOND),\n+        microsField,\n+        deltaString,\n+        htmlEscaper().escape(renderEvent(event)));\n+  }\n+\n+  private static String renderAttributes(ReadableAttributes attributes) {\n+    final StringBuilder stringBuilder = new StringBuilder();\n+    stringBuilder.append(\"Attributes:{\");\n+    final AtomicBoolean first = new AtomicBoolean(true);\n+    attributes.forEach(\n+        new KeyValueConsumer<AttributeValue>() {\n+          @Override\n+          public void consume(String key, AttributeValue value) {\n+            if (!first.getAndSet(false)) {\n+              stringBuilder.append(\", \");\n+            }\n+            stringBuilder.append(key);\n+            stringBuilder.append(\"=\");\n+            switch (value.getType()) {\n+              case STRING:\n+                stringBuilder.append(value.getStringValue());\n+                break;\n+              case BOOLEAN:\n+                stringBuilder.append(value.getBooleanValue());\n+                break;\n+              case LONG:\n+                stringBuilder.append(value.getLongValue());\n+                break;\n+              case DOUBLE:\n+                stringBuilder.append(value.getDoubleValue());\n+                break;\n+              case STRING_ARRAY:\n+                stringBuilder.append(value.getStringArrayValue().toString());\n+                break;\n+              case BOOLEAN_ARRAY:\n+                stringBuilder.append(value.getBooleanArrayValue().toString());\n+                break;\n+              case LONG_ARRAY:\n+                stringBuilder.append(value.getLongArrayValue().toString());\n+                break;\n+              case DOUBLE_ARRAY:\n+                stringBuilder.append(value.getDoubleArrayValue().toString());\n+                break;\n+            }\n+          }\n+        });\n+    stringBuilder.append(\"}\");\n+    return stringBuilder.toString();\n+  }\n+\n+  private static String renderEvent(Event event) {\n+    StringBuilder stringBuilder = new StringBuilder();\n+    stringBuilder.append(event.getName());\n+    if (!event.getAttributes().isEmpty()) {\n+      stringBuilder.append(\" | \");\n+      stringBuilder.append(renderAttributes(event.getAttributes()));\n+    }\n+    return stringBuilder.toString();\n+  }\n+\n+  /**\n+   * Emits HTML body content to the {@link PrintStream} {@code out}. Content emitted by this\n+   * function should be enclosed by <body></body> tag.\n+   *\n+   * @param queryMap the map containing URL query parameters.s\n+   * @param out the {@link PrintStream} {@code out}.\n+   */\n+  private void emitHtmlBody(Map<String, String> queryMap, PrintStream out)\n+      throws UnsupportedEncodingException {\n+    if (dataAggregator == null) {\n+      out.print(\"OpenTelemetry implementation not available.\");\n+      return;\n+    }\n+    // Link to OpenTelemetry Logo\n+    out.print(\n+        \"<img style=\\\"height: 90px;\\\" src=\\\"data:image/png;base64,\"\n+            + ZPageLogo.logoBase64\n+            + \"\\\" />\");\n+    out.print(\"<h1>TraceZ Summary</h1>\");\n+    emitSummaryTable(out);\n+    // spanName will be null if the query parameter doesn't exist in the URL\n+    String spanName = queryMap.get(PARAM_SPAN_NAME);\n+    if (spanName != null) {\n+      // Convert spanName with URL encoding\n+      spanName = URLEncoder.encode(spanName, \"UTF-8\");\n+      // Show detailed information for the corresponding span\n+      String typeStr = queryMap.get(PARAM_SAMPLE_TYPE);\n+      if (typeStr != null) {\n+        List<SpanData> spans = null;\n+        SampleType type = SampleType.fromString(typeStr);\n+        if (type == SampleType.UNKNOWN) {\n+          // Type of sample is garbage value\n+          return;\n+        } else if (type == SampleType.RUNNING) {\n+          // Display running span\n+          spans = dataAggregator.getRunningSpans(spanName);\n+          Collections.sort(spans, new SpanDataComparator(/* incremental= */ true));\n+        } else {\n+          String subtypeStr = queryMap.get(PARAM_SAMPLE_SUB_TYPE);\n+          if (subtypeStr != null) {\n+            int subtype = Integer.parseInt(subtypeStr);\n+            if (type == SampleType.LATENCY) {\n+              if (subtype < 0 || subtype >= LatencyBoundary.values().length) {\n+                // N/A or out-of-bound check for latency based subtype, valid values: [0, 8]\n+                return;\n+              }\n+              // Display latency based span\n+              LatencyBoundary latencyBoundary = LatencyBoundary.values()[subtype];\n+              spans =\n+                  dataAggregator.getOkSpans(\n+                      spanName,\n+                      latencyBoundary.getLatencyLowerBound(),\n+                      latencyBoundary.getLatencyUpperBound());\n+              Collections.sort(spans, new SpanDataComparator(/* incremental= */ false));\n+            } else {\n+              if (subtype < 0 || subtype >= CanonicalCode.values().length) {\n+                // N/A or out-of-bound cueck for error based subtype, valid values: [0, 15]\n+                return;\n+              }\n+              // Display error based span\n+              spans = dataAggregator.getErrorSpans(spanName);\n+              Collections.sort(spans, new SpanDataComparator(/* incremental= */ false));\n+            }\n+          }\n+        }\n+        out.print(\"<h2>Span Details</h2>\");\n+        emitSpanNameAndCount(out, spanName, spans == null ? 0 : spans.size(), type);\n+\n+        if (spans != null) {\n+          Formatter formatter = new Formatter(out, Locale.US);\n+          emitSpanDetails(out, formatter, spans);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void emitHtml(Map<String, String> queryMap, OutputStream outputStream) {\n+    // PrintStream for emiting HTML contents\n+    try (PrintStream out = new PrintStream(outputStream, /* autoFlush= */ false, \"UTF-8\")) {\n+      out.print(\"<!DOCTYPE html>\");\n+      out.print(\"<html lang=\\\"en\\\">\");\n+      out.print(\"<head>\");\n+      out.print(\"<meta charset=\\\"UTF-8\\\">\");\n+      out.print(\n+          \"<link rel=\\\"shortcut icon\\\" href=\\\"data:image/png;base64,\"\n+              + ZPageLogo.faviconBase64\n+              + \"\\\" type=\\\"image/png\\\">\");\n+      out.print(\n+          \"<link href=\\\"https://fonts.googleapis.com/css?family=Open+Sans:300\\\"\"\n+              + \"rel=\\\"stylesheet\\\">\");\n+      out.print(\n+          \"<link href=\\\"https://fonts.googleapis.com/css?family=Roboto\\\" rel=\\\"stylesheet\\\">\");\n+      out.print(\"<title>TraceZ</title>\");\n+      emitHtmlStyle(out);\n+      out.print(\"</head>\");\n+      out.print(\"<body>\");\n+      try {\n+        emitHtmlBody(queryMap, out);\n+      } catch (Throwable t) {\n+        out.print(\"Error while generating HTML: \" + t.toString());\n+      }\n+      out.print(\"</body>\");\n+      out.print(\"</html>\");\n+    } catch (Throwable t) {\n+      System.err.print(\"Error while generating HTML: \" + t.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88a703b4591e804e3804e5e8e8459d24244a2d27"}, "originalPosition": 540}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg4MDU3Ng==", "bodyText": "Static before non-static", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451880576", "createdAt": "2020-07-08T23:31:16Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorTest.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for {@link TracezDataAggregator}. */\n+@RunWith(JUnit4.class)\n+public final class TracezDataAggregatorTest {\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezDataAggregatorTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  private static final String SPAN_NAME_ONE = \"one\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88a703b4591e804e3804e5e8e8459d24244a2d27"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg4MDkwNQ==", "bodyText": "Don't need to check size, you can check contents directly, e.g,\nassertThat(names).containsExactly(SPAN_NAME_ONE, SPAN_NAME_TWO)\nApplies throughout PR", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451880905", "createdAt": "2020-07-08T23:32:17Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorTest.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for {@link TracezDataAggregator}. */\n+@RunWith(JUnit4.class)\n+public final class TracezDataAggregatorTest {\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezDataAggregatorTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  private static final String SPAN_NAME_ONE = \"one\";\n+  private static final String SPAN_NAME_TWO = \"two\";\n+\n+  @Rule public MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  @Before\n+  public void setup() {\n+    tracerSdkProvider.addSpanProcessor(spanProcessor);\n+  }\n+\n+  @Test\n+  public void getSpanNames_noSpans() {\n+    assertThat(dataAggregator.getSpanNames()).isEmpty();\n+  }\n+\n+  @Test\n+  public void getSpanNames_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getSpanNames should return a set with 2 span names */\n+    Set<String> names = dataAggregator.getSpanNames();\n+    assertThat(names.size()).isEqualTo(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88a703b4591e804e3804e5e8e8459d24244a2d27"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg4MTA1Mw==", "bodyText": "Map assert also has containsExactly", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451881053", "createdAt": "2020-07-08T23:32:46Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorTest.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for {@link TracezDataAggregator}. */\n+@RunWith(JUnit4.class)\n+public final class TracezDataAggregatorTest {\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezDataAggregatorTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  private static final String SPAN_NAME_ONE = \"one\";\n+  private static final String SPAN_NAME_TWO = \"two\";\n+\n+  @Rule public MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  @Before\n+  public void setup() {\n+    tracerSdkProvider.addSpanProcessor(spanProcessor);\n+  }\n+\n+  @Test\n+  public void getSpanNames_noSpans() {\n+    assertThat(dataAggregator.getSpanNames()).isEmpty();\n+  }\n+\n+  @Test\n+  public void getSpanNames_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getSpanNames should return a set with 2 span names */\n+    Set<String> names = dataAggregator.getSpanNames();\n+    assertThat(names.size()).isEqualTo(2);\n+    assertThat(names).contains(SPAN_NAME_ONE);\n+    assertThat(names).contains(SPAN_NAME_TWO);\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getSpanNames should still return a set with 2 span names */\n+    names = dataAggregator.getSpanNames();\n+    assertThat(names.size()).isEqualTo(2);\n+    assertThat(names).contains(SPAN_NAME_ONE);\n+    assertThat(names).contains(SPAN_NAME_TWO);\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_noSpans() {\n+    /* getRunningSpanCounts should return a an empty map */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts).isEmpty();\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_oneSpanName() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    /* getRunningSpanCounts should return a map with 1 span name */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isEqualTo(3);\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getRunningSpanCounts should return a map with no span names */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts).isEmpty();\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getRunningSpanCounts should return a map with 2 different span names */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(2);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_TWO)).isEqualTo(1);\n+\n+    span1.end();\n+    /* getRunningSpanCounts should return a map with 1 unique span name */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88a703b4591e804e3804e5e8e8459d24244a2d27"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg4MTI1OA==", "bodyText": "assertThat(counts).isEmpty() and remove following", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r451881258", "createdAt": "2020-07-08T23:33:25Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregatorTest.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for {@link TracezDataAggregator}. */\n+@RunWith(JUnit4.class)\n+public final class TracezDataAggregatorTest {\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezDataAggregatorTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  private static final String SPAN_NAME_ONE = \"one\";\n+  private static final String SPAN_NAME_TWO = \"two\";\n+\n+  @Rule public MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  @Before\n+  public void setup() {\n+    tracerSdkProvider.addSpanProcessor(spanProcessor);\n+  }\n+\n+  @Test\n+  public void getSpanNames_noSpans() {\n+    assertThat(dataAggregator.getSpanNames()).isEmpty();\n+  }\n+\n+  @Test\n+  public void getSpanNames_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getSpanNames should return a set with 2 span names */\n+    Set<String> names = dataAggregator.getSpanNames();\n+    assertThat(names.size()).isEqualTo(2);\n+    assertThat(names).contains(SPAN_NAME_ONE);\n+    assertThat(names).contains(SPAN_NAME_TWO);\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getSpanNames should still return a set with 2 span names */\n+    names = dataAggregator.getSpanNames();\n+    assertThat(names.size()).isEqualTo(2);\n+    assertThat(names).contains(SPAN_NAME_ONE);\n+    assertThat(names).contains(SPAN_NAME_TWO);\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_noSpans() {\n+    /* getRunningSpanCounts should return a an empty map */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts).isEmpty();\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_oneSpanName() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    /* getRunningSpanCounts should return a map with 1 span name */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isEqualTo(3);\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getRunningSpanCounts should return a map with no span names */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts).isEmpty();\n+  }\n+\n+  @Test\n+  public void getRunningSpanCounts_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getRunningSpanCounts should return a map with 2 different span names */\n+    Map<String, Integer> counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(2);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_TWO)).isEqualTo(1);\n+\n+    span1.end();\n+    /* getRunningSpanCounts should return a map with 1 unique span name */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts.size()).isEqualTo(1);\n+    assertThat(counts.get(SPAN_NAME_ONE)).isNull();\n+    assertThat(counts.get(SPAN_NAME_TWO)).isEqualTo(1);\n+\n+    span2.end();\n+    /* getRunningSpanCounts should return a map with no span names */\n+    counts = dataAggregator.getRunningSpanCounts();\n+    assertThat(counts).isEmpty();\n+  }\n+\n+  @Test\n+  public void getRunningSpans_noSpans() {\n+    /* getRunningSpans should return an empty List */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE)).isEmpty();\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_TWO)).isEmpty();\n+  }\n+\n+  @Test\n+  public void getRunningSpans_oneSpanName() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span3 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    /* getRunningSpans should return a List with all 3 spans */\n+    List<SpanData> spans = dataAggregator.getRunningSpans(SPAN_NAME_ONE);\n+    assertThat(spans.size()).isEqualTo(3);\n+    assertThat(spans).contains(((ReadableSpan) span1).toSpanData());\n+    assertThat(spans).contains(((ReadableSpan) span2).toSpanData());\n+    assertThat(spans).contains(((ReadableSpan) span3).toSpanData());\n+    span1.end();\n+    span2.end();\n+    span3.end();\n+    /* getRunningSpans should return an empty List */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE)).isEmpty();\n+  }\n+\n+  @Test\n+  public void getRunningSpans_twoSpanNames() {\n+    Span span1 = tracer.spanBuilder(SPAN_NAME_ONE).startSpan();\n+    Span span2 = tracer.spanBuilder(SPAN_NAME_TWO).startSpan();\n+    /* getRunningSpans should return a List with only the corresponding span */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE))\n+        .containsExactly(((ReadableSpan) span1).toSpanData());\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_TWO))\n+        .containsExactly(((ReadableSpan) span2).toSpanData());\n+    span1.end();\n+    span2.end();\n+    /* getRunningSpans should return an empty List for each span name */\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_ONE)).isEmpty();\n+    assertThat(dataAggregator.getRunningSpans(SPAN_NAME_TWO)).isEmpty();\n+  }\n+\n+  @Test\n+  public void getSpanLatencyCounts_noSpans() {\n+    /* getSpanLatencyCounts should return a an empty map */\n+    Map<String, Map<LatencyBoundary, Integer>> counts = dataAggregator.getSpanLatencyCounts();\n+    assertThat(counts.size()).isEqualTo(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88a703b4591e804e3804e5e8e8459d24244a2d27"}, "originalPosition": 176}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fee6378c49a085fb6ce72b38b4c739b0d4812cff", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/fee6378c49a085fb6ce72b38b4c739b0d4812cff", "committedDate": "2020-07-09T18:02:35Z", "message": "Addressed additional comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3934318c1146974a786cb3918291c85d5d32a4e", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/a3934318c1146974a786cb3918291c85d5d32a4e", "committedDate": "2020-07-09T19:18:39Z", "message": "Migrated images to resources, used logger to log errors, and other minor fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b2357f4fa00e697080807f0e65b3d9406e6a0b9", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/0b2357f4fa00e697080807f0e65b3d9406e6a0b9", "committedDate": "2020-07-09T23:33:40Z", "message": "Moved a variable to within a class in TracezZPageHandler"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be61de27eddf89762857a3b6b5ef997a18e85014", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/be61de27eddf89762857a3b6b5ef997a18e85014", "committedDate": "2020-07-09T23:35:17Z", "message": "Made a small fix to scope"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NzY3Nzc3", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-446767777", "createdAt": "2020-07-11T01:45:50Z", "commit": {"oid": "be61de27eddf89762857a3b6b5ef997a18e85014"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMVQwMTo0NTo1MVrOGwJexg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMVQwMTo1OTo0MlrOGwJj5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MDE2Ng==", "bodyText": "Think this was missed as part of a different comment - you don't need to synchronize anymore", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453140166", "createdAt": "2020-07-11T01:45:51Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private final ImmutableMap<LatencyBoundary, SpanBucket> latencyBuckets;\n+  private final ImmutableMap<CanonicalCode, SpanBucket> errorBuckets;\n+\n+  TracezSpanBuckets() {\n+    ImmutableMap.Builder<LatencyBoundary, SpanBucket> latencyBucketsBuilder =\n+        ImmutableMap.builder();\n+    for (LatencyBoundary bucket : LatencyBoundary.values()) {\n+      latencyBucketsBuilder.put(bucket, new SpanBucket(/* isLatencyBucket= */ true));\n+    }\n+    latencyBuckets = latencyBucketsBuilder.build();\n+    ImmutableMap.Builder<CanonicalCode, SpanBucket> errorBucketsBuilder = ImmutableMap.builder();\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBucketsBuilder.put(code, new SpanBucket(/* isLatencyBucket= */ false));\n+      }\n+    }\n+    errorBuckets = errorBucketsBuilder.build();\n+  }\n+\n+  void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      latencyBuckets.get(LatencyBoundary.getBoundary(span.getLatencyNanos())).add(span);\n+      return;\n+    }\n+    errorBuckets.get(status.getCanonicalCode()).add(span);\n+  }\n+\n+  Map<LatencyBoundary, Integer> getLatencyBoundaryToCountMap() {\n+    Map<LatencyBoundary, Integer> latencyCounts = new EnumMap<>(LatencyBoundary.class);\n+    for (LatencyBoundary bucket : LatencyBoundary.values()) {\n+      latencyCounts.put(bucket, latencyBuckets.get(bucket).size());\n+    }\n+    return latencyCounts;\n+  }\n+\n+  List<ReadableSpan> getOkSpans() {\n+    List<ReadableSpan> okSpans = new ArrayList<>();\n+    for (SpanBucket latencyBucket : latencyBuckets.values()) {\n+      synchronized (latencyBucket) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be61de27eddf89762857a3b6b5ef997a18e85014"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MDE5MQ==", "bodyText": "Ditto", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453140191", "createdAt": "2020-07-11T01:46:10Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBuckets.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+final class TracezSpanBuckets {\n+  private final ImmutableMap<LatencyBoundary, SpanBucket> latencyBuckets;\n+  private final ImmutableMap<CanonicalCode, SpanBucket> errorBuckets;\n+\n+  TracezSpanBuckets() {\n+    ImmutableMap.Builder<LatencyBoundary, SpanBucket> latencyBucketsBuilder =\n+        ImmutableMap.builder();\n+    for (LatencyBoundary bucket : LatencyBoundary.values()) {\n+      latencyBucketsBuilder.put(bucket, new SpanBucket(/* isLatencyBucket= */ true));\n+    }\n+    latencyBuckets = latencyBucketsBuilder.build();\n+    ImmutableMap.Builder<CanonicalCode, SpanBucket> errorBucketsBuilder = ImmutableMap.builder();\n+    for (CanonicalCode code : CanonicalCode.values()) {\n+      if (!code.toStatus().isOk()) {\n+        errorBucketsBuilder.put(code, new SpanBucket(/* isLatencyBucket= */ false));\n+      }\n+    }\n+    errorBuckets = errorBucketsBuilder.build();\n+  }\n+\n+  void addToBucket(ReadableSpan span) {\n+    Status status = span.toSpanData().getStatus();\n+    if (status.isOk()) {\n+      latencyBuckets.get(LatencyBoundary.getBoundary(span.getLatencyNanos())).add(span);\n+      return;\n+    }\n+    errorBuckets.get(status.getCanonicalCode()).add(span);\n+  }\n+\n+  Map<LatencyBoundary, Integer> getLatencyBoundaryToCountMap() {\n+    Map<LatencyBoundary, Integer> latencyCounts = new EnumMap<>(LatencyBoundary.class);\n+    for (LatencyBoundary bucket : LatencyBoundary.values()) {\n+      latencyCounts.put(bucket, latencyBuckets.get(bucket).size());\n+    }\n+    return latencyCounts;\n+  }\n+\n+  List<ReadableSpan> getOkSpans() {\n+    List<ReadableSpan> okSpans = new ArrayList<>();\n+    for (SpanBucket latencyBucket : latencyBuckets.values()) {\n+      synchronized (latencyBucket) {\n+        latencyBucket.addTo(okSpans);\n+      }\n+    }\n+    return okSpans;\n+  }\n+\n+  List<ReadableSpan> getErrorSpans() {\n+    List<ReadableSpan> errorSpans = new ArrayList<>();\n+    for (SpanBucket errorBucket : errorBuckets.values()) {\n+      synchronized (errorSpans) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be61de27eddf89762857a3b6b5ef997a18e85014"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MDE5OQ==", "bodyText": "Newline", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453140199", "createdAt": "2020-07-11T01:46:20Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/README.md", "diffHunk": "@@ -0,0 +1,9 @@\n+# OpenTelemetry SDK Contrib - zPages\n+\n+[![Javadocs][javadoc-image]][javadoc-url]\n+\n+This module contains code for OpenTelemetry's Java zPages.\n+\n+<!--- TODO: Update javadoc -->\n+[javadoc-image]: https://www.javadoc.io/badge/io.opentelemetry/opentelemetry-sdk-contrib-auto-config.svg\n+[javadoc-url]: https://www.javadoc.io/doc/io.opentelemetry/opentelemetry-sdk-contrib-auto-config", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be61de27eddf89762857a3b6b5ef997a18e85014"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MDI5OQ==", "bodyText": "From what I can tell we don't expose classes from these modules in the API here so they can be implementation instead of api", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453140299", "createdAt": "2020-07-11T01:47:29Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/build.gradle", "diffHunk": "@@ -0,0 +1,19 @@\n+plugins {\n+    id \"java\"\n+    id \"maven-publish\"\n+\n+    id \"ru.vyarus.animalsniffer\"\n+}\n+\n+description = 'OpenTelemetry - zPages'\n+ext.moduleName = \"io.opentelemetry.sdk.extension.zpages\"\n+\n+dependencies {\n+    api project(':opentelemetry-api'),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be61de27eddf89762857a3b6b5ef997a18e85014"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MDQwOQ==", "bodyText": "Collections.emptyList", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453140409", "createdAt": "2020-07-11T01:48:35Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  Set<String> getSpanNames() {\n+    Set<String> spanNames = new TreeSet<>();\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    for (ReadableSpan span : allRunningSpans) {\n+      spanNames.add(span.getName());\n+    }\n+    spanNames.addAll(spanProcessor.getCompletedSpanCache().keySet());\n+    return spanNames;\n+  }\n+\n+  /**\n+   * Returns a Map of the running span counts for {@link TracezDataAggregator}.\n+   *\n+   * @return a Map of span counts for each span name.\n+   */\n+  Map<String, Integer> getRunningSpanCounts() {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    Map<String, Integer> numSpansPerName = new HashMap<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      Integer prevValue = numSpansPerName.get(span.getName());\n+      numSpansPerName.put(span.getName(), prevValue != null ? prevValue + 1 : 1);\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all running spans with a given span name for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link SpanData}.\n+   */\n+  List<SpanData> getRunningSpans(String spanName) {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      if (span.getName().equals(spanName)) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * Returns a Map of span names to counts for all {@link Status#OK} spans in {@link\n+   * TracezDataAggregator}.\n+   *\n+   * @return a Map of span names to counts, where the counts are further indexed by the latency\n+   *     boundaries.\n+   */\n+  Map<String, Map<LatencyBoundary, Integer>> getSpanLatencyCounts() {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Map<String, Map<LatencyBoundary, Integer>> numSpansPerName = new HashMap<>();\n+    for (Entry<String, TracezSpanBuckets> cacheEntry : completedSpanCache.entrySet()) {\n+      numSpansPerName.put(\n+          cacheEntry.getKey(), cacheEntry.getValue().getLatencyBoundaryToCountMap());\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all {@link Status#OK} spans with a given span name between [lowerBound,\n+   * upperBound) for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @param lowerBound latency lower bound (inclusive)\n+   * @param upperBound latency upper bound (exclusive)\n+   * @return a List of {@link SpanData}.\n+   */\n+  List<SpanData> getOkSpans(String spanName, long lowerBound, long upperBound) {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    TracezSpanBuckets buckets = completedSpanCache.get(spanName);\n+    if (buckets == null) {\n+      return new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be61de27eddf89762857a3b6b5ef997a18e85014"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MDUxOQ==", "bodyText": "I don't think this is actually visible for testing it's overriding a protected method so so is protected", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453140519", "createdAt": "2020-07-11T01:49:56Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanProcessor.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import io.opentelemetry.trace.SpanId;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A {@link SpanProcessor} implementation for the traceZ zPage.\n+ *\n+ * <p>Configuration options for {@link TracezSpanProcessor} can be read from system properties,\n+ * environment variables, or {@link java.util.Properties} objects.\n+ *\n+ * <p>For system properties and {@link java.util.Properties} objects, {@link TracezSpanProcessor}\n+ * will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code otel.zpages.export.sampled}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ *\n+ * <p>For environment variables, {@link TracezSpanProcessor} will look for the following names:\n+ *\n+ * <ul>\n+ *   <li>{@code OTEL_ZPAGES_EXPORT_SAMPLED}: sets whether only sampled spans should be exported.\n+ * </ul>\n+ */\n+@ThreadSafe\n+final class TracezSpanProcessor implements SpanProcessor {\n+  private final ConcurrentMap<SpanId, ReadableSpan> runningSpanCache;\n+  private final ConcurrentMap<String, TracezSpanBuckets> completedSpanCache;\n+  private final boolean sampled;\n+\n+  /**\n+   * Constructor for {@link TracezSpanProcessor}.\n+   *\n+   * @param sampled report only sampled spans.\n+   */\n+  TracezSpanProcessor(boolean sampled) {\n+    runningSpanCache = new ConcurrentHashMap<>();\n+    completedSpanCache = new ConcurrentHashMap<>();\n+    this.sampled = sampled;\n+  }\n+\n+  @Override\n+  public void onStart(ReadableSpan span) {\n+    runningSpanCache.put(span.getSpanContext().getSpanId(), span);\n+  }\n+\n+  @Override\n+  public boolean isStartRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void onEnd(ReadableSpan span) {\n+    runningSpanCache.remove(span.getSpanContext().getSpanId());\n+    if (!sampled || span.getSpanContext().getTraceFlags().isSampled()) {\n+      completedSpanCache.putIfAbsent(span.getName(), new TracezSpanBuckets());\n+      completedSpanCache.get(span.getName()).addToBucket(span);\n+    }\n+  }\n+\n+  @Override\n+  public boolean isEndRequired() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    // Do nothing.\n+  }\n+\n+  @Override\n+  public void forceFlush() {\n+    // Do nothing.\n+  }\n+\n+  /**\n+   * Returns a Collection of all running spans for {@link TracezSpanProcessor}.\n+   *\n+   * @return a Collection of {@link ReadableSpan}.\n+   */\n+  Collection<ReadableSpan> getRunningSpans() {\n+    return runningSpanCache.values();\n+  }\n+\n+  /**\n+   * Returns a Collection of all completed spans for {@link TracezSpanProcessor}.\n+   *\n+   * @return a Collection of {@link ReadableSpan}.\n+   */\n+  Collection<ReadableSpan> getCompletedSpans() {\n+    Collection<ReadableSpan> completedSpans = new ArrayList<>();\n+    for (TracezSpanBuckets buckets : completedSpanCache.values()) {\n+      completedSpans.addAll(buckets.getSpans());\n+    }\n+    return completedSpans;\n+  }\n+\n+  /**\n+   * Returns the completed span cache for {@link TracezSpanProcessor}.\n+   *\n+   * @return a Map of String to {@link TracezSpanBuckets}.\n+   */\n+  Map<String, TracezSpanBuckets> getCompletedSpanCache() {\n+    return completedSpanCache;\n+  }\n+\n+  /**\n+   * Returns a new Builder for {@link TracezSpanProcessor}.\n+   *\n+   * @return a new {@link TracezSpanProcessor}.\n+   */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  /** Builder class for {@link TracezSpanProcessor}. */\n+  public static final class Builder extends ConfigBuilder<Builder> {\n+\n+    private static final String KEY_SAMPLED = \"otel.zpages.export.sampled\";\n+    private static final boolean DEFAULT_EXPORT_ONLY_SAMPLED = true;\n+    private boolean sampled = DEFAULT_EXPORT_ONLY_SAMPLED;\n+\n+    private Builder() {}\n+\n+    /**\n+     * Sets the configuration values from the given configuration map for only the available keys.\n+     * This method looks for the following keys:\n+     *\n+     * <ul>\n+     *   <li>{@code otel.zpages.export.sampled}: to set whether only sampled spans should be\n+     *       exported.\n+     * </ul>\n+     *\n+     * @param configMap {@link Map} holding the configuration values.\n+     * @return this.\n+     */\n+    @VisibleForTesting", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be61de27eddf89762857a3b6b5ef997a18e85014"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MDc5NQ==", "bodyText": "Why are these commented?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453140795", "createdAt": "2020-07-11T01:52:23Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezSpanBucketsTest.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.Mock;\n+\n+/** Unit tests for {@link TracezSpanBuckets}. */\n+@RunWith(JUnit4.class)\n+public class TracezSpanBucketsTest {\n+  @Mock private ReadableSpan readableSpan;\n+  @Mock private SpanData spanData;\n+\n+  @Test\n+  public void addToBucket_moreThanTenLatencySamples() {\n+    /*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be61de27eddf89762857a3b6b5ef997a18e85014"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MTE3Nw==", "bodyText": "Don't use mocks for collections. Incidentally noticed this always returns null for any key, are we missing test coverage related to query parameters?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453141177", "createdAt": "2020-07-11T01:56:10Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandlerTest.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.EndSpanOptions;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.util.Map;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for {@link TracezZPageHandler}. */\n+@RunWith(MockitoJUnitRunner.class)\n+public final class TracezZPageHandlerTest {\n+  private static final String FINISHED_SPAN_ONE = \"FinishedSpanOne\";\n+  private static final String FINISHED_SPAN_TWO = \"FinishedSpanTwo\";\n+  private static final String RUNNING_SPAN = \"RunningSpan\";\n+  private static final String LATENCY_SPAN = \"LatencySpan\";\n+  private static final String ERROR_SPAN = \"ErrorSpan\";\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezZPageHandlerTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  @Mock Map<String, String> queryMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be61de27eddf89762857a3b6b5ef997a18e85014"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MTIzOQ==", "bodyText": "Collections.emptyList", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453141239", "createdAt": "2020-07-11T01:56:56Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezDataAggregator.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.trace.Status;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A data aggregator for the traceZ zPage.\n+ *\n+ * <p>The traceZ data aggregator compiles information about the running spans, span latencies, and\n+ * error spans for the frontend of the zPage.\n+ */\n+@ThreadSafe\n+final class TracezDataAggregator {\n+  private final TracezSpanProcessor spanProcessor;\n+\n+  /**\n+   * Constructor for {@link TracezDataAggregator}.\n+   *\n+   * @param spanProcessor collects span data.\n+   */\n+  TracezDataAggregator(TracezSpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  /**\n+   * Returns a Set of running and completed span names for {@link TracezDataAggregator}.\n+   *\n+   * @return a Set of {@link String}.\n+   */\n+  Set<String> getSpanNames() {\n+    Set<String> spanNames = new TreeSet<>();\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    for (ReadableSpan span : allRunningSpans) {\n+      spanNames.add(span.getName());\n+    }\n+    spanNames.addAll(spanProcessor.getCompletedSpanCache().keySet());\n+    return spanNames;\n+  }\n+\n+  /**\n+   * Returns a Map of the running span counts for {@link TracezDataAggregator}.\n+   *\n+   * @return a Map of span counts for each span name.\n+   */\n+  Map<String, Integer> getRunningSpanCounts() {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    Map<String, Integer> numSpansPerName = new HashMap<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      Integer prevValue = numSpansPerName.get(span.getName());\n+      numSpansPerName.put(span.getName(), prevValue != null ? prevValue + 1 : 1);\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all running spans with a given span name for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link SpanData}.\n+   */\n+  List<SpanData> getRunningSpans(String spanName) {\n+    Collection<ReadableSpan> allRunningSpans = spanProcessor.getRunningSpans();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allRunningSpans) {\n+      if (span.getName().equals(spanName)) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * Returns a Map of span names to counts for all {@link Status#OK} spans in {@link\n+   * TracezDataAggregator}.\n+   *\n+   * @return a Map of span names to counts, where the counts are further indexed by the latency\n+   *     boundaries.\n+   */\n+  Map<String, Map<LatencyBoundary, Integer>> getSpanLatencyCounts() {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Map<String, Map<LatencyBoundary, Integer>> numSpansPerName = new HashMap<>();\n+    for (Entry<String, TracezSpanBuckets> cacheEntry : completedSpanCache.entrySet()) {\n+      numSpansPerName.put(\n+          cacheEntry.getKey(), cacheEntry.getValue().getLatencyBoundaryToCountMap());\n+    }\n+    return numSpansPerName;\n+  }\n+\n+  /**\n+   * Returns a List of all {@link Status#OK} spans with a given span name between [lowerBound,\n+   * upperBound) for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @param lowerBound latency lower bound (inclusive)\n+   * @param upperBound latency upper bound (exclusive)\n+   * @return a List of {@link SpanData}.\n+   */\n+  List<SpanData> getOkSpans(String spanName, long lowerBound, long upperBound) {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    TracezSpanBuckets buckets = completedSpanCache.get(spanName);\n+    if (buckets == null) {\n+      return new ArrayList<>();\n+    }\n+    Collection<ReadableSpan> allOkSpans = buckets.getOkSpans();\n+    List<SpanData> filteredSpans = new ArrayList<>();\n+    for (ReadableSpan span : allOkSpans) {\n+      if (span.getLatencyNanos() >= lowerBound && span.getLatencyNanos() < upperBound) {\n+        filteredSpans.add(span.toSpanData());\n+      }\n+    }\n+    return filteredSpans;\n+  }\n+\n+  /**\n+   * Returns a Map of error span counts for {@link TracezDataAggregator}.\n+   *\n+   * @return a Map of error span counts for each span name.\n+   */\n+  Map<String, Integer> getErrorSpanCounts() {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    Map<String, Integer> numErrorsPerName = new HashMap<>();\n+    for (Entry<String, TracezSpanBuckets> cacheEntry : completedSpanCache.entrySet()) {\n+      numErrorsPerName.put(cacheEntry.getKey(), cacheEntry.getValue().getErrorSpans().size());\n+    }\n+    return numErrorsPerName;\n+  }\n+\n+  /**\n+   * Returns a List of error spans with a given span name for {@link TracezDataAggregator}.\n+   *\n+   * @param spanName name to filter returned spans.\n+   * @return a List of {@link SpanData}.\n+   */\n+  List<SpanData> getErrorSpans(String spanName) {\n+    Map<String, TracezSpanBuckets> completedSpanCache = spanProcessor.getCompletedSpanCache();\n+    TracezSpanBuckets buckets = completedSpanCache.get(spanName);\n+    if (buckets == null) {\n+      return new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be61de27eddf89762857a3b6b5ef997a18e85014"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE0MTQ3OA==", "bodyText": "Remove", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453141478", "createdAt": "2020-07-11T01:59:42Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageLogo.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.io.BaseEncoding;\n+import com.google.common.io.ByteStreams;\n+import java.io.InputStream;\n+import java.util.logging.Logger;\n+\n+final class ZPageLogo {\n+  private ZPageLogo() {}\n+\n+  /**\n+   * Get OpenTelemetry logo in base64 encoding.\n+   *\n+   * @return OpenTelemetry logo in base64 encoding.\n+   */\n+  public static String getLogoBase64() {\n+    try {\n+      InputStream in = ZPageLogo.class.getClassLoader().getResourceAsStream(\"logo.png\");\n+      byte[] bytes = ByteStreams.toByteArray(in);\n+      return BaseEncoding.base64().encode(bytes);\n+    } catch (Throwable t) {\n+      Logger.getLogger(ZPageLogo.class.getName())\n+          .warning(\"Error while getting OpenTelemetry Logo: \" + t.toString());\n+      t.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be61de27eddf89762857a3b6b5ef997a18e85014"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2ODAwNTMz", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-446800533", "createdAt": "2020-07-11T12:46:20Z", "commit": {"oid": "be61de27eddf89762857a3b6b5ef997a18e85014"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMVQxMjo0NjoyMVrOGwMoZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMVQxMjo0NjoyMVrOGwMoZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE5MTc4MQ==", "bodyText": "Sorry realized this should be AtomicReferenceArray\nhttps://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReferenceArray.html\nShould just replace the array accesses with .set / .get", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453191781", "createdAt": "2020-07-11T12:46:21Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/SpanBucket.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.primitives.UnsignedInts;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+final class SpanBucket {\n+  // A power of 2 means Integer.MAX_VALUE % bucketSize = bucketSize - 1, so the index will always\n+  // loop back to 0.\n+  private static final int LATENCY_BUCKET_SIZE = 16;\n+  private static final int ERROR_BUCKET_SIZE = 8;\n+\n+  private final ReadableSpan[] spans;\n+  private final AtomicInteger index;\n+  private final int bucketSize;\n+\n+  SpanBucket(boolean isLatencyBucket) {\n+    bucketSize = isLatencyBucket ? LATENCY_BUCKET_SIZE : ERROR_BUCKET_SIZE;\n+    spans = new ReadableSpan[bucketSize];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be61de27eddf89762857a3b6b5ef997a18e85014"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2495cf9e375d75a2103c41a8eafeefac7c075930", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/2495cf9e375d75a2103c41a8eafeefac7c075930", "committedDate": "2020-07-13T14:35:12Z", "message": "Removed printStackTrace, added test for query parameter"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MzMzMTcy", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-447333172", "createdAt": "2020-07-13T14:59:51Z", "commit": {"oid": "2495cf9e375d75a2103c41a8eafeefac7c075930"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDo1OTo1MVrOGwse6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDo1OTo1MVrOGwse6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxMzY0MA==", "bodyText": "Generally, the idiomatic way to access a logger is to make the Logger a static field of this class.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453713640", "createdAt": "2020-07-13T14:59:51Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageLogo.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.io.BaseEncoding;\n+import com.google.common.io.ByteStreams;\n+import java.io.InputStream;\n+import java.util.logging.Logger;\n+\n+final class ZPageLogo {\n+  private ZPageLogo() {}\n+\n+  /**\n+   * Get OpenTelemetry logo in base64 encoding.\n+   *\n+   * @return OpenTelemetry logo in base64 encoding.\n+   */\n+  public static String getLogoBase64() {\n+    try {\n+      InputStream in = ZPageLogo.class.getClassLoader().getResourceAsStream(\"logo.png\");\n+      byte[] bytes = ByteStreams.toByteArray(in);\n+      return BaseEncoding.base64().encode(bytes);\n+    } catch (Throwable t) {\n+      Logger.getLogger(ZPageLogo.class.getName())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2495cf9e375d75a2103c41a8eafeefac7c075930"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MzMzOTkw", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-447333990", "createdAt": "2020-07-13T15:00:45Z", "commit": {"oid": "2495cf9e375d75a2103c41a8eafeefac7c075930"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTowMDo0NVrOGwshnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTowMDo0NVrOGwshnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxNDMzMg==", "bodyText": "rather than logging the toString, it's more useful to log the entire exception. there is an overload that let's you pass in the exception itself, and let the logging framework/formatter deal with how to display it.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453714332", "createdAt": "2020-07-13T15:00:45Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageLogo.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.io.BaseEncoding;\n+import com.google.common.io.ByteStreams;\n+import java.io.InputStream;\n+import java.util.logging.Logger;\n+\n+final class ZPageLogo {\n+  private ZPageLogo() {}\n+\n+  /**\n+   * Get OpenTelemetry logo in base64 encoding.\n+   *\n+   * @return OpenTelemetry logo in base64 encoding.\n+   */\n+  public static String getLogoBase64() {\n+    try {\n+      InputStream in = ZPageLogo.class.getClassLoader().getResourceAsStream(\"logo.png\");\n+      byte[] bytes = ByteStreams.toByteArray(in);\n+      return BaseEncoding.base64().encode(bytes);\n+    } catch (Throwable t) {\n+      Logger.getLogger(ZPageLogo.class.getName())\n+          .warning(\"Error while getting OpenTelemetry Logo: \" + t.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2495cf9e375d75a2103c41a8eafeefac7c075930"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MzM0NTAx", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-447334501", "createdAt": "2020-07-13T15:01:18Z", "commit": {"oid": "2495cf9e375d75a2103c41a8eafeefac7c075930"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTowMToxOFrOGwsjRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTowMToxOFrOGwsjRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxNDc1OA==", "bodyText": "What will the caller end up doing with an empty string? Will it just cause another excpetion higher up the stack?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453714758", "createdAt": "2020-07-13T15:01:18Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageLogo.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.io.BaseEncoding;\n+import com.google.common.io.ByteStreams;\n+import java.io.InputStream;\n+import java.util.logging.Logger;\n+\n+final class ZPageLogo {\n+  private ZPageLogo() {}\n+\n+  /**\n+   * Get OpenTelemetry logo in base64 encoding.\n+   *\n+   * @return OpenTelemetry logo in base64 encoding.\n+   */\n+  public static String getLogoBase64() {\n+    try {\n+      InputStream in = ZPageLogo.class.getClassLoader().getResourceAsStream(\"logo.png\");\n+      byte[] bytes = ByteStreams.toByteArray(in);\n+      return BaseEncoding.base64().encode(bytes);\n+    } catch (Throwable t) {\n+      Logger.getLogger(ZPageLogo.class.getName())\n+          .warning(\"Error while getting OpenTelemetry Logo: \" + t.toString());\n+      return \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2495cf9e375d75a2103c41a8eafeefac7c075930"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MzM1MTI3", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-447335127", "createdAt": "2020-07-13T15:01:59Z", "commit": {"oid": "2495cf9e375d75a2103c41a8eafeefac7c075930"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTowMTo1OVrOGwslOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTowMTo1OVrOGwslOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxNTI1Nw==", "bodyText": "all the same comments apply down here, of course.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r453715257", "createdAt": "2020-07-13T15:01:59Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/ZPageLogo.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.io.BaseEncoding;\n+import com.google.common.io.ByteStreams;\n+import java.io.InputStream;\n+import java.util.logging.Logger;\n+\n+final class ZPageLogo {\n+  private ZPageLogo() {}\n+\n+  /**\n+   * Get OpenTelemetry logo in base64 encoding.\n+   *\n+   * @return OpenTelemetry logo in base64 encoding.\n+   */\n+  public static String getLogoBase64() {\n+    try {\n+      InputStream in = ZPageLogo.class.getClassLoader().getResourceAsStream(\"logo.png\");\n+      byte[] bytes = ByteStreams.toByteArray(in);\n+      return BaseEncoding.base64().encode(bytes);\n+    } catch (Throwable t) {\n+      Logger.getLogger(ZPageLogo.class.getName())\n+          .warning(\"Error while getting OpenTelemetry Logo: \" + t.toString());\n+      return \"\";\n+    }\n+  }\n+\n+  /**\n+   * Get OpenTelemetry favicon in base64 encoding.\n+   *\n+   * @return OpenTelemetry favicon in base64 encoding.\n+   */\n+  public static String getFaviconBase64() {\n+    try {\n+\n+      InputStream in = ZPageLogo.class.getClassLoader().getResourceAsStream(\"favicon.png\");\n+      byte[] bytes = ByteStreams.toByteArray(in);\n+      return BaseEncoding.base64().encode(bytes);\n+    } catch (Throwable t) {\n+      Logger.getLogger(ZPageLogo.class.getName())\n+          .warning(\"Error while getting OpenTelemetry Logo: \" + t.toString());\n+      return \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2495cf9e375d75a2103c41a8eafeefac7c075930"}, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "648a8b4e162f0f0cd0278bb75d496b68d2d119b7", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/648a8b4e162f0f0cd0278bb75d496b68d2d119b7", "committedDate": "2020-07-13T15:16:27Z", "message": "Changed logger to static field, used log method to log detailed stackTrace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6113ea096e3eeff312e83ed53a2c68428230fe7", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/d6113ea096e3eeff312e83ed53a2c68428230fe7", "committedDate": "2020-07-13T18:54:38Z", "message": "Made minor fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23e17281b03d570809a69e8f9c3ef01180c325e1", "author": {"user": {"login": "williamhu99", "name": "William Hu"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/23e17281b03d570809a69e8f9c3ef01180c325e1", "committedDate": "2020-07-13T21:02:12Z", "message": "Resolved unmodifiable list error with getOkSpans and getErrorSpans"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NjkwNjk5", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-447690699", "createdAt": "2020-07-13T23:51:36Z", "commit": {"oid": "23e17281b03d570809a69e8f9c3ef01180c325e1"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMzo1MTozNlrOGw-1AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMzo1MjoyNFrOGw-1wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxNDIwOQ==", "bodyText": "In general, you should think of mockito as a hack, a very important hack, but still one that uses bytecode manipulation to circumvent normal Java for testing (now adays it can even mock out final classes, wow). For normal containers even in tests it's best to avoid that (can just pass ImmutableMap.of() without much loss in expressiveness).\nDon't forget that this now ties down the implementation - .isEmpty returns false for this map even though you're trying to test the empty map case, so it's not correct and we're just sort of lucky the test passes.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r454014209", "createdAt": "2020-07-13T23:51:36Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandlerTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.EndSpanOptions;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for {@link TracezZPageHandler}. */\n+@RunWith(MockitoJUnitRunner.class)\n+public final class TracezZPageHandlerTest {\n+  private static final String FINISHED_SPAN_ONE = \"FinishedSpanOne\";\n+  private static final String FINISHED_SPAN_TWO = \"FinishedSpanTwo\";\n+  private static final String RUNNING_SPAN = \"RunningSpan\";\n+  private static final String LATENCY_SPAN = \"LatencySpan\";\n+  private static final String ERROR_SPAN = \"ErrorSpan\";\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezZPageHandlerTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  @Mock Map<String, String> queryMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23e17281b03d570809a69e8f9c3ef01180c325e1"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAxNDQwMg==", "bodyText": "I saw a third .get on subsampletype or something but see only two query parameters in this test so guessing we're missing one more test case.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r454014402", "createdAt": "2020-07-13T23:52:24Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandlerTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import io.opentelemetry.sdk.internal.TestClock;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+import io.opentelemetry.trace.EndSpanOptions;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Status.CanonicalCode;\n+import io.opentelemetry.trace.Tracer;\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for {@link TracezZPageHandler}. */\n+@RunWith(MockitoJUnitRunner.class)\n+public final class TracezZPageHandlerTest {\n+  private static final String FINISHED_SPAN_ONE = \"FinishedSpanOne\";\n+  private static final String FINISHED_SPAN_TWO = \"FinishedSpanTwo\";\n+  private static final String RUNNING_SPAN = \"RunningSpan\";\n+  private static final String LATENCY_SPAN = \"LatencySpan\";\n+  private static final String ERROR_SPAN = \"ErrorSpan\";\n+  private final TestClock testClock = TestClock.create();\n+  private final TracerSdkProvider tracerSdkProvider =\n+      TracerSdkProvider.builder().setClock(testClock).build();\n+  private final Tracer tracer = tracerSdkProvider.get(\"TracezZPageHandlerTest\");\n+  private final TracezSpanProcessor spanProcessor = TracezSpanProcessor.newBuilder().build();\n+  private final TracezDataAggregator dataAggregator = new TracezDataAggregator(spanProcessor);\n+  @Mock Map<String, String> queryMap;\n+\n+  @Rule public MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  @Before\n+  public void setup() {\n+    tracerSdkProvider.addSpanProcessor(spanProcessor);\n+  }\n+\n+  @Test\n+  public void summaryTable_emitRowForEachSpan() {\n+    OutputStream output = new ByteArrayOutputStream();\n+    Span finishedSpan1 = tracer.spanBuilder(FINISHED_SPAN_ONE).startSpan();\n+    Span finishedSpan2 = tracer.spanBuilder(FINISHED_SPAN_TWO).startSpan();\n+    finishedSpan1.end();\n+    finishedSpan2.end();\n+\n+    Span runningSpan = tracer.spanBuilder(RUNNING_SPAN).startSpan();\n+\n+    Span latencySpan = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions = EndSpanOptions.builder().setEndTimestamp(10002L).build();\n+    latencySpan.end(endOptions);\n+\n+    Span errorSpan = tracer.spanBuilder(ERROR_SPAN).startSpan();\n+    errorSpan.setStatus(CanonicalCode.INVALID_ARGUMENT.toStatus());\n+    errorSpan.end();\n+\n+    TracezZPageHandler tracezZPageHandler = new TracezZPageHandler(dataAggregator);\n+    tracezZPageHandler.emitHtml(queryMap, output);\n+\n+    // Emit a row for all types of spans\n+    assertThat(output.toString()).contains(FINISHED_SPAN_ONE);\n+    assertThat(output.toString()).contains(FINISHED_SPAN_TWO);\n+    assertThat(output.toString()).contains(RUNNING_SPAN);\n+    assertThat(output.toString()).contains(LATENCY_SPAN);\n+    assertThat(output.toString()).contains(ERROR_SPAN);\n+\n+    runningSpan.end();\n+  }\n+\n+  @Test\n+  public void summaryTable_linkForRunningSpans() {\n+    OutputStream output = new ByteArrayOutputStream();\n+    Span runningSpan1 = tracer.spanBuilder(RUNNING_SPAN).startSpan();\n+    Span runningSpan2 = tracer.spanBuilder(RUNNING_SPAN).startSpan();\n+    Span runningSpan3 = tracer.spanBuilder(RUNNING_SPAN).startSpan();\n+    Span finishedSpan = tracer.spanBuilder(FINISHED_SPAN_ONE).startSpan();\n+    finishedSpan.end();\n+\n+    TracezZPageHandler tracezZPageHandler = new TracezZPageHandler(dataAggregator);\n+    tracezZPageHandler.emitHtml(queryMap, output);\n+\n+    // Link for running span with 3 running\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + RUNNING_SPAN + \"&ztype=0&zsubtype=0\\\">3\");\n+    // No link for finished spans\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + FINISHED_SPAN_ONE + \"&ztype=0&subtype=0\\\"\");\n+\n+    runningSpan1.end();\n+    runningSpan2.end();\n+    runningSpan3.end();\n+  }\n+\n+  @Test\n+  public void summaryTable_linkForLatencyBasedSpans_NoneForEmptyBoundary() {\n+    OutputStream output = new ByteArrayOutputStream();\n+    TracezZPageHandler tracezZPageHandler = new TracezZPageHandler(dataAggregator);\n+    tracezZPageHandler.emitHtml(queryMap, output);\n+\n+    // No link for boundary 0\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=0\\\"\");\n+    // No link for boundary 1\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=1\\\"\");\n+    // No link for boundary 2\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=2\\\"\");\n+    // No link for boundary 3\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=3\\\"\");\n+    // No link for boundary 4\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=4\\\"\");\n+    // No link for boundary 5\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=5\\\"\");\n+    // No link for boundary 6\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=6\\\"\");\n+    // No link for boundary 7\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=7\\\"\");\n+    // No link for boundary 8\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=8\\\"\");\n+  }\n+\n+  @Test\n+  public void summaryTable_linkForLatencyBasedSpans_OnePerBoundary() {\n+    OutputStream output = new ByteArrayOutputStream();\n+    // Boundary 0, >1us\n+    Span latencySpanSubtype0 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions0 = EndSpanOptions.builder().setEndTimestamp(1002L).build();\n+    latencySpanSubtype0.end(endOptions0);\n+    // Boundary 1, >10us\n+    Span latencySpanSubtype1 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions1 = EndSpanOptions.builder().setEndTimestamp(10002L).build();\n+    latencySpanSubtype1.end(endOptions1);\n+    // Boundary 2, >100us\n+    Span latencySpanSubtype2 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions2 = EndSpanOptions.builder().setEndTimestamp(100002L).build();\n+    latencySpanSubtype2.end(endOptions2);\n+    // Boundary 3, >1ms\n+    Span latencySpanSubtype3 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions3 = EndSpanOptions.builder().setEndTimestamp(1000002L).build();\n+    latencySpanSubtype3.end(endOptions3);\n+    // Boundary 4, >10ms\n+    Span latencySpanSubtype4 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions4 = EndSpanOptions.builder().setEndTimestamp(10000002L).build();\n+    latencySpanSubtype4.end(endOptions4);\n+    // Boundary 5, >100ms\n+    Span latencySpanSubtype5 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions5 = EndSpanOptions.builder().setEndTimestamp(100000002L).build();\n+    latencySpanSubtype5.end(endOptions5);\n+    // Boundary 6, >1s\n+    Span latencySpanSubtype6 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions6 = EndSpanOptions.builder().setEndTimestamp(1000000002L).build();\n+    latencySpanSubtype6.end(endOptions6);\n+    // Boundary 7, >10s\n+    Span latencySpanSubtype7 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions7 = EndSpanOptions.builder().setEndTimestamp(10000000002L).build();\n+    latencySpanSubtype7.end(endOptions7);\n+    // Boundary 8, >100s\n+    Span latencySpanSubtype8 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions8 = EndSpanOptions.builder().setEndTimestamp(100000000002L).build();\n+    latencySpanSubtype8.end(endOptions8);\n+\n+    TracezZPageHandler tracezZPageHandler = new TracezZPageHandler(dataAggregator);\n+    tracezZPageHandler.emitHtml(queryMap, output);\n+\n+    // Link for boundary 0\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=0\\\">1\");\n+    // Link for boundary 1\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=1\\\">1\");\n+    // Link for boundary 2\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=2\\\">1\");\n+    // Link for boundary 3\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=3\\\">1\");\n+    // Link for boundary 4\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=4\\\">1\");\n+    // Link for boundary 5\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=5\\\">1\");\n+    // Link for boundary 6\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=6\\\">1\");\n+    // Link for boundary 7\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=7\\\">1\");\n+    // Link for boundary 8\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=8\\\">1\");\n+  }\n+\n+  @Test\n+  public void summaryTable_linkForLatencyBasedSpans_MultipleForOneBoundary() {\n+    OutputStream output = new ByteArrayOutputStream();\n+    // 4 samples in boundary 5, >100ms\n+    Span latencySpan100ms1 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions1 = EndSpanOptions.builder().setEndTimestamp(112931232L).build();\n+    latencySpan100ms1.end(endOptions1);\n+    Span latencySpan100ms2 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions2 = EndSpanOptions.builder().setEndTimestamp(138694322L).build();\n+    latencySpan100ms2.end(endOptions2);\n+    Span latencySpan100ms3 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions3 = EndSpanOptions.builder().setEndTimestamp(154486482L).build();\n+    latencySpan100ms3.end(endOptions3);\n+    Span latencySpan100ms4 = tracer.spanBuilder(LATENCY_SPAN).setStartTimestamp(1L).startSpan();\n+    EndSpanOptions endOptions4 = EndSpanOptions.builder().setEndTimestamp(194892582L).build();\n+    latencySpan100ms4.end(endOptions4);\n+\n+    TracezZPageHandler tracezZPageHandler = new TracezZPageHandler(dataAggregator);\n+    tracezZPageHandler.emitHtml(queryMap, output);\n+\n+    // Link for boundary 5 with 4 samples\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + LATENCY_SPAN + \"&ztype=1&zsubtype=5\\\">4\");\n+  }\n+\n+  @Test\n+  public void summaryTable_linkForErrorSpans() {\n+    OutputStream output = new ByteArrayOutputStream();\n+    Span errorSpan1 = tracer.spanBuilder(ERROR_SPAN).startSpan();\n+    Span errorSpan2 = tracer.spanBuilder(ERROR_SPAN).startSpan();\n+    Span errorSpan3 = tracer.spanBuilder(ERROR_SPAN).startSpan();\n+    Span finishedSpan = tracer.spanBuilder(FINISHED_SPAN_ONE).startSpan();\n+    errorSpan1.setStatus(CanonicalCode.CANCELLED.toStatus());\n+    errorSpan2.setStatus(CanonicalCode.ABORTED.toStatus());\n+    errorSpan3.setStatus(CanonicalCode.DEADLINE_EXCEEDED.toStatus());\n+    errorSpan1.end();\n+    errorSpan2.end();\n+    errorSpan3.end();\n+    finishedSpan.end();\n+\n+    TracezZPageHandler tracezZPageHandler = new TracezZPageHandler(dataAggregator);\n+    tracezZPageHandler.emitHtml(queryMap, output);\n+\n+    // Link for error based spans with 3 samples\n+    assertThat(output.toString())\n+        .contains(\"href=\\\"?zspanname=\" + ERROR_SPAN + \"&ztype=2&zsubtype=0\\\">3\");\n+    // No link for Status{#OK} spans\n+    assertThat(output.toString())\n+        .doesNotContain(\"href=\\\"?zspanname=\" + FINISHED_SPAN_ONE + \"&ztype=2&subtype=0\\\"\");\n+  }\n+\n+  @Test\n+  public void spanDetails_emitSpanNameCorrectly() {\n+    OutputStream output = new ByteArrayOutputStream();\n+    Map<String, String> queryMapWithSpanName = new HashMap<String, String>();\n+    queryMapWithSpanName.put(\"zspanname\", FINISHED_SPAN_ONE);\n+    queryMapWithSpanName.put(\"ztype\", \"1\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23e17281b03d570809a69e8f9c3ef01180c325e1"}, "originalPosition": 281}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4MDY0NjEz", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-448064613", "createdAt": "2020-07-14T12:36:36Z", "commit": {"oid": "23e17281b03d570809a69e8f9c3ef01180c325e1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "317876f331e4ba8e870f05d8b24b0d3b0304f86a", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/317876f331e4ba8e870f05d8b24b0d3b0304f86a", "committedDate": "2020-07-14T20:32:37Z", "message": "Changed map @Mock to empty map, added more test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "842629c3e3f13e3aac897fa24841ea9d6df3fc84", "author": {"user": {"login": "wtyanan", "name": "Terry (Tianyu) Wang"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/842629c3e3f13e3aac897fa24841ea9d6df3fc84", "committedDate": "2020-07-15T01:27:18Z", "message": "Changed test runner"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4NTgzOTI2", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-448583926", "createdAt": "2020-07-15T02:17:52Z", "commit": {"oid": "842629c3e3f13e3aac897fa24841ea9d6df3fc84"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MDgxNjM0", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-449081634", "createdAt": "2020-07-15T15:39:46Z", "commit": {"oid": "842629c3e3f13e3aac897fa24841ea9d6df3fc84"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNTozOTo0N1rOGyEDvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNTozOTo0N1rOGyEDvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE0ODQ3Nw==", "bodyText": "I'd love to have unit tests on this class specifically, but that can be in a follow-up PR.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#discussion_r455148477", "createdAt": "2020-07-15T15:39:47Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/SpanBucket.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.zpages;\n+\n+import com.google.common.primitives.UnsignedInts;\n+import io.opentelemetry.sdk.trace.ReadableSpan;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReferenceArray;\n+\n+final class SpanBucket {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "842629c3e3f13e3aac897fa24841ea9d6df3fc84"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MDg5MjM3", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1380#pullrequestreview-449089237", "createdAt": "2020-07-15T15:49:36Z", "commit": {"oid": "842629c3e3f13e3aac897fa24841ea9d6df3fc84"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2516, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}