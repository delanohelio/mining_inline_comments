{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ0NDg0NTYy", "number": 2395, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QyMDo0Mzo0MlrOFIu_ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QyMDo1NjoyMlrOFIvVZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NzAyODQzOnYy", "diffSide": "RIGHT", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/aggregation/AggregationFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QyMDo0Mzo0MlrOIK0xPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQxNTo1NjoxNFrOILKemQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODIyMTI0NA==", "bodyText": "This comment is no longer correct.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2395#discussion_r548221244", "createdAt": "2020-12-23T20:43:42Z", "author": {"login": "jkwatson"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/aggregation/AggregationFactory.java", "diffHunk": "@@ -5,11 +5,11 @@\n \n package io.opentelemetry.sdk.metrics.aggregation;\n \n-import io.opentelemetry.sdk.metrics.aggregator.Aggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.AggregatorHandle;\n import io.opentelemetry.sdk.metrics.common.InstrumentValueType;\n import javax.annotation.concurrent.Immutable;\n \n-/** Factory class for {@link Aggregator}. */\n+/** Factory class for {@link AggregatorHandle}. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "551b47f25fc01caf4dd7588b74da0c47310f63af"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODU3NjkyMQ==", "bodyText": "Updated.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2395#discussion_r548576921", "createdAt": "2020-12-24T15:56:14Z", "author": {"login": "bogdandrutu"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/aggregation/AggregationFactory.java", "diffHunk": "@@ -5,11 +5,11 @@\n \n package io.opentelemetry.sdk.metrics.aggregation;\n \n-import io.opentelemetry.sdk.metrics.aggregator.Aggregator;\n+import io.opentelemetry.sdk.metrics.aggregator.AggregatorHandle;\n import io.opentelemetry.sdk.metrics.common.InstrumentValueType;\n import javax.annotation.concurrent.Immutable;\n \n-/** Factory class for {@link Aggregator}. */\n+/** Factory class for {@link AggregatorHandle}. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODIyMTI0NA=="}, "originalCommit": {"oid": "551b47f25fc01caf4dd7588b74da0c47310f63af"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NzA4NDU1OnYy", "diffSide": "RIGHT", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/aggregator/DoubleMinMaxSumCountAggregator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QyMDo1NjoyMlrOIK1VYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQxNTo0MzowMlrOILJ6LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODIzMDQ5Nw==", "bodyText": "If we're ok with not testing the exact type returned by the createHandle method, we could make these handle implementations private.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2395#discussion_r548230497", "createdAt": "2020-12-23T20:56:22Z", "author": {"login": "jkwatson"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/aggregator/DoubleMinMaxSumCountAggregator.java", "diffHunk": "@@ -11,77 +11,85 @@\n import javax.annotation.concurrent.ThreadSafe;\n \n @ThreadSafe\n-public final class DoubleMinMaxSumCountAggregator extends Aggregator<MinMaxSumCountAccumulation> {\n-  private static final AggregatorFactory<MinMaxSumCountAccumulation> AGGREGATOR_FACTORY =\n-      new AggregatorFactory<MinMaxSumCountAccumulation>() {\n-        @Override\n-        public Aggregator<MinMaxSumCountAccumulation> getAggregator() {\n-          return new DoubleMinMaxSumCountAggregator();\n-        }\n+public final class DoubleMinMaxSumCountAggregator\n+    implements Aggregator<MinMaxSumCountAccumulation> {\n+  private static final DoubleMinMaxSumCountAggregator INSTANCE =\n+      new DoubleMinMaxSumCountAggregator();\n \n-        @Override\n-        public MinMaxSumCountAccumulation accumulateDouble(double value) {\n-          return MinMaxSumCountAccumulation.create(1, value, value, value);\n-        }\n-      };\n-\n-  private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n-  // The current value. This controls its own internal thread-safety via method access. Don't\n-  // try to use its fields directly.\n-  @GuardedBy(\"lock\")\n-  private final DoubleState current = new DoubleState();\n-\n-  public static AggregatorFactory<MinMaxSumCountAccumulation> getFactory() {\n-    return AGGREGATOR_FACTORY;\n+  /**\n+   * Returns the instance of this {@link Aggregator}.\n+   *\n+   * @return the instance of this {@link Aggregator}.\n+   */\n+  public static Aggregator<MinMaxSumCountAccumulation> getInstance() {\n+    return INSTANCE;\n   }\n \n   private DoubleMinMaxSumCountAggregator() {}\n \n   @Override\n-  protected MinMaxSumCountAccumulation doAccumulateThenReset() {\n-    lock.writeLock().lock();\n-    try {\n-      MinMaxSumCountAccumulation toReturn =\n-          MinMaxSumCountAccumulation.create(current.count, current.sum, current.min, current.max);\n-      current.reset();\n-      return toReturn;\n-    } finally {\n-      lock.writeLock().unlock();\n-    }\n+  public AggregatorHandle<MinMaxSumCountAccumulation> createHandle() {\n+    return new Handle();\n   }\n \n   @Override\n-  protected void doRecordDouble(double value) {\n-    lock.writeLock().lock();\n-    try {\n-      current.record(value);\n-    } finally {\n-      lock.writeLock().unlock();\n-    }\n+  public MinMaxSumCountAccumulation accumulateDouble(double value) {\n+    return MinMaxSumCountAccumulation.create(1, value, value, value);\n   }\n \n-  private static final class DoubleState {\n-    private long count;\n-    private double sum;\n-    private double min;\n-    private double max;\n+  static final class Handle extends AggregatorHandle<MinMaxSumCountAccumulation> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "551b47f25fc01caf4dd7588b74da0c47310f63af"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODU2NzU5Ng==", "bodyText": "I had them initially private, then when I had to fix the tests I did this. We should follow up on this, for the moment I am keeping this way to not remove tests.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2395#discussion_r548567596", "createdAt": "2020-12-24T15:43:02Z", "author": {"login": "bogdandrutu"}, "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/aggregator/DoubleMinMaxSumCountAggregator.java", "diffHunk": "@@ -11,77 +11,85 @@\n import javax.annotation.concurrent.ThreadSafe;\n \n @ThreadSafe\n-public final class DoubleMinMaxSumCountAggregator extends Aggregator<MinMaxSumCountAccumulation> {\n-  private static final AggregatorFactory<MinMaxSumCountAccumulation> AGGREGATOR_FACTORY =\n-      new AggregatorFactory<MinMaxSumCountAccumulation>() {\n-        @Override\n-        public Aggregator<MinMaxSumCountAccumulation> getAggregator() {\n-          return new DoubleMinMaxSumCountAggregator();\n-        }\n+public final class DoubleMinMaxSumCountAggregator\n+    implements Aggregator<MinMaxSumCountAccumulation> {\n+  private static final DoubleMinMaxSumCountAggregator INSTANCE =\n+      new DoubleMinMaxSumCountAggregator();\n \n-        @Override\n-        public MinMaxSumCountAccumulation accumulateDouble(double value) {\n-          return MinMaxSumCountAccumulation.create(1, value, value, value);\n-        }\n-      };\n-\n-  private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n-  // The current value. This controls its own internal thread-safety via method access. Don't\n-  // try to use its fields directly.\n-  @GuardedBy(\"lock\")\n-  private final DoubleState current = new DoubleState();\n-\n-  public static AggregatorFactory<MinMaxSumCountAccumulation> getFactory() {\n-    return AGGREGATOR_FACTORY;\n+  /**\n+   * Returns the instance of this {@link Aggregator}.\n+   *\n+   * @return the instance of this {@link Aggregator}.\n+   */\n+  public static Aggregator<MinMaxSumCountAccumulation> getInstance() {\n+    return INSTANCE;\n   }\n \n   private DoubleMinMaxSumCountAggregator() {}\n \n   @Override\n-  protected MinMaxSumCountAccumulation doAccumulateThenReset() {\n-    lock.writeLock().lock();\n-    try {\n-      MinMaxSumCountAccumulation toReturn =\n-          MinMaxSumCountAccumulation.create(current.count, current.sum, current.min, current.max);\n-      current.reset();\n-      return toReturn;\n-    } finally {\n-      lock.writeLock().unlock();\n-    }\n+  public AggregatorHandle<MinMaxSumCountAccumulation> createHandle() {\n+    return new Handle();\n   }\n \n   @Override\n-  protected void doRecordDouble(double value) {\n-    lock.writeLock().lock();\n-    try {\n-      current.record(value);\n-    } finally {\n-      lock.writeLock().unlock();\n-    }\n+  public MinMaxSumCountAccumulation accumulateDouble(double value) {\n+    return MinMaxSumCountAccumulation.create(1, value, value, value);\n   }\n \n-  private static final class DoubleState {\n-    private long count;\n-    private double sum;\n-    private double min;\n-    private double max;\n+  static final class Handle extends AggregatorHandle<MinMaxSumCountAccumulation> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODIzMDQ5Nw=="}, "originalCommit": {"oid": "551b47f25fc01caf4dd7588b74da0c47310f63af"}, "originalPosition": 73}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1628, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}