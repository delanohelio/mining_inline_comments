{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2MjQ4MjUy", "number": 1301, "title": "Add AWS X-Ray propagator", "bodyText": "Adds support for AWS X-Ray trace header propagation and tests.", "createdAt": "2020-06-01T22:31:10Z", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301", "merged": true, "mergeCommit": {"oid": "61167434bd8069918cff0386cd5dcd7c4812eb1b"}, "closed": true, "closedAt": "2020-06-10T22:27:30Z", "author": {"login": "shengxil"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnK6_ogFqTQyMjI3NDQzMA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcqBXUygFqTQyODQ3MDU0Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMjc0NDMw", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#pullrequestreview-422274430", "createdAt": "2020-06-02T00:56:36Z", "commit": {"oid": "aa348632a26dcdd8f734835f2043f4fbb51da52c"}, "state": "COMMENTED", "comments": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwMDo1NjozNlrOGder4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwMTo1MjozMVrOGdfing==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NDY0Mg==", "bodyText": "Nit let's line break before .build()", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433564642", "createdAt": "2020-06-02T00:56:36Z", "author": {"login": "anuraaga"}, "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa348632a26dcdd8f734835f2043f4fbb51da52c"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NTE5OQ==", "bodyText": "Put in visibility order public (none here), package private, private.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433565199", "createdAt": "2020-06-02T00:58:53Z", "author": {"login": "anuraaga"}, "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa348632a26dcdd8f734835f2043f4fbb51da52c"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NTI4OA==", "bodyText": "Since SDK depends on Guava, I think it's ok for extensions to as well since it's basically free. So can add @VisibleForTesting", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433565288", "createdAt": "2020-06-02T00:59:17Z", "author": {"login": "anuraaga"}, "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NTE5OQ=="}, "originalCommit": {"oid": "aa348632a26dcdd8f734835f2043f4fbb51da52c"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NjA1MA==", "bodyText": "Can you run ./gradlew googleJavaFormat?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433566050", "createdAt": "2020-06-02T01:02:22Z", "author": {"login": "anuraaga"}, "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa348632a26dcdd8f734835f2043f4fbb51da52c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2NzA5OQ==", "bodyText": "Can we add tracestate as additional params too? Not sure we'd prefer tracestate= some serialized string or put the KV's directly (probably need to dedupe against our known keys if the latter).\nIf not now, let's add a TODO to revisit it we shouldn't just drop it if possible.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433567099", "createdAt": "2020-06-02T01:06:59Z", "author": {"login": "anuraaga"}, "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId = TRACE_ID_VERSION + TRACE_ID_DELIMITER +\n+        otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH) + TRACE_ID_DELIMITER +\n+        otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    String traceHeader = TRACE_ID_KEY + KV_DELIMITER + xrayTraceId + TRACE_HEADER_DELIMITER +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa348632a26dcdd8f734835f2043f4fbb51da52c"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2Nzc0MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                checkNotNull(carrier, \"carrier\");\n          \n          \n            \n                checkNotNull(getter, \"getter\");\n          \n          \n            \n                Objects.requireNonNull(carrier, \"carrier\");\n          \n          \n            \n                Objects.requireNonNull(getter, \"getter\");", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433567740", "createdAt": "2020-06-02T01:09:39Z", "author": {"login": "anuraaga"}, "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId = TRACE_ID_VERSION + TRACE_ID_DELIMITER +\n+        otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH) + TRACE_ID_DELIMITER +\n+        otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    String traceHeader = TRACE_ID_KEY + KV_DELIMITER + xrayTraceId + TRACE_HEADER_DELIMITER +\n+        PARENT_ID_KEY + KV_DELIMITER + parentId + TRACE_HEADER_DELIMITER +\n+        SAMPLED_FLAG_KEY + KV_DELIMITER + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa348632a26dcdd8f734835f2043f4fbb51da52c"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2ODA4Nw==", "bodyText": "As per 3) should we avoid throwing on null?\nhttps://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/error-handling.md#basic-error-handling-principles", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433568087", "createdAt": "2020-06-02T01:10:58Z", "author": {"login": "anuraaga"}, "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa348632a26dcdd8f734835f2043f4fbb51da52c"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2ODkwOQ==", "bodyText": "Think it's better to use .getSpan(context) and check span.getContext().isValid(). From what I can tell, this current method may return an invalid span too, so either we check both null and valid or just valid.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433568909", "createdAt": "2020-06-02T01:14:29Z", "author": {"login": "anuraaga"}, "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa348632a26dcdd8f734835f2043f4fbb51da52c"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2OTI2MQ==", "bodyText": "Instead of a large catch-all exception, only catch where an exception could happen. Even if we're worried about missing something, this isn't the right layer to have a catch-all.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433569261", "createdAt": "2020-06-02T01:15:57Z", "author": {"login": "anuraaga"}, "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId = TRACE_ID_VERSION + TRACE_ID_DELIMITER +\n+        otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH) + TRACE_ID_DELIMITER +\n+        otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    String traceHeader = TRACE_ID_KEY + KV_DELIMITER + xrayTraceId + TRACE_HEADER_DELIMITER +\n+        PARENT_ID_KEY + KV_DELIMITER + parentId + TRACE_HEADER_DELIMITER +\n+        SAMPLED_FLAG_KEY + KV_DELIMITER + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa348632a26dcdd8f734835f2043f4fbb51da52c"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2OTgwMw==", "bodyText": "I'm not sure if internal package is really meant for use from contrib, but similar to above, since this is SDK, we may as well just use Guava and Strings.isNullOrEmpty", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433569803", "createdAt": "2020-06-02T01:18:17Z", "author": {"login": "anuraaga"}, "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId = TRACE_ID_VERSION + TRACE_ID_DELIMITER +\n+        otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH) + TRACE_ID_DELIMITER +\n+        otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    String traceHeader = TRACE_ID_KEY + KV_DELIMITER + xrayTraceId + TRACE_HEADER_DELIMITER +\n+        PARENT_ID_KEY + KV_DELIMITER + parentId + TRACE_HEADER_DELIMITER +\n+        SAMPLED_FLAG_KEY + KV_DELIMITER + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    try {\n+      String traceHeader = getter.get(carrier, TRACE_HEADER_KEY);\n+      if (StringUtils.isNullOrEmpty(traceHeader)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa348632a26dcdd8f734835f2043f4fbb51da52c"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3MjUzNA==", "bodyText": "We want our instrumentation to have as low an impact on user app's performance as possible so we should take care in optimizing especially parse logic.\nThis is probably the most optimized version\nhttps://github.com/openzipkin/zipkin-aws/blob/master/brave-propagation-aws/src/main/java/brave/propagation/aws/AWSExtractor.java#L72\nEven if that's too complex, we can still get a lot of improvement by avoiding .split in favor of indexOf and substring, I don't think we need to use split at all here (the warning is valid :) )", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433572534", "createdAt": "2020-06-02T01:28:47Z", "author": {"login": "anuraaga"}, "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId = TRACE_ID_VERSION + TRACE_ID_DELIMITER +\n+        otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH) + TRACE_ID_DELIMITER +\n+        otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    String traceHeader = TRACE_ID_KEY + KV_DELIMITER + xrayTraceId + TRACE_HEADER_DELIMITER +\n+        PARENT_ID_KEY + KV_DELIMITER + parentId + TRACE_HEADER_DELIMITER +\n+        SAMPLED_FLAG_KEY + KV_DELIMITER + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    try {\n+      String traceHeader = getter.get(carrier, TRACE_HEADER_KEY);\n+      if (StringUtils.isNullOrEmpty(traceHeader)) {\n+        return SpanContext.getInvalid();\n+      }\n+\n+      String[] parts = traceHeader.split(String.valueOf(TRACE_HEADER_DELIMITER));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa348632a26dcdd8f734835f2043f4fbb51da52c"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3MjYxMA==", "bodyText": "When avoiding split we should also inline the key/value parse here to avoid allocating arrays", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433572610", "createdAt": "2020-06-02T01:29:07Z", "author": {"login": "anuraaga"}, "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId = TRACE_ID_VERSION + TRACE_ID_DELIMITER +\n+        otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH) + TRACE_ID_DELIMITER +\n+        otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    String traceHeader = TRACE_ID_KEY + KV_DELIMITER + xrayTraceId + TRACE_HEADER_DELIMITER +\n+        PARENT_ID_KEY + KV_DELIMITER + parentId + TRACE_HEADER_DELIMITER +\n+        SAMPLED_FLAG_KEY + KV_DELIMITER + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    try {\n+      String traceHeader = getter.get(carrier, TRACE_HEADER_KEY);\n+      if (StringUtils.isNullOrEmpty(traceHeader)) {\n+        return SpanContext.getInvalid();\n+      }\n+\n+      String[] parts = traceHeader.split(String.valueOf(TRACE_HEADER_DELIMITER));\n+      TraceId traceId = TraceId.getInvalid();\n+      SpanId spanId = SpanId.getInvalid();\n+      TraceFlags traceFlags = null;\n+\n+      for (String part : parts) {\n+        String[] keyAndValue = extractKeyAndValue(part);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa348632a26dcdd8f734835f2043f4fbb51da52c"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3Mjg4Mg==", "bodyText": "Think we can put them in tracestate, related to above comment. We should do both or neither though not just one.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433572882", "createdAt": "2020-06-02T01:30:09Z", "author": {"login": "anuraaga"}, "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId = TRACE_ID_VERSION + TRACE_ID_DELIMITER +\n+        otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH) + TRACE_ID_DELIMITER +\n+        otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    String traceHeader = TRACE_ID_KEY + KV_DELIMITER + xrayTraceId + TRACE_HEADER_DELIMITER +\n+        PARENT_ID_KEY + KV_DELIMITER + parentId + TRACE_HEADER_DELIMITER +\n+        SAMPLED_FLAG_KEY + KV_DELIMITER + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    try {\n+      String traceHeader = getter.get(carrier, TRACE_HEADER_KEY);\n+      if (StringUtils.isNullOrEmpty(traceHeader)) {\n+        return SpanContext.getInvalid();\n+      }\n+\n+      String[] parts = traceHeader.split(String.valueOf(TRACE_HEADER_DELIMITER));\n+      TraceId traceId = TraceId.getInvalid();\n+      SpanId spanId = SpanId.getInvalid();\n+      TraceFlags traceFlags = null;\n+\n+      for (String part : parts) {\n+        String[] keyAndValue = extractKeyAndValue(part);\n+        if (keyAndValue == null) {\n+          continue;\n+        }\n+        String key = keyAndValue[0];\n+        String value = keyAndValue[1];\n+\n+        switch (key) {\n+          case TRACE_ID_KEY:\n+            traceId = parseTraceId(value);\n+            break;\n+          case PARENT_ID_KEY:\n+            spanId = parseSpanId(value);\n+            break;\n+          case SAMPLED_FLAG_KEY:\n+            traceFlags = parseTraceFlag(value);\n+            break;\n+          default:\n+            // Ignoring the arbitrary TraceHeader keys in OpenTelemetry", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa348632a26dcdd8f734835f2043f4fbb51da52c"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3NDk3Ng==", "bodyText": "char flag = xraySampledFlag.charAt(0);\nif (flag == IS_SAMPLED)\netc", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433574976", "createdAt": "2020-06-02T01:37:55Z", "author": {"login": "anuraaga"}, "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>.\n+ *\n+ * To register the X-Ray propagator together with default propagator:\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators.builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId = TRACE_ID_VERSION + TRACE_ID_DELIMITER +\n+        otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH) + TRACE_ID_DELIMITER +\n+        otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    String traceHeader = TRACE_ID_KEY + KV_DELIMITER + xrayTraceId + TRACE_HEADER_DELIMITER +\n+        PARENT_ID_KEY + KV_DELIMITER + parentId + TRACE_HEADER_DELIMITER +\n+        SAMPLED_FLAG_KEY + KV_DELIMITER + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    try {\n+      String traceHeader = getter.get(carrier, TRACE_HEADER_KEY);\n+      if (StringUtils.isNullOrEmpty(traceHeader)) {\n+        return SpanContext.getInvalid();\n+      }\n+\n+      String[] parts = traceHeader.split(String.valueOf(TRACE_HEADER_DELIMITER));\n+      TraceId traceId = TraceId.getInvalid();\n+      SpanId spanId = SpanId.getInvalid();\n+      TraceFlags traceFlags = null;\n+\n+      for (String part : parts) {\n+        String[] keyAndValue = extractKeyAndValue(part);\n+        if (keyAndValue == null) {\n+          continue;\n+        }\n+        String key = keyAndValue[0];\n+        String value = keyAndValue[1];\n+\n+        switch (key) {\n+          case TRACE_ID_KEY:\n+            traceId = parseTraceId(value);\n+            break;\n+          case PARENT_ID_KEY:\n+            spanId = parseSpanId(value);\n+            break;\n+          case SAMPLED_FLAG_KEY:\n+            traceFlags = parseTraceFlag(value);\n+            break;\n+          default:\n+            // Ignoring the arbitrary TraceHeader keys in OpenTelemetry\n+            break;\n+        }\n+      }\n+\n+      if (!traceId.isValid()) {\n+        logger.info(\n+            \"Invalid TraceId in X-Ray trace header: '\"\n+                + TRACE_HEADER_KEY\n+                + \"' with value \"\n+                + traceHeader\n+                + \"'. Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      if (!spanId.isValid()) {\n+        logger.info(\n+            \"Invalid ParentId in X-Ray trace header: '\"\n+                + TRACE_HEADER_KEY\n+                + \"' with value \"\n+                + traceHeader\n+                + \"'. Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      return SpanContext\n+          .createFromRemoteParent(traceId, spanId, traceFlags, TraceState.getDefault());\n+    } catch (Exception e) {\n+      logger.log(Level.INFO, \"Error parsing X-Ray trace header. \"\n+          + \"Returning INVALID span context.\", e);\n+      return SpanContext.getInvalid();\n+    }\n+  }\n+\n+  @Nullable\n+  private static String[] extractKeyAndValue(String keyValueString) {\n+    keyValueString = keyValueString.trim();\n+    if (StringUtils.isNullOrEmpty(keyValueString)) {\n+      throw new IllegalArgumentException(\"Invalid key value pair: \" + keyValueString);\n+    }\n+\n+    String[] keyAndValue = keyValueString.split(String.valueOf(KV_DELIMITER));\n+    if (keyAndValue.length != 2) {\n+      throw new IllegalArgumentException(\"Invalid key value pair: \" + keyValueString);\n+    }\n+\n+    if (keyAndValue[0].isEmpty() || keyAndValue[1].isEmpty()) {\n+      throw new IllegalArgumentException(\"Invalid key value pair: \" + keyValueString);\n+    }\n+\n+    return keyAndValue;\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static TraceId parseTraceId(String xrayTraceId) {\n+    String[] parts = xrayTraceId.split(String.valueOf(TRACE_ID_DELIMITER));\n+    if (parts.length != 3) {\n+      return TraceId.getInvalid();\n+    }\n+\n+    if (!parts[0].equals(TRACE_ID_VERSION) ||\n+        parts[1].length() != TRACE_ID_FIRST_PART_LENGTH ||\n+        parts[2].length() != TRACE_ID_SECOND_PART_LENGTH) {\n+      return TraceId.getInvalid();\n+    }\n+\n+    // X-Ray trace id format is 1-{8 digit hex}-{24 digit hex}\n+    return TraceId.fromLowerBase16(parts[1] + parts[2], 0);\n+  }\n+\n+  private static SpanId parseSpanId(String xrayParentId) {\n+    if (xrayParentId.length() != PARENT_ID_LENGTH) {\n+      return SpanId.getInvalid();\n+    }\n+\n+    return SpanId.fromLowerBase16(xrayParentId, 0);\n+  }\n+\n+  private static TraceFlags parseTraceFlag(String xraySampledFlag) {\n+    if (xraySampledFlag.length() != SAMPLED_FLAG_LENGTH) {\n+      throw new IllegalArgumentException(\"Invalid Sampling flag: \" + xraySampledFlag);\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa348632a26dcdd8f734835f2043f4fbb51da52c"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3Njk0NQ==", "bodyText": "I'd inline the strings, or have constants for the various forms. It's more readable and avoids the issue of now we need a test for this test helper.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433576945", "createdAt": "2020-06-02T01:45:39Z", "author": {"login": "anuraaga"}, "path": "sdk_contrib/aws_v1_support/src/test/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagatorTest.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.opentelemetry.sdk.contrib.trace.aws.propagation.AWSXRayPropagator.TRACE_HEADER_KEY;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Setter;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class AWSXRayPropagatorTest {\n+\n+  private static final String TRACE_ID_FIRST_PART = \"8a3c60f7\";\n+  private static final String TRACE_ID_SECOND_PART = \"d188f8fa79d48a391a778fa6\";\n+  private static final String TRACE_ID_BASE16 = TRACE_ID_FIRST_PART + TRACE_ID_SECOND_PART;\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+\n+  private static final String SPAN_ID_BASE16 = \"53995c3f42cd8ad8\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final TraceFlags SAMPLED_TRACE_FLAG = TraceFlags.builder().setIsSampled(true).build();\n+\n+  private static final HttpTextFormat.Setter<Map<String, String>> setter =\n+      new HttpTextFormat.Setter<Map<String, String>>() {\n+        @Override\n+        public void set(Map<String, String> carrier, String key, String value) {\n+          carrier.put(key, value);\n+        }\n+      };\n+  private static final HttpTextFormat.Getter<Map<String, String>> getter =\n+      new HttpTextFormat.Getter<Map<String, String>>() {\n+        @Nullable\n+        @Override\n+        public String get(Map<String, String> carrier, String key) {\n+          return carrier.get(key);\n+        }\n+      };\n+  private final AWSXRayPropagator xrayPropagator = new AWSXRayPropagator();\n+\n+  @Test\n+  public void inject_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa348632a26dcdd8f734835f2043f4fbb51da52c"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3NzY1NA==", "bodyText": "This test doesn't seem to reflect reality and I don't think it actually verifies anything. We've already verified in our other tests that carrier is passed to the setter. So I think we can remove the test.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433577654", "createdAt": "2020-06-02T01:48:34Z", "author": {"login": "anuraaga"}, "path": "sdk_contrib/aws_v1_support/src/test/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagatorTest.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.opentelemetry.sdk.contrib.trace.aws.propagation.AWSXRayPropagator.TRACE_HEADER_KEY;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Setter;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class AWSXRayPropagatorTest {\n+\n+  private static final String TRACE_ID_FIRST_PART = \"8a3c60f7\";\n+  private static final String TRACE_ID_SECOND_PART = \"d188f8fa79d48a391a778fa6\";\n+  private static final String TRACE_ID_BASE16 = TRACE_ID_FIRST_PART + TRACE_ID_SECOND_PART;\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+\n+  private static final String SPAN_ID_BASE16 = \"53995c3f42cd8ad8\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final TraceFlags SAMPLED_TRACE_FLAG = TraceFlags.builder().setIsSampled(true).build();\n+\n+  private static final HttpTextFormat.Setter<Map<String, String>> setter =\n+      new HttpTextFormat.Setter<Map<String, String>>() {\n+        @Override\n+        public void set(Map<String, String> carrier, String key, String value) {\n+          carrier.put(key, value);\n+        }\n+      };\n+  private static final HttpTextFormat.Getter<Map<String, String>> getter =\n+      new HttpTextFormat.Getter<Map<String, String>>() {\n+        @Nullable\n+        @Override\n+        public String get(Map<String, String> carrier, String key) {\n+          return carrier.get(key);\n+        }\n+      };\n+  private final AWSXRayPropagator xrayPropagator = new AWSXRayPropagator();\n+\n+  @Test\n+  public void inject_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(\n+                TRACE_ID_BASE16, SPAN_ID_BASE16, \"1\"));\n+  }\n+\n+  @Test\n+  public void inject_SampledContext_nullCarrierUsage() {\n+    final Map<String, String> carrier = new LinkedHashMap<>();\n+\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        null,\n+        new Setter<Map<String, String>>() {\n+          @Override\n+          public void set(Map<String, String> ignored, String key, String value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa348632a26dcdd8f734835f2043f4fbb51da52c"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3ODE0NQ==", "bodyText": "Nit I'd put the success cases above the error cases.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433578145", "createdAt": "2020-06-02T01:50:28Z", "author": {"login": "anuraaga"}, "path": "sdk_contrib/aws_v1_support/src/test/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagatorTest.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.opentelemetry.sdk.contrib.trace.aws.propagation.AWSXRayPropagator.TRACE_HEADER_KEY;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Setter;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class AWSXRayPropagatorTest {\n+\n+  private static final String TRACE_ID_FIRST_PART = \"8a3c60f7\";\n+  private static final String TRACE_ID_SECOND_PART = \"d188f8fa79d48a391a778fa6\";\n+  private static final String TRACE_ID_BASE16 = TRACE_ID_FIRST_PART + TRACE_ID_SECOND_PART;\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+\n+  private static final String SPAN_ID_BASE16 = \"53995c3f42cd8ad8\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final TraceFlags SAMPLED_TRACE_FLAG = TraceFlags.builder().setIsSampled(true).build();\n+\n+  private static final HttpTextFormat.Setter<Map<String, String>> setter =\n+      new HttpTextFormat.Setter<Map<String, String>>() {\n+        @Override\n+        public void set(Map<String, String> carrier, String key, String value) {\n+          carrier.put(key, value);\n+        }\n+      };\n+  private static final HttpTextFormat.Getter<Map<String, String>> getter =\n+      new HttpTextFormat.Getter<Map<String, String>>() {\n+        @Nullable\n+        @Override\n+        public String get(Map<String, String> carrier, String key) {\n+          return carrier.get(key);\n+        }\n+      };\n+  private final AWSXRayPropagator xrayPropagator = new AWSXRayPropagator();\n+\n+  @Test\n+  public void inject_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(\n+                TRACE_ID_BASE16, SPAN_ID_BASE16, \"1\"));\n+  }\n+\n+  @Test\n+  public void inject_SampledContext_nullCarrierUsage() {\n+    final Map<String, String> carrier = new LinkedHashMap<>();\n+\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        null,\n+        new Setter<Map<String, String>>() {\n+          @Override\n+          public void set(Map<String, String> ignored, String key, String value) {\n+            carrier.put(key, value);\n+          }\n+        });\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(\n+                TRACE_ID_BASE16, SPAN_ID_BASE16, \"1\"));\n+  }\n+\n+  @Test\n+  public void inject_NotSampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, TraceFlags.getDefault(), TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(\n+                TRACE_ID_BASE16, SPAN_ID_BASE16, \"0\"));\n+  }\n+\n+  @Test\n+  public void extract_EmptyHeaderValue() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(TRACE_HEADER_KEY, \"\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_NotEnoughParts() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(TRACE_HEADER_KEY, \"aa:bb:cc\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_TooManyParts() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(TRACE_HEADER_KEY, \"aa:bb:cc:dd:ee\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidTraceId() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        generateTraceHeaderValue(\n+            \"abcdefghijklmnopabcdefghijklmnop\", SPAN_ID_BASE16, \"0\"));\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidTraceId_Size() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        generateTraceHeaderValue(\n+            TRACE_ID_BASE16 + \"00\", SPAN_ID_BASE16, \"0\"));\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidSpanId() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        generateTraceHeaderValue(\n+            TRACE_ID_BASE16, \"abcdefghijklmnop\", \"0\"));\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidSpanId_Size() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        generateTraceHeaderValue(\n+            TRACE_ID_BASE16, SPAN_ID_BASE16 + \"00\", \"0\"));\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidFlags() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        generateTraceHeaderValue(TRACE_ID_BASE16, SPAN_ID_BASE16, \"\"));\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidFlags_Size() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        generateTraceHeaderValue(\n+            TRACE_ID_BASE16, SPAN_ID_BASE16, \"10220\"));\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidFlags_NonNumeric() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        generateTraceHeaderValue(\n+            TRACE_ID_BASE16, SPAN_ID_BASE16, \"abcdefr\"));\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_SampledContext() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa348632a26dcdd8f734835f2043f4fbb51da52c"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3ODM1OA==", "bodyText": "Here especially, don't use a helper method or even a constant, inlining the header will make much more readable what the test is checking.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433578358", "createdAt": "2020-06-02T01:51:20Z", "author": {"login": "anuraaga"}, "path": "sdk_contrib/aws_v1_support/src/test/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagatorTest.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.opentelemetry.sdk.contrib.trace.aws.propagation.AWSXRayPropagator.TRACE_HEADER_KEY;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Setter;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class AWSXRayPropagatorTest {\n+\n+  private static final String TRACE_ID_FIRST_PART = \"8a3c60f7\";\n+  private static final String TRACE_ID_SECOND_PART = \"d188f8fa79d48a391a778fa6\";\n+  private static final String TRACE_ID_BASE16 = TRACE_ID_FIRST_PART + TRACE_ID_SECOND_PART;\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+\n+  private static final String SPAN_ID_BASE16 = \"53995c3f42cd8ad8\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final TraceFlags SAMPLED_TRACE_FLAG = TraceFlags.builder().setIsSampled(true).build();\n+\n+  private static final HttpTextFormat.Setter<Map<String, String>> setter =\n+      new HttpTextFormat.Setter<Map<String, String>>() {\n+        @Override\n+        public void set(Map<String, String> carrier, String key, String value) {\n+          carrier.put(key, value);\n+        }\n+      };\n+  private static final HttpTextFormat.Getter<Map<String, String>> getter =\n+      new HttpTextFormat.Getter<Map<String, String>>() {\n+        @Nullable\n+        @Override\n+        public String get(Map<String, String> carrier, String key) {\n+          return carrier.get(key);\n+        }\n+      };\n+  private final AWSXRayPropagator xrayPropagator = new AWSXRayPropagator();\n+\n+  @Test\n+  public void inject_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(\n+                TRACE_ID_BASE16, SPAN_ID_BASE16, \"1\"));\n+  }\n+\n+  @Test\n+  public void inject_SampledContext_nullCarrierUsage() {\n+    final Map<String, String> carrier = new LinkedHashMap<>();\n+\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        null,\n+        new Setter<Map<String, String>>() {\n+          @Override\n+          public void set(Map<String, String> ignored, String key, String value) {\n+            carrier.put(key, value);\n+          }\n+        });\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(\n+                TRACE_ID_BASE16, SPAN_ID_BASE16, \"1\"));\n+  }\n+\n+  @Test\n+  public void inject_NotSampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, TraceFlags.getDefault(), TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(\n+                TRACE_ID_BASE16, SPAN_ID_BASE16, \"0\"));\n+  }\n+\n+  @Test\n+  public void extract_EmptyHeaderValue() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(TRACE_HEADER_KEY, \"\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_NotEnoughParts() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(TRACE_HEADER_KEY, \"aa:bb:cc\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_TooManyParts() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(TRACE_HEADER_KEY, \"aa:bb:cc:dd:ee\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidTraceId() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        generateTraceHeaderValue(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa348632a26dcdd8f734835f2043f4fbb51da52c"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3ODY1NA==", "bodyText": "I think these two tests are supposed to use semicolon instead of colon.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r433578654", "createdAt": "2020-06-02T01:52:31Z", "author": {"login": "anuraaga"}, "path": "sdk_contrib/aws_v1_support/src/test/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagatorTest.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.opentelemetry.sdk.contrib.trace.aws.propagation.AWSXRayPropagator.TRACE_HEADER_KEY;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Setter;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class AWSXRayPropagatorTest {\n+\n+  private static final String TRACE_ID_FIRST_PART = \"8a3c60f7\";\n+  private static final String TRACE_ID_SECOND_PART = \"d188f8fa79d48a391a778fa6\";\n+  private static final String TRACE_ID_BASE16 = TRACE_ID_FIRST_PART + TRACE_ID_SECOND_PART;\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+\n+  private static final String SPAN_ID_BASE16 = \"53995c3f42cd8ad8\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final TraceFlags SAMPLED_TRACE_FLAG = TraceFlags.builder().setIsSampled(true).build();\n+\n+  private static final HttpTextFormat.Setter<Map<String, String>> setter =\n+      new HttpTextFormat.Setter<Map<String, String>>() {\n+        @Override\n+        public void set(Map<String, String> carrier, String key, String value) {\n+          carrier.put(key, value);\n+        }\n+      };\n+  private static final HttpTextFormat.Getter<Map<String, String>> getter =\n+      new HttpTextFormat.Getter<Map<String, String>>() {\n+        @Nullable\n+        @Override\n+        public String get(Map<String, String> carrier, String key) {\n+          return carrier.get(key);\n+        }\n+      };\n+  private final AWSXRayPropagator xrayPropagator = new AWSXRayPropagator();\n+\n+  @Test\n+  public void inject_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(\n+                TRACE_ID_BASE16, SPAN_ID_BASE16, \"1\"));\n+  }\n+\n+  @Test\n+  public void inject_SampledContext_nullCarrierUsage() {\n+    final Map<String, String> carrier = new LinkedHashMap<>();\n+\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        null,\n+        new Setter<Map<String, String>>() {\n+          @Override\n+          public void set(Map<String, String> ignored, String key, String value) {\n+            carrier.put(key, value);\n+          }\n+        });\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(\n+                TRACE_ID_BASE16, SPAN_ID_BASE16, \"1\"));\n+  }\n+\n+  @Test\n+  public void inject_NotSampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, TraceFlags.getDefault(), TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY,\n+            generateTraceHeaderValue(\n+                TRACE_ID_BASE16, SPAN_ID_BASE16, \"0\"));\n+  }\n+\n+  @Test\n+  public void extract_EmptyHeaderValue() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(TRACE_HEADER_KEY, \"\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_NotEnoughParts() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(TRACE_HEADER_KEY, \"aa:bb:cc\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa348632a26dcdd8f734835f2043f4fbb51da52c"}, "originalPosition": 138}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MTQ3NTgx", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#pullrequestreview-424147581", "createdAt": "2020-06-04T06:50:38Z", "commit": {"oid": "24ac33119453937bc530fb51347ed61319c8d7df"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNjo1MDozOVrOGe4C6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMzozNDoxMFrOGgBl2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAyODcxMw==", "bodyText": "I agree with aligning with the other propagators in behavior, like the NPE behavior, but we don't need to copy the implementation details if they can be better. The default propagator has this pattern since it initially had a bug where valid wasn't checked and that was tacked on, but it should have been cleaner. Let's be clean here\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Span span = TracingContextUtils.getSpanWithoutDefault(context);\n          \n          \n            \n                if (span == null || !span.getContext().isValid()) {\n          \n          \n            \n                Span span = TracingContextUtils.getSpan(context);\n          \n          \n            \n                if (!span.getContext().isValid()) {", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r435028713", "createdAt": "2020-06-04T06:50:39Z", "author": {"login": "anuraaga"}, "path": "sdk_contrib/aws_v1_support/src/main/java/io/opentelemetry/sdk/contrib/trace/aws/propagation/AWSXRayPropagator.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.contrib.trace.aws.propagation;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See\n+ *\n+ * <pre><a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-con\n+ * cepts-tracingheader>AWS Tracing header spec</a></pre>\n+ *\n+ * .\n+ *\n+ * <p>To register the X-Ray propagator together with default propagator:\n+ *\n+ * <pre>\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators\n+ *     .builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * </pre>\n+ */\n+public class AWSXRayPropagator implements HttpTextFormat {\n+\n+  @VisibleForTesting static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+\n+  private static final Logger logger = Logger.getLogger(AWSXRayPropagator.class.getName());\n+\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+  private static final int TRACE_ID_SECOND_PART_LENGTH = 24;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null || !span.getContext().isValid()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ac33119453937bc530fb51347ed61319c8d7df"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMzA3OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n          \n          \n            \n             *     .addHttpTextFormat(new AWSXRayPropagator())\n          \n          \n            \n                   .build());", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r436233079", "createdAt": "2020-06-06T03:23:34Z", "author": {"login": "anuraaga"}, "path": "contrib/trace_propagators/src/main/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagator.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader>AWS\n+ * Tracing header spec</a>\n+ *\n+ * <p>To register the X-Ray propagator together with default propagator:\n+ *\n+ * <pre>{@code\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators\n+ *     .builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "251a2db38077303f70ee0061fd9861db142d00e8"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMzM3NQ==", "bodyText": "Cool", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r436233375", "createdAt": "2020-06-06T03:28:13Z", "author": {"login": "anuraaga"}, "path": "contrib/trace_propagators/src/main/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagator.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader>AWS\n+ * Tracing header spec</a>\n+ *\n+ * <p>To register the X-Ray propagator together with default propagator:\n+ *\n+ * <pre>{@code\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators\n+ *     .builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * }</pre>\n+ */\n+public class AwsXRayPropagator implements HttpTextFormat {\n+\n+  @VisibleForTesting static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+\n+  private static final Logger logger = Logger.getLogger(AwsXRayPropagator.class.getName());\n+\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final char TRACE_ID_LENGTH = 35;\n+  private static final char TRACE_ID_VERSION = '1';\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_DELIMITER_INDEX_1 = 1;\n+  private static final int TRACE_ID_DELIMITER_INDEX_2 = 10;\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null || !span.getContext().isValid()) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId =\n+        String.valueOf(TRACE_ID_VERSION)\n+            + TRACE_ID_DELIMITER\n+            + otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH)\n+            + TRACE_ID_DELIMITER\n+            + otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+    // TODO: Add OT trace state to the X-Ray trace header\n+\n+    String traceHeader =\n+        TRACE_ID_KEY\n+            + KV_DELIMITER\n+            + xrayTraceId\n+            + TRACE_HEADER_DELIMITER\n+            + PARENT_ID_KEY\n+            + KV_DELIMITER\n+            + parentId\n+            + TRACE_HEADER_DELIMITER\n+            + SAMPLED_FLAG_KEY\n+            + KV_DELIMITER\n+            + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    Objects.requireNonNull(carrier, \"carrier\");\n+    Objects.requireNonNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String traceHeader = getter.get(carrier, TRACE_HEADER_KEY);\n+    if (Strings.isNullOrEmpty(traceHeader)) {\n+      return SpanContext.getInvalid();\n+    }\n+\n+    TraceId traceId = TraceId.getInvalid();\n+    SpanId spanId = SpanId.getInvalid();\n+    TraceFlags traceFlags = TraceFlags.getDefault();\n+\n+    int pos = 0;\n+    while (pos < traceHeader.length()) {\n+      int delimiterIndex = traceHeader.indexOf(TRACE_HEADER_DELIMITER, pos);\n+      final String part;\n+      if (delimiterIndex >= 0) {\n+        part = traceHeader.substring(pos, delimiterIndex);\n+        pos = delimiterIndex + 1;\n+      } else {\n+        // Last part.\n+        part = traceHeader.substring(pos);\n+        pos = traceHeader.length();\n+      }\n+      String trimmedPart = part.trim();\n+      int equalsIndex = trimmedPart.indexOf(KV_DELIMITER);\n+      if (equalsIndex < 0) {\n+        logger.info(\n+            \"Error parsing X-Ray trace header. Invalid key value pair: \"\n+                + part\n+                + \" Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      String value = trimmedPart.substring(equalsIndex + 1);\n+\n+      if (trimmedPart.startsWith(TRACE_ID_KEY)) {\n+        traceId = parseTraceId(value);\n+      } else if (trimmedPart.startsWith(PARENT_ID_KEY)) {\n+        spanId = parseSpanId(value);\n+      } else if (trimmedPart.startsWith(SAMPLED_FLAG_KEY)) {\n+        traceFlags = parseTraceFlag(value);\n+      }\n+      // TODO: Put the arbitrary TraceHeader keys in OT trace state\n+    }\n+\n+    if (!traceId.isValid()) {\n+      logger.info(\n+          \"Invalid TraceId in X-Ray trace header: '\"\n+              + TRACE_HEADER_KEY\n+              + \"' with value \"\n+              + traceHeader\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    if (!spanId.isValid()) {\n+      logger.info(\n+          \"Invalid ParentId in X-Ray trace header: '\"\n+              + TRACE_HEADER_KEY\n+              + \"' with value \"\n+              + traceHeader\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    if (traceFlags == null) {\n+      logger.info(\n+          \"Invalid Sampling flag in X-Ray trace header: '\"\n+              + TRACE_HEADER_KEY\n+              + \"' with value \"\n+              + traceHeader\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    return SpanContext.createFromRemoteParent(traceId, spanId, traceFlags, TraceState.getDefault());\n+  }\n+\n+  private static TraceId parseTraceId(String xrayTraceId) {\n+    if (xrayTraceId.length() != TRACE_ID_LENGTH) {\n+      return TraceId.getInvalid();\n+    }\n+\n+    // Check version trace id version\n+    if (xrayTraceId.charAt(0) != TRACE_ID_VERSION) {\n+      return TraceId.getInvalid();\n+    }\n+\n+    // Check delimiters", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "251a2db38077303f70ee0061fd9861db142d00e8"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMzQ1NA==", "bodyText": "Recommend instead having inline constants for different types of trace headers, e.g.\nTRACE_HEADER_SAMPLED = \"Root=11241341413441;Parent=12312134;Sampled=1\"\nTRACE_HEADER_UNSAMPLED = \"Root=11241341413441;Parent=12312134;Sampled=0\"\nThere's some duplication, but since this is testdata, not business logic, doesn't really affect maintenance. But it has a nice benefit that anyone, including people not familiar with X-Ray, can easily see what an X-Ray header is supposed to look like.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r436233454", "createdAt": "2020-06-06T03:29:54Z", "author": {"login": "anuraaga"}, "path": "contrib/trace_propagators/src/test/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagatorTest.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.opentelemetry.contrib.trace.propagation.AwsXRayPropagator.TRACE_HEADER_KEY;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class AwsXRayPropagatorTest {\n+\n+  private static final String TRACE_ID_FIRST_PART = \"8a3c60f7\";\n+  private static final String TRACE_ID_SECOND_PART = \"d188f8fa79d48a391a778fa6\";\n+  private static final String TRACE_ID_BASE16 = TRACE_ID_FIRST_PART + TRACE_ID_SECOND_PART;\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final String TRACE_ID_XRAY =\n+      \"1-\" + TRACE_ID_BASE16.substring(0, 8) + \"-\" + TRACE_ID_BASE16.substring(8);\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+\n+  private static final String SPAN_ID_BASE16 = \"53995c3f42cd8ad8\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final TraceFlags SAMPLED_TRACE_FLAG =\n+      TraceFlags.builder().setIsSampled(true).build();\n+\n+  private static final HttpTextFormat.Setter<Map<String, String>> setter =\n+      new HttpTextFormat.Setter<Map<String, String>>() {\n+        @Override\n+        public void set(Map<String, String> carrier, String key, String value) {\n+          carrier.put(key, value);\n+        }\n+      };\n+  private static final HttpTextFormat.Getter<Map<String, String>> getter =\n+      new HttpTextFormat.Getter<Map<String, String>>() {\n+        @Nullable\n+        @Override\n+        public String get(Map<String, String> carrier, String key) {\n+          return carrier.get(key);\n+        }\n+      };\n+  private final AwsXRayPropagator xrayPropagator = new AwsXRayPropagator();\n+\n+  @Test\n+  public void inject_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=1\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "251a2db38077303f70ee0061fd9861db142d00e8"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMzU1Mg==", "bodyText": "Couple more test cases\n\nValid header with keys in different oder\nValid header with additional params. We strip this right now but need to make sure this propagator can read any valid header", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r436233552", "createdAt": "2020-06-06T03:31:21Z", "author": {"login": "anuraaga"}, "path": "contrib/trace_propagators/src/test/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagatorTest.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.opentelemetry.contrib.trace.propagation.AwsXRayPropagator.TRACE_HEADER_KEY;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class AwsXRayPropagatorTest {\n+\n+  private static final String TRACE_ID_FIRST_PART = \"8a3c60f7\";\n+  private static final String TRACE_ID_SECOND_PART = \"d188f8fa79d48a391a778fa6\";\n+  private static final String TRACE_ID_BASE16 = TRACE_ID_FIRST_PART + TRACE_ID_SECOND_PART;\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final String TRACE_ID_XRAY =\n+      \"1-\" + TRACE_ID_BASE16.substring(0, 8) + \"-\" + TRACE_ID_BASE16.substring(8);\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+\n+  private static final String SPAN_ID_BASE16 = \"53995c3f42cd8ad8\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final TraceFlags SAMPLED_TRACE_FLAG =\n+      TraceFlags.builder().setIsSampled(true).build();\n+\n+  private static final HttpTextFormat.Setter<Map<String, String>> setter =\n+      new HttpTextFormat.Setter<Map<String, String>>() {\n+        @Override\n+        public void set(Map<String, String> carrier, String key, String value) {\n+          carrier.put(key, value);\n+        }\n+      };\n+  private static final HttpTextFormat.Getter<Map<String, String>> getter =\n+      new HttpTextFormat.Getter<Map<String, String>>() {\n+        @Nullable\n+        @Override\n+        public String get(Map<String, String> carrier, String key) {\n+          return carrier.get(key);\n+        }\n+      };\n+  private final AwsXRayPropagator xrayPropagator = new AwsXRayPropagator();\n+\n+  @Test\n+  public void inject_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=1\");\n+  }\n+\n+  @Test\n+  public void inject_NotSampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, TraceFlags.getDefault(), TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=0\");\n+  }\n+\n+  @Test\n+  public void extract_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    carrier.put(\n+        TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=1\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), carrier, getter)))\n+        .isEqualTo(\n+            SpanContext.createFromRemoteParent(\n+                TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT));\n+  }\n+\n+  @Test\n+  public void extract_NotSampledContext() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "251a2db38077303f70ee0061fd9861db142d00e8"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMzY0NQ==", "bodyText": "Isn't this branch an invalid header?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r436233645", "createdAt": "2020-06-06T03:33:08Z", "author": {"login": "anuraaga"}, "path": "contrib/trace_propagators/src/main/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagator.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader>AWS\n+ * Tracing header spec</a>\n+ *\n+ * <p>To register the X-Ray propagator together with default propagator:\n+ *\n+ * <pre>{@code\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators\n+ *     .builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * }</pre>\n+ */\n+public class AwsXRayPropagator implements HttpTextFormat {\n+\n+  @VisibleForTesting static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+\n+  private static final Logger logger = Logger.getLogger(AwsXRayPropagator.class.getName());\n+\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final char TRACE_ID_LENGTH = 35;\n+  private static final char TRACE_ID_VERSION = '1';\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_DELIMITER_INDEX_1 = 1;\n+  private static final int TRACE_ID_DELIMITER_INDEX_2 = 10;\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null || !span.getContext().isValid()) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId =\n+        String.valueOf(TRACE_ID_VERSION)\n+            + TRACE_ID_DELIMITER\n+            + otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH)\n+            + TRACE_ID_DELIMITER\n+            + otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+    // TODO: Add OT trace state to the X-Ray trace header\n+\n+    String traceHeader =\n+        TRACE_ID_KEY\n+            + KV_DELIMITER\n+            + xrayTraceId\n+            + TRACE_HEADER_DELIMITER\n+            + PARENT_ID_KEY\n+            + KV_DELIMITER\n+            + parentId\n+            + TRACE_HEADER_DELIMITER\n+            + SAMPLED_FLAG_KEY\n+            + KV_DELIMITER\n+            + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    Objects.requireNonNull(carrier, \"carrier\");\n+    Objects.requireNonNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String traceHeader = getter.get(carrier, TRACE_HEADER_KEY);\n+    if (Strings.isNullOrEmpty(traceHeader)) {\n+      return SpanContext.getInvalid();\n+    }\n+\n+    TraceId traceId = TraceId.getInvalid();\n+    SpanId spanId = SpanId.getInvalid();\n+    TraceFlags traceFlags = TraceFlags.getDefault();\n+\n+    int pos = 0;\n+    while (pos < traceHeader.length()) {\n+      int delimiterIndex = traceHeader.indexOf(TRACE_HEADER_DELIMITER, pos);\n+      final String part;\n+      if (delimiterIndex >= 0) {\n+        part = traceHeader.substring(pos, delimiterIndex);\n+        pos = delimiterIndex + 1;\n+      } else {\n+        // Last part.\n+        part = traceHeader.substring(pos);\n+        pos = traceHeader.length();\n+      }\n+      String trimmedPart = part.trim();\n+      int equalsIndex = trimmedPart.indexOf(KV_DELIMITER);\n+      if (equalsIndex < 0) {\n+        logger.info(\n+            \"Error parsing X-Ray trace header. Invalid key value pair: \"\n+                + part\n+                + \" Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      String value = trimmedPart.substring(equalsIndex + 1);\n+\n+      if (trimmedPart.startsWith(TRACE_ID_KEY)) {\n+        traceId = parseTraceId(value);\n+      } else if (trimmedPart.startsWith(PARENT_ID_KEY)) {\n+        spanId = parseSpanId(value);\n+      } else if (trimmedPart.startsWith(SAMPLED_FLAG_KEY)) {\n+        traceFlags = parseTraceFlag(value);\n+      }\n+      // TODO: Put the arbitrary TraceHeader keys in OT trace state\n+    }\n+\n+    if (!traceId.isValid()) {\n+      logger.info(\n+          \"Invalid TraceId in X-Ray trace header: '\"\n+              + TRACE_HEADER_KEY\n+              + \"' with value \"\n+              + traceHeader\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    if (!spanId.isValid()) {\n+      logger.info(\n+          \"Invalid ParentId in X-Ray trace header: '\"\n+              + TRACE_HEADER_KEY\n+              + \"' with value \"\n+              + traceHeader\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    if (traceFlags == null) {\n+      logger.info(\n+          \"Invalid Sampling flag in X-Ray trace header: '\"\n+              + TRACE_HEADER_KEY\n+              + \"' with value \"\n+              + traceHeader\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    return SpanContext.createFromRemoteParent(traceId, spanId, traceFlags, TraceState.getDefault());\n+  }\n+\n+  private static TraceId parseTraceId(String xrayTraceId) {\n+    if (xrayTraceId.length() != TRACE_ID_LENGTH) {\n+      return TraceId.getInvalid();\n+    }\n+\n+    // Check version trace id version\n+    if (xrayTraceId.charAt(0) != TRACE_ID_VERSION) {\n+      return TraceId.getInvalid();\n+    }\n+\n+    // Check delimiters\n+    if (xrayTraceId.charAt(TRACE_ID_DELIMITER_INDEX_1) != TRACE_ID_DELIMITER\n+        || xrayTraceId.charAt(TRACE_ID_DELIMITER_INDEX_2) != TRACE_ID_DELIMITER) {\n+      return TraceId.getInvalid();\n+    }\n+\n+    String epochPart =\n+        xrayTraceId.substring(TRACE_ID_DELIMITER_INDEX_1 + 1, TRACE_ID_DELIMITER_INDEX_2);\n+    String uniquePart = xrayTraceId.substring(TRACE_ID_DELIMITER_INDEX_2 + 1, TRACE_ID_LENGTH);\n+\n+    try {\n+      // X-Ray trace id format is 1-{8 digit hex}-{24 digit hex}\n+      return TraceId.fromLowerBase16(epochPart + uniquePart, 0);\n+    } catch (Exception e) {\n+      return TraceId.getInvalid();\n+    }\n+  }\n+\n+  private static SpanId parseSpanId(String xrayParentId) {\n+    if (xrayParentId.length() != PARENT_ID_LENGTH) {\n+      return SpanId.getInvalid();\n+    }\n+\n+    try {\n+      return SpanId.fromLowerBase16(xrayParentId, 0);\n+    } catch (Exception e) {\n+      return SpanId.getInvalid();\n+    }\n+  }\n+\n+  @Nullable\n+  private static TraceFlags parseTraceFlag(String xraySampledFlag) {\n+    if (xraySampledFlag.length() != SAMPLED_FLAG_LENGTH) {\n+      // Returning null as there is no invalid trace flag defined.\n+      return null;\n+    }\n+\n+    char flag = xraySampledFlag.charAt(0);\n+    if (flag == IS_SAMPLED) {\n+      return TraceFlags.builder().setIsSampled(true).build();\n+    } else if (flag == NOT_SAMPLED) {\n+      return TraceFlags.builder().setIsSampled(false).build();\n+    } else {\n+      try {\n+        return TraceFlags.fromLowerBase16(xraySampledFlag, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "251a2db38077303f70ee0061fd9861db142d00e8"}, "originalPosition": 263}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMzY5MA==", "bodyText": "I don't think this tests anything different from _Size. But having a test with one character that isn't 0 or 1 seems important", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r436233690", "createdAt": "2020-06-06T03:34:10Z", "author": {"login": "anuraaga"}, "path": "contrib/trace_propagators/src/test/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagatorTest.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.opentelemetry.contrib.trace.propagation.AwsXRayPropagator.TRACE_HEADER_KEY;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class AwsXRayPropagatorTest {\n+\n+  private static final String TRACE_ID_FIRST_PART = \"8a3c60f7\";\n+  private static final String TRACE_ID_SECOND_PART = \"d188f8fa79d48a391a778fa6\";\n+  private static final String TRACE_ID_BASE16 = TRACE_ID_FIRST_PART + TRACE_ID_SECOND_PART;\n+  private static final TraceId TRACE_ID = TraceId.fromLowerBase16(TRACE_ID_BASE16, 0);\n+  private static final String TRACE_ID_XRAY =\n+      \"1-\" + TRACE_ID_BASE16.substring(0, 8) + \"-\" + TRACE_ID_BASE16.substring(8);\n+  private static final TraceState TRACE_STATE_DEFAULT = TraceState.builder().build();\n+\n+  private static final String SPAN_ID_BASE16 = \"53995c3f42cd8ad8\";\n+  private static final SpanId SPAN_ID = SpanId.fromLowerBase16(SPAN_ID_BASE16, 0);\n+  private static final TraceFlags SAMPLED_TRACE_FLAG =\n+      TraceFlags.builder().setIsSampled(true).build();\n+\n+  private static final HttpTextFormat.Setter<Map<String, String>> setter =\n+      new HttpTextFormat.Setter<Map<String, String>>() {\n+        @Override\n+        public void set(Map<String, String> carrier, String key, String value) {\n+          carrier.put(key, value);\n+        }\n+      };\n+  private static final HttpTextFormat.Getter<Map<String, String>> getter =\n+      new HttpTextFormat.Getter<Map<String, String>>() {\n+        @Nullable\n+        @Override\n+        public String get(Map<String, String> carrier, String key) {\n+          return carrier.get(key);\n+        }\n+      };\n+  private final AwsXRayPropagator xrayPropagator = new AwsXRayPropagator();\n+\n+  @Test\n+  public void inject_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=1\");\n+  }\n+\n+  @Test\n+  public void inject_NotSampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    xrayPropagator.inject(\n+        withSpanContext(\n+            SpanContext.create(TRACE_ID, SPAN_ID, TraceFlags.getDefault(), TRACE_STATE_DEFAULT),\n+            Context.current()),\n+        carrier,\n+        setter);\n+    assertThat(carrier)\n+        .containsEntry(\n+            TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=0\");\n+  }\n+\n+  @Test\n+  public void extract_SampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    carrier.put(\n+        TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=1\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), carrier, getter)))\n+        .isEqualTo(\n+            SpanContext.createFromRemoteParent(\n+                TRACE_ID, SPAN_ID, SAMPLED_TRACE_FLAG, TRACE_STATE_DEFAULT));\n+  }\n+\n+  @Test\n+  public void extract_NotSampledContext() {\n+    Map<String, String> carrier = new LinkedHashMap<>();\n+    carrier.put(\n+        TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=0\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), carrier, getter)))\n+        .isEqualTo(\n+            SpanContext.createFromRemoteParent(\n+                TRACE_ID, SPAN_ID, TraceFlags.getDefault(), TRACE_STATE_DEFAULT));\n+  }\n+\n+  @Test\n+  public void extract_EmptyHeaderValue() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(TRACE_HEADER_KEY, \"\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidTraceId() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        \"Root=abcdefghijklmnopabcdefghijklmnop;Parent=\" + SPAN_ID_BASE16 + \";Sampled=0\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidTraceId_Size() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        \"Root=\" + TRACE_ID_XRAY + \"00\" + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=0\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidSpanId() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=abcdefghijklmnop;Sampled=0\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidSpanId_Size() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \"00\" + \";Sampled=0\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidFlags() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidFlags_Size() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY, \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=10220\");\n+\n+    assertThat(getSpanContext(xrayPropagator.extract(Context.current(), invalidHeaders, getter)))\n+        .isSameInstanceAs(SpanContext.getInvalid());\n+  }\n+\n+  @Test\n+  public void extract_InvalidFlags_NonNumeric() {\n+    Map<String, String> invalidHeaders = new LinkedHashMap<>();\n+    invalidHeaders.put(\n+        TRACE_HEADER_KEY,\n+        \"Root=\" + TRACE_ID_XRAY + \";Parent=\" + SPAN_ID_BASE16 + \";Sampled=abcdefr\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "251a2db38077303f70ee0061fd9861db142d00e8"}, "originalPosition": 201}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1ODczMDk0", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#pullrequestreview-425873094", "createdAt": "2020-06-08T01:21:36Z", "commit": {"oid": "251a2db38077303f70ee0061fd9861db142d00e8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMToyMTozNlrOGgNFqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMToyMTozNlrOGgNFqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMjA1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static final char TRACE_ID_LENGTH = 35;\n          \n          \n            \n              private static final int TRACE_ID_LENGTH = 35;", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r436422056", "createdAt": "2020-06-08T01:21:36Z", "author": {"login": "anuraaga"}, "path": "contrib/trace_propagators/src/main/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagator.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader>AWS\n+ * Tracing header spec</a>\n+ *\n+ * <p>To register the X-Ray propagator together with default propagator:\n+ *\n+ * <pre>{@code\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators\n+ *     .builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator()).build());\n+ * }</pre>\n+ */\n+public class AwsXRayPropagator implements HttpTextFormat {\n+\n+  @VisibleForTesting static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+\n+  private static final Logger logger = Logger.getLogger(AwsXRayPropagator.class.getName());\n+\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final char TRACE_ID_LENGTH = 35;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "251a2db38077303f70ee0061fd9861db142d00e8"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NjgxNzQx", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#pullrequestreview-426681741", "createdAt": "2020-06-08T23:09:08Z", "commit": {"oid": "6f9491783f0e41f1acc9d7a7ae2e12c777253d1d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NTY3OTI5", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#pullrequestreview-427567929", "createdAt": "2020-06-09T21:45:11Z", "commit": {"oid": "6f9491783f0e41f1acc9d7a7ae2e12c777253d1d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMTo0NToxMVrOGhdi_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMTo0NToxMVrOGhdi_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0MDI4Nw==", "bodyText": "If you made the TRACE_ID_VERSION a string, you could avoid the String.valueOf call above, and just use startsWith for this call. Might read a little cleaner in both cases.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r437740287", "createdAt": "2020-06-09T21:45:11Z", "author": {"login": "jkwatson"}, "path": "contrib/trace_propagators/src/main/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagator.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader>AWS\n+ * Tracing header spec</a>\n+ *\n+ * <p>To register the X-Ray propagator together with default propagator:\n+ *\n+ * <pre>{@code\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators\n+ *     .builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator())\n+ *     .build());\n+ * }</pre>\n+ */\n+public class AwsXRayPropagator implements HttpTextFormat {\n+\n+  @VisibleForTesting static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+\n+  private static final Logger logger = Logger.getLogger(AwsXRayPropagator.class.getName());\n+\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final int TRACE_ID_LENGTH = 35;\n+  private static final char TRACE_ID_VERSION = '1';\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_DELIMITER_INDEX_1 = 1;\n+  private static final int TRACE_ID_DELIMITER_INDEX_2 = 10;\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpan(context);\n+    if (!span.getContext().isValid()) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId =\n+        String.valueOf(TRACE_ID_VERSION)\n+            + TRACE_ID_DELIMITER\n+            + otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH)\n+            + TRACE_ID_DELIMITER\n+            + otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+    // TODO: Add OT trace state to the X-Ray trace header\n+\n+    String traceHeader =\n+        TRACE_ID_KEY\n+            + KV_DELIMITER\n+            + xrayTraceId\n+            + TRACE_HEADER_DELIMITER\n+            + PARENT_ID_KEY\n+            + KV_DELIMITER\n+            + parentId\n+            + TRACE_HEADER_DELIMITER\n+            + SAMPLED_FLAG_KEY\n+            + KV_DELIMITER\n+            + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    Objects.requireNonNull(carrier, \"carrier\");\n+    Objects.requireNonNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String traceHeader = getter.get(carrier, TRACE_HEADER_KEY);\n+    if (Strings.isNullOrEmpty(traceHeader)) {\n+      return SpanContext.getInvalid();\n+    }\n+\n+    TraceId traceId = TraceId.getInvalid();\n+    SpanId spanId = SpanId.getInvalid();\n+    TraceFlags traceFlags = TraceFlags.getDefault();\n+\n+    int pos = 0;\n+    while (pos < traceHeader.length()) {\n+      int delimiterIndex = traceHeader.indexOf(TRACE_HEADER_DELIMITER, pos);\n+      final String part;\n+      if (delimiterIndex >= 0) {\n+        part = traceHeader.substring(pos, delimiterIndex);\n+        pos = delimiterIndex + 1;\n+      } else {\n+        // Last part.\n+        part = traceHeader.substring(pos);\n+        pos = traceHeader.length();\n+      }\n+      String trimmedPart = part.trim();\n+      int equalsIndex = trimmedPart.indexOf(KV_DELIMITER);\n+      if (equalsIndex < 0) {\n+        logger.info(\n+            \"Error parsing X-Ray trace header. Invalid key value pair: \"\n+                + part\n+                + \" Returning INVALID span context.\");\n+        return SpanContext.getInvalid();\n+      }\n+\n+      String value = trimmedPart.substring(equalsIndex + 1);\n+\n+      if (trimmedPart.startsWith(TRACE_ID_KEY)) {\n+        traceId = parseTraceId(value);\n+      } else if (trimmedPart.startsWith(PARENT_ID_KEY)) {\n+        spanId = parseSpanId(value);\n+      } else if (trimmedPart.startsWith(SAMPLED_FLAG_KEY)) {\n+        traceFlags = parseTraceFlag(value);\n+      }\n+      // TODO: Put the arbitrary TraceHeader keys in OT trace state\n+    }\n+\n+    if (!traceId.isValid()) {\n+      logger.info(\n+          \"Invalid TraceId in X-Ray trace header: '\"\n+              + TRACE_HEADER_KEY\n+              + \"' with value \"\n+              + traceHeader\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    if (!spanId.isValid()) {\n+      logger.info(\n+          \"Invalid ParentId in X-Ray trace header: '\"\n+              + TRACE_HEADER_KEY\n+              + \"' with value \"\n+              + traceHeader\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    if (traceFlags == null) {\n+      logger.info(\n+          \"Invalid Sampling flag in X-Ray trace header: '\"\n+              + TRACE_HEADER_KEY\n+              + \"' with value \"\n+              + traceHeader\n+              + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    return SpanContext.createFromRemoteParent(traceId, spanId, traceFlags, TraceState.getDefault());\n+  }\n+\n+  private static TraceId parseTraceId(String xrayTraceId) {\n+    if (xrayTraceId.length() != TRACE_ID_LENGTH) {\n+      return TraceId.getInvalid();\n+    }\n+\n+    // Check version trace id version\n+    if (xrayTraceId.charAt(0) != TRACE_ID_VERSION) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f9491783f0e41f1acc9d7a7ae2e12c777253d1d"}, "originalPosition": 216}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NTcyMTAw", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#pullrequestreview-427572100", "createdAt": "2020-06-09T21:53:01Z", "commit": {"oid": "6f9491783f0e41f1acc9d7a7ae2e12c777253d1d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "70fd68a2980b1f0a0e21de0a7eb6534a2b0218be", "author": {"user": {"login": "shengxil", "name": "Shengxin Li"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/70fd68a2980b1f0a0e21de0a7eb6534a2b0218be", "committedDate": "2020-06-09T22:12:43Z", "message": "Using String trace id version"}, "afterCommit": {"oid": "43f42068d2aeea5639b357c4f1e6a291aed4c120", "author": {"user": {"login": "shengxil", "name": "Shengxin Li"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/43f42068d2aeea5639b357c4f1e6a291aed4c120", "committedDate": "2020-06-09T23:51:37Z", "message": "Add AWS X-Ray propagator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NjIxODc2", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#pullrequestreview-427621876", "createdAt": "2020-06-09T23:53:35Z", "commit": {"oid": "70fd68a2980b1f0a0e21de0a7eb6534a2b0218be"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMzo1NDo0MlrOGhgSFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMzo1NDo0MlrOGhgSFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc4NTEwOQ==", "bodyText": "I just realized that this means the B3 and Jaeger propagators now depend on guava. I'm concerned that will be surprising, and potentially lead to version conflicts down the road.\nOpinions, @carlosalberto and @bogdandrutu ?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r437785109", "createdAt": "2020-06-09T23:54:42Z", "author": {"login": "jkwatson"}, "path": "contrib/trace_propagators/build.gradle", "diffHunk": "@@ -12,6 +12,9 @@ ext.moduleName = \"io.opentelemetry.contrib.trace.propagation\"\n dependencies {\n     api project(':opentelemetry-api')\n \n+    implementation libraries.guava,\n+            platform(boms.guava)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43f42068d2aeea5639b357c4f1e6a291aed4c120"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3Njk4MTIy", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#pullrequestreview-427698122", "createdAt": "2020-06-10T04:13:33Z", "commit": {"oid": "43f42068d2aeea5639b357c4f1e6a291aed4c120"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNDoxMzozM1rOGhkOOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNDoxNTowNFrOGhkPhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0OTY1OA==", "bodyText": "We were initially working in the sdk_contrib repo and I think there it makes sense to use Guava where helpful since the sdk depends on it anyways. But agree for the API we don't really need it, at least for now.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r437849658", "createdAt": "2020-06-10T04:13:33Z", "author": {"login": "anuraaga"}, "path": "contrib/trace_propagators/build.gradle", "diffHunk": "@@ -12,6 +12,9 @@ ext.moduleName = \"io.opentelemetry.contrib.trace.propagation\"\n dependencies {\n     api project(':opentelemetry-api')\n \n+    implementation libraries.guava,\n+            platform(boms.guava)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc4NTEwOQ=="}, "originalCommit": {"oid": "43f42068d2aeea5639b357c4f1e6a291aed4c120"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0OTczMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @VisibleForTesting static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n          \n          \n            \n              // Visible for testing\n          \n          \n            \n              static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r437849732", "createdAt": "2020-06-10T04:13:49Z", "author": {"login": "anuraaga"}, "path": "contrib/trace_propagators/src/main/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagator.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader>AWS\n+ * Tracing header spec</a>\n+ *\n+ * <p>To register the X-Ray propagator together with default propagator:\n+ *\n+ * <pre>{@code\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators\n+ *     .builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator())\n+ *     .build());\n+ * }</pre>\n+ */\n+public class AwsXRayPropagator implements HttpTextFormat {\n+\n+  @VisibleForTesting static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43f42068d2aeea5639b357c4f1e6a291aed4c120"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0OTk5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (Strings.isNullOrEmpty(traceHeader)) {\n          \n          \n            \n                if (traceHeader == null || traceHeader.isEmpty()) {\n          \n      \n    \n    \n  \n\nFor just this one line I guess we may as well inline this rather than worry about guava or helper methods etc. Alternatively, we don't really need the empty check as an empty string is invalid and will always work with our below logic but it'd be somewhat less optimal. Not sure if a getter will return empty strings often enough for us to worry about it though.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r437849991", "createdAt": "2020-06-10T04:15:04Z", "author": {"login": "anuraaga"}, "path": "contrib/trace_propagators/src/main/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagator.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Implementation of the AWS X-Ray Trace Header propagation protocol. See <a href=\n+ * https://https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader>AWS\n+ * Tracing header spec</a>\n+ *\n+ * <p>To register the X-Ray propagator together with default propagator:\n+ *\n+ * <pre>{@code\n+ * OpenTelemetry.setPropagators(\n+ *   DefaultContextPropagators\n+ *     .builder()\n+ *     .addHttpTextFormat(new HttpTraceContext())\n+ *     .addHttpTextFormat(new AWSXRayPropagator())\n+ *     .build());\n+ * }</pre>\n+ */\n+public class AwsXRayPropagator implements HttpTextFormat {\n+\n+  @VisibleForTesting static final String TRACE_HEADER_KEY = \"X-Amzn-Trace-Id\";\n+\n+  private static final Logger logger = Logger.getLogger(AwsXRayPropagator.class.getName());\n+\n+  private static final char TRACE_HEADER_DELIMITER = ';';\n+  private static final char KV_DELIMITER = '=';\n+\n+  private static final String TRACE_ID_KEY = \"Root\";\n+  private static final int TRACE_ID_LENGTH = 35;\n+  private static final String TRACE_ID_VERSION = \"1\";\n+  private static final char TRACE_ID_DELIMITER = '-';\n+  private static final int TRACE_ID_DELIMITER_INDEX_1 = 1;\n+  private static final int TRACE_ID_DELIMITER_INDEX_2 = 10;\n+  private static final int TRACE_ID_FIRST_PART_LENGTH = 8;\n+\n+  private static final String PARENT_ID_KEY = \"Parent\";\n+  private static final int PARENT_ID_LENGTH = 16;\n+\n+  private static final String SAMPLED_FLAG_KEY = \"Sampled\";\n+  private static final int SAMPLED_FLAG_LENGTH = 1;\n+  private static final char IS_SAMPLED = '1';\n+  private static final char NOT_SAMPLED = '0';\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_HEADER_KEY);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, @Nullable C carrier, Setter<C> setter) {\n+    Objects.requireNonNull(context, \"context\");\n+    Objects.requireNonNull(setter, \"setter\");\n+\n+    Span span = TracingContextUtils.getSpan(context);\n+    if (!span.getContext().isValid()) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+\n+    String otTraceId = spanContext.getTraceId().toLowerBase16();\n+    String xrayTraceId =\n+        TRACE_ID_VERSION\n+            + TRACE_ID_DELIMITER\n+            + otTraceId.substring(0, TRACE_ID_FIRST_PART_LENGTH)\n+            + TRACE_ID_DELIMITER\n+            + otTraceId.substring(TRACE_ID_FIRST_PART_LENGTH);\n+    String parentId = spanContext.getSpanId().toLowerBase16();\n+    char samplingFlag = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+    // TODO: Add OT trace state to the X-Ray trace header\n+\n+    String traceHeader =\n+        TRACE_ID_KEY\n+            + KV_DELIMITER\n+            + xrayTraceId\n+            + TRACE_HEADER_DELIMITER\n+            + PARENT_ID_KEY\n+            + KV_DELIMITER\n+            + parentId\n+            + TRACE_HEADER_DELIMITER\n+            + SAMPLED_FLAG_KEY\n+            + KV_DELIMITER\n+            + samplingFlag;\n+    setter.set(carrier, TRACE_HEADER_KEY, traceHeader);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    Objects.requireNonNull(carrier, \"carrier\");\n+    Objects.requireNonNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String traceHeader = getter.get(carrier, TRACE_HEADER_KEY);\n+    if (Strings.isNullOrEmpty(traceHeader)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43f42068d2aeea5639b357c4f1e6a291aed4c120"}, "originalPosition": 135}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3Njk5MjY0", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#pullrequestreview-427699264", "createdAt": "2020-06-10T04:17:41Z", "commit": {"oid": "43f42068d2aeea5639b357c4f1e6a291aed4c120"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNDoxNzo0MVrOGhkR2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNDoxNzo0MVrOGhkR2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1MDU4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                implementation libraries.guava,\n          \n          \n            \n                        platform(boms.guava)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r437850587", "createdAt": "2020-06-10T04:17:41Z", "author": {"login": "anuraaga"}, "path": "contrib/trace_propagators/build.gradle", "diffHunk": "@@ -12,6 +12,9 @@ ext.moduleName = \"io.opentelemetry.contrib.trace.propagation\"\n dependencies {\n     api project(':opentelemetry-api')\n \n+    implementation libraries.guava,\n+            platform(boms.guava)\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43f42068d2aeea5639b357c4f1e6a291aed4c120"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3Njk5NDcw", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#pullrequestreview-427699470", "createdAt": "2020-06-10T04:18:25Z", "commit": {"oid": "43f42068d2aeea5639b357c4f1e6a291aed4c120"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNDoxODoyNVrOGhkSgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNDoxODoyNVrOGhkSgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1MDc1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import com.google.common.annotations.VisibleForTesting;\n          \n          \n            \n            import com.google.common.base.Strings;", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#discussion_r437850754", "createdAt": "2020-06-10T04:18:25Z", "author": {"login": "anuraaga"}, "path": "contrib/trace_propagators/src/main/java/io/opentelemetry/contrib/trace/propagation/AwsXRayPropagator.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.contrib.trace.propagation;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43f42068d2aeea5639b357c4f1e6a291aed4c120"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3Njk5NjUx", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#pullrequestreview-427699651", "createdAt": "2020-06-10T04:19:03Z", "commit": {"oid": "43f42068d2aeea5639b357c4f1e6a291aed4c120"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18be88b9cd084ed330a4cc099af5d780d327b7cb", "author": {"user": {"login": "shengxil", "name": "Shengxin Li"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/18be88b9cd084ed330a4cc099af5d780d327b7cb", "committedDate": "2020-06-10T18:35:38Z", "message": "Add AWS X-Ray propagator"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "43f42068d2aeea5639b357c4f1e6a291aed4c120", "author": {"user": {"login": "shengxil", "name": "Shengxin Li"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/43f42068d2aeea5639b357c4f1e6a291aed4c120", "committedDate": "2020-06-09T23:51:37Z", "message": "Add AWS X-Ray propagator"}, "afterCommit": {"oid": "18be88b9cd084ed330a4cc099af5d780d327b7cb", "author": {"user": {"login": "shengxil", "name": "Shengxin Li"}}, "url": "https://github.com/open-telemetry/opentelemetry-java/commit/18be88b9cd084ed330a4cc099af5d780d327b7cb", "committedDate": "2020-06-10T18:35:38Z", "message": "Add AWS X-Ray propagator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NDcwNTQ3", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1301#pullrequestreview-428470547", "createdAt": "2020-06-10T22:26:17Z", "commit": {"oid": "18be88b9cd084ed330a4cc099af5d780d327b7cb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2843, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}