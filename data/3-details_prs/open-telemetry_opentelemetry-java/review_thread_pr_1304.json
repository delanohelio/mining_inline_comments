{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3NDcyMjA2", "number": 1304, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOToxNjoxMFrOECeawg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMTowNzozN1rOEDRvMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDMwOTc4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOToxNjoxMFrOGe9BlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNToxMjoxNVrOGfyiYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMDI5Mw==", "bodyText": "Thanks! The API in this PR LGTM. Only comment is may stick with putAttribute instead of add, more familiar since it's inspired by Java's Map and conveys that duplicates are deduped.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r435110293", "createdAt": "2020-06-04T09:16:10Z", "author": {"login": "anuraaga"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the\n+ * attributes.\n+ */\n+@Immutable\n+public abstract class Attributes implements ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY =\n+      new Attributes() {\n+        @Override\n+        public void forEach(KeyValueConsumer<AttributeValue> consumer) {\n+          // no-op\n+        }\n+      };\n+\n+  private static Attributes sortAndFilter(Object... data) {\n+    return new AutoValue_Attributes_ArrayBackedAttributes(Helper.sortAndFilter(data));\n+  }\n+\n+  /** An {@link Attributes} instance with no attributes. */\n+  public static Attributes empty() {\n+    return EMPTY;\n+  }\n+\n+  /** An {@link Attributes} instance with a single key-value pair. */\n+  public static Attributes of(String key, AttributeValue value) {\n+    return sortAndFilter(key, value);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with two key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1, AttributeValue value1, String key2, AttributeValue value2) {\n+    return sortAndFilter(key1, value1, key2, value2);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with three key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3) {\n+    return sortAndFilter(key1, value1, key2, value2, key3, value3);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with four key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4) {\n+    return sortAndFilter(key1, value1, key2, value2, key3, value3, key4, value4);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with five key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4,\n+      String key5,\n+      AttributeValue value5) {\n+    return sortAndFilter(\n+        key1, value1,\n+        key2, value2,\n+        key3, value3,\n+        key4, value4,\n+        key5, value5);\n+  }\n+\n+  /** Creates a new {@link Builder} instance for creating arbitrary {@link Attributes}. */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    abstract List<Object> data();\n+\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    public void forEach(KeyValueConsumer<AttributeValue> consumer) {\n+      for (int i = 0; i < data().size(); i++) {\n+        consumer.consume((String) data().get(i), (AttributeValue) data().get(++i));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Enables the creation of an {@link Attributes} instance with an arbitrary number of key-value\n+   * pairs.\n+   */\n+  public static class Builder {\n+    private final List<Object> data = new ArrayList<>();\n+\n+    /** Create the {@link Attributes} from this. */\n+    public Attributes build() {\n+      return sortAndFilter(data.toArray());\n+    }\n+\n+    /**\n+     * Add a bare {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, AttributeValue value) {\n+      data.add(key);\n+      data.add(value);\n+      return this;\n+    }\n+\n+    /**\n+     * Add a String {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, String value) {\n+      data.add(key);\n+      data.add(stringAttributeValue(value));\n+      return this;\n+    }\n+\n+    /**\n+     * Add a long {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, long value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ec6c74b383b272a3bd6d6ed8240ed6dc433bc56"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMyMzA3OA==", "bodyText": "I'm fine with put*. I'll update.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r435323078", "createdAt": "2020-06-04T14:55:20Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the\n+ * attributes.\n+ */\n+@Immutable\n+public abstract class Attributes implements ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY =\n+      new Attributes() {\n+        @Override\n+        public void forEach(KeyValueConsumer<AttributeValue> consumer) {\n+          // no-op\n+        }\n+      };\n+\n+  private static Attributes sortAndFilter(Object... data) {\n+    return new AutoValue_Attributes_ArrayBackedAttributes(Helper.sortAndFilter(data));\n+  }\n+\n+  /** An {@link Attributes} instance with no attributes. */\n+  public static Attributes empty() {\n+    return EMPTY;\n+  }\n+\n+  /** An {@link Attributes} instance with a single key-value pair. */\n+  public static Attributes of(String key, AttributeValue value) {\n+    return sortAndFilter(key, value);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with two key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1, AttributeValue value1, String key2, AttributeValue value2) {\n+    return sortAndFilter(key1, value1, key2, value2);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with three key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3) {\n+    return sortAndFilter(key1, value1, key2, value2, key3, value3);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with four key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4) {\n+    return sortAndFilter(key1, value1, key2, value2, key3, value3, key4, value4);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with five key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4,\n+      String key5,\n+      AttributeValue value5) {\n+    return sortAndFilter(\n+        key1, value1,\n+        key2, value2,\n+        key3, value3,\n+        key4, value4,\n+        key5, value5);\n+  }\n+\n+  /** Creates a new {@link Builder} instance for creating arbitrary {@link Attributes}. */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    abstract List<Object> data();\n+\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    public void forEach(KeyValueConsumer<AttributeValue> consumer) {\n+      for (int i = 0; i < data().size(); i++) {\n+        consumer.consume((String) data().get(i), (AttributeValue) data().get(++i));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Enables the creation of an {@link Attributes} instance with an arbitrary number of key-value\n+   * pairs.\n+   */\n+  public static class Builder {\n+    private final List<Object> data = new ArrayList<>();\n+\n+    /** Create the {@link Attributes} from this. */\n+    public Attributes build() {\n+      return sortAndFilter(data.toArray());\n+    }\n+\n+    /**\n+     * Add a bare {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, AttributeValue value) {\n+      data.add(key);\n+      data.add(value);\n+      return this;\n+    }\n+\n+    /**\n+     * Add a String {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, String value) {\n+      data.add(key);\n+      data.add(stringAttributeValue(value));\n+      return this;\n+    }\n+\n+    /**\n+     * Add a long {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, long value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMDI5Mw=="}, "originalCommit": {"oid": "9ec6c74b383b272a3bd6d6ed8240ed6dc433bc56"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMyOTI1Mg==", "bodyText": "I'm wondering if we should have setAttribute() instead, to align this with Span.setAttribute(). No strong feeling though.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r435329252", "createdAt": "2020-06-04T15:03:20Z", "author": {"login": "carlosalberto"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the\n+ * attributes.\n+ */\n+@Immutable\n+public abstract class Attributes implements ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY =\n+      new Attributes() {\n+        @Override\n+        public void forEach(KeyValueConsumer<AttributeValue> consumer) {\n+          // no-op\n+        }\n+      };\n+\n+  private static Attributes sortAndFilter(Object... data) {\n+    return new AutoValue_Attributes_ArrayBackedAttributes(Helper.sortAndFilter(data));\n+  }\n+\n+  /** An {@link Attributes} instance with no attributes. */\n+  public static Attributes empty() {\n+    return EMPTY;\n+  }\n+\n+  /** An {@link Attributes} instance with a single key-value pair. */\n+  public static Attributes of(String key, AttributeValue value) {\n+    return sortAndFilter(key, value);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with two key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1, AttributeValue value1, String key2, AttributeValue value2) {\n+    return sortAndFilter(key1, value1, key2, value2);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with three key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3) {\n+    return sortAndFilter(key1, value1, key2, value2, key3, value3);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with four key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4) {\n+    return sortAndFilter(key1, value1, key2, value2, key3, value3, key4, value4);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with five key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4,\n+      String key5,\n+      AttributeValue value5) {\n+    return sortAndFilter(\n+        key1, value1,\n+        key2, value2,\n+        key3, value3,\n+        key4, value4,\n+        key5, value5);\n+  }\n+\n+  /** Creates a new {@link Builder} instance for creating arbitrary {@link Attributes}. */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    abstract List<Object> data();\n+\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    public void forEach(KeyValueConsumer<AttributeValue> consumer) {\n+      for (int i = 0; i < data().size(); i++) {\n+        consumer.consume((String) data().get(i), (AttributeValue) data().get(++i));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Enables the creation of an {@link Attributes} instance with an arbitrary number of key-value\n+   * pairs.\n+   */\n+  public static class Builder {\n+    private final List<Object> data = new ArrayList<>();\n+\n+    /** Create the {@link Attributes} from this. */\n+    public Attributes build() {\n+      return sortAndFilter(data.toArray());\n+    }\n+\n+    /**\n+     * Add a bare {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, AttributeValue value) {\n+      data.add(key);\n+      data.add(value);\n+      return this;\n+    }\n+\n+    /**\n+     * Add a String {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, String value) {\n+      data.add(key);\n+      data.add(stringAttributeValue(value));\n+      return this;\n+    }\n+\n+    /**\n+     * Add a long {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, long value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMDI5Mw=="}, "originalCommit": {"oid": "9ec6c74b383b272a3bd6d6ed8240ed6dc433bc56"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQxNzAzMQ==", "bodyText": "I'm totally fine, either way. @anuraaga , what do you think about setAttribute, rather than putAttribute ?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r435417031", "createdAt": "2020-06-04T17:11:46Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the\n+ * attributes.\n+ */\n+@Immutable\n+public abstract class Attributes implements ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY =\n+      new Attributes() {\n+        @Override\n+        public void forEach(KeyValueConsumer<AttributeValue> consumer) {\n+          // no-op\n+        }\n+      };\n+\n+  private static Attributes sortAndFilter(Object... data) {\n+    return new AutoValue_Attributes_ArrayBackedAttributes(Helper.sortAndFilter(data));\n+  }\n+\n+  /** An {@link Attributes} instance with no attributes. */\n+  public static Attributes empty() {\n+    return EMPTY;\n+  }\n+\n+  /** An {@link Attributes} instance with a single key-value pair. */\n+  public static Attributes of(String key, AttributeValue value) {\n+    return sortAndFilter(key, value);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with two key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1, AttributeValue value1, String key2, AttributeValue value2) {\n+    return sortAndFilter(key1, value1, key2, value2);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with three key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3) {\n+    return sortAndFilter(key1, value1, key2, value2, key3, value3);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with four key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4) {\n+    return sortAndFilter(key1, value1, key2, value2, key3, value3, key4, value4);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with five key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4,\n+      String key5,\n+      AttributeValue value5) {\n+    return sortAndFilter(\n+        key1, value1,\n+        key2, value2,\n+        key3, value3,\n+        key4, value4,\n+        key5, value5);\n+  }\n+\n+  /** Creates a new {@link Builder} instance for creating arbitrary {@link Attributes}. */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    abstract List<Object> data();\n+\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    public void forEach(KeyValueConsumer<AttributeValue> consumer) {\n+      for (int i = 0; i < data().size(); i++) {\n+        consumer.consume((String) data().get(i), (AttributeValue) data().get(++i));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Enables the creation of an {@link Attributes} instance with an arbitrary number of key-value\n+   * pairs.\n+   */\n+  public static class Builder {\n+    private final List<Object> data = new ArrayList<>();\n+\n+    /** Create the {@link Attributes} from this. */\n+    public Attributes build() {\n+      return sortAndFilter(data.toArray());\n+    }\n+\n+    /**\n+     * Add a bare {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, AttributeValue value) {\n+      data.add(key);\n+      data.add(value);\n+      return this;\n+    }\n+\n+    /**\n+     * Add a String {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, String value) {\n+      data.add(key);\n+      data.add(stringAttributeValue(value));\n+      return this;\n+    }\n+\n+    /**\n+     * Add a long {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, long value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMDI5Mw=="}, "originalCommit": {"oid": "9ec6c74b383b272a3bd6d6ed8240ed6dc433bc56"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUxMTExNQ==", "bodyText": "+1 for setAttribute, to align with Span.setAttribute", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r435511115", "createdAt": "2020-06-04T19:51:34Z", "author": {"login": "trask"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the\n+ * attributes.\n+ */\n+@Immutable\n+public abstract class Attributes implements ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY =\n+      new Attributes() {\n+        @Override\n+        public void forEach(KeyValueConsumer<AttributeValue> consumer) {\n+          // no-op\n+        }\n+      };\n+\n+  private static Attributes sortAndFilter(Object... data) {\n+    return new AutoValue_Attributes_ArrayBackedAttributes(Helper.sortAndFilter(data));\n+  }\n+\n+  /** An {@link Attributes} instance with no attributes. */\n+  public static Attributes empty() {\n+    return EMPTY;\n+  }\n+\n+  /** An {@link Attributes} instance with a single key-value pair. */\n+  public static Attributes of(String key, AttributeValue value) {\n+    return sortAndFilter(key, value);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with two key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1, AttributeValue value1, String key2, AttributeValue value2) {\n+    return sortAndFilter(key1, value1, key2, value2);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with three key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3) {\n+    return sortAndFilter(key1, value1, key2, value2, key3, value3);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with four key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4) {\n+    return sortAndFilter(key1, value1, key2, value2, key3, value3, key4, value4);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with five key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4,\n+      String key5,\n+      AttributeValue value5) {\n+    return sortAndFilter(\n+        key1, value1,\n+        key2, value2,\n+        key3, value3,\n+        key4, value4,\n+        key5, value5);\n+  }\n+\n+  /** Creates a new {@link Builder} instance for creating arbitrary {@link Attributes}. */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    abstract List<Object> data();\n+\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    public void forEach(KeyValueConsumer<AttributeValue> consumer) {\n+      for (int i = 0; i < data().size(); i++) {\n+        consumer.consume((String) data().get(i), (AttributeValue) data().get(++i));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Enables the creation of an {@link Attributes} instance with an arbitrary number of key-value\n+   * pairs.\n+   */\n+  public static class Builder {\n+    private final List<Object> data = new ArrayList<>();\n+\n+    /** Create the {@link Attributes} from this. */\n+    public Attributes build() {\n+      return sortAndFilter(data.toArray());\n+    }\n+\n+    /**\n+     * Add a bare {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, AttributeValue value) {\n+      data.add(key);\n+      data.add(value);\n+      return this;\n+    }\n+\n+    /**\n+     * Add a String {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, String value) {\n+      data.add(key);\n+      data.add(stringAttributeValue(value));\n+      return this;\n+    }\n+\n+    /**\n+     * Add a long {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, long value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMDI5Mw=="}, "originalCommit": {"oid": "9ec6c74b383b272a3bd6d6ed8240ed6dc433bc56"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUxMTc5MA==", "bodyText": "ok, I'll assume @anuraaga is ok, and if not, we can change it.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r435511790", "createdAt": "2020-06-04T19:52:53Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the\n+ * attributes.\n+ */\n+@Immutable\n+public abstract class Attributes implements ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY =\n+      new Attributes() {\n+        @Override\n+        public void forEach(KeyValueConsumer<AttributeValue> consumer) {\n+          // no-op\n+        }\n+      };\n+\n+  private static Attributes sortAndFilter(Object... data) {\n+    return new AutoValue_Attributes_ArrayBackedAttributes(Helper.sortAndFilter(data));\n+  }\n+\n+  /** An {@link Attributes} instance with no attributes. */\n+  public static Attributes empty() {\n+    return EMPTY;\n+  }\n+\n+  /** An {@link Attributes} instance with a single key-value pair. */\n+  public static Attributes of(String key, AttributeValue value) {\n+    return sortAndFilter(key, value);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with two key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1, AttributeValue value1, String key2, AttributeValue value2) {\n+    return sortAndFilter(key1, value1, key2, value2);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with three key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3) {\n+    return sortAndFilter(key1, value1, key2, value2, key3, value3);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with four key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4) {\n+    return sortAndFilter(key1, value1, key2, value2, key3, value3, key4, value4);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with five key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4,\n+      String key5,\n+      AttributeValue value5) {\n+    return sortAndFilter(\n+        key1, value1,\n+        key2, value2,\n+        key3, value3,\n+        key4, value4,\n+        key5, value5);\n+  }\n+\n+  /** Creates a new {@link Builder} instance for creating arbitrary {@link Attributes}. */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    abstract List<Object> data();\n+\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    public void forEach(KeyValueConsumer<AttributeValue> consumer) {\n+      for (int i = 0; i < data().size(); i++) {\n+        consumer.consume((String) data().get(i), (AttributeValue) data().get(++i));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Enables the creation of an {@link Attributes} instance with an arbitrary number of key-value\n+   * pairs.\n+   */\n+  public static class Builder {\n+    private final List<Object> data = new ArrayList<>();\n+\n+    /** Create the {@link Attributes} from this. */\n+    public Attributes build() {\n+      return sortAndFilter(data.toArray());\n+    }\n+\n+    /**\n+     * Add a bare {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, AttributeValue value) {\n+      data.add(key);\n+      data.add(value);\n+      return this;\n+    }\n+\n+    /**\n+     * Add a String {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, String value) {\n+      data.add(key);\n+      data.add(stringAttributeValue(value));\n+      return this;\n+    }\n+\n+    /**\n+     * Add a long {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, long value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMDI5Mw=="}, "originalCommit": {"oid": "9ec6c74b383b272a3bd6d6ed8240ed6dc433bc56"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyODMzNw==", "bodyText": "done.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r435528337", "createdAt": "2020-06-04T20:25:32Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the\n+ * attributes.\n+ */\n+@Immutable\n+public abstract class Attributes implements ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY =\n+      new Attributes() {\n+        @Override\n+        public void forEach(KeyValueConsumer<AttributeValue> consumer) {\n+          // no-op\n+        }\n+      };\n+\n+  private static Attributes sortAndFilter(Object... data) {\n+    return new AutoValue_Attributes_ArrayBackedAttributes(Helper.sortAndFilter(data));\n+  }\n+\n+  /** An {@link Attributes} instance with no attributes. */\n+  public static Attributes empty() {\n+    return EMPTY;\n+  }\n+\n+  /** An {@link Attributes} instance with a single key-value pair. */\n+  public static Attributes of(String key, AttributeValue value) {\n+    return sortAndFilter(key, value);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with two key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1, AttributeValue value1, String key2, AttributeValue value2) {\n+    return sortAndFilter(key1, value1, key2, value2);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with three key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3) {\n+    return sortAndFilter(key1, value1, key2, value2, key3, value3);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with four key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4) {\n+    return sortAndFilter(key1, value1, key2, value2, key3, value3, key4, value4);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with five key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4,\n+      String key5,\n+      AttributeValue value5) {\n+    return sortAndFilter(\n+        key1, value1,\n+        key2, value2,\n+        key3, value3,\n+        key4, value4,\n+        key5, value5);\n+  }\n+\n+  /** Creates a new {@link Builder} instance for creating arbitrary {@link Attributes}. */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    abstract List<Object> data();\n+\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    public void forEach(KeyValueConsumer<AttributeValue> consumer) {\n+      for (int i = 0; i < data().size(); i++) {\n+        consumer.consume((String) data().get(i), (AttributeValue) data().get(++i));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Enables the creation of an {@link Attributes} instance with an arbitrary number of key-value\n+   * pairs.\n+   */\n+  public static class Builder {\n+    private final List<Object> data = new ArrayList<>();\n+\n+    /** Create the {@link Attributes} from this. */\n+    public Attributes build() {\n+      return sortAndFilter(data.toArray());\n+    }\n+\n+    /**\n+     * Add a bare {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, AttributeValue value) {\n+      data.add(key);\n+      data.add(value);\n+      return this;\n+    }\n+\n+    /**\n+     * Add a String {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, String value) {\n+      data.add(key);\n+      data.add(stringAttributeValue(value));\n+      return this;\n+    }\n+\n+    /**\n+     * Add a long {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, long value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMDI5Mw=="}, "originalCommit": {"oid": "9ec6c74b383b272a3bd6d6ed8240ed6dc433bc56"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk4NzA0MQ==", "bodyText": "Sorry for the late SGTM", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r435987041", "createdAt": "2020-06-05T15:12:15Z", "author": {"login": "anuraaga"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the\n+ * attributes.\n+ */\n+@Immutable\n+public abstract class Attributes implements ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY =\n+      new Attributes() {\n+        @Override\n+        public void forEach(KeyValueConsumer<AttributeValue> consumer) {\n+          // no-op\n+        }\n+      };\n+\n+  private static Attributes sortAndFilter(Object... data) {\n+    return new AutoValue_Attributes_ArrayBackedAttributes(Helper.sortAndFilter(data));\n+  }\n+\n+  /** An {@link Attributes} instance with no attributes. */\n+  public static Attributes empty() {\n+    return EMPTY;\n+  }\n+\n+  /** An {@link Attributes} instance with a single key-value pair. */\n+  public static Attributes of(String key, AttributeValue value) {\n+    return sortAndFilter(key, value);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with two key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1, AttributeValue value1, String key2, AttributeValue value2) {\n+    return sortAndFilter(key1, value1, key2, value2);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with three key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3) {\n+    return sortAndFilter(key1, value1, key2, value2, key3, value3);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with four key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4) {\n+    return sortAndFilter(key1, value1, key2, value2, key3, value3, key4, value4);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with five key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4,\n+      String key5,\n+      AttributeValue value5) {\n+    return sortAndFilter(\n+        key1, value1,\n+        key2, value2,\n+        key3, value3,\n+        key4, value4,\n+        key5, value5);\n+  }\n+\n+  /** Creates a new {@link Builder} instance for creating arbitrary {@link Attributes}. */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    abstract List<Object> data();\n+\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    public void forEach(KeyValueConsumer<AttributeValue> consumer) {\n+      for (int i = 0; i < data().size(); i++) {\n+        consumer.consume((String) data().get(i), (AttributeValue) data().get(++i));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Enables the creation of an {@link Attributes} instance with an arbitrary number of key-value\n+   * pairs.\n+   */\n+  public static class Builder {\n+    private final List<Object> data = new ArrayList<>();\n+\n+    /** Create the {@link Attributes} from this. */\n+    public Attributes build() {\n+      return sortAndFilter(data.toArray());\n+    }\n+\n+    /**\n+     * Add a bare {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, AttributeValue value) {\n+      data.add(key);\n+      data.add(value);\n+      return this;\n+    }\n+\n+    /**\n+     * Add a String {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, String value) {\n+      data.add(key);\n+      data.add(stringAttributeValue(value));\n+      return this;\n+    }\n+\n+    /**\n+     * Add a long {@link AttributeValue} to this.\n+     *\n+     * @return this Builder\n+     */\n+    public Builder addAttribute(String key, long value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMDI5Mw=="}, "originalCommit": {"oid": "9ec6c74b383b272a3bd6d6ed8240ed6dc433bc56"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTMwMTE0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMzoxNTo1M1rOGfuBWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNTo0MDowOFrOGfznUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkxMzA1MQ==", "bodyText": "Guessing you wrote this you don't want to use Arrays.sort(), which uses merge sort (and more memory)? If that's the case, adding a note for further reference would be nice.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r435913051", "createdAt": "2020-06-05T13:15:53Z", "author": {"login": "carlosalberto"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+public interface ImmutableKeyValuePairs<V> {\n+  /** Iterates over all the key-value pairs of attributes contained by this instance. */\n+  void forEach(KeyValueConsumer<V> consumer);\n+\n+  /**\n+   * Used for iterating over the key-value pairs contained by an {@link ImmutableKeyValuePairs}\n+   * instance.\n+   */\n+  interface KeyValueConsumer<T> {\n+    void consume(String key, T value);\n+  }\n+\n+  class Helper {\n+    private Helper() {}\n+\n+    static <T> List<Object> sortAndFilter(Object[] data) {\n+      checkArgument(\n+          data.length % 2 == 0, \"You must provide an even number of key/value pair arguments.\");\n+\n+      quickSort(data, 0, data.length - 2);\n+      return dedupe(data);\n+    }\n+\n+    private static void quickSort(Object[] data, int leftIndex, int rightIndex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "029d3e24250237bd8d24a1c15aaab278f8040889"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk3NDQ2NA==", "bodyText": "I don't know of a way to use Arrays.sort() to sort only based on every other value, and keep the pairs together.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r435974464", "createdAt": "2020-06-05T14:51:46Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+public interface ImmutableKeyValuePairs<V> {\n+  /** Iterates over all the key-value pairs of attributes contained by this instance. */\n+  void forEach(KeyValueConsumer<V> consumer);\n+\n+  /**\n+   * Used for iterating over the key-value pairs contained by an {@link ImmutableKeyValuePairs}\n+   * instance.\n+   */\n+  interface KeyValueConsumer<T> {\n+    void consume(String key, T value);\n+  }\n+\n+  class Helper {\n+    private Helper() {}\n+\n+    static <T> List<Object> sortAndFilter(Object[] data) {\n+      checkArgument(\n+          data.length % 2 == 0, \"You must provide an even number of key/value pair arguments.\");\n+\n+      quickSort(data, 0, data.length - 2);\n+      return dedupe(data);\n+    }\n+\n+    private static void quickSort(Object[] data, int leftIndex, int rightIndex) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkxMzA1MQ=="}, "originalCommit": {"oid": "029d3e24250237bd8d24a1c15aaab278f8040889"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNDY4OQ==", "bodyText": "Oooh, right. I totally forgot about that part ;)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436004689", "createdAt": "2020-06-05T15:40:08Z", "author": {"login": "carlosalberto"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+public interface ImmutableKeyValuePairs<V> {\n+  /** Iterates over all the key-value pairs of attributes contained by this instance. */\n+  void forEach(KeyValueConsumer<V> consumer);\n+\n+  /**\n+   * Used for iterating over the key-value pairs contained by an {@link ImmutableKeyValuePairs}\n+   * instance.\n+   */\n+  interface KeyValueConsumer<T> {\n+    void consume(String key, T value);\n+  }\n+\n+  class Helper {\n+    private Helper() {}\n+\n+    static <T> List<Object> sortAndFilter(Object[] data) {\n+      checkArgument(\n+          data.length % 2 == 0, \"You must provide an even number of key/value pair arguments.\");\n+\n+      quickSort(data, 0, data.length - 2);\n+      return dedupe(data);\n+    }\n+\n+    private static void quickSort(Object[] data, int leftIndex, int rightIndex) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkxMzA1MQ=="}, "originalCommit": {"oid": "029d3e24250237bd8d24a1c15aaab278f8040889"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNTY1NTA0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNDo0NTo1OFrOGfxjOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNjo0NzowOFrOGgKl2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk3MDg3Mw==", "bodyText": "This can be package protected, no need to expose it public. Also why do you not make this an abstract class with all the utils inside it. It will remove some duplicate code between Labels and Attributes.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r435970873", "createdAt": "2020-06-05T14:45:58Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+public interface ImmutableKeyValuePairs<V> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "029d3e24250237bd8d24a1c15aaab278f8040889"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk3NTQ2Ng==", "bodyText": "I'll give it a try. Originally, I was hoping this could be a single-method-interface, and hence implementable as a lambda, but that won't be possible once we add isEmpty() and size().", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r435975466", "createdAt": "2020-06-05T14:53:17Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+public interface ImmutableKeyValuePairs<V> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk3MDg3Mw=="}, "originalCommit": {"oid": "029d3e24250237bd8d24a1c15aaab278f8040889"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk3OTE3Nw==", "bodyText": "Also, if we make this interface package-protected, we'll need to move the consumer interface up out of it. Not a big deal, but it is a consequence.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r435979177", "createdAt": "2020-06-05T14:59:00Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+public interface ImmutableKeyValuePairs<V> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk3MDg3Mw=="}, "originalCommit": {"oid": "029d3e24250237bd8d24a1c15aaab278f8040889"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAyMzA1OQ==", "bodyText": "That can be public correct.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436023059", "createdAt": "2020-06-05T16:12:33Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+public interface ImmutableKeyValuePairs<V> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk3MDg3Mw=="}, "originalCommit": {"oid": "029d3e24250237bd8d24a1c15aaab278f8040889"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4MzUxNQ==", "bodyText": "ok, update and pushed. PTaL", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436183515", "createdAt": "2020-06-05T22:01:02Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+public interface ImmutableKeyValuePairs<V> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk3MDg3Mw=="}, "originalCommit": {"oid": "029d3e24250237bd8d24a1c15aaab278f8040889"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM4MTE0Nw==", "bodyText": "i'm not super happy with the change to an abstract class, but we can address in the future.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436381147", "createdAt": "2020-06-07T16:47:08Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+public interface ImmutableKeyValuePairs<V> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk3MDg3Mw=="}, "originalCommit": {"oid": "029d3e24250237bd8d24a1c15aaab278f8040889"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzIzMTgzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMTozMDo0N1rOGgBEow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNjo0NjozOFrOGgKlrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNTE4Nw==", "bodyText": "Recommend leaving this abstract and having EMPTY use the value implementation passing in empty list. Don't need to have yet more implementations of the abstract type for the empty types.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436225187", "createdAt": "2020-06-06T01:30:47Z", "author": {"login": "anuraaga"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+abstract class ImmutableKeyValuePairs<V> {\n+\n+  List<Object> data() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNzQ3MA==", "bodyText": "Also, since this is internal consider Object[] for a bit less overhead.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436227470", "createdAt": "2020-06-06T01:59:22Z", "author": {"login": "anuraaga"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+abstract class ImmutableKeyValuePairs<V> {\n+\n+  List<Object> data() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNTE4Nw=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyOTQyNg==", "bodyText": "I wish I could, but if we want to use AutoValue for the implementation, it needs a list. :(", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436229426", "createdAt": "2020-06-06T02:27:24Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+abstract class ImmutableKeyValuePairs<V> {\n+\n+  List<Object> data() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNTE4Nw=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3ODg4Mg==", "bodyText": "I actually think that the previous incarnation where this was an interface was easier to understand. Even though it ends up with like 6-8 lines of duplicated code, I think it's actually a better design to this be an interface.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436278882", "createdAt": "2020-06-06T15:50:06Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+abstract class ImmutableKeyValuePairs<V> {\n+\n+  List<Object> data() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNTE4Nw=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM4MTEwMQ==", "bodyText": "this is going to change in the next PR, with the addition of 2 new methods. will address there.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436381101", "createdAt": "2020-06-07T16:46:38Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+abstract class ImmutableKeyValuePairs<V> {\n+\n+  List<Object> data() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNTE4Nw=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzIzNTc1OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMTozNzowMlrOGgBGsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNjozMzo0MFrOGgKhkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNTcxNA==", "bodyText": "Just wondering, do we need to sort attributes? I guess labels are sorted because of Prometheus. It's ok if it's to keep generic but curious. I think attributes can commonly be created per span instead of being singletons so this sorting would add up.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436225714", "createdAt": "2020-06-06T01:37:02Z", "author": {"login": "anuraaga"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the\n+ * attributes.\n+ */\n+@Immutable\n+public abstract class Attributes extends ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY = new Attributes() {};\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    abstract List<Object> data();\n+  }\n+\n+  /** An {@link Attributes} instance with no attributes. */\n+  public static Attributes empty() {\n+    return EMPTY;\n+  }\n+\n+  /** An {@link Attributes} instance with a single key-value pair. */\n+  public static Attributes of(String key, AttributeValue value) {\n+    return sortAndFilterToAttributes(key, value);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with two key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1, AttributeValue value1, String key2, AttributeValue value2) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with three key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2, key3, value3);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with four key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2, key3, value3, key4, value4);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with five key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4,\n+      String key5,\n+      AttributeValue value5) {\n+    return sortAndFilterToAttributes(\n+        key1, value1,\n+        key2, value2,\n+        key3, value3,\n+        key4, value4,\n+        key5, value5);\n+  }\n+\n+  private static Attributes sortAndFilterToAttributes(Object... data) {\n+    return new AutoValue_Attributes_ArrayBackedAttributes(sortAndFilter(data));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNjk5MQ==", "bodyText": "Otherwise we could add a quick check that the data is already sorted and deduped and bypass the logic. If users notice the sorting showing up in profiles they can reorder their code to speed it up.\nFor reference I have had users report this exact sort of issue line/armeria#2150", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436226991", "createdAt": "2020-06-06T01:52:26Z", "author": {"login": "anuraaga"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the\n+ * attributes.\n+ */\n+@Immutable\n+public abstract class Attributes extends ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY = new Attributes() {};\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    abstract List<Object> data();\n+  }\n+\n+  /** An {@link Attributes} instance with no attributes. */\n+  public static Attributes empty() {\n+    return EMPTY;\n+  }\n+\n+  /** An {@link Attributes} instance with a single key-value pair. */\n+  public static Attributes of(String key, AttributeValue value) {\n+    return sortAndFilterToAttributes(key, value);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with two key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1, AttributeValue value1, String key2, AttributeValue value2) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with three key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2, key3, value3);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with four key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2, key3, value3, key4, value4);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with five key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4,\n+      String key5,\n+      AttributeValue value5) {\n+    return sortAndFilterToAttributes(\n+        key1, value1,\n+        key2, value2,\n+        key3, value3,\n+        key4, value4,\n+        key5, value5);\n+  }\n+\n+  private static Attributes sortAndFilterToAttributes(Object... data) {\n+    return new AutoValue_Attributes_ArrayBackedAttributes(sortAndFilter(data));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNTcxNA=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyOTE2Nw==", "bodyText": "The sorting is just for making the equals/hashcode work out right.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436229167", "createdAt": "2020-06-06T02:24:10Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the\n+ * attributes.\n+ */\n+@Immutable\n+public abstract class Attributes extends ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY = new Attributes() {};\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    abstract List<Object> data();\n+  }\n+\n+  /** An {@link Attributes} instance with no attributes. */\n+  public static Attributes empty() {\n+    return EMPTY;\n+  }\n+\n+  /** An {@link Attributes} instance with a single key-value pair. */\n+  public static Attributes of(String key, AttributeValue value) {\n+    return sortAndFilterToAttributes(key, value);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with two key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1, AttributeValue value1, String key2, AttributeValue value2) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with three key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2, key3, value3);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with four key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2, key3, value3, key4, value4);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with five key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4,\n+      String key5,\n+      AttributeValue value5) {\n+    return sortAndFilterToAttributes(\n+        key1, value1,\n+        key2, value2,\n+        key3, value3,\n+        key4, value4,\n+        key5, value5);\n+  }\n+\n+  private static Attributes sortAndFilterToAttributes(Object... data) {\n+    return new AutoValue_Attributes_ArrayBackedAttributes(sortAndFilter(data));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNTcxNA=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMjM3NA==", "bodyText": "I guess you can do the equals/hash in n^2 and will be as good as sorting + equals check for less than 10 labels. You may want to give a try and a benchmark", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436232374", "createdAt": "2020-06-06T03:12:41Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the\n+ * attributes.\n+ */\n+@Immutable\n+public abstract class Attributes extends ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY = new Attributes() {};\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    abstract List<Object> data();\n+  }\n+\n+  /** An {@link Attributes} instance with no attributes. */\n+  public static Attributes empty() {\n+    return EMPTY;\n+  }\n+\n+  /** An {@link Attributes} instance with a single key-value pair. */\n+  public static Attributes of(String key, AttributeValue value) {\n+    return sortAndFilterToAttributes(key, value);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with two key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1, AttributeValue value1, String key2, AttributeValue value2) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with three key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2, key3, value3);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with four key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2, key3, value3, key4, value4);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with five key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4,\n+      String key5,\n+      AttributeValue value5) {\n+    return sortAndFilterToAttributes(\n+        key1, value1,\n+        key2, value2,\n+        key3, value3,\n+        key4, value4,\n+        key5, value5);\n+  }\n+\n+  private static Attributes sortAndFilterToAttributes(Object... data) {\n+    return new AutoValue_Attributes_ArrayBackedAttributes(sortAndFilter(data));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNTcxNA=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3ODk5NA==", "bodyText": "I'd like to save this kind of micro-optimization until after the API lands, and we can parellelize the work with using this for the APIs and doing optimizations. On my branch where I use this for Events and Links, this is already a significant improvement (~10% better) in both speed and memory allocations than the existing implementation.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436278994", "createdAt": "2020-06-06T15:51:32Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the\n+ * attributes.\n+ */\n+@Immutable\n+public abstract class Attributes extends ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY = new Attributes() {};\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    abstract List<Object> data();\n+  }\n+\n+  /** An {@link Attributes} instance with no attributes. */\n+  public static Attributes empty() {\n+    return EMPTY;\n+  }\n+\n+  /** An {@link Attributes} instance with a single key-value pair. */\n+  public static Attributes of(String key, AttributeValue value) {\n+    return sortAndFilterToAttributes(key, value);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with two key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1, AttributeValue value1, String key2, AttributeValue value2) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with three key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2, key3, value3);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with four key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2, key3, value3, key4, value4);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with five key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4,\n+      String key5,\n+      AttributeValue value5) {\n+    return sortAndFilterToAttributes(\n+        key1, value1,\n+        key2, value2,\n+        key3, value3,\n+        key4, value4,\n+        key5, value5);\n+  }\n+\n+  private static Attributes sortAndFilterToAttributes(Object... data) {\n+    return new AutoValue_Attributes_ArrayBackedAttributes(sortAndFilter(data));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNTcxNA=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDQyNw==", "bodyText": "I think just a dump n^2 is simpler than quicksort + dedup on sorted array.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436284427", "createdAt": "2020-06-06T17:07:27Z", "author": {"login": "bogdandrutu"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the\n+ * attributes.\n+ */\n+@Immutable\n+public abstract class Attributes extends ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY = new Attributes() {};\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    abstract List<Object> data();\n+  }\n+\n+  /** An {@link Attributes} instance with no attributes. */\n+  public static Attributes empty() {\n+    return EMPTY;\n+  }\n+\n+  /** An {@link Attributes} instance with a single key-value pair. */\n+  public static Attributes of(String key, AttributeValue value) {\n+    return sortAndFilterToAttributes(key, value);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with two key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1, AttributeValue value1, String key2, AttributeValue value2) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with three key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2, key3, value3);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with four key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2, key3, value3, key4, value4);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with five key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4,\n+      String key5,\n+      AttributeValue value5) {\n+    return sortAndFilterToAttributes(\n+        key1, value1,\n+        key2, value2,\n+        key3, value3,\n+        key4, value4,\n+        key5, value5);\n+  }\n+\n+  private static Attributes sortAndFilterToAttributes(Object... data) {\n+    return new AutoValue_Attributes_ArrayBackedAttributes(sortAndFilter(data));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNTcxNA=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NjYyMA==", "bodyText": "ok to save that for a follow-on PR?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436286620", "createdAt": "2020-06-06T17:38:10Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the\n+ * attributes.\n+ */\n+@Immutable\n+public abstract class Attributes extends ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY = new Attributes() {};\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    abstract List<Object> data();\n+  }\n+\n+  /** An {@link Attributes} instance with no attributes. */\n+  public static Attributes empty() {\n+    return EMPTY;\n+  }\n+\n+  /** An {@link Attributes} instance with a single key-value pair. */\n+  public static Attributes of(String key, AttributeValue value) {\n+    return sortAndFilterToAttributes(key, value);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with two key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1, AttributeValue value1, String key2, AttributeValue value2) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with three key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2, key3, value3);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with four key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2, key3, value3, key4, value4);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with five key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4,\n+      String key5,\n+      AttributeValue value5) {\n+    return sortAndFilterToAttributes(\n+        key1, value1,\n+        key2, value2,\n+        key3, value3,\n+        key4, value4,\n+        key5, value5);\n+  }\n+\n+  private static Attributes sortAndFilterToAttributes(Object... data) {\n+    return new AutoValue_Attributes_ArrayBackedAttributes(sortAndFilter(data));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNTcxNA=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM4MDA1MA==", "bodyText": "Just a thought on sorting...if we do need key-lookup in the future, having the keys sorted makes binary searching easy.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436380050", "createdAt": "2020-06-07T16:33:40Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the\n+ * attributes.\n+ */\n+@Immutable\n+public abstract class Attributes extends ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY = new Attributes() {};\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    abstract List<Object> data();\n+  }\n+\n+  /** An {@link Attributes} instance with no attributes. */\n+  public static Attributes empty() {\n+    return EMPTY;\n+  }\n+\n+  /** An {@link Attributes} instance with a single key-value pair. */\n+  public static Attributes of(String key, AttributeValue value) {\n+    return sortAndFilterToAttributes(key, value);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with two key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1, AttributeValue value1, String key2, AttributeValue value2) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with three key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2, key3, value3);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with four key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2, key3, value3, key4, value4);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with five key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4,\n+      String key5,\n+      AttributeValue value5) {\n+    return sortAndFilterToAttributes(\n+        key1, value1,\n+        key2, value2,\n+        key3, value3,\n+        key4, value4,\n+        key5, value5);\n+  }\n+\n+  private static Attributes sortAndFilterToAttributes(Object... data) {\n+    return new AutoValue_Attributes_ArrayBackedAttributes(sortAndFilter(data));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNTcxNA=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzIzNjgwOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMTozODo1NFrOGgBHRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNjo0NjowMVrOGgKlfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNTg2Mg==", "bodyText": "I think this is a user API so can't throw per 1)\nhttps://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/error-handling.md#basic-error-handling-principles", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436225862", "createdAt": "2020-06-06T01:38:54Z", "author": {"login": "anuraaga"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+abstract class ImmutableKeyValuePairs<V> {\n+\n+  List<Object> data() {\n+    return Collections.emptyList();\n+  }\n+\n+  /** Iterates over all the key-value pairs of attributes contained by this instance. */\n+  @SuppressWarnings(\"unchecked\")\n+  public void forEach(KeyValueConsumer<V> consumer) {\n+    for (int i = 0; i < data().size(); i += 2) {\n+      consumer.consume((String) data().get(i), (V) data().get(i + 1));\n+    }\n+  }\n+\n+  static List<Object> sortAndFilter(Object[] data) {\n+    checkArgument(\n+        data.length % 2 == 0, \"You must provide an even number of key/value pair arguments.\");\n+\n+    quickSort(data, 0, data.length - 2);\n+    return dedupe(data);\n+  }\n+\n+  private static void quickSort(Object[] data, int leftIndex, int rightIndex) {\n+    if (leftIndex >= rightIndex) {\n+      return;\n+    }\n+\n+    String pivotKey = (String) data[rightIndex];\n+    int counter = leftIndex;\n+\n+    for (int i = leftIndex; i <= rightIndex; i += 2) {\n+      if (((String) data[i]).compareTo(pivotKey) <= 0) {\n+        swap(data, counter, i);\n+        counter += 2;\n+      }\n+    }\n+\n+    quickSort(data, leftIndex, counter - 4);\n+    quickSort(data, counter, rightIndex);\n+  }\n+\n+  private static List<Object> dedupe(Object[] data) {\n+    List<Object> result = new ArrayList<>(data.length);\n+    Object previousKey = null;\n+\n+    for (int i = 0; i < data.length; i += 2) {\n+      Object key = data[i];\n+      Object value = data[i + 1];\n+      checkNotNull(key, \"You cannot provide null keys for creation of attributes.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyOTQwNg==", "bodyText": "hmm. null keys seems like a pretty bad problem. what do you suggest we do if some instrumentation puts in a null key?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436229406", "createdAt": "2020-06-06T02:27:00Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+abstract class ImmutableKeyValuePairs<V> {\n+\n+  List<Object> data() {\n+    return Collections.emptyList();\n+  }\n+\n+  /** Iterates over all the key-value pairs of attributes contained by this instance. */\n+  @SuppressWarnings(\"unchecked\")\n+  public void forEach(KeyValueConsumer<V> consumer) {\n+    for (int i = 0; i < data().size(); i += 2) {\n+      consumer.consume((String) data().get(i), (V) data().get(i + 1));\n+    }\n+  }\n+\n+  static List<Object> sortAndFilter(Object[] data) {\n+    checkArgument(\n+        data.length % 2 == 0, \"You must provide an even number of key/value pair arguments.\");\n+\n+    quickSort(data, 0, data.length - 2);\n+    return dedupe(data);\n+  }\n+\n+  private static void quickSort(Object[] data, int leftIndex, int rightIndex) {\n+    if (leftIndex >= rightIndex) {\n+      return;\n+    }\n+\n+    String pivotKey = (String) data[rightIndex];\n+    int counter = leftIndex;\n+\n+    for (int i = leftIndex; i <= rightIndex; i += 2) {\n+      if (((String) data[i]).compareTo(pivotKey) <= 0) {\n+        swap(data, counter, i);\n+        counter += 2;\n+      }\n+    }\n+\n+    quickSort(data, leftIndex, counter - 4);\n+    quickSort(data, counter, rightIndex);\n+  }\n+\n+  private static List<Object> dedupe(Object[] data) {\n+    List<Object> result = new ArrayList<>(data.length);\n+    Object previousKey = null;\n+\n+    for (int i = 0; i < data.length; i += 2) {\n+      Object key = data[i];\n+      Object value = data[i + 1];\n+      checkNotNull(key, \"You cannot provide null keys for creation of attributes.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNTg2Mg=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMDQ3MQ==", "bodyText": "I agree it's a bad problem but eventually some user will find their app crash because of observability logic and complain even in the most unlikely scenarios :) And I think that's the motivation behind those principles.\nJust skipping of course makes finding these bugs hard - how about a configurable check that can be enabled in unit tests? https://github.com/aws/aws-xray-sdk-java/blob/master/aws-xray-recorder-sdk-core/src/main/java/com/amazonaws/xray/utils/LooseValidations.java#L24", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436230471", "createdAt": "2020-06-06T02:44:08Z", "author": {"login": "anuraaga"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+abstract class ImmutableKeyValuePairs<V> {\n+\n+  List<Object> data() {\n+    return Collections.emptyList();\n+  }\n+\n+  /** Iterates over all the key-value pairs of attributes contained by this instance. */\n+  @SuppressWarnings(\"unchecked\")\n+  public void forEach(KeyValueConsumer<V> consumer) {\n+    for (int i = 0; i < data().size(); i += 2) {\n+      consumer.consume((String) data().get(i), (V) data().get(i + 1));\n+    }\n+  }\n+\n+  static List<Object> sortAndFilter(Object[] data) {\n+    checkArgument(\n+        data.length % 2 == 0, \"You must provide an even number of key/value pair arguments.\");\n+\n+    quickSort(data, 0, data.length - 2);\n+    return dedupe(data);\n+  }\n+\n+  private static void quickSort(Object[] data, int leftIndex, int rightIndex) {\n+    if (leftIndex >= rightIndex) {\n+      return;\n+    }\n+\n+    String pivotKey = (String) data[rightIndex];\n+    int counter = leftIndex;\n+\n+    for (int i = leftIndex; i <= rightIndex; i += 2) {\n+      if (((String) data[i]).compareTo(pivotKey) <= 0) {\n+        swap(data, counter, i);\n+        counter += 2;\n+      }\n+    }\n+\n+    quickSort(data, leftIndex, counter - 4);\n+    quickSort(data, counter, rightIndex);\n+  }\n+\n+  private static List<Object> dedupe(Object[] data) {\n+    List<Object> result = new ArrayList<>(data.length);\n+    Object previousKey = null;\n+\n+    for (int i = 0; i < data.length; i += 2) {\n+      Object key = data[i];\n+      Object value = data[i + 1];\n+      checkNotNull(key, \"You cannot provide null keys for creation of attributes.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNTg2Mg=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3OTA3NA==", "bodyText": "How about skipping and logging? I do think this will be a very rare occurrence, and will almost certainly indicate a programming bug.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436279074", "createdAt": "2020-06-06T15:52:32Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+abstract class ImmutableKeyValuePairs<V> {\n+\n+  List<Object> data() {\n+    return Collections.emptyList();\n+  }\n+\n+  /** Iterates over all the key-value pairs of attributes contained by this instance. */\n+  @SuppressWarnings(\"unchecked\")\n+  public void forEach(KeyValueConsumer<V> consumer) {\n+    for (int i = 0; i < data().size(); i += 2) {\n+      consumer.consume((String) data().get(i), (V) data().get(i + 1));\n+    }\n+  }\n+\n+  static List<Object> sortAndFilter(Object[] data) {\n+    checkArgument(\n+        data.length % 2 == 0, \"You must provide an even number of key/value pair arguments.\");\n+\n+    quickSort(data, 0, data.length - 2);\n+    return dedupe(data);\n+  }\n+\n+  private static void quickSort(Object[] data, int leftIndex, int rightIndex) {\n+    if (leftIndex >= rightIndex) {\n+      return;\n+    }\n+\n+    String pivotKey = (String) data[rightIndex];\n+    int counter = leftIndex;\n+\n+    for (int i = leftIndex; i <= rightIndex; i += 2) {\n+      if (((String) data[i]).compareTo(pivotKey) <= 0) {\n+        swap(data, counter, i);\n+        counter += 2;\n+      }\n+    }\n+\n+    quickSort(data, leftIndex, counter - 4);\n+    quickSort(data, counter, rightIndex);\n+  }\n+\n+  private static List<Object> dedupe(Object[] data) {\n+    List<Object> result = new ArrayList<>(data.length);\n+    Object previousKey = null;\n+\n+    for (int i = 0; i < data.length; i += 2) {\n+      Object key = data[i];\n+      Object value = data[i + 1];\n+      checkNotNull(key, \"You cannot provide null keys for creation of attributes.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNTg2Mg=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM4MTA1NA==", "bodyText": "ok, skipped null keys and logged.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436381054", "createdAt": "2020-06-07T16:46:01Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+abstract class ImmutableKeyValuePairs<V> {\n+\n+  List<Object> data() {\n+    return Collections.emptyList();\n+  }\n+\n+  /** Iterates over all the key-value pairs of attributes contained by this instance. */\n+  @SuppressWarnings(\"unchecked\")\n+  public void forEach(KeyValueConsumer<V> consumer) {\n+    for (int i = 0; i < data().size(); i += 2) {\n+      consumer.consume((String) data().get(i), (V) data().get(i + 1));\n+    }\n+  }\n+\n+  static List<Object> sortAndFilter(Object[] data) {\n+    checkArgument(\n+        data.length % 2 == 0, \"You must provide an even number of key/value pair arguments.\");\n+\n+    quickSort(data, 0, data.length - 2);\n+    return dedupe(data);\n+  }\n+\n+  private static void quickSort(Object[] data, int leftIndex, int rightIndex) {\n+    if (leftIndex >= rightIndex) {\n+      return;\n+    }\n+\n+    String pivotKey = (String) data[rightIndex];\n+    int counter = leftIndex;\n+\n+    for (int i = leftIndex; i <= rightIndex; i += 2) {\n+      if (((String) data[i]).compareTo(pivotKey) <= 0) {\n+        swap(data, counter, i);\n+        counter += 2;\n+      }\n+    }\n+\n+    quickSort(data, leftIndex, counter - 4);\n+    quickSort(data, counter, rightIndex);\n+  }\n+\n+  private static List<Object> dedupe(Object[] data) {\n+    List<Object> result = new ArrayList<>(data.length);\n+    Object previousKey = null;\n+\n+    for (int i = 0; i < data.length; i += 2) {\n+      Object key = data[i];\n+      Object value = data[i + 1];\n+      checkNotNull(key, \"You cannot provide null keys for creation of attributes.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNTg2Mg=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzI0MzU0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMTo1MDowNFrOGgBK6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxNTo1Mjo1OFrOGgEXQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNjc5NQ==", "bodyText": "Since we're allocating anyways and the number of items should be quite low, consider doing an out-of-place insertion sort where it's easy to dedupe while sorting and is faster than quicksort for small collections", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436226795", "createdAt": "2020-06-06T01:50:04Z", "author": {"login": "anuraaga"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+abstract class ImmutableKeyValuePairs<V> {\n+\n+  List<Object> data() {\n+    return Collections.emptyList();\n+  }\n+\n+  /** Iterates over all the key-value pairs of attributes contained by this instance. */\n+  @SuppressWarnings(\"unchecked\")\n+  public void forEach(KeyValueConsumer<V> consumer) {\n+    for (int i = 0; i < data().size(); i += 2) {\n+      consumer.consume((String) data().get(i), (V) data().get(i + 1));\n+    }\n+  }\n+\n+  static List<Object> sortAndFilter(Object[] data) {\n+    checkArgument(\n+        data.length % 2 == 0, \"You must provide an even number of key/value pair arguments.\");\n+\n+    quickSort(data, 0, data.length - 2);\n+    return dedupe(data);\n+  }\n+\n+  private static void quickSort(Object[] data, int leftIndex, int rightIndex) {\n+    if (leftIndex >= rightIndex) {\n+      return;\n+    }\n+\n+    String pivotKey = (String) data[rightIndex];\n+    int counter = leftIndex;\n+\n+    for (int i = leftIndex; i <= rightIndex; i += 2) {\n+      if (((String) data[i]).compareTo(pivotKey) <= 0) {\n+        swap(data, counter, i);\n+        counter += 2;\n+      }\n+    }\n+\n+    quickSort(data, leftIndex, counter - 4);\n+    quickSort(data, counter, rightIndex);\n+  }\n+\n+  private static List<Object> dedupe(Object[] data) {\n+    List<Object> result = new ArrayList<>(data.length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNzU2Mg==", "bodyText": "Realized that if sort and dedupe were combined into one insertion sort could do it in-place too. Dupes should be rare I think so copying only for the dupe case would be nice.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436227562", "createdAt": "2020-06-06T02:00:27Z", "author": {"login": "anuraaga"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+abstract class ImmutableKeyValuePairs<V> {\n+\n+  List<Object> data() {\n+    return Collections.emptyList();\n+  }\n+\n+  /** Iterates over all the key-value pairs of attributes contained by this instance. */\n+  @SuppressWarnings(\"unchecked\")\n+  public void forEach(KeyValueConsumer<V> consumer) {\n+    for (int i = 0; i < data().size(); i += 2) {\n+      consumer.consume((String) data().get(i), (V) data().get(i + 1));\n+    }\n+  }\n+\n+  static List<Object> sortAndFilter(Object[] data) {\n+    checkArgument(\n+        data.length % 2 == 0, \"You must provide an even number of key/value pair arguments.\");\n+\n+    quickSort(data, 0, data.length - 2);\n+    return dedupe(data);\n+  }\n+\n+  private static void quickSort(Object[] data, int leftIndex, int rightIndex) {\n+    if (leftIndex >= rightIndex) {\n+      return;\n+    }\n+\n+    String pivotKey = (String) data[rightIndex];\n+    int counter = leftIndex;\n+\n+    for (int i = leftIndex; i <= rightIndex; i += 2) {\n+      if (((String) data[i]).compareTo(pivotKey) <= 0) {\n+        swap(data, counter, i);\n+        counter += 2;\n+      }\n+    }\n+\n+    quickSort(data, leftIndex, counter - 4);\n+    quickSort(data, counter, rightIndex);\n+  }\n+\n+  private static List<Object> dedupe(Object[] data) {\n+    List<Object> result = new ArrayList<>(data.length);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNjc5NQ=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyOTI5Mw==", "bodyText": "I think we can save fine-grained optimization like this until after we've got it all up and running. :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436229293", "createdAt": "2020-06-06T02:25:33Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+abstract class ImmutableKeyValuePairs<V> {\n+\n+  List<Object> data() {\n+    return Collections.emptyList();\n+  }\n+\n+  /** Iterates over all the key-value pairs of attributes contained by this instance. */\n+  @SuppressWarnings(\"unchecked\")\n+  public void forEach(KeyValueConsumer<V> consumer) {\n+    for (int i = 0; i < data().size(); i += 2) {\n+      consumer.consume((String) data().get(i), (V) data().get(i + 1));\n+    }\n+  }\n+\n+  static List<Object> sortAndFilter(Object[] data) {\n+    checkArgument(\n+        data.length % 2 == 0, \"You must provide an even number of key/value pair arguments.\");\n+\n+    quickSort(data, 0, data.length - 2);\n+    return dedupe(data);\n+  }\n+\n+  private static void quickSort(Object[] data, int leftIndex, int rightIndex) {\n+    if (leftIndex >= rightIndex) {\n+      return;\n+    }\n+\n+    String pivotKey = (String) data[rightIndex];\n+    int counter = leftIndex;\n+\n+    for (int i = leftIndex; i <= rightIndex; i += 2) {\n+      if (((String) data[i]).compareTo(pivotKey) <= 0) {\n+        swap(data, counter, i);\n+        counter += 2;\n+      }\n+    }\n+\n+    quickSort(data, leftIndex, counter - 4);\n+    quickSort(data, counter, rightIndex);\n+  }\n+\n+  private static List<Object> dedupe(Object[] data) {\n+    List<Object> result = new ArrayList<>(data.length);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNjc5NQ=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMTAwOQ==", "bodyText": "Agree though might still consider at least the already-sorted/deduped check in this one that would probably be good enough for most cases anyways and should be relatively simple.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436231009", "createdAt": "2020-06-06T02:51:59Z", "author": {"login": "anuraaga"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+abstract class ImmutableKeyValuePairs<V> {\n+\n+  List<Object> data() {\n+    return Collections.emptyList();\n+  }\n+\n+  /** Iterates over all the key-value pairs of attributes contained by this instance. */\n+  @SuppressWarnings(\"unchecked\")\n+  public void forEach(KeyValueConsumer<V> consumer) {\n+    for (int i = 0; i < data().size(); i += 2) {\n+      consumer.consume((String) data().get(i), (V) data().get(i + 1));\n+    }\n+  }\n+\n+  static List<Object> sortAndFilter(Object[] data) {\n+    checkArgument(\n+        data.length % 2 == 0, \"You must provide an even number of key/value pair arguments.\");\n+\n+    quickSort(data, 0, data.length - 2);\n+    return dedupe(data);\n+  }\n+\n+  private static void quickSort(Object[] data, int leftIndex, int rightIndex) {\n+    if (leftIndex >= rightIndex) {\n+      return;\n+    }\n+\n+    String pivotKey = (String) data[rightIndex];\n+    int counter = leftIndex;\n+\n+    for (int i = leftIndex; i <= rightIndex; i += 2) {\n+      if (((String) data[i]).compareTo(pivotKey) <= 0) {\n+        swap(data, counter, i);\n+        counter += 2;\n+      }\n+    }\n+\n+    quickSort(data, leftIndex, counter - 4);\n+    quickSort(data, counter, rightIndex);\n+  }\n+\n+  private static List<Object> dedupe(Object[] data) {\n+    List<Object> result = new ArrayList<>(data.length);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNjc5NQ=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3OTEwNA==", "bodyText": "See above comments on getting this landed before doing micro-optimizations.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436279104", "createdAt": "2020-06-06T15:52:58Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/ImmutableKeyValuePairs.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.internal.Utils.checkArgument;\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable set of key-value pairs. Keys are only {@link String} typed. Can be iterated over\n+ * using the {@link #forEach(KeyValueConsumer)} method.\n+ *\n+ * @param <V> The type of the values contained in this.\n+ * @see Labels\n+ * @see Attributes\n+ */\n+@Immutable\n+abstract class ImmutableKeyValuePairs<V> {\n+\n+  List<Object> data() {\n+    return Collections.emptyList();\n+  }\n+\n+  /** Iterates over all the key-value pairs of attributes contained by this instance. */\n+  @SuppressWarnings(\"unchecked\")\n+  public void forEach(KeyValueConsumer<V> consumer) {\n+    for (int i = 0; i < data().size(); i += 2) {\n+      consumer.consume((String) data().get(i), (V) data().get(i + 1));\n+    }\n+  }\n+\n+  static List<Object> sortAndFilter(Object[] data) {\n+    checkArgument(\n+        data.length % 2 == 0, \"You must provide an even number of key/value pair arguments.\");\n+\n+    quickSort(data, 0, data.length - 2);\n+    return dedupe(data);\n+  }\n+\n+  private static void quickSort(Object[] data, int leftIndex, int rightIndex) {\n+    if (leftIndex >= rightIndex) {\n+      return;\n+    }\n+\n+    String pivotKey = (String) data[rightIndex];\n+    int counter = leftIndex;\n+\n+    for (int i = leftIndex; i <= rightIndex; i += 2) {\n+      if (((String) data[i]).compareTo(pivotKey) <= 0) {\n+        swap(data, counter, i);\n+        counter += 2;\n+      }\n+    }\n+\n+    quickSort(data, leftIndex, counter - 4);\n+    quickSort(data, counter, rightIndex);\n+  }\n+\n+  private static List<Object> dedupe(Object[] data) {\n+    List<Object> result = new ArrayList<>(data.length);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNjc5NQ=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzI1MTQ0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/common/KeyValueConsumer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMjowNTowMlrOGgBO9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNjo0NTozMVrOGgKlTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNzgzMQ==", "bodyText": "ImmutableKeyValuePairs isn't in public API so can't link it. Just some generic word like container should be fine.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436227831", "createdAt": "2020-06-06T02:05:02Z", "author": {"login": "anuraaga"}, "path": "api/src/main/java/io/opentelemetry/common/KeyValueConsumer.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+/**\n+ * Used for iterating over the key-value pairs contained by an {@link ImmutableKeyValuePairs}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyOTI2Mg==", "bodyText": "fair enough. will update.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436229262", "createdAt": "2020-06-06T02:25:10Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/KeyValueConsumer.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+/**\n+ * Used for iterating over the key-value pairs contained by an {@link ImmutableKeyValuePairs}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNzgzMQ=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM4MTAwNg==", "bodyText": "done", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436381006", "createdAt": "2020-06-07T16:45:31Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/KeyValueConsumer.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+/**\n+ * Used for iterating over the key-value pairs contained by an {@link ImmutableKeyValuePairs}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNzgzMQ=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzI1MzUyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMjowOTowMFrOGgBQIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNjo0NToyM1rOGgKlPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyODEyOA==", "bodyText": "Sets instead of Add throughout (matches the method name and javadoc should generally be present tense, not command tense)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436228128", "createdAt": "2020-06-06T02:09:00Z", "author": {"login": "anuraaga"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the\n+ * attributes.\n+ */\n+@Immutable\n+public abstract class Attributes extends ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY = new Attributes() {};\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    abstract List<Object> data();\n+  }\n+\n+  /** An {@link Attributes} instance with no attributes. */\n+  public static Attributes empty() {\n+    return EMPTY;\n+  }\n+\n+  /** An {@link Attributes} instance with a single key-value pair. */\n+  public static Attributes of(String key, AttributeValue value) {\n+    return sortAndFilterToAttributes(key, value);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with two key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1, AttributeValue value1, String key2, AttributeValue value2) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with three key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2, key3, value3);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with four key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2, key3, value3, key4, value4);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with five key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4,\n+      String key5,\n+      AttributeValue value5) {\n+    return sortAndFilterToAttributes(\n+        key1, value1,\n+        key2, value2,\n+        key3, value3,\n+        key4, value4,\n+        key5, value5);\n+  }\n+\n+  private static Attributes sortAndFilterToAttributes(Object... data) {\n+    return new AutoValue_Attributes_ArrayBackedAttributes(sortAndFilter(data));\n+  }\n+\n+  /** Creates a new {@link Builder} instance for creating arbitrary {@link Attributes}. */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  /**\n+   * Enables the creation of an {@link Attributes} instance with an arbitrary number of key-value\n+   * pairs.\n+   */\n+  public static class Builder {\n+    private final List<Object> data = new ArrayList<>();\n+\n+    /** Create the {@link Attributes} from this. */\n+    public Attributes build() {\n+      return sortAndFilterToAttributes(data.toArray());\n+    }\n+\n+    /**\n+     * Add a bare {@link AttributeValue} to this.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM4MDk5MQ==", "bodyText": "done", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436380991", "createdAt": "2020-06-07T16:45:23Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the\n+ * attributes.\n+ */\n+@Immutable\n+public abstract class Attributes extends ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY = new Attributes() {};\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    abstract List<Object> data();\n+  }\n+\n+  /** An {@link Attributes} instance with no attributes. */\n+  public static Attributes empty() {\n+    return EMPTY;\n+  }\n+\n+  /** An {@link Attributes} instance with a single key-value pair. */\n+  public static Attributes of(String key, AttributeValue value) {\n+    return sortAndFilterToAttributes(key, value);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with two key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1, AttributeValue value1, String key2, AttributeValue value2) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with three key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2, key3, value3);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with four key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4) {\n+    return sortAndFilterToAttributes(key1, value1, key2, value2, key3, value3, key4, value4);\n+  }\n+\n+  /**\n+   * An {@link Attributes} instance with five key-value pairs. Order of the keys is not preserved.\n+   * Duplicate keys will be removed.\n+   */\n+  public static Attributes of(\n+      String key1,\n+      AttributeValue value1,\n+      String key2,\n+      AttributeValue value2,\n+      String key3,\n+      AttributeValue value3,\n+      String key4,\n+      AttributeValue value4,\n+      String key5,\n+      AttributeValue value5) {\n+    return sortAndFilterToAttributes(\n+        key1, value1,\n+        key2, value2,\n+        key3, value3,\n+        key4, value4,\n+        key5, value5);\n+  }\n+\n+  private static Attributes sortAndFilterToAttributes(Object... data) {\n+    return new AutoValue_Attributes_ArrayBackedAttributes(sortAndFilter(data));\n+  }\n+\n+  /** Creates a new {@link Builder} instance for creating arbitrary {@link Attributes}. */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  /**\n+   * Enables the creation of an {@link Attributes} instance with an arbitrary number of key-value\n+   * pairs.\n+   */\n+  public static class Builder {\n+    private final List<Object> data = new ArrayList<>();\n+\n+    /** Create the {@link Attributes} from this. */\n+    public Attributes build() {\n+      return sortAndFilterToAttributes(data.toArray());\n+    }\n+\n+    /**\n+     * Add a bare {@link AttributeValue} to this.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyODEyOA=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzI1MzcxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMjowOToyN1rOGgBQNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNjo0NToxNlrOGgKlMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyODE1MQ==", "bodyText": "Returns a for all the factories", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436228151", "createdAt": "2020-06-06T02:09:27Z", "author": {"login": "anuraaga"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the\n+ * attributes.\n+ */\n+@Immutable\n+public abstract class Attributes extends ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY = new Attributes() {};\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    abstract List<Object> data();\n+  }\n+\n+  /** An {@link Attributes} instance with no attributes. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM4MDk3OQ==", "bodyText": "done", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436380979", "createdAt": "2020-06-07T16:45:16Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the\n+ * attributes.\n+ */\n+@Immutable\n+public abstract class Attributes extends ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY = new Attributes() {};\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    abstract List<Object> data();\n+  }\n+\n+  /** An {@link Attributes} instance with no attributes. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyODE1MQ=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzI1Mzk0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQwMjowOTo1NlrOGgBQXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxNjo0NTowM1rOGgKlFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyODE5MA==", "bodyText": "No type parameter anymore remove from javadoc", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436228190", "createdAt": "2020-06-06T02:09:56Z", "author": {"login": "anuraaga"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyOTM1NA==", "bodyText": "whoops! got lost in the refactoring. will fix.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436229354", "createdAt": "2020-06-06T02:26:11Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyODE5MA=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM4MDk0OQ==", "bodyText": "done", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436380949", "createdAt": "2020-06-07T16:45:03Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes. The type parameter denotes the type of the values of the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyODE5MA=="}, "originalCommit": {"oid": "136fbe5a16c02f2de6fdd19a3ba339af165495a2"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODcxNzM2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMTowNjo1NlrOGgM-3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNToxMToyNlrOGgjKjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMDMxOQ==", "bodyText": "Still recommend this to be Attributes.newBuilder().build() instead of adding a new implementation of Attributes", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436420319", "createdAt": "2020-06-08T01:06:56Z", "author": {"login": "anuraaga"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes.\n+ *\n+ * <p>The keys are {@link String}s and the values are {@link AttributeValue} instances.\n+ */\n+@Immutable\n+public abstract class Attributes extends ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY = new Attributes() {};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74ab7d1fa2b760e6bcd9dab9138d0fc9d7e277c7"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4MDU5Mw==", "bodyText": "Sure. I'm fine either way.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436780593", "createdAt": "2020-06-08T15:06:47Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes.\n+ *\n+ * <p>The keys are {@link String}s and the values are {@link AttributeValue} instances.\n+ */\n+@Immutable\n+public abstract class Attributes extends ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY = new Attributes() {};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMDMxOQ=="}, "originalCommit": {"oid": "74ab7d1fa2b760e6bcd9dab9138d0fc9d7e277c7"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4Mzc1OA==", "bodyText": "done.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436783758", "createdAt": "2020-06-08T15:11:26Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes.\n+ *\n+ * <p>The keys are {@link String}s and the values are {@link AttributeValue} instances.\n+ */\n+@Immutable\n+public abstract class Attributes extends ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY = new Attributes() {};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMDMxOQ=="}, "originalCommit": {"oid": "74ab7d1fa2b760e6bcd9dab9138d0fc9d7e277c7"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODcxNzkzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMTowNzozN1rOGgM_NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNTowMzo0OVrOGgi2kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMDQwNQ==", "bodyText": "Think we can use of here, it's the \"base case\" of the varargs. Similar to what guava does", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436420405", "createdAt": "2020-06-08T01:07:37Z", "author": {"login": "anuraaga"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes.\n+ *\n+ * <p>The keys are {@link String}s and the values are {@link AttributeValue} instances.\n+ */\n+@Immutable\n+public abstract class Attributes extends ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY = new Attributes() {};\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    abstract List<Object> data();\n+  }\n+\n+  /** Returns a {@link Attributes} instance with no attributes. */\n+  public static Attributes empty() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74ab7d1fa2b760e6bcd9dab9138d0fc9d7e277c7"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc3ODY0Mg==", "bodyText": "I actually didn't use that pattern, quite intentionally, since I think guava's use of the empty of is quite annoying and surprising. :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1304#discussion_r436778642", "createdAt": "2020-06-08T15:03:49Z", "author": {"login": "jkwatson"}, "path": "api/src/main/java/io/opentelemetry/common/Attributes.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import static io.opentelemetry.common.AttributeValue.arrayAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.booleanAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.doubleAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.longAttributeValue;\n+import static io.opentelemetry.common.AttributeValue.stringAttributeValue;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * An immutable container for attributes.\n+ *\n+ * <p>The keys are {@link String}s and the values are {@link AttributeValue} instances.\n+ */\n+@Immutable\n+public abstract class Attributes extends ImmutableKeyValuePairs<AttributeValue> {\n+  private static final Attributes EMPTY = new Attributes() {};\n+\n+  @AutoValue\n+  @Immutable\n+  abstract static class ArrayBackedAttributes extends Attributes {\n+    ArrayBackedAttributes() {}\n+\n+    @Override\n+    abstract List<Object> data();\n+  }\n+\n+  /** Returns a {@link Attributes} instance with no attributes. */\n+  public static Attributes empty() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMDQwNQ=="}, "originalCommit": {"oid": "74ab7d1fa2b760e6bcd9dab9138d0fc9d7e277c7"}, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 775, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}