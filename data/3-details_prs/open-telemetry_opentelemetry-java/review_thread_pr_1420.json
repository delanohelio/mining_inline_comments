{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ5NzI4ODI1", "number": 1420, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMjo0OTo0MlrOEO5cPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNjoyNjoyNVrOEO-uAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MDU2NjM2OnYy", "diffSide": "RIGHT", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMjo0OTo0MlrOGyT9gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMzoyNzozMVrOGyUvNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQwOTAyNg==", "bodyText": "you can pull this sort call up one level, right? Since it's the same in both the if and the else branches?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1420#discussion_r455409026", "createdAt": "2020-07-15T22:49:42Z", "author": {"login": "jkwatson"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -486,18 +486,19 @@ private void emitHtmlBody(Map<String, String> queryMap, PrintStream out)\n               // Display latency based span\n               LatencyBoundary latencyBoundary = LatencyBoundary.values()[subtype];\n               spans =\n-                  dataAggregator.getOkSpans(\n-                      spanName,\n-                      latencyBoundary.getLatencyLowerBound(),\n-                      latencyBoundary.getLatencyUpperBound());\n+                  new ArrayList<>(\n+                      dataAggregator.getOkSpans(\n+                          spanName,\n+                          latencyBoundary.getLatencyLowerBound(),\n+                          latencyBoundary.getLatencyUpperBound()));\n               Collections.sort(spans, new SpanDataComparator(/* incremental= */ false));\n             } else {\n               if (subtype < 0 || subtype >= CanonicalCode.values().length) {\n                 // N/A or out-of-bound cueck for error based subtype, valid values: [0, 15]\n                 return;\n               }\n               // Display error based span\n-              spans = dataAggregator.getErrorSpans(spanName);\n+              spans = new ArrayList<>(dataAggregator.getErrorSpans(spanName));\n               Collections.sort(spans, new SpanDataComparator(/* incremental= */ false));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "293bb7aa55feb73b6fee380c1cd856842cc4cd86"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQyMTc1MA==", "bodyText": "Hmm yes, I think originally it's meant for sorting in a different order, but now it's all the same, I'll pull them out", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1420#discussion_r455421750", "createdAt": "2020-07-15T23:27:31Z", "author": {"login": "wtyanan"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -486,18 +486,19 @@ private void emitHtmlBody(Map<String, String> queryMap, PrintStream out)\n               // Display latency based span\n               LatencyBoundary latencyBoundary = LatencyBoundary.values()[subtype];\n               spans =\n-                  dataAggregator.getOkSpans(\n-                      spanName,\n-                      latencyBoundary.getLatencyLowerBound(),\n-                      latencyBoundary.getLatencyUpperBound());\n+                  new ArrayList<>(\n+                      dataAggregator.getOkSpans(\n+                          spanName,\n+                          latencyBoundary.getLatencyLowerBound(),\n+                          latencyBoundary.getLatencyUpperBound()));\n               Collections.sort(spans, new SpanDataComparator(/* incremental= */ false));\n             } else {\n               if (subtype < 0 || subtype >= CanonicalCode.values().length) {\n                 // N/A or out-of-bound cueck for error based subtype, valid values: [0, 15]\n                 return;\n               }\n               // Display error based span\n-              spans = dataAggregator.getErrorSpans(spanName);\n+              spans = new ArrayList<>(dataAggregator.getErrorSpans(spanName));\n               Collections.sort(spans, new SpanDataComparator(/* incremental= */ false));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQwOTAyNg=="}, "originalCommit": {"oid": "293bb7aa55feb73b6fee380c1cd856842cc4cd86"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MDY5MjMyOnYy", "diffSide": "RIGHT", "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQyMzo0NTozMVrOGyVGRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMDo1Nzo1MlrOGyWWwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQyNzY1NQ==", "bodyText": "We may as well stick with immutable ImmutableList.sortedCopyOf. I guess one problem was that we didn't go \"all-in\" on ImmutableList, if we did then issues like sorting a collection become more obviously a bug. Let's try to keep the standard in this code that all the containers are immutable.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1420#discussion_r455427655", "createdAt": "2020-07-15T23:45:31Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -486,18 +486,19 @@ private void emitHtmlBody(Map<String, String> queryMap, PrintStream out)\n               // Display latency based span\n               LatencyBoundary latencyBoundary = LatencyBoundary.values()[subtype];\n               spans =\n-                  dataAggregator.getOkSpans(\n-                      spanName,\n-                      latencyBoundary.getLatencyLowerBound(),\n-                      latencyBoundary.getLatencyUpperBound());\n+                  new ArrayList<>(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "293bb7aa55feb73b6fee380c1cd856842cc4cd86"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0MzM2MA==", "bodyText": "So instead of new ArrayList<>(), I should use ImmutableList.sortedCopyOf?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1420#discussion_r455443360", "createdAt": "2020-07-16T00:39:10Z", "author": {"login": "wtyanan"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -486,18 +486,19 @@ private void emitHtmlBody(Map<String, String> queryMap, PrintStream out)\n               // Display latency based span\n               LatencyBoundary latencyBoundary = LatencyBoundary.values()[subtype];\n               spans =\n-                  dataAggregator.getOkSpans(\n-                      spanName,\n-                      latencyBoundary.getLatencyLowerBound(),\n-                      latencyBoundary.getLatencyUpperBound());\n+                  new ArrayList<>(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQyNzY1NQ=="}, "originalCommit": {"oid": "293bb7aa55feb73b6fee380c1cd856842cc4cd86"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0NTQ0Mg==", "bodyText": "Yeah", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1420#discussion_r455445442", "createdAt": "2020-07-16T00:46:55Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -486,18 +486,19 @@ private void emitHtmlBody(Map<String, String> queryMap, PrintStream out)\n               // Display latency based span\n               LatencyBoundary latencyBoundary = LatencyBoundary.values()[subtype];\n               spans =\n-                  dataAggregator.getOkSpans(\n-                      spanName,\n-                      latencyBoundary.getLatencyLowerBound(),\n-                      latencyBoundary.getLatencyUpperBound());\n+                  new ArrayList<>(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQyNzY1NQ=="}, "originalCommit": {"oid": "293bb7aa55feb73b6fee380c1cd856842cc4cd86"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0ODI1OA==", "bodyText": "I will remove new ArrayList<>() and instead of Collections.sort, I will do spans = ImmutableList.sortedCopyOf(comparator, spans). Is this a reasonable approach as well?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1420#discussion_r455448258", "createdAt": "2020-07-16T00:57:52Z", "author": {"login": "wtyanan"}, "path": "sdk_extensions/zpages/src/main/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandler.java", "diffHunk": "@@ -486,18 +486,19 @@ private void emitHtmlBody(Map<String, String> queryMap, PrintStream out)\n               // Display latency based span\n               LatencyBoundary latencyBoundary = LatencyBoundary.values()[subtype];\n               spans =\n-                  dataAggregator.getOkSpans(\n-                      spanName,\n-                      latencyBoundary.getLatencyLowerBound(),\n-                      latencyBoundary.getLatencyUpperBound());\n+                  new ArrayList<>(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQyNzY1NQ=="}, "originalCommit": {"oid": "293bb7aa55feb73b6fee380c1cd856842cc4cd86"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MTQzMTA3OnYy", "diffSide": "RIGHT", "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandlerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNjoyNjoyNVrOGybyGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNjoyNjoyNVrOGybyGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTUzNzE3OA==", "bodyText": "Not a big deal but it's a bit less verbose to use ImmutableMap.of, it's very close in feeling to a map literal.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1420#discussion_r455537178", "createdAt": "2020-07-16T06:26:25Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/zpages/src/test/java/io/opentelemetry/sdk/extensions/zpages/TracezZPageHandlerTest.java", "diffHunk": "@@ -274,18 +274,94 @@ public void summaryTable_linkForErrorSpans() {\n   }\n \n   @Test\n-  public void spanDetails_emitSpanNameCorrectly() {\n+  public void spanDetails_emitRunningSpanDetailsCorrectly() {\n+    OutputStream output = new ByteArrayOutputStream();\n+    Map<String, String> queryMap = new HashMap<String, String>();\n+    Span runningSpan = tracer.spanBuilder(RUNNING_SPAN).startSpan();\n+\n+    queryMap.put(\"zspanname\", RUNNING_SPAN);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a25e0e14a7fa55eec76f7332236e57b8258c956"}, "originalPosition": 73}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1482, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}