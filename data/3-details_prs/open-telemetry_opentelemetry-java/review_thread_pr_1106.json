{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAyODYyODIx", "number": 1106, "reviewThreads": {"totalCount": 44, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMzozNTowOVrODxbIsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMzo1NjowM1rOD1BibQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTUxNDEwOnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMzozNTowOVrOGE43Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDowNjowOFrOGE5dsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc3OTE1OA==", "bodyText": "I think we don't have this in any other build.gradle. Maybe a separate PR to add to all of them?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r407779158", "createdAt": "2020-04-13T23:35:09Z", "author": {"login": "bogdandrutu"}, "path": "build.gradle", "diffHunk": "@@ -1,3 +1,19 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc4ODk3Nw==", "bodyText": "Yeah, I'm happy to remove it. My file template in IDEA just created it automatically for me.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r407788977", "createdAt": "2020-04-14T00:06:08Z", "author": {"login": "jkwatson"}, "path": "build.gradle", "diffHunk": "@@ -1,3 +1,19 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc3OTE1OA=="}, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTYzMDg1OnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDozMjoxM1rOGE57qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDozMjoxM1rOGE57qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5NjY1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    zipkinReporterVersion = '2.7.14'\n          \n          \n            \n                    zipkinReporterVersion = '2.12.2'", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r407796650", "createdAt": "2020-04-14T00:32:13Z", "author": {"login": "codefromthecrypt"}, "path": "build.gradle", "diffHunk": "@@ -96,6 +112,7 @@ subprojects {\n         prometheusVersion = '0.8.1'\n         protobufVersion = '3.11.4'\n         protocVersion = '3.11.4'\n+        zipkinReporterVersion = '2.7.14'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTYzNTQzOnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDozNDozMVrOGE5-Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwMTo0NToxMVrOGGRijg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5NzMzOQ==", "bodyText": "UI and dependency linking checks for errors. This is a simplified change, but check first of there's already a tag named \"error\"?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n          \n          \n            \n                    spanBuilder.putTag(\"error\", status.getCanonicalCode().toString());", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r407797339", "createdAt": "2020-04-14T00:34:31Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIzNjk0OQ==", "bodyText": "I'm not sure I understand what you mean. Are you suggesting that if the user had already added an \"error\" tag, that we don't try to overwrite it?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408236949", "createdAt": "2020-04-14T15:39:34Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5NzMzOQ=="}, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5OTc3OQ==", "bodyText": "yep that was what I meant", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408499779", "createdAt": "2020-04-14T23:47:31Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5NzMzOQ=="}, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk3ODgxOA==", "bodyText": "gotcha", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408978818", "createdAt": "2020-04-15T16:34:53Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5NzMzOQ=="}, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIzMjAxNA==", "bodyText": "this is now implemented.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409232014", "createdAt": "2020-04-16T01:45:11Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5NzMzOQ=="}, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTYzNjczOnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDozNToxMFrOGE5_EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMToxOToyNFrOGFmb3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5NzUyMQ==", "bodyText": "Is there a chance this can be an HTTP code? or is this RPC only?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r407797521", "createdAt": "2020-04-14T00:35:10Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI0NzM5Mw==", "bodyText": "the statuses are defined here:  \n  \n    \n      opentelemetry-java/api/src/main/java/io/opentelemetry/trace/Status.java\n    \n    \n         Line 38\n      in\n      c24e4a9\n    \n    \n    \n    \n\n        \n          \n           public final class Status {", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408247393", "createdAt": "2020-04-14T15:53:32Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5NzUyMQ=="}, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMDA4MA==", "bodyText": "this appears RPC status, can you confirm HTTP is not mapped to this?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408500080", "createdAt": "2020-04-14T23:48:28Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5NzUyMQ=="}, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyNTc4OA==", "bodyText": "Can confirm that HTTP is definitely mapped to these:  https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/http.md#status", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408525788", "createdAt": "2020-04-15T01:19:24Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5NzUyMQ=="}, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTYzOTQyOnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDozNjozN1rOGE6Ahw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDozNjozN1rOGE6Ahw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5Nzg5NQ==", "bodyText": "producer/consumer also? https://github.com/open-telemetry/opentelemetry-python/blob/master/ext/opentelemetry-ext-zipkin/src/opentelemetry/ext/zipkin/__init__.py#L80", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r407797895", "createdAt": "2020-04-14T00:36:37Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @javax.annotation.Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTY0MTUyOnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDozNzozNlrOGE6Btg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNToyOTo1NVrOGFUYKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5ODE5OA==", "bodyText": "is there any chance endTimestamp doesn't exist?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r407798198", "createdAt": "2020-04-14T00:37:36Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIyOTkzMA==", "bodyText": "Currently, no. Only finished spans get sent to the exporters. There are a few issues/suggestions about consuming incomplete spans, but right now, it's a non-null field.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408229930", "createdAt": "2020-04-14T15:29:55Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5ODE5OA=="}, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTY1MDAyOnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDo0MjoxMlrOGE6Grg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDo0MjoxMlrOGE6Grg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5OTQ3MA==", "bodyText": "Not quite sure yet if the below revision is useful or not.. We will have a RPC tag shortly, but I'm not sure this usage here is RPC only. Anyway here's a better link for HTTP\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n          \n          \n            \n              // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r407799470", "createdAt": "2020-04-14T00:42:12Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTY1NDc0OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfigurationTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDo0NDozNlrOGE6JaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNjoyNTo1NFrOGFW2IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwMDE2OA==", "bodyText": "one of these should test the whole thing works I think, ex using https://github.com/openzipkin/zipkin/tree/master/zipkin-junit", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r407800168", "createdAt": "2020-04-14T00:44:36Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfigurationTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/** Unit tests for {@link ZipkinExporterConfiguration}. */\n+@RunWith(MockitoJUnitRunner.class)\n+public class ZipkinExporterConfigurationTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2NzY3Mg==", "bodyText": "I'd like to have that as a separate PR. I'll add an issue to track it.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408267672", "createdAt": "2020-04-14T16:22:07Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfigurationTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/** Unit tests for {@link ZipkinExporterConfiguration}. */\n+@RunWith(MockitoJUnitRunner.class)\n+public class ZipkinExporterConfigurationTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwMDE2OA=="}, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3MDM2OA==", "bodyText": "#1110", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408270368", "createdAt": "2020-04-14T16:25:54Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfigurationTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/** Unit tests for {@link ZipkinExporterConfiguration}. */\n+@RunWith(MockitoJUnitRunner.class)\n+public class ZipkinExporterConfigurationTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwMDE2OA=="}, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTY1Njk3OnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDo0NTo0NFrOGE6KsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNjo0MjoxNlrOGFXhIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwMDQ5Nw==", "bodyText": "you can switch to the bom https://github.com/openzipkin/zipkin-reporter-java#version-alignments\ngradle supports it now, then you also get zipkin-junit's version number for free.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r407800497", "createdAt": "2020-04-14T00:45:44Z", "author": {"login": "codefromthecrypt"}, "path": "build.gradle", "diffHunk": "@@ -117,6 +134,8 @@ subprojects {\n                 prometheus_client_common: \"io.prometheus:simpleclient_common:${prometheusVersion}\",\n                 protobuf                : \"com.google.protobuf:protobuf-java:${protobufVersion}\",\n                 protobuf_util           : \"com.google.protobuf:protobuf-java-util:${protobufVersion}\",\n+                zipkin_reporter         : \"io.zipkin.reporter2:zipkin-reporter:${zipkinReporterVersion}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI4MDQ3MA==", "bodyText": "cool. I think this will require a bit of rework of our gradle files, so I'll log this as a separate issue, so as not to clutter up this PR too much.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408280470", "createdAt": "2020-04-14T16:40:49Z", "author": {"login": "jkwatson"}, "path": "build.gradle", "diffHunk": "@@ -117,6 +134,8 @@ subprojects {\n                 prometheus_client_common: \"io.prometheus:simpleclient_common:${prometheusVersion}\",\n                 protobuf                : \"com.google.protobuf:protobuf-java:${protobufVersion}\",\n                 protobuf_util           : \"com.google.protobuf:protobuf-java-util:${protobufVersion}\",\n+                zipkin_reporter         : \"io.zipkin.reporter2:zipkin-reporter:${zipkinReporterVersion}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwMDQ5Nw=="}, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI4MTM3Ng==", "bodyText": "#1111", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408281376", "createdAt": "2020-04-14T16:42:16Z", "author": {"login": "jkwatson"}, "path": "build.gradle", "diffHunk": "@@ -117,6 +134,8 @@ subprojects {\n                 prometheus_client_common: \"io.prometheus:simpleclient_common:${prometheusVersion}\",\n                 protobuf                : \"com.google.protobuf:protobuf-java:${protobufVersion}\",\n                 protobuf_util           : \"com.google.protobuf:protobuf-java-util:${protobufVersion}\",\n+                zipkin_reporter         : \"io.zipkin.reporter2:zipkin-reporter:${zipkinReporterVersion}\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwMDQ5Nw=="}, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTY1OTM0OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/build.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDo0Njo1NVrOGE6MCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNToyODoyN1rOGFUThw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwMDg0Mg==", "bodyText": "I'd take out guava. unless it is used somehow underneath, the types used in the code below aren't pulling weight to pin this. I know you're surprised that I, of all people, am making this comment", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r407800842", "createdAt": "2020-04-14T00:46:55Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/build.gradle", "diffHunk": "@@ -0,0 +1,56 @@\n+plugins {\n+    id \"java\"\n+    id \"maven-publish\"\n+\n+    id \"ru.vyarus.animalsniffer\"\n+}\n+\n+description = 'OpenTelemetry - Zipkin Exporter'\n+ext.moduleName = \"io.opentelemetry.exporters.zipkin\"\n+\n+dependencies {\n+    compileOnly libraries.auto_value\n+\n+    api project(':opentelemetry-sdk')\n+\n+    annotationProcessor libraries.auto_value\n+\n+    implementation libraries.guava", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIyODc0Mw==", "bodyText": "I'll move it to a testImplementation and clean up the very few usages.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408228743", "createdAt": "2020-04-14T15:28:27Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/build.gradle", "diffHunk": "@@ -0,0 +1,56 @@\n+plugins {\n+    id \"java\"\n+    id \"maven-publish\"\n+\n+    id \"ru.vyarus.animalsniffer\"\n+}\n+\n+description = 'OpenTelemetry - Zipkin Exporter'\n+ext.moduleName = \"io.opentelemetry.exporters.zipkin\"\n+\n+dependencies {\n+    compileOnly libraries.auto_value\n+\n+    api project(':opentelemetry-sdk')\n+\n+    annotationProcessor libraries.auto_value\n+\n+    implementation libraries.guava", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwMDg0Mg=="}, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTY2NDA0OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDo0OToxMlrOGE6OmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNTozMToxOVrOGFUcIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwMTQ5Ng==", "bodyText": "add a test where there is no kind? I didn't see one..", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r407801496", "createdAt": "2020-04-14T00:49:12Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIzMDk0NQ==", "bodyText": "kind is required in OpenTelemetry spans; you can't even create one without a kind set.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408230945", "createdAt": "2020-04-14T15:31:19Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/apache/incubator-zipkin-brave/blob/643b7245c462dc14d47afcdb076b2603fd421497/instrumentation/grpc/src/main/java/brave/grpc/GrpcParser.java#L67-L73\n+  @VisibleForTesting static final String STATUS_CODE = \"otel.status_code\";\n+  @VisibleForTesting static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  @VisibleForTesting static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwMTQ5Ng=="}, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTY4OTc2OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMTowMzozN1rOGE6dyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMTowMzozN1rOGE6dyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwNTM4Ng==", "bodyText": "Some polish as I've been redoing a lot of docs like these lately, to intro things. Hope it helps.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This is the OpenTelemetry exporter, which sends span data to Zipkin.\n          \n          \n            \n            This is an OpenTelemetry exporter that sends span data using the [io.zipkin.reporter2:zipkin-reporter](https://github.com/openzipkin/zipkin-reporter-java\") library.\n          \n          \n            \n            \n          \n          \n            \n            By default, this POSTs json in [Zipkin format](https://zipkin.io/zipkin-api/#/default/post_spans) to\n          \n          \n            \n            a specified HTTP URL. This could be to a [Zipkin](https://zipkin.io) service, or anything that\n          \n          \n            \n            consumes the same format.\n          \n          \n            \n            \n          \n          \n            \n            You can alternatively use other formats, such as protobuf, or override the `Sender` to use a non-HTTP transport, such as Kafka.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r407805386", "createdAt": "2020-04-14T01:03:37Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/README.md", "diffHunk": "@@ -0,0 +1,30 @@\n+# OpenTelemetry - Zipkin Span Exporter\n+\n+[![Javadocs][javadoc-image]][javadoc-url]\n+\n+This is the OpenTelemetry exporter, which sends span data to Zipkin.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTY5MTI4OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMTowNDoxOFrOGE6eow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMTowNDoxOFrOGE6eow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgwNTYwMw==", "bodyText": "probably a wildcard s/http/https/ here. Fixing to avoid first timers getting confused why things don't work.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        .setV2Url(\"https://localhost/api/v2/spans\")\n          \n          \n            \n                        .setV2Url(\"http://localhost/api/v2/spans\")", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r407805603", "createdAt": "2020-04-14T01:04:18Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/README.md", "diffHunk": "@@ -0,0 +1,30 @@\n+# OpenTelemetry - Zipkin Span Exporter\n+\n+[![Javadocs][javadoc-image]][javadoc-url]\n+\n+This is the OpenTelemetry exporter, which sends span data to Zipkin.\n+\n+## Configuration\n+\n+The Zipkin span exporter can be configured programmatically.\n+\n+An example of simple Zipkin exporter initialization. In this case\n+spans will be sent to a Zipkin endpoint running on `localhost`:\n+\n+```java\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setV2Url(\"https://localhost/api/v2/spans\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39bb30bf1cd33f245022a04bb8cdfc5d7986a25d"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjExNDk1OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/build.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzo1MDowN1rOGFk5UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNTozMTo1OVrOGF_cyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMDU2MQ==", "bodyText": "maybe a comment that says this is the minimum api level of otel? whatever the minimum is, this should be", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408500561", "createdAt": "2020-04-14T23:50:07Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/build.gradle", "diffHunk": "@@ -0,0 +1,57 @@\n+plugins {\n+    id \"java\"\n+    id \"maven-publish\"\n+\n+    id \"ru.vyarus.animalsniffer\"\n+}\n+\n+description = 'OpenTelemetry - Zipkin Exporter'\n+ext.moduleName = \"io.opentelemetry.exporters.zipkin\"\n+\n+dependencies {\n+    compileOnly libraries.auto_value\n+\n+    api project(':opentelemetry-sdk')\n+\n+    annotationProcessor libraries.auto_value\n+\n+    implementation libraries.zipkin_reporter\n+    implementation libraries.zipkin_urlconnection\n+\n+    testImplementation libraries.guava\n+\n+    signature \"org.codehaus.mojo.signature:java17:1.0@signature\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkzNTYyNw==", "bodyText": "adding a comment to the README about this.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408935627", "createdAt": "2020-04-15T15:31:59Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/build.gradle", "diffHunk": "@@ -0,0 +1,57 @@\n+plugins {\n+    id \"java\"\n+    id \"maven-publish\"\n+\n+    id \"ru.vyarus.animalsniffer\"\n+}\n+\n+description = 'OpenTelemetry - Zipkin Exporter'\n+ext.moduleName = \"io.opentelemetry.exporters.zipkin\"\n+\n+dependencies {\n+    compileOnly libraries.auto_value\n+\n+    api project(':opentelemetry-sdk')\n+\n+    annotationProcessor libraries.auto_value\n+\n+    implementation libraries.zipkin_reporter\n+    implementation libraries.zipkin_urlconnection\n+\n+    testImplementation libraries.guava\n+\n+    signature \"org.codehaus.mojo.signature:java17:1.0@signature\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMDU2MQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjExNjAwOnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/build.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzo1MDozNFrOGFk55g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMToxNToxN1rOGFmXxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMDcxMA==", "bodyText": "is it normal for the license header to be in the middle of the file?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408500710", "createdAt": "2020-04-14T23:50:34Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/build.gradle", "diffHunk": "@@ -0,0 +1,57 @@\n+plugins {\n+    id \"java\"\n+    id \"maven-publish\"\n+\n+    id \"ru.vyarus.animalsniffer\"\n+}\n+\n+description = 'OpenTelemetry - Zipkin Exporter'\n+ext.moduleName = \"io.opentelemetry.exporters.zipkin\"\n+\n+dependencies {\n+    compileOnly libraries.auto_value\n+\n+    api project(':opentelemetry-sdk')\n+\n+    annotationProcessor libraries.auto_value\n+\n+    implementation libraries.zipkin_reporter\n+    implementation libraries.zipkin_urlconnection\n+\n+    testImplementation libraries.guava\n+\n+    signature \"org.codehaus.mojo.signature:java17:1.0@signature\"\n+    signature \"net.sf.androidscents.signature:android-api-level-24:7.0_r2@signature\"\n+}\n+\n+animalsniffer {\n+    // Don't check sourceSets.jmh and sourceSets.test\n+    sourceSets = [\n+            sourceSets.main\n+    ]\n+}\n+\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyNDc0Mg==", "bodyText": "arg! IDEA keeps throwing this in when it's not wanted. will remove, for sure.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408524742", "createdAt": "2020-04-15T01:15:17Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/build.gradle", "diffHunk": "@@ -0,0 +1,57 @@\n+plugins {\n+    id \"java\"\n+    id \"maven-publish\"\n+\n+    id \"ru.vyarus.animalsniffer\"\n+}\n+\n+description = 'OpenTelemetry - Zipkin Exporter'\n+ext.moduleName = \"io.opentelemetry.exporters.zipkin\"\n+\n+dependencies {\n+    compileOnly libraries.auto_value\n+\n+    api project(':opentelemetry-sdk')\n+\n+    annotationProcessor libraries.auto_value\n+\n+    implementation libraries.zipkin_reporter\n+    implementation libraries.zipkin_urlconnection\n+\n+    testImplementation libraries.guava\n+\n+    signature \"org.codehaus.mojo.signature:java17:1.0@signature\"\n+    signature \"net.sf.androidscents.signature:android-api-level-24:7.0_r2@signature\"\n+}\n+\n+animalsniffer {\n+    // Don't check sourceSets.jmh and sourceSets.test\n+    sourceSets = [\n+            sourceSets.main\n+    ]\n+}\n+\n+/*", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMDcxMA=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjExNzM5OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzo1MToyMVrOGFk6wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNTozMjoxN1rOGF_doQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMDkzMA==", "bodyText": "probably not correct? either 0.3 (if adding in a patch) or the next releasable version?\nsame everywhere", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408500930", "createdAt": "2020-04-14T23:51:21Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.3.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkzNTg0MQ==", "bodyText": "yep, fixing to be 0.4.0 everywhere", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408935841", "createdAt": "2020-04-15T15:32:17Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.3.0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMDkzMA=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjEyMDEwOnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzo1Mjo0MFrOGFk8TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDowOTozNVrOGHgOyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMTMyNA==", "bodyText": "I'm guessing the project has rules that require filler javadoc statements? These don't seem to add value otherwise, except for maybe the version once it is correct. If you want better descriptions let me know.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408501324", "createdAt": "2020-04-14T23:52:40Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.3.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyNDkwMg==", "bodyText": "This was directly copied from the opencensus exporter. Better descriptions would be great!", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408524902", "createdAt": "2020-04-15T01:15:54Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.3.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMTMyNA=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkzNjIzNQ==", "bodyText": "And, I agree with you on the usefulness of much of the javadoc.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408936235", "createdAt": "2020-04-15T15:32:46Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.3.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMTMyNA=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwMjg5Nw==", "bodyText": "in that case, is it within the rules of the project to remove them? Less fluff to write, and we can focus on single-sentence explanations. lemme know and then I'll respond accordingly.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409202897", "createdAt": "2020-04-16T00:02:10Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.3.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMTMyNA=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIzMjMzMw==", "bodyText": "I'll poke at this tomorrow. I'm not 100% sure of the rules, myself.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409232333", "createdAt": "2020-04-16T01:46:17Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.3.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMTMyNA=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwODM4Ng==", "bodyText": "Looks like javadoc is not required, but if it's there, it needs to be complete and well-formed.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410408386", "createdAt": "2020-04-17T18:48:59Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.3.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMTMyNA=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMTI5MQ==", "bodyText": "ok I'll give you some text in another review round", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410521291", "createdAt": "2020-04-18T00:09:35Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.3.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMTMyNA=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjEyNTQxOnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzo1NDo1OVrOGFk_Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODo0NDo1N1rOGHZNyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMjA3OQ==", "bodyText": "description is good here.. @return this. is silly and I'm guessing slave to javadoc or checkstyle?\nI would add @see for the actual methods on the type being built and do most of the describing there.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408502079", "createdAt": "2020-04-14T23:54:59Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.3.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.3.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.3.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.3.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.3.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.3.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.3.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this.\n+     * @since 0.3.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);\n+\n+    /**\n+     * Sets the Zipkin V2 URL, e.g.: \"http://127.0.0.1:9411/api/v2/spans\".\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * @param v2Url the Zipkin V2 URL.\n+     * @return this.\n+     * @since 0.3.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyNDk5Mw==", "bodyText": "again, direct copy from the opencensus version. :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408524993", "createdAt": "2020-04-15T01:16:19Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.3.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.3.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.3.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.3.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.3.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.3.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.3.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this.\n+     * @since 0.3.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);\n+\n+    /**\n+     * Sets the Zipkin V2 URL, e.g.: \"http://127.0.0.1:9411/api/v2/spans\".\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * @param v2Url the Zipkin V2 URL.\n+     * @return this.\n+     * @since 0.3.0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMjA3OQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwNjM0NA==", "bodyText": "going to leave this as-is for now. Follow-on PRs to clean this up can be made, as desired.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410406344", "createdAt": "2020-04-17T18:44:57Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.3.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.3.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.3.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.3.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.3.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.3.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.3.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this.\n+     * @since 0.3.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);\n+\n+    /**\n+     * Sets the Zipkin V2 URL, e.g.: \"http://127.0.0.1:9411/api/v2/spans\".\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * @param v2Url the Zipkin V2 URL.\n+     * @return this.\n+     * @since 0.3.0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMjA3OQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjEyNzg1OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzo1NjowMFrOGFlAlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMToxNjo0MlrOGFmZDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMjQyMQ==", "bodyText": "maybe just grep since before you finish this PR", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408502421", "createdAt": "2020-04-14T23:56:00Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.3.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.3.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.3.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.3.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.3.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.3.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.3.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this.\n+     * @since 0.3.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);\n+\n+    /**\n+     * Sets the Zipkin V2 URL, e.g.: \"http://127.0.0.1:9411/api/v2/spans\".\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * @param v2Url the Zipkin V2 URL.\n+     * @return this.\n+     * @since 0.3.0\n+     */\n+    public abstract Builder setV2Url(String v2Url);\n+\n+    /**\n+     * Sets the Zipkin sender.\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * @param sender the Zipkin sender.\n+     * @return this.\n+     * @since 0.3.0\n+     */\n+    public abstract Builder setSender(Sender sender);\n+\n+    /**\n+     * Sets the {@link SpanBytesEncoder}.\n+     *\n+     * @param encoder the {@code SpanBytesEncoder}.\n+     * @return this\n+     * @since 0.3.0\n+     */\n+    public abstract Builder setEncoder(SpanBytesEncoder encoder);\n+\n+    abstract String getV2Url();\n+\n+    @Nullable\n+    abstract Sender getSender();\n+\n+    abstract ZipkinExporterConfiguration autoBuild();\n+\n+    /**\n+     * Builds a {@link ZipkinExporterConfiguration}.\n+     *\n+     * @return a {@code ZipkinExporterConfiguration}.\n+     * @since 0.22", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyNTA3MA==", "bodyText": "yeah, I missed this one in my pass through.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408525070", "createdAt": "2020-04-15T01:16:42Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.3.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.3.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.3.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.3.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.3.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.3.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.3.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this.\n+     * @since 0.3.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);\n+\n+    /**\n+     * Sets the Zipkin V2 URL, e.g.: \"http://127.0.0.1:9411/api/v2/spans\".\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * @param v2Url the Zipkin V2 URL.\n+     * @return this.\n+     * @since 0.3.0\n+     */\n+    public abstract Builder setV2Url(String v2Url);\n+\n+    /**\n+     * Sets the Zipkin sender.\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * @param sender the Zipkin sender.\n+     * @return this.\n+     * @since 0.3.0\n+     */\n+    public abstract Builder setSender(Sender sender);\n+\n+    /**\n+     * Sets the {@link SpanBytesEncoder}.\n+     *\n+     * @param encoder the {@code SpanBytesEncoder}.\n+     * @return this\n+     * @since 0.3.0\n+     */\n+    public abstract Builder setEncoder(SpanBytesEncoder encoder);\n+\n+    abstract String getV2Url();\n+\n+    @Nullable\n+    abstract Sender getSender();\n+\n+    abstract ZipkinExporterConfiguration autoBuild();\n+\n+    /**\n+     * Builds a {@link ZipkinExporterConfiguration}.\n+     *\n+     * @return a {@code ZipkinExporterConfiguration}.\n+     * @since 0.22", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMjQyMQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjE2NjI4OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "isResolved": true, "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoxNDo1NFrOGFlXQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODo0NDoyM1rOGHZMlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ==", "bodyText": "I'm almost certain we wouldn't add 'otel' as a tag as that would just require re-mapping it back later.\nAs far as I can tell, this is an RPC code, and more specifically gRPC.\nI don't think we would waste indexing on the one called code either. so we should pick one.\nLet's drop \"otel.status_code\" and rename \"otel.status_description\" to \"grpc.status_code\",\nas it seems to be the same value as what we tag today.\nEx. today grpc only tags \"error\" \"grpc.status_code\", ex \"grpc.status_code\" -> \"UNIMPLEMENTED\" (not a numerical tag)\nThis trades short term conflation with portability with existing search and indexing especially as I doubt\nmany RPC frameworks except grpc are integrated with otel at the moment.\nYou can add a better comment which is that we are tentatively re-using grpc until a final decision is made on rpc tags openzipkin/brave#999\nIt may also be worth mentioning in the README that while the \"error\" tag is a zipkin tag, \"grpc.status_code\" is tentative. Adding the best tentative choice is better than blocking this work or introducing a non-existent tag that will add burden to existing sites as many don't have means to re-map tags (never needed to).", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408508225", "createdAt": "2020-04-15T00:14:54Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyNTY1NA==", "bodyText": "This is definitely not just grpc. Here are the official mappings for http status codes:  https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/http.md#status\n@trask can comment as to whether those are being faithfully followed in the auto-instrumentation project or not.\nWith the naming of the tags...I just copied these from the opencensus version, and replaced \"opencensus\" with \"otel\". Happy to make them whatever is appropriate.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408525654", "createdAt": "2020-04-15T01:18:52Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyOTExMw==", "bodyText": "if there's nothing besides grpc and http defined, then check for \"http.status_code\" first? if that's missing, assume it isn't and set to \"otel.status_description\" -> \"grpc.status_code\".", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408529113", "createdAt": "2020-04-15T01:31:57Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU1MTQxNg==", "bodyText": "re: auto-instrumentation - for instrumentation other than http and grpc we're only using Status.OK/Status.UNKNOWN (to mark success/failure). hmm, even for http and grpc instrumentation, we're only using Status.OK/Status.UNKNOWN, but that needs to be fixed (heading over there to file an issue now...)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408551416", "createdAt": "2020-04-15T02:55:05Z", "author": {"login": "trask"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk4Mzc1Mg==", "bodyText": "ok, I took a stab at this, @adriancole . Feedback welcome. Assuming grpc feels weird to me, but you're the boss!", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408983752", "createdAt": "2020-04-15T16:42:39Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwMjQ5NQ==", "bodyText": "feeling weird is good. this is the tension that leads to better decisions later. please do let me know if you find anything besides grpc that uses this (besides the somewhat arbitrary lossy conversion of http status). meanwhile probably by month end we'll have an rpc tag and replace this.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409202495", "createdAt": "2020-04-16T00:00:44Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIzMTIxNg==", "bodyText": "I guess my \"weird feeling\" might be assuaged if we removed the g and just said rpc, but maybe that's splitting hairs a bit.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409231216", "createdAt": "2020-04-16T01:42:26Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIzNTc0OQ==", "bodyText": "the issue I referenced will solve this probably before 0.4 or 0.5 here, just it is better to use a tag that exists today vs create one only to change it. don't worry.. I've the same opinion!", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409235749", "createdAt": "2020-04-16T01:58:40Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIzNjQwMw==", "bodyText": "in other words, we (OpenZipkin) should be able to settle the name, usage and content of the tag \"grpc.status_code\", just we owe ourselves to check this vs other RPC frameworks etc. I don't think this has been done here either, yet, so happy to share when that occurs.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409236403", "createdAt": "2020-04-16T02:01:03Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTczMjAxMA==", "bodyText": "the comment above these values no longer makes sense. Do you have a better one to use until it gets settled?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409732010", "createdAt": "2020-04-16T17:35:25Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwNjAzNg==", "bodyText": "fixed per conversation below", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410406036", "createdAt": "2020-04-17T18:44:23Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODIyNQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjE2OTI0OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "isResolved": true, "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoxNjo1MVrOGFlZJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODo0Mzo1OVrOGHZLzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ==", "bodyText": "usually I add an assert false or similar as this is a bug I think. especially in the same repo there should never be an escape from enum switch (to degree it happens outside is avoidable version skew)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408508711", "createdAt": "2020-04-15T00:16:51Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyNjMwMw==", "bodyText": "Probably makes sense to at least add a log message that there was an unknown attribute value type. And, there are array valued types coming...not sure what zipkin wants for array-valued attributes.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408526303", "createdAt": "2020-04-15T01:21:33Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyODU1OA==", "bodyText": "join on comma if you support array values.\nI wouldn't log or if anything log once if there's a bug here on unmatched (avoid tight loops of logging). assert will catch it ideally.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408528558", "createdAt": "2020-04-15T01:29:47Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0Mzg1NA==", "bodyText": "This project doesn't use java assert, so I don't want to do that. I'd also rather not have the export fail if a new type gets added without the exporter being updated. (like if someone updates their SDK version, but doesn't update their exporter version).", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408943854", "createdAt": "2020-04-15T15:43:14Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwMDgyNQ==", "bodyText": "up to you. FYI we do it all the time. running assertions in prod isn't usual. but I just wanted to express my opinion and thanks for that. something like a log-once seems fine!", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409200825", "createdAt": "2020-04-15T23:55:29Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwMTQwMA==", "bodyText": "ps the reason we do it is if you don't, and only log, the build won't break when something new is added.. and typically logs are ignored. if you think of a better way to handle this case, let me know as that's the only reason we do it (to make sure someone doesn't have to remember all the things that need to be updated)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409201400", "createdAt": "2020-04-15T23:57:24Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIzMTY3MA==", "bodyText": "hmmm. if we make sure to have a test that iterates over all the values of the type enum, then we can guarantee the build fails by just having it throw an exception. Since this is a part of the main project, it will fail the build. I'll give this a try tomorrow!", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409231670", "createdAt": "2020-04-16T01:44:00Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYxMzkxMA==", "bodyText": "I think we have static checks enabled and you fail to compile if we miss a value, no need to have tests for all the values to catch this bug (it is good to have tests for all the values to ensure correctness, but not for this particular problem). Hope I am not wrong, can you give a try?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409613910", "createdAt": "2020-04-16T14:44:03Z", "author": {"login": "bogdandrutu"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYxNDY2Mg==", "bodyText": "The problem comes when we add a new type, and users will use the API with the new type and an old exporter package. That's when we may have troubles.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409614662", "createdAt": "2020-04-16T14:44:59Z", "author": {"login": "bogdandrutu"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcyODI1Mg==", "bodyText": "fair enough!", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409728252", "createdAt": "2020-04-16T17:29:23Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTczMDE5Mg==", "bodyText": "I think we have static checks enabled and you fail to compile if we miss a value, no need to have tests for all the values to catch this bug (it is good to have tests for all the values to ensure correctness, but not for this particular problem). Hope I am not wrong, can you give a try?\n\nConfirmed. errorprone catches this and fails the build if you're missing an enum in your switch branches.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409730192", "createdAt": "2020-04-16T17:32:27Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI2OTIwMg==", "bodyText": "We can simply use throw if you want. No need to use assert", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410269202", "createdAt": "2020-04-17T14:41:47Z", "author": {"login": "bogdandrutu"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwNTgzOA==", "bodyText": "changed to throw an exception for now.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410405838", "createdAt": "2020-04-17T18:43:59Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwODcxMQ=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjE3MTc0OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoxODowMlrOGFlakA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQyMzo1ODo1M1rOGGPs4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwOTA3Mg==", "bodyText": "URLConnection doesn't need to close on shutdown. However, the builder method that sets sender could warn the caller (in javadoc) that they are responsible to close the sender (a better choice than us closing it randomly)\nEventhough the calls here are synchronous, most senders will have resources open like kafka connections.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408509072", "createdAt": "2020-04-15T00:18:02Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";\n+  }\n+\n+  @Override\n+  public ResultCode export(final Collection<SpanData> spanDataList) {\n+    List<byte[]> encodedSpans = new ArrayList<>(spanDataList.size());\n+    for (SpanData spanData : spanDataList) {\n+      encodedSpans.add(encoder.encode(generateSpan(spanData, localEndpoint)));\n+    }\n+    try {\n+      sender.sendSpans(encodedSpans).execute();\n+    } catch (IOException e) {\n+      return ResultCode.FAILED_NOT_RETRYABLE;\n+    }\n+    return ResultCode.SUCCESS;\n+  }\n+\n+  @Override\n+  public void shutdown() {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyOTc1OA==", "bodyText": "you don't think that we should close the sender in the shutdown? Shutdown is only called when the exporter will no longer be used.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408529758", "createdAt": "2020-04-15T01:34:30Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";\n+  }\n+\n+  @Override\n+  public ResultCode export(final Collection<SpanData> spanDataList) {\n+    List<byte[]> encodedSpans = new ArrayList<>(spanDataList.size());\n+    for (SpanData spanData : spanDataList) {\n+      encodedSpans.add(encoder.encode(generateSpan(spanData, localEndpoint)));\n+    }\n+    try {\n+      sender.sendSpans(encodedSpans).execute();\n+    } catch (IOException e) {\n+      return ResultCode.FAILED_NOT_RETRYABLE;\n+    }\n+    return ResultCode.SUCCESS;\n+  }\n+\n+  @Override\n+  public void shutdown() {}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwOTA3Mg=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUzMzIwNg==", "bodyText": "I've always been of the opinion of \"you open it, you close it\" so, if someone hands you a resource (they opened) you don't close it, as that's their job. Ex if in spring a closeable bean is managed where it is defined and would be odd to have something else close it randomly.\nif you do close it, then make sure that's known in the javadoc etc, so that it doesn't feel random and people can wrap if they don't want it closed.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408533206", "createdAt": "2020-04-15T01:47:26Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";\n+  }\n+\n+  @Override\n+  public ResultCode export(final Collection<SpanData> spanDataList) {\n+    List<byte[]> encodedSpans = new ArrayList<>(spanDataList.size());\n+    for (SpanData spanData : spanDataList) {\n+      encodedSpans.add(encoder.encode(generateSpan(spanData, localEndpoint)));\n+    }\n+    try {\n+      sender.sendSpans(encodedSpans).execute();\n+    } catch (IOException e) {\n+      return ResultCode.FAILED_NOT_RETRYABLE;\n+    }\n+    return ResultCode.SUCCESS;\n+  }\n+\n+  @Override\n+  public void shutdown() {}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwOTA3Mg=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NTQ5OA==", "bodyText": "Sender doesn't appear to have a shutdown method, so I guess this is moot.  :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408945498", "createdAt": "2020-04-15T15:45:32Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";\n+  }\n+\n+  @Override\n+  public ResultCode export(final Collection<SpanData> spanDataList) {\n+    List<byte[]> encodedSpans = new ArrayList<>(spanDataList.size());\n+    for (SpanData spanData : spanDataList) {\n+      encodedSpans.add(encoder.encode(generateSpan(spanData, localEndpoint)));\n+    }\n+    try {\n+      sender.sendSpans(encodedSpans).execute();\n+    } catch (IOException e) {\n+      return ResultCode.FAILED_NOT_RETRYABLE;\n+    }\n+    return ResultCode.SUCCESS;\n+  }\n+\n+  @Override\n+  public void shutdown() {}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwOTA3Mg=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0NTk1Mw==", "bodyText": "oh derp. it has a close(). nm me.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408945953", "createdAt": "2020-04-15T15:46:11Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";\n+  }\n+\n+  @Override\n+  public ResultCode export(final Collection<SpanData> spanDataList) {\n+    List<byte[]> encodedSpans = new ArrayList<>(spanDataList.size());\n+    for (SpanData spanData : spanDataList) {\n+      encodedSpans.add(encoder.encode(generateSpan(spanData, localEndpoint)));\n+    }\n+    try {\n+      sender.sendSpans(encodedSpans).execute();\n+    } catch (IOException e) {\n+      return ResultCode.FAILED_NOT_RETRYABLE;\n+    }\n+    return ResultCode.SUCCESS;\n+  }\n+\n+  @Override\n+  public void shutdown() {}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwOTA3Mg=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0ODM5MQ==", "bodyText": "It's a little tricky, since if you use the configuration option that creates a Sender in the background, then the user doesn't have control over the lifecycle. I'll change this to close the Sender and add javadoc to the configuration to let people know it'll happen.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408948391", "createdAt": "2020-04-15T15:49:34Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";\n+  }\n+\n+  @Override\n+  public ResultCode export(final Collection<SpanData> spanDataList) {\n+    List<byte[]> encodedSpans = new ArrayList<>(spanDataList.size());\n+    for (SpanData spanData : spanDataList) {\n+      encodedSpans.add(encoder.encode(generateSpan(spanData, localEndpoint)));\n+    }\n+    try {\n+      sender.sendSpans(encodedSpans).execute();\n+    } catch (IOException e) {\n+      return ResultCode.FAILED_NOT_RETRYABLE;\n+    }\n+    return ResultCode.SUCCESS;\n+  }\n+\n+  @Override\n+  public void shutdown() {}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwOTA3Mg=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwMTg5MQ==", "bodyText": "makes sense! you'd have to either do that or register a shutdown hook. I know we have one scenario somewhere where we do similar to what you said.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409201891", "createdAt": "2020-04-15T23:58:53Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"otel.status_code\";\n+  static final String STATUS_DESCRIPTION = \"otel.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private final SpanBytesEncoder encoder;\n+  private final Sender sender;\n+  private final Endpoint localEndpoint;\n+\n+  ZipkinSpanExporter(SpanBytesEncoder encoder, Sender sender, String serviceName) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+    this.localEndpoint = produceLocalEndpoint(serviceName);\n+  }\n+\n+  /** Logic borrowed from brave.internal.Platform.produceLocalEndpoint */\n+  static Endpoint produceLocalEndpoint(String serviceName) {\n+    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\n+    try {\n+      Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+      if (nics == null) {\n+        return builder.build();\n+      }\n+      while (nics.hasMoreElements()) {\n+        NetworkInterface nic = nics.nextElement();\n+        Enumeration<InetAddress> addresses = nic.getInetAddresses();\n+        while (addresses.hasMoreElements()) {\n+          InetAddress address = addresses.nextElement();\n+          if (address.isSiteLocalAddress()) {\n+            builder.ip(address);\n+            break;\n+          }\n+        }\n+      }\n+    } catch (Exception e) {\n+      // don't crash the caller if there was a problem reading nics.\n+      if (logger.isLoggable(Level.FINE)) {\n+        logger.log(Level.FINE, \"error reading nics\", e);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n+    long startTimestamp = toEpochMicros(spanData.getStartEpochNanos());\n+\n+    long endTimestamp = toEpochMicros(spanData.getEndEpochNanos());\n+\n+    Span.Builder spanBuilder =\n+        Span.newBuilder()\n+            .traceId(spanData.getTraceId().toLowerBase16())\n+            .id(spanData.getSpanId().toLowerBase16())\n+            .kind(toSpanKind(spanData))\n+            .name(spanData.getName())\n+            .timestamp(toEpochMicros(spanData.getStartEpochNanos()))\n+            .duration(endTimestamp - startTimestamp)\n+            .localEndpoint(localEndpoint);\n+\n+    if (spanData.getParentSpanId().isValid()) {\n+      spanBuilder.parentId(spanData.getParentSpanId().toLowerBase16());\n+    }\n+\n+    for (Map.Entry<String, AttributeValue> label : spanData.getAttributes().entrySet()) {\n+      spanBuilder.putTag(label.getKey(), attributeValueToString(label.getValue()));\n+    }\n+    Status status = spanData.getStatus();\n+    if (status != null) {\n+      spanBuilder.putTag(STATUS_CODE, status.getCanonicalCode().toString());\n+      if (status.getDescription() != null) {\n+        spanBuilder.putTag(STATUS_DESCRIPTION, status.getDescription());\n+      }\n+      if (!status.isOk()) {\n+        spanBuilder.putTag(STATUS_ERROR, status.getCanonicalCode().toString());\n+      }\n+    }\n+\n+    for (SpanData.TimedEvent annotation : spanData.getTimedEvents()) {\n+      spanBuilder.addAnnotation(toEpochMicros(annotation.getEpochNanos()), annotation.getName());\n+    }\n+\n+    return spanBuilder.build();\n+  }\n+\n+  @Nullable\n+  private static Span.Kind toSpanKind(SpanData spanData) {\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.SERVER\n+        || (spanData.getKind() == null && Boolean.TRUE.equals(spanData.getHasRemoteParent()))) {\n+      return Span.Kind.SERVER;\n+    }\n+\n+    // This is a hack because the Span API did not have SpanKind.\n+    if (spanData.getKind() == Kind.CLIENT || spanData.getName().startsWith(\"Sent.\")) {\n+      return Span.Kind.CLIENT;\n+    }\n+\n+    if (spanData.getKind() == Kind.PRODUCER) {\n+      return Span.Kind.PRODUCER;\n+    }\n+    if (spanData.getKind() == Kind.CONSUMER) {\n+      return Span.Kind.CONSUMER;\n+    }\n+\n+    return null;\n+  }\n+\n+  private static long toEpochMicros(long epochNanos) {\n+    return MICROSECONDS.convert(epochNanos, NANOSECONDS);\n+  }\n+\n+  private static String attributeValueToString(AttributeValue attributeValue) {\n+    Type type = attributeValue.getType();\n+    switch (type) {\n+      case STRING:\n+        return attributeValue.getStringValue();\n+      case BOOLEAN:\n+        return String.valueOf(attributeValue.getBooleanValue());\n+      case LONG:\n+        return String.valueOf(attributeValue.getLongValue());\n+      case DOUBLE:\n+        return String.valueOf(attributeValue.getDoubleValue());\n+    }\n+    return \"\";\n+  }\n+\n+  @Override\n+  public ResultCode export(final Collection<SpanData> spanDataList) {\n+    List<byte[]> encodedSpans = new ArrayList<>(spanDataList.size());\n+    for (SpanData spanData : spanDataList) {\n+      encodedSpans.add(encoder.encode(generateSpan(spanData, localEndpoint)));\n+    }\n+    try {\n+      sender.sendSpans(encodedSpans).execute();\n+    } catch (IOException e) {\n+      return ResultCode.FAILED_NOT_RETRYABLE;\n+    }\n+    return ResultCode.SUCCESS;\n+  }\n+\n+  @Override\n+  public void shutdown() {}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwOTA3Mg=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjE3OTM3OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDoyMTo0M1rOGFle2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNTo1NDo1MlrOGGAeMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMDE2OA==", "bodyText": "sorry if I am blind, but definitely add something for the Kind that coerces to null?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408510168", "createdAt": "2020-04-15T00:21:43Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Link;\n+import io.opentelemetry.sdk.trace.export.SpanExporter.ResultCode;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import zipkin2.Call;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/** Unit tests for {@link ZipkinSpanExporterTest}. */\n+@RunWith(MockitoJUnitRunner.class)\n+public class ZipkinSpanExporterTest {\n+\n+  @Mock private Sender mockSender;\n+  @Mock private SpanBytesEncoder mockEncoder;\n+  @Mock private Call<Void> mockZipkinCall;\n+\n+  private static final Endpoint localEndpoint =\n+      ZipkinSpanExporter.produceLocalEndpoint(\"tweetiebird\");\n+  private static final String TRACE_ID = \"d239036e7d5cec116b562147388b35bf\";\n+  private static final String SPAN_ID = \"9cc1e3049173be09\";\n+  private static final String PARENT_SPAN_ID = \"8b03ab423da481c5\";\n+  private static final Map<String, AttributeValue> attributes = Collections.emptyMap();\n+  private static final List<SpanData.TimedEvent> annotations =\n+      ImmutableList.of(\n+          SpanData.TimedEvent.create(\n+              1505855799_433901068L, \"RECEIVED\", Collections.<String, AttributeValue>emptyMap()),\n+          SpanData.TimedEvent.create(\n+              1505855799_459486280L, \"SENT\", Collections.<String, AttributeValue>emptyMap()));\n+\n+  @Test\n+  public void generateSpan_remoteParent() {\n+    SpanData data = buildStandardSpan().build();\n+\n+    assertThat(ZipkinSpanExporter.generateSpan(data, localEndpoint))\n+        .isEqualTo(buildZipkinSpan(Span.Kind.SERVER, \"OK\"));\n+  }\n+\n+  @Test\n+  public void generateSpan_ServerKind() {\n+    SpanData data = buildStandardSpan().setKind(Kind.SERVER).build();\n+\n+    assertThat(ZipkinSpanExporter.generateSpan(data, localEndpoint))\n+        .isEqualTo(buildZipkinSpan(Span.Kind.SERVER, \"OK\"));\n+  }\n+\n+  @Test\n+  public void generateSpan_ClientKind() {\n+    SpanData data = buildStandardSpan().setKind(Kind.CLIENT).build();\n+\n+    assertThat(ZipkinSpanExporter.generateSpan(data, localEndpoint))\n+        .isEqualTo(buildZipkinSpan(Span.Kind.CLIENT, \"OK\"));\n+  }\n+\n+  @Test\n+  public void generateSpan_ConsumeKind() {\n+    SpanData data = buildStandardSpan().setKind(Kind.CONSUMER).build();\n+\n+    assertThat(ZipkinSpanExporter.generateSpan(data, localEndpoint))\n+        .isEqualTo(buildZipkinSpan(Span.Kind.CONSUMER, \"OK\"));\n+  }\n+\n+  @Test\n+  public void generateSpan_ProducerKind() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk1MjM3MQ==", "bodyText": "ah, on the outbound side. Looks like INTERNAL ends up with null.  will do!", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r408952371", "createdAt": "2020-04-15T15:54:52Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/test/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporterTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.Link;\n+import io.opentelemetry.sdk.trace.export.SpanExporter.ResultCode;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import zipkin2.Call;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/** Unit tests for {@link ZipkinSpanExporterTest}. */\n+@RunWith(MockitoJUnitRunner.class)\n+public class ZipkinSpanExporterTest {\n+\n+  @Mock private Sender mockSender;\n+  @Mock private SpanBytesEncoder mockEncoder;\n+  @Mock private Call<Void> mockZipkinCall;\n+\n+  private static final Endpoint localEndpoint =\n+      ZipkinSpanExporter.produceLocalEndpoint(\"tweetiebird\");\n+  private static final String TRACE_ID = \"d239036e7d5cec116b562147388b35bf\";\n+  private static final String SPAN_ID = \"9cc1e3049173be09\";\n+  private static final String PARENT_SPAN_ID = \"8b03ab423da481c5\";\n+  private static final Map<String, AttributeValue> attributes = Collections.emptyMap();\n+  private static final List<SpanData.TimedEvent> annotations =\n+      ImmutableList.of(\n+          SpanData.TimedEvent.create(\n+              1505855799_433901068L, \"RECEIVED\", Collections.<String, AttributeValue>emptyMap()),\n+          SpanData.TimedEvent.create(\n+              1505855799_459486280L, \"SENT\", Collections.<String, AttributeValue>emptyMap()));\n+\n+  @Test\n+  public void generateSpan_remoteParent() {\n+    SpanData data = buildStandardSpan().build();\n+\n+    assertThat(ZipkinSpanExporter.generateSpan(data, localEndpoint))\n+        .isEqualTo(buildZipkinSpan(Span.Kind.SERVER, \"OK\"));\n+  }\n+\n+  @Test\n+  public void generateSpan_ServerKind() {\n+    SpanData data = buildStandardSpan().setKind(Kind.SERVER).build();\n+\n+    assertThat(ZipkinSpanExporter.generateSpan(data, localEndpoint))\n+        .isEqualTo(buildZipkinSpan(Span.Kind.SERVER, \"OK\"));\n+  }\n+\n+  @Test\n+  public void generateSpan_ClientKind() {\n+    SpanData data = buildStandardSpan().setKind(Kind.CLIENT).build();\n+\n+    assertThat(ZipkinSpanExporter.generateSpan(data, localEndpoint))\n+        .isEqualTo(buildZipkinSpan(Span.Kind.CLIENT, \"OK\"));\n+  }\n+\n+  @Test\n+  public void generateSpan_ConsumeKind() {\n+    SpanData data = buildStandardSpan().setKind(Kind.CONSUMER).build();\n+\n+    assertThat(ZipkinSpanExporter.generateSpan(data, localEndpoint))\n+        .isEqualTo(buildZipkinSpan(Span.Kind.CONSUMER, \"OK\"));\n+  }\n+\n+  @Test\n+  public void generateSpan_ProducerKind() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMDE2OA=="}, "originalCommit": {"oid": "83424a74e17dc5e440f20ad1bed804298166ac77"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NTI2MzE3OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwMTo0Mjo1NFrOGG9Bog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODo0Mzo0NFrOGHZLWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk0NDQ4Mg==", "bodyText": "@jkwatson PS I was assuming grpc \"only\" sets status vs adding a different tag also like \"rpc.status\" or \"grpc.status\" attribute per https://github.com/open-telemetry/opentelemetry-specification/blob/bfb060b23113ba9af492f8c63dd89ecfc500810b/specification/trace/semantic_conventions/rpc.md#status\nIn this case, I think the logic below can be simplified.. only when the mandatory \"rpc.service\" attribute exists, set \"grpc.status_code\" as we aren't likely to use the status values for any other reason.\nThe follow-up comment can refer to openzipkin/brave#999 which is likely to have the outcome of setting a tag like \"rpc.status\" (not yet decided) when the status is not OK. That is assuming there's no heuristic way to identify if the service in otel is grpc or not.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r409944482", "createdAt": "2020-04-17T01:42:54Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"grpc.status_code\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "adf694a04807b55b64c55b98f214c9b32a238dd4"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwNTcyMA==", "bodyText": "cool. I think I've got it in the right shape now!", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410405720", "createdAt": "2020-04-17T18:43:44Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. As an example see:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // Note: these 3 fields are non-private for testing\n+  static final String STATUS_CODE = \"grpc.status_code\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk0NDQ4Mg=="}, "originalCommit": {"oid": "adf694a04807b55b64c55b98f214c9b32a238dd4"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODg0NjI3OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoxMjowOVrOGHgQWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoxMjowOVrOGHgQWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMTY4OA==", "bodyText": "delete need to expose this as it is conditional anyway by marking package private (delete javadoc)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410521688", "createdAt": "2020-04-18T00:12:09Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODg0OTgyOnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoxNDo1NVrOGHgSUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoxNDo1NVrOGHgSUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjE5NQ==", "bodyText": "delete need to expose this as it is conditional anyway by marking package private (delete javadoc)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410522195", "createdAt": "2020-04-18T00:14:55Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODg1MDczOnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoxNTo0MFrOGHgS2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzoyMToyN1rOGIfTdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjMyOA==", "bodyText": "is this actually nullable? or would this just be UrlSender by default?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410522328", "createdAt": "2020-04-18T00:15:40Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMzAzNA==", "bodyText": "you can delete the javadoc by making this package private..", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410523034", "createdAt": "2020-04-18T00:20:24Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjMyOA=="}, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUzNjcwNQ==", "bodyText": "agreed. This isn't actually nullable.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r411536705", "createdAt": "2020-04-20T16:54:20Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjMyOA=="}, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU1NDY3Nw==", "bodyText": "BUT, autovalue needs it to be marked as such so that the builder will let me check to see if it's been set. \ud83e\udd26", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r411554677", "createdAt": "2020-04-20T17:21:27Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjMyOA=="}, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODg1MjAyOnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoxNzozMFrOGHgTqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoxNzozMFrOGHgTqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjUzNg==", "bodyText": "From brave. (PS you will very likely end up needing localIP override. implicit lookups are a nice default, but users set this to the well-known-address sometimes.\nhttps://github.com/openzipkin/brave/blob/master/brave/src/main/java/brave/Tracing.java#L163\n    /**\n     * Label of the remote node in the service graph, such as \"favstar\". Avoid names with variables\n     * or unique identifiers embedded. Defaults to \"unknown\".\n     *\n     * <p>This is a primary label for trace lookup and aggregation, so it should be intuitive and\n     * consistent. Many use a name from service discovery.\n     */", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410522536", "createdAt": "2020-04-18T00:17:30Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.4.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.4.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODg1NDczOnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoxOTo0N1rOGHgVLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMjowNzozM1rOGIvMqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjkyNA==", "bodyText": "consider adding a static factory method to simplify this.\nex\n  /**\n   * Builds a HTTP exporter for <a href=\"https://zipkin.io/zipkin-api/#/\">Zipkin V2</a> format.\n   * \n   * @param endpoint See {@link Builder#setEndpoint(String)}, ex. \"http://zipkinhost:9411/api/v2/spans\".\n   */\n  public static ZipkinExporterConfiguration create(String endpoint) {\n... newbuilder.endpoint().build()", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410522924", "createdAt": "2020-04-18T00:19:47Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNTk3Mg==", "bodyText": "In fact.. if you do this, you can probably get out of the complex statements in the builder. remove the \"endpoint\" variant, and require anyone using the builder to supply their own sender and encoder. SOOO much simpler.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410525972", "createdAt": "2020-04-18T00:40:02Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjkyNA=="}, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1MDAzNg==", "bodyText": "would you have an overload for the serviceName, or just require people who want to set that to use the builder directly?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r411650036", "createdAt": "2020-04-20T19:55:32Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjkyNA=="}, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2MDA0OQ==", "bodyText": "I tried this out, including the serviceName option. Let me know what you think.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r411660049", "createdAt": "2020-04-20T20:12:15Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjkyNA=="}, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc5MjAwNg==", "bodyText": "I guess the local service name is still not a otel concept right?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r411792006", "createdAt": "2020-04-21T00:58:16Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjkyNA=="}, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgwNjk5Mw==", "bodyText": "I think(?) this is the service.name resource attribute: https://github.com/open-telemetry/opentelemetry-specification/tree/master/specification/resource/semantic_conventions#service", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r411806993", "createdAt": "2020-04-21T01:42:53Z", "author": {"login": "trask"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjkyNA=="}, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgxNTA4Mw==", "bodyText": "If this is the same thing as the Resource service.name, then that is a property that is available to the exporter via the Resource attached to the SpanData instance. It's not generally something you configure at the exporter level, at least not from what I've seen so far.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r411815083", "createdAt": "2020-04-21T02:07:33Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMjkyNA=="}, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODg1NTc5OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoyMDo0MlrOGHgVww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoyMDo0MlrOGHgVww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMzA3NQ==", "bodyText": "same delete the javadoc by package private", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410523075", "createdAt": "2020-04-18T00:20:42Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.4.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODg1NzE0OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoyMjowN1rOGHgWnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoyMjowN1rOGHgWnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMzI5Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    .setV2Url(\"\")\n          \n          \n            \n                    .setV2Url(\"\") // trick auto-value so that we can check if either this or the sender are set at build time", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410523292", "createdAt": "2020-04-18T00:22:07Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.4.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODg1ODk1OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoyMzozM1rOGHgXmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoyMzozM1rOGHgXmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMzU0Nw==", "bodyText": "you should probably rename this as v2 url has more to do with the encoding (v1 can be passed!)\nalmost everything in the wild says \"endpoint\" rename to endpoint?\nfrom zipkin-reporter-java\n    /**\n     * No default. The POST URL for zipkin's <a href=\"https://zipkin.io/zipkin-api/#/\">v2 api</a>,\n     * usually \"http://zipkinhost:9411/api/v2/spans\"\n     */\n    // customizable so that users can re-map /api/v2/spans ex for browser-originated traces\n\nhttps://github.com/openzipkin/zipkin-reporter-java/blob/master/urlconnection/src/main/java/zipkin2/reporter/urlconnection/URLConnectionSender.java#L68", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410523547", "createdAt": "2020-04-18T00:23:33Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.4.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.4.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);\n+\n+    /**\n+     * Sets the Zipkin V2 URL, e.g.: \"http://127.0.0.1:9411/api/v2/spans\".", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODg1OTk3OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoyNDowM1rOGHgYGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoyNDowM1rOGHgYGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyMzY3Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n          \n          \n            \n                 * <p>At least one of {@code V2Url} or {@code Sender} needs to be specified. If both {@code", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410523673", "createdAt": "2020-04-18T00:24:03Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.4.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.4.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);\n+\n+    /**\n+     * Sets the Zipkin V2 URL, e.g.: \"http://127.0.0.1:9411/api/v2/spans\".\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODg2MjM0OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoyNjozN1rOGHgZdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoyNjozN1rOGHgZdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNDAyMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n          \n          \n            \n                 * <p>At least one of {@code V2Url} or {@code Sender} needs to be specified. If both {@code", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410524021", "createdAt": "2020-04-18T00:26:37Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.4.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.4.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);\n+\n+    /**\n+     * Sets the Zipkin V2 URL, e.g.: \"http://127.0.0.1:9411/api/v2/spans\".\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * @param v2Url the Zipkin V2 URL.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setV2Url(String v2Url);\n+\n+    /**\n+     * Sets the Zipkin sender.\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODg2NTAyOnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoyOTowOFrOGHga4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDoyOTowOFrOGHga4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNDM4NQ==", "bodyText": "Implements the client side of the span transport. Defaults to {@link UrlConnectionSender}.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410524385", "createdAt": "2020-04-18T00:29:08Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.4.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.4.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);\n+\n+    /**\n+     * Sets the Zipkin V2 URL, e.g.: \"http://127.0.0.1:9411/api/v2/spans\".\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * @param v2Url the Zipkin V2 URL.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setV2Url(String v2Url);\n+\n+    /**\n+     * Sets the Zipkin sender.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODg2NzA1OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDozMToxMlrOGHgcBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDozMToxMlrOGHgcBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNDY3OA==", "bodyText": "change to BytesEncoder<Span> as otherwise you'll break non-zipkin formats like https://github.com/openzipkin/zipkin-gcp/blob/master/sender-stackdriver/src/main/java/zipkin2/reporter/stackdriver/StackdriverEncoder.java\n(ack that they would make their own exporter, but anyway no need to narrow the type)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410524678", "createdAt": "2020-04-18T00:31:12Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.4.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.4.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);\n+\n+    /**\n+     * Sets the Zipkin V2 URL, e.g.: \"http://127.0.0.1:9411/api/v2/spans\".\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * @param v2Url the Zipkin V2 URL.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setV2Url(String v2Url);\n+\n+    /**\n+     * Sets the Zipkin sender.\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * <p>Note: if you provide a {@link Sender} instance via this method, the {@link Sender#close()}\n+     * method will be called when the exporter is shut down.\n+     *\n+     * @param sender the Zipkin sender.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setSender(Sender sender);\n+\n+    /**\n+     * Sets the {@link SpanBytesEncoder}.\n+     *\n+     * @param encoder the {@code SpanBytesEncoder}.\n+     * @return this Builder instance\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setEncoder(SpanBytesEncoder encoder);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODg2NzI4OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDozMToyOVrOGHgcJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDozMToyOVrOGHgcJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNDcxMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return this Builder instance\n          \n          \n            \n                 * @return this Builder instance\n          \n          \n            \n                 * @see SpanBytesEncoder", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410524711", "createdAt": "2020-04-18T00:31:29Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.4.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.4.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);\n+\n+    /**\n+     * Sets the Zipkin V2 URL, e.g.: \"http://127.0.0.1:9411/api/v2/spans\".\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * @param v2Url the Zipkin V2 URL.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setV2Url(String v2Url);\n+\n+    /**\n+     * Sets the Zipkin sender.\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * <p>Note: if you provide a {@link Sender} instance via this method, the {@link Sender#close()}\n+     * method will be called when the exporter is shut down.\n+     *\n+     * @param sender the Zipkin sender.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setSender(Sender sender);\n+\n+    /**\n+     * Sets the {@link SpanBytesEncoder}.\n+     *\n+     * @param encoder the {@code SpanBytesEncoder}.\n+     * @return this Builder instance", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODg2ODM3OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDozMjozMlrOGHgcyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDozMjozMlrOGHgcyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyNDg3Mw==", "bodyText": "Controls the format used by the {@link Sender}. Defaults to  {@link SpanBytesEncoder#JSON_V2}", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r410524873", "createdAt": "2020-04-18T00:32:32Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.internal.Utils;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  /**\n+   * Returns the service name.\n+   *\n+   * @return the service name.\n+   * @since 0.4.0\n+   */\n+  public abstract String getServiceName();\n+\n+  /**\n+   * Returns the Zipkin V2 URL.\n+   *\n+   * @return the Zipkin V2 URL.\n+   * @since 0.4.0\n+   */\n+  public abstract String getV2Url();\n+\n+  /**\n+   * Returns the Zipkin sender.\n+   *\n+   * @return the Zipkin sender.\n+   * @since 0.4.0\n+   */\n+  @Nullable\n+  public abstract Sender getSender();\n+\n+  /**\n+   * Returns the {@link SpanBytesEncoder}.\n+   *\n+   * <p>Default is {@link SpanBytesEncoder#JSON_V2}.\n+   *\n+   * @return the {@code SpanBytesEncoder}\n+   * @since 0.4.0\n+   */\n+  public abstract SpanBytesEncoder getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder}.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setV2Url(\"\")\n+        .setEncoder(SpanBytesEncoder.JSON_V2);\n+  }\n+\n+  /**\n+   * Builder for {@link ZipkinExporterConfiguration}.\n+   *\n+   * @since 0.4.0\n+   */\n+  @AutoValue.Builder\n+  public abstract static class Builder {\n+\n+    Builder() {}\n+\n+    /**\n+     * Sets the service name.\n+     *\n+     * @param serviceName the service name.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setServiceName(String serviceName);\n+\n+    /**\n+     * Sets the Zipkin V2 URL, e.g.: \"http://127.0.0.1:9411/api/v2/spans\".\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * @param v2Url the Zipkin V2 URL.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setV2Url(String v2Url);\n+\n+    /**\n+     * Sets the Zipkin sender.\n+     *\n+     * <p>At least one of {@code V2Url} and {@code Sender} needs to be specified. If both {@code\n+     * V2Url} and {@code Sender} are set, {@code Sender} takes precedence.\n+     *\n+     * <p>Note: if you provide a {@link Sender} instance via this method, the {@link Sender#close()}\n+     * method will be called when the exporter is shut down.\n+     *\n+     * @param sender the Zipkin sender.\n+     * @return this Builder instance.\n+     * @since 0.4.0\n+     */\n+    public abstract Builder setSender(Sender sender);\n+\n+    /**\n+     * Sets the {@link SpanBytesEncoder}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4d315f47740d5a71e4ff49ad1184ca20f569e89"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2Mzc2ODg3OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDozNDowOVrOGJeKKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMTo1OTowM1rOGJf5YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NDQ4OA==", "bodyText": "please don't add an empty endpoint", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412584488", "createdAt": "2020-04-22T00:34:09Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. For http see here:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // For discussion about GRPC errors/tags, see here:  https://github.com/openzipkin/brave/pull/999\n+  // Note: these 3 fields are non-private for testing\n+  static final String GRPC_STATUS_CODE = \"grpc.status_code\";\n+  static final String GRPC_STATUS_DESCRIPTION = \"grpc.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private static final Endpoint EMPTY_ENDPOINT = Endpoint.newBuilder().build();\n+\n+  private final BytesEncoder<Span> encoder;\n+  private final Sender sender;\n+\n+  ZipkinSpanExporter(BytesEncoder<Span> encoder, Sender sender) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+  }\n+\n+  static Span generateSpan(SpanData spanData) {\n+    Endpoint endpoint = EMPTY_ENDPOINT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e03b0ed0740fa6b09309533c54e6ab760fd8cf7b"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYwODMzOQ==", "bodyText": "The zipkin API just sets null when you pass in an empty one. Are you saying that if we can't make an endpoint, we shouldn't send spans?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412608339", "createdAt": "2020-04-22T01:46:13Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. For http see here:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // For discussion about GRPC errors/tags, see here:  https://github.com/openzipkin/brave/pull/999\n+  // Note: these 3 fields are non-private for testing\n+  static final String GRPC_STATUS_CODE = \"grpc.status_code\";\n+  static final String GRPC_STATUS_DESCRIPTION = \"grpc.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private static final Endpoint EMPTY_ENDPOINT = Endpoint.newBuilder().build();\n+\n+  private final BytesEncoder<Span> encoder;\n+  private final Sender sender;\n+\n+  ZipkinSpanExporter(BytesEncoder<Span> encoder, Sender sender) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+  }\n+\n+  static Span generateSpan(SpanData spanData) {\n+    Endpoint endpoint = EMPTY_ENDPOINT;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NDQ4OA=="}, "originalCommit": {"oid": "e03b0ed0740fa6b09309533c54e6ab760fd8cf7b"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxMjA2NQ==", "bodyText": "it is distracting to set an empty endpoint for reasons including what you mentioned. that's the main point. just call the endpoint builder when you have one?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412612065", "createdAt": "2020-04-22T01:56:30Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. For http see here:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // For discussion about GRPC errors/tags, see here:  https://github.com/openzipkin/brave/pull/999\n+  // Note: these 3 fields are non-private for testing\n+  static final String GRPC_STATUS_CODE = \"grpc.status_code\";\n+  static final String GRPC_STATUS_DESCRIPTION = \"grpc.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private static final Endpoint EMPTY_ENDPOINT = Endpoint.newBuilder().build();\n+\n+  private final BytesEncoder<Span> encoder;\n+  private final Sender sender;\n+\n+  ZipkinSpanExporter(BytesEncoder<Span> encoder, Sender sender) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+  }\n+\n+  static Span generateSpan(SpanData spanData) {\n+    Endpoint endpoint = EMPTY_ENDPOINT;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NDQ4OA=="}, "originalCommit": {"oid": "e03b0ed0740fa6b09309533c54e6ab760fd8cf7b"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxMjk2MQ==", "bodyText": "the longer answer is that it would be easy for this code to drift to adding more data into the span for no reason. For example, if you change codec later, it would likely serialize \"localEndpoint\": {} which is useless overhead, plus adding empty is already confusing.\nhope this makes sense.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412612961", "createdAt": "2020-04-22T01:59:03Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. For http see here:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // For discussion about GRPC errors/tags, see here:  https://github.com/openzipkin/brave/pull/999\n+  // Note: these 3 fields are non-private for testing\n+  static final String GRPC_STATUS_CODE = \"grpc.status_code\";\n+  static final String GRPC_STATUS_DESCRIPTION = \"grpc.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private static final Endpoint EMPTY_ENDPOINT = Endpoint.newBuilder().build();\n+\n+  private final BytesEncoder<Span> encoder;\n+  private final Sender sender;\n+\n+  ZipkinSpanExporter(BytesEncoder<Span> encoder, Sender sender) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+  }\n+\n+  static Span generateSpan(SpanData spanData) {\n+    Endpoint endpoint = EMPTY_ENDPOINT;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NDQ4OA=="}, "originalCommit": {"oid": "e03b0ed0740fa6b09309533c54e6ab760fd8cf7b"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2Mzc3NDA2OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDozNjoyNFrOGJeMyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDozNjoyNFrOGJeMyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NTE2Mg==", "bodyText": "use \n  \n    \n      opentelemetry-java/sdk/src/main/java/io/opentelemetry/sdk/resources/ResourceConstants.java\n    \n    \n         Line 32\n      in\n      6330901\n    \n    \n    \n    \n\n        \n          \n           public static final String SERVICE_NAME = \"service.name\"; \n        \n    \n  \n\n?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412585162", "createdAt": "2020-04-22T00:36:24Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. For http see here:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // For discussion about GRPC errors/tags, see here:  https://github.com/openzipkin/brave/pull/999\n+  // Note: these 3 fields are non-private for testing\n+  static final String GRPC_STATUS_CODE = \"grpc.status_code\";\n+  static final String GRPC_STATUS_DESCRIPTION = \"grpc.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private static final Endpoint EMPTY_ENDPOINT = Endpoint.newBuilder().build();\n+\n+  private final BytesEncoder<Span> encoder;\n+  private final Sender sender;\n+\n+  ZipkinSpanExporter(BytesEncoder<Span> encoder, Sender sender) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+  }\n+\n+  static Span generateSpan(SpanData spanData) {\n+    Endpoint endpoint = EMPTY_ENDPOINT;\n+    Map<String, AttributeValue> resourceAttributes = spanData.getResource().getAttributes();\n+    AttributeValue serviceNameValue = resourceAttributes.get(\"service.name\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e03b0ed0740fa6b09309533c54e6ab760fd8cf7b"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2Mzc5NTE2OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "isResolved": false, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDo0NDo0MlrOGJeXoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNTo0Mjo1N1rOGJ9WXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzkzNw==", "bodyText": "I understand where this is coming from and the discussions around it, but I still haven't heard any reason to believe \"service.name\" would be set by default. I suspect that's why the jaeger export was written to have a gear for this. \n  \n    \n      opentelemetry-java/exporters/jaeger/src/test/java/io/opentelemetry/exporters/jaeger/JaegerIntegrationTest.java\n    \n    \n         Line 85\n      in\n      c32c776\n    \n    \n    \n    \n\n        \n          \n           .setServiceName(SERVICE_NAME) \n        \n    \n  \n\n\nRecall the main thing we've done recently is dodge a 2 arg factory method. To make data unqueryable is a more bitter pill than just deleting that discussion and having no factory methods. Basically if this is all about the single arg factory method, it really isn't worth it to cause damage.\nA different point.. the whole thing started about the choice between endpoint and a different sender. This is not a complex enough problem to make us want to damage the data model by removing something more important for. If it is, simply remove the endpoint arg to \"buy us\" a service name one.\nIf it isn't a problem to have three methods (one for service, one for endpoint shortcut and one for the sender that uses) do an overload? Ex we do similarly in our okhttp sender (also autovalue)\n    /**\n     * No default. The POST URL for zipkin's <a href=\"https://zipkin.io/zipkin-api/#/\">v2 api</a>,\n     * usually \"http://zipkinhost:9411/api/v2/spans\"\n     */\n    // customizable so that users can re-map /api/v2/spans ex for browser-originated traces\n    public Builder endpoint(String endpoint) {\n      if (endpoint == null) throw new NullPointerException(\"endpoint == null\");\n      HttpUrl parsed = HttpUrl.parse(endpoint);\n      if (parsed == null) throw new IllegalArgumentException(\"invalid post url: \" + endpoint);\n      return endpoint(parsed);\n    }\nThe reason I'm so concerned basically is I cannot see anything in this repo that sets this and we know lack thereof results in unqueryable and unaggregatable data. Using a dummy name which cannot be set at a level people are likely to control will result in an unfairly bad experience vs jaeger who have a setting. This is not worth waiting for complaints about (which likely would dump into zipkin's channel)\nRegardless, if we want to suggest to prioritize the \"service.name\", knowing we have a fallback, both should be in the README. When there's a normalized way to set the \"service.name\" in the span resource above this tier, both jaeger and zipkin exporters can get a README update.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412587937", "createdAt": "2020-04-22T00:44:42Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. For http see here:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // For discussion about GRPC errors/tags, see here:  https://github.com/openzipkin/brave/pull/999\n+  // Note: these 3 fields are non-private for testing\n+  static final String GRPC_STATUS_CODE = \"grpc.status_code\";\n+  static final String GRPC_STATUS_DESCRIPTION = \"grpc.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private static final Endpoint EMPTY_ENDPOINT = Endpoint.newBuilder().build();\n+\n+  private final BytesEncoder<Span> encoder;\n+  private final Sender sender;\n+\n+  ZipkinSpanExporter(BytesEncoder<Span> encoder, Sender sender) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+  }\n+\n+  static Span generateSpan(SpanData spanData) {\n+    Endpoint endpoint = EMPTY_ENDPOINT;\n+    Map<String, AttributeValue> resourceAttributes = spanData.getResource().getAttributes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e03b0ed0740fa6b09309533c54e6ab760fd8cf7b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU5MDc2OQ==", "bodyText": "my first stab at writing that comment was crap.. hopefully my rewording above is more coherent (coffee is setting in)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412590769", "createdAt": "2020-04-22T00:53:35Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. For http see here:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // For discussion about GRPC errors/tags, see here:  https://github.com/openzipkin/brave/pull/999\n+  // Note: these 3 fields are non-private for testing\n+  static final String GRPC_STATUS_CODE = \"grpc.status_code\";\n+  static final String GRPC_STATUS_DESCRIPTION = \"grpc.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private static final Endpoint EMPTY_ENDPOINT = Endpoint.newBuilder().build();\n+\n+  private final BytesEncoder<Span> encoder;\n+  private final Sender sender;\n+\n+  ZipkinSpanExporter(BytesEncoder<Span> encoder, Sender sender) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+  }\n+\n+  static Span generateSpan(SpanData spanData) {\n+    Endpoint endpoint = EMPTY_ENDPOINT;\n+    Map<String, AttributeValue> resourceAttributes = spanData.getResource().getAttributes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzkzNw=="}, "originalCommit": {"oid": "e03b0ed0740fa6b09309533c54e6ab760fd8cf7b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxMDMxNA==", "bodyText": "The idea, as I understand it, is that the person configuring the SDK will add the Resource to the TracerProvider once, at startup. It's not code that would exist in the SDK itself, but written by the SDK user.\nI'm not sure about that jaeger exporter, and why it might have been written that way. My guess is that it predates the semantic convention of putting service.name in the Resource.\nI'll put an exporter-level serviceName back and have it be the fallback.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412610314", "createdAt": "2020-04-22T01:51:49Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. For http see here:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // For discussion about GRPC errors/tags, see here:  https://github.com/openzipkin/brave/pull/999\n+  // Note: these 3 fields are non-private for testing\n+  static final String GRPC_STATUS_CODE = \"grpc.status_code\";\n+  static final String GRPC_STATUS_DESCRIPTION = \"grpc.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private static final Endpoint EMPTY_ENDPOINT = Endpoint.newBuilder().build();\n+\n+  private final BytesEncoder<Span> encoder;\n+  private final Sender sender;\n+\n+  ZipkinSpanExporter(BytesEncoder<Span> encoder, Sender sender) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+  }\n+\n+  static Span generateSpan(SpanData spanData) {\n+    Endpoint endpoint = EMPTY_ENDPOINT;\n+    Map<String, AttributeValue> resourceAttributes = spanData.getResource().getAttributes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzkzNw=="}, "originalCommit": {"oid": "e03b0ed0740fa6b09309533c54e6ab760fd8cf7b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYzOTAwOA==", "bodyText": "There is an issue to use the resource for that in Jaeger", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412639008", "createdAt": "2020-04-22T03:19:44Z", "author": {"login": "bogdandrutu"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. For http see here:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // For discussion about GRPC errors/tags, see here:  https://github.com/openzipkin/brave/pull/999\n+  // Note: these 3 fields are non-private for testing\n+  static final String GRPC_STATUS_CODE = \"grpc.status_code\";\n+  static final String GRPC_STATUS_DESCRIPTION = \"grpc.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private static final Endpoint EMPTY_ENDPOINT = Endpoint.newBuilder().build();\n+\n+  private final BytesEncoder<Span> encoder;\n+  private final Sender sender;\n+\n+  ZipkinSpanExporter(BytesEncoder<Span> encoder, Sender sender) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+  }\n+\n+  static Span generateSpan(SpanData spanData) {\n+    Endpoint endpoint = EMPTY_ENDPOINT;\n+    Map<String, AttributeValue> resourceAttributes = spanData.getResource().getAttributes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzkzNw=="}, "originalCommit": {"oid": "e03b0ed0740fa6b09309533c54e6ab760fd8cf7b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0MDA0Mw==", "bodyText": "cool maybe link to that in a TODO. regardless it seems a fallback is prudent.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412640043", "createdAt": "2020-04-22T03:23:06Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. For http see here:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // For discussion about GRPC errors/tags, see here:  https://github.com/openzipkin/brave/pull/999\n+  // Note: these 3 fields are non-private for testing\n+  static final String GRPC_STATUS_CODE = \"grpc.status_code\";\n+  static final String GRPC_STATUS_DESCRIPTION = \"grpc.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private static final Endpoint EMPTY_ENDPOINT = Endpoint.newBuilder().build();\n+\n+  private final BytesEncoder<Span> encoder;\n+  private final Sender sender;\n+\n+  ZipkinSpanExporter(BytesEncoder<Span> encoder, Sender sender) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+  }\n+\n+  static Span generateSpan(SpanData spanData) {\n+    Endpoint endpoint = EMPTY_ENDPOINT;\n+    Map<String, AttributeValue> resourceAttributes = spanData.getResource().getAttributes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzkzNw=="}, "originalCommit": {"oid": "e03b0ed0740fa6b09309533c54e6ab760fd8cf7b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0NjQzMw==", "bodyText": "#978", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412646433", "createdAt": "2020-04-22T03:43:41Z", "author": {"login": "bogdandrutu"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. For http see here:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // For discussion about GRPC errors/tags, see here:  https://github.com/openzipkin/brave/pull/999\n+  // Note: these 3 fields are non-private for testing\n+  static final String GRPC_STATUS_CODE = \"grpc.status_code\";\n+  static final String GRPC_STATUS_DESCRIPTION = \"grpc.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private static final Endpoint EMPTY_ENDPOINT = Endpoint.newBuilder().build();\n+\n+  private final BytesEncoder<Span> encoder;\n+  private final Sender sender;\n+\n+  ZipkinSpanExporter(BytesEncoder<Span> encoder, Sender sender) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+  }\n+\n+  static Span generateSpan(SpanData spanData) {\n+    Endpoint endpoint = EMPTY_ENDPOINT;\n+    Map<String, AttributeValue> resourceAttributes = spanData.getResource().getAttributes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzkzNw=="}, "originalCommit": {"oid": "e03b0ed0740fa6b09309533c54e6ab760fd8cf7b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0Njg1Mw==", "bodyText": "There are some concerns that you also pointed. We should resolve both exporters when we do it.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r412646853", "createdAt": "2020-04-22T03:45:19Z", "author": {"login": "bogdandrutu"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. For http see here:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // For discussion about GRPC errors/tags, see here:  https://github.com/openzipkin/brave/pull/999\n+  // Note: these 3 fields are non-private for testing\n+  static final String GRPC_STATUS_CODE = \"grpc.status_code\";\n+  static final String GRPC_STATUS_DESCRIPTION = \"grpc.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private static final Endpoint EMPTY_ENDPOINT = Endpoint.newBuilder().build();\n+\n+  private final BytesEncoder<Span> encoder;\n+  private final Sender sender;\n+\n+  ZipkinSpanExporter(BytesEncoder<Span> encoder, Sender sender) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+  }\n+\n+  static Span generateSpan(SpanData spanData) {\n+    Endpoint endpoint = EMPTY_ENDPOINT;\n+    Map<String, AttributeValue> resourceAttributes = spanData.getResource().getAttributes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzkzNw=="}, "originalCommit": {"oid": "e03b0ed0740fa6b09309533c54e6ab760fd8cf7b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA1MTk1Ng==", "bodyText": "Also we have this defined in specs as well:\nopen-telemetry/opentelemetry-specification#472\n@adriancole may want to confirm that it is what you expect :). Thanks", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r413051956", "createdAt": "2020-04-22T14:51:17Z", "author": {"login": "bogdandrutu"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. For http see here:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // For discussion about GRPC errors/tags, see here:  https://github.com/openzipkin/brave/pull/999\n+  // Note: these 3 fields are non-private for testing\n+  static final String GRPC_STATUS_CODE = \"grpc.status_code\";\n+  static final String GRPC_STATUS_DESCRIPTION = \"grpc.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private static final Endpoint EMPTY_ENDPOINT = Endpoint.newBuilder().build();\n+\n+  private final BytesEncoder<Span> encoder;\n+  private final Sender sender;\n+\n+  ZipkinSpanExporter(BytesEncoder<Span> encoder, Sender sender) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+  }\n+\n+  static Span generateSpan(SpanData spanData) {\n+    Endpoint endpoint = EMPTY_ENDPOINT;\n+    Map<String, AttributeValue> resourceAttributes = spanData.getResource().getAttributes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzkzNw=="}, "originalCommit": {"oid": "e03b0ed0740fa6b09309533c54e6ab760fd8cf7b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5NTUxNw==", "bodyText": "ok, I restored the serviceName option, but have it be superceded by the service.name set in the Resource, if it's there. Phew.\nIf this is an ok approach for now, then let's get this bad boy merged and see if it works!", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r413095517", "createdAt": "2020-04-22T15:42:57Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.AttributeValue.Type;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import zipkin2.Endpoint;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.reporter.Sender;\n+\n+/**\n+ * This class was based on the OpenCensus zipkin exporter code at\n+ * https://github.com/census-instrumentation/opencensus-java/tree/c960b19889de5e4a7b25f90919d28b066590d4f0/exporters/trace/zipkin\n+ */\n+final class ZipkinSpanExporter implements SpanExporter {\n+\n+  private static final Logger logger = Logger.getLogger(ZipkinSpanExporter.class.getName());\n+\n+  // The naming follows Zipkin convention. For http see here:\n+  // https://github.com/openzipkin/brave/blob/eee993f998ae57b08644cc357a6d478827428710/instrumentation/http/src/main/java/brave/http/HttpTags.java\n+  // For discussion about GRPC errors/tags, see here:  https://github.com/openzipkin/brave/pull/999\n+  // Note: these 3 fields are non-private for testing\n+  static final String GRPC_STATUS_CODE = \"grpc.status_code\";\n+  static final String GRPC_STATUS_DESCRIPTION = \"grpc.status_description\";\n+  static final String STATUS_ERROR = \"error\";\n+\n+  private static final Endpoint EMPTY_ENDPOINT = Endpoint.newBuilder().build();\n+\n+  private final BytesEncoder<Span> encoder;\n+  private final Sender sender;\n+\n+  ZipkinSpanExporter(BytesEncoder<Span> encoder, Sender sender) {\n+    this.encoder = encoder;\n+    this.sender = sender;\n+  }\n+\n+  static Span generateSpan(SpanData spanData) {\n+    Endpoint endpoint = EMPTY_ENDPOINT;\n+    Map<String, AttributeValue> resourceAttributes = spanData.getResource().getAttributes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzkzNw=="}, "originalCommit": {"oid": "e03b0ed0740fa6b09309533c54e6ab760fd8cf7b"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2OTI1Mzk3OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/README.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMzo1MjozN1rOGKQjzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNTozODoyM1rOGKuu8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMDI1NQ==", "bodyText": "fix the drift?", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r413410255", "createdAt": "2020-04-22T23:52:37Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/README.md", "diffHunk": "@@ -0,0 +1,40 @@\n+# OpenTelemetry - Zipkin Span Exporter\n+\n+[![Javadocs][javadoc-image]][javadoc-url]\n+\n+This is an OpenTelemetry exporter that sends span data using the [io.zipkin.reporter2:zipkin-reporter](https://github.com/openzipkin/zipkin-reporter-java\") library.\n+\n+By default, this POSTs json in [Zipkin format](https://zipkin.io/zipkin-api/#/default/post_spans) to\n+a specified HTTP URL. This could be to a [Zipkin](https://zipkin.io) service, or anything that\n+consumes the same format.\n+\n+You can alternatively use other formats, such as protobuf, or override the `Sender` to use a non-HTTP transport, such as Kafka.\n+\n+## Configuration\n+\n+The Zipkin span exporter can be configured programmatically.\n+\n+An example of simple Zipkin exporter initialization. In this case\n+spans will be sent to a Zipkin endpoint running on `localhost`:\n+\n+```java\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setV2Url(\"http://localhost/api/v2/spans\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8112b7a6dbe4cdb634c917da13facae524b7f207"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg5NTg0Mw==", "bodyText": "done", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r413895843", "createdAt": "2020-04-23T15:27:46Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/README.md", "diffHunk": "@@ -0,0 +1,40 @@\n+# OpenTelemetry - Zipkin Span Exporter\n+\n+[![Javadocs][javadoc-image]][javadoc-url]\n+\n+This is an OpenTelemetry exporter that sends span data using the [io.zipkin.reporter2:zipkin-reporter](https://github.com/openzipkin/zipkin-reporter-java\") library.\n+\n+By default, this POSTs json in [Zipkin format](https://zipkin.io/zipkin-api/#/default/post_spans) to\n+a specified HTTP URL. This could be to a [Zipkin](https://zipkin.io) service, or anything that\n+consumes the same format.\n+\n+You can alternatively use other formats, such as protobuf, or override the `Sender` to use a non-HTTP transport, such as Kafka.\n+\n+## Configuration\n+\n+The Zipkin span exporter can be configured programmatically.\n+\n+An example of simple Zipkin exporter initialization. In this case\n+spans will be sent to a Zipkin endpoint running on `localhost`:\n+\n+```java\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setV2Url(\"http://localhost/api/v2/spans\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMDI1NQ=="}, "originalCommit": {"oid": "8112b7a6dbe4cdb634c917da13facae524b7f207"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwNDYyNg==", "bodyText": "done", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r413904626", "createdAt": "2020-04-23T15:38:23Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/README.md", "diffHunk": "@@ -0,0 +1,40 @@\n+# OpenTelemetry - Zipkin Span Exporter\n+\n+[![Javadocs][javadoc-image]][javadoc-url]\n+\n+This is an OpenTelemetry exporter that sends span data using the [io.zipkin.reporter2:zipkin-reporter](https://github.com/openzipkin/zipkin-reporter-java\") library.\n+\n+By default, this POSTs json in [Zipkin format](https://zipkin.io/zipkin-api/#/default/post_spans) to\n+a specified HTTP URL. This could be to a [Zipkin](https://zipkin.io) service, or anything that\n+consumes the same format.\n+\n+You can alternatively use other formats, such as protobuf, or override the `Sender` to use a non-HTTP transport, such as Kafka.\n+\n+## Configuration\n+\n+The Zipkin span exporter can be configured programmatically.\n+\n+An example of simple Zipkin exporter initialization. In this case\n+spans will be sent to a Zipkin endpoint running on `localhost`:\n+\n+```java\n+    ZipkinExporterConfiguration configuration =\n+        ZipkinExporterConfiguration.builder()\n+            .setV2Url(\"http://localhost/api/v2/spans\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMDI1NQ=="}, "originalCommit": {"oid": "8112b7a6dbe4cdb634c917da13facae524b7f207"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2OTI1Nzg1OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMzo1NDoxMVrOGKQmBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwMTozNTo0M1rOGKSsvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMDgyMQ==", "bodyText": "I really don't like factory methods like this personally as two string args can be easily permuted, but I don't feel like holding you up on another round as it isn't important enough and people can figure it out.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r413410821", "createdAt": "2020-04-22T23:54:11Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+import zipkin2.reporter.urlconnection.URLConnectionSender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  abstract String getServiceName();\n+\n+  abstract Sender getSender();\n+\n+  abstract BytesEncoder<Span> getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder} with defaults set to an \"unknown\" serviceName and using the\n+   * {@link SpanBytesEncoder#JSON_V2} encoder.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setEncoder(SpanBytesEncoder.JSON_V2)\n+        .setServiceName(\"unknown\");\n+  }\n+\n+  /**\n+   * Builds a HTTP exporter for <a href=\"https://zipkin.io/zipkin-api/#/\">Zipkin V2</a> format.\n+   *\n+   * @param endpoint The Zipkin endpoint URL, ex. \"http://zipkinhost:9411/api/v2/spans\".\n+   * @param serviceName The serviceName with which to identify Spans. See {@link\n+   *     Builder#setServiceName(String)} for details.\n+   */\n+  public static ZipkinExporterConfiguration create(String endpoint, String serviceName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8112b7a6dbe4cdb634c917da13facae524b7f207"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ0MTU1NA==", "bodyText": "So... no factory methods, or just the one with a single arg? I have no strong opinion either way.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r413441554", "createdAt": "2020-04-23T01:24:18Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+import zipkin2.reporter.urlconnection.URLConnectionSender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  abstract String getServiceName();\n+\n+  abstract Sender getSender();\n+\n+  abstract BytesEncoder<Span> getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder} with defaults set to an \"unknown\" serviceName and using the\n+   * {@link SpanBytesEncoder#JSON_V2} encoder.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setEncoder(SpanBytesEncoder.JSON_V2)\n+        .setServiceName(\"unknown\");\n+  }\n+\n+  /**\n+   * Builds a HTTP exporter for <a href=\"https://zipkin.io/zipkin-api/#/\">Zipkin V2</a> format.\n+   *\n+   * @param endpoint The Zipkin endpoint URL, ex. \"http://zipkinhost:9411/api/v2/spans\".\n+   * @param serviceName The serviceName with which to identify Spans. See {@link\n+   *     Builder#setServiceName(String)} for details.\n+   */\n+  public static ZipkinExporterConfiguration create(String endpoint, String serviceName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMDgyMQ=="}, "originalCommit": {"oid": "8112b7a6dbe4cdb634c917da13facae524b7f207"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ0NTMxMA==", "bodyText": "because of \"service.name\" isn't in a crystal clear state, I think it is better to use the builder similar to how jaeger does, and fail if a fallback service name isn't given. this forces folks to think about this, for example, there's often an application name property somewhere they can reach even if they can't affect instrumentation to affect \"service.name\" They can be told that if you don't know one set \"unknown\" but I feel it is better to let them see the importance of it via making the property required.\nex \"unknown\" makes a almost useless aggregation which can be hard to hunt down. We use this because we used to use it. It is true there's a slight amount of value as you can see bugs where people didn't set a value in one place, and \"unknown\" is better for people to punt with vs making up new words for \"unknown\".\nAll that said, many wouldn't even know to set this unless told to via a required property. I think using required as a means to help users who know a better value set one from config, is a better optimization than what would likely be the opposite, where folks only find out that they should have set it by looking at traces already in the system.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r413445310", "createdAt": "2020-04-23T01:35:43Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+import zipkin2.reporter.urlconnection.URLConnectionSender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  abstract String getServiceName();\n+\n+  abstract Sender getSender();\n+\n+  abstract BytesEncoder<Span> getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder} with defaults set to an \"unknown\" serviceName and using the\n+   * {@link SpanBytesEncoder#JSON_V2} encoder.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setEncoder(SpanBytesEncoder.JSON_V2)\n+        .setServiceName(\"unknown\");\n+  }\n+\n+  /**\n+   * Builds a HTTP exporter for <a href=\"https://zipkin.io/zipkin-api/#/\">Zipkin V2</a> format.\n+   *\n+   * @param endpoint The Zipkin endpoint URL, ex. \"http://zipkinhost:9411/api/v2/spans\".\n+   * @param serviceName The serviceName with which to identify Spans. See {@link\n+   *     Builder#setServiceName(String)} for details.\n+   */\n+  public static ZipkinExporterConfiguration create(String endpoint, String serviceName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMDgyMQ=="}, "originalCommit": {"oid": "8112b7a6dbe4cdb634c917da13facae524b7f207"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2OTI2MzE3OnYy", "diffSide": "RIGHT", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMzo1NjowM1rOGKQo3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNTozODoxM1rOGKuuag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMTU0OA==", "bodyText": "I feel it is better to have someone forced to be add their own \"unknown\" vs do it for them. Similar to previous comments I'm not sure the value in creating a new way to make \"unknown\" and I think these factory methods will do just that. personally I would delete them and just have usage similar to jaeger in README asking them to indicate a fallback (default) service name.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r413411548", "createdAt": "2020-04-22T23:56:03Z", "author": {"login": "codefromthecrypt"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+import zipkin2.reporter.urlconnection.URLConnectionSender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  abstract String getServiceName();\n+\n+  abstract Sender getSender();\n+\n+  abstract BytesEncoder<Span> getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder} with defaults set to an \"unknown\" serviceName and using the\n+   * {@link SpanBytesEncoder#JSON_V2} encoder.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setEncoder(SpanBytesEncoder.JSON_V2)\n+        .setServiceName(\"unknown\");\n+  }\n+\n+  /**\n+   * Builds a HTTP exporter for <a href=\"https://zipkin.io/zipkin-api/#/\">Zipkin V2</a> format.\n+   *\n+   * @param endpoint The Zipkin endpoint URL, ex. \"http://zipkinhost:9411/api/v2/spans\".\n+   * @param serviceName The serviceName with which to identify Spans. See {@link\n+   *     Builder#setServiceName(String)} for details.\n+   */\n+  public static ZipkinExporterConfiguration create(String endpoint, String serviceName) {\n+    return ZipkinExporterConfiguration.builder()\n+        .setEndpoint(endpoint)\n+        .setServiceName(serviceName)\n+        .build();\n+  }\n+\n+  /**\n+   * Builds a HTTP exporter for <a href=\"https://zipkin.io/zipkin-api/#/\">Zipkin V2</a> format.\n+   *\n+   * @param endpoint The Zipkin endpoint URL, ex. \"http://zipkinhost:9411/api/v2/spans\".\n+   */\n+  public static ZipkinExporterConfiguration create(String endpoint) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8112b7a6dbe4cdb634c917da13facae524b7f207"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwNDQ5MA==", "bodyText": "remove the \"unknown\" from the defaults; serviceName is now required.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1106#discussion_r413904490", "createdAt": "2020-04-23T15:38:13Z", "author": {"login": "jkwatson"}, "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinExporterConfiguration.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.zipkin;\n+\n+import com.google.auto.value.AutoValue;\n+import javax.annotation.concurrent.Immutable;\n+import zipkin2.Span;\n+import zipkin2.codec.BytesEncoder;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Sender;\n+import zipkin2.reporter.urlconnection.URLConnectionSender;\n+\n+/**\n+ * Configurations for {@link ZipkinSpanExporter}.\n+ *\n+ * @since 0.4.0\n+ */\n+@AutoValue\n+@Immutable\n+public abstract class ZipkinExporterConfiguration {\n+\n+  ZipkinExporterConfiguration() {}\n+\n+  abstract String getServiceName();\n+\n+  abstract Sender getSender();\n+\n+  abstract BytesEncoder<Span> getEncoder();\n+\n+  /**\n+   * Returns a new {@link Builder} with defaults set to an \"unknown\" serviceName and using the\n+   * {@link SpanBytesEncoder#JSON_V2} encoder.\n+   *\n+   * @return a {@code Builder}.\n+   * @since 0.4.0\n+   */\n+  public static Builder builder() {\n+    return new AutoValue_ZipkinExporterConfiguration.Builder()\n+        .setEncoder(SpanBytesEncoder.JSON_V2)\n+        .setServiceName(\"unknown\");\n+  }\n+\n+  /**\n+   * Builds a HTTP exporter for <a href=\"https://zipkin.io/zipkin-api/#/\">Zipkin V2</a> format.\n+   *\n+   * @param endpoint The Zipkin endpoint URL, ex. \"http://zipkinhost:9411/api/v2/spans\".\n+   * @param serviceName The serviceName with which to identify Spans. See {@link\n+   *     Builder#setServiceName(String)} for details.\n+   */\n+  public static ZipkinExporterConfiguration create(String endpoint, String serviceName) {\n+    return ZipkinExporterConfiguration.builder()\n+        .setEndpoint(endpoint)\n+        .setServiceName(serviceName)\n+        .build();\n+  }\n+\n+  /**\n+   * Builds a HTTP exporter for <a href=\"https://zipkin.io/zipkin-api/#/\">Zipkin V2</a> format.\n+   *\n+   * @param endpoint The Zipkin endpoint URL, ex. \"http://zipkinhost:9411/api/v2/spans\".\n+   */\n+  public static ZipkinExporterConfiguration create(String endpoint) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMTU0OA=="}, "originalCommit": {"oid": "8112b7a6dbe4cdb634c917da13facae524b7f207"}, "originalPosition": 76}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 845, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}