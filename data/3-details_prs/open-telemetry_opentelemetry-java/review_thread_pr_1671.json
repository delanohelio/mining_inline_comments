{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkwNjU5NjQy", "number": 1671, "reviewThreads": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNDowOToyN1rOEl6nHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwNToyODoxOVrOEnts8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MTkzMDU0OnYy", "diffSide": "RIGHT", "path": "sdk_extensions/aws_v1_support/build.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNDowOToyN1rOHVpnsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNDoyNzozM1rOHX0jIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ2NDA1MA==", "bodyText": "This is a pretty heavyweight dependency, just one of the transitive dependencies alone is 8MB and I think total it will possibly double the agent size.\nCan you try making direct calls to the API? FWIU, token is just a file to read so authentication is very easy for k8s API so it's mostly just parsing, which doesn't seem too bad.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r492464050", "createdAt": "2020-09-22T04:09:27Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/build.gradle", "diffHunk": "@@ -16,6 +16,11 @@ dependencies {\n             libraries.guava,\n             platform(boms.guava)\n \n+    implementation 'com.fasterxml.jackson.core:jackson-databind:2.11.0',\n+            libraries.guava,\n+            platform(boms.guava)\n+    implementation 'io.kubernetes:client-java:9.0.0'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3551a5ad1a2ebfcafee3999ec45af793161e4e0b"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0MDI1Nw==", "bodyText": "use HttpURLConnection instead of k8s client", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494740257", "createdAt": "2020-09-25T04:27:33Z", "author": {"login": "wangzlei"}, "path": "sdk_extensions/aws_v1_support/build.gradle", "diffHunk": "@@ -16,6 +16,11 @@ dependencies {\n             libraries.guava,\n             platform(boms.guava)\n \n+    implementation 'com.fasterxml.jackson.core:jackson-databind:2.11.0',\n+            libraries.guava,\n+            platform(boms.guava)\n+    implementation 'io.kubernetes:client-java:9.0.0'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ2NDA1MA=="}, "originalCommit": {"oid": "3551a5ad1a2ebfcafee3999ec45af793161e4e0b"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MTk0MDQ5OnYy", "diffSide": "RIGHT", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/EksHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNDoxNjoxMVrOHVptKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNDoyODoyN1rOHX0j7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ2NTQ0OQ==", "bodyText": "Should be able to do one call to get a config map instead of listing\nhttps://docs.openshift.com/container-platform/3.7/rest_api/api/v1.ConfigMap.html#Get-api-v1-namespaces-namespace-configmaps-name", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r492465449", "createdAt": "2020-09-22T04:16:11Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/EksHelper.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.Configuration;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapList;\n+import io.kubernetes.client.util.Config;\n+import java.io.IOException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+class EksHelper {\n+\n+  private static final Logger logger = Logger.getLogger(EksHelper.class.getName());\n+\n+  private static final String NAMESPACE_KUBE_SYSTEM = \"kube-system\";\n+  private static final String NAMESPACE_AWS_CLOUDWATCH = \"amazon-cloudwatch\";\n+  private static final String EKS_CONFIGMAP = \"aws-auth\";\n+  private static final String CLOUDWATCH_CONFIGMAP = \"cluster-info\";\n+  private static final String CLUSTER_NAME_KEY = \"cluster.name\";\n+\n+  @Nullable private final CoreV1Api k8sApi;\n+\n+  public EksHelper() {\n+    CoreV1Api k8sApi = null;\n+    try {\n+      ApiClient client = Config.defaultClient();\n+      Configuration.setDefaultApiClient(client);\n+      k8sApi = new CoreV1Api();\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, \"Failed to init k8s client API, sdk is not running on EKS.\");\n+    }\n+    this.k8sApi = k8sApi;\n+  }\n+\n+  @VisibleForTesting\n+  public EksHelper(CoreV1Api k8sApi) {\n+    this.k8sApi = k8sApi;\n+  }\n+\n+  boolean isEks() {\n+    if (k8sApi == null) {\n+      return false;\n+    }\n+\n+    try {\n+      V1ConfigMapList configMapList =\n+          k8sApi.listNamespacedConfigMap(\n+              NAMESPACE_KUBE_SYSTEM, null, null, null, null, null, null, null, null, null);\n+\n+      if (configMapList == null) {\n+        logger.log(Level.INFO, \"Failed to get configmap of namespace %s.\", NAMESPACE_KUBE_SYSTEM);\n+        return false;\n+      }\n+\n+      for (V1ConfigMap item : configMapList.getItems()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3551a5ad1a2ebfcafee3999ec45af793161e4e0b"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0MDQ2MA==", "bodyText": "yeah, seems k8s client sdk does not support accurate query, will change to call restful api directly", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494740460", "createdAt": "2020-09-25T04:28:27Z", "author": {"login": "wangzlei"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/EksHelper.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.kubernetes.client.openapi.ApiClient;\n+import io.kubernetes.client.openapi.ApiException;\n+import io.kubernetes.client.openapi.Configuration;\n+import io.kubernetes.client.openapi.apis.CoreV1Api;\n+import io.kubernetes.client.openapi.models.V1ConfigMap;\n+import io.kubernetes.client.openapi.models.V1ConfigMapList;\n+import io.kubernetes.client.util.Config;\n+import java.io.IOException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+class EksHelper {\n+\n+  private static final Logger logger = Logger.getLogger(EksHelper.class.getName());\n+\n+  private static final String NAMESPACE_KUBE_SYSTEM = \"kube-system\";\n+  private static final String NAMESPACE_AWS_CLOUDWATCH = \"amazon-cloudwatch\";\n+  private static final String EKS_CONFIGMAP = \"aws-auth\";\n+  private static final String CLOUDWATCH_CONFIGMAP = \"cluster-info\";\n+  private static final String CLUSTER_NAME_KEY = \"cluster.name\";\n+\n+  @Nullable private final CoreV1Api k8sApi;\n+\n+  public EksHelper() {\n+    CoreV1Api k8sApi = null;\n+    try {\n+      ApiClient client = Config.defaultClient();\n+      Configuration.setDefaultApiClient(client);\n+      k8sApi = new CoreV1Api();\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, \"Failed to init k8s client API, sdk is not running on EKS.\");\n+    }\n+    this.k8sApi = k8sApi;\n+  }\n+\n+  @VisibleForTesting\n+  public EksHelper(CoreV1Api k8sApi) {\n+    this.k8sApi = k8sApi;\n+  }\n+\n+  boolean isEks() {\n+    if (k8sApi == null) {\n+      return false;\n+    }\n+\n+    try {\n+      V1ConfigMapList configMapList =\n+          k8sApi.listNamespacedConfigMap(\n+              NAMESPACE_KUBE_SYSTEM, null, null, null, null, null, null, null, null, null);\n+\n+      if (configMapList == null) {\n+        logger.log(Level.INFO, \"Failed to get configmap of namespace %s.\", NAMESPACE_KUBE_SYSTEM);\n+        return false;\n+      }\n+\n+      for (V1ConfigMap item : configMapList.getItems()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ2NTQ0OQ=="}, "originalCommit": {"oid": "3551a5ad1a2ebfcafee3999ec45af793161e4e0b"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NjU3MjE3OnYy", "diffSide": "RIGHT", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNToyNjo0MFrOHX1cSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMTozMjo1NVrOHYTfvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NDg4OQ==", "bodyText": "Nothing particularly restful, let's call it just HttpClient or JdkHttpClient", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494754889", "createdAt": "2020-09-25T05:26:40Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0NzI5NQ==", "bodyText": "Change to JdkHttpClient", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495247295", "createdAt": "2020-09-25T21:32:55Z", "author": {"login": "wangzlei"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NDg4OQ=="}, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NjU3NjQwOnYy", "diffSide": "RIGHT", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNToyOToxMFrOHX1eyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMTozMzozMVrOHYTheg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NTUzMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return String.format(\"Bearer %s\", content);\n          \n          \n            \n                  return \"Bearer \" + content;\n          \n      \n    \n    \n  \n\nAvoid String.format since it's slow performance and rarely that much more readable", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494755531", "createdAt": "2020-09-25T05:29:10Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      if (requestPropertyMap != null) {\n+        for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+          connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+        }\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.WARNING,\n+            String.format(\n+                \"Error reponse from %s code (%s) text %s\",\n+                urlStr, responseCode, readResponseString(connection)));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Restful Client fetch string failed: %s\", e));\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      throw new IllegalStateException(\"UTF-8 not supported can't happen.\", e);\n+    }\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(String keystorePath) {\n+    try {\n+      KeyStore keyStore = getK8sKeystore(keystorePath);\n+\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception: %s\", e);\n+    }\n+    return null;\n+  }\n+\n+  String getK8sCredHeader(String tokenFilePath) {\n+    try {\n+      File file = new File(tokenFilePath);\n+      String content = Files.asCharSource(file, Charsets.UTF_8).read();\n+      return String.format(\"Bearer %s\", content);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0NzczOA==", "bodyText": "ok, will change all of String.format to '+'", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495247738", "createdAt": "2020-09-25T21:33:31Z", "author": {"login": "wangzlei"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      if (requestPropertyMap != null) {\n+        for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+          connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+        }\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.WARNING,\n+            String.format(\n+                \"Error reponse from %s code (%s) text %s\",\n+                urlStr, responseCode, readResponseString(connection)));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Restful Client fetch string failed: %s\", e));\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      throw new IllegalStateException(\"UTF-8 not supported can't happen.\", e);\n+    }\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(String keystorePath) {\n+    try {\n+      KeyStore keyStore = getK8sKeystore(keystorePath);\n+\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception: %s\", e);\n+    }\n+    return null;\n+  }\n+\n+  String getK8sCredHeader(String tokenFilePath) {\n+    try {\n+      File file = new File(tokenFilePath);\n+      String content = Files.asCharSource(file, Charsets.UTF_8).read();\n+      return String.format(\"Bearer %s\", content);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NTUzMQ=="}, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NjYwODM2OnYy", "diffSide": "RIGHT", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTo0NTo0N1rOHX1wYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMTozNDowOVrOHYTjmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDAzMw==", "bodyText": "Let's avoid doing anything if keyStore is null due to an error. So I guess in the caller,\nKeyStore keyStore = getK8sKeystore(keystorePath);\nif (keyStore != null) { ((HttpsURLConnection))connection.setSslSocketFactory(buildSslSocketFactory(keyStore));", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494760033", "createdAt": "2020-09-25T05:45:47Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      if (requestPropertyMap != null) {\n+        for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+          connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+        }\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.WARNING,\n+            String.format(\n+                \"Error reponse from %s code (%s) text %s\",\n+                urlStr, responseCode, readResponseString(connection)));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Restful Client fetch string failed: %s\", e));\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      throw new IllegalStateException(\"UTF-8 not supported can't happen.\", e);\n+    }\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(String keystorePath) {\n+    try {\n+      KeyStore keyStore = getK8sKeystore(keystorePath);\n+\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0ODI4Mw==", "bodyText": "fix in next commit", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495248283", "createdAt": "2020-09-25T21:34:09Z", "author": {"login": "wangzlei"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      if (requestPropertyMap != null) {\n+        for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+          connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+        }\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.WARNING,\n+            String.format(\n+                \"Error reponse from %s code (%s) text %s\",\n+                urlStr, responseCode, readResponseString(connection)));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Restful Client fetch string failed: %s\", e));\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      throw new IllegalStateException(\"UTF-8 not supported can't happen.\", e);\n+    }\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(String keystorePath) {\n+    try {\n+      KeyStore keyStore = getK8sKeystore(keystorePath);\n+\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDAzMw=="}, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NjYxMDU1OnYy", "diffSide": "RIGHT", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTo0NzowMVrOHX1xqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTo0NzowMVrOHX1xqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDM2Mw==", "bodyText": "This is an internal class, let's assume it's not null", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494760363", "createdAt": "2020-09-25T05:47:01Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      if (requestPropertyMap != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NjYxMTMwOnYy", "diffSide": "RIGHT", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTo0NzozMVrOHX1yMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTo0NzozMVrOHX1yMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDQ5Ng==", "bodyText": "This is an internal class, let's keep the logic more direct - we can assume not null means not empty, these are passed by our code, not users", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494760496", "createdAt": "2020-09-25T05:47:31Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NjYxMTg3OnYy", "diffSide": "RIGHT", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTo0Nzo0OFrOHX1yfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMTozNToxNFrOHYTndg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDU3Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n          \n          \n            \n                    connection = new URL(urlStr).openConnection();", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494760573", "createdAt": "2020-09-25T05:47:48Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0OTI3MA==", "bodyText": "check the doc, have to use this style:\nconnection = (HttpsURLConnection) new URL(urlStr).openConnection();\nand\nconnection = (HttpURLConnection) new URL(urlStr).openConnection();", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495249270", "createdAt": "2020-09-25T21:35:14Z", "author": {"login": "wangzlei"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDU3Mw=="}, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NjYxMjEzOnYy", "diffSide": "RIGHT", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTo0Nzo1NFrOHX1ynw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTo0Nzo1NFrOHX1ynw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDYwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    connection = (HttpURLConnection) new URL(urlStr).openConnection();\n          \n          \n            \n                    connection = new URL(urlStr).openConnection();", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494760607", "createdAt": "2020-09-25T05:47:54Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NjYxMjQ4OnYy", "diffSide": "RIGHT", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTo0ODowN1rOHX1y2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMTozNTozOVrOHYTo_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDY2Ng==", "bodyText": "Check the urlStr is https before", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494760666", "createdAt": "2020-09-25T05:48:07Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0OTY2MQ==", "bodyText": "fix in next commit", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495249661", "createdAt": "2020-09-25T21:35:39Z", "author": {"login": "wangzlei"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MDY2Ng=="}, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NjYxODMzOnYy", "diffSide": "RIGHT", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTo1MDo0N1rOHX11_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMTozNzoxNVrOHYTt8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MTQ3MA==", "bodyText": "Can clean up a bit I think\nFile caFile = new File(caFilePath); // Oh by the way, let's rename this variable from keystorePath :)\nif (!caFile.exists()) {\n  return null;\n}\n\ntry (InputStream certStream = new FileInputStream(caFile)) {\n  KeyStore trustStore = KeyStore.getInstance()\n  ...\n\n  return trustStore;\n} catch ()\n// No need for finally :)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494761470", "createdAt": "2020-09-25T05:50:47Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      if (requestPropertyMap != null) {\n+        for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+          connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+        }\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.WARNING,\n+            String.format(\n+                \"Error reponse from %s code (%s) text %s\",\n+                urlStr, responseCode, readResponseString(connection)));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Restful Client fetch string failed: %s\", e));\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      throw new IllegalStateException(\"UTF-8 not supported can't happen.\", e);\n+    }\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(String keystorePath) {\n+    try {\n+      KeyStore keyStore = getK8sKeystore(keystorePath);\n+\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception: %s\", e);\n+    }\n+    return null;\n+  }\n+\n+  String getK8sCredHeader(String tokenFilePath) {\n+    try {\n+      File file = new File(tokenFilePath);\n+      String content = Files.asCharSource(file, Charsets.UTF_8).read();\n+      return String.format(\"Bearer %s\", content);\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Unable to load K8s client token: %s\", e));\n+    }\n+    return \"\";\n+  }\n+\n+  private static KeyStore getK8sKeystore(String keyStorePath) {\n+    InputStream certificateFile = null;\n+    try {\n+      KeyStore trustStore = null;\n+      File caFile = new File(keyStorePath);\n+\n+      if (caFile.exists()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI1MDkyOQ==", "bodyText": "ok", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495250929", "createdAt": "2020-09-25T21:37:15Z", "author": {"login": "wangzlei"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      if (requestPropertyMap != null) {\n+        for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+          connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+        }\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.WARNING,\n+            String.format(\n+                \"Error reponse from %s code (%s) text %s\",\n+                urlStr, responseCode, readResponseString(connection)));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Restful Client fetch string failed: %s\", e));\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      throw new IllegalStateException(\"UTF-8 not supported can't happen.\", e);\n+    }\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(String keystorePath) {\n+    try {\n+      KeyStore keyStore = getK8sKeystore(keystorePath);\n+\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception: %s\", e);\n+    }\n+    return null;\n+  }\n+\n+  String getK8sCredHeader(String tokenFilePath) {\n+    try {\n+      File file = new File(tokenFilePath);\n+      String content = Files.asCharSource(file, Charsets.UTF_8).read();\n+      return String.format(\"Bearer %s\", content);\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Unable to load K8s client token: %s\", e));\n+    }\n+    return \"\";\n+  }\n+\n+  private static KeyStore getK8sKeystore(String keyStorePath) {\n+    InputStream certificateFile = null;\n+    try {\n+      KeyStore trustStore = null;\n+      File caFile = new File(keyStorePath);\n+\n+      if (caFile.exists()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MTQ3MA=="}, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NjYxOTIwOnYy", "diffSide": "RIGHT", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTo1MToxMlrOHX12cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTo1MToxMlrOHX12cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MTU4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      throw new IllegalArgumentException(\"K8s cert file contained no certificates.\");\n          \n          \n            \n                      return null;", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494761584", "createdAt": "2020-09-25T05:51:12Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      if (requestPropertyMap != null) {\n+        for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+          connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+        }\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.WARNING,\n+            String.format(\n+                \"Error reponse from %s code (%s) text %s\",\n+                urlStr, responseCode, readResponseString(connection)));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Restful Client fetch string failed: %s\", e));\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      throw new IllegalStateException(\"UTF-8 not supported can't happen.\", e);\n+    }\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(String keystorePath) {\n+    try {\n+      KeyStore keyStore = getK8sKeystore(keystorePath);\n+\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception: %s\", e);\n+    }\n+    return null;\n+  }\n+\n+  String getK8sCredHeader(String tokenFilePath) {\n+    try {\n+      File file = new File(tokenFilePath);\n+      String content = Files.asCharSource(file, Charsets.UTF_8).read();\n+      return String.format(\"Bearer %s\", content);\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, String.format(\"Unable to load K8s client token: %s\", e));\n+    }\n+    return \"\";\n+  }\n+\n+  private static KeyStore getK8sKeystore(String keyStorePath) {\n+    InputStream certificateFile = null;\n+    try {\n+      KeyStore trustStore = null;\n+      File caFile = new File(keyStorePath);\n+\n+      if (caFile.exists()) {\n+        trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+        trustStore.load(null, null);\n+        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\");\n+\n+        certificateFile = new FileInputStream(caFile);\n+        Collection<? extends Certificate> certificates =\n+            certificateFactory.generateCertificates(certificateFile);\n+\n+        if (certificates.isEmpty()) {\n+          throw new IllegalArgumentException(\"K8s cert file contained no certificates.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NjYyMjA0OnYy", "diffSide": "RIGHT", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTo1Mjo0MFrOHX14Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTo1Mjo0MFrOHX14Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MjAxMA==", "bodyText": "I switched the logging to FINE recently - since resource attributes are still a nice-to-have and not must, we should only log for debug logging and not as warnings.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494762010", "createdAt": "2020-09-25T05:52:40Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClient.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.base.Strings;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class RestfulClient {\n+\n+  private static final Logger logger = Logger.getLogger(RestfulClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (Strings.isNullOrEmpty(keyStorePath)) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      } else {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStorePath));\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      if (requestPropertyMap != null) {\n+        for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+          connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+        }\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.WARNING,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NjYyNTg3OnYy", "diffSide": "RIGHT", "path": "sdk_extensions/aws_v1_support/src/test/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClientTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTo1NDo1MlrOHX16XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTo1NDo1MlrOHX16XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc2MjU4OA==", "bodyText": "Offline you mentioned trouble testing HTTPS. Yeah it looks like wiremock only supports Java keystore, but not a certificate file. Armeria's mock server supports certificate files well so we'll probably switch to it, for now can leave a TODO", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r494762588", "createdAt": "2020-09-25T05:54:52Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/test/java/io/opentelemetry/sdk/extensions/trace/aws/resource/RestfulClientTest.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.any;\n+import static com.github.tomakehurst.wiremock.client.WireMock.equalTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.getRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.ok;\n+import static com.github.tomakehurst.wiremock.client.WireMock.stubFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlPathEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static com.github.tomakehurst.wiremock.core.WireMockConfiguration.wireMockConfig;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.github.tomakehurst.wiremock.junit.WireMockClassRule;\n+import com.google.common.collect.ImmutableMap;\n+import java.io.IOException;\n+import java.util.Map;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+public class RestfulClientTest {\n+\n+  @ClassRule\n+  public static WireMockClassRule server = new WireMockClassRule(wireMockConfig().dynamicPort());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bdb6814459e66168b7d4a8c265f05bc3b43d18e"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMDYxOTMxOnYy", "diffSide": "RIGHT", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMjo0MzoxOFrOHYcdbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwNDozMDozNlrOHYdouw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM5NDE1Ng==", "bodyText": "Ah sorry in that case let cast to HttpUrlConnection here - the variable is that type so it's weird using a different one when casting.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495394156", "createdAt": "2020-09-26T02:43:18Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class JdkHttpClient {\n+\n+  private static final Logger logger = Logger.getLogger(JdkHttpClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (urlStr.startsWith(\"https\")) {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e369a2a52dfff991f4899d5425257147965d60ec"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxMzQzNQ==", "bodyText": "yeah, here can also be HttpURLConnection", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495413435", "createdAt": "2020-09-26T04:30:36Z", "author": {"login": "wangzlei"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class JdkHttpClient {\n+\n+  private static final Logger logger = Logger.getLogger(JdkHttpClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (urlStr.startsWith(\"https\")) {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM5NDE1Ng=="}, "originalCommit": {"oid": "e369a2a52dfff991f4899d5425257147965d60ec"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMDYyMjMzOnYy", "diffSide": "RIGHT", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMjo0NDozMFrOHYcfZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMjo0NDozMFrOHYcfZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM5NDY2MQ==", "bodyText": "Here also FINE, I think this is the block that's hit when the server doesn't exist at all (matters more when we switch Ec2Resource to this new class)", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495394661", "createdAt": "2020-09-26T02:44:30Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class JdkHttpClient {\n+\n+  private static final Logger logger = Logger.getLogger(JdkHttpClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (urlStr.startsWith(\"https\")) {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        KeyStore keyStore = getK8sKeystore(keyStorePath);\n+        if (keyStore != null) {\n+          ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStore));\n+        }\n+      } else {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+        connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.FINE,\n+            \"Error reponse from \"\n+                + urlStr\n+                + \" code (\"\n+                + responseCode\n+                + \") text \"\n+                + readResponseString(connection));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, \"JdkHttpClient fetch string failed: \" + e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e369a2a52dfff991f4899d5425257147965d60ec"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMDYyNTg2OnYy", "diffSide": "RIGHT", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMjo0NTo1OVrOHYchpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMjo0NTo1OVrOHYchpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM5NTIzNg==", "bodyText": "Package private", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495395236", "createdAt": "2020-09-26T02:45:59Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class JdkHttpClient {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e369a2a52dfff991f4899d5425257147965d60ec"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMDYyODU1OnYy", "diffSide": "RIGHT", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMjo0NzowNVrOHYcjhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwNDozODoyNFrOHYdqxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM5NTcxNw==", "bodyText": "Move this into EksResource it's k8s specific", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495395717", "createdAt": "2020-09-26T02:47:05Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class JdkHttpClient {\n+\n+  private static final Logger logger = Logger.getLogger(JdkHttpClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (urlStr.startsWith(\"https\")) {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        KeyStore keyStore = getK8sKeystore(keyStorePath);\n+        if (keyStore != null) {\n+          ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStore));\n+        }\n+      } else {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+        connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.FINE,\n+            \"Error reponse from \"\n+                + urlStr\n+                + \" code (\"\n+                + responseCode\n+                + \") text \"\n+                + readResponseString(connection));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, \"JdkHttpClient fetch string failed: \" + e);\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      logger.log(Level.WARNING, \"UTF-8 not supported can't happen. \" + e);\n+    }\n+    return \"\";\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(KeyStore keyStore) {\n+    try {\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception: \" + e);\n+    }\n+    return null;\n+  }\n+\n+  String getK8sCredHeader(String tokenFilePath) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e369a2a52dfff991f4899d5425257147965d60ec"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxMzk1OQ==", "bodyText": "move method to EksResource", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495413959", "createdAt": "2020-09-26T04:38:24Z", "author": {"login": "wangzlei"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class JdkHttpClient {\n+\n+  private static final Logger logger = Logger.getLogger(JdkHttpClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (urlStr.startsWith(\"https\")) {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        KeyStore keyStore = getK8sKeystore(keyStorePath);\n+        if (keyStore != null) {\n+          ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStore));\n+        }\n+      } else {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+        connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.FINE,\n+            \"Error reponse from \"\n+                + urlStr\n+                + \" code (\"\n+                + responseCode\n+                + \") text \"\n+                + readResponseString(connection));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, \"JdkHttpClient fetch string failed: \" + e);\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      logger.log(Level.WARNING, \"UTF-8 not supported can't happen. \" + e);\n+    }\n+    return \"\";\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(KeyStore keyStore) {\n+    try {\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception: \" + e);\n+    }\n+    return null;\n+  }\n+\n+  String getK8sCredHeader(String tokenFilePath) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM5NTcxNw=="}, "originalCommit": {"oid": "e369a2a52dfff991f4899d5425257147965d60ec"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMDYzMDgyOnYy", "diffSide": "RIGHT", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMjo0ODoxMFrOHYck9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwNDozODowNFrOHYdquA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM5NjA4Nw==", "bodyText": "Rename to not be k8s since it's just about client TLS trusted cert.\ngetKeystoreForTrustedCert(String certPath) for example", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495396087", "createdAt": "2020-09-26T02:48:10Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class JdkHttpClient {\n+\n+  private static final Logger logger = Logger.getLogger(JdkHttpClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (urlStr.startsWith(\"https\")) {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        KeyStore keyStore = getK8sKeystore(keyStorePath);\n+        if (keyStore != null) {\n+          ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStore));\n+        }\n+      } else {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+        connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.FINE,\n+            \"Error reponse from \"\n+                + urlStr\n+                + \" code (\"\n+                + responseCode\n+                + \") text \"\n+                + readResponseString(connection));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, \"JdkHttpClient fetch string failed: \" + e);\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      logger.log(Level.WARNING, \"UTF-8 not supported can't happen. \" + e);\n+    }\n+    return \"\";\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(KeyStore keyStore) {\n+    try {\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception: \" + e);\n+    }\n+    return null;\n+  }\n+\n+  String getK8sCredHeader(String tokenFilePath) {\n+    try {\n+      File file = new File(tokenFilePath);\n+      String content = Files.asCharSource(file, Charsets.UTF_8).read();\n+      return \"Bearer \" + content;\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, \"Unable to load K8s client token: \" + e);\n+    }\n+    return \"\";\n+  }\n+\n+  private static KeyStore getK8sKeystore(String keyStorePath) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e369a2a52dfff991f4899d5425257147965d60ec"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxMzk0NA==", "bodyText": "update code to generic getKeystoreForTrustedCert", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495413944", "createdAt": "2020-09-26T04:38:04Z", "author": {"login": "wangzlei"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.Files;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+public class JdkHttpClient {\n+\n+  private static final Logger logger = Logger.getLogger(JdkHttpClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod,\n+      String urlStr,\n+      Map<String, String> requestPropertyMap,\n+      String keyStorePath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (urlStr.startsWith(\"https\")) {\n+        connection = (HttpsURLConnection) new URL(urlStr).openConnection();\n+        KeyStore keyStore = getK8sKeystore(keyStorePath);\n+        if (keyStore != null) {\n+          ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStore));\n+        }\n+      } else {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+        connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.FINE,\n+            \"Error reponse from \"\n+                + urlStr\n+                + \" code (\"\n+                + responseCode\n+                + \") text \"\n+                + readResponseString(connection));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, \"JdkHttpClient fetch string failed: \" + e);\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      logger.log(Level.WARNING, \"UTF-8 not supported can't happen. \" + e);\n+    }\n+    return \"\";\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(KeyStore keyStore) {\n+    try {\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception: \" + e);\n+    }\n+    return null;\n+  }\n+\n+  String getK8sCredHeader(String tokenFilePath) {\n+    try {\n+      File file = new File(tokenFilePath);\n+      String content = Files.asCharSource(file, Charsets.UTF_8).read();\n+      return \"Bearer \" + content;\n+    } catch (IOException e) {\n+      logger.log(Level.WARNING, \"Unable to load K8s client token: \" + e);\n+    }\n+    return \"\";\n+  }\n+\n+  private static KeyStore getK8sKeystore(String keyStorePath) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM5NjA4Nw=="}, "originalCommit": {"oid": "e369a2a52dfff991f4899d5425257147965d60ec"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMDc4NzA1OnYy", "diffSide": "RIGHT", "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwNToyODoxOVrOHYd5vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yN1QwOTowMDo1NFrOHYl6VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxNzc5MA==", "bodyText": "Ah good catch - if we need index let's just use traditional for loop. for(int i = 0; I < ...", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495417790", "createdAt": "2020-09-26T05:28:19Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.io.ByteStreams;\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+class JdkHttpClient {\n+\n+  private static final Logger logger = Logger.getLogger(JdkHttpClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod, String urlStr, Map<String, String> requestPropertyMap, String certPath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (urlStr.startsWith(\"https\")) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+        KeyStore keyStore = getKeystoreForTrustedCert(certPath);\n+        if (keyStore != null) {\n+          ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStore));\n+        }\n+      } else {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+        connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.FINE,\n+            \"Error reponse from \"\n+                + urlStr\n+                + \" code (\"\n+                + responseCode\n+                + \") text \"\n+                + readResponseString(connection));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.FINE, \"JdkHttpClient fetch string failed.\", e);\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      logger.log(Level.WARNING, \"UTF-8 not supported can't happen.\", e);\n+    }\n+    return \"\";\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(KeyStore keyStore) {\n+    try {\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception.\", e);\n+    }\n+    return null;\n+  }\n+\n+  private static KeyStore getKeystoreForTrustedCert(String certPath) {\n+    try (FileInputStream fis = new FileInputStream(certPath)) {\n+      KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+      trustStore.load(null, null);\n+      CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\");\n+\n+      Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(fis);\n+\n+      int i = 0;\n+      for (Certificate certificate : certificates) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be35b8cb91f0c5170ad11ced929a64985c2fb22a"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQ5ODExMA==", "bodyText": "Collection does not support random access, have to convert it to Array. Here I also fell code looks ugly, if we have other way to name the cert in for loop, I would prefer not call Collection.toArray().", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495498110", "createdAt": "2020-09-26T21:37:17Z", "author": {"login": "wangzlei"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.io.ByteStreams;\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+class JdkHttpClient {\n+\n+  private static final Logger logger = Logger.getLogger(JdkHttpClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod, String urlStr, Map<String, String> requestPropertyMap, String certPath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (urlStr.startsWith(\"https\")) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+        KeyStore keyStore = getKeystoreForTrustedCert(certPath);\n+        if (keyStore != null) {\n+          ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStore));\n+        }\n+      } else {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+        connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.FINE,\n+            \"Error reponse from \"\n+                + urlStr\n+                + \" code (\"\n+                + responseCode\n+                + \") text \"\n+                + readResponseString(connection));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.FINE, \"JdkHttpClient fetch string failed.\", e);\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      logger.log(Level.WARNING, \"UTF-8 not supported can't happen.\", e);\n+    }\n+    return \"\";\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(KeyStore keyStore) {\n+    try {\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception.\", e);\n+    }\n+    return null;\n+  }\n+\n+  private static KeyStore getKeystoreForTrustedCert(String certPath) {\n+    try (FileInputStream fis = new FileInputStream(certPath)) {\n+      KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+      trustStore.load(null, null);\n+      CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\");\n+\n+      Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(fis);\n+\n+      int i = 0;\n+      for (Certificate certificate : certificates) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxNzc5MA=="}, "originalCommit": {"oid": "be35b8cb91f0c5170ad11ced929a64985c2fb22a"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU0OTAxMg==", "bodyText": "Ah was thinking collection has it as opposed to iterable. In that case no worries.", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1671#discussion_r495549012", "createdAt": "2020-09-27T09:00:54Z", "author": {"login": "anuraaga"}, "path": "sdk_extensions/aws_v1_support/src/main/java/io/opentelemetry/sdk/extensions/trace/aws/resource/JdkHttpClient.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.extensions.trace.aws.resource;\n+\n+import com.google.common.io.ByteStreams;\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+class JdkHttpClient {\n+\n+  private static final Logger logger = Logger.getLogger(JdkHttpClient.class.getName());\n+\n+  private static final int TIMEOUT_MILLIS = 2000;\n+\n+  String fetchString(\n+      String httpMethod, String urlStr, Map<String, String> requestPropertyMap, String certPath) {\n+    final HttpURLConnection connection;\n+\n+    try {\n+      if (urlStr.startsWith(\"https\")) {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+        KeyStore keyStore = getKeystoreForTrustedCert(certPath);\n+        if (keyStore != null) {\n+          ((HttpsURLConnection) connection).setSSLSocketFactory(buildSslSocketFactory(keyStore));\n+        }\n+      } else {\n+        connection = (HttpURLConnection) new URL(urlStr).openConnection();\n+      }\n+\n+      connection.setRequestMethod(httpMethod);\n+      connection.setConnectTimeout(TIMEOUT_MILLIS);\n+      connection.setReadTimeout(TIMEOUT_MILLIS);\n+\n+      for (Map.Entry<String, String> requestProperty : requestPropertyMap.entrySet()) {\n+        connection.setRequestProperty(requestProperty.getKey(), requestProperty.getValue());\n+      }\n+\n+      int responseCode = connection.getResponseCode();\n+      if (responseCode != 200) {\n+        logger.log(\n+            Level.FINE,\n+            \"Error reponse from \"\n+                + urlStr\n+                + \" code (\"\n+                + responseCode\n+                + \") text \"\n+                + readResponseString(connection));\n+        return \"\";\n+      }\n+\n+      return readResponseString(connection).trim();\n+\n+    } catch (IOException e) {\n+      logger.log(Level.FINE, \"JdkHttpClient fetch string failed.\", e);\n+    }\n+\n+    return \"\";\n+  }\n+\n+  private static String readResponseString(HttpURLConnection connection) {\n+    ByteArrayOutputStream os = new ByteArrayOutputStream();\n+    try (InputStream is = connection.getInputStream()) {\n+      ByteStreams.copy(is, os);\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try (InputStream is = connection.getErrorStream()) {\n+      if (is != null) {\n+        ByteStreams.copy(is, os);\n+      }\n+    } catch (IOException e) {\n+      // Only best effort read if we can.\n+    }\n+    try {\n+      return os.toString(StandardCharsets.UTF_8.name());\n+    } catch (UnsupportedEncodingException e) {\n+      logger.log(Level.WARNING, \"UTF-8 not supported can't happen.\", e);\n+    }\n+    return \"\";\n+  }\n+\n+  private static SSLSocketFactory buildSslSocketFactory(KeyStore keyStore) {\n+    try {\n+      String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\n+      TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);\n+      tmf.init(keyStore);\n+\n+      SSLContext context = SSLContext.getInstance(\"TLS\");\n+      context.init(null, tmf.getTrustManagers(), null);\n+      return context.getSocketFactory();\n+\n+    } catch (Exception e) {\n+      logger.log(Level.WARNING, \"Build SslSocketFactory for K8s restful client exception.\", e);\n+    }\n+    return null;\n+  }\n+\n+  private static KeyStore getKeystoreForTrustedCert(String certPath) {\n+    try (FileInputStream fis = new FileInputStream(certPath)) {\n+      KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+      trustStore.load(null, null);\n+      CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\");\n+\n+      Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(fis);\n+\n+      int i = 0;\n+      for (Certificate certificate : certificates) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxNzc5MA=="}, "originalCommit": {"oid": "be35b8cb91f0c5170ad11ced929a64985c2fb22a"}, "originalPosition": 138}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1200, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}